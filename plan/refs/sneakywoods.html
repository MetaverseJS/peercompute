<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P 3D Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 16px;
            text-shadow: 1px 1px 1px black;
            pointer-events: none;
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
        }
        #score {
            margin-bottom: 10px;
        }
        #players {
            margin-top: 10px;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 14px;
            text-align: right;
            text-shadow: 1px 1px 1px black;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            pointer-events: none;
        }
        
        /* Mobile joystick styles */
        .joystick-container {
            position: absolute;
            bottom: 20px;
            width: 120px;
            height: 120px;
            z-index: 20;
            pointer-events: none;
            display: none;
        }

        @media (max-width: 768px) and (pointer: coarse) {
            .joystick-container {
                display: block;
            }
            #attack-button {
                display: block;
            }
        }

        #left-joystick {
            left: calc(25% - 60px);
        }

        #right-joystick {
            right: calc(25% - 60px);
        }

        .joystick {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(128, 128, 128, 0.3);
            border-radius: 50%;
            pointer-events: auto;
            touch-action: none;
        }

        .joystick-knob {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            transition: left 0.1s ease-out, top 0.1s ease-out;
        }
        
        /* Attack button styles */
        #attack-button {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 80px;
            background: rgba(255, 0, 0, 0.5);
            border-radius: 50%;
            display: none;
            z-index: 20;
            border: none;
            color: white;
            font-weight: bold;
            font-size: 16px;
            text-align: center;
            pointer-events: auto;
            touch-action: manipulation;
        }
    </style>
</head>
<body>
        <div id="hud">
        <div id="score">Score: 0</div>
        <div id="highscore">High Score: 0</div>
        <div id="position">Position: 0, 0, 0</div>
        <div id="players">Players: 1</div>
    </div>
    
    <div id="controls">
        <div>WASD: Move</div>
        <div>Mouse/Arrows: Look</div>
        <div>Space/Click: Attack</div>
        <div>Movement has momentum</div>
    </div>
    <div style="position:absolute;top:10px;left:50%;transform:translateX(-50%);z-index:20;display:flex;gap:8px;">
      <input id="nameInput" placeholder="Name" style="padding:6px 10px;border-radius:6px;border:1px solid #444;background:#111;color:#fff;outline:none;">
      <button id="nameBtn" style="padding:6px 12px;border-radius:6px;border:1px solid #2563eb;background:#2563eb;color:#fff;cursor:pointer;">Update Name</button>
      <input id="colorPicker" type="color" value="#00ff00" style="padding:4px;width:48px;height:36px;border:1px solid #444;border-radius:6px;background:#111;cursor:pointer;">
    </div>
    
    <!-- Mobile joystick controls -->
    <div id="left-joystick" class="joystick-container">
        <div class="joystick">
            <div class="joystick-knob"></div>
        </div>
    </div>
    <div id="right-joystick" class="joystick-container">
        <div class="joystick">
            <div class="joystick-knob"></div>
        </div>
    </div>
    
    <!-- Attack button for mobile -->
    <button id="attack-button">ATTACK</button>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script defer src="/bundle.js"></script>
    <script>
        // Joystick class
        class Joystick {
            constructor(element) {
                this.element = element;
                this.knob = element.querySelector('.joystick-knob');
                this.touchId = null;
                this.deltaX = 0;
                this.deltaY = 0;
                this.maxDistance = 40;
                this.isActive = false;
                this.startX = 0;
                this.startY = 0;

                document.addEventListener('touchstart', this.onTouchStart.bind(this), {passive: false});
                document.addEventListener('touchmove', this.onTouchMove.bind(this), {passive: false});
                document.addEventListener('touchend', this.onTouchEnd.bind(this), {passive: false});
                document.addEventListener('touchcancel', this.onTouchEnd.bind(this), {passive: false});
            }

            onTouchStart(e) {
                if (this.touchId !== null) return;

                for (let touch of e.changedTouches) {
                    const rect = this.element.getBoundingClientRect();
                    const touchX = touch.clientX - rect.left;
                    const touchY = touch.clientY - rect.top;

                    if (touchX >= 0 && touchX <= rect.width && touchY >= 0 && touchY <= rect.height) {
                        e.preventDefault();
                        this.touchId = touch.identifier;
                        this.isActive = true;
                        this.startX = touchX;
                        this.startY = touchY;
                        this.updatePosition(touch);
                        break;
                    }
                }
            }

            onTouchMove(e) {
                if (this.touchId === null) return;

                for (let touch of e.touches) {
                    if (touch.identifier === this.touchId) {
                        e.preventDefault();
                        this.updatePosition(touch);
                        break;
                    }
                }
            }

            onTouchEnd(e) {
                for (let touch of e.changedTouches) {
                    if (touch.identifier === this.touchId) {
                        e.preventDefault();
                        this.touchId = null;
                        this.isActive = false;
                        this.deltaX = 0;
                        this.deltaY = 0;
                        this.knob.style.left = '50%';
                        this.knob.style.top = '50%';
                        break;
                    }
                }
            }

            updatePosition(touch) {
                const rect = this.element.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;

                const currentX = touch.clientX - rect.left;
                const currentY = touch.clientY - rect.top;
                let x = currentX - this.startX;
                let y = currentY - this.startY;

                const distance = Math.sqrt(x * x + y * y);
                if (distance > this.maxDistance) {
                    const angle = Math.atan2(y, x);
                    x = Math.cos(angle) * this.maxDistance;
                    y = Math.sin(angle) * this.maxDistance;
                }

                this.deltaX = x / this.maxDistance;
                this.deltaY = y / this.maxDistance;

                this.knob.style.left = `${centerX + x}px`;
                this.knob.style.top = `${centerY + y}px`;
            }

            getValues() {
                return {
                    x: this.isActive ? this.deltaX : 0,
                    y: this.isActive ? this.deltaY : 0
                };
            }
        }
        
        // Game constants
        const PLAYER_SIZE = 1;
        const GRID_CELL_SIZE = 20;
        const MIN_OBSTACLE_SIZE = 1;
        const MAX_OBSTACLE_SIZE = 10;
        const OBSTACLE_DENSITY = 0.2;
        const MAX_SPEED = 0.2;          // Maximum movement speed
        const ACCELERATION = 0.05;      // Acceleration rate
        const FRICTION = 0.95;          // Friction coefficient (0-1, lower = more friction)
        const MOVEMENT_SPEED = 0.1;     // For peer movement
        const TURN_SPEED = 0.02;
        const ATTACK_SIZE = 1;
        const ATTACK_DISTANCE = 1.5;
        const ATTACK_DURATION = 500;
        const CAMERA_DISTANCE = 5;
        const VIEW_DISTANCE = 5;
        
        // Game state
        let score = 0;
        let playerPosition = new THREE.Vector3(0, PLAYER_SIZE / 2, 0);
        let playerRotation = 0;
        let playerVelocity = new THREE.Vector3(0, 0, 0);  // Current movement velocity
        let canAttack = true;
        let attackSphere = null;
        let attackTimeout = null;
        let spotlightActive = false;
        
        // Input state
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            arrowup: false,
            arrowdown: false,
            arrowleft: false,
            arrowright: false,
            space: false
        };
        const mouse = { x: 0, y: 0, pressed: false };
        
        // Initialize joysticks
        let leftJoystick, rightJoystick;
        const isMobile = 'ontouchstart' in window && window.matchMedia("(max-width: 768px)").matches;
        
        // Networking / state
        let myPeerId = null;
        let myName = `Player-${Math.floor(Math.random() * 999)}`;
        let myColor = 0x00ff00;
        let peers = new Map();
        let peerMeshes = new Map();
        const seenAttacks = new Map(); // attackerId -> lastTs
        const gameNamespace = 'sneakywoods';
        let node = null;
        let stateManager = null;
        let playerLabel = null;
        const log = (...args) => console.log('[sneakywoods]', ...args);
        let backgroundHeartbeat = null;
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, PLAYER_SIZE * 1.6, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.gammaOutput = true;
        renderer.gammaFactor = 2.2;
        renderer.physicallyCorrectLights = true;
        document.body.appendChild(renderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x111111, 0.2);
        scene.add(ambientLight);
        
        // Player spotlight
        const playerSpotlight = new THREE.SpotLight(0xffffff, 25, 75, Math.PI / 6, 0.3, 1);
        playerSpotlight.position.set(0, 8, 0);
        playerSpotlight.castShadow = true;
        playerSpotlight.shadow.mapSize.width = 1024;
        playerSpotlight.shadow.mapSize.height = 1024;
        playerSpotlight.shadow.camera.near = 0.5;
        playerSpotlight.shadow.camera.far = 100;
        playerSpotlight.shadow.bias = -0.0001;
        playerSpotlight.visible = false;
        scene.add(playerSpotlight);
        
        // Helper for spotlight target
        const spotlightTarget = new THREE.Object3D();
        scene.add(spotlightTarget);
        playerSpotlight.target = spotlightTarget;
        
        // Player representation
        const playerGeometry = new THREE.BoxGeometry(PLAYER_SIZE, PLAYER_SIZE, PLAYER_SIZE);
        const playerMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x00ff00, 
            emissive: 0x003300,
            shininess: 30,
            specular: 0xffffff
        });
        const playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
        playerMesh.castShadow = true;
        playerMesh.receiveShadow = true;
        applyMeshColor(playerMesh, myColor);
        scene.add(playerMesh);
        
        // Attack cube setup
        const attackGeometry = new THREE.BoxGeometry(ATTACK_SIZE, ATTACK_SIZE, ATTACK_SIZE);
        const attackMaterial = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            transparent: true,
            opacity: 0.8,
            wireframe: true
        });
        
        // Fog for atmospheric effect
        scene.fog = new THREE.FogExp2(0x000000, 0.01);
        
        // Grid setup
        const grid = new Map();
        const gridObjects = new Map();
        // Color helper
        function applyMeshColor(mesh, hex) {
            if (!mesh || !mesh.material) return;
            mesh.material.color.setHex(hex);
            mesh.material.emissive.setHex(hex);
            mesh.material.emissiveIntensity = 0.25;
        }

        // Simple seeded RNG for world determinism (mulberry32)
        function mulberry32(seed) {
            return function() {
                seed |= 0; seed = seed + 0x6D2B79F5 | 0;
                let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
                t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            };
        }
        const WORLD_SEED = 1337;
        const rngForCell = (x, z) => mulberry32((WORLD_SEED ^ (x * 73856093) ^ (z * 19349663)) >>> 0);

        // Helper to create a simple text sprite for names
        function createNameLabel(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const fontSize = 28;
            const padding = 10;
            ctx.font = `${fontSize}px Arial`;
            const metrics = ctx.measureText(text);
            canvas.width = metrics.width + padding * 2;
            canvas.height = fontSize + padding * 2;
            ctx.font = `${fontSize}px Arial`;
            ctx.fillStyle = 'white';
            ctx.textBaseline = 'middle';
            ctx.textAlign = 'center';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true, depthWrite: false });
            const sprite = new THREE.Sprite(material);
            const scale = 0.012;
            sprite.scale.set(canvas.width * scale, canvas.height * scale, 1);
            sprite.userData = { text };
            return sprite;
        }
        
        // Get a random environment object (tree or building)
        function getRandomEnvironmentObject(size, rng) {
            const rand = rng || Math.random;
            const objectType = rand() > 0.9 ? 'building' : 'tree';
            
            if (objectType === 'tree') {
                // Tree (cone with green color)
                const height = size * 2;
                const radius = size / 2;
                const geometry = new THREE.ConeGeometry(radius, height, 8);
                const material = new THREE.MeshPhongMaterial({
                    color: 0x228B22,
                    shininess: 5,
                    specular: 0x333333
                });
                const tree = new THREE.Mesh(geometry, material);
                tree.position.y = height / 2;
                return { mesh: tree, type: 'tree' };
            } else {
                // Building (rectangular box)
                const width = size * 2;
                const height = size * (2 + rand() * 3);
                const depth = size * 2;
                const geometry = new THREE.BoxGeometry(width, height, depth);
                
                const colors = [0x808080, 0xA9A9A9, 0x8B4513, 0xD2B48C, 0x696969];
                const color = colors[Math.floor(rand() * colors.length)];
                
                const material = new THREE.MeshPhongMaterial({
                    color: color,
                    shininess: 30,
                    specular: 0x555555
                });
                const building = new THREE.Mesh(geometry, material);
                building.position.y = height / 2;
                return { mesh: building, type: 'building' };
            }
        }
        
        // Add an environment object (tree or building)
        function addEnvironmentObject(x, z, rng) {
            const rand = rng || Math.random;
            const size = MIN_OBSTACLE_SIZE + rand() * (MAX_OBSTACLE_SIZE - MIN_OBSTACLE_SIZE);
            const { mesh, type } = getRandomEnvironmentObject(size, rand);
            
            mesh.position.x = x;
            mesh.position.z = z;
            
            if (type === 'tree') {
                mesh.rotation.y = rand() * Math.PI * 2;
            }
            
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            scene.add(mesh);
            
            const boundingBox = new THREE.Box3().setFromObject(mesh);
            gridObjects.set(mesh.id, {
                mesh: mesh,
                boundingBox: boundingBox,
                type: type
            });
            
            return mesh;
        }
        
        // Generate a grid cell
        function generateGridCell(x, z) {
            const cellRng = rngForCell(x, z);
            const cellKey = `${x},${z}`;
            if (grid.has(cellKey)) return;
            
            grid.set(cellKey, true);
            
            const floorGeometry = new THREE.PlaneGeometry(GRID_CELL_SIZE, GRID_CELL_SIZE);
            const floorMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFFFFF,
                side: THREE.DoubleSide,
                shininess: 10,
                reflectivity: 0.5
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = Math.PI / 2;
            floor.position.set(
                x * GRID_CELL_SIZE + GRID_CELL_SIZE / 2,
                0,
                z * GRID_CELL_SIZE + GRID_CELL_SIZE / 2
            );
            floor.receiveShadow = true;
            scene.add(floor);
            
            const obstacleCount = Math.floor(cellRng() * 2) + 1;
            for (let i = 0; i < obstacleCount; i++) {
                addEnvironmentObject(
                    x * GRID_CELL_SIZE + cellRng() * GRID_CELL_SIZE,
                    z * GRID_CELL_SIZE + cellRng() * GRID_CELL_SIZE,
                    cellRng
                );
            }
        }
        
        // Initialize the grid around the origin
        function initializeGrid() {
            for (let x = -VIEW_DISTANCE; x <= VIEW_DISTANCE; x++) {
                for (let z = -VIEW_DISTANCE; z <= VIEW_DISTANCE; z++) {
                    generateGridCell(x, z);
                }
            }
        }
        
        // Update grid based on player position
        function updateGrid() {
            const gridX = Math.floor(playerPosition.x / GRID_CELL_SIZE);
            const gridZ = Math.floor(playerPosition.z / GRID_CELL_SIZE);
            
            for (let x = gridX - VIEW_DISTANCE; x <= gridX + VIEW_DISTANCE; x++) {
                for (let z = gridZ - VIEW_DISTANCE; z <= gridZ + VIEW_DISTANCE; z++) {
                    generateGridCell(x, z);
                }
            }
        }
        
        // Check collision between player and obstacles
        function checkCollisions(position) {
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                position,
                new THREE.Vector3(PLAYER_SIZE, PLAYER_SIZE, PLAYER_SIZE)
            );
            
            for (const [id, obj] of gridObjects.entries()) {
                if (obj.type === 'building' && playerBox.intersectsBox(obj.boundingBox)) {
                    return true;
                }
            }
            
            return false;
        }
        
        function pickSpawnPosition() {
            const anchors = [
                ...Array.from(peers.values()).map(p => p.position),
            ];
            // include current player position as anchor if already set
            if (playerPosition) anchors.push(playerPosition.clone());
            const anchor = anchors.length ? anchors[Math.floor(Math.random() * anchors.length)] : null;
            const angle = Math.random() * Math.PI * 2;
            const distance = 3 * GRID_CELL_SIZE;
            const pos = anchor ? anchor.clone() : new THREE.Vector3(0, PLAYER_SIZE / 2, 0);
            pos.x += Math.cos(angle) * distance;
            pos.z += Math.sin(angle) * distance;
            pos.y = PLAYER_SIZE / 2;
            let attempts = 0;
            const maxAttempts = 20;
            while (checkCollisions(pos) && attempts < maxAttempts) {
                const newAngle = angle + (Math.PI / 4) * attempts;
                pos.x = (anchor ? anchor.x : 0) + Math.cos(newAngle) * distance;
                pos.z = (anchor ? anchor.z : 0) + Math.sin(newAngle) * distance;
                attempts++;
            }
            return pos;
        }

        // Respawn on periphery near others
        function respawnOnPeriphery() {
            const pos = pickSpawnPosition();
            playerPosition.copy(pos);
            updateGrid();
        }
        
        // Handle player attack
        function attack() {
            if (!canAttack) return;
            
            const direction = new THREE.Vector3(0, 0, -1)
                .applyAxisAngle(new THREE.Vector3(0, 1, 0), playerRotation)
                .normalize();
                
            const attackPosition = new THREE.Vector3()
                .copy(playerPosition)
                .add(direction.multiplyScalar(ATTACK_DISTANCE));
                
            attackSphere = new THREE.Mesh(attackGeometry, attackMaterial);
            attackSphere.position.copy(attackPosition);
            attackSphere.rotation.y = playerRotation;
            scene.add(attackSphere);
            
            playerSpotlight.visible = true;
            
            canAttack = false;
            
            broadcastAttack(attackPosition);
            
            const hitSomeone = checkAttackHits(attackPosition);
            
            if (hitSomeone) {
                console.log("You hit someone! Score increased to", score);
            }
            
            attackTimeout = setTimeout(() => {
                scene.remove(attackSphere);
                attackSphere = null;
                canAttack = true;
                
                if (!keys.w && !keys.a && !keys.s && !keys.d && 
                    !keys.arrowleft && !keys.arrowright && 
                    !keys.space && !mouse.pressed) {
                    playerSpotlight.visible = false;
                }
            }, ATTACK_DURATION);
        }
        
            // Check if attack hits other players
            function checkAttackHits(attackPosition) {
                const attackBox = new THREE.Box3().setFromCenterAndSize(
                    attackPosition,
                    new THREE.Vector3(ATTACK_SIZE, ATTACK_SIZE, ATTACK_SIZE)
                );
                
                let hitSomeone = false;
                
                for (const [peerId, peerData] of peers.entries()) {
                    const peerBox = new THREE.Box3().setFromCenterAndSize(
                        peerData.position,
                        new THREE.Vector3(PLAYER_SIZE, PLAYER_SIZE, PLAYER_SIZE)
                    );
                    
                    if (attackBox.intersectsBox(peerBox)) {
                        hitSomeone = true;
                        score++;
                        updateHUD();
                        publishPlayerState();
                        
                        const peerMesh = peerMeshes.get(peerId);
                        if (peerMesh) {
                            const originalColor = peerMesh.material.color.clone();
                            peerMesh.material.color.set(0xff0000);
                        
                        setTimeout(() => {
                            peerMesh.material.color.copy(originalColor);
                        }, 500);
                    }
                    
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 3 * GRID_CELL_SIZE;
                    peerData.position.set(
                        Math.cos(angle) * distance,
                        PLAYER_SIZE / 2,
                        Math.sin(angle) * distance
                    );
                    if (peerMesh) {
                        peerMesh.position.copy(peerData.position);
                    }
                    
                    // Broadcast hits could be added via state/event channel
                }
            }
            
            return hitSomeone;
        }
        
        // Update HUD
        function updateHUD() {
            document.getElementById('score').textContent = `Score: ${score}`;
            const allScores = [
                { name: myName, score },
                ...Array.from(peers.entries()).map(([id, p]) => ({ name: p.name || id, score: p.score || 0 }))
            ];
            const leader = allScores.reduce((best, cur) => cur.score > (best?.score ?? -Infinity) ? cur : best, null);
            document.getElementById('highscore').textContent = leader ? `High Score: ${leader.score} (${leader.name})` : 'High Score: 0';
            document.getElementById('position').textContent = `Position: ${playerPosition.x.toFixed(1)}, ${playerPosition.y.toFixed(1)}, ${playerPosition.z.toFixed(1)}`;
            const names = [myName, ...Array.from(peers.values()).map(p => p.name)].filter(Boolean);
            document.getElementById('players').textContent = `Players: ${peers.size + 1} | Speed: ${playerVelocity.length().toFixed(2)} | ${names.join(', ')}`;
        }
        
        // Input handling
        document.addEventListener('keydown', (event) => {
            const key = event.key.toLowerCase();
            if (key in keys) {
                keys[key] = true;
            }
        });
        
        document.addEventListener('keyup', (event) => {
            const key = event.key.toLowerCase();
            if (key in keys) {
                keys[key] = false;
            }
        });
        
        document.addEventListener('mousemove', (event) => {
            if (document.pointerLockElement === renderer.domElement) {
                playerRotation -= event.movementX * 0.002;
            }
        });
        
        document.addEventListener('mousedown', (event) => {
            if (event.button === 0) {
                mouse.pressed = true;
                attack();
            }
        });
        
        document.addEventListener('mouseup', (event) => {
            if (event.button === 0) {
                mouse.pressed = false;
            }
        });
        
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space' && canAttack) {
                attack();
            }
        });
        
        renderer.domElement.addEventListener('click', () => {
            renderer.domElement.requestPointerLock();
        });
        
        // Add attack button event listeners for mobile
        const attackButton = document.getElementById('attack-button');
        attackButton.addEventListener('touchstart', function(e) {
            e.preventDefault();
            attack();
        });

        // Name entry / updates
        const nameInput = document.getElementById('nameInput');
        const nameBtn = document.getElementById('nameBtn');
        const colorPicker = document.getElementById('colorPicker');
        if (nameInput) {
            nameInput.value = myName;
        }
        if (colorPicker) {
            // Initialize from picker default
            const hex = colorPicker.value || '#00ff00';
            myColor = parseInt(hex.replace('#','0x'), 16);
            applyMeshColor(playerMesh, myColor);
        }
        function commitNameUpdate() {
            const next = nameInput?.value?.trim();
            if (!next) return;
            myName = next;
            publishPlayerState();
            updateHUD();
        }
        if (nameBtn) {
            nameBtn.addEventListener('click', commitNameUpdate);
        }
        if (nameInput) {
            nameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    commitNameUpdate();
                }
            });
        }
        if (colorPicker) {
            colorPicker.addEventListener('input', (e) => {
                const hex = e.target.value || '#00ff00';
                myColor = parseInt(hex.replace('#','0x'), 16);
                applyMeshColor(playerMesh, myColor);
                publishPlayerState();
            });
        }
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                startBackgroundHeartbeat();
            } else {
                stopBackgroundHeartbeat();
                publishPlayerState();
            }
        });
        
        // Game update loop
        function update() {
            // Skip heavy work when tab hidden; background heartbeat handles presence
            if (document.hidden) {
                requestAnimationFrame(update);
                return;
            }
            // Simple movement vector based on keys or joystick
            let direction = new THREE.Vector3(0, 0, 0);
            
            // Check for mobile joystick input
            if (isMobile && leftJoystick) {
                const leftValues = leftJoystick.getValues();
                if (Math.abs(leftValues.x) > 0.1 || Math.abs(leftValues.y) > 0.1) {
                    direction.z += leftValues.y; // Forward/backward (reversed)
                    direction.x += leftValues.x; // Left/right
                }
            } else {
                // Forward/backward with keyboard
                if (keys.w || keys.arrowup) {
                    direction.z -= 1;
                }
                if (keys.s || keys.arrowdown) {
                    direction.z += 1;
                }
                
                // Left/right with keyboard
                if (keys.a) {
                    direction.x -= 1;
                }
                if (keys.d) {
                    direction.x += 1;
                }
            }
            
            // Rotate direction by player's rotation
            if (direction.length() > 0) {
                direction.normalize();
                direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), playerRotation);
                
                // Apply acceleration in that direction
                playerVelocity.x += direction.x * ACCELERATION;
                playerVelocity.z += direction.z * ACCELERATION;
            }
            
            // Apply friction
            playerVelocity.multiplyScalar(FRICTION);
            
            // Limit max speed
            const speed = playerVelocity.length();
            if (speed > MAX_SPEED) {
                playerVelocity.normalize().multiplyScalar(MAX_SPEED);
            }
            
            // Stop if very slow
            if (speed < 0.001) {
                playerVelocity.set(0, 0, 0);
            }
            
            // Check for right joystick input for rotation on mobile
            if (isMobile && rightJoystick) {
                const rightValues = rightJoystick.getValues();
                if (Math.abs(rightValues.x) > 0.1) {
                    playerRotation -= rightValues.x * TURN_SPEED * 2; // More sensitive for mobile
                }
            } else {
                // Apply rotation from arrow keys
                if (keys.arrowleft) {
                    playerRotation += TURN_SPEED;
                }
                if (keys.arrowright) {
                    playerRotation -= TURN_SPEED;
                }
            }
            
            // Apply velocity to position
            if (playerVelocity.length() > 0) {
                const nextPosition = new THREE.Vector3(
                    playerPosition.x + playerVelocity.x,
                    playerPosition.y,
                    playerPosition.z + playerVelocity.z
                );
                
                if (!checkCollisions(nextPosition)) {
                    playerPosition.copy(nextPosition);
                } else {
                    // Collision - bounce effect
                    playerVelocity.multiplyScalar(-0.5);
                }
            }
            
            // Update player mesh and spotlight
            playerMesh.position.copy(playerPosition);
            playerMesh.rotation.y = playerRotation;
            
            playerSpotlight.position.copy(playerPosition);
            playerSpotlight.position.y += 8;
            
            const targetOffset = new THREE.Vector3(0, 0, -20);
            targetOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), playerRotation);
            spotlightTarget.position.copy(playerPosition).add(targetOffset);
            spotlightTarget.position.y = 0;
            
            spotlightTarget.updateMatrixWorld();
            playerSpotlight.target.updateMatrixWorld();
            
            // Update camera position for third-person view
            const cameraOffset = new THREE.Vector3(
                Math.sin(playerRotation) * CAMERA_DISTANCE,
                CAMERA_DISTANCE * 0.6,
                Math.cos(playerRotation) * CAMERA_DISTANCE
            );
            camera.position.copy(playerPosition).add(cameraOffset);
            camera.lookAt(playerPosition);
            
            // Update terrain
            updateGrid();
            
            // Update spotlight based on movement
            spotlightActive = keys.w || keys.a || keys.s || keys.d || 
                             keys.arrowleft || keys.arrowright || 
                             keys.space || mouse.pressed || 
                             playerVelocity.length() > 0.01;
            
            playerSpotlight.visible = spotlightActive;
            
            // Update UI
            updateHUD();
            
            // Update peer positions with smoothing
            for (const [peerId, mesh] of peerMeshes.entries()) {
                const peerData = peers.get(peerId);
                if (peerData) {
                    const renderPos = peerData.renderPosition || peerData.position.clone();
                    renderPos.lerp(peerData.position, 0.12);
                    mesh.position.copy(renderPos);
                    peerData.renderPosition = renderPos;

                    const targetRot = peerData.rotation;
                    const currentRot = peerData.renderRotation || targetRot;
                    const rotDiff = ((targetRot - currentRot + Math.PI) % (Math.PI * 2)) - Math.PI;
                    const newRot = currentRot + rotDiff * 0.15;
                    mesh.rotation.y = newRot;
                    peerData.renderRotation = newRot;
                }
            }
            
            // Render
            renderer.render(scene, camera);
            
            // Continue loop
            requestAnimationFrame(update);
        }
        
        // Window resize handling
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Update joystick positions on resize
            if (document.getElementById('left-joystick')) {
                document.getElementById('left-joystick').style.left = 'calc(25% - 60px)';
            }
            if (document.getElementById('right-joystick')) {
                document.getElementById('right-joystick').style.right = 'calc(25% - 60px)';
            }
        });
        
        // Add a peer
        function addPeer(peerId, colorOverride) {
            const position = pickSpawnPosition();
            
            peers.set(peerId, {
                position: position,
                rotation: Math.random() * Math.PI * 2,
                score: 0,
                name: `Peer-${peerId.slice(0,4)}`,
                lastSeen: Date.now(),
                lastPos: position.clone(),
                lastRot: 0,
                attackFlashUntil: 0,
                renderPosition: position.clone(),
                renderRotation: 0
            });
            
            const peerGeometry = new THREE.BoxGeometry(PLAYER_SIZE, PLAYER_SIZE, PLAYER_SIZE);
            const peerMaterial = new THREE.MeshPhongMaterial({ 
                color: colorOverride || 0x0000ff,
                emissive: 0x000033,
                shininess: 30,
                specular: 0xffffff
            });
            const peerMesh = new THREE.Mesh(peerGeometry, peerMaterial);
            peerMesh.position.copy(position);
            peerMesh.castShadow = true;
            peerMesh.receiveShadow = true;
            // Add a simple spotlight for visibility
            const spotTarget = new THREE.Object3D();
            scene.add(spotTarget);
            const spot = new THREE.SpotLight(0xffffff, 6, 60, Math.PI / 6, 0.35, 1);
            spot.position.set(0, 3, 0);
            spot.castShadow = true;
            spot.shadow.mapSize.width = 512;
            spot.shadow.mapSize.height = 512;
            spot.shadow.bias = -0.0005;
            spot.target = spotTarget;
            peerMesh.add(spot);
            peerMesh.userData.spot = spot;
            peerMesh.userData.spotTarget = spotTarget;
            spot.visible = false;
            scene.add(peerMesh);
            
            peerMeshes.set(peerId, peerMesh);
            
            updateHUD();
        }

        function removePeer(peerId) {
            const mesh = peerMeshes.get(peerId);
            if (mesh) {
                if (mesh.userData?.spotTarget) {
                    scene.remove(mesh.userData.spotTarget);
                }
                scene.remove(mesh);
                peerMeshes.delete(peerId);
            }
            peers.delete(peerId);
            updateHUD();
        }
        
        // Simulate peer movement (disabled; real peers only)
        function startPeerSimulation() {}
        
        // Simulate peer attack
        function simulatePeerAttack(peerId) {
            if (!peers.has(peerId)) return;
            
            const peerData = peers.get(peerId);
            const peerMesh = peerMeshes.get(peerId);
            
            const direction = new THREE.Vector3(0, 0, -1)
                .applyAxisAngle(new THREE.Vector3(0, 1, 0), peerData.rotation)
                .normalize();
                
            const attackPosition = new THREE.Vector3()
                .copy(peerData.position)
                .add(direction.multiplyScalar(ATTACK_DISTANCE));
            
            const attackGeometry = new THREE.BoxGeometry(ATTACK_SIZE, ATTACK_SIZE, ATTACK_SIZE);
            const attackMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.8,
                wireframe: true
            });
            const attackCube = new THREE.Mesh(attackGeometry, attackMaterial);
            attackCube.position.copy(attackPosition);
            attackCube.rotation.y = peerData.rotation;
            scene.add(attackCube);
            
            const spotlight = peerMesh.children.find(child => child instanceof THREE.SpotLight);
            if (spotlight) {
                spotlight.visible = true;
            }
            
            const attackBox = new THREE.Box3().setFromCenterAndSize(
                attackPosition,
                new THREE.Vector3(ATTACK_SIZE, ATTACK_SIZE, ATTACK_SIZE)
            );
            
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                playerPosition,
                new THREE.Vector3(PLAYER_SIZE, PLAYER_SIZE, PLAYER_SIZE)
            );
            
            if (attackBox.intersectsBox(playerBox)) {
                handlePlayerHit();
            }
            
            setTimeout(() => {
                scene.remove(attackCube);
                
                if (spotlight) {
                    setTimeout(() => {
                        spotlight.visible = false;
                    }, 300);
                }
            }, ATTACK_DURATION);
        }
        
        // Send message to a specific peer
        // P2P Communication Setup (PeerCompute)
        async function setupP2P() {
            try {
                const cfg = await fetch('/relay-config.json').then(r => r.ok ? r.json() : null).catch(() => null);
                const NodeKernel = window.NodeKernel;
                node = new NodeKernel({
                    bootstrapPeers: cfg?.bootstrapPeers || [],
                    enablePersistence: false,
                    gameId: 'sneakywoods',
                    roomId: 'global'
                });
                await node.initialize();
                await node.start();
                stateManager = node.getStateManager();
                myPeerId = node.getStatus().network.peerId;
                log(`Connected as ${myPeerId}`);

                // Observe namespace changes
                stateManager.observeNamespace(gameNamespace, (value, key) => {
                    if (key.startsWith('player-')) {
                        const id = key.replace('player-', '');
                        if (id === myPeerId) return;
                        applyRemotePlayer(id, value);
                        return;
                    }
                    if (key.startsWith('attack-')) {
                        const attacker = key.replace('attack-', '');
                        handleRemoteAttack(attacker, value);
                        return;
                    }
                });

                // Prune stale peers if their state stops updating
                setInterval(() => {
                    const now = Date.now();
                    for (const [id, data] of peers.entries()) {
                        if ((now - (data.lastSeen || 0)) > 10000) {
                            removePeer(id);
                        }
                    }
                }, 5000);

                // Publish our initial state and kick off heartbeats
                publishPlayerState();
                broadcastPosition(); // will repeat via requestAnimationFrame below
                window.addEventListener('beforeunload', () => {
                    if (stateManager) {
                        stateManager.deleteScoped(gameNamespace, `player-${myPeerId}`);
                    }
                });
            } catch (err) {
                console.error('P2P setup error:', err);
            }
        }

        // No-op placeholders for legacy peer messaging hooks
        function sendToPeer(peerId, message) {
            // Intentionally empty; state sync handled via Yjs/state-set
        }

        const POSITION_BROADCAST_MS = 250;
        let lastPositionBroadcast = 0;

        function publishPlayerState() {
            if (!stateManager || !myPeerId) return;
            const payload = {
                name: myName,
                position: { x: playerPosition.x, y: playerPosition.y, z: playerPosition.z },
                rotation: playerRotation,
                ts: Date.now(),
                color: myColor,
                score
            };
            stateManager.writeScoped(gameNamespace, `player-${myPeerId}`, payload);
        }

        function broadcastPosition() {
            const now = performance.now();
            if (now - lastPositionBroadcast >= POSITION_BROADCAST_MS) {
                lastPositionBroadcast = now;
                publishPlayerState();
            }
            requestAnimationFrame(broadcastPosition);
        }

        function startBackgroundHeartbeat() {
            if (backgroundHeartbeat) return;
            backgroundHeartbeat = setInterval(() => {
                publishPlayerState();
            }, 1000);
        }

        function stopBackgroundHeartbeat() {
            if (backgroundHeartbeat) {
                clearInterval(backgroundHeartbeat);
                backgroundHeartbeat = null;
            }
        }

        function handlePlayerHit() {
            console.log("YOU WERE HIT");
            const flashOverlay = document.createElement('div');
            flashOverlay.style.position = 'fixed';
            flashOverlay.style.top = '0';
            flashOverlay.style.left = '0';
            flashOverlay.style.width = '100%';
            flashOverlay.style.height = '100%';
            flashOverlay.style.backgroundColor = 'rgba(255,0,0,0.35)';
            flashOverlay.style.pointerEvents = 'none';
            flashOverlay.style.zIndex = '1000';
            document.body.appendChild(flashOverlay);
            setTimeout(() => flashOverlay.remove(), 300);

            const angle = Math.random() * Math.PI * 2;
            const distance = 3 * GRID_CELL_SIZE;
            playerPosition.x = Math.cos(angle) * distance;
            playerPosition.z = Math.sin(angle) * distance;
            playerPosition.y = PLAYER_SIZE / 2;

            let attempts = 0;
            const maxAttempts = 20;
            while (checkCollisions(playerPosition) && attempts < maxAttempts) {
                const newAngle = angle + (Math.PI / 4) * attempts;
                playerPosition.x = Math.cos(newAngle) * distance;
                playerPosition.z = Math.sin(newAngle) * distance;
                attempts++;
            }
            updateGrid();
            score = 0;
            publishPlayerState();
            updateHUD();
        }

        // Broadcast attack event so other clients can test hit and render FX
        function broadcastAttack(attackPosition) {
            if (!stateManager || !myPeerId) return;
            const payload = {
                position: { x: attackPosition.x, y: attackPosition.y, z: attackPosition.z },
                rotation: playerRotation,
                ts: Date.now()
            };
            stateManager.writeScoped(gameNamespace, `attack-${myPeerId}`, payload);
            handleRemoteAttack(myPeerId, payload); // apply locally to ensure visuals
        }

        function handleRemoteAttack(attackerId, payload) {
            if (!payload) return;
            const last = seenAttacks.get(attackerId);
            if (last && last === payload.ts) return;
            seenAttacks.set(attackerId, payload.ts);

            const attackPos = new THREE.Vector3(payload.position.x, payload.position.y, payload.position.z);
            const attackCube = new THREE.Mesh(attackGeometry, attackMaterial.clone());
            attackCube.position.copy(attackPos);
            attackCube.rotation.y = payload.rotation || 0;
            scene.add(attackCube);
            setTimeout(() => scene.remove(attackCube), ATTACK_DURATION);

            // Move spotlight for attacker if present
            const mesh = peerMeshes.get(attackerId);
            const angleDir = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), payload.rotation || 0);
            if (mesh?.userData?.spotTarget) {
                const offset = angleDir.clone().multiplyScalar(15);
                mesh.userData.spotTarget.position.copy(attackPos).add(offset);
            }
            if (mesh?.userData?.spot) {
                mesh.userData.spot.visible = true;
            }
            const attackerData = peers.get(attackerId);
            if (attackerData) {
                attackerData.attackFlashUntil = performance.now() + 800;
            }

            // Local hit detection
            if (attackerId !== myPeerId) {
                const attackBox = new THREE.Box3().setFromCenterAndSize(
                    attackPos,
                    new THREE.Vector3(ATTACK_SIZE, ATTACK_SIZE, ATTACK_SIZE)
                );
                const playerBox = new THREE.Box3().setFromCenterAndSize(
                    playerPosition,
                    new THREE.Vector3(PLAYER_SIZE, PLAYER_SIZE, PLAYER_SIZE)
                );
                if (attackBox.intersectsBox(playerBox)) {
                    handlePlayerHit();
                }
            }
        }

        function applyRemotePlayer(peerId, data) {
            if (!data) {
                removePeer(peerId);
                return;
            }
            if (!peers.has(peerId)) {
                addPeer(peerId, data.color);
            }
            const peerData = peers.get(peerId);
            const prevPos = peerData.lastPos || peerData.position.clone();
            const prevRot = peerData.lastRot || 0;
            peerData.position.set(data.position.x, data.position.y, data.position.z);
            peerData.rotation = data.rotation || 0;
            peerData.name = data.name;
            peerData.lastSeen = Date.now();
            peerData.lastPos = peerData.position.clone();
            peerData.lastRot = peerData.rotation;
            peerData.score = data.score || 0;
            if (!peerData.renderPosition) peerData.renderPosition = peerData.position.clone();
            if (peerData.renderPosition.distanceTo(peerData.position) > 20) {
                // snap large jumps (teleports)
                peerData.renderPosition.copy(peerData.position);
            }
            const mesh = peerMeshes.get(peerId);
            if (mesh) {
                mesh.position.copy(peerData.position);
                mesh.rotation.y = peerData.rotation;
                if (data.color) applyMeshColor(mesh, data.color);
                const spot = mesh.userData.spot;
                const spotTarget = mesh.userData.spotTarget;
                if (spot && spotTarget) {
                    const moved = prevPos.distanceTo(peerData.position) > 0.02;
                    const rotChanged = Math.abs(prevRot - peerData.rotation) > 0.05;
                const now = performance.now();
                const active = moved || rotChanged || (peerData.attackFlashUntil || 0) > now;
                const targetOffset = new THREE.Vector3(0, 0, -15).applyAxisAngle(new THREE.Vector3(0, 1, 0), peerData.renderRotation || peerData.rotation);
                spotTarget.position.copy(peerData.renderPosition || peerData.position).add(targetOffset);
                spotTarget.position.y = 0;
                spot.visible = active;
            }
                updateNameLabel(mesh, peerData.name || peerId);
            }
            updateHUD();
        }

        function updateNameLabel(mesh, text) {
            if (!mesh) return;
            const currentText = mesh.userData.nameLabel?.userData?.text;
            if (currentText === text) return;
            if (mesh.userData.nameLabel) {
                mesh.remove(mesh.userData.nameLabel);
            }
            const label = createNameLabel(text);
            label.userData = { text };
            label.position.set(0, PLAYER_SIZE * 0.9, 0);
            mesh.add(label);
            mesh.userData.nameLabel = label;
        }
        
        // Initialize joysticks on mobile devices
        if (isMobile) {
            leftJoystick = new Joystick(document.getElementById('left-joystick'));
            rightJoystick = new Joystick(document.getElementById('right-joystick'));
            
            // Show attack button on mobile
            const attackButton = document.getElementById('attack-button');
            if (attackButton) {
                attackButton.style.display = 'block';
            }
        }
        
        // Initialize the game
        initializeGrid();
        respawnOnPeriphery();
        setupP2P();
        update();
    </script>
</body>
</html>
