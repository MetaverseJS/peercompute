<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PeerCompute P2P Test</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #1a1a1a;
      color: #e0e0e0;
    }
    h1 {
      color: #4CAF50;
      border-bottom: 2px solid #4CAF50;
      padding-bottom: 10px;
    }
    .container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-top: 20px;
    }
    .panel {
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 20px;
    }
    .panel h2 {
      margin-top: 0;
      color: #64B5F6;
      font-size: 1.2em;
    }
    button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 10px 20px;
      margin: 5px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    button:hover {
      background: #45a049;
    }
    button:disabled {
      background: #666;
      cursor: not-allowed;
    }
    .status {
      padding: 15px;
      margin: 10px 0;
      border-radius: 4px;
      background: #333;
      border-left: 4px solid #2196F3;
    }
    .status.success {
      border-left-color: #4CAF50;
    }
    .status.error {
      border-left-color: #f44336;
    }
    .status.warning {
      border-left-color: #ff9800;
    }
    .log {
      background: #1a1a1a;
      border: 1px solid #444;
      border-radius: 4px;
      padding: 10px;
      height: 300px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 12px;
    }
    .log-entry {
      margin: 2px 0;
      padding: 4px;
      border-radius: 2px;
    }
    .log-entry.info {
      color: #64B5F6;
    }
    .log-entry.success {
      color: #4CAF50;
    }
    .log-entry.error {
      color: #f44336;
    }
    .log-entry.warning {
      color: #ff9800;
    }
    input {
      padding: 8px;
      margin: 5px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #333;
      color: #e0e0e0;
      width: 300px;
    }
    .state-display {
      background: #1a1a1a;
      border: 1px solid #444;
      border-radius: 4px;
      padding: 10px;
      margin: 10px 0;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      max-height: 200px;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <h1>üåê PeerCompute P2P Connectivity Test</h1>
  
  <div class="container">
    <!-- Node Control Panel -->
    <div class="panel">
      <h2>Node Control</h2>
      <div id="status" class="status">
        <strong>Status:</strong> Not initialized
      </div>
      
      <div>
        <button id="initBtn" onclick="initializeNode()">Initialize Node</button>
        <button id="startBtn" onclick="startNode()" disabled>Start Node</button>
        <button id="stopBtn" onclick="stopNode()" disabled>Stop Node</button>
      </div>
      
      <div style="margin-top: 20px;">
        <h3>Node Info</h3>
        <div id="nodeInfo" class="state-display">
          Node not initialized
        </div>
      </div>
    </div>
    
    <!-- State Management Panel -->
    <div class="panel">
      <h2>State Management (CRDT)</h2>
      
      <div>
        <h3>Write to State</h3>
        <input type="text" id="stateKey" placeholder="Key" />
        <input type="text" id="stateValue" placeholder="Value" />
        <button onclick="writeState()">Write</button>
      </div>
      
      <div>
        <h3>Read from State</h3>
        <input type="text" id="readKey" placeholder="Key" />
        <button onclick="readState()">Read</button>
        <div id="readResult" class="state-display" style="margin-top: 10px;">
          Result will appear here
        </div>
      </div>
      
      <div>
        <h3>Current State Snapshot</h3>
        <button onclick="getSnapshot()">Refresh Snapshot</button>
        <div id="stateSnapshot" class="state-display">
          No state yet
        </div>
      </div>
    </div>
  </div>
  
  <!-- Log Panel -->
  <div class="panel" style="margin-top: 20px;">
    <h2>Event Log</h2>
    <button onclick="clearLog()">Clear Log</button>
    <div id="log" class="log"></div>
  </div>
  
  <script defer src="bundle.js"></script>
  <script type="module">
    // NodeKernel is exposed on window by bundle.js
    // import { NodeKernel } from './src/peercompute/nodeKernel/NodeKernel.js';
    
    let node = null;
    let stateUnsubscribe = null;
    
    // Expose node instance globally for testing
    window.node = null;
    
    // Make functions globally available
    window.initializeNode = initializeNode;
    window.startNode = startNode;
    window.stopNode = stopNode;
    window.writeState = writeState;
    window.readState = readState;
    window.getSnapshot = getSnapshot;
    window.clearLog = clearLog;
    
    function log(message, type = 'info') {
      const logDiv = document.getElementById('log');
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      logDiv.appendChild(entry);
      logDiv.scrollTop = logDiv.scrollHeight;
      console.log(message);
    }
    
    function updateStatus(message, type = 'info') {
      const statusDiv = document.getElementById('status');
      statusDiv.className = `status ${type}`;
      statusDiv.innerHTML = `<strong>Status:</strong> ${message}`;
    }
    
    function updateNodeInfo() {
      if (!node) return;
      
      const status = node.getStatus();
      const infoDiv = document.getElementById('nodeInfo');
      const bootstrapPeers = node?.config?.bootstrapPeers || [];
      const announceAddrs = node?.getNetworkManager()?.getConnectedPeers?.()?.map(p => p.peerId) || [];

      infoDiv.innerHTML = `
<strong>Node ID:</strong> ${status.nodeId || 'N/A'}<br>
<strong>Initialized:</strong> ${status.isInitialized}<br>
<strong>Started:</strong> ${status.isStarted}<br>
<strong>Topology:</strong> ${status.topology}<br>
<strong>Bootstrap peers:</strong> ${bootstrapPeers.length ? bootstrapPeers.join(', ') : 'None'}<br>
<strong>Peers:</strong> ${announceAddrs.length > 0 ? announceAddrs.join(', ') : 'None'}<br>
<br>
<strong>Network:</strong><br>
- Peer ID: ${status.network.peerId || 'N/A'}<br>
- Peers: ${status.network.peerCount}<br>
- Connected: ${status.network.isConnected}<br>
<br>
<strong>State:</strong><br>
- Keys: ${status.state.keyCount}<br>
- Persistence: ${status.state.hasPersistence}<br>
- P2P Sync: ${status.state.hasP2PSync}
      `.trim();
    }
    
    async function initializeNode() {
      try {
        log('Initializing NodeKernel...', 'info');
        updateStatus('Initializing...', 'warning');
        
        // Wait for bundle to load NodeKernel if needed
        if (!window.NodeKernel) {
            log('Waiting for NodeKernel bundle...', 'warning');
            let retries = 0;
            while (!window.NodeKernel && retries < 20) {
                await new Promise(r => setTimeout(r, 100));
                retries++;
            }
            if (!window.NodeKernel) throw new Error('NodeKernel not found in bundle');
        }
        const NodeKernel = window.NodeKernel;

        // Try to load relay config if available (prefer served file from /public)
        let bootstrapPeers = null;
        try {
          const tryFetch = async (path) => {
            try {
              const res = await fetch(path, { cache: 'no-store' });
              if (res.ok) return await res.json();
              return null;
            } catch {
              return null;
            }
          };

          // Try multiple locations so it works with dev server:
          // - /public/relay-config.json is served at /relay-config.json
          // - fallback to dotfile at root (may not be served by dev server)
          const cfg =
            (await tryFetch('/relay-config.json')) ||
            (await tryFetch('relay-config.json')) ||
            (await tryFetch('/.relay-config.json')) ||
            (await tryFetch('.relay-config.json'));

          if (cfg && Array.isArray(cfg.bootstrapPeers) && cfg.bootstrapPeers.length > 0) {
            bootstrapPeers = cfg.bootstrapPeers;
            log(`Using relay bootstrap peers: ${bootstrapPeers.join(', ')}`, 'info');
          } else {
            log('No relay peers configured (tried relay-config.json). Bootstrapping disabled.', 'warning');
          }
        } catch (e) {
          log(`Error loading relay config: ${e.message}`, 'warning');
        }
        
        node = new NodeKernel({
          topology: 'distributed',
          enablePersistence: true,
          bootstrapPeers
        });
        
        // Expose to window for testing
        window.node = node;
        
        await node.initialize();
        
        // Subscribe to all state changes
        const stateManager = node.getStateManager();
        stateUnsubscribe = stateManager.subscribe('*', (value, key) => {
          log(`State changed: ${key} = ${JSON.stringify(value)}`, 'success');
          updateNodeInfo();
        });
        
        log('Node initialized successfully!', 'success');
        updateStatus('Initialized (not started)', 'success');
        updateNodeInfo();
        
        document.getElementById('initBtn').disabled = true;
        document.getElementById('startBtn').disabled = false;
        
      } catch (error) {
        log(`Initialization failed: ${error.message}`, 'error');
        updateStatus(`Error: ${error.message}`, 'error');
        console.error(error);
      }
    }
    
    async function startNode() {
      try {
        log('Starting node...', 'info');
        updateStatus('Starting...', 'warning');
        
        await node.start();
        
        log('Node started! Connected to P2P network', 'success');
        updateStatus('Running', 'success');
        updateNodeInfo();
        
        document.getElementById('startBtn').disabled = true;
        document.getElementById('stopBtn').disabled = false;
        
      } catch (error) {
        log(`Start failed: ${error.message}`, 'error');
        updateStatus(`Error: ${error.message}`, 'error');
        console.error(error);
      }
    }
    
    async function stopNode() {
      try {
        log('Stopping node...', 'info');
        updateStatus('Stopping...', 'warning');
        
        if (stateUnsubscribe) {
          stateUnsubscribe();
        }
        
        await node.stop();
        
        log('Node stopped', 'info');
        updateStatus('Stopped', 'info');
        
        document.getElementById('stopBtn').disabled = true;
        document.getElementById('initBtn').disabled = false;
        document.getElementById('startBtn').disabled = true;
        
      } catch (error) {
        log(`Stop failed: ${error.message}`, 'error');
        updateStatus(`Error: ${error.message}`, 'error');
        console.error(error);
      }
    }
    
    function writeState() {
      if (!node || !node.isInitialized) {
        log('Node not initialized', 'error');
        return;
      }
      
      const key = document.getElementById('stateKey').value.trim();
      const value = document.getElementById('stateValue').value.trim();
      
      if (!key) {
        log('Please enter a key', 'warning');
        return;
      }
      
      try {
        const stateManager = node.getStateManager();
        stateManager.write(key, value);
        log(`Wrote to state: ${key} = ${value}`, 'success');
        
        // Clear inputs
        document.getElementById('stateKey').value = '';
        document.getElementById('stateValue').value = '';
        
        updateNodeInfo();
      } catch (error) {
        log(`Write failed: ${error.message}`, 'error');
      }
    }
    
    function readState() {
      if (!node || !node.isInitialized) {
        log('Node not initialized', 'error');
        return;
      }
      
      const key = document.getElementById('readKey').value.trim();
      
      if (!key) {
        log('Please enter a key', 'warning');
        return;
      }
      
      try {
        const stateManager = node.getStateManager();
        const value = stateManager.read(key);
        
        const resultDiv = document.getElementById('readResult');
        if (value !== undefined) {
          resultDiv.textContent = `${key} = ${JSON.stringify(value)}`;
          log(`Read from state: ${key} = ${JSON.stringify(value)}`, 'info');
        } else {
          resultDiv.textContent = `Key "${key}" not found`;
          log(`Key "${key}" not found in state`, 'warning');
        }
      } catch (error) {
        log(`Read failed: ${error.message}`, 'error');
      }
    }
    
    function getSnapshot() {
      if (!node || !node.isInitialized) {
        log('Node not initialized', 'error');
        return;
      }
      
      try {
        const stateManager = node.getStateManager();
        const snapshot = stateManager.snapshot();
        
        const snapshotDiv = document.getElementById('stateSnapshot');
        snapshotDiv.textContent = JSON.stringify(snapshot, null, 2);
        
        log('State snapshot retrieved', 'info');
      } catch (error) {
        log(`Snapshot failed: ${error.message}`, 'error');
      }
    }
    
    function clearLog() {
      document.getElementById('log').innerHTML = '';
    }
    
    // Initial log entry
    log('PeerCompute P2P Test initialized. Click "Initialize Node" to begin.', 'info');
  </script>
</body>
</html>
