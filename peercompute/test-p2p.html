<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PeerCompute P2P Test</title>
  <style>
    :root {
      --bg-deep: #0a0f0c;
      --bg-mid: #101a15;
      --grid: #143326;
      --panel: #0f1714;
      --panel-edge: #1f3a2c;
      --panel-glow: rgba(125, 255, 106, 0.12);
      --text: #d6f9e6;
      --muted: #7fa792;
      --neon-green: #7dff6a;
      --neon-amber: #ffd166;
      --neon-cyan: #4deeea;
      --neon-red: #ff5f5f;
      --shadow: rgba(0, 0, 0, 0.6);
      --scanline: rgba(255, 255, 255, 0.03);
    }
    * {
      box-sizing: border-box;
    }
    body {
      font-family: 'Press Start 2P', 'VT323', 'IBM Plex Mono', 'Fira Mono', Consolas, 'Courier New', monospace;
      max-width: 1200px;
      margin: 0 auto;
      padding: 24px;
      background: radial-gradient(120% 120% at 50% 0%, #141f1a 0%, #0b110e 45%, #070b09 100%);
      color: var(--text);
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background: repeating-linear-gradient(
        180deg,
        rgba(0, 0, 0, 0) 0,
        rgba(0, 0, 0, 0) 2px,
        var(--scanline) 3px
      );
      pointer-events: none;
      mix-blend-mode: screen;
      opacity: 0.35;
    }
    body::after {
      content: "";
      position: fixed;
      inset: 0;
      box-shadow: inset 0 0 120px rgba(0, 0, 0, 0.75);
      pointer-events: none;
    }
    h1 {
      color: var(--neon-green);
      border-bottom: 2px solid var(--panel-edge);
      padding-bottom: 14px;
      margin-top: 0;
      font-size: 1.35rem;
      text-shadow: 0 0 12px rgba(125, 255, 106, 0.35);
      animation: glow 3s ease-in-out infinite;
    }
    .container {
      display: grid;
      grid-template-columns: 1fr;
      gap: 20px;
      margin-top: 20px;
    }
    .panel {
      background: linear-gradient(135deg, #0c1411 0%, #0f1b16 50%, #0d1512 100%);
      border: 1px solid var(--panel-edge);
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 10px 30px var(--shadow), 0 0 18px var(--panel-glow);
      position: relative;
    }
    .panel::before {
      content: "";
      position: absolute;
      inset: 1px;
      border-radius: 10px;
      border: 1px dashed rgba(125, 255, 106, 0.15);
      pointer-events: none;
    }
    .panel h2 {
      margin-top: 0;
      color: var(--neon-cyan);
      font-size: 1rem;
      text-shadow: 0 0 8px rgba(77, 238, 234, 0.4);
    }
    h3 {
      color: var(--neon-amber);
      font-size: 0.9rem;
      margin-bottom: 8px;
    }
    button {
      background: linear-gradient(180deg, #1b2f25 0%, #0d1a14 100%);
      color: var(--neon-green);
      border: 1px solid var(--panel-edge);
      padding: 10px 18px;
      margin: 6px 6px 6px 0;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.45);
      transition: transform 0.1s ease, box-shadow 0.2s ease, color 0.2s ease;
    }
    button:hover {
      transform: translateY(-1px);
      color: #b9ff96;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.55);
    }
    button:active {
      transform: translateY(1px);
    }
    button:disabled {
      background: #1a1f1d;
      color: #4d6b5a;
      cursor: not-allowed;
      box-shadow: none;
    }
    .status {
      padding: 14px;
      margin: 12px 0;
      border-radius: 6px;
      background: #0c1512;
      border-left: 4px solid var(--neon-cyan);
      box-shadow: inset 0 0 12px rgba(77, 238, 234, 0.12);
    }
    .status.success {
      border-left-color: var(--neon-green);
      box-shadow: inset 0 0 12px rgba(125, 255, 106, 0.15);
    }
    .status.error {
      border-left-color: var(--neon-red);
      box-shadow: inset 0 0 12px rgba(255, 95, 95, 0.15);
    }
    .status.warning {
      border-left-color: var(--neon-amber);
      box-shadow: inset 0 0 12px rgba(255, 209, 102, 0.15);
    }
    .log,
    .state-display {
      background: #070b09;
      border: 1px solid var(--panel-edge);
      border-radius: 6px;
      padding: 12px;
      overflow-y: auto;
      font-family: 'IBM Plex Mono', 'Fira Mono', Consolas, 'Courier New', monospace;
      font-size: 0.75rem;
      color: var(--text);
      text-transform: none;
      letter-spacing: 0.2px;
      box-shadow: inset 0 0 18px rgba(0, 0, 0, 0.7);
    }
    .log {
      height: 300px;
    }
    .log-entry {
      margin: 4px 0;
      padding: 4px 6px;
      border-radius: 4px;
      background: rgba(8, 13, 11, 0.6);
    }
    .log-entry.info {
      color: var(--neon-cyan);
    }
    .log-entry.success {
      color: var(--neon-green);
    }
    .log-entry.error {
      color: var(--neon-red);
    }
    .log-entry.warning {
      color: var(--neon-amber);
    }
    input {
      padding: 10px 12px;
      margin: 6px 6px 6px 0;
      border: 1px solid var(--panel-edge);
      border-radius: 6px;
      background: #0b1511;
      color: var(--text);
      width: min(320px, 100%);
      height: 38px;
      font-family: inherit;
      text-transform: none;
    }
    input::placeholder {
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .state-display {
      max-height: 200px;
      height: 180px;
    }
    @media (max-width: 900px) {
      body {
        padding: 16px;
      }
      .container {
        grid-template-columns: 1fr;
      }
      h1 {
        font-size: 1.1rem;
      }
    }
    @keyframes glow {
      0%, 100% { text-shadow: 0 0 10px rgba(125, 255, 106, 0.25); }
      50% { text-shadow: 0 0 18px rgba(125, 255, 106, 0.45); }
    }
  </style>
</head>
<body>
  <h1>üåê PeerCompute P2P Connectivity Test</h1>
  
  <div class="container">
    <!-- Node Control Panel -->
    <div class="panel">
      <h2>Node Control</h2>
      <div id="status" class="status">
        <strong>Status:</strong> Not initialized
      </div>
      
      <div>
        <button id="initBtn" onclick="initializeNode()">Initialize Node</button>
        <button id="startBtn" onclick="startNode()" disabled>Start Node</button>
        <button id="stopBtn" onclick="stopNode()" disabled>Stop Node</button>
      </div>
      
      <div style="margin-top: 20px;">
        <h3>Node Info</h3>
        <div id="nodeInfo" class="state-display">
          Node not initialized
        </div>
      </div>
    </div>
    
    <!-- State Management Panel -->
    <div class="panel">
      <h2>State Management (CRDT)</h2>
      
      <div>
        <h3>Write to State</h3>
        <input type="text" id="stateKey" placeholder="Key" disabled />
        <input type="text" id="stateValue" placeholder="Value" disabled />
        <button id="writeBtn" onclick="writeState()" disabled>Write</button>
      </div>
      
      <div>
        <h3>Read from State</h3>
        <input type="text" id="readKey" placeholder="Key" disabled />
        <button id="readBtn" onclick="readState()" disabled>Read</button>
        <div id="readResult" class="state-display" style="margin-top: 10px;">
          Result will appear here
        </div>
      </div>
      
      <div>
        <h3>Current State Snapshot</h3>
        <button id="snapshotBtn" onclick="getSnapshot()" disabled>Refresh Snapshot</button>
        <div id="stateSnapshot" class="state-display">
          No state yet
        </div>
      </div>
    </div>
  </div>
  
  <!-- Log Panel -->
  <div class="panel" style="margin-top: 20px;">
    <h2>Event Log</h2>
    <button onclick="clearLog()">Clear Log</button>
    <div id="log" class="log"></div>
  </div>
  
  <script defer src="bundle.js"></script>
  <script type="module">
    // NodeKernel is exposed on window by bundle.js
    // import { NodeKernel } from './src/peercompute/nodeKernel/NodeKernel.js';
    
    let node = null;
    let stateUnsubscribe = null;
    
    // Expose node instance globally for testing
    window.node = null;
    
    // Make functions globally available
    window.initializeNode = initializeNode;
    window.startNode = startNode;
    window.stopNode = stopNode;
    window.writeState = writeState;
    window.readState = readState;
    window.getSnapshot = getSnapshot;
    window.clearLog = clearLog;
    
    function log(message, type = 'info') {
      const logDiv = document.getElementById('log');
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      logDiv.appendChild(entry);
      logDiv.scrollTop = logDiv.scrollHeight;
      console.log(message);
    }
    
    function updateStatus(message, type = 'info') {
      const statusDiv = document.getElementById('status');
      statusDiv.className = `status ${type}`;
      statusDiv.innerHTML = `<strong>Status:</strong> ${message}`;
    }
    
    function updateNodeInfo() {
      if (!node) return;
      
      const status = node.getStatus();
      const infoDiv = document.getElementById('nodeInfo');
      const bootstrapPeers = node?.config?.bootstrapPeers || [];
      const announceAddrs = node?.getNetworkManager()?.getConnectedPeers?.()?.map(p => p.peerId) || [];

      infoDiv.innerHTML = `
<strong>Node ID:</strong> ${status.nodeId || 'N/A'}<br>
<strong>Initialized:</strong> ${status.isInitialized}<br>
<strong>Started:</strong> ${status.isStarted}<br>
<strong>Topology:</strong> ${status.topology}<br>
<strong>Bootstrap peers:</strong> ${bootstrapPeers.length ? bootstrapPeers.join(', ') : 'None'}<br>
<strong>Peers:</strong> ${announceAddrs.length > 0 ? announceAddrs.join(', ') : 'None'}<br>
<br>
<strong>Network:</strong><br>
- Peer ID: ${status.network.peerId || 'N/A'}<br>
- Peers: ${status.network.peerCount}<br>
- Connected: ${status.network.isConnected}<br>
<br>
<strong>State:</strong><br>
- Keys: ${status.state.keyCount}<br>
- Persistence: ${status.state.hasPersistence}<br>
- P2P Sync: ${status.state.hasP2PSync}
      `.trim();
    }

    function setStateControlsEnabled(enabled) {
      const fields = [
        document.getElementById('stateKey'),
        document.getElementById('stateValue'),
        document.getElementById('readKey')
      ];
      const buttons = [
        document.getElementById('writeBtn'),
        document.getElementById('readBtn'),
        document.getElementById('snapshotBtn')
      ];
      fields.forEach((el) => {
        if (el) el.disabled = !enabled;
      });
      buttons.forEach((el) => {
        if (el) el.disabled = !enabled;
      });
    }
    
    async function initializeNode() {
      try {
        log('Initializing NodeKernel...', 'info');
        updateStatus('Initializing...', 'warning');
        
        // Wait for bundle to load NodeKernel if needed
        if (!window.NodeKernel) {
            log('Waiting for NodeKernel bundle...', 'warning');
            let retries = 0;
            while (!window.NodeKernel && retries < 20) {
                await new Promise(r => setTimeout(r, 100));
                retries++;
            }
            if (!window.NodeKernel) throw new Error('NodeKernel not found in bundle');
        }
        const NodeKernel = window.NodeKernel;

        // Try to load relay config if available (prefer served file from /public)
        let bootstrapPeers = null;
        try {
          const tryFetch = async (path) => {
            try {
              const res = await fetch(path, { cache: 'no-store' });
              if (res.ok) return await res.json();
              return null;
            } catch {
              return null;
            }
          };

          // Try multiple locations so it works with dev server:
          // - /public/relay-config.json is served at /relay-config.json
          // - fallback to dotfile at root (may not be served by dev server)
          const cfg =
            (await tryFetch('/relay-config.json')) ||
            (await tryFetch('relay-config.json')) ||
            (await tryFetch('/.relay-config.json')) ||
            (await tryFetch('.relay-config.json'));

          if (cfg && Array.isArray(cfg.bootstrapPeers) && cfg.bootstrapPeers.length > 0) {
            bootstrapPeers = cfg.bootstrapPeers;
            log(`Using relay bootstrap peers: ${bootstrapPeers.join(', ')}`, 'info');
          } else {
            log('No relay peers configured (tried relay-config.json). Bootstrapping disabled.', 'warning');
          }
        } catch (e) {
          log(`Error loading relay config: ${e.message}`, 'warning');
        }
        
        node = new NodeKernel({
          topology: 'distributed',
          enablePersistence: true,
          bootstrapPeers
        });
        
        // Expose to window for testing
        window.node = node;
        
        await node.initialize();
        
        // Subscribe to all state changes
        const stateManager = node.getStateManager();
        stateUnsubscribe = stateManager.subscribe('*', (value, key) => {
          log(`State changed: ${key} = ${JSON.stringify(value)}`, 'success');
          updateNodeInfo();
        });
        
        log('Node initialized successfully!', 'success');
        updateStatus('Initialized (not started)', 'success');
        updateNodeInfo();
        
        document.getElementById('initBtn').disabled = true;
        document.getElementById('startBtn').disabled = false;
        setStateControlsEnabled(false);
        
      } catch (error) {
        log(`Initialization failed: ${error.message}`, 'error');
        updateStatus(`Error: ${error.message}`, 'error');
        console.error(error);
      }
    }
    
    async function startNode() {
      try {
        log('Starting node...', 'info');
        updateStatus('Starting...', 'warning');
        
        await node.start();
        
        log('Node started! Connected to P2P network', 'success');
        updateStatus('Running', 'success');
        updateNodeInfo();
        
        document.getElementById('startBtn').disabled = true;
        document.getElementById('stopBtn').disabled = false;
        setStateControlsEnabled(true);
        
      } catch (error) {
        log(`Start failed: ${error.message}`, 'error');
        updateStatus(`Error: ${error.message}`, 'error');
        console.error(error);
      }
    }
    
    async function stopNode() {
      try {
        log('Stopping node...', 'info');
        updateStatus('Stopping...', 'warning');
        
        if (stateUnsubscribe) {
          stateUnsubscribe();
        }
        
        await node.stop();
        
        log('Node stopped', 'info');
        updateStatus('Stopped', 'info');
        
        document.getElementById('stopBtn').disabled = true;
        document.getElementById('initBtn').disabled = false;
        document.getElementById('startBtn').disabled = true;
        setStateControlsEnabled(false);
        
      } catch (error) {
        log(`Stop failed: ${error.message}`, 'error');
        updateStatus(`Error: ${error.message}`, 'error');
        console.error(error);
      }
    }
    
    function writeState() {
      if (!node || !node.isStarted) {
        log('Node not started', 'error');
        return;
      }
      
      const key = document.getElementById('stateKey').value.trim();
      const value = document.getElementById('stateValue').value.trim();
      
      if (!key) {
        log('Please enter a key', 'warning');
        return;
      }
      
      try {
        const stateManager = node.getStateManager();
        stateManager.write(key, value);
        log(`Wrote to state: ${key} = ${value}`, 'success');
        
        // Clear inputs
        document.getElementById('stateKey').value = '';
        document.getElementById('stateValue').value = '';
        
        updateNodeInfo();
      } catch (error) {
        log(`Write failed: ${error.message}`, 'error');
      }
    }
    
    function readState() {
      if (!node || !node.isStarted) {
        log('Node not started', 'error');
        return;
      }
      
      const key = document.getElementById('readKey').value.trim();
      
      if (!key) {
        log('Please enter a key', 'warning');
        return;
      }
      
      try {
        const stateManager = node.getStateManager();
        const value = stateManager.read(key);
        
        const resultDiv = document.getElementById('readResult');
        if (value !== undefined) {
          resultDiv.textContent = `${key} = ${JSON.stringify(value)}`;
          log(`Read from state: ${key} = ${JSON.stringify(value)}`, 'info');
        } else {
          resultDiv.textContent = `Key "${key}" not found`;
          log(`Key "${key}" not found in state`, 'warning');
        }
      } catch (error) {
        log(`Read failed: ${error.message}`, 'error');
      }
    }
    
    function getSnapshot() {
      if (!node || !node.isStarted) {
        log('Node not started', 'error');
        return;
      }
      
      try {
        const stateManager = node.getStateManager();
        const snapshot = stateManager.snapshot();
        
        const snapshotDiv = document.getElementById('stateSnapshot');
        snapshotDiv.textContent = JSON.stringify(snapshot, null, 2);
        
        log('State snapshot retrieved', 'info');
      } catch (error) {
        log(`Snapshot failed: ${error.message}`, 'error');
      }
    }
    
    function clearLog() {
      document.getElementById('log').innerHTML = '';
    }
    
    // Initial log entry
    log('PeerCompute P2P Test initialized. Click "Initialize Node" to begin.', 'info');
    setStateControlsEnabled(false);
  </script>
</body>
</html>
