<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PeerCompute Automated Tests</title>
  <style>
    body {
      font-family: 'Inter', system-ui, sans-serif;
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
      background: #111;
      color: #e5e7eb;
      line-height: 1.5;
    }
    h1 {
      font-size: 2rem;
      margin-bottom: 1.5rem;
      background: linear-gradient(to right, #60a5fa, #a78bfa);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .test-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-top: 20px;
    }
    .node-panel {
      background: #1e1e1e;
      border: 1px solid #404040;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    }
    .node-panel h2 {
      margin-top: 0;
      color: #e5e7eb;
      font-size: 1.2em;
      border-bottom: 1px solid #404040;
      padding-bottom: 10px;
      margin-bottom: 15px;
    }
    .status {
      padding: 12px;
      margin: 10px 0;
      border-radius: 6px;
      background: #2d2d2d;
      border-left: 4px solid #3b82f6;
      font-weight: 500;
    }
    .status.error {
      border-left-color: #ef4444;
      background: #2d1a1a;
      color: #fca5a5;
    }
    .status.success {
      border-left-color: #22c55e;
      background: #1a2d1a;
      color: #86efac;
    }
    .status.warning {
      border-left-color: #f59e0b;
      background: #2d261a;
      color: #fcd34d;
    }
    button {
      background: #3b82f6;
      color: white;
      border: none;
      padding: 10px 20px;
      margin: 5px;
      border-radius: 6px;
      cursor: pointer;
      font-family: inherit;
      font-weight: 600;
      font-size: 0.95em;
      transition: background-color 0.2s;
    }
    button:hover {
      background: #2563eb;
    }
    button:disabled {
      background: #4b5563;
      color: #9ca3af;
      cursor: not-allowed;
    }
    .log {
      background: #000;
      border: 1px solid #404040;
      border-radius: 8px;
      padding: 12px;
      height: 300px;
      overflow-y: auto;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.85em;
      margin-top: 15px;
    }
    .log-entry {
      margin: 4px 0;
      padding: 2px 0;
      border-bottom: 1px solid #222;
    }
    .log-entry.info { color: #9ca3af; }
    .log-entry.success { color: #34d399; }
    .log-entry.error { color: #f87171; }
    .log-entry.warning { color: #fbbf24; }
    .test-results {
      margin-top: 20px;
      padding: 20px;
      background: #1e1e1e;
      border: 1px solid #404040;
      border-radius: 12px;
    }
    .test-result {
      padding: 12px;
      margin: 8px 0;
      border-radius: 6px;
      background: #2d2d2d;
    }
    .test-result.pass {
      border-left: 4px solid #22c55e;
    }
    .test-result.fail {
      border-left: 4px solid #ef4444;
    }
    .metrics {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin: 15px 0;
    }
    .metric {
      background: #2d2d2d;
      padding: 12px;
      border-radius: 6px;
      border: 1px solid #404040;
    }
    .metric-label {
      font-size: 0.75em;
      color: #9ca3af;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 4px;
    }
    .metric-value {
      font-size: 1.1em;
      font-weight: 600;
      color: white;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <h1>ðŸ§ª PeerCompute Automated Test Suite</h1>
  
  <div>
    <button onclick="runAllTests()">â–¶ Run All Tests</button>
    <button onclick="runConnectivityTest()">ðŸ”— Test Connectivity</button>
    <button onclick="runStateSync()">ðŸ“Š Test State Sync</button>
    <button onclick="clearLogs()">ðŸ—‘ Clear Logs</button>
  </div>
  
  <div class="test-container">
    <!-- Node 1 Panel -->
    <div class="node-panel">
      <h2>Node 1</h2>
      <div id="node1Status" class="status">Waiting...</div>
      <div class="metrics">
        <div class="metric">
          <div class="metric-label">Peer ID</div>
          <div class="metric-value" id="node1PeerId">-</div>
        </div>
        <div class="metric">
          <div class="metric-label">Peers</div>
          <div class="metric-value" id="node1Peers">0</div>
        </div>
        <div class="metric">
          <div class="metric-label">Connections</div>
          <div class="metric-value" id="node1Connections">0</div>
        </div>
      </div>
      <div id="node1Log" class="log"></div>
    </div>
    
    <!-- Node 2 Panel -->
    <div class="node-panel">
      <h2>Node 2</h2>
      <div id="node2Status" class="status">Waiting...</div>
      <div class="metrics">
        <div class="metric">
          <div class="metric-label">Peer ID</div>
          <div class="metric-value" id="node2PeerId">-</div>
        </div>
        <div class="metric">
          <div class="metric-label">Peers</div>
          <div class="metric-value" id="node2Peers">0</div>
        </div>
        <div class="metric">
          <div class="metric-label">Connections</div>
          <div class="metric-value" id="node2Connections">0</div>
        </div>
      </div>
      <div id="node2Log" class="log"></div>
    </div>
  </div>
  
  <div class="test-results">
    <h2>Test Results</h2>
    <div id="testResults"></div>
  </div>
  
  <script defer src="bundle.js"></script>
  <script type="module">
    // import { NodeKernel } from './src/peercompute/nodeKernel/NodeKernel.js';
    
    let node1 = null;
    let node2 = null;
    let testResults = [];
    
    // Make functions globally available
    window.runAllTests = runAllTests;
    window.runConnectivityTest = runConnectivityTest;
    window.runStateSync = runStateSync;
    window.clearLogs = clearLogs;
    
    function log(nodeId, message, type = 'info') {
      const logDiv = document.getElementById(`node${nodeId}Log`);
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      logDiv.appendChild(entry);
      logDiv.scrollTop = logDiv.scrollHeight;
      console.log(`[Node${nodeId}] ${message}`);
    }
    
    function updateStatus(nodeId, message, type = 'info') {
      const statusDiv = document.getElementById(`node${nodeId}Status`);
      statusDiv.className = `status ${type}`;
      statusDiv.textContent = message;
    }
    
    function updateMetrics(nodeId, status) {
      document.getElementById(`node${nodeId}PeerId`).textContent = 
        status.network.peerId?.substring(0, 8) + '...' || '-';
      document.getElementById(`node${nodeId}Peers`).textContent = 
        status.network.peerCount || 0;
      document.getElementById(`node${nodeId}Connections`).textContent = 
        status.network.connections || 0;
    }
    
    function addTestResult(testName, passed, message) {
      testResults.push({ testName, passed, message, timestamp: Date.now() });
      
      const resultsDiv = document.getElementById('testResults');
      const resultDiv = document.createElement('div');
      resultDiv.className = `test-result ${passed ? 'pass' : 'fail'}`;
      resultDiv.innerHTML = `
        <strong>${passed ? 'âœ“' : 'âœ—'} ${testName}</strong><br>
        ${message}
      `;
      resultsDiv.appendChild(resultDiv);
    }
    
    async function initializeNode(nodeId) {
      log(nodeId, 'Initializing node...', 'info');
      updateStatus(nodeId, 'Initializing...', 'warning');
      
      // Wait for bundle to load NodeKernel
      if (!window.NodeKernel) {
        let retries = 0;
        while (!window.NodeKernel && retries < 20) {
          await new Promise(r => setTimeout(r, 100));
          retries++;
        }
        if (!window.NodeKernel) throw new Error('NodeKernel not found in bundle');
      }
      const NodeKernel = window.NodeKernel;

      // Try to load relay config
      let bootstrapPeers = [];
      try {
        const tryFetch = async (path) => {
          try {
            const res = await fetch(path, { cache: 'no-store' });
            if (res.ok) return await res.json();
            return null;
          } catch { return null; }
        };
        
        const cfg = (await tryFetch('/relay-config.json')) || 
                   (await tryFetch('relay-config.json'));
                   
        if (cfg && Array.isArray(cfg.bootstrapPeers) && cfg.bootstrapPeers.length > 0) {
          bootstrapPeers = cfg.bootstrapPeers;
          log(nodeId, `Using relay: ${bootstrapPeers[0]}`, 'info');
        } else {
          log(nodeId, 'No relay config found. Using peer discovery only.', 'warning');
        }
      } catch (e) {
        log(nodeId, `Config error: ${e.message}`, 'warning');
      }

      const node = new NodeKernel({
        topology: 'distributed',
        enablePersistence: true,
        bootstrapPeers: bootstrapPeers
      });
      
      await node.initialize();
      log(nodeId, 'Node initialized', 'success');
      
      await node.start();
      log(nodeId, 'Node started', 'success');
      updateStatus(nodeId, 'Running', 'success');
      
      // Update metrics periodically
      setInterval(() => {
        const status = node.getStatus();
        updateMetrics(nodeId, status);
      }, 1000);
      
      return node;
    }
    
    async function runAllTests() {
      testResults = [];
      document.getElementById('testResults').innerHTML = '';
      clearLogs();
      
      log(1, 'Starting automated test suite...', 'info');
      log(2, 'Starting automated test suite...', 'info');
      
      try {
        // Test 1: Node Initialization
        await testNodeInitialization();
        
        // Test 2: Network Connectivity  
        await testNetworkConnectivity();
        
        // Test 3: Peer Discovery
        await testPeerDiscovery();
        
        // Test 4: State Synchronization
        await testStateSynchronization();
        
        // Test 5: Message Exchange
        await testMessageExchange();
        
        // Summary
        const passed = testResults.filter(r => r.passed).length;
        const total = testResults.length;
        log(1, `Tests complete: ${passed}/${total} passed`, passed === total ? 'success' : 'error');
        log(2, `Tests complete: ${passed}/${total} passed`, passed === total ? 'success' : 'error');
        
      } catch (error) {
        log(1, `Test suite failed: ${error.message}`, 'error');
        log(2, `Test suite failed: ${error.message}`, 'error');
        addTestResult('Test Suite', false, error.message);
      }
    }
    
    async function testNodeInitialization() {
      log(1, 'TEST: Node Initialization', 'info');
      log(2, 'TEST: Node Initialization', 'info');
      
      try {
        node1 = await initializeNode(1);
        node2 = await initializeNode(2);
        
        const status1 = node1.getStatus();
        const status2 = node2.getStatus();
        
        if (status1.isInitialized && status2.isInitialized) {
          addTestResult('Node Initialization', true, 'Both nodes initialized successfully');
          log(1, 'Node 1 peer ID: ' + status1.network.peerId, 'info');
          log(2, 'Node 2 peer ID: ' + status2.network.peerId, 'info');
        } else {
          throw new Error('Node initialization incomplete');
        }
      } catch (error) {
        addTestResult('Node Initialization', false, error.message);
        throw error;
      }
    }
    
    async function testNetworkConnectivity() {
      log(1, 'TEST: Network Connectivity', 'info');
      log(2, 'TEST: Network Connectivity', 'info');
      
      try {
        // Wait for connections to establish
        await new Promise(resolve => setTimeout(resolve, 3000));
        
        const status1 = node1.getStatus();
        const status2 = node2.getStatus();
        
        log(1, `Connections: ${status1.network.connections}`, 'info');
        log(2, `Connections: ${status2.network.connections}`, 'info');
        
        if (status1.network.connections > 0 && status2.network.connections > 0) {
          addTestResult('Network Connectivity', true, 
            `Node1: ${status1.network.connections} connections, Node2: ${status2.network.connections} connections`);
        } else {
          addTestResult('Network Connectivity', false, 
            'One or both nodes failed to establish connections');
        }
      } catch (error) {
        addTestResult('Network Connectivity', false, error.message);
      }
    }
    
    async function testPeerDiscovery() {
      log(1, 'TEST: Peer Discovery', 'info');
      log(2, 'TEST: Peer Discovery', 'info');
      
      try {
        // Wait for peer discovery
        await new Promise(resolve => setTimeout(resolve, 5000));
        
        const status1 = node1.getStatus();
        const status2 = node2.getStatus();
        
        log(1, `Discovered peers: ${status1.network.peerCount}`, 'info');
        log(2, `Discovered peers: ${status2.network.peerCount}`, 'info');
        
        // Check if nodes discovered each other
        const networkMgr1 = node1.getNetworkManager();
        const networkMgr2 = node2.getNetworkManager();
        
        const peers1 = networkMgr1.getConnectedPeers();
        const peers2 = networkMgr2.getConnectedPeers();
        
        log(1, `Connected to: ${peers1.map(p => p.peerId.substring(0,8)).join(', ')}`, 'info');
        log(2, `Connected to: ${peers2.map(p => p.peerId.substring(0,8)).join(', ')}`, 'info');
        
        // Check if they're connected to each other
        const node1PeerId = status1.network.peerId;
        const node2PeerId = status2.network.peerId;
        
        const node1FoundNode2 = peers1.some(p => p.peerId === node2PeerId);
        const node2FoundNode1 = peers2.some(p => p.peerId === node1PeerId);
        
        if (node1FoundNode2 && node2FoundNode1) {
          addTestResult('Peer Discovery', true, 'Nodes successfully discovered each other');
          log(1, 'âœ“ Found Node 2', 'success');
          log(2, 'âœ“ Found Node 1', 'success');
        } else {
          addTestResult('Peer Discovery', false, 
            `Node1 found Node2: ${node1FoundNode2}, Node2 found Node1: ${node2FoundNode1}`);
          log(1, node1FoundNode2 ? 'âœ“ Found Node 2' : 'âœ— Did not find Node 2', 
            node1FoundNode2 ? 'success' : 'error');
          log(2, node2FoundNode1 ? 'âœ“ Found Node 1' : 'âœ— Did not find Node 1', 
            node2FoundNode1 ? 'success' : 'error');
        }
      } catch (error) {
        addTestResult('Peer Discovery', false, error.message);
      }
    }
    
    async function testStateSynchronization() {
      log(1, 'TEST: State Synchronization', 'info');
      log(2, 'TEST: State Synchronization', 'info');
      
      try {
        const testKey = 'test-sync-' + Date.now();
        const testValue = 'Hello from Node 1';
        
        // Write to node 1
        node1.getStateManager().write(testKey, testValue);
        log(1, `Wrote: ${testKey} = ${testValue}`, 'info');
        
        // Wait for sync
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Read from node 2
        const readValue = node2.getStateManager().read(testKey);
        log(2, `Read: ${testKey} = ${readValue}`, 'info');
        
        if (readValue === testValue) {
          addTestResult('State Synchronization', true, 
            'State successfully synchronized between nodes');
          log(2, 'âœ“ State sync successful', 'success');
        } else {
          addTestResult('State Synchronization', false, 
            `Expected: ${testValue}, Got: ${readValue}`);
          log(2, 'âœ— State sync failed', 'error');
        }
      } catch (error) {
        addTestResult('State Synchronization', false, error.message);
      }
    }
    
    async function testMessageExchange() {
      log(1, 'TEST: Message Exchange', 'info');
      log(2, 'TEST: Message Exchange', 'info');
      
      try {
        const status2 = node2.getStatus();
        const node2PeerId = status2.network.peerId;
        
        // Send message from node 1 to node 2
        const networkMgr1 = node1.getNetworkManager();
        await networkMgr1.sendToPeer(node2PeerId, {
          type: 'test-message',
          data: { text: 'Hello Node 2!' }
        });
        
        log(1, 'Sent test message to Node 2', 'info');
        log(2, 'Awaiting message from Node 1...', 'info');
        
        // Wait a bit
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        addTestResult('Message Exchange', true, 'Message sent (receiving not yet verified)');
        
      } catch (error) {
        addTestResult('Message Exchange', false, error.message);
      }
    }
    
    async function runConnectivityTest() {
      document.getElementById('testResults').innerHTML = '';
      clearLogs();
      await testNodeInitialization();
      await testNetworkConnectivity();
    }
    
    async function runStateSync() {
      if (!node1 || !node2) {
        log(1, 'Nodes not initialized. Run full test suite first.', 'error');
        return;
      }
      await testStateSynchronization();
    }
    
    function clearLogs() {
      document.getElementById('node1Log').innerHTML = '';
      document.getElementById('node2Log').innerHTML = '';
    }
    
    // Auto-start on load
    log(1, 'Automated test suite ready. Click "Run All Tests" to begin.', 'info');
    log(2, 'Automated test suite ready. Click "Run All Tests" to begin.', 'info');
  </script>
</body>
</html>
