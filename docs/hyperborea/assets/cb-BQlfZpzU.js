var s5=Object.defineProperty;var gA=r=>{throw TypeError(r)};var o5=(r,e,t)=>e in r?s5(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var f=(r,e,t)=>o5(r,typeof e!="symbol"?e+"":e,t),hb=(r,e,t)=>e.has(r)||gA("Cannot "+t);var N=(r,e,t)=>(hb(r,e,"read from private field"),t?t.call(r):e.get(r)),xe=(r,e,t)=>e.has(r)?gA("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),_e=(r,e,t,n)=>(hb(r,e,"write to private field"),n?n.call(r,t):e.set(r,t),t),be=(r,e,t)=>(hb(r,e,"access private method"),t);var Ti=(r,e,t,n)=>({set _(i){_e(r,e,i,t)},get _(){return N(r,e,n)}});(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))n(i);new MutationObserver(i=>{for(const s of i)if(s.type==="childList")for(const o of s.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&n(o)}).observe(document,{childList:!0,subtree:!0});function t(i){const s={};return i.integrity&&(s.integrity=i.integrity),i.referrerPolicy&&(s.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?s.credentials="include":i.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function n(i){if(i.ep)return;i.ep=!0;const s=t(i);fetch(i.href,s)}})();/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const e0="160",a5={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},c5={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},DD=0,sx=1,LD=2,l5=3,u5=0,_E=1,xE=2,hs=3,Mo=0,yr=1,qi=2,h5=2,wo=0,xc=1,oa=2,ox=3,ax=4,ND=5,aa=100,OD=101,UD=102,cx=103,lx=104,kD=200,BD=201,FD=202,$D=203,kg=204,Bg=205,zD=206,VD=207,HD=208,GD=209,WD=210,qD=211,KD=212,XD=213,YD=214,ZD=0,JD=1,jD=2,Vd=3,QD=4,eL=5,tL=6,nL=7,Jf=0,rL=1,iL=2,vo=0,sL=1,oL=2,aL=3,cL=4,lL=5,uL=6,ux="attached",hL="detached",t0=300,Ao=301,xa=302,Hd=303,Gd=304,fh=306,Wd=1e3,gr=1001,qd=1002,ln=1003,Fg=1004,d5=1004,Ed=1005,f5=1005,un=1006,SE=1007,p5=1007,Sa=1008,m5=1008,_o=1009,dL=1010,fL=1011,n0=1012,EE=1013,io=1014,Ki=1015,ku=1016,ME=1017,AE=1018,ya=1020,pL=1021,kr=1023,mL=1024,gL=1025,ba=1026,Ic=1027,yL=1028,TE=1029,bL=1030,CE=1031,IE=1033,ag=33776,cg=33777,lg=33778,ug=33779,hx=35840,dx=35841,fx=35842,px=35843,PE=36196,mx=37492,gx=37496,yx=37808,bx=37809,wx=37810,vx=37811,_x=37812,xx=37813,Sx=37814,Ex=37815,Mx=37816,Ax=37817,Tx=37818,Cx=37819,Ix=37820,Px=37821,hg=36492,Rx=36494,Dx=36495,wL=36283,Lx=36284,Nx=36285,Ox=36286,vL=2200,_L=2201,xL=2202,Kd=2300,Xd=2301,dg=2302,rc=2400,ic=2401,Yd=2402,r0=2500,RE=2501,g5=0,y5=1,b5=2,DE=3e3,wa=3001,SL=3200,EL=3201,Ra=0,ML=1,ti="",bn="srgb",Ts="srgb-linear",i0="display-p3",jf="display-p3-linear",Zd="linear",Ft="srgb",Jd="rec709",jd="p3",w5=0,Ya=7680,v5=7681,_5=7682,x5=7683,S5=34055,E5=34056,M5=5386,A5=512,T5=513,C5=514,I5=515,P5=516,R5=517,D5=518,Ux=519,AL=512,TL=513,CL=514,LE=515,IL=516,PL=517,RL=518,DL=519,Qd=35044,L5=35048,N5=35040,O5=35045,U5=35049,k5=35041,B5=35046,F5=35050,$5=35042,z5="100",kx="300 es",$g=1035,Xi=2e3,Bu=2001;class Do{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[e]===void 0&&(n[e]=[]),n[e].indexOf(t)===-1&&n[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const n=this._listeners;return n[e]!==void 0&&n[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const i=this._listeners[e];if(i!==void 0){const s=i.indexOf(t);s!==-1&&i.splice(s,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const n=this._listeners[e.type];if(n!==void 0){e.target=this;const i=n.slice(0);for(let s=0,o=i.length;s<o;s++)i[s].call(this,e);e.target=null}}}const qn=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let yA=1234567;const Sc=Math.PI/180,Fu=180/Math.PI;function ii(){const r=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(qn[r&255]+qn[r>>8&255]+qn[r>>16&255]+qn[r>>24&255]+"-"+qn[e&255]+qn[e>>8&255]+"-"+qn[e>>16&15|64]+qn[e>>24&255]+"-"+qn[t&63|128]+qn[t>>8&255]+"-"+qn[t>>16&255]+qn[t>>24&255]+qn[n&255]+qn[n>>8&255]+qn[n>>16&255]+qn[n>>24&255]).toLowerCase()}function rn(r,e,t){return Math.max(e,Math.min(t,r))}function NE(r,e){return(r%e+e)%e}function V5(r,e,t,n,i){return n+(r-e)*(i-n)/(t-e)}function H5(r,e,t){return r!==e?(t-r)/(e-r):0}function Md(r,e,t){return(1-t)*r+t*e}function G5(r,e,t,n){return Md(r,e,1-Math.exp(-t*n))}function W5(r,e=1){return e-Math.abs(NE(r,e*2)-e)}function q5(r,e,t){return r<=e?0:r>=t?1:(r=(r-e)/(t-e),r*r*(3-2*r))}function K5(r,e,t){return r<=e?0:r>=t?1:(r=(r-e)/(t-e),r*r*r*(r*(r*6-15)+10))}function X5(r,e){return r+Math.floor(Math.random()*(e-r+1))}function Y5(r,e){return r+Math.random()*(e-r)}function Z5(r){return r*(.5-Math.random())}function J5(r){r!==void 0&&(yA=r);let e=yA+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}function j5(r){return r*Sc}function Q5(r){return r*Fu}function Bx(r){return(r&r-1)===0&&r!==0}function eF(r){return Math.pow(2,Math.ceil(Math.log(r)/Math.LN2))}function zg(r){return Math.pow(2,Math.floor(Math.log(r)/Math.LN2))}function tF(r,e,t,n,i){const s=Math.cos,o=Math.sin,a=s(t/2),c=o(t/2),l=s((e+n)/2),u=o((e+n)/2),h=s((e-n)/2),d=o((e-n)/2),m=s((n-e)/2),p=o((n-e)/2);switch(i){case"XYX":r.set(a*u,c*h,c*d,a*l);break;case"YZY":r.set(c*d,a*u,c*h,a*l);break;case"ZXZ":r.set(c*h,c*d,a*u,a*l);break;case"XZX":r.set(a*u,c*p,c*m,a*l);break;case"YXY":r.set(c*m,a*u,c*p,a*l);break;case"ZYZ":r.set(c*p,c*m,a*u,a*l);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}function Br(r,e){switch(e.constructor){case Float32Array:return r;case Uint32Array:return r/4294967295;case Uint16Array:return r/65535;case Uint8Array:return r/255;case Int32Array:return Math.max(r/2147483647,-1);case Int16Array:return Math.max(r/32767,-1);case Int8Array:return Math.max(r/127,-1);default:throw new Error("Invalid component type.")}}function tt(r,e){switch(e.constructor){case Float32Array:return r;case Uint32Array:return Math.round(r*4294967295);case Uint16Array:return Math.round(r*65535);case Uint8Array:return Math.round(r*255);case Int32Array:return Math.round(r*2147483647);case Int16Array:return Math.round(r*32767);case Int8Array:return Math.round(r*127);default:throw new Error("Invalid component type.")}}const nF={DEG2RAD:Sc,RAD2DEG:Fu,generateUUID:ii,clamp:rn,euclideanModulo:NE,mapLinear:V5,inverseLerp:H5,lerp:Md,damp:G5,pingpong:W5,smoothstep:q5,smootherstep:K5,randInt:X5,randFloat:Y5,randFloatSpread:Z5,seededRandom:J5,degToRad:j5,radToDeg:Q5,isPowerOfTwo:Bx,ceilPowerOfTwo:eF,floorPowerOfTwo:zg,setQuaternionFromProperEuler:tF,normalize:tt,denormalize:Br};class se{constructor(e=0,t=0){se.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,n=this.y,i=e.elements;return this.x=i[0]*t+i[3]*n+i[6],this.y=i[1]*t+i[4]*n+i[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(rn(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const n=Math.cos(t),i=Math.sin(t),s=this.x-e.x,o=this.y-e.y;return this.x=s*n-o*i+e.x,this.y=s*i+o*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class rt{constructor(e,t,n,i,s,o,a,c,l){rt.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],e!==void 0&&this.set(e,t,n,i,s,o,a,c,l)}set(e,t,n,i,s,o,a,c,l){const u=this.elements;return u[0]=e,u[1]=i,u[2]=a,u[3]=t,u[4]=s,u[5]=c,u[6]=n,u[7]=o,u[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,i=t.elements,s=this.elements,o=n[0],a=n[3],c=n[6],l=n[1],u=n[4],h=n[7],d=n[2],m=n[5],p=n[8],b=i[0],g=i[3],y=i[6],v=i[1],w=i[4],_=i[7],M=i[2],E=i[5],C=i[8];return s[0]=o*b+a*v+c*M,s[3]=o*g+a*w+c*E,s[6]=o*y+a*_+c*C,s[1]=l*b+u*v+h*M,s[4]=l*g+u*w+h*E,s[7]=l*y+u*_+h*C,s[2]=d*b+m*v+p*M,s[5]=d*g+m*w+p*E,s[8]=d*y+m*_+p*C,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[1],i=e[2],s=e[3],o=e[4],a=e[5],c=e[6],l=e[7],u=e[8];return t*o*u-t*a*l-n*s*u+n*a*c+i*s*l-i*o*c}invert(){const e=this.elements,t=e[0],n=e[1],i=e[2],s=e[3],o=e[4],a=e[5],c=e[6],l=e[7],u=e[8],h=u*o-a*l,d=a*c-u*s,m=l*s-o*c,p=t*h+n*d+i*m;if(p===0)return this.set(0,0,0,0,0,0,0,0,0);const b=1/p;return e[0]=h*b,e[1]=(i*l-u*n)*b,e[2]=(a*n-i*o)*b,e[3]=d*b,e[4]=(u*t-i*c)*b,e[5]=(i*s-a*t)*b,e[6]=m*b,e[7]=(n*c-l*t)*b,e[8]=(o*t-n*s)*b,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,i,s,o,a){const c=Math.cos(s),l=Math.sin(s);return this.set(n*c,n*l,-n*(c*o+l*a)+o+e,-i*l,i*c,-i*(-l*o+c*a)+a+t,0,0,1),this}scale(e,t){return this.premultiply(db.makeScale(e,t)),this}rotate(e){return this.premultiply(db.makeRotation(-e)),this}translate(e,t){return this.premultiply(db.makeTranslation(e,t)),this}makeTranslation(e,t){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,t,0,0,1),this}makeRotation(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,n,t,0,0,0,1),this}makeScale(e,t){return this.set(e,0,0,0,t,0,0,0,1),this}equals(e){const t=this.elements,n=e.elements;for(let i=0;i<9;i++)if(t[i]!==n[i])return!1;return!0}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const db=new rt;function LL(r){for(let e=r.length-1;e>=0;--e)if(r[e]>=65535)return!0;return!1}const rF={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function Rl(r,e){return new rF[r](e)}function ef(r){return document.createElementNS("http://www.w3.org/1999/xhtml",r)}function NL(){const r=ef("canvas");return r.style.display="block",r}const bA={};function Ad(r){r in bA||(bA[r]=!0,console.warn(r))}const wA=new rt().set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),vA=new rt().set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),Mp={[Ts]:{transfer:Zd,primaries:Jd,toReference:r=>r,fromReference:r=>r},[bn]:{transfer:Ft,primaries:Jd,toReference:r=>r.convertSRGBToLinear(),fromReference:r=>r.convertLinearToSRGB()},[jf]:{transfer:Zd,primaries:jd,toReference:r=>r.applyMatrix3(vA),fromReference:r=>r.applyMatrix3(wA)},[i0]:{transfer:Ft,primaries:jd,toReference:r=>r.convertSRGBToLinear().applyMatrix3(vA),fromReference:r=>r.applyMatrix3(wA).convertLinearToSRGB()}},iF=new Set([Ts,jf]),Ct={enabled:!0,_workingColorSpace:Ts,get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(r){if(!iF.has(r))throw new Error(`Unsupported working color space, "${r}".`);this._workingColorSpace=r},convert:function(r,e,t){if(this.enabled===!1||e===t||!e||!t)return r;const n=Mp[e].toReference,i=Mp[t].fromReference;return i(n(r))},fromWorkingColorSpace:function(r,e){return this.convert(r,this._workingColorSpace,e)},toWorkingColorSpace:function(r,e){return this.convert(r,e,this._workingColorSpace)},getPrimaries:function(r){return Mp[r].primaries},getTransfer:function(r){return r===ti?Zd:Mp[r].transfer}};function Xl(r){return r<.04045?r*.0773993808:Math.pow(r*.9478672986+.0521327014,2.4)}function fb(r){return r<.0031308?r*12.92:1.055*Math.pow(r,.41666)-.055}let rl;class OE{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{rl===void 0&&(rl=ef("canvas")),rl.width=e.width,rl.height=e.height;const n=rl.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height),t=rl}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const t=ef("canvas");t.width=e.width,t.height=e.height;const n=t.getContext("2d");n.drawImage(e,0,0,e.width,e.height);const i=n.getImageData(0,0,e.width,e.height),s=i.data;for(let o=0;o<s.length;o++)s[o]=Xl(s[o]/255)*255;return n.putImageData(i,0,0),t}else if(e.data){const t=e.data.slice(0);for(let n=0;n<t.length;n++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[n]=Math.floor(Xl(t[n]/255)*255):t[n]=Xl(t[n]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}let sF=0;class sc{constructor(e=null){this.isSource=!0,Object.defineProperty(this,"id",{value:sF++}),this.uuid=ii(),this.data=e,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const n={uuid:this.uuid,url:""},i=this.data;if(i!==null){let s;if(Array.isArray(i)){s=[];for(let o=0,a=i.length;o<a;o++)i[o].isDataTexture?s.push(pb(i[o].image)):s.push(pb(i[o]))}else s=pb(i);n.url=s}return t||(e.images[this.uuid]=n),n}}function pb(r){return typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&r instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&r instanceof ImageBitmap?OE.getDataURL(r):r.data?{data:Array.from(r.data),width:r.width,height:r.height,type:r.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let oF=0;class hn extends Do{constructor(e=hn.DEFAULT_IMAGE,t=hn.DEFAULT_MAPPING,n=gr,i=gr,s=un,o=Sa,a=kr,c=_o,l=hn.DEFAULT_ANISOTROPY,u=ti){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:oF++}),this.uuid=ii(),this.name="",this.source=new sc(e),this.mipmaps=[],this.mapping=t,this.channel=0,this.wrapS=n,this.wrapT=i,this.magFilter=s,this.minFilter=o,this.anisotropy=l,this.format=a,this.internalFormat=null,this.type=c,this.offset=new se(0,0),this.repeat=new se(1,1),this.center=new se(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new rt,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,typeof u=="string"?this.colorSpace=u:(Ad("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=u===wa?bn:ti),this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.channel=e.channel,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.colorSpace=e.colorSpace,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const n={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(n.userData=this.userData),t||(e.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==t0)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case Wd:e.x=e.x-Math.floor(e.x);break;case gr:e.x=e.x<0?0:1;break;case qd:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case Wd:e.y=e.y-Math.floor(e.y);break;case gr:e.y=e.y<0?0:1;break;case qd:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}get encoding(){return Ad("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace===bn?wa:DE}set encoding(e){Ad("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=e===wa?bn:ti}}hn.DEFAULT_IMAGE=null;hn.DEFAULT_MAPPING=t0;hn.DEFAULT_ANISOTROPY=1;class mt{constructor(e=0,t=0,n=0,i=1){mt.prototype.isVector4=!0,this.x=e,this.y=t,this.z=n,this.w=i}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,n,i){return this.x=e,this.y=t,this.z=n,this.w=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,n=this.y,i=this.z,s=this.w,o=e.elements;return this.x=o[0]*t+o[4]*n+o[8]*i+o[12]*s,this.y=o[1]*t+o[5]*n+o[9]*i+o[13]*s,this.z=o[2]*t+o[6]*n+o[10]*i+o[14]*s,this.w=o[3]*t+o[7]*n+o[11]*i+o[15]*s,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,n,i,s;const c=e.elements,l=c[0],u=c[4],h=c[8],d=c[1],m=c[5],p=c[9],b=c[2],g=c[6],y=c[10];if(Math.abs(u-d)<.01&&Math.abs(h-b)<.01&&Math.abs(p-g)<.01){if(Math.abs(u+d)<.1&&Math.abs(h+b)<.1&&Math.abs(p+g)<.1&&Math.abs(l+m+y-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const w=(l+1)/2,_=(m+1)/2,M=(y+1)/2,E=(u+d)/4,C=(h+b)/4,I=(p+g)/4;return w>_&&w>M?w<.01?(n=0,i=.707106781,s=.707106781):(n=Math.sqrt(w),i=E/n,s=C/n):_>M?_<.01?(n=.707106781,i=0,s=.707106781):(i=Math.sqrt(_),n=E/i,s=I/i):M<.01?(n=.707106781,i=.707106781,s=0):(s=Math.sqrt(M),n=C/s,i=I/s),this.set(n,i,s,t),this}let v=Math.sqrt((g-p)*(g-p)+(h-b)*(h-b)+(d-u)*(d-u));return Math.abs(v)<.001&&(v=1),this.x=(g-p)/v,this.y=(h-b)/v,this.z=(d-u)/v,this.w=Math.acos((l+m+y-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this.w=e.w+(t.w-e.w)*n,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class OL extends Do{constructor(e=1,t=1,n={}){super(),this.isRenderTarget=!0,this.width=e,this.height=t,this.depth=1,this.scissor=new mt(0,0,e,t),this.scissorTest=!1,this.viewport=new mt(0,0,e,t);const i={width:e,height:t,depth:1};n.encoding!==void 0&&(Ad("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."),n.colorSpace=n.encoding===wa?bn:ti),n=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:un,depthBuffer:!0,stencilBuffer:!1,depthTexture:null,samples:0},n),this.texture=new hn(i,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=n.generateMipmaps,this.texture.internalFormat=n.internalFormat,this.depthBuffer=n.depthBuffer,this.stencilBuffer=n.stencilBuffer,this.depthTexture=n.depthTexture,this.samples=n.samples}setSize(e,t,n=1){(this.width!==e||this.height!==t||this.depth!==n)&&(this.width=e,this.height=t,this.depth=n,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.isRenderTargetTexture=!0;const t=Object.assign({},e.texture.image);return this.texture.source=new sc(t),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class ts extends OL{constructor(e=1,t=1,n={}){super(e,t,n),this.isWebGLRenderTarget=!0}}class s0 extends hn{constructor(e=null,t=1,n=1,i=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:n,depth:i},this.magFilter=ln,this.minFilter=ln,this.wrapR=gr,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class aF extends ts{constructor(e=1,t=1,n=1,i={}){super(e,t,i),this.isWebGLArrayRenderTarget=!0,this.depth=n,this.texture=new s0(null,e,t,n),this.texture.isRenderTargetTexture=!0}}class UE extends hn{constructor(e=null,t=1,n=1,i=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:n,depth:i},this.magFilter=ln,this.minFilter=ln,this.wrapR=gr,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class cF extends ts{constructor(e=1,t=1,n=1,i={}){super(e,t,i),this.isWebGL3DRenderTarget=!0,this.depth=n,this.texture=new UE(null,e,t,n),this.texture.isRenderTargetTexture=!0}}class lF extends ts{constructor(e=1,t=1,n=1,i={}){super(e,t,i),this.isWebGLMultipleRenderTargets=!0;const s=this.texture;this.texture=[];for(let o=0;o<n;o++)this.texture[o]=s.clone(),this.texture[o].isRenderTargetTexture=!0}setSize(e,t,n=1){if(this.width!==e||this.height!==t||this.depth!==n){this.width=e,this.height=t,this.depth=n;for(let i=0,s=this.texture.length;i<s;i++)this.texture[i].image.width=e,this.texture[i].image.height=t,this.texture[i].image.depth=n;this.dispose()}this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}copy(e){this.dispose(),this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.texture.length=0;for(let t=0,n=e.texture.length;t<n;t++)this.texture[t]=e.texture[t].clone(),this.texture[t].isRenderTargetTexture=!0;return this}}class Hr{constructor(e=0,t=0,n=0,i=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=n,this._w=i}static slerpFlat(e,t,n,i,s,o,a){let c=n[i+0],l=n[i+1],u=n[i+2],h=n[i+3];const d=s[o+0],m=s[o+1],p=s[o+2],b=s[o+3];if(a===0){e[t+0]=c,e[t+1]=l,e[t+2]=u,e[t+3]=h;return}if(a===1){e[t+0]=d,e[t+1]=m,e[t+2]=p,e[t+3]=b;return}if(h!==b||c!==d||l!==m||u!==p){let g=1-a;const y=c*d+l*m+u*p+h*b,v=y>=0?1:-1,w=1-y*y;if(w>Number.EPSILON){const M=Math.sqrt(w),E=Math.atan2(M,y*v);g=Math.sin(g*E)/M,a=Math.sin(a*E)/M}const _=a*v;if(c=c*g+d*_,l=l*g+m*_,u=u*g+p*_,h=h*g+b*_,g===1-a){const M=1/Math.sqrt(c*c+l*l+u*u+h*h);c*=M,l*=M,u*=M,h*=M}}e[t]=c,e[t+1]=l,e[t+2]=u,e[t+3]=h}static multiplyQuaternionsFlat(e,t,n,i,s,o){const a=n[i],c=n[i+1],l=n[i+2],u=n[i+3],h=s[o],d=s[o+1],m=s[o+2],p=s[o+3];return e[t]=a*p+u*h+c*m-l*d,e[t+1]=c*p+u*d+l*h-a*m,e[t+2]=l*p+u*m+a*d-c*h,e[t+3]=u*p-a*h-c*d-l*m,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,n,i){return this._x=e,this._y=t,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t=!0){const n=e._x,i=e._y,s=e._z,o=e._order,a=Math.cos,c=Math.sin,l=a(n/2),u=a(i/2),h=a(s/2),d=c(n/2),m=c(i/2),p=c(s/2);switch(o){case"XYZ":this._x=d*u*h+l*m*p,this._y=l*m*h-d*u*p,this._z=l*u*p+d*m*h,this._w=l*u*h-d*m*p;break;case"YXZ":this._x=d*u*h+l*m*p,this._y=l*m*h-d*u*p,this._z=l*u*p-d*m*h,this._w=l*u*h+d*m*p;break;case"ZXY":this._x=d*u*h-l*m*p,this._y=l*m*h+d*u*p,this._z=l*u*p+d*m*h,this._w=l*u*h-d*m*p;break;case"ZYX":this._x=d*u*h-l*m*p,this._y=l*m*h+d*u*p,this._z=l*u*p-d*m*h,this._w=l*u*h+d*m*p;break;case"YZX":this._x=d*u*h+l*m*p,this._y=l*m*h+d*u*p,this._z=l*u*p-d*m*h,this._w=l*u*h-d*m*p;break;case"XZY":this._x=d*u*h-l*m*p,this._y=l*m*h-d*u*p,this._z=l*u*p+d*m*h,this._w=l*u*h+d*m*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t===!0&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const n=t/2,i=Math.sin(n);return this._x=e.x*i,this._y=e.y*i,this._z=e.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,n=t[0],i=t[4],s=t[8],o=t[1],a=t[5],c=t[9],l=t[2],u=t[6],h=t[10],d=n+a+h;if(d>0){const m=.5/Math.sqrt(d+1);this._w=.25/m,this._x=(u-c)*m,this._y=(s-l)*m,this._z=(o-i)*m}else if(n>a&&n>h){const m=2*Math.sqrt(1+n-a-h);this._w=(u-c)/m,this._x=.25*m,this._y=(i+o)/m,this._z=(s+l)/m}else if(a>h){const m=2*Math.sqrt(1+a-n-h);this._w=(s-l)/m,this._x=(i+o)/m,this._y=.25*m,this._z=(c+u)/m}else{const m=2*Math.sqrt(1+h-n-a);this._w=(o-i)/m,this._x=(s+l)/m,this._y=(c+u)/m,this._z=.25*m}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let n=e.dot(t)+1;return n<Number.EPSILON?(n=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=n):(this._x=0,this._y=-e.z,this._z=e.y,this._w=n)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=n),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(rn(this.dot(e),-1,1)))}rotateTowards(e,t){const n=this.angleTo(e);if(n===0)return this;const i=Math.min(1,t/n);return this.slerp(e,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const n=e._x,i=e._y,s=e._z,o=e._w,a=t._x,c=t._y,l=t._z,u=t._w;return this._x=n*u+o*a+i*l-s*c,this._y=i*u+o*c+s*a-n*l,this._z=s*u+o*l+n*c-i*a,this._w=o*u-n*a-i*c-s*l,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const n=this._x,i=this._y,s=this._z,o=this._w;let a=o*e._w+n*e._x+i*e._y+s*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=o,this._x=n,this._y=i,this._z=s,this;const c=1-a*a;if(c<=Number.EPSILON){const m=1-t;return this._w=m*o+t*this._w,this._x=m*n+t*this._x,this._y=m*i+t*this._y,this._z=m*s+t*this._z,this.normalize(),this}const l=Math.sqrt(c),u=Math.atan2(l,a),h=Math.sin((1-t)*u)/l,d=Math.sin(t*u)/l;return this._w=o*h+this._w*d,this._x=n*h+this._x*d,this._y=i*h+this._y*d,this._z=s*h+this._z*d,this._onChangeCallback(),this}slerpQuaternions(e,t,n){return this.copy(e).slerp(t,n)}random(){const e=Math.random(),t=Math.sqrt(1-e),n=Math.sqrt(e),i=2*Math.PI*Math.random(),s=2*Math.PI*Math.random();return this.set(t*Math.cos(i),n*Math.sin(s),n*Math.cos(s),t*Math.sin(i))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class k{constructor(e=0,t=0,n=0){k.prototype.isVector3=!0,this.x=e,this.y=t,this.z=n}set(e,t,n){return n===void 0&&(n=this.z),this.x=e,this.y=t,this.z=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(_A.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(_A.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,n=this.y,i=this.z,s=e.elements;return this.x=s[0]*t+s[3]*n+s[6]*i,this.y=s[1]*t+s[4]*n+s[7]*i,this.z=s[2]*t+s[5]*n+s[8]*i,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,n=this.y,i=this.z,s=e.elements,o=1/(s[3]*t+s[7]*n+s[11]*i+s[15]);return this.x=(s[0]*t+s[4]*n+s[8]*i+s[12])*o,this.y=(s[1]*t+s[5]*n+s[9]*i+s[13])*o,this.z=(s[2]*t+s[6]*n+s[10]*i+s[14])*o,this}applyQuaternion(e){const t=this.x,n=this.y,i=this.z,s=e.x,o=e.y,a=e.z,c=e.w,l=2*(o*i-a*n),u=2*(a*t-s*i),h=2*(s*n-o*t);return this.x=t+c*l+o*h-a*u,this.y=n+c*u+a*l-s*h,this.z=i+c*h+s*u-o*l,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,n=this.y,i=this.z,s=e.elements;return this.x=s[0]*t+s[4]*n+s[8]*i,this.y=s[1]*t+s[5]*n+s[9]*i,this.z=s[2]*t+s[6]*n+s[10]*i,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const n=e.x,i=e.y,s=e.z,o=t.x,a=t.y,c=t.z;return this.x=i*c-s*a,this.y=s*o-n*c,this.z=n*a-i*o,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)}projectOnPlane(e){return mb.copy(this).projectOnVector(e),this.sub(mb)}reflect(e){return this.sub(mb.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(rn(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y,i=this.z-e.z;return t*t+n*n+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,n){const i=Math.sin(t)*e;return this.x=i*Math.sin(n),this.y=Math.cos(t)*e,this.z=i*Math.cos(n),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,n){return this.x=e*Math.sin(t),this.y=n,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),i=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=i,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=(Math.random()-.5)*2,t=Math.random()*Math.PI*2,n=Math.sqrt(1-e**2);return this.x=n*Math.cos(t),this.y=n*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const mb=new k,_A=new Hr;class br{constructor(e=new k(1/0,1/0,1/0),t=new k(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t+=3)this.expandByPoint(Ci.fromArray(e,t));return this}setFromBufferAttribute(e){this.makeEmpty();for(let t=0,n=e.count;t<n;t++)this.expandByPoint(Ci.fromBufferAttribute(e,t));return this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=Ci.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const n=e.geometry;if(n!==void 0){const s=n.getAttribute("position");if(t===!0&&s!==void 0&&e.isInstancedMesh!==!0)for(let o=0,a=s.count;o<a;o++)e.isMesh===!0?e.getVertexPosition(o,Ci):Ci.fromBufferAttribute(s,o),Ci.applyMatrix4(e.matrixWorld),this.expandByPoint(Ci);else e.boundingBox!==void 0?(e.boundingBox===null&&e.computeBoundingBox(),Ap.copy(e.boundingBox)):(n.boundingBox===null&&n.computeBoundingBox(),Ap.copy(n.boundingBox)),Ap.applyMatrix4(e.matrixWorld),this.union(Ap)}const i=e.children;for(let s=0,o=i.length;s<o;s++)this.expandByObject(i[s],t);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,Ci),Ci.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,n;return e.normal.x>0?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(Oh),Tp.subVectors(this.max,Oh),il.subVectors(e.a,Oh),sl.subVectors(e.b,Oh),ol.subVectors(e.c,Oh),ko.subVectors(sl,il),Bo.subVectors(ol,sl),ka.subVectors(il,ol);let t=[0,-ko.z,ko.y,0,-Bo.z,Bo.y,0,-ka.z,ka.y,ko.z,0,-ko.x,Bo.z,0,-Bo.x,ka.z,0,-ka.x,-ko.y,ko.x,0,-Bo.y,Bo.x,0,-ka.y,ka.x,0];return!gb(t,il,sl,ol,Tp)||(t=[1,0,0,0,1,0,0,0,1],!gb(t,il,sl,ol,Tp))?!1:(Cp.crossVectors(ko,Bo),t=[Cp.x,Cp.y,Cp.z],gb(t,il,sl,ol,Tp))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,Ci).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=this.getSize(Ci).length()*.5),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(Us[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),Us[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),Us[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),Us[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),Us[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),Us[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),Us[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),Us[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(Us),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const Us=[new k,new k,new k,new k,new k,new k,new k,new k],Ci=new k,Ap=new br,il=new k,sl=new k,ol=new k,ko=new k,Bo=new k,ka=new k,Oh=new k,Tp=new k,Cp=new k,Ba=new k;function gb(r,e,t,n,i){for(let s=0,o=r.length-3;s<=o;s+=3){Ba.fromArray(r,s);const a=i.x*Math.abs(Ba.x)+i.y*Math.abs(Ba.y)+i.z*Math.abs(Ba.z),c=e.dot(Ba),l=t.dot(Ba),u=n.dot(Ba);if(Math.max(-Math.max(c,l,u),Math.min(c,l,u))>a)return!1}return!0}const uF=new br,Uh=new k,yb=new k;class Bn{constructor(e=new k,t=-1){this.isSphere=!0,this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const n=this.center;t!==void 0?n.copy(t):uF.setFromPoints(e).getCenter(n);let i=0;for(let s=0,o=e.length;s<o;s++)i=Math.max(i,n.distanceToSquared(e[s]));return this.radius=Math.sqrt(i),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const n=this.center.distanceToSquared(e);return t.copy(e),n>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;Uh.subVectors(e,this.center);const t=Uh.lengthSq();if(t>this.radius*this.radius){const n=Math.sqrt(t),i=(n-this.radius)*.5;this.center.addScaledVector(Uh,i/n),this.radius+=i}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(yb.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(Uh.copy(e.center).add(yb)),this.expandByPoint(Uh.copy(e.center).sub(yb))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const ks=new k,bb=new k,Ip=new k,Fo=new k,wb=new k,Pp=new k,vb=new k;class ph{constructor(e=new k,t=new k(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,ks)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.origin).addScaledVector(this.direction,n)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=ks.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(ks.copy(this.origin).addScaledVector(this.direction,t),ks.distanceToSquared(e))}distanceSqToSegment(e,t,n,i){bb.copy(e).add(t).multiplyScalar(.5),Ip.copy(t).sub(e).normalize(),Fo.copy(this.origin).sub(bb);const s=e.distanceTo(t)*.5,o=-this.direction.dot(Ip),a=Fo.dot(this.direction),c=-Fo.dot(Ip),l=Fo.lengthSq(),u=Math.abs(1-o*o);let h,d,m,p;if(u>0)if(h=o*c-a,d=o*a-c,p=s*u,h>=0)if(d>=-p)if(d<=p){const b=1/u;h*=b,d*=b,m=h*(h+o*d+2*a)+d*(o*h+d+2*c)+l}else d=s,h=Math.max(0,-(o*d+a)),m=-h*h+d*(d+2*c)+l;else d=-s,h=Math.max(0,-(o*d+a)),m=-h*h+d*(d+2*c)+l;else d<=-p?(h=Math.max(0,-(-o*s+a)),d=h>0?-s:Math.min(Math.max(-s,-c),s),m=-h*h+d*(d+2*c)+l):d<=p?(h=0,d=Math.min(Math.max(-s,-c),s),m=d*(d+2*c)+l):(h=Math.max(0,-(o*s+a)),d=h>0?s:Math.min(Math.max(-s,-c),s),m=-h*h+d*(d+2*c)+l);else d=o>0?-s:s,h=Math.max(0,-(o*d+a)),m=-h*h+d*(d+2*c)+l;return n&&n.copy(this.origin).addScaledVector(this.direction,h),i&&i.copy(bb).addScaledVector(Ip,d),m}intersectSphere(e,t){ks.subVectors(e.center,this.origin);const n=ks.dot(this.direction),i=ks.dot(ks)-n*n,s=e.radius*e.radius;if(i>s)return null;const o=Math.sqrt(s-i),a=n-o,c=n+o;return c<0?null:a<0?this.at(c,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null}intersectPlane(e,t){const n=this.distanceToPlane(e);return n===null?null:this.at(n,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let n,i,s,o,a,c;const l=1/this.direction.x,u=1/this.direction.y,h=1/this.direction.z,d=this.origin;return l>=0?(n=(e.min.x-d.x)*l,i=(e.max.x-d.x)*l):(n=(e.max.x-d.x)*l,i=(e.min.x-d.x)*l),u>=0?(s=(e.min.y-d.y)*u,o=(e.max.y-d.y)*u):(s=(e.max.y-d.y)*u,o=(e.min.y-d.y)*u),n>o||s>i||((s>n||isNaN(n))&&(n=s),(o<i||isNaN(i))&&(i=o),h>=0?(a=(e.min.z-d.z)*h,c=(e.max.z-d.z)*h):(a=(e.max.z-d.z)*h,c=(e.min.z-d.z)*h),n>c||a>i)||((a>n||n!==n)&&(n=a),(c<i||i!==i)&&(i=c),i<0)?null:this.at(n>=0?n:i,t)}intersectsBox(e){return this.intersectBox(e,ks)!==null}intersectTriangle(e,t,n,i,s){wb.subVectors(t,e),Pp.subVectors(n,e),vb.crossVectors(wb,Pp);let o=this.direction.dot(vb),a;if(o>0){if(i)return null;a=1}else if(o<0)a=-1,o=-o;else return null;Fo.subVectors(this.origin,e);const c=a*this.direction.dot(Pp.crossVectors(Fo,Pp));if(c<0)return null;const l=a*this.direction.dot(wb.cross(Fo));if(l<0||c+l>o)return null;const u=-a*Fo.dot(vb);return u<0?null:this.at(u/o,s)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class $e{constructor(e,t,n,i,s,o,a,c,l,u,h,d,m,p,b,g){$e.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],e!==void 0&&this.set(e,t,n,i,s,o,a,c,l,u,h,d,m,p,b,g)}set(e,t,n,i,s,o,a,c,l,u,h,d,m,p,b,g){const y=this.elements;return y[0]=e,y[4]=t,y[8]=n,y[12]=i,y[1]=s,y[5]=o,y[9]=a,y[13]=c,y[2]=l,y[6]=u,y[10]=h,y[14]=d,y[3]=m,y[7]=p,y[11]=b,y[15]=g,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new $e().fromArray(this.elements)}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],this}copyPosition(e){const t=this.elements,n=e.elements;return t[12]=n[12],t[13]=n[13],t[14]=n[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,n){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(e,t,n){return this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,n=e.elements,i=1/al.setFromMatrixColumn(e,0).length(),s=1/al.setFromMatrixColumn(e,1).length(),o=1/al.setFromMatrixColumn(e,2).length();return t[0]=n[0]*i,t[1]=n[1]*i,t[2]=n[2]*i,t[3]=0,t[4]=n[4]*s,t[5]=n[5]*s,t[6]=n[6]*s,t[7]=0,t[8]=n[8]*o,t[9]=n[9]*o,t[10]=n[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){const t=this.elements,n=e.x,i=e.y,s=e.z,o=Math.cos(n),a=Math.sin(n),c=Math.cos(i),l=Math.sin(i),u=Math.cos(s),h=Math.sin(s);if(e.order==="XYZ"){const d=o*u,m=o*h,p=a*u,b=a*h;t[0]=c*u,t[4]=-c*h,t[8]=l,t[1]=m+p*l,t[5]=d-b*l,t[9]=-a*c,t[2]=b-d*l,t[6]=p+m*l,t[10]=o*c}else if(e.order==="YXZ"){const d=c*u,m=c*h,p=l*u,b=l*h;t[0]=d+b*a,t[4]=p*a-m,t[8]=o*l,t[1]=o*h,t[5]=o*u,t[9]=-a,t[2]=m*a-p,t[6]=b+d*a,t[10]=o*c}else if(e.order==="ZXY"){const d=c*u,m=c*h,p=l*u,b=l*h;t[0]=d-b*a,t[4]=-o*h,t[8]=p+m*a,t[1]=m+p*a,t[5]=o*u,t[9]=b-d*a,t[2]=-o*l,t[6]=a,t[10]=o*c}else if(e.order==="ZYX"){const d=o*u,m=o*h,p=a*u,b=a*h;t[0]=c*u,t[4]=p*l-m,t[8]=d*l+b,t[1]=c*h,t[5]=b*l+d,t[9]=m*l-p,t[2]=-l,t[6]=a*c,t[10]=o*c}else if(e.order==="YZX"){const d=o*c,m=o*l,p=a*c,b=a*l;t[0]=c*u,t[4]=b-d*h,t[8]=p*h+m,t[1]=h,t[5]=o*u,t[9]=-a*u,t[2]=-l*u,t[6]=m*h+p,t[10]=d-b*h}else if(e.order==="XZY"){const d=o*c,m=o*l,p=a*c,b=a*l;t[0]=c*u,t[4]=-h,t[8]=l*u,t[1]=d*h+b,t[5]=o*u,t[9]=m*h-p,t[2]=p*h-m,t[6]=a*u,t[10]=b*h+d}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(hF,e,dF)}lookAt(e,t,n){const i=this.elements;return Kr.subVectors(e,t),Kr.lengthSq()===0&&(Kr.z=1),Kr.normalize(),$o.crossVectors(n,Kr),$o.lengthSq()===0&&(Math.abs(n.z)===1?Kr.x+=1e-4:Kr.z+=1e-4,Kr.normalize(),$o.crossVectors(n,Kr)),$o.normalize(),Rp.crossVectors(Kr,$o),i[0]=$o.x,i[4]=Rp.x,i[8]=Kr.x,i[1]=$o.y,i[5]=Rp.y,i[9]=Kr.y,i[2]=$o.z,i[6]=Rp.z,i[10]=Kr.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,i=t.elements,s=this.elements,o=n[0],a=n[4],c=n[8],l=n[12],u=n[1],h=n[5],d=n[9],m=n[13],p=n[2],b=n[6],g=n[10],y=n[14],v=n[3],w=n[7],_=n[11],M=n[15],E=i[0],C=i[4],I=i[8],x=i[12],T=i[1],F=i[5],$=i[9],H=i[13],S=i[2],A=i[6],P=i[10],L=i[14],B=i[3],D=i[7],V=i[11],z=i[15];return s[0]=o*E+a*T+c*S+l*B,s[4]=o*C+a*F+c*A+l*D,s[8]=o*I+a*$+c*P+l*V,s[12]=o*x+a*H+c*L+l*z,s[1]=u*E+h*T+d*S+m*B,s[5]=u*C+h*F+d*A+m*D,s[9]=u*I+h*$+d*P+m*V,s[13]=u*x+h*H+d*L+m*z,s[2]=p*E+b*T+g*S+y*B,s[6]=p*C+b*F+g*A+y*D,s[10]=p*I+b*$+g*P+y*V,s[14]=p*x+b*H+g*L+y*z,s[3]=v*E+w*T+_*S+M*B,s[7]=v*C+w*F+_*A+M*D,s[11]=v*I+w*$+_*P+M*V,s[15]=v*x+w*H+_*L+M*z,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[4],i=e[8],s=e[12],o=e[1],a=e[5],c=e[9],l=e[13],u=e[2],h=e[6],d=e[10],m=e[14],p=e[3],b=e[7],g=e[11],y=e[15];return p*(+s*c*h-i*l*h-s*a*d+n*l*d+i*a*m-n*c*m)+b*(+t*c*m-t*l*d+s*o*d-i*o*m+i*l*u-s*c*u)+g*(+t*l*h-t*a*m-s*o*h+n*o*m+s*a*u-n*l*u)+y*(-i*a*u-t*c*h+t*a*d+i*o*h-n*o*d+n*c*u)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,n){const i=this.elements;return e.isVector3?(i[12]=e.x,i[13]=e.y,i[14]=e.z):(i[12]=e,i[13]=t,i[14]=n),this}invert(){const e=this.elements,t=e[0],n=e[1],i=e[2],s=e[3],o=e[4],a=e[5],c=e[6],l=e[7],u=e[8],h=e[9],d=e[10],m=e[11],p=e[12],b=e[13],g=e[14],y=e[15],v=h*g*l-b*d*l+b*c*m-a*g*m-h*c*y+a*d*y,w=p*d*l-u*g*l-p*c*m+o*g*m+u*c*y-o*d*y,_=u*b*l-p*h*l+p*a*m-o*b*m-u*a*y+o*h*y,M=p*h*c-u*b*c-p*a*d+o*b*d+u*a*g-o*h*g,E=t*v+n*w+i*_+s*M;if(E===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const C=1/E;return e[0]=v*C,e[1]=(b*d*s-h*g*s-b*i*m+n*g*m+h*i*y-n*d*y)*C,e[2]=(a*g*s-b*c*s+b*i*l-n*g*l-a*i*y+n*c*y)*C,e[3]=(h*c*s-a*d*s-h*i*l+n*d*l+a*i*m-n*c*m)*C,e[4]=w*C,e[5]=(u*g*s-p*d*s+p*i*m-t*g*m-u*i*y+t*d*y)*C,e[6]=(p*c*s-o*g*s-p*i*l+t*g*l+o*i*y-t*c*y)*C,e[7]=(o*d*s-u*c*s+u*i*l-t*d*l-o*i*m+t*c*m)*C,e[8]=_*C,e[9]=(p*h*s-u*b*s-p*n*m+t*b*m+u*n*y-t*h*y)*C,e[10]=(o*b*s-p*a*s+p*n*l-t*b*l-o*n*y+t*a*y)*C,e[11]=(u*a*s-o*h*s-u*n*l+t*h*l+o*n*m-t*a*m)*C,e[12]=M*C,e[13]=(u*b*i-p*h*i+p*n*d-t*b*d-u*n*g+t*h*g)*C,e[14]=(p*a*i-o*b*i-p*n*c+t*b*c+o*n*g-t*a*g)*C,e[15]=(o*h*i-u*a*i+u*n*c-t*h*c-o*n*d+t*a*d)*C,this}scale(e){const t=this.elements,n=e.x,i=e.y,s=e.z;return t[0]*=n,t[4]*=i,t[8]*=s,t[1]*=n,t[5]*=i,t[9]*=s,t[2]*=n,t[6]*=i,t[10]*=s,t[3]*=n,t[7]*=i,t[11]*=s,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,i))}makeTranslation(e,t,n){return e.isVector3?this.set(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1):this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),n=Math.sin(e);return this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const n=Math.cos(t),i=Math.sin(t),s=1-n,o=e.x,a=e.y,c=e.z,l=s*o,u=s*a;return this.set(l*o+n,l*a-i*c,l*c+i*a,0,l*a+i*c,u*a+n,u*c-i*o,0,l*c-i*a,u*c+i*o,s*c*c+n,0,0,0,0,1),this}makeScale(e,t,n){return this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1),this}makeShear(e,t,n,i,s,o){return this.set(1,n,s,0,e,1,o,0,t,i,1,0,0,0,0,1),this}compose(e,t,n){const i=this.elements,s=t._x,o=t._y,a=t._z,c=t._w,l=s+s,u=o+o,h=a+a,d=s*l,m=s*u,p=s*h,b=o*u,g=o*h,y=a*h,v=c*l,w=c*u,_=c*h,M=n.x,E=n.y,C=n.z;return i[0]=(1-(b+y))*M,i[1]=(m+_)*M,i[2]=(p-w)*M,i[3]=0,i[4]=(m-_)*E,i[5]=(1-(d+y))*E,i[6]=(g+v)*E,i[7]=0,i[8]=(p+w)*C,i[9]=(g-v)*C,i[10]=(1-(d+b))*C,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}decompose(e,t,n){const i=this.elements;let s=al.set(i[0],i[1],i[2]).length();const o=al.set(i[4],i[5],i[6]).length(),a=al.set(i[8],i[9],i[10]).length();this.determinant()<0&&(s=-s),e.x=i[12],e.y=i[13],e.z=i[14],Ii.copy(this);const l=1/s,u=1/o,h=1/a;return Ii.elements[0]*=l,Ii.elements[1]*=l,Ii.elements[2]*=l,Ii.elements[4]*=u,Ii.elements[5]*=u,Ii.elements[6]*=u,Ii.elements[8]*=h,Ii.elements[9]*=h,Ii.elements[10]*=h,t.setFromRotationMatrix(Ii),n.x=s,n.y=o,n.z=a,this}makePerspective(e,t,n,i,s,o,a=Xi){const c=this.elements,l=2*s/(t-e),u=2*s/(n-i),h=(t+e)/(t-e),d=(n+i)/(n-i);let m,p;if(a===Xi)m=-(o+s)/(o-s),p=-2*o*s/(o-s);else if(a===Bu)m=-o/(o-s),p=-o*s/(o-s);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+a);return c[0]=l,c[4]=0,c[8]=h,c[12]=0,c[1]=0,c[5]=u,c[9]=d,c[13]=0,c[2]=0,c[6]=0,c[10]=m,c[14]=p,c[3]=0,c[7]=0,c[11]=-1,c[15]=0,this}makeOrthographic(e,t,n,i,s,o,a=Xi){const c=this.elements,l=1/(t-e),u=1/(n-i),h=1/(o-s),d=(t+e)*l,m=(n+i)*u;let p,b;if(a===Xi)p=(o+s)*h,b=-2*h;else if(a===Bu)p=s*h,b=-1*h;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+a);return c[0]=2*l,c[4]=0,c[8]=0,c[12]=-d,c[1]=0,c[5]=2*u,c[9]=0,c[13]=-m,c[2]=0,c[6]=0,c[10]=b,c[14]=-p,c[3]=0,c[7]=0,c[11]=0,c[15]=1,this}equals(e){const t=this.elements,n=e.elements;for(let i=0;i<16;i++)if(t[i]!==n[i])return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e[t+9]=n[9],e[t+10]=n[10],e[t+11]=n[11],e[t+12]=n[12],e[t+13]=n[13],e[t+14]=n[14],e[t+15]=n[15],e}}const al=new k,Ii=new $e,hF=new k(0,0,0),dF=new k(1,1,1),$o=new k,Rp=new k,Kr=new k,xA=new $e,SA=new Hr;class Qf{constructor(e=0,t=0,n=0,i=Qf.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=t,this._z=n,this._order=i}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,n,i=this._order){return this._x=e,this._y=t,this._z=n,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,n=!0){const i=e.elements,s=i[0],o=i[4],a=i[8],c=i[1],l=i[5],u=i[9],h=i[2],d=i[6],m=i[10];switch(t){case"XYZ":this._y=Math.asin(rn(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-u,m),this._z=Math.atan2(-o,s)):(this._x=Math.atan2(d,l),this._z=0);break;case"YXZ":this._x=Math.asin(-rn(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(a,m),this._z=Math.atan2(c,l)):(this._y=Math.atan2(-h,s),this._z=0);break;case"ZXY":this._x=Math.asin(rn(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-h,m),this._z=Math.atan2(-o,l)):(this._y=0,this._z=Math.atan2(c,s));break;case"ZYX":this._y=Math.asin(-rn(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(d,m),this._z=Math.atan2(c,s)):(this._x=0,this._z=Math.atan2(-o,l));break;case"YZX":this._z=Math.asin(rn(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(-u,l),this._y=Math.atan2(-h,s)):(this._x=0,this._y=Math.atan2(a,m));break;case"XZY":this._z=Math.asin(-rn(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(d,l),this._y=Math.atan2(a,s)):(this._x=Math.atan2(-u,m),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,n===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,n){return xA.makeRotationFromQuaternion(e),this.setFromRotationMatrix(xA,t,n)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return SA.setFromEuler(this),this.setFromQuaternion(SA,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Qf.DEFAULT_ORDER="XYZ";class o0{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let fF=0;const EA=new k,cl=new Hr,Bs=new $e,Dp=new k,kh=new k,pF=new k,mF=new Hr,MA=new k(1,0,0),AA=new k(0,1,0),TA=new k(0,0,1),gF={type:"added"},yF={type:"removed"};class wt extends Do{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:fF++}),this.uuid=ii(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=wt.DEFAULT_UP.clone();const e=new k,t=new Qf,n=new Hr,i=new k(1,1,1);function s(){n.setFromEuler(t,!1)}function o(){t.setFromQuaternion(n,void 0,!1)}t._onChange(s),n._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new $e},normalMatrix:{value:new rt}}),this.matrix=new $e,this.matrixWorld=new $e,this.matrixAutoUpdate=wt.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=wt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new o0,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return cl.setFromAxisAngle(e,t),this.quaternion.multiply(cl),this}rotateOnWorldAxis(e,t){return cl.setFromAxisAngle(e,t),this.quaternion.premultiply(cl),this}rotateX(e){return this.rotateOnAxis(MA,e)}rotateY(e){return this.rotateOnAxis(AA,e)}rotateZ(e){return this.rotateOnAxis(TA,e)}translateOnAxis(e,t){return EA.copy(e).applyQuaternion(this.quaternion),this.position.add(EA.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(MA,e)}translateY(e){return this.translateOnAxis(AA,e)}translateZ(e){return this.translateOnAxis(TA,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(Bs.copy(this.matrixWorld).invert())}lookAt(e,t,n){e.isVector3?Dp.copy(e):Dp.set(e,t,n);const i=this.parent;this.updateWorldMatrix(!0,!1),kh.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Bs.lookAt(kh,Dp,this.up):Bs.lookAt(Dp,kh,this.up),this.quaternion.setFromRotationMatrix(Bs),i&&(Bs.extractRotation(i.matrixWorld),cl.setFromRotationMatrix(Bs),this.quaternion.premultiply(cl.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(gF)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(yF)),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){return this.remove(...this.children)}attach(e){return this.updateWorldMatrix(!0,!1),Bs.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),Bs.multiply(e.parent.matrixWorld)),e.applyMatrix4(Bs),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let n=0,i=this.children.length;n<i;n++){const o=this.children[n].getObjectByProperty(e,t);if(o!==void 0)return o}}getObjectsByProperty(e,t,n=[]){this[e]===t&&n.push(this);const i=this.children;for(let s=0,o=i.length;s<o;s++)i[s].getObjectsByProperty(e,t,n);return n}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(kh,e,pF),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(kh,mF,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let n=0,i=t.length;n<i;n++){const s=t[n];(s.matrixWorldAutoUpdate===!0||e===!0)&&s.updateMatrixWorld(e)}}updateWorldMatrix(e,t){const n=this.parent;if(e===!0&&n!==null&&n.matrixWorldAutoUpdate===!0&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const i=this.children;for(let s=0,o=i.length;s<o;s++){const a=i[s];a.matrixWorldAutoUpdate===!0&&a.updateWorldMatrix(!1,!0)}}}toJSON(e){const t=e===void 0||typeof e=="string",n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),i.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(i.type="BatchedMesh",i.perObjectFrustumCulled=this.perObjectFrustumCulled,i.sortObjects=this.sortObjects,i.drawRanges=this._drawRanges,i.reservedRanges=this._reservedRanges,i.visibility=this._visibility,i.active=this._active,i.bounds=this._bounds.map(a=>({boxInitialized:a.boxInitialized,boxMin:a.box.min.toArray(),boxMax:a.box.max.toArray(),sphereInitialized:a.sphereInitialized,sphereRadius:a.sphere.radius,sphereCenter:a.sphere.center.toArray()})),i.maxGeometryCount=this._maxGeometryCount,i.maxVertexCount=this._maxVertexCount,i.maxIndexCount=this._maxIndexCount,i.geometryInitialized=this._geometryInitialized,i.geometryCount=this._geometryCount,i.matricesTexture=this._matricesTexture.toJSON(e),this.boundingSphere!==null&&(i.boundingSphere={center:i.boundingSphere.center.toArray(),radius:i.boundingSphere.radius}),this.boundingBox!==null&&(i.boundingBox={min:i.boundingBox.min.toArray(),max:i.boundingBox.max.toArray()}));function s(a,c){return a[c.uuid]===void 0&&(a[c.uuid]=c.toJSON(e)),c.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(i.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=s(e.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const c=a.shapes;if(Array.isArray(c))for(let l=0,u=c.length;l<u;l++){const h=c[l];s(e.shapes,h)}else s(e.shapes,c)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(e.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let c=0,l=this.material.length;c<l;c++)a.push(s(e.materials,this.material[c]));i.material=a}else i.material=s(e.materials,this.material);if(this.children.length>0){i.children=[];for(let a=0;a<this.children.length;a++)i.children.push(this.children[a].toJSON(e).object)}if(this.animations.length>0){i.animations=[];for(let a=0;a<this.animations.length;a++){const c=this.animations[a];i.animations.push(s(e.animations,c))}}if(t){const a=o(e.geometries),c=o(e.materials),l=o(e.textures),u=o(e.images),h=o(e.shapes),d=o(e.skeletons),m=o(e.animations),p=o(e.nodes);a.length>0&&(n.geometries=a),c.length>0&&(n.materials=c),l.length>0&&(n.textures=l),u.length>0&&(n.images=u),h.length>0&&(n.shapes=h),d.length>0&&(n.skeletons=d),m.length>0&&(n.animations=m),p.length>0&&(n.nodes=p)}return n.object=i,n;function o(a){const c=[];for(const l in a){const u=a[l];delete u.metadata,c.push(u)}return c}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.animations=e.animations.slice(),this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let n=0;n<e.children.length;n++){const i=e.children[n];this.add(i.clone())}return this}}wt.DEFAULT_UP=new k(0,1,0);wt.DEFAULT_MATRIX_AUTO_UPDATE=!0;wt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const Pi=new k,Fs=new k,_b=new k,$s=new k,ll=new k,ul=new k,CA=new k,xb=new k,Sb=new k,Eb=new k;let Lp=!1;class Ur{constructor(e=new k,t=new k,n=new k){this.a=e,this.b=t,this.c=n}static getNormal(e,t,n,i){i.subVectors(n,t),Pi.subVectors(e,t),i.cross(Pi);const s=i.lengthSq();return s>0?i.multiplyScalar(1/Math.sqrt(s)):i.set(0,0,0)}static getBarycoord(e,t,n,i,s){Pi.subVectors(i,t),Fs.subVectors(n,t),_b.subVectors(e,t);const o=Pi.dot(Pi),a=Pi.dot(Fs),c=Pi.dot(_b),l=Fs.dot(Fs),u=Fs.dot(_b),h=o*l-a*a;if(h===0)return s.set(0,0,0),null;const d=1/h,m=(l*c-a*u)*d,p=(o*u-a*c)*d;return s.set(1-m-p,p,m)}static containsPoint(e,t,n,i){return this.getBarycoord(e,t,n,i,$s)===null?!1:$s.x>=0&&$s.y>=0&&$s.x+$s.y<=1}static getUV(e,t,n,i,s,o,a,c){return Lp===!1&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),Lp=!0),this.getInterpolation(e,t,n,i,s,o,a,c)}static getInterpolation(e,t,n,i,s,o,a,c){return this.getBarycoord(e,t,n,i,$s)===null?(c.x=0,c.y=0,"z"in c&&(c.z=0),"w"in c&&(c.w=0),null):(c.setScalar(0),c.addScaledVector(s,$s.x),c.addScaledVector(o,$s.y),c.addScaledVector(a,$s.z),c)}static isFrontFacing(e,t,n,i){return Pi.subVectors(n,t),Fs.subVectors(e,t),Pi.cross(Fs).dot(i)<0}set(e,t,n){return this.a.copy(e),this.b.copy(t),this.c.copy(n),this}setFromPointsAndIndices(e,t,n,i){return this.a.copy(e[t]),this.b.copy(e[n]),this.c.copy(e[i]),this}setFromAttributeAndIndices(e,t,n,i){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,n),this.c.fromBufferAttribute(e,i),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return Pi.subVectors(this.c,this.b),Fs.subVectors(this.a,this.b),Pi.cross(Fs).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Ur.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Ur.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,n,i,s){return Lp===!1&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),Lp=!0),Ur.getInterpolation(e,this.a,this.b,this.c,t,n,i,s)}getInterpolation(e,t,n,i,s){return Ur.getInterpolation(e,this.a,this.b,this.c,t,n,i,s)}containsPoint(e){return Ur.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Ur.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const n=this.a,i=this.b,s=this.c;let o,a;ll.subVectors(i,n),ul.subVectors(s,n),xb.subVectors(e,n);const c=ll.dot(xb),l=ul.dot(xb);if(c<=0&&l<=0)return t.copy(n);Sb.subVectors(e,i);const u=ll.dot(Sb),h=ul.dot(Sb);if(u>=0&&h<=u)return t.copy(i);const d=c*h-u*l;if(d<=0&&c>=0&&u<=0)return o=c/(c-u),t.copy(n).addScaledVector(ll,o);Eb.subVectors(e,s);const m=ll.dot(Eb),p=ul.dot(Eb);if(p>=0&&m<=p)return t.copy(s);const b=m*l-c*p;if(b<=0&&l>=0&&p<=0)return a=l/(l-p),t.copy(n).addScaledVector(ul,a);const g=u*p-m*h;if(g<=0&&h-u>=0&&m-p>=0)return CA.subVectors(s,i),a=(h-u)/(h-u+(m-p)),t.copy(i).addScaledVector(CA,a);const y=1/(g+b+d);return o=b*y,a=d*y,t.copy(n).addScaledVector(ll,o).addScaledVector(ul,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const UL={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},zo={h:0,s:0,l:0},Np={h:0,s:0,l:0};function Mb(r,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?r+(e-r)*6*t:t<1/2?e:t<2/3?r+(e-r)*6*(2/3-t):r}class ye{constructor(e,t,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,t,n)}set(e,t,n){if(t===void 0&&n===void 0){const i=e;i&&i.isColor?this.copy(i):typeof i=="number"?this.setHex(i):typeof i=="string"&&this.setStyle(i)}else this.setRGB(e,t,n);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=bn){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,Ct.toWorkingColorSpace(this,t),this}setRGB(e,t,n,i=Ct.workingColorSpace){return this.r=e,this.g=t,this.b=n,Ct.toWorkingColorSpace(this,i),this}setHSL(e,t,n,i=Ct.workingColorSpace){if(e=NE(e,1),t=rn(t,0,1),n=rn(n,0,1),t===0)this.r=this.g=this.b=n;else{const s=n<=.5?n*(1+t):n+t-n*t,o=2*n-s;this.r=Mb(o,s,e+1/3),this.g=Mb(o,s,e),this.b=Mb(o,s,e-1/3)}return Ct.toWorkingColorSpace(this,i),this}setStyle(e,t=bn){function n(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let i;if(i=/^(\w+)\(([^\)]*)\)/.exec(e)){let s;const o=i[1],a=i[2];switch(o){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return n(s[4]),this.setRGB(Math.min(255,parseInt(s[1],10))/255,Math.min(255,parseInt(s[2],10))/255,Math.min(255,parseInt(s[3],10))/255,t);if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return n(s[4]),this.setRGB(Math.min(100,parseInt(s[1],10))/100,Math.min(100,parseInt(s[2],10))/100,Math.min(100,parseInt(s[3],10))/100,t);break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return n(s[4]),this.setHSL(parseFloat(s[1])/360,parseFloat(s[2])/100,parseFloat(s[3])/100,t);break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(e)){const s=i[1],o=s.length;if(o===3)return this.setRGB(parseInt(s.charAt(0),16)/15,parseInt(s.charAt(1),16)/15,parseInt(s.charAt(2),16)/15,t);if(o===6)return this.setHex(parseInt(s,16),t);console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,t);return this}setColorName(e,t=bn){const n=UL[e.toLowerCase()];return n!==void 0?this.setHex(n,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=Xl(e.r),this.g=Xl(e.g),this.b=Xl(e.b),this}copyLinearToSRGB(e){return this.r=fb(e.r),this.g=fb(e.g),this.b=fb(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=bn){return Ct.fromWorkingColorSpace(Kn.copy(this),e),Math.round(rn(Kn.r*255,0,255))*65536+Math.round(rn(Kn.g*255,0,255))*256+Math.round(rn(Kn.b*255,0,255))}getHexString(e=bn){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=Ct.workingColorSpace){Ct.fromWorkingColorSpace(Kn.copy(this),t);const n=Kn.r,i=Kn.g,s=Kn.b,o=Math.max(n,i,s),a=Math.min(n,i,s);let c,l;const u=(a+o)/2;if(a===o)c=0,l=0;else{const h=o-a;switch(l=u<=.5?h/(o+a):h/(2-o-a),o){case n:c=(i-s)/h+(i<s?6:0);break;case i:c=(s-n)/h+2;break;case s:c=(n-i)/h+4;break}c/=6}return e.h=c,e.s=l,e.l=u,e}getRGB(e,t=Ct.workingColorSpace){return Ct.fromWorkingColorSpace(Kn.copy(this),t),e.r=Kn.r,e.g=Kn.g,e.b=Kn.b,e}getStyle(e=bn){Ct.fromWorkingColorSpace(Kn.copy(this),e);const t=Kn.r,n=Kn.g,i=Kn.b;return e!==bn?`color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`:`rgb(${Math.round(t*255)},${Math.round(n*255)},${Math.round(i*255)})`}offsetHSL(e,t,n){return this.getHSL(zo),this.setHSL(zo.h+e,zo.s+t,zo.l+n)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,n){return this.r=e.r+(t.r-e.r)*n,this.g=e.g+(t.g-e.g)*n,this.b=e.b+(t.b-e.b)*n,this}lerpHSL(e,t){this.getHSL(zo),e.getHSL(Np);const n=Md(zo.h,Np.h,t),i=Md(zo.s,Np.s,t),s=Md(zo.l,Np.l,t);return this.setHSL(n,i,s),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const t=this.r,n=this.g,i=this.b,s=e.elements;return this.r=s[0]*t+s[3]*n+s[6]*i,this.g=s[1]*t+s[4]*n+s[7]*i,this.b=s[2]*t+s[5]*n+s[8]*i,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const Kn=new ye;ye.NAMES=UL;let bF=0;class wr extends Do{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:bF++}),this.uuid=ii(),this.name="",this.type="Material",this.blending=xc,this.side=Mo,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=kg,this.blendDst=Bg,this.blendEquation=aa,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new ye(0,0,0),this.blendAlpha=0,this.depthFunc=Vd,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Ux,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Ya,this.stencilZFail=Ya,this.stencilZPass=Ya,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const n=e[t];if(n===void 0){console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);continue}const i=this[t];if(i===void 0){console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);continue}i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[t]=n}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const n={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen!==void 0&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(n.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(n.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(n.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(n.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(n.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.anisotropy!==void 0&&(n.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(n.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(n.anisotropyMap=this.anisotropyMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(n.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==xc&&(n.blending=this.blending),this.side!==Mo&&(n.side=this.side),this.vertexColors===!0&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.transparent===!0&&(n.transparent=!0),this.blendSrc!==kg&&(n.blendSrc=this.blendSrc),this.blendDst!==Bg&&(n.blendDst=this.blendDst),this.blendEquation!==aa&&(n.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(n.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(n.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(n.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(n.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(n.blendAlpha=this.blendAlpha),this.depthFunc!==Vd&&(n.depthFunc=this.depthFunc),this.depthTest===!1&&(n.depthTest=this.depthTest),this.depthWrite===!1&&(n.depthWrite=this.depthWrite),this.colorWrite===!1&&(n.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(n.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==Ux&&(n.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(n.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(n.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==Ya&&(n.stencilFail=this.stencilFail),this.stencilZFail!==Ya&&(n.stencilZFail=this.stencilZFail),this.stencilZPass!==Ya&&(n.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(n.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaHash===!0&&(n.alphaHash=!0),this.alphaToCoverage===!0&&(n.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=!0),this.forceSinglePass===!0&&(n.forceSinglePass=!0),this.wireframe===!0&&(n.wireframe=!0),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=!0),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),this.fog===!1&&(n.fog=!1),Object.keys(this.userData).length>0&&(n.userData=this.userData);function i(s){const o=[];for(const a in s){const c=s[a];delete c.metadata,o.push(c)}return o}if(t){const s=i(e.textures),o=i(e.images);s.length>0&&(n.textures=s),o.length>0&&(n.images=o)}return n}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.blendColor.copy(e.blendColor),this.blendAlpha=e.blendAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let n=null;if(t!==null){const i=t.length;n=new Array(i);for(let s=0;s!==i;++s)n[s]=t[s].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaHash=e.alphaHash,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}class Ar extends wr{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new ye(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Jf,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const ro=wF();function wF(){const r=new ArrayBuffer(4),e=new Float32Array(r),t=new Uint32Array(r),n=new Uint32Array(512),i=new Uint32Array(512);for(let c=0;c<256;++c){const l=c-127;l<-27?(n[c]=0,n[c|256]=32768,i[c]=24,i[c|256]=24):l<-14?(n[c]=1024>>-l-14,n[c|256]=1024>>-l-14|32768,i[c]=-l-1,i[c|256]=-l-1):l<=15?(n[c]=l+15<<10,n[c|256]=l+15<<10|32768,i[c]=13,i[c|256]=13):l<128?(n[c]=31744,n[c|256]=64512,i[c]=24,i[c|256]=24):(n[c]=31744,n[c|256]=64512,i[c]=13,i[c|256]=13)}const s=new Uint32Array(2048),o=new Uint32Array(64),a=new Uint32Array(64);for(let c=1;c<1024;++c){let l=c<<13,u=0;for(;(l&8388608)===0;)l<<=1,u-=8388608;l&=-8388609,u+=947912704,s[c]=l|u}for(let c=1024;c<2048;++c)s[c]=939524096+(c-1024<<13);for(let c=1;c<31;++c)o[c]=c<<23;o[31]=1199570944,o[32]=2147483648;for(let c=33;c<63;++c)o[c]=2147483648+(c-32<<23);o[63]=3347054592;for(let c=1;c<64;++c)c!==32&&(a[c]=1024);return{floatView:e,uint32View:t,baseTable:n,shiftTable:i,mantissaTable:s,exponentTable:o,offsetTable:a}}function Dr(r){Math.abs(r)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),r=rn(r,-65504,65504),ro.floatView[0]=r;const e=ro.uint32View[0],t=e>>23&511;return ro.baseTable[t]+((e&8388607)>>ro.shiftTable[t])}function rd(r){const e=r>>10;return ro.uint32View[0]=ro.mantissaTable[ro.offsetTable[e]+(r&1023)]+ro.exponentTable[e],ro.floatView[0]}const vF={toHalfFloat:Dr,fromHalfFloat:rd},fn=new k,Op=new se;class It{constructor(e,t,n=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=n,this.usage=Qd,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.gpuType=Ki,this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}get updateRange(){return console.warn("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this.gpuType=e.gpuType,this}copyAt(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let i=0,s=this.itemSize;i<s;i++)this.array[e+i]=t.array[n+i];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,n=this.count;t<n;t++)Op.fromBufferAttribute(this,t),Op.applyMatrix3(e),this.setXY(t,Op.x,Op.y);else if(this.itemSize===3)for(let t=0,n=this.count;t<n;t++)fn.fromBufferAttribute(this,t),fn.applyMatrix3(e),this.setXYZ(t,fn.x,fn.y,fn.z);return this}applyMatrix4(e){for(let t=0,n=this.count;t<n;t++)fn.fromBufferAttribute(this,t),fn.applyMatrix4(e),this.setXYZ(t,fn.x,fn.y,fn.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)fn.fromBufferAttribute(this,t),fn.applyNormalMatrix(e),this.setXYZ(t,fn.x,fn.y,fn.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)fn.fromBufferAttribute(this,t),fn.transformDirection(e),this.setXYZ(t,fn.x,fn.y,fn.z);return this}set(e,t=0){return this.array.set(e,t),this}getComponent(e,t){let n=this.array[e*this.itemSize+t];return this.normalized&&(n=Br(n,this.array)),n}setComponent(e,t,n){return this.normalized&&(n=tt(n,this.array)),this.array[e*this.itemSize+t]=n,this}getX(e){let t=this.array[e*this.itemSize];return this.normalized&&(t=Br(t,this.array)),t}setX(e,t){return this.normalized&&(t=tt(t,this.array)),this.array[e*this.itemSize]=t,this}getY(e){let t=this.array[e*this.itemSize+1];return this.normalized&&(t=Br(t,this.array)),t}setY(e,t){return this.normalized&&(t=tt(t,this.array)),this.array[e*this.itemSize+1]=t,this}getZ(e){let t=this.array[e*this.itemSize+2];return this.normalized&&(t=Br(t,this.array)),t}setZ(e,t){return this.normalized&&(t=tt(t,this.array)),this.array[e*this.itemSize+2]=t,this}getW(e){let t=this.array[e*this.itemSize+3];return this.normalized&&(t=Br(t,this.array)),t}setW(e,t){return this.normalized&&(t=tt(t,this.array)),this.array[e*this.itemSize+3]=t,this}setXY(e,t,n){return e*=this.itemSize,this.normalized&&(t=tt(t,this.array),n=tt(n,this.array)),this.array[e+0]=t,this.array[e+1]=n,this}setXYZ(e,t,n,i){return e*=this.itemSize,this.normalized&&(t=tt(t,this.array),n=tt(n,this.array),i=tt(i,this.array)),this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this}setXYZW(e,t,n,i,s){return e*=this.itemSize,this.normalized&&(t=tt(t,this.array),n=tt(n,this.array),i=tt(i,this.array),s=tt(s,this.array)),this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this.array[e+3]=s,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==Qd&&(e.usage=this.usage),e}}class _F extends It{constructor(e,t,n){super(new Int8Array(e),t,n)}}class xF extends It{constructor(e,t,n){super(new Uint8Array(e),t,n)}}class SF extends It{constructor(e,t,n){super(new Uint8ClampedArray(e),t,n)}}class EF extends It{constructor(e,t,n){super(new Int16Array(e),t,n)}}class kE extends It{constructor(e,t,n){super(new Uint16Array(e),t,n)}}class MF extends It{constructor(e,t,n){super(new Int32Array(e),t,n)}}class BE extends It{constructor(e,t,n){super(new Uint32Array(e),t,n)}}class AF extends It{constructor(e,t,n){super(new Uint16Array(e),t,n),this.isFloat16BufferAttribute=!0}getX(e){let t=rd(this.array[e*this.itemSize]);return this.normalized&&(t=Br(t,this.array)),t}setX(e,t){return this.normalized&&(t=tt(t,this.array)),this.array[e*this.itemSize]=Dr(t),this}getY(e){let t=rd(this.array[e*this.itemSize+1]);return this.normalized&&(t=Br(t,this.array)),t}setY(e,t){return this.normalized&&(t=tt(t,this.array)),this.array[e*this.itemSize+1]=Dr(t),this}getZ(e){let t=rd(this.array[e*this.itemSize+2]);return this.normalized&&(t=Br(t,this.array)),t}setZ(e,t){return this.normalized&&(t=tt(t,this.array)),this.array[e*this.itemSize+2]=Dr(t),this}getW(e){let t=rd(this.array[e*this.itemSize+3]);return this.normalized&&(t=Br(t,this.array)),t}setW(e,t){return this.normalized&&(t=tt(t,this.array)),this.array[e*this.itemSize+3]=Dr(t),this}setXY(e,t,n){return e*=this.itemSize,this.normalized&&(t=tt(t,this.array),n=tt(n,this.array)),this.array[e+0]=Dr(t),this.array[e+1]=Dr(n),this}setXYZ(e,t,n,i){return e*=this.itemSize,this.normalized&&(t=tt(t,this.array),n=tt(n,this.array),i=tt(i,this.array)),this.array[e+0]=Dr(t),this.array[e+1]=Dr(n),this.array[e+2]=Dr(i),this}setXYZW(e,t,n,i,s){return e*=this.itemSize,this.normalized&&(t=tt(t,this.array),n=tt(n,this.array),i=tt(i,this.array),s=tt(s,this.array)),this.array[e+0]=Dr(t),this.array[e+1]=Dr(n),this.array[e+2]=Dr(i),this.array[e+3]=Dr(s),this}}class Ce extends It{constructor(e,t,n){super(new Float32Array(e),t,n)}}class TF extends It{constructor(e,t,n){super(new Float64Array(e),t,n)}}let CF=0;const li=new $e,Ab=new wt,hl=new k,Xr=new br,Bh=new br,Mn=new k;class Ye extends Do{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:CF++}),this.uuid=ii(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(LL(e)?BE:kE)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const s=new rt().getNormalMatrix(e);n.applyNormalMatrix(s),n.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(e),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return li.makeRotationFromQuaternion(e),this.applyMatrix4(li),this}rotateX(e){return li.makeRotationX(e),this.applyMatrix4(li),this}rotateY(e){return li.makeRotationY(e),this.applyMatrix4(li),this}rotateZ(e){return li.makeRotationZ(e),this.applyMatrix4(li),this}translate(e,t,n){return li.makeTranslation(e,t,n),this.applyMatrix4(li),this}scale(e,t,n){return li.makeScale(e,t,n),this.applyMatrix4(li),this}lookAt(e){return Ab.lookAt(e),Ab.updateMatrix(),this.applyMatrix4(Ab.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(hl).negate(),this.translate(hl.x,hl.y,hl.z),this}setFromPoints(e){const t=[];for(let n=0,i=e.length;n<i;n++){const s=e[n];t.push(s.x,s.y,s.z||0)}return this.setAttribute("position",new Ce(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new br);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new k(-1/0,-1/0,-1/0),new k(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let n=0,i=t.length;n<i;n++){const s=t[n];Xr.setFromBufferAttribute(s),this.morphTargetsRelative?(Mn.addVectors(this.boundingBox.min,Xr.min),this.boundingBox.expandByPoint(Mn),Mn.addVectors(this.boundingBox.max,Xr.max),this.boundingBox.expandByPoint(Mn)):(this.boundingBox.expandByPoint(Xr.min),this.boundingBox.expandByPoint(Xr.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Bn);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new k,1/0);return}if(e){const n=this.boundingSphere.center;if(Xr.setFromBufferAttribute(e),t)for(let s=0,o=t.length;s<o;s++){const a=t[s];Bh.setFromBufferAttribute(a),this.morphTargetsRelative?(Mn.addVectors(Xr.min,Bh.min),Xr.expandByPoint(Mn),Mn.addVectors(Xr.max,Bh.max),Xr.expandByPoint(Mn)):(Xr.expandByPoint(Bh.min),Xr.expandByPoint(Bh.max))}Xr.getCenter(n);let i=0;for(let s=0,o=e.count;s<o;s++)Mn.fromBufferAttribute(e,s),i=Math.max(i,n.distanceToSquared(Mn));if(t)for(let s=0,o=t.length;s<o;s++){const a=t[s],c=this.morphTargetsRelative;for(let l=0,u=a.count;l<u;l++)Mn.fromBufferAttribute(a,l),c&&(hl.fromBufferAttribute(e,l),Mn.add(hl)),i=Math.max(i,n.distanceToSquared(Mn))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=e.array,i=t.position.array,s=t.normal.array,o=t.uv.array,a=i.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new It(new Float32Array(4*a),4));const c=this.getAttribute("tangent").array,l=[],u=[];for(let T=0;T<a;T++)l[T]=new k,u[T]=new k;const h=new k,d=new k,m=new k,p=new se,b=new se,g=new se,y=new k,v=new k;function w(T,F,$){h.fromArray(i,T*3),d.fromArray(i,F*3),m.fromArray(i,$*3),p.fromArray(o,T*2),b.fromArray(o,F*2),g.fromArray(o,$*2),d.sub(h),m.sub(h),b.sub(p),g.sub(p);const H=1/(b.x*g.y-g.x*b.y);isFinite(H)&&(y.copy(d).multiplyScalar(g.y).addScaledVector(m,-b.y).multiplyScalar(H),v.copy(m).multiplyScalar(b.x).addScaledVector(d,-g.x).multiplyScalar(H),l[T].add(y),l[F].add(y),l[$].add(y),u[T].add(v),u[F].add(v),u[$].add(v))}let _=this.groups;_.length===0&&(_=[{start:0,count:n.length}]);for(let T=0,F=_.length;T<F;++T){const $=_[T],H=$.start,S=$.count;for(let A=H,P=H+S;A<P;A+=3)w(n[A+0],n[A+1],n[A+2])}const M=new k,E=new k,C=new k,I=new k;function x(T){C.fromArray(s,T*3),I.copy(C);const F=l[T];M.copy(F),M.sub(C.multiplyScalar(C.dot(F))).normalize(),E.crossVectors(I,F);const H=E.dot(u[T])<0?-1:1;c[T*4]=M.x,c[T*4+1]=M.y,c[T*4+2]=M.z,c[T*4+3]=H}for(let T=0,F=_.length;T<F;++T){const $=_[T],H=$.start,S=$.count;for(let A=H,P=H+S;A<P;A+=3)x(n[A+0]),x(n[A+1]),x(n[A+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new It(new Float32Array(t.count*3),3),this.setAttribute("normal",n);else for(let d=0,m=n.count;d<m;d++)n.setXYZ(d,0,0,0);const i=new k,s=new k,o=new k,a=new k,c=new k,l=new k,u=new k,h=new k;if(e)for(let d=0,m=e.count;d<m;d+=3){const p=e.getX(d+0),b=e.getX(d+1),g=e.getX(d+2);i.fromBufferAttribute(t,p),s.fromBufferAttribute(t,b),o.fromBufferAttribute(t,g),u.subVectors(o,s),h.subVectors(i,s),u.cross(h),a.fromBufferAttribute(n,p),c.fromBufferAttribute(n,b),l.fromBufferAttribute(n,g),a.add(u),c.add(u),l.add(u),n.setXYZ(p,a.x,a.y,a.z),n.setXYZ(b,c.x,c.y,c.z),n.setXYZ(g,l.x,l.y,l.z)}else for(let d=0,m=t.count;d<m;d+=3)i.fromBufferAttribute(t,d+0),s.fromBufferAttribute(t,d+1),o.fromBufferAttribute(t,d+2),u.subVectors(o,s),h.subVectors(i,s),u.cross(h),n.setXYZ(d+0,u.x,u.y,u.z),n.setXYZ(d+1,u.x,u.y,u.z),n.setXYZ(d+2,u.x,u.y,u.z);this.normalizeNormals(),n.needsUpdate=!0}}normalizeNormals(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)Mn.fromBufferAttribute(e,t),Mn.normalize(),e.setXYZ(t,Mn.x,Mn.y,Mn.z)}toNonIndexed(){function e(a,c){const l=a.array,u=a.itemSize,h=a.normalized,d=new l.constructor(c.length*u);let m=0,p=0;for(let b=0,g=c.length;b<g;b++){a.isInterleavedBufferAttribute?m=c[b]*a.data.stride+a.offset:m=c[b]*u;for(let y=0;y<u;y++)d[p++]=l[m++]}return new It(d,u,h)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new Ye,n=this.index.array,i=this.attributes;for(const a in i){const c=i[a],l=e(c,n);t.setAttribute(a,l)}const s=this.morphAttributes;for(const a in s){const c=[],l=s[a];for(let u=0,h=l.length;u<h;u++){const d=l[u],m=e(d,n);c.push(m)}t.morphAttributes[a]=c}t.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let a=0,c=o.length;a<c;a++){const l=o[a];t.addGroup(l.start,l.count,l.materialIndex)}return t}toJSON(){const e={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const c=this.parameters;for(const l in c)c[l]!==void 0&&(e[l]=c[l]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const n=this.attributes;for(const c in n){const l=n[c];e.data.attributes[c]=l.toJSON(e.data)}const i={};let s=!1;for(const c in this.morphAttributes){const l=this.morphAttributes[c],u=[];for(let h=0,d=l.length;h<d;h++){const m=l[h];u.push(m.toJSON(e.data))}u.length>0&&(i[c]=u,s=!0)}s&&(e.data.morphAttributes=i,e.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(e.data.groups=JSON.parse(JSON.stringify(o)));const a=this.boundingSphere;return a!==null&&(e.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;n!==null&&this.setIndex(n.clone(t));const i=e.attributes;for(const l in i){const u=i[l];this.setAttribute(l,u.clone(t))}const s=e.morphAttributes;for(const l in s){const u=[],h=s[l];for(let d=0,m=h.length;d<m;d++)u.push(h[d].clone(t));this.morphAttributes[l]=u}this.morphTargetsRelative=e.morphTargetsRelative;const o=e.groups;for(let l=0,u=o.length;l<u;l++){const h=o[l];this.addGroup(h.start,h.count,h.materialIndex)}const a=e.boundingBox;a!==null&&(this.boundingBox=a.clone());const c=e.boundingSphere;return c!==null&&(this.boundingSphere=c.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const IA=new $e,Fa=new ph,Up=new Bn,PA=new k,dl=new k,fl=new k,pl=new k,Tb=new k,kp=new k,Bp=new se,Fp=new se,$p=new se,RA=new k,DA=new k,LA=new k,zp=new k,Vp=new k;class De extends wt{constructor(e=new Ye,t=new Ar){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=i.length;s<o;s++){const a=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}getVertexPosition(e,t){const n=this.geometry,i=n.attributes.position,s=n.morphAttributes.position,o=n.morphTargetsRelative;t.fromBufferAttribute(i,e);const a=this.morphTargetInfluences;if(s&&a){kp.set(0,0,0);for(let c=0,l=s.length;c<l;c++){const u=a[c],h=s[c];u!==0&&(Tb.fromBufferAttribute(h,e),o?kp.addScaledVector(Tb,u):kp.addScaledVector(Tb.sub(t),u))}t.add(kp)}return t}raycast(e,t){const n=this.geometry,i=this.material,s=this.matrixWorld;i!==void 0&&(n.boundingSphere===null&&n.computeBoundingSphere(),Up.copy(n.boundingSphere),Up.applyMatrix4(s),Fa.copy(e.ray).recast(e.near),!(Up.containsPoint(Fa.origin)===!1&&(Fa.intersectSphere(Up,PA)===null||Fa.origin.distanceToSquared(PA)>(e.far-e.near)**2))&&(IA.copy(s).invert(),Fa.copy(e.ray).applyMatrix4(IA),!(n.boundingBox!==null&&Fa.intersectsBox(n.boundingBox)===!1)&&this._computeIntersections(e,t,Fa)))}_computeIntersections(e,t,n){let i;const s=this.geometry,o=this.material,a=s.index,c=s.attributes.position,l=s.attributes.uv,u=s.attributes.uv1,h=s.attributes.normal,d=s.groups,m=s.drawRange;if(a!==null)if(Array.isArray(o))for(let p=0,b=d.length;p<b;p++){const g=d[p],y=o[g.materialIndex],v=Math.max(g.start,m.start),w=Math.min(a.count,Math.min(g.start+g.count,m.start+m.count));for(let _=v,M=w;_<M;_+=3){const E=a.getX(_),C=a.getX(_+1),I=a.getX(_+2);i=Hp(this,y,e,n,l,u,h,E,C,I),i&&(i.faceIndex=Math.floor(_/3),i.face.materialIndex=g.materialIndex,t.push(i))}}else{const p=Math.max(0,m.start),b=Math.min(a.count,m.start+m.count);for(let g=p,y=b;g<y;g+=3){const v=a.getX(g),w=a.getX(g+1),_=a.getX(g+2);i=Hp(this,o,e,n,l,u,h,v,w,_),i&&(i.faceIndex=Math.floor(g/3),t.push(i))}}else if(c!==void 0)if(Array.isArray(o))for(let p=0,b=d.length;p<b;p++){const g=d[p],y=o[g.materialIndex],v=Math.max(g.start,m.start),w=Math.min(c.count,Math.min(g.start+g.count,m.start+m.count));for(let _=v,M=w;_<M;_+=3){const E=_,C=_+1,I=_+2;i=Hp(this,y,e,n,l,u,h,E,C,I),i&&(i.faceIndex=Math.floor(_/3),i.face.materialIndex=g.materialIndex,t.push(i))}}else{const p=Math.max(0,m.start),b=Math.min(c.count,m.start+m.count);for(let g=p,y=b;g<y;g+=3){const v=g,w=g+1,_=g+2;i=Hp(this,o,e,n,l,u,h,v,w,_),i&&(i.faceIndex=Math.floor(g/3),t.push(i))}}}}function IF(r,e,t,n,i,s,o,a){let c;if(e.side===yr?c=n.intersectTriangle(o,s,i,!0,a):c=n.intersectTriangle(i,s,o,e.side===Mo,a),c===null)return null;Vp.copy(a),Vp.applyMatrix4(r.matrixWorld);const l=t.ray.origin.distanceTo(Vp);return l<t.near||l>t.far?null:{distance:l,point:Vp.clone(),object:r}}function Hp(r,e,t,n,i,s,o,a,c,l){r.getVertexPosition(a,dl),r.getVertexPosition(c,fl),r.getVertexPosition(l,pl);const u=IF(r,e,t,n,dl,fl,pl,zp);if(u){i&&(Bp.fromBufferAttribute(i,a),Fp.fromBufferAttribute(i,c),$p.fromBufferAttribute(i,l),u.uv=Ur.getInterpolation(zp,dl,fl,pl,Bp,Fp,$p,new se)),s&&(Bp.fromBufferAttribute(s,a),Fp.fromBufferAttribute(s,c),$p.fromBufferAttribute(s,l),u.uv1=Ur.getInterpolation(zp,dl,fl,pl,Bp,Fp,$p,new se),u.uv2=u.uv1),o&&(RA.fromBufferAttribute(o,a),DA.fromBufferAttribute(o,c),LA.fromBufferAttribute(o,l),u.normal=Ur.getInterpolation(zp,dl,fl,pl,RA,DA,LA,new k),u.normal.dot(n.direction)>0&&u.normal.multiplyScalar(-1));const h={a,b:c,c:l,normal:new k,materialIndex:0};Ur.getNormal(dl,fl,pl,h.normal),u.face=h}return u}class Qt extends Ye{constructor(e=1,t=1,n=1,i=1,s=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:i,heightSegments:s,depthSegments:o};const a=this;i=Math.floor(i),s=Math.floor(s),o=Math.floor(o);const c=[],l=[],u=[],h=[];let d=0,m=0;p("z","y","x",-1,-1,n,t,e,o,s,0),p("z","y","x",1,-1,n,t,-e,o,s,1),p("x","z","y",1,1,e,n,t,i,o,2),p("x","z","y",1,-1,e,n,-t,i,o,3),p("x","y","z",1,-1,e,t,n,i,s,4),p("x","y","z",-1,-1,e,t,-n,i,s,5),this.setIndex(c),this.setAttribute("position",new Ce(l,3)),this.setAttribute("normal",new Ce(u,3)),this.setAttribute("uv",new Ce(h,2));function p(b,g,y,v,w,_,M,E,C,I,x){const T=_/C,F=M/I,$=_/2,H=M/2,S=E/2,A=C+1,P=I+1;let L=0,B=0;const D=new k;for(let V=0;V<P;V++){const z=V*F-H;for(let q=0;q<A;q++){const G=q*T-$;D[b]=G*v,D[g]=z*w,D[y]=S,l.push(D.x,D.y,D.z),D[b]=0,D[g]=0,D[y]=E>0?1:-1,u.push(D.x,D.y,D.z),h.push(q/C),h.push(1-V/I),L+=1}}for(let V=0;V<I;V++)for(let z=0;z<C;z++){const q=d+z+A*V,G=d+z+A*(V+1),Y=d+(z+1)+A*(V+1),j=d+(z+1)+A*V;c.push(q,G,j),c.push(G,Y,j),B+=6}a.addGroup(m,B,x),m+=B,d+=L}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Qt(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function $u(r){const e={};for(const t in r){e[t]={};for(const n in r[t]){const i=r[t][n];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?i.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[t][n]=null):e[t][n]=i.clone():Array.isArray(i)?e[t][n]=i.slice():e[t][n]=i}}return e}function Er(r){const e={};for(let t=0;t<r.length;t++){const n=$u(r[t]);for(const i in n)e[i]=n[i]}return e}function PF(r){const e=[];for(let t=0;t<r.length;t++)e.push(r[t].clone());return e}function kL(r){return r.getRenderTarget()===null?r.outputColorSpace:Ct.workingColorSpace}const BL={clone:$u,merge:Er};var RF=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,DF=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class Fr extends wr{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=RF,this.fragmentShader=DF,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1,clipCullDistance:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=$u(e.uniforms),this.uniformsGroups=PF(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const i in this.uniforms){const o=this.uniforms[i].value;o&&o.isTexture?t.uniforms[i]={type:"t",value:o.toJSON(e).uuid}:o&&o.isColor?t.uniforms[i]={type:"c",value:o.getHex()}:o&&o.isVector2?t.uniforms[i]={type:"v2",value:o.toArray()}:o&&o.isVector3?t.uniforms[i]={type:"v3",value:o.toArray()}:o&&o.isVector4?t.uniforms[i]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?t.uniforms[i]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?t.uniforms[i]={type:"m4",value:o.toArray()}:t.uniforms[i]={value:o}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader,t.lights=this.lights,t.clipping=this.clipping;const n={};for(const i in this.extensions)this.extensions[i]===!0&&(n[i]=!0);return Object.keys(n).length>0&&(t.extensions=n),t}}class a0 extends wt{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new $e,this.projectionMatrix=new $e,this.projectionMatrixInverse=new $e,this.coordinateSystem=Xi}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this.coordinateSystem=e.coordinateSystem,this}getWorldDirection(e){return super.getWorldDirection(e).negate()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}class In extends a0{constructor(e=50,t=1,n=.1,i=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=Fu*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(Sc*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return Fu*2*Math.atan(Math.tan(Sc*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,n,i,s,o){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=s,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(Sc*.5*this.fov)/this.zoom,n=2*t,i=this.aspect*n,s=-.5*i;const o=this.view;if(this.view!==null&&this.view.enabled){const c=o.fullWidth,l=o.fullHeight;s+=o.offsetX*i/c,t-=o.offsetY*n/l,i*=o.width/c,n*=o.height/l}const a=this.filmOffset;a!==0&&(s+=e*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+i,t,t-n,e,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}const ml=-90,gl=1;class FL extends wt{constructor(e,t,n){super(),this.type="CubeCamera",this.renderTarget=n,this.coordinateSystem=null,this.activeMipmapLevel=0;const i=new In(ml,gl,e,t);i.layers=this.layers,this.add(i);const s=new In(ml,gl,e,t);s.layers=this.layers,this.add(s);const o=new In(ml,gl,e,t);o.layers=this.layers,this.add(o);const a=new In(ml,gl,e,t);a.layers=this.layers,this.add(a);const c=new In(ml,gl,e,t);c.layers=this.layers,this.add(c);const l=new In(ml,gl,e,t);l.layers=this.layers,this.add(l)}updateCoordinateSystem(){const e=this.coordinateSystem,t=this.children.concat(),[n,i,s,o,a,c]=t;for(const l of t)this.remove(l);if(e===Xi)n.up.set(0,1,0),n.lookAt(1,0,0),i.up.set(0,1,0),i.lookAt(-1,0,0),s.up.set(0,0,-1),s.lookAt(0,1,0),o.up.set(0,0,1),o.lookAt(0,-1,0),a.up.set(0,1,0),a.lookAt(0,0,1),c.up.set(0,1,0),c.lookAt(0,0,-1);else if(e===Bu)n.up.set(0,-1,0),n.lookAt(-1,0,0),i.up.set(0,-1,0),i.lookAt(1,0,0),s.up.set(0,0,1),s.lookAt(0,1,0),o.up.set(0,0,-1),o.lookAt(0,-1,0),a.up.set(0,-1,0),a.lookAt(0,0,1),c.up.set(0,-1,0),c.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+e);for(const l of t)this.add(l),l.updateMatrixWorld()}update(e,t){this.parent===null&&this.updateMatrixWorld();const{renderTarget:n,activeMipmapLevel:i}=this;this.coordinateSystem!==e.coordinateSystem&&(this.coordinateSystem=e.coordinateSystem,this.updateCoordinateSystem());const[s,o,a,c,l,u]=this.children,h=e.getRenderTarget(),d=e.getActiveCubeFace(),m=e.getActiveMipmapLevel(),p=e.xr.enabled;e.xr.enabled=!1;const b=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,e.setRenderTarget(n,0,i),e.render(t,s),e.setRenderTarget(n,1,i),e.render(t,o),e.setRenderTarget(n,2,i),e.render(t,a),e.setRenderTarget(n,3,i),e.render(t,c),e.setRenderTarget(n,4,i),e.render(t,l),n.texture.generateMipmaps=b,e.setRenderTarget(n,5,i),e.render(t,u),e.setRenderTarget(h,d,m),e.xr.enabled=p,n.texture.needsPMREMUpdate=!0}}class ep extends hn{constructor(e,t,n,i,s,o,a,c,l,u){e=e!==void 0?e:[],t=t!==void 0?t:Ao,super(e,t,n,i,s,o,a,c,l,u),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class $L extends ts{constructor(e=1,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const n={width:e,height:e,depth:1},i=[n,n,n,n,n,n];t.encoding!==void 0&&(Ad("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."),t.colorSpace=t.encoding===wa?bn:ti),this.texture=new ep(i,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:un}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.colorSpace=t.colorSpace,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new Qt(5,5,5),s=new Fr({name:"CubemapFromEquirect",uniforms:$u(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:yr,blending:wo});s.uniforms.tEquirect.value=t;const o=new De(i,s),a=t.minFilter;return t.minFilter===Sa&&(t.minFilter=un),new FL(1,10,this).update(e,o),t.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(e,t,n,i){const s=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,n,i);e.setRenderTarget(s)}}const Cb=new k,LF=new k,NF=new rt;class ta{constructor(e=new k(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,n,i){return this.normal.set(e,t,n),this.constant=i,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,n){const i=Cb.subVectors(n,t).cross(LF.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(i,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,t){const n=e.delta(Cb),i=this.normal.dot(n);if(i===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const s=-(e.start.dot(this.normal)+this.constant)/i;return s<0||s>1?null:t.copy(e.start).addScaledVector(n,s)}intersectsLine(e){const t=this.distanceToPoint(e.start),n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const n=t||NF.getNormalMatrix(e),i=this.coplanarPoint(Cb).applyMatrix4(e),s=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(s),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}const $a=new Bn,Gp=new k;class tp{constructor(e=new ta,t=new ta,n=new ta,i=new ta,s=new ta,o=new ta){this.planes=[e,t,n,i,s,o]}set(e,t,n,i,s,o){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(n),a[3].copy(i),a[4].copy(s),a[5].copy(o),this}copy(e){const t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this}setFromProjectionMatrix(e,t=Xi){const n=this.planes,i=e.elements,s=i[0],o=i[1],a=i[2],c=i[3],l=i[4],u=i[5],h=i[6],d=i[7],m=i[8],p=i[9],b=i[10],g=i[11],y=i[12],v=i[13],w=i[14],_=i[15];if(n[0].setComponents(c-s,d-l,g-m,_-y).normalize(),n[1].setComponents(c+s,d+l,g+m,_+y).normalize(),n[2].setComponents(c+o,d+u,g+p,_+v).normalize(),n[3].setComponents(c-o,d-u,g-p,_-v).normalize(),n[4].setComponents(c-a,d-h,g-b,_-w).normalize(),t===Xi)n[5].setComponents(c+a,d+h,g+b,_+w).normalize();else if(t===Bu)n[5].setComponents(a,h,b,w).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+t);return this}intersectsObject(e){if(e.boundingSphere!==void 0)e.boundingSphere===null&&e.computeBoundingSphere(),$a.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);else{const t=e.geometry;t.boundingSphere===null&&t.computeBoundingSphere(),$a.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)}return this.intersectsSphere($a)}intersectsSprite(e){return $a.center.set(0,0,0),$a.radius=.7071067811865476,$a.applyMatrix4(e.matrixWorld),this.intersectsSphere($a)}intersectsSphere(e){const t=this.planes,n=e.center,i=-e.radius;for(let s=0;s<6;s++)if(t[s].distanceToPoint(n)<i)return!1;return!0}intersectsBox(e){const t=this.planes;for(let n=0;n<6;n++){const i=t[n];if(Gp.x=i.normal.x>0?e.max.x:e.min.x,Gp.y=i.normal.y>0?e.max.y:e.min.y,Gp.z=i.normal.z>0?e.max.z:e.min.z,i.distanceToPoint(Gp)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function zL(){let r=null,e=!1,t=null,n=null;function i(s,o){t(s,o),n=r.requestAnimationFrame(i)}return{start:function(){e!==!0&&t!==null&&(n=r.requestAnimationFrame(i),e=!0)},stop:function(){r.cancelAnimationFrame(n),e=!1},setAnimationLoop:function(s){t=s},setContext:function(s){r=s}}}function OF(r,e){const t=e.isWebGL2,n=new WeakMap;function i(l,u){const h=l.array,d=l.usage,m=h.byteLength,p=r.createBuffer();r.bindBuffer(u,p),r.bufferData(u,h,d),l.onUploadCallback();let b;if(h instanceof Float32Array)b=r.FLOAT;else if(h instanceof Uint16Array)if(l.isFloat16BufferAttribute)if(t)b=r.HALF_FLOAT;else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else b=r.UNSIGNED_SHORT;else if(h instanceof Int16Array)b=r.SHORT;else if(h instanceof Uint32Array)b=r.UNSIGNED_INT;else if(h instanceof Int32Array)b=r.INT;else if(h instanceof Int8Array)b=r.BYTE;else if(h instanceof Uint8Array)b=r.UNSIGNED_BYTE;else if(h instanceof Uint8ClampedArray)b=r.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+h);return{buffer:p,type:b,bytesPerElement:h.BYTES_PER_ELEMENT,version:l.version,size:m}}function s(l,u,h){const d=u.array,m=u._updateRange,p=u.updateRanges;if(r.bindBuffer(h,l),m.count===-1&&p.length===0&&r.bufferSubData(h,0,d),p.length!==0){for(let b=0,g=p.length;b<g;b++){const y=p[b];t?r.bufferSubData(h,y.start*d.BYTES_PER_ELEMENT,d,y.start,y.count):r.bufferSubData(h,y.start*d.BYTES_PER_ELEMENT,d.subarray(y.start,y.start+y.count))}u.clearUpdateRanges()}m.count!==-1&&(t?r.bufferSubData(h,m.offset*d.BYTES_PER_ELEMENT,d,m.offset,m.count):r.bufferSubData(h,m.offset*d.BYTES_PER_ELEMENT,d.subarray(m.offset,m.offset+m.count)),m.count=-1),u.onUploadCallback()}function o(l){return l.isInterleavedBufferAttribute&&(l=l.data),n.get(l)}function a(l){l.isInterleavedBufferAttribute&&(l=l.data);const u=n.get(l);u&&(r.deleteBuffer(u.buffer),n.delete(l))}function c(l,u){if(l.isGLBufferAttribute){const d=n.get(l);(!d||d.version<l.version)&&n.set(l,{buffer:l.buffer,type:l.type,bytesPerElement:l.elementSize,version:l.version});return}l.isInterleavedBufferAttribute&&(l=l.data);const h=n.get(l);if(h===void 0)n.set(l,i(l,u));else if(h.version<l.version){if(h.size!==l.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");s(h.buffer,l,u),h.version=l.version}}return{get:o,remove:a,update:c}}class Pc extends Ye{constructor(e=1,t=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:i};const s=e/2,o=t/2,a=Math.floor(n),c=Math.floor(i),l=a+1,u=c+1,h=e/a,d=t/c,m=[],p=[],b=[],g=[];for(let y=0;y<u;y++){const v=y*d-o;for(let w=0;w<l;w++){const _=w*h-s;p.push(_,-v,0),b.push(0,0,1),g.push(w/a),g.push(1-y/c)}}for(let y=0;y<c;y++)for(let v=0;v<a;v++){const w=v+l*y,_=v+l*(y+1),M=v+1+l*(y+1),E=v+1+l*y;m.push(w,_,E),m.push(_,M,E)}this.setIndex(m),this.setAttribute("position",new Ce(p,3)),this.setAttribute("normal",new Ce(b,3)),this.setAttribute("uv",new Ce(g,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Pc(e.width,e.height,e.widthSegments,e.heightSegments)}}var UF=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,kF=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,BF=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,FF=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,$F=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,zF=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,VF=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,HF=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,GF=`#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,WF=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`,qF=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,KF=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,XF=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,YF=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,ZF=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,JF=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,jF=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,QF=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,e$=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,t$=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,n$=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,r$=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,i$=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,s$=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,o$=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,a$=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,c$=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,l$=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,u$=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,h$=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,d$="gl_FragColor = linearToOutputTexel( gl_FragColor );",f$=`
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,p$=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,m$=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,g$=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,y$=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,b$=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,w$=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,v$=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,_$=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,x$=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,S$=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,E$=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,M$=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,A$=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,T$=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,C$=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,I$=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,P$=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,R$=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,D$=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,L$=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,N$=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,O$=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,U$=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,k$=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,B$=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,F$=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,$$=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,z$=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,V$=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,H$=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,G$=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,W$=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,q$=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,K$=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,X$=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,Y$=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,Z$=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,J$=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,j$=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,Q$=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,ez=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,tz=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,nz=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,rz=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,iz=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,sz=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,oz=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,az=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,cz=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,lz=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,uz=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,hz=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,dz=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,fz=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,pz=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,mz=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,gz=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,yz=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,bz=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,wz=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,vz=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,_z=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,xz=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,Sz=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,Ez=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,Mz=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,Az=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,Tz=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,Cz=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color *= toneMappingExposure;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	return color;
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,Iz=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,Pz=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,Rz=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,Dz=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,Lz=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,Nz=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const Oz=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,Uz=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,kz=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,Bz=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,Fz=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,$z=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,zz=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,Vz=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,Hz=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,Gz=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,Wz=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,qz=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,Kz=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,Xz=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Yz=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,Zz=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Jz=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,jz=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Qz=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,e8=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,t8=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,n8=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,r8=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,i8=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,s8=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,o8=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,a8=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,c8=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,l8=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,u8=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,h8=`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,d8=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,f8=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,p8=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,et={alphahash_fragment:UF,alphahash_pars_fragment:kF,alphamap_fragment:BF,alphamap_pars_fragment:FF,alphatest_fragment:$F,alphatest_pars_fragment:zF,aomap_fragment:VF,aomap_pars_fragment:HF,batching_pars_vertex:GF,batching_vertex:WF,begin_vertex:qF,beginnormal_vertex:KF,bsdfs:XF,iridescence_fragment:YF,bumpmap_pars_fragment:ZF,clipping_planes_fragment:JF,clipping_planes_pars_fragment:jF,clipping_planes_pars_vertex:QF,clipping_planes_vertex:e$,color_fragment:t$,color_pars_fragment:n$,color_pars_vertex:r$,color_vertex:i$,common:s$,cube_uv_reflection_fragment:o$,defaultnormal_vertex:a$,displacementmap_pars_vertex:c$,displacementmap_vertex:l$,emissivemap_fragment:u$,emissivemap_pars_fragment:h$,colorspace_fragment:d$,colorspace_pars_fragment:f$,envmap_fragment:p$,envmap_common_pars_fragment:m$,envmap_pars_fragment:g$,envmap_pars_vertex:y$,envmap_physical_pars_fragment:I$,envmap_vertex:b$,fog_vertex:w$,fog_pars_vertex:v$,fog_fragment:_$,fog_pars_fragment:x$,gradientmap_pars_fragment:S$,lightmap_fragment:E$,lightmap_pars_fragment:M$,lights_lambert_fragment:A$,lights_lambert_pars_fragment:T$,lights_pars_begin:C$,lights_toon_fragment:P$,lights_toon_pars_fragment:R$,lights_phong_fragment:D$,lights_phong_pars_fragment:L$,lights_physical_fragment:N$,lights_physical_pars_fragment:O$,lights_fragment_begin:U$,lights_fragment_maps:k$,lights_fragment_end:B$,logdepthbuf_fragment:F$,logdepthbuf_pars_fragment:$$,logdepthbuf_pars_vertex:z$,logdepthbuf_vertex:V$,map_fragment:H$,map_pars_fragment:G$,map_particle_fragment:W$,map_particle_pars_fragment:q$,metalnessmap_fragment:K$,metalnessmap_pars_fragment:X$,morphcolor_vertex:Y$,morphnormal_vertex:Z$,morphtarget_pars_vertex:J$,morphtarget_vertex:j$,normal_fragment_begin:Q$,normal_fragment_maps:ez,normal_pars_fragment:tz,normal_pars_vertex:nz,normal_vertex:rz,normalmap_pars_fragment:iz,clearcoat_normal_fragment_begin:sz,clearcoat_normal_fragment_maps:oz,clearcoat_pars_fragment:az,iridescence_pars_fragment:cz,opaque_fragment:lz,packing:uz,premultiplied_alpha_fragment:hz,project_vertex:dz,dithering_fragment:fz,dithering_pars_fragment:pz,roughnessmap_fragment:mz,roughnessmap_pars_fragment:gz,shadowmap_pars_fragment:yz,shadowmap_pars_vertex:bz,shadowmap_vertex:wz,shadowmask_pars_fragment:vz,skinbase_vertex:_z,skinning_pars_vertex:xz,skinning_vertex:Sz,skinnormal_vertex:Ez,specularmap_fragment:Mz,specularmap_pars_fragment:Az,tonemapping_fragment:Tz,tonemapping_pars_fragment:Cz,transmission_fragment:Iz,transmission_pars_fragment:Pz,uv_pars_fragment:Rz,uv_pars_vertex:Dz,uv_vertex:Lz,worldpos_vertex:Nz,background_vert:Oz,background_frag:Uz,backgroundCube_vert:kz,backgroundCube_frag:Bz,cube_vert:Fz,cube_frag:$z,depth_vert:zz,depth_frag:Vz,distanceRGBA_vert:Hz,distanceRGBA_frag:Gz,equirect_vert:Wz,equirect_frag:qz,linedashed_vert:Kz,linedashed_frag:Xz,meshbasic_vert:Yz,meshbasic_frag:Zz,meshlambert_vert:Jz,meshlambert_frag:jz,meshmatcap_vert:Qz,meshmatcap_frag:e8,meshnormal_vert:t8,meshnormal_frag:n8,meshphong_vert:r8,meshphong_frag:i8,meshphysical_vert:s8,meshphysical_frag:o8,meshtoon_vert:a8,meshtoon_frag:c8,points_vert:l8,points_frag:u8,shadow_vert:h8,shadow_frag:d8,sprite_vert:f8,sprite_frag:p8},we={common:{diffuse:{value:new ye(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new rt},alphaMap:{value:null},alphaMapTransform:{value:new rt},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new rt}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new rt}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new rt}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new rt},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new rt},normalScale:{value:new se(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new rt},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new rt}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new rt}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new rt}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new ye(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new ye(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new rt},alphaTest:{value:0},uvTransform:{value:new rt}},sprite:{diffuse:{value:new ye(16777215)},opacity:{value:1},center:{value:new se(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new rt},alphaMap:{value:null},alphaMapTransform:{value:new rt},alphaTest:{value:0}}},Wi={basic:{uniforms:Er([we.common,we.specularmap,we.envmap,we.aomap,we.lightmap,we.fog]),vertexShader:et.meshbasic_vert,fragmentShader:et.meshbasic_frag},lambert:{uniforms:Er([we.common,we.specularmap,we.envmap,we.aomap,we.lightmap,we.emissivemap,we.bumpmap,we.normalmap,we.displacementmap,we.fog,we.lights,{emissive:{value:new ye(0)}}]),vertexShader:et.meshlambert_vert,fragmentShader:et.meshlambert_frag},phong:{uniforms:Er([we.common,we.specularmap,we.envmap,we.aomap,we.lightmap,we.emissivemap,we.bumpmap,we.normalmap,we.displacementmap,we.fog,we.lights,{emissive:{value:new ye(0)},specular:{value:new ye(1118481)},shininess:{value:30}}]),vertexShader:et.meshphong_vert,fragmentShader:et.meshphong_frag},standard:{uniforms:Er([we.common,we.envmap,we.aomap,we.lightmap,we.emissivemap,we.bumpmap,we.normalmap,we.displacementmap,we.roughnessmap,we.metalnessmap,we.fog,we.lights,{emissive:{value:new ye(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:et.meshphysical_vert,fragmentShader:et.meshphysical_frag},toon:{uniforms:Er([we.common,we.aomap,we.lightmap,we.emissivemap,we.bumpmap,we.normalmap,we.displacementmap,we.gradientmap,we.fog,we.lights,{emissive:{value:new ye(0)}}]),vertexShader:et.meshtoon_vert,fragmentShader:et.meshtoon_frag},matcap:{uniforms:Er([we.common,we.bumpmap,we.normalmap,we.displacementmap,we.fog,{matcap:{value:null}}]),vertexShader:et.meshmatcap_vert,fragmentShader:et.meshmatcap_frag},points:{uniforms:Er([we.points,we.fog]),vertexShader:et.points_vert,fragmentShader:et.points_frag},dashed:{uniforms:Er([we.common,we.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:et.linedashed_vert,fragmentShader:et.linedashed_frag},depth:{uniforms:Er([we.common,we.displacementmap]),vertexShader:et.depth_vert,fragmentShader:et.depth_frag},normal:{uniforms:Er([we.common,we.bumpmap,we.normalmap,we.displacementmap,{opacity:{value:1}}]),vertexShader:et.meshnormal_vert,fragmentShader:et.meshnormal_frag},sprite:{uniforms:Er([we.sprite,we.fog]),vertexShader:et.sprite_vert,fragmentShader:et.sprite_frag},background:{uniforms:{uvTransform:{value:new rt},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:et.background_vert,fragmentShader:et.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1}},vertexShader:et.backgroundCube_vert,fragmentShader:et.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:et.cube_vert,fragmentShader:et.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:et.equirect_vert,fragmentShader:et.equirect_frag},distanceRGBA:{uniforms:Er([we.common,we.displacementmap,{referencePosition:{value:new k},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:et.distanceRGBA_vert,fragmentShader:et.distanceRGBA_frag},shadow:{uniforms:Er([we.lights,we.fog,{color:{value:new ye(0)},opacity:{value:1}}]),vertexShader:et.shadow_vert,fragmentShader:et.shadow_frag}};Wi.physical={uniforms:Er([Wi.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new rt},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new rt},clearcoatNormalScale:{value:new se(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new rt},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new rt},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new rt},sheen:{value:0},sheenColor:{value:new ye(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new rt},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new rt},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new rt},transmissionSamplerSize:{value:new se},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new rt},attenuationDistance:{value:0},attenuationColor:{value:new ye(0)},specularColor:{value:new ye(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new rt},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new rt},anisotropyVector:{value:new se},anisotropyMap:{value:null},anisotropyMapTransform:{value:new rt}}]),vertexShader:et.meshphysical_vert,fragmentShader:et.meshphysical_frag};const Wp={r:0,b:0,g:0};function m8(r,e,t,n,i,s,o){const a=new ye(0);let c=s===!0?0:1,l,u,h=null,d=0,m=null;function p(g,y){let v=!1,w=y.isScene===!0?y.background:null;w&&w.isTexture&&(w=(y.backgroundBlurriness>0?t:e).get(w)),w===null?b(a,c):w&&w.isColor&&(b(w,1),v=!0);const _=r.xr.getEnvironmentBlendMode();_==="additive"?n.buffers.color.setClear(0,0,0,1,o):_==="alpha-blend"&&n.buffers.color.setClear(0,0,0,0,o),(r.autoClear||v)&&r.clear(r.autoClearColor,r.autoClearDepth,r.autoClearStencil),w&&(w.isCubeTexture||w.mapping===fh)?(u===void 0&&(u=new De(new Qt(1,1,1),new Fr({name:"BackgroundCubeMaterial",uniforms:$u(Wi.backgroundCube.uniforms),vertexShader:Wi.backgroundCube.vertexShader,fragmentShader:Wi.backgroundCube.fragmentShader,side:yr,depthTest:!1,depthWrite:!1,fog:!1})),u.geometry.deleteAttribute("normal"),u.geometry.deleteAttribute("uv"),u.onBeforeRender=function(M,E,C){this.matrixWorld.copyPosition(C.matrixWorld)},Object.defineProperty(u.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(u)),u.material.uniforms.envMap.value=w,u.material.uniforms.flipEnvMap.value=w.isCubeTexture&&w.isRenderTargetTexture===!1?-1:1,u.material.uniforms.backgroundBlurriness.value=y.backgroundBlurriness,u.material.uniforms.backgroundIntensity.value=y.backgroundIntensity,u.material.toneMapped=Ct.getTransfer(w.colorSpace)!==Ft,(h!==w||d!==w.version||m!==r.toneMapping)&&(u.material.needsUpdate=!0,h=w,d=w.version,m=r.toneMapping),u.layers.enableAll(),g.unshift(u,u.geometry,u.material,0,0,null)):w&&w.isTexture&&(l===void 0&&(l=new De(new Pc(2,2),new Fr({name:"BackgroundMaterial",uniforms:$u(Wi.background.uniforms),vertexShader:Wi.background.vertexShader,fragmentShader:Wi.background.fragmentShader,side:Mo,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),Object.defineProperty(l.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(l)),l.material.uniforms.t2D.value=w,l.material.uniforms.backgroundIntensity.value=y.backgroundIntensity,l.material.toneMapped=Ct.getTransfer(w.colorSpace)!==Ft,w.matrixAutoUpdate===!0&&w.updateMatrix(),l.material.uniforms.uvTransform.value.copy(w.matrix),(h!==w||d!==w.version||m!==r.toneMapping)&&(l.material.needsUpdate=!0,h=w,d=w.version,m=r.toneMapping),l.layers.enableAll(),g.unshift(l,l.geometry,l.material,0,0,null))}function b(g,y){g.getRGB(Wp,kL(r)),n.buffers.color.setClear(Wp.r,Wp.g,Wp.b,y,o)}return{getClearColor:function(){return a},setClearColor:function(g,y=1){a.set(g),c=y,b(a,c)},getClearAlpha:function(){return c},setClearAlpha:function(g){c=g,b(a,c)},render:p}}function g8(r,e,t,n){const i=r.getParameter(r.MAX_VERTEX_ATTRIBS),s=n.isWebGL2?null:e.get("OES_vertex_array_object"),o=n.isWebGL2||s!==null,a={},c=g(null);let l=c,u=!1;function h(S,A,P,L,B){let D=!1;if(o){const V=b(L,P,A);l!==V&&(l=V,m(l.object)),D=y(S,L,P,B),D&&v(S,L,P,B)}else{const V=A.wireframe===!0;(l.geometry!==L.id||l.program!==P.id||l.wireframe!==V)&&(l.geometry=L.id,l.program=P.id,l.wireframe=V,D=!0)}B!==null&&t.update(B,r.ELEMENT_ARRAY_BUFFER),(D||u)&&(u=!1,I(S,A,P,L),B!==null&&r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,t.get(B).buffer))}function d(){return n.isWebGL2?r.createVertexArray():s.createVertexArrayOES()}function m(S){return n.isWebGL2?r.bindVertexArray(S):s.bindVertexArrayOES(S)}function p(S){return n.isWebGL2?r.deleteVertexArray(S):s.deleteVertexArrayOES(S)}function b(S,A,P){const L=P.wireframe===!0;let B=a[S.id];B===void 0&&(B={},a[S.id]=B);let D=B[A.id];D===void 0&&(D={},B[A.id]=D);let V=D[L];return V===void 0&&(V=g(d()),D[L]=V),V}function g(S){const A=[],P=[],L=[];for(let B=0;B<i;B++)A[B]=0,P[B]=0,L[B]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:A,enabledAttributes:P,attributeDivisors:L,object:S,attributes:{},index:null}}function y(S,A,P,L){const B=l.attributes,D=A.attributes;let V=0;const z=P.getAttributes();for(const q in z)if(z[q].location>=0){const Y=B[q];let j=D[q];if(j===void 0&&(q==="instanceMatrix"&&S.instanceMatrix&&(j=S.instanceMatrix),q==="instanceColor"&&S.instanceColor&&(j=S.instanceColor)),Y===void 0||Y.attribute!==j||j&&Y.data!==j.data)return!0;V++}return l.attributesNum!==V||l.index!==L}function v(S,A,P,L){const B={},D=A.attributes;let V=0;const z=P.getAttributes();for(const q in z)if(z[q].location>=0){let Y=D[q];Y===void 0&&(q==="instanceMatrix"&&S.instanceMatrix&&(Y=S.instanceMatrix),q==="instanceColor"&&S.instanceColor&&(Y=S.instanceColor));const j={};j.attribute=Y,Y&&Y.data&&(j.data=Y.data),B[q]=j,V++}l.attributes=B,l.attributesNum=V,l.index=L}function w(){const S=l.newAttributes;for(let A=0,P=S.length;A<P;A++)S[A]=0}function _(S){M(S,0)}function M(S,A){const P=l.newAttributes,L=l.enabledAttributes,B=l.attributeDivisors;P[S]=1,L[S]===0&&(r.enableVertexAttribArray(S),L[S]=1),B[S]!==A&&((n.isWebGL2?r:e.get("ANGLE_instanced_arrays"))[n.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](S,A),B[S]=A)}function E(){const S=l.newAttributes,A=l.enabledAttributes;for(let P=0,L=A.length;P<L;P++)A[P]!==S[P]&&(r.disableVertexAttribArray(P),A[P]=0)}function C(S,A,P,L,B,D,V){V===!0?r.vertexAttribIPointer(S,A,P,B,D):r.vertexAttribPointer(S,A,P,L,B,D)}function I(S,A,P,L){if(n.isWebGL2===!1&&(S.isInstancedMesh||L.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;w();const B=L.attributes,D=P.getAttributes(),V=A.defaultAttributeValues;for(const z in D){const q=D[z];if(q.location>=0){let G=B[z];if(G===void 0&&(z==="instanceMatrix"&&S.instanceMatrix&&(G=S.instanceMatrix),z==="instanceColor"&&S.instanceColor&&(G=S.instanceColor)),G!==void 0){const Y=G.normalized,j=G.itemSize,X=t.get(G);if(X===void 0)continue;const ne=X.buffer,oe=X.type,he=X.bytesPerElement,ce=n.isWebGL2===!0&&(oe===r.INT||oe===r.UNSIGNED_INT||G.gpuType===EE);if(G.isInterleavedBufferAttribute){const fe=G.data,W=fe.stride,ue=G.offset;if(fe.isInstancedInterleavedBuffer){for(let re=0;re<q.locationSize;re++)M(q.location+re,fe.meshPerAttribute);S.isInstancedMesh!==!0&&L._maxInstanceCount===void 0&&(L._maxInstanceCount=fe.meshPerAttribute*fe.count)}else for(let re=0;re<q.locationSize;re++)_(q.location+re);r.bindBuffer(r.ARRAY_BUFFER,ne);for(let re=0;re<q.locationSize;re++)C(q.location+re,j/q.locationSize,oe,Y,W*he,(ue+j/q.locationSize*re)*he,ce)}else{if(G.isInstancedBufferAttribute){for(let fe=0;fe<q.locationSize;fe++)M(q.location+fe,G.meshPerAttribute);S.isInstancedMesh!==!0&&L._maxInstanceCount===void 0&&(L._maxInstanceCount=G.meshPerAttribute*G.count)}else for(let fe=0;fe<q.locationSize;fe++)_(q.location+fe);r.bindBuffer(r.ARRAY_BUFFER,ne);for(let fe=0;fe<q.locationSize;fe++)C(q.location+fe,j/q.locationSize,oe,Y,j*he,j/q.locationSize*fe*he,ce)}}else if(V!==void 0){const Y=V[z];if(Y!==void 0)switch(Y.length){case 2:r.vertexAttrib2fv(q.location,Y);break;case 3:r.vertexAttrib3fv(q.location,Y);break;case 4:r.vertexAttrib4fv(q.location,Y);break;default:r.vertexAttrib1fv(q.location,Y)}}}}E()}function x(){$();for(const S in a){const A=a[S];for(const P in A){const L=A[P];for(const B in L)p(L[B].object),delete L[B];delete A[P]}delete a[S]}}function T(S){if(a[S.id]===void 0)return;const A=a[S.id];for(const P in A){const L=A[P];for(const B in L)p(L[B].object),delete L[B];delete A[P]}delete a[S.id]}function F(S){for(const A in a){const P=a[A];if(P[S.id]===void 0)continue;const L=P[S.id];for(const B in L)p(L[B].object),delete L[B];delete P[S.id]}}function $(){H(),u=!0,l!==c&&(l=c,m(l.object))}function H(){c.geometry=null,c.program=null,c.wireframe=!1}return{setup:h,reset:$,resetDefaultState:H,dispose:x,releaseStatesOfGeometry:T,releaseStatesOfProgram:F,initAttributes:w,enableAttribute:_,disableUnusedAttributes:E}}function y8(r,e,t,n){const i=n.isWebGL2;let s;function o(u){s=u}function a(u,h){r.drawArrays(s,u,h),t.update(h,s,1)}function c(u,h,d){if(d===0)return;let m,p;if(i)m=r,p="drawArraysInstanced";else if(m=e.get("ANGLE_instanced_arrays"),p="drawArraysInstancedANGLE",m===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}m[p](s,u,h,d),t.update(h,s,d)}function l(u,h,d){if(d===0)return;const m=e.get("WEBGL_multi_draw");if(m===null)for(let p=0;p<d;p++)this.render(u[p],h[p]);else{m.multiDrawArraysWEBGL(s,u,0,h,0,d);let p=0;for(let b=0;b<d;b++)p+=h[b];t.update(p,s,1)}}this.setMode=o,this.render=a,this.renderInstances=c,this.renderMultiDraw=l}function b8(r,e,t){let n;function i(){if(n!==void 0)return n;if(e.has("EXT_texture_filter_anisotropic")===!0){const C=e.get("EXT_texture_filter_anisotropic");n=r.getParameter(C.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n}function s(C){if(C==="highp"){if(r.getShaderPrecisionFormat(r.VERTEX_SHADER,r.HIGH_FLOAT).precision>0&&r.getShaderPrecisionFormat(r.FRAGMENT_SHADER,r.HIGH_FLOAT).precision>0)return"highp";C="mediump"}return C==="mediump"&&r.getShaderPrecisionFormat(r.VERTEX_SHADER,r.MEDIUM_FLOAT).precision>0&&r.getShaderPrecisionFormat(r.FRAGMENT_SHADER,r.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext<"u"&&r.constructor.name==="WebGL2RenderingContext";let a=t.precision!==void 0?t.precision:"highp";const c=s(a);c!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",c,"instead."),a=c);const l=o||e.has("WEBGL_draw_buffers"),u=t.logarithmicDepthBuffer===!0,h=r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS),d=r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS),m=r.getParameter(r.MAX_TEXTURE_SIZE),p=r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE),b=r.getParameter(r.MAX_VERTEX_ATTRIBS),g=r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS),y=r.getParameter(r.MAX_VARYING_VECTORS),v=r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS),w=d>0,_=o||e.has("OES_texture_float"),M=w&&_,E=o?r.getParameter(r.MAX_SAMPLES):0;return{isWebGL2:o,drawBuffers:l,getMaxAnisotropy:i,getMaxPrecision:s,precision:a,logarithmicDepthBuffer:u,maxTextures:h,maxVertexTextures:d,maxTextureSize:m,maxCubemapSize:p,maxAttributes:b,maxVertexUniforms:g,maxVaryings:y,maxFragmentUniforms:v,vertexTextures:w,floatFragmentTextures:_,floatVertexTextures:M,maxSamples:E}}function w8(r){const e=this;let t=null,n=0,i=!1,s=!1;const o=new ta,a=new rt,c={value:null,needsUpdate:!1};this.uniform=c,this.numPlanes=0,this.numIntersection=0,this.init=function(h,d){const m=h.length!==0||d||n!==0||i;return i=d,n=h.length,m},this.beginShadows=function(){s=!0,u(null)},this.endShadows=function(){s=!1},this.setGlobalState=function(h,d){t=u(h,d,0)},this.setState=function(h,d,m){const p=h.clippingPlanes,b=h.clipIntersection,g=h.clipShadows,y=r.get(h);if(!i||p===null||p.length===0||s&&!g)s?u(null):l();else{const v=s?0:n,w=v*4;let _=y.clippingState||null;c.value=_,_=u(p,d,w,m);for(let M=0;M!==w;++M)_[M]=t[M];y.clippingState=_,this.numIntersection=b?this.numPlanes:0,this.numPlanes+=v}};function l(){c.value!==t&&(c.value=t,c.needsUpdate=n>0),e.numPlanes=n,e.numIntersection=0}function u(h,d,m,p){const b=h!==null?h.length:0;let g=null;if(b!==0){if(g=c.value,p!==!0||g===null){const y=m+b*4,v=d.matrixWorldInverse;a.getNormalMatrix(v),(g===null||g.length<y)&&(g=new Float32Array(y));for(let w=0,_=m;w!==b;++w,_+=4)o.copy(h[w]).applyMatrix4(v,a),o.normal.toArray(g,_),g[_+3]=o.constant}c.value=g,c.needsUpdate=!0}return e.numPlanes=b,e.numIntersection=0,g}}function v8(r){let e=new WeakMap;function t(o,a){return a===Hd?o.mapping=Ao:a===Gd&&(o.mapping=xa),o}function n(o){if(o&&o.isTexture){const a=o.mapping;if(a===Hd||a===Gd)if(e.has(o)){const c=e.get(o).texture;return t(c,o.mapping)}else{const c=o.image;if(c&&c.height>0){const l=new $L(c.height/2);return l.fromEquirectangularTexture(r,o),e.set(o,l),o.addEventListener("dispose",i),t(l.texture,o.mapping)}else return null}}return o}function i(o){const a=o.target;a.removeEventListener("dispose",i);const c=e.get(a);c!==void 0&&(e.delete(a),c.dispose())}function s(){e=new WeakMap}return{get:n,dispose:s}}class c0 extends a0{constructor(e=-1,t=1,n=1,i=-1,s=.1,o=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=n,this.bottom=i,this.near=s,this.far=o,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,n,i,s,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=s,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let s=n-e,o=n+e,a=i+t,c=i-t;if(this.view!==null&&this.view.enabled){const l=(this.right-this.left)/this.view.fullWidth/this.zoom,u=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=l*this.view.offsetX,o=s+l*this.view.width,a-=u*this.view.offsetY,c=a-u*this.view.height}this.projectionMatrix.makeOrthographic(s,o,a,c,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}const Dl=4,NA=[.125,.215,.35,.446,.526,.582],tc=20,Ib=new c0,OA=new ye;let Pb=null,Rb=0,Db=0;const Za=(1+Math.sqrt(5))/2,yl=1/Za,UA=[new k(1,1,1),new k(-1,1,1),new k(1,1,-1),new k(-1,1,-1),new k(0,Za,yl),new k(0,Za,-yl),new k(yl,0,Za),new k(-yl,0,Za),new k(Za,yl,0),new k(-Za,yl,0)];class Fx{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,n=.1,i=100){Pb=this._renderer.getRenderTarget(),Rb=this._renderer.getActiveCubeFace(),Db=this._renderer.getActiveMipmapLevel(),this._setSize(256);const s=this._allocateTargets();return s.depthBuffer=!0,this._sceneToCubeUV(e,n,i,s),t>0&&this._blur(s,0,0,t),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=FA(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=BA(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(Pb,Rb,Db),e.scissorTest=!1,qp(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===Ao||e.mapping===xa?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),Pb=this._renderer.getRenderTarget(),Rb=this._renderer.getActiveCubeFace(),Db=this._renderer.getActiveMipmapLevel();const n=t||this._allocateTargets();return this._textureToCubeUV(e,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,n={magFilter:un,minFilter:un,generateMipmaps:!1,type:ku,format:kr,colorSpace:Ts,depthBuffer:!1},i=kA(e,t,n);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==t){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=kA(e,t,n);const{_lodMax:s}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=_8(s)),this._blurMaterial=x8(s,e,t)}return i}_compileMaterial(e){const t=new De(this._lodPlanes[0],e);this._renderer.compile(t,Ib)}_sceneToCubeUV(e,t,n,i){const a=new In(90,1,t,n),c=[1,-1,1,1,1,1],l=[1,1,1,-1,-1,-1],u=this._renderer,h=u.autoClear,d=u.toneMapping;u.getClearColor(OA),u.toneMapping=vo,u.autoClear=!1;const m=new Ar({name:"PMREM.Background",side:yr,depthWrite:!1,depthTest:!1}),p=new De(new Qt,m);let b=!1;const g=e.background;g?g.isColor&&(m.color.copy(g),e.background=null,b=!0):(m.color.copy(OA),b=!0);for(let y=0;y<6;y++){const v=y%3;v===0?(a.up.set(0,c[y],0),a.lookAt(l[y],0,0)):v===1?(a.up.set(0,0,c[y]),a.lookAt(0,l[y],0)):(a.up.set(0,c[y],0),a.lookAt(0,0,l[y]));const w=this._cubeSize;qp(i,v*w,y>2?w:0,w,w),u.setRenderTarget(i),b&&u.render(p,a),u.render(e,a)}p.geometry.dispose(),p.material.dispose(),u.toneMapping=d,u.autoClear=h,e.background=g}_textureToCubeUV(e,t){const n=this._renderer,i=e.mapping===Ao||e.mapping===xa;i?(this._cubemapMaterial===null&&(this._cubemapMaterial=FA()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=BA());const s=i?this._cubemapMaterial:this._equirectMaterial,o=new De(this._lodPlanes[0],s),a=s.uniforms;a.envMap.value=e;const c=this._cubeSize;qp(t,0,0,3*c,2*c),n.setRenderTarget(t),n.render(o,Ib)}_applyPMREM(e){const t=this._renderer,n=t.autoClear;t.autoClear=!1;for(let i=1;i<this._lodPlanes.length;i++){const s=Math.sqrt(this._sigmas[i]*this._sigmas[i]-this._sigmas[i-1]*this._sigmas[i-1]),o=UA[(i-1)%UA.length];this._blur(e,i-1,i,s,o)}t.autoClear=n}_blur(e,t,n,i,s){const o=this._pingPongRenderTarget;this._halfBlur(e,o,t,n,i,"latitudinal",s),this._halfBlur(o,e,n,n,i,"longitudinal",s)}_halfBlur(e,t,n,i,s,o,a){const c=this._renderer,l=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const u=3,h=new De(this._lodPlanes[i],l),d=l.uniforms,m=this._sizeLods[n]-1,p=isFinite(s)?Math.PI/(2*m):2*Math.PI/(2*tc-1),b=s/p,g=isFinite(s)?1+Math.floor(u*b):tc;g>tc&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${tc}`);const y=[];let v=0;for(let C=0;C<tc;++C){const I=C/b,x=Math.exp(-I*I/2);y.push(x),C===0?v+=x:C<g&&(v+=2*x)}for(let C=0;C<y.length;C++)y[C]=y[C]/v;d.envMap.value=e.texture,d.samples.value=g,d.weights.value=y,d.latitudinal.value=o==="latitudinal",a&&(d.poleAxis.value=a);const{_lodMax:w}=this;d.dTheta.value=p,d.mipInt.value=w-n;const _=this._sizeLods[i],M=3*_*(i>w-Dl?i-w+Dl:0),E=4*(this._cubeSize-_);qp(t,M,E,3*_,2*_),c.setRenderTarget(t),c.render(h,Ib)}}function _8(r){const e=[],t=[],n=[];let i=r;const s=r-Dl+1+NA.length;for(let o=0;o<s;o++){const a=Math.pow(2,i);t.push(a);let c=1/a;o>r-Dl?c=NA[o-r+Dl-1]:o===0&&(c=0),n.push(c);const l=1/(a-2),u=-l,h=1+l,d=[u,u,h,u,h,h,u,u,h,h,u,h],m=6,p=6,b=3,g=2,y=1,v=new Float32Array(b*p*m),w=new Float32Array(g*p*m),_=new Float32Array(y*p*m);for(let E=0;E<m;E++){const C=E%3*2/3-1,I=E>2?0:-1,x=[C,I,0,C+2/3,I,0,C+2/3,I+1,0,C,I,0,C+2/3,I+1,0,C,I+1,0];v.set(x,b*p*E),w.set(d,g*p*E);const T=[E,E,E,E,E,E];_.set(T,y*p*E)}const M=new Ye;M.setAttribute("position",new It(v,b)),M.setAttribute("uv",new It(w,g)),M.setAttribute("faceIndex",new It(_,y)),e.push(M),i>Dl&&i--}return{lodPlanes:e,sizeLods:t,sigmas:n}}function kA(r,e,t){const n=new ts(r,e,t);return n.texture.mapping=fh,n.texture.name="PMREM.cubeUv",n.scissorTest=!0,n}function qp(r,e,t,n,i){r.viewport.set(e,t,n,i),r.scissor.set(e,t,n,i)}function x8(r,e,t){const n=new Float32Array(tc),i=new k(0,1,0);return new Fr({name:"SphericalGaussianBlur",defines:{n:tc,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${r}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:n},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:FE(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:wo,depthTest:!1,depthWrite:!1})}function BA(){return new Fr({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:FE(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:wo,depthTest:!1,depthWrite:!1})}function FA(){return new Fr({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:FE(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:wo,depthTest:!1,depthWrite:!1})}function FE(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function S8(r){let e=new WeakMap,t=null;function n(a){if(a&&a.isTexture){const c=a.mapping,l=c===Hd||c===Gd,u=c===Ao||c===xa;if(l||u)if(a.isRenderTargetTexture&&a.needsPMREMUpdate===!0){a.needsPMREMUpdate=!1;let h=e.get(a);return t===null&&(t=new Fx(r)),h=l?t.fromEquirectangular(a,h):t.fromCubemap(a,h),e.set(a,h),h.texture}else{if(e.has(a))return e.get(a).texture;{const h=a.image;if(l&&h&&h.height>0||u&&h&&i(h)){t===null&&(t=new Fx(r));const d=l?t.fromEquirectangular(a):t.fromCubemap(a);return e.set(a,d),a.addEventListener("dispose",s),d.texture}else return null}}}return a}function i(a){let c=0;const l=6;for(let u=0;u<l;u++)a[u]!==void 0&&c++;return c===l}function s(a){const c=a.target;c.removeEventListener("dispose",s);const l=e.get(c);l!==void 0&&(e.delete(c),l.dispose())}function o(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:n,dispose:o}}function E8(r){const e={};function t(n){if(e[n]!==void 0)return e[n];let i;switch(n){case"WEBGL_depth_texture":i=r.getExtension("WEBGL_depth_texture")||r.getExtension("MOZ_WEBGL_depth_texture")||r.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=r.getExtension("EXT_texture_filter_anisotropic")||r.getExtension("MOZ_EXT_texture_filter_anisotropic")||r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=r.getExtension("WEBGL_compressed_texture_s3tc")||r.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=r.getExtension("WEBGL_compressed_texture_pvrtc")||r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=r.getExtension(n)}return e[n]=i,i}return{has:function(n){return t(n)!==null},init:function(n){n.isWebGL2?(t("EXT_color_buffer_float"),t("WEBGL_clip_cull_distance")):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture")},get:function(n){const i=t(n);return i===null&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),i}}}function M8(r,e,t,n){const i={},s=new WeakMap;function o(h){const d=h.target;d.index!==null&&e.remove(d.index);for(const p in d.attributes)e.remove(d.attributes[p]);for(const p in d.morphAttributes){const b=d.morphAttributes[p];for(let g=0,y=b.length;g<y;g++)e.remove(b[g])}d.removeEventListener("dispose",o),delete i[d.id];const m=s.get(d);m&&(e.remove(m),s.delete(d)),n.releaseStatesOfGeometry(d),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,t.memory.geometries--}function a(h,d){return i[d.id]===!0||(d.addEventListener("dispose",o),i[d.id]=!0,t.memory.geometries++),d}function c(h){const d=h.attributes;for(const p in d)e.update(d[p],r.ARRAY_BUFFER);const m=h.morphAttributes;for(const p in m){const b=m[p];for(let g=0,y=b.length;g<y;g++)e.update(b[g],r.ARRAY_BUFFER)}}function l(h){const d=[],m=h.index,p=h.attributes.position;let b=0;if(m!==null){const v=m.array;b=m.version;for(let w=0,_=v.length;w<_;w+=3){const M=v[w+0],E=v[w+1],C=v[w+2];d.push(M,E,E,C,C,M)}}else if(p!==void 0){const v=p.array;b=p.version;for(let w=0,_=v.length/3-1;w<_;w+=3){const M=w+0,E=w+1,C=w+2;d.push(M,E,E,C,C,M)}}else return;const g=new(LL(d)?BE:kE)(d,1);g.version=b;const y=s.get(h);y&&e.remove(y),s.set(h,g)}function u(h){const d=s.get(h);if(d){const m=h.index;m!==null&&d.version<m.version&&l(h)}else l(h);return s.get(h)}return{get:a,update:c,getWireframeAttribute:u}}function A8(r,e,t,n){const i=n.isWebGL2;let s;function o(m){s=m}let a,c;function l(m){a=m.type,c=m.bytesPerElement}function u(m,p){r.drawElements(s,p,a,m*c),t.update(p,s,1)}function h(m,p,b){if(b===0)return;let g,y;if(i)g=r,y="drawElementsInstanced";else if(g=e.get("ANGLE_instanced_arrays"),y="drawElementsInstancedANGLE",g===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}g[y](s,p,a,m*c,b),t.update(p,s,b)}function d(m,p,b){if(b===0)return;const g=e.get("WEBGL_multi_draw");if(g===null)for(let y=0;y<b;y++)this.render(m[y]/c,p[y]);else{g.multiDrawElementsWEBGL(s,p,0,a,m,0,b);let y=0;for(let v=0;v<b;v++)y+=p[v];t.update(y,s,1)}}this.setMode=o,this.setIndex=l,this.render=u,this.renderInstances=h,this.renderMultiDraw=d}function T8(r){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function n(s,o,a){switch(t.calls++,o){case r.TRIANGLES:t.triangles+=a*(s/3);break;case r.LINES:t.lines+=a*(s/2);break;case r.LINE_STRIP:t.lines+=a*(s-1);break;case r.LINE_LOOP:t.lines+=a*s;break;case r.POINTS:t.points+=a*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function i(){t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:i,update:n}}function C8(r,e){return r[0]-e[0]}function I8(r,e){return Math.abs(e[1])-Math.abs(r[1])}function P8(r,e,t){const n={},i=new Float32Array(8),s=new WeakMap,o=new mt,a=[];for(let l=0;l<8;l++)a[l]=[l,0];function c(l,u,h){const d=l.morphTargetInfluences;if(e.isWebGL2===!0){const m=u.morphAttributes.position||u.morphAttributes.normal||u.morphAttributes.color,p=m!==void 0?m.length:0;let b=s.get(u);if(b===void 0||b.count!==p){let S=function(){$.dispose(),s.delete(u),u.removeEventListener("dispose",S)};b!==void 0&&b.texture.dispose();const v=u.morphAttributes.position!==void 0,w=u.morphAttributes.normal!==void 0,_=u.morphAttributes.color!==void 0,M=u.morphAttributes.position||[],E=u.morphAttributes.normal||[],C=u.morphAttributes.color||[];let I=0;v===!0&&(I=1),w===!0&&(I=2),_===!0&&(I=3);let x=u.attributes.position.count*I,T=1;x>e.maxTextureSize&&(T=Math.ceil(x/e.maxTextureSize),x=e.maxTextureSize);const F=new Float32Array(x*T*4*p),$=new s0(F,x,T,p);$.type=Ki,$.needsUpdate=!0;const H=I*4;for(let A=0;A<p;A++){const P=M[A],L=E[A],B=C[A],D=x*T*4*A;for(let V=0;V<P.count;V++){const z=V*H;v===!0&&(o.fromBufferAttribute(P,V),F[D+z+0]=o.x,F[D+z+1]=o.y,F[D+z+2]=o.z,F[D+z+3]=0),w===!0&&(o.fromBufferAttribute(L,V),F[D+z+4]=o.x,F[D+z+5]=o.y,F[D+z+6]=o.z,F[D+z+7]=0),_===!0&&(o.fromBufferAttribute(B,V),F[D+z+8]=o.x,F[D+z+9]=o.y,F[D+z+10]=o.z,F[D+z+11]=B.itemSize===4?o.w:1)}}b={count:p,texture:$,size:new se(x,T)},s.set(u,b),u.addEventListener("dispose",S)}let g=0;for(let v=0;v<d.length;v++)g+=d[v];const y=u.morphTargetsRelative?1:1-g;h.getUniforms().setValue(r,"morphTargetBaseInfluence",y),h.getUniforms().setValue(r,"morphTargetInfluences",d),h.getUniforms().setValue(r,"morphTargetsTexture",b.texture,t),h.getUniforms().setValue(r,"morphTargetsTextureSize",b.size)}else{const m=d===void 0?0:d.length;let p=n[u.id];if(p===void 0||p.length!==m){p=[];for(let w=0;w<m;w++)p[w]=[w,0];n[u.id]=p}for(let w=0;w<m;w++){const _=p[w];_[0]=w,_[1]=d[w]}p.sort(I8);for(let w=0;w<8;w++)w<m&&p[w][1]?(a[w][0]=p[w][0],a[w][1]=p[w][1]):(a[w][0]=Number.MAX_SAFE_INTEGER,a[w][1]=0);a.sort(C8);const b=u.morphAttributes.position,g=u.morphAttributes.normal;let y=0;for(let w=0;w<8;w++){const _=a[w],M=_[0],E=_[1];M!==Number.MAX_SAFE_INTEGER&&E?(b&&u.getAttribute("morphTarget"+w)!==b[M]&&u.setAttribute("morphTarget"+w,b[M]),g&&u.getAttribute("morphNormal"+w)!==g[M]&&u.setAttribute("morphNormal"+w,g[M]),i[w]=E,y+=E):(b&&u.hasAttribute("morphTarget"+w)===!0&&u.deleteAttribute("morphTarget"+w),g&&u.hasAttribute("morphNormal"+w)===!0&&u.deleteAttribute("morphNormal"+w),i[w]=0)}const v=u.morphTargetsRelative?1:1-y;h.getUniforms().setValue(r,"morphTargetBaseInfluence",v),h.getUniforms().setValue(r,"morphTargetInfluences",i)}}return{update:c}}function R8(r,e,t,n){let i=new WeakMap;function s(c){const l=n.render.frame,u=c.geometry,h=e.get(c,u);if(i.get(h)!==l&&(e.update(h),i.set(h,l)),c.isInstancedMesh&&(c.hasEventListener("dispose",a)===!1&&c.addEventListener("dispose",a),i.get(c)!==l&&(t.update(c.instanceMatrix,r.ARRAY_BUFFER),c.instanceColor!==null&&t.update(c.instanceColor,r.ARRAY_BUFFER),i.set(c,l))),c.isSkinnedMesh){const d=c.skeleton;i.get(d)!==l&&(d.update(),i.set(d,l))}return h}function o(){i=new WeakMap}function a(c){const l=c.target;l.removeEventListener("dispose",a),t.remove(l.instanceMatrix),l.instanceColor!==null&&t.remove(l.instanceColor)}return{update:s,dispose:o}}class $E extends hn{constructor(e,t,n,i,s,o,a,c,l,u){if(u=u!==void 0?u:ba,u!==ba&&u!==Ic)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&u===ba&&(n=io),n===void 0&&u===Ic&&(n=ya),super(null,i,s,o,a,c,u,n,l),this.isDepthTexture=!0,this.image={width:e,height:t},this.magFilter=a!==void 0?a:ln,this.minFilter=c!==void 0?c:ln,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(e){return super.copy(e),this.compareFunction=e.compareFunction,this}toJSON(e){const t=super.toJSON(e);return this.compareFunction!==null&&(t.compareFunction=this.compareFunction),t}}const VL=new hn,HL=new $E(1,1);HL.compareFunction=LE;const GL=new s0,WL=new UE,qL=new ep,$A=[],zA=[],VA=new Float32Array(16),HA=new Float32Array(9),GA=new Float32Array(4);function mh(r,e,t){const n=r[0];if(n<=0||n>0)return r;const i=e*t;let s=$A[i];if(s===void 0&&(s=new Float32Array(i),$A[i]=s),e!==0){n.toArray(s,0);for(let o=1,a=0;o!==e;++o)a+=t,r[o].toArray(s,a)}return s}function _n(r,e){if(r.length!==e.length)return!1;for(let t=0,n=r.length;t<n;t++)if(r[t]!==e[t])return!1;return!0}function xn(r,e){for(let t=0,n=e.length;t<n;t++)r[t]=e[t]}function l0(r,e){let t=zA[e];t===void 0&&(t=new Int32Array(e),zA[e]=t);for(let n=0;n!==e;++n)t[n]=r.allocateTextureUnit();return t}function D8(r,e){const t=this.cache;t[0]!==e&&(r.uniform1f(this.addr,e),t[0]=e)}function L8(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(r.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(_n(t,e))return;r.uniform2fv(this.addr,e),xn(t,e)}}function N8(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(r.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(r.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(_n(t,e))return;r.uniform3fv(this.addr,e),xn(t,e)}}function O8(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(r.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(_n(t,e))return;r.uniform4fv(this.addr,e),xn(t,e)}}function U8(r,e){const t=this.cache,n=e.elements;if(n===void 0){if(_n(t,e))return;r.uniformMatrix2fv(this.addr,!1,e),xn(t,e)}else{if(_n(t,n))return;GA.set(n),r.uniformMatrix2fv(this.addr,!1,GA),xn(t,n)}}function k8(r,e){const t=this.cache,n=e.elements;if(n===void 0){if(_n(t,e))return;r.uniformMatrix3fv(this.addr,!1,e),xn(t,e)}else{if(_n(t,n))return;HA.set(n),r.uniformMatrix3fv(this.addr,!1,HA),xn(t,n)}}function B8(r,e){const t=this.cache,n=e.elements;if(n===void 0){if(_n(t,e))return;r.uniformMatrix4fv(this.addr,!1,e),xn(t,e)}else{if(_n(t,n))return;VA.set(n),r.uniformMatrix4fv(this.addr,!1,VA),xn(t,n)}}function F8(r,e){const t=this.cache;t[0]!==e&&(r.uniform1i(this.addr,e),t[0]=e)}function $8(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(r.uniform2i(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(_n(t,e))return;r.uniform2iv(this.addr,e),xn(t,e)}}function z8(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(r.uniform3i(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(_n(t,e))return;r.uniform3iv(this.addr,e),xn(t,e)}}function V8(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(r.uniform4i(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(_n(t,e))return;r.uniform4iv(this.addr,e),xn(t,e)}}function H8(r,e){const t=this.cache;t[0]!==e&&(r.uniform1ui(this.addr,e),t[0]=e)}function G8(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(r.uniform2ui(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(_n(t,e))return;r.uniform2uiv(this.addr,e),xn(t,e)}}function W8(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(r.uniform3ui(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(_n(t,e))return;r.uniform3uiv(this.addr,e),xn(t,e)}}function q8(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(r.uniform4ui(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(_n(t,e))return;r.uniform4uiv(this.addr,e),xn(t,e)}}function K8(r,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i);const s=this.type===r.SAMPLER_2D_SHADOW?HL:VL;t.setTexture2D(e||s,i)}function X8(r,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i),t.setTexture3D(e||WL,i)}function Y8(r,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i),t.setTextureCube(e||qL,i)}function Z8(r,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i),t.setTexture2DArray(e||GL,i)}function J8(r){switch(r){case 5126:return D8;case 35664:return L8;case 35665:return N8;case 35666:return O8;case 35674:return U8;case 35675:return k8;case 35676:return B8;case 5124:case 35670:return F8;case 35667:case 35671:return $8;case 35668:case 35672:return z8;case 35669:case 35673:return V8;case 5125:return H8;case 36294:return G8;case 36295:return W8;case 36296:return q8;case 35678:case 36198:case 36298:case 36306:case 35682:return K8;case 35679:case 36299:case 36307:return X8;case 35680:case 36300:case 36308:case 36293:return Y8;case 36289:case 36303:case 36311:case 36292:return Z8}}function j8(r,e){r.uniform1fv(this.addr,e)}function Q8(r,e){const t=mh(e,this.size,2);r.uniform2fv(this.addr,t)}function eV(r,e){const t=mh(e,this.size,3);r.uniform3fv(this.addr,t)}function tV(r,e){const t=mh(e,this.size,4);r.uniform4fv(this.addr,t)}function nV(r,e){const t=mh(e,this.size,4);r.uniformMatrix2fv(this.addr,!1,t)}function rV(r,e){const t=mh(e,this.size,9);r.uniformMatrix3fv(this.addr,!1,t)}function iV(r,e){const t=mh(e,this.size,16);r.uniformMatrix4fv(this.addr,!1,t)}function sV(r,e){r.uniform1iv(this.addr,e)}function oV(r,e){r.uniform2iv(this.addr,e)}function aV(r,e){r.uniform3iv(this.addr,e)}function cV(r,e){r.uniform4iv(this.addr,e)}function lV(r,e){r.uniform1uiv(this.addr,e)}function uV(r,e){r.uniform2uiv(this.addr,e)}function hV(r,e){r.uniform3uiv(this.addr,e)}function dV(r,e){r.uniform4uiv(this.addr,e)}function fV(r,e,t){const n=this.cache,i=e.length,s=l0(t,i);_n(n,s)||(r.uniform1iv(this.addr,s),xn(n,s));for(let o=0;o!==i;++o)t.setTexture2D(e[o]||VL,s[o])}function pV(r,e,t){const n=this.cache,i=e.length,s=l0(t,i);_n(n,s)||(r.uniform1iv(this.addr,s),xn(n,s));for(let o=0;o!==i;++o)t.setTexture3D(e[o]||WL,s[o])}function mV(r,e,t){const n=this.cache,i=e.length,s=l0(t,i);_n(n,s)||(r.uniform1iv(this.addr,s),xn(n,s));for(let o=0;o!==i;++o)t.setTextureCube(e[o]||qL,s[o])}function gV(r,e,t){const n=this.cache,i=e.length,s=l0(t,i);_n(n,s)||(r.uniform1iv(this.addr,s),xn(n,s));for(let o=0;o!==i;++o)t.setTexture2DArray(e[o]||GL,s[o])}function yV(r){switch(r){case 5126:return j8;case 35664:return Q8;case 35665:return eV;case 35666:return tV;case 35674:return nV;case 35675:return rV;case 35676:return iV;case 5124:case 35670:return sV;case 35667:case 35671:return oV;case 35668:case 35672:return aV;case 35669:case 35673:return cV;case 5125:return lV;case 36294:return uV;case 36295:return hV;case 36296:return dV;case 35678:case 36198:case 36298:case 36306:case 35682:return fV;case 35679:case 36299:case 36307:return pV;case 35680:case 36300:case 36308:case 36293:return mV;case 36289:case 36303:case 36311:case 36292:return gV}}class bV{constructor(e,t,n){this.id=e,this.addr=n,this.cache=[],this.type=t.type,this.setValue=J8(t.type)}}class wV{constructor(e,t,n){this.id=e,this.addr=n,this.cache=[],this.type=t.type,this.size=t.size,this.setValue=yV(t.type)}}class vV{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,n){const i=this.seq;for(let s=0,o=i.length;s!==o;++s){const a=i[s];a.setValue(e,t[a.id],n)}}}const Lb=/(\w+)(\])?(\[|\.)?/g;function WA(r,e){r.seq.push(e),r.map[e.id]=e}function _V(r,e,t){const n=r.name,i=n.length;for(Lb.lastIndex=0;;){const s=Lb.exec(n),o=Lb.lastIndex;let a=s[1];const c=s[2]==="]",l=s[3];if(c&&(a=a|0),l===void 0||l==="["&&o+2===i){WA(t,l===void 0?new bV(a,r,e):new wV(a,r,e));break}else{let h=t.map[a];h===void 0&&(h=new vV(a),WA(t,h)),t=h}}}class fg{constructor(e,t){this.seq=[],this.map={};const n=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);for(let i=0;i<n;++i){const s=e.getActiveUniform(t,i),o=e.getUniformLocation(t,s.name);_V(s,o,this)}}setValue(e,t,n,i){const s=this.map[t];s!==void 0&&s.setValue(e,n,i)}setOptional(e,t,n){const i=t[n];i!==void 0&&this.setValue(e,n,i)}static upload(e,t,n,i){for(let s=0,o=t.length;s!==o;++s){const a=t[s],c=n[a.id];c.needsUpdate!==!1&&a.setValue(e,c.value,i)}}static seqWithValue(e,t){const n=[];for(let i=0,s=e.length;i!==s;++i){const o=e[i];o.id in t&&n.push(o)}return n}}function qA(r,e,t){const n=r.createShader(e);return r.shaderSource(n,t),r.compileShader(n),n}const xV=37297;let SV=0;function EV(r,e){const t=r.split(`
`),n=[],i=Math.max(e-6,0),s=Math.min(e+6,t.length);for(let o=i;o<s;o++){const a=o+1;n.push(`${a===e?">":" "} ${a}: ${t[o]}`)}return n.join(`
`)}function MV(r){const e=Ct.getPrimaries(Ct.workingColorSpace),t=Ct.getPrimaries(r);let n;switch(e===t?n="":e===jd&&t===Jd?n="LinearDisplayP3ToLinearSRGB":e===Jd&&t===jd&&(n="LinearSRGBToLinearDisplayP3"),r){case Ts:case jf:return[n,"LinearTransferOETF"];case bn:case i0:return[n,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space:",r),[n,"LinearTransferOETF"]}}function KA(r,e,t){const n=r.getShaderParameter(e,r.COMPILE_STATUS),i=r.getShaderInfoLog(e).trim();if(n&&i==="")return"";const s=/ERROR: 0:(\d+)/.exec(i);if(s){const o=parseInt(s[1]);return t.toUpperCase()+`

`+i+`

`+EV(r.getShaderSource(e),o)}else return i}function AV(r,e){const t=MV(e);return`vec4 ${r}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`}function TV(r,e){let t;switch(e){case sL:t="Linear";break;case oL:t="Reinhard";break;case aL:t="OptimizedCineon";break;case cL:t="ACESFilmic";break;case uL:t="AgX";break;case lL:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+r+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function CV(r){return[r.extensionDerivatives||r.envMapCubeUVHeight||r.bumpMap||r.normalMapTangentSpace||r.clearcoatNormalMap||r.flatShading||r.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(r.extensionFragDepth||r.logarithmicDepthBuffer)&&r.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",r.extensionDrawBuffers&&r.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(r.extensionShaderTextureLOD||r.envMap||r.transmission)&&r.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Ll).join(`
`)}function IV(r){return[r.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":""].filter(Ll).join(`
`)}function PV(r){const e=[];for(const t in r){const n=r[t];n!==!1&&e.push("#define "+t+" "+n)}return e.join(`
`)}function RV(r,e){const t={},n=r.getProgramParameter(e,r.ACTIVE_ATTRIBUTES);for(let i=0;i<n;i++){const s=r.getActiveAttrib(e,i),o=s.name;let a=1;s.type===r.FLOAT_MAT2&&(a=2),s.type===r.FLOAT_MAT3&&(a=3),s.type===r.FLOAT_MAT4&&(a=4),t[o]={type:s.type,location:r.getAttribLocation(e,o),locationSize:a}}return t}function Ll(r){return r!==""}function XA(r,e){const t=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return r.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,t).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function YA(r,e){return r.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const DV=/^[ \t]*#include +<([\w\d./]+)>/gm;function $x(r){return r.replace(DV,NV)}const LV=new Map([["encodings_fragment","colorspace_fragment"],["encodings_pars_fragment","colorspace_pars_fragment"],["output_fragment","opaque_fragment"]]);function NV(r,e){let t=et[e];if(t===void 0){const n=LV.get(e);if(n!==void 0)t=et[n],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',e,n);else throw new Error("Can not resolve #include <"+e+">")}return $x(t)}const OV=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function ZA(r){return r.replace(OV,UV)}function UV(r,e,t,n){let i="";for(let s=parseInt(e);s<parseInt(t);s++)i+=n.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return i}function JA(r){let e="precision "+r.precision+` float;
precision `+r.precision+" int;";return r.precision==="highp"?e+=`
#define HIGH_PRECISION`:r.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:r.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function kV(r){let e="SHADOWMAP_TYPE_BASIC";return r.shadowMapType===_E?e="SHADOWMAP_TYPE_PCF":r.shadowMapType===xE?e="SHADOWMAP_TYPE_PCF_SOFT":r.shadowMapType===hs&&(e="SHADOWMAP_TYPE_VSM"),e}function BV(r){let e="ENVMAP_TYPE_CUBE";if(r.envMap)switch(r.envMapMode){case Ao:case xa:e="ENVMAP_TYPE_CUBE";break;case fh:e="ENVMAP_TYPE_CUBE_UV";break}return e}function FV(r){let e="ENVMAP_MODE_REFLECTION";if(r.envMap)switch(r.envMapMode){case xa:e="ENVMAP_MODE_REFRACTION";break}return e}function $V(r){let e="ENVMAP_BLENDING_NONE";if(r.envMap)switch(r.combine){case Jf:e="ENVMAP_BLENDING_MULTIPLY";break;case rL:e="ENVMAP_BLENDING_MIX";break;case iL:e="ENVMAP_BLENDING_ADD";break}return e}function zV(r){const e=r.envMapCubeUVHeight;if(e===null)return null;const t=Math.log2(e)-2,n=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),112)),texelHeight:n,maxMip:t}}function VV(r,e,t,n){const i=r.getContext(),s=t.defines;let o=t.vertexShader,a=t.fragmentShader;const c=kV(t),l=BV(t),u=FV(t),h=$V(t),d=zV(t),m=t.isWebGL2?"":CV(t),p=IV(t),b=PV(s),g=i.createProgram();let y,v,w=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(y=["#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,b].filter(Ll).join(`
`),y.length>0&&(y+=`
`),v=[m,"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,b].filter(Ll).join(`
`),v.length>0&&(v+=`
`)):(y=[JA(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,b,t.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",t.batching?"#define USE_BATCHING":"",t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+u:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.displacementMap?"#define USE_DISPLACEMENTMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.mapUv?"#define MAP_UV "+t.mapUv:"",t.alphaMapUv?"#define ALPHAMAP_UV "+t.alphaMapUv:"",t.lightMapUv?"#define LIGHTMAP_UV "+t.lightMapUv:"",t.aoMapUv?"#define AOMAP_UV "+t.aoMapUv:"",t.emissiveMapUv?"#define EMISSIVEMAP_UV "+t.emissiveMapUv:"",t.bumpMapUv?"#define BUMPMAP_UV "+t.bumpMapUv:"",t.normalMapUv?"#define NORMALMAP_UV "+t.normalMapUv:"",t.displacementMapUv?"#define DISPLACEMENTMAP_UV "+t.displacementMapUv:"",t.metalnessMapUv?"#define METALNESSMAP_UV "+t.metalnessMapUv:"",t.roughnessMapUv?"#define ROUGHNESSMAP_UV "+t.roughnessMapUv:"",t.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+t.anisotropyMapUv:"",t.clearcoatMapUv?"#define CLEARCOATMAP_UV "+t.clearcoatMapUv:"",t.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+t.clearcoatNormalMapUv:"",t.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+t.clearcoatRoughnessMapUv:"",t.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+t.iridescenceMapUv:"",t.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+t.iridescenceThicknessMapUv:"",t.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+t.sheenColorMapUv:"",t.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+t.sheenRoughnessMapUv:"",t.specularMapUv?"#define SPECULARMAP_UV "+t.specularMapUv:"",t.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+t.specularColorMapUv:"",t.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+t.specularIntensityMapUv:"",t.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+t.transmissionMapUv:"",t.thicknessMapUv?"#define THICKNESSMAP_UV "+t.thicknessMapUv:"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors&&t.isWebGL2?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+c:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.useLegacyLights?"#define LEGACY_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Ll).join(`
`),v=[m,JA(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,b,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+l:"",t.envMap?"#define "+u:"",t.envMap?"#define "+h:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescence?"#define USE_IRIDESCENCE":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+c:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.useLegacyLights?"#define LEGACY_LIGHTS":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==vo?"#define TONE_MAPPING":"",t.toneMapping!==vo?et.tonemapping_pars_fragment:"",t.toneMapping!==vo?TV("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",et.colorspace_pars_fragment,AV("linearToOutputTexel",t.outputColorSpace),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(Ll).join(`
`)),o=$x(o),o=XA(o,t),o=YA(o,t),a=$x(a),a=XA(a,t),a=YA(a,t),o=ZA(o),a=ZA(a),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(w=`#version 300 es
`,y=[p,"precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+y,v=["precision mediump sampler2DArray;","#define varying in",t.glslVersion===kx?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===kx?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+v);const _=w+y+o,M=w+v+a,E=qA(i,i.VERTEX_SHADER,_),C=qA(i,i.FRAGMENT_SHADER,M);i.attachShader(g,E),i.attachShader(g,C),t.index0AttributeName!==void 0?i.bindAttribLocation(g,0,t.index0AttributeName):t.morphTargets===!0&&i.bindAttribLocation(g,0,"position"),i.linkProgram(g);function I($){if(r.debug.checkShaderErrors){const H=i.getProgramInfoLog(g).trim(),S=i.getShaderInfoLog(E).trim(),A=i.getShaderInfoLog(C).trim();let P=!0,L=!0;if(i.getProgramParameter(g,i.LINK_STATUS)===!1)if(P=!1,typeof r.debug.onShaderError=="function")r.debug.onShaderError(i,g,E,C);else{const B=KA(i,E,"vertex"),D=KA(i,C,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(g,i.VALIDATE_STATUS)+`

Program Info Log: `+H+`
`+B+`
`+D)}else H!==""?console.warn("THREE.WebGLProgram: Program Info Log:",H):(S===""||A==="")&&(L=!1);L&&($.diagnostics={runnable:P,programLog:H,vertexShader:{log:S,prefix:y},fragmentShader:{log:A,prefix:v}})}i.deleteShader(E),i.deleteShader(C),x=new fg(i,g),T=RV(i,g)}let x;this.getUniforms=function(){return x===void 0&&I(this),x};let T;this.getAttributes=function(){return T===void 0&&I(this),T};let F=t.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return F===!1&&(F=i.getProgramParameter(g,xV)),F},this.destroy=function(){n.releaseStatesOfProgram(this),i.deleteProgram(g),this.program=void 0},this.type=t.shaderType,this.name=t.shaderName,this.id=SV++,this.cacheKey=e,this.usedTimes=1,this.program=g,this.vertexShader=E,this.fragmentShader=C,this}let HV=0;class GV{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,n=e.fragmentShader,i=this._getShaderStage(t),s=this._getShaderStage(n),o=this._getShaderCacheForMaterial(e);return o.has(i)===!1&&(o.add(i),i.usedTimes++),o.has(s)===!1&&(o.add(s),s.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const n of t)n.usedTimes--,n.usedTimes===0&&this.shaderCache.delete(n.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;let n=t.get(e);return n===void 0&&(n=new Set,t.set(e,n)),n}_getShaderStage(e){const t=this.shaderCache;let n=t.get(e);return n===void 0&&(n=new WV(e),t.set(e,n)),n}}class WV{constructor(e){this.id=HV++,this.code=e,this.usedTimes=0}}function qV(r,e,t,n,i,s,o){const a=new o0,c=new GV,l=[],u=i.isWebGL2,h=i.logarithmicDepthBuffer,d=i.vertexTextures;let m=i.precision;const p={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function b(x){return x===0?"uv":`uv${x}`}function g(x,T,F,$,H){const S=$.fog,A=H.geometry,P=x.isMeshStandardMaterial?$.environment:null,L=(x.isMeshStandardMaterial?t:e).get(x.envMap||P),B=L&&L.mapping===fh?L.image.height:null,D=p[x.type];x.precision!==null&&(m=i.getMaxPrecision(x.precision),m!==x.precision&&console.warn("THREE.WebGLProgram.getParameters:",x.precision,"not supported, using",m,"instead."));const V=A.morphAttributes.position||A.morphAttributes.normal||A.morphAttributes.color,z=V!==void 0?V.length:0;let q=0;A.morphAttributes.position!==void 0&&(q=1),A.morphAttributes.normal!==void 0&&(q=2),A.morphAttributes.color!==void 0&&(q=3);let G,Y,j,X;if(D){const _r=Wi[D];G=_r.vertexShader,Y=_r.fragmentShader}else G=x.vertexShader,Y=x.fragmentShader,c.update(x),j=c.getVertexShaderID(x),X=c.getFragmentShaderID(x);const ne=r.getRenderTarget(),oe=H.isInstancedMesh===!0,he=H.isBatchedMesh===!0,ce=!!x.map,fe=!!x.matcap,W=!!L,ue=!!x.aoMap,re=!!x.lightMap,le=!!x.bumpMap,ie=!!x.normalMap,Oe=!!x.displacementMap,Te=!!x.emissiveMap,O=!!x.metalnessMap,R=!!x.roughnessMap,J=x.anisotropy>0,ge=x.clearcoat>0,pe=x.iridescence>0,de=x.sheen>0,Le=x.transmission>0,Ee=J&&!!x.anisotropyMap,Pe=ge&&!!x.clearcoatMap,ze=ge&&!!x.clearcoatNormalMap,je=ge&&!!x.clearcoatRoughnessMap,me=pe&&!!x.iridescenceMap,_t=pe&&!!x.iridescenceThicknessMap,ct=de&&!!x.sheenColorMap,Xe=de&&!!x.sheenRoughnessMap,ke=!!x.specularMap,Re=!!x.specularColorMap,nt=!!x.specularIntensityMap,Tt=Le&&!!x.transmissionMap,Zt=Le&&!!x.thicknessMap,st=!!x.gradientMap,ve=!!x.alphaMap,K=x.alphaTest>0,Me=!!x.alphaHash,Ae=!!x.extensions,qe=!!A.attributes.uv1,Ve=!!A.attributes.uv2,Ut=!!A.attributes.uv3;let kt=vo;return x.toneMapped&&(ne===null||ne.isXRRenderTarget===!0)&&(kt=r.toneMapping),{isWebGL2:u,shaderID:D,shaderType:x.type,shaderName:x.name,vertexShader:G,fragmentShader:Y,defines:x.defines,customVertexShaderID:j,customFragmentShaderID:X,isRawShaderMaterial:x.isRawShaderMaterial===!0,glslVersion:x.glslVersion,precision:m,batching:he,instancing:oe,instancingColor:oe&&H.instanceColor!==null,supportsVertexTextures:d,outputColorSpace:ne===null?r.outputColorSpace:ne.isXRRenderTarget===!0?ne.texture.colorSpace:Ts,map:ce,matcap:fe,envMap:W,envMapMode:W&&L.mapping,envMapCubeUVHeight:B,aoMap:ue,lightMap:re,bumpMap:le,normalMap:ie,displacementMap:d&&Oe,emissiveMap:Te,normalMapObjectSpace:ie&&x.normalMapType===ML,normalMapTangentSpace:ie&&x.normalMapType===Ra,metalnessMap:O,roughnessMap:R,anisotropy:J,anisotropyMap:Ee,clearcoat:ge,clearcoatMap:Pe,clearcoatNormalMap:ze,clearcoatRoughnessMap:je,iridescence:pe,iridescenceMap:me,iridescenceThicknessMap:_t,sheen:de,sheenColorMap:ct,sheenRoughnessMap:Xe,specularMap:ke,specularColorMap:Re,specularIntensityMap:nt,transmission:Le,transmissionMap:Tt,thicknessMap:Zt,gradientMap:st,opaque:x.transparent===!1&&x.blending===xc,alphaMap:ve,alphaTest:K,alphaHash:Me,combine:x.combine,mapUv:ce&&b(x.map.channel),aoMapUv:ue&&b(x.aoMap.channel),lightMapUv:re&&b(x.lightMap.channel),bumpMapUv:le&&b(x.bumpMap.channel),normalMapUv:ie&&b(x.normalMap.channel),displacementMapUv:Oe&&b(x.displacementMap.channel),emissiveMapUv:Te&&b(x.emissiveMap.channel),metalnessMapUv:O&&b(x.metalnessMap.channel),roughnessMapUv:R&&b(x.roughnessMap.channel),anisotropyMapUv:Ee&&b(x.anisotropyMap.channel),clearcoatMapUv:Pe&&b(x.clearcoatMap.channel),clearcoatNormalMapUv:ze&&b(x.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:je&&b(x.clearcoatRoughnessMap.channel),iridescenceMapUv:me&&b(x.iridescenceMap.channel),iridescenceThicknessMapUv:_t&&b(x.iridescenceThicknessMap.channel),sheenColorMapUv:ct&&b(x.sheenColorMap.channel),sheenRoughnessMapUv:Xe&&b(x.sheenRoughnessMap.channel),specularMapUv:ke&&b(x.specularMap.channel),specularColorMapUv:Re&&b(x.specularColorMap.channel),specularIntensityMapUv:nt&&b(x.specularIntensityMap.channel),transmissionMapUv:Tt&&b(x.transmissionMap.channel),thicknessMapUv:Zt&&b(x.thicknessMap.channel),alphaMapUv:ve&&b(x.alphaMap.channel),vertexTangents:!!A.attributes.tangent&&(ie||J),vertexColors:x.vertexColors,vertexAlphas:x.vertexColors===!0&&!!A.attributes.color&&A.attributes.color.itemSize===4,vertexUv1s:qe,vertexUv2s:Ve,vertexUv3s:Ut,pointsUvs:H.isPoints===!0&&!!A.attributes.uv&&(ce||ve),fog:!!S,useFog:x.fog===!0,fogExp2:S&&S.isFogExp2,flatShading:x.flatShading===!0,sizeAttenuation:x.sizeAttenuation===!0,logarithmicDepthBuffer:h,skinning:H.isSkinnedMesh===!0,morphTargets:A.morphAttributes.position!==void 0,morphNormals:A.morphAttributes.normal!==void 0,morphColors:A.morphAttributes.color!==void 0,morphTargetsCount:z,morphTextureStride:q,numDirLights:T.directional.length,numPointLights:T.point.length,numSpotLights:T.spot.length,numSpotLightMaps:T.spotLightMap.length,numRectAreaLights:T.rectArea.length,numHemiLights:T.hemi.length,numDirLightShadows:T.directionalShadowMap.length,numPointLightShadows:T.pointShadowMap.length,numSpotLightShadows:T.spotShadowMap.length,numSpotLightShadowsWithMaps:T.numSpotLightShadowsWithMaps,numLightProbes:T.numLightProbes,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:x.dithering,shadowMapEnabled:r.shadowMap.enabled&&F.length>0,shadowMapType:r.shadowMap.type,toneMapping:kt,useLegacyLights:r._useLegacyLights,decodeVideoTexture:ce&&x.map.isVideoTexture===!0&&Ct.getTransfer(x.map.colorSpace)===Ft,premultipliedAlpha:x.premultipliedAlpha,doubleSided:x.side===qi,flipSided:x.side===yr,useDepthPacking:x.depthPacking>=0,depthPacking:x.depthPacking||0,index0AttributeName:x.index0AttributeName,extensionDerivatives:Ae&&x.extensions.derivatives===!0,extensionFragDepth:Ae&&x.extensions.fragDepth===!0,extensionDrawBuffers:Ae&&x.extensions.drawBuffers===!0,extensionShaderTextureLOD:Ae&&x.extensions.shaderTextureLOD===!0,extensionClipCullDistance:Ae&&x.extensions.clipCullDistance&&n.has("WEBGL_clip_cull_distance"),rendererExtensionFragDepth:u||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:u||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:u||n.has("EXT_shader_texture_lod"),rendererExtensionParallelShaderCompile:n.has("KHR_parallel_shader_compile"),customProgramCacheKey:x.customProgramCacheKey()}}function y(x){const T=[];if(x.shaderID?T.push(x.shaderID):(T.push(x.customVertexShaderID),T.push(x.customFragmentShaderID)),x.defines!==void 0)for(const F in x.defines)T.push(F),T.push(x.defines[F]);return x.isRawShaderMaterial===!1&&(v(T,x),w(T,x),T.push(r.outputColorSpace)),T.push(x.customProgramCacheKey),T.join()}function v(x,T){x.push(T.precision),x.push(T.outputColorSpace),x.push(T.envMapMode),x.push(T.envMapCubeUVHeight),x.push(T.mapUv),x.push(T.alphaMapUv),x.push(T.lightMapUv),x.push(T.aoMapUv),x.push(T.bumpMapUv),x.push(T.normalMapUv),x.push(T.displacementMapUv),x.push(T.emissiveMapUv),x.push(T.metalnessMapUv),x.push(T.roughnessMapUv),x.push(T.anisotropyMapUv),x.push(T.clearcoatMapUv),x.push(T.clearcoatNormalMapUv),x.push(T.clearcoatRoughnessMapUv),x.push(T.iridescenceMapUv),x.push(T.iridescenceThicknessMapUv),x.push(T.sheenColorMapUv),x.push(T.sheenRoughnessMapUv),x.push(T.specularMapUv),x.push(T.specularColorMapUv),x.push(T.specularIntensityMapUv),x.push(T.transmissionMapUv),x.push(T.thicknessMapUv),x.push(T.combine),x.push(T.fogExp2),x.push(T.sizeAttenuation),x.push(T.morphTargetsCount),x.push(T.morphAttributeCount),x.push(T.numDirLights),x.push(T.numPointLights),x.push(T.numSpotLights),x.push(T.numSpotLightMaps),x.push(T.numHemiLights),x.push(T.numRectAreaLights),x.push(T.numDirLightShadows),x.push(T.numPointLightShadows),x.push(T.numSpotLightShadows),x.push(T.numSpotLightShadowsWithMaps),x.push(T.numLightProbes),x.push(T.shadowMapType),x.push(T.toneMapping),x.push(T.numClippingPlanes),x.push(T.numClipIntersection),x.push(T.depthPacking)}function w(x,T){a.disableAll(),T.isWebGL2&&a.enable(0),T.supportsVertexTextures&&a.enable(1),T.instancing&&a.enable(2),T.instancingColor&&a.enable(3),T.matcap&&a.enable(4),T.envMap&&a.enable(5),T.normalMapObjectSpace&&a.enable(6),T.normalMapTangentSpace&&a.enable(7),T.clearcoat&&a.enable(8),T.iridescence&&a.enable(9),T.alphaTest&&a.enable(10),T.vertexColors&&a.enable(11),T.vertexAlphas&&a.enable(12),T.vertexUv1s&&a.enable(13),T.vertexUv2s&&a.enable(14),T.vertexUv3s&&a.enable(15),T.vertexTangents&&a.enable(16),T.anisotropy&&a.enable(17),T.alphaHash&&a.enable(18),T.batching&&a.enable(19),x.push(a.mask),a.disableAll(),T.fog&&a.enable(0),T.useFog&&a.enable(1),T.flatShading&&a.enable(2),T.logarithmicDepthBuffer&&a.enable(3),T.skinning&&a.enable(4),T.morphTargets&&a.enable(5),T.morphNormals&&a.enable(6),T.morphColors&&a.enable(7),T.premultipliedAlpha&&a.enable(8),T.shadowMapEnabled&&a.enable(9),T.useLegacyLights&&a.enable(10),T.doubleSided&&a.enable(11),T.flipSided&&a.enable(12),T.useDepthPacking&&a.enable(13),T.dithering&&a.enable(14),T.transmission&&a.enable(15),T.sheen&&a.enable(16),T.opaque&&a.enable(17),T.pointsUvs&&a.enable(18),T.decodeVideoTexture&&a.enable(19),x.push(a.mask)}function _(x){const T=p[x.type];let F;if(T){const $=Wi[T];F=BL.clone($.uniforms)}else F=x.uniforms;return F}function M(x,T){let F;for(let $=0,H=l.length;$<H;$++){const S=l[$];if(S.cacheKey===T){F=S,++F.usedTimes;break}}return F===void 0&&(F=new VV(r,T,x,s),l.push(F)),F}function E(x){if(--x.usedTimes===0){const T=l.indexOf(x);l[T]=l[l.length-1],l.pop(),x.destroy()}}function C(x){c.remove(x)}function I(){c.dispose()}return{getParameters:g,getProgramCacheKey:y,getUniforms:_,acquireProgram:M,releaseProgram:E,releaseShaderCache:C,programs:l,dispose:I}}function KV(){let r=new WeakMap;function e(s){let o=r.get(s);return o===void 0&&(o={},r.set(s,o)),o}function t(s){r.delete(s)}function n(s,o,a){r.get(s)[o]=a}function i(){r=new WeakMap}return{get:e,remove:t,update:n,dispose:i}}function XV(r,e){return r.groupOrder!==e.groupOrder?r.groupOrder-e.groupOrder:r.renderOrder!==e.renderOrder?r.renderOrder-e.renderOrder:r.material.id!==e.material.id?r.material.id-e.material.id:r.z!==e.z?r.z-e.z:r.id-e.id}function jA(r,e){return r.groupOrder!==e.groupOrder?r.groupOrder-e.groupOrder:r.renderOrder!==e.renderOrder?r.renderOrder-e.renderOrder:r.z!==e.z?e.z-r.z:r.id-e.id}function QA(){const r=[];let e=0;const t=[],n=[],i=[];function s(){e=0,t.length=0,n.length=0,i.length=0}function o(h,d,m,p,b,g){let y=r[e];return y===void 0?(y={id:h.id,object:h,geometry:d,material:m,groupOrder:p,renderOrder:h.renderOrder,z:b,group:g},r[e]=y):(y.id=h.id,y.object=h,y.geometry=d,y.material=m,y.groupOrder=p,y.renderOrder=h.renderOrder,y.z=b,y.group=g),e++,y}function a(h,d,m,p,b,g){const y=o(h,d,m,p,b,g);m.transmission>0?n.push(y):m.transparent===!0?i.push(y):t.push(y)}function c(h,d,m,p,b,g){const y=o(h,d,m,p,b,g);m.transmission>0?n.unshift(y):m.transparent===!0?i.unshift(y):t.unshift(y)}function l(h,d){t.length>1&&t.sort(h||XV),n.length>1&&n.sort(d||jA),i.length>1&&i.sort(d||jA)}function u(){for(let h=e,d=r.length;h<d;h++){const m=r[h];if(m.id===null)break;m.id=null,m.object=null,m.geometry=null,m.material=null,m.group=null}}return{opaque:t,transmissive:n,transparent:i,init:s,push:a,unshift:c,finish:u,sort:l}}function YV(){let r=new WeakMap;function e(n,i){const s=r.get(n);let o;return s===void 0?(o=new QA,r.set(n,[o])):i>=s.length?(o=new QA,s.push(o)):o=s[i],o}function t(){r=new WeakMap}return{get:e,dispose:t}}function ZV(){const r={};return{get:function(e){if(r[e.id]!==void 0)return r[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new k,color:new ye};break;case"SpotLight":t={position:new k,direction:new k,color:new ye,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new k,color:new ye,distance:0,decay:0};break;case"HemisphereLight":t={direction:new k,skyColor:new ye,groundColor:new ye};break;case"RectAreaLight":t={color:new ye,position:new k,halfWidth:new k,halfHeight:new k};break}return r[e.id]=t,t}}}function JV(){const r={};return{get:function(e){if(r[e.id]!==void 0)return r[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new se};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new se};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new se,shadowCameraNear:1,shadowCameraFar:1e3};break}return r[e.id]=t,t}}}let jV=0;function QV(r,e){return(e.castShadow?2:0)-(r.castShadow?2:0)+(e.map?1:0)-(r.map?1:0)}function eH(r,e){const t=new ZV,n=JV(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let u=0;u<9;u++)i.probe.push(new k);const s=new k,o=new $e,a=new $e;function c(u,h){let d=0,m=0,p=0;for(let $=0;$<9;$++)i.probe[$].set(0,0,0);let b=0,g=0,y=0,v=0,w=0,_=0,M=0,E=0,C=0,I=0,x=0;u.sort(QV);const T=h===!0?Math.PI:1;for(let $=0,H=u.length;$<H;$++){const S=u[$],A=S.color,P=S.intensity,L=S.distance,B=S.shadow&&S.shadow.map?S.shadow.map.texture:null;if(S.isAmbientLight)d+=A.r*P*T,m+=A.g*P*T,p+=A.b*P*T;else if(S.isLightProbe){for(let D=0;D<9;D++)i.probe[D].addScaledVector(S.sh.coefficients[D],P);x++}else if(S.isDirectionalLight){const D=t.get(S);if(D.color.copy(S.color).multiplyScalar(S.intensity*T),S.castShadow){const V=S.shadow,z=n.get(S);z.shadowBias=V.bias,z.shadowNormalBias=V.normalBias,z.shadowRadius=V.radius,z.shadowMapSize=V.mapSize,i.directionalShadow[b]=z,i.directionalShadowMap[b]=B,i.directionalShadowMatrix[b]=S.shadow.matrix,_++}i.directional[b]=D,b++}else if(S.isSpotLight){const D=t.get(S);D.position.setFromMatrixPosition(S.matrixWorld),D.color.copy(A).multiplyScalar(P*T),D.distance=L,D.coneCos=Math.cos(S.angle),D.penumbraCos=Math.cos(S.angle*(1-S.penumbra)),D.decay=S.decay,i.spot[y]=D;const V=S.shadow;if(S.map&&(i.spotLightMap[C]=S.map,C++,V.updateMatrices(S),S.castShadow&&I++),i.spotLightMatrix[y]=V.matrix,S.castShadow){const z=n.get(S);z.shadowBias=V.bias,z.shadowNormalBias=V.normalBias,z.shadowRadius=V.radius,z.shadowMapSize=V.mapSize,i.spotShadow[y]=z,i.spotShadowMap[y]=B,E++}y++}else if(S.isRectAreaLight){const D=t.get(S);D.color.copy(A).multiplyScalar(P),D.halfWidth.set(S.width*.5,0,0),D.halfHeight.set(0,S.height*.5,0),i.rectArea[v]=D,v++}else if(S.isPointLight){const D=t.get(S);if(D.color.copy(S.color).multiplyScalar(S.intensity*T),D.distance=S.distance,D.decay=S.decay,S.castShadow){const V=S.shadow,z=n.get(S);z.shadowBias=V.bias,z.shadowNormalBias=V.normalBias,z.shadowRadius=V.radius,z.shadowMapSize=V.mapSize,z.shadowCameraNear=V.camera.near,z.shadowCameraFar=V.camera.far,i.pointShadow[g]=z,i.pointShadowMap[g]=B,i.pointShadowMatrix[g]=S.shadow.matrix,M++}i.point[g]=D,g++}else if(S.isHemisphereLight){const D=t.get(S);D.skyColor.copy(S.color).multiplyScalar(P*T),D.groundColor.copy(S.groundColor).multiplyScalar(P*T),i.hemi[w]=D,w++}}v>0&&(e.isWebGL2?r.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=we.LTC_FLOAT_1,i.rectAreaLTC2=we.LTC_FLOAT_2):(i.rectAreaLTC1=we.LTC_HALF_1,i.rectAreaLTC2=we.LTC_HALF_2):r.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=we.LTC_FLOAT_1,i.rectAreaLTC2=we.LTC_FLOAT_2):r.has("OES_texture_half_float_linear")===!0?(i.rectAreaLTC1=we.LTC_HALF_1,i.rectAreaLTC2=we.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=d,i.ambient[1]=m,i.ambient[2]=p;const F=i.hash;(F.directionalLength!==b||F.pointLength!==g||F.spotLength!==y||F.rectAreaLength!==v||F.hemiLength!==w||F.numDirectionalShadows!==_||F.numPointShadows!==M||F.numSpotShadows!==E||F.numSpotMaps!==C||F.numLightProbes!==x)&&(i.directional.length=b,i.spot.length=y,i.rectArea.length=v,i.point.length=g,i.hemi.length=w,i.directionalShadow.length=_,i.directionalShadowMap.length=_,i.pointShadow.length=M,i.pointShadowMap.length=M,i.spotShadow.length=E,i.spotShadowMap.length=E,i.directionalShadowMatrix.length=_,i.pointShadowMatrix.length=M,i.spotLightMatrix.length=E+C-I,i.spotLightMap.length=C,i.numSpotLightShadowsWithMaps=I,i.numLightProbes=x,F.directionalLength=b,F.pointLength=g,F.spotLength=y,F.rectAreaLength=v,F.hemiLength=w,F.numDirectionalShadows=_,F.numPointShadows=M,F.numSpotShadows=E,F.numSpotMaps=C,F.numLightProbes=x,i.version=jV++)}function l(u,h){let d=0,m=0,p=0,b=0,g=0;const y=h.matrixWorldInverse;for(let v=0,w=u.length;v<w;v++){const _=u[v];if(_.isDirectionalLight){const M=i.directional[d];M.direction.setFromMatrixPosition(_.matrixWorld),s.setFromMatrixPosition(_.target.matrixWorld),M.direction.sub(s),M.direction.transformDirection(y),d++}else if(_.isSpotLight){const M=i.spot[p];M.position.setFromMatrixPosition(_.matrixWorld),M.position.applyMatrix4(y),M.direction.setFromMatrixPosition(_.matrixWorld),s.setFromMatrixPosition(_.target.matrixWorld),M.direction.sub(s),M.direction.transformDirection(y),p++}else if(_.isRectAreaLight){const M=i.rectArea[b];M.position.setFromMatrixPosition(_.matrixWorld),M.position.applyMatrix4(y),a.identity(),o.copy(_.matrixWorld),o.premultiply(y),a.extractRotation(o),M.halfWidth.set(_.width*.5,0,0),M.halfHeight.set(0,_.height*.5,0),M.halfWidth.applyMatrix4(a),M.halfHeight.applyMatrix4(a),b++}else if(_.isPointLight){const M=i.point[m];M.position.setFromMatrixPosition(_.matrixWorld),M.position.applyMatrix4(y),m++}else if(_.isHemisphereLight){const M=i.hemi[g];M.direction.setFromMatrixPosition(_.matrixWorld),M.direction.transformDirection(y),g++}}}return{setup:c,setupView:l,state:i}}function eT(r,e){const t=new eH(r,e),n=[],i=[];function s(){n.length=0,i.length=0}function o(h){n.push(h)}function a(h){i.push(h)}function c(h){t.setup(n,h)}function l(h){t.setupView(n,h)}return{init:s,state:{lightsArray:n,shadowsArray:i,lights:t},setupLights:c,setupLightsView:l,pushLight:o,pushShadow:a}}function tH(r,e){let t=new WeakMap;function n(s,o=0){const a=t.get(s);let c;return a===void 0?(c=new eT(r,e),t.set(s,[c])):o>=a.length?(c=new eT(r,e),a.push(c)):c=a[o],c}function i(){t=new WeakMap}return{get:n,dispose:i}}class zE extends wr{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=SL,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class VE extends wr{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}const nH=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,rH=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function iH(r,e,t){let n=new tp;const i=new se,s=new se,o=new mt,a=new zE({depthPacking:EL}),c=new VE,l={},u=t.maxTextureSize,h={[Mo]:yr,[yr]:Mo,[qi]:qi},d=new Fr({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new se},radius:{value:4}},vertexShader:nH,fragmentShader:rH}),m=d.clone();m.defines.HORIZONTAL_PASS=1;const p=new Ye;p.setAttribute("position",new It(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const b=new De(p,d),g=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=_E;let y=this.type;this.render=function(E,C,I){if(g.enabled===!1||g.autoUpdate===!1&&g.needsUpdate===!1||E.length===0)return;const x=r.getRenderTarget(),T=r.getActiveCubeFace(),F=r.getActiveMipmapLevel(),$=r.state;$.setBlending(wo),$.buffers.color.setClear(1,1,1,1),$.buffers.depth.setTest(!0),$.setScissorTest(!1);const H=y!==hs&&this.type===hs,S=y===hs&&this.type!==hs;for(let A=0,P=E.length;A<P;A++){const L=E[A],B=L.shadow;if(B===void 0){console.warn("THREE.WebGLShadowMap:",L,"has no shadow.");continue}if(B.autoUpdate===!1&&B.needsUpdate===!1)continue;i.copy(B.mapSize);const D=B.getFrameExtents();if(i.multiply(D),s.copy(B.mapSize),(i.x>u||i.y>u)&&(i.x>u&&(s.x=Math.floor(u/D.x),i.x=s.x*D.x,B.mapSize.x=s.x),i.y>u&&(s.y=Math.floor(u/D.y),i.y=s.y*D.y,B.mapSize.y=s.y)),B.map===null||H===!0||S===!0){const z=this.type!==hs?{minFilter:ln,magFilter:ln}:{};B.map!==null&&B.map.dispose(),B.map=new ts(i.x,i.y,z),B.map.texture.name=L.name+".shadowMap",B.camera.updateProjectionMatrix()}r.setRenderTarget(B.map),r.clear();const V=B.getViewportCount();for(let z=0;z<V;z++){const q=B.getViewport(z);o.set(s.x*q.x,s.y*q.y,s.x*q.z,s.y*q.w),$.viewport(o),B.updateMatrices(L,z),n=B.getFrustum(),_(C,I,B.camera,L,this.type)}B.isPointLightShadow!==!0&&this.type===hs&&v(B,I),B.needsUpdate=!1}y=this.type,g.needsUpdate=!1,r.setRenderTarget(x,T,F)};function v(E,C){const I=e.update(b);d.defines.VSM_SAMPLES!==E.blurSamples&&(d.defines.VSM_SAMPLES=E.blurSamples,m.defines.VSM_SAMPLES=E.blurSamples,d.needsUpdate=!0,m.needsUpdate=!0),E.mapPass===null&&(E.mapPass=new ts(i.x,i.y)),d.uniforms.shadow_pass.value=E.map.texture,d.uniforms.resolution.value=E.mapSize,d.uniforms.radius.value=E.radius,r.setRenderTarget(E.mapPass),r.clear(),r.renderBufferDirect(C,null,I,d,b,null),m.uniforms.shadow_pass.value=E.mapPass.texture,m.uniforms.resolution.value=E.mapSize,m.uniforms.radius.value=E.radius,r.setRenderTarget(E.map),r.clear(),r.renderBufferDirect(C,null,I,m,b,null)}function w(E,C,I,x){let T=null;const F=I.isPointLight===!0?E.customDistanceMaterial:E.customDepthMaterial;if(F!==void 0)T=F;else if(T=I.isPointLight===!0?c:a,r.localClippingEnabled&&C.clipShadows===!0&&Array.isArray(C.clippingPlanes)&&C.clippingPlanes.length!==0||C.displacementMap&&C.displacementScale!==0||C.alphaMap&&C.alphaTest>0||C.map&&C.alphaTest>0){const $=T.uuid,H=C.uuid;let S=l[$];S===void 0&&(S={},l[$]=S);let A=S[H];A===void 0&&(A=T.clone(),S[H]=A,C.addEventListener("dispose",M)),T=A}if(T.visible=C.visible,T.wireframe=C.wireframe,x===hs?T.side=C.shadowSide!==null?C.shadowSide:C.side:T.side=C.shadowSide!==null?C.shadowSide:h[C.side],T.alphaMap=C.alphaMap,T.alphaTest=C.alphaTest,T.map=C.map,T.clipShadows=C.clipShadows,T.clippingPlanes=C.clippingPlanes,T.clipIntersection=C.clipIntersection,T.displacementMap=C.displacementMap,T.displacementScale=C.displacementScale,T.displacementBias=C.displacementBias,T.wireframeLinewidth=C.wireframeLinewidth,T.linewidth=C.linewidth,I.isPointLight===!0&&T.isMeshDistanceMaterial===!0){const $=r.properties.get(T);$.light=I}return T}function _(E,C,I,x,T){if(E.visible===!1)return;if(E.layers.test(C.layers)&&(E.isMesh||E.isLine||E.isPoints)&&(E.castShadow||E.receiveShadow&&T===hs)&&(!E.frustumCulled||n.intersectsObject(E))){E.modelViewMatrix.multiplyMatrices(I.matrixWorldInverse,E.matrixWorld);const H=e.update(E),S=E.material;if(Array.isArray(S)){const A=H.groups;for(let P=0,L=A.length;P<L;P++){const B=A[P],D=S[B.materialIndex];if(D&&D.visible){const V=w(E,D,x,T);E.onBeforeShadow(r,E,C,I,H,V,B),r.renderBufferDirect(I,null,H,V,E,B),E.onAfterShadow(r,E,C,I,H,V,B)}}}else if(S.visible){const A=w(E,S,x,T);E.onBeforeShadow(r,E,C,I,H,A,null),r.renderBufferDirect(I,null,H,A,E,null),E.onAfterShadow(r,E,C,I,H,A,null)}}const $=E.children;for(let H=0,S=$.length;H<S;H++)_($[H],C,I,x,T)}function M(E){E.target.removeEventListener("dispose",M);for(const I in l){const x=l[I],T=E.target.uuid;T in x&&(x[T].dispose(),delete x[T])}}}function sH(r,e,t){const n=t.isWebGL2;function i(){let K=!1;const Me=new mt;let Ae=null;const qe=new mt(0,0,0,0);return{setMask:function(Ve){Ae!==Ve&&!K&&(r.colorMask(Ve,Ve,Ve,Ve),Ae=Ve)},setLocked:function(Ve){K=Ve},setClear:function(Ve,Ut,kt,Sn,_r){_r===!0&&(Ve*=Sn,Ut*=Sn,kt*=Sn),Me.set(Ve,Ut,kt,Sn),qe.equals(Me)===!1&&(r.clearColor(Ve,Ut,kt,Sn),qe.copy(Me))},reset:function(){K=!1,Ae=null,qe.set(-1,0,0,0)}}}function s(){let K=!1,Me=null,Ae=null,qe=null;return{setTest:function(Ve){Ve?he(r.DEPTH_TEST):ce(r.DEPTH_TEST)},setMask:function(Ve){Me!==Ve&&!K&&(r.depthMask(Ve),Me=Ve)},setFunc:function(Ve){if(Ae!==Ve){switch(Ve){case ZD:r.depthFunc(r.NEVER);break;case JD:r.depthFunc(r.ALWAYS);break;case jD:r.depthFunc(r.LESS);break;case Vd:r.depthFunc(r.LEQUAL);break;case QD:r.depthFunc(r.EQUAL);break;case eL:r.depthFunc(r.GEQUAL);break;case tL:r.depthFunc(r.GREATER);break;case nL:r.depthFunc(r.NOTEQUAL);break;default:r.depthFunc(r.LEQUAL)}Ae=Ve}},setLocked:function(Ve){K=Ve},setClear:function(Ve){qe!==Ve&&(r.clearDepth(Ve),qe=Ve)},reset:function(){K=!1,Me=null,Ae=null,qe=null}}}function o(){let K=!1,Me=null,Ae=null,qe=null,Ve=null,Ut=null,kt=null,Sn=null,_r=null;return{setTest:function(Bt){K||(Bt?he(r.STENCIL_TEST):ce(r.STENCIL_TEST))},setMask:function(Bt){Me!==Bt&&!K&&(r.stencilMask(Bt),Me=Bt)},setFunc:function(Bt,xr,os){(Ae!==Bt||qe!==xr||Ve!==os)&&(r.stencilFunc(Bt,xr,os),Ae=Bt,qe=xr,Ve=os)},setOp:function(Bt,xr,os){(Ut!==Bt||kt!==xr||Sn!==os)&&(r.stencilOp(Bt,xr,os),Ut=Bt,kt=xr,Sn=os)},setLocked:function(Bt){K=Bt},setClear:function(Bt){_r!==Bt&&(r.clearStencil(Bt),_r=Bt)},reset:function(){K=!1,Me=null,Ae=null,qe=null,Ve=null,Ut=null,kt=null,Sn=null,_r=null}}}const a=new i,c=new s,l=new o,u=new WeakMap,h=new WeakMap;let d={},m={},p=new WeakMap,b=[],g=null,y=!1,v=null,w=null,_=null,M=null,E=null,C=null,I=null,x=new ye(0,0,0),T=0,F=!1,$=null,H=null,S=null,A=null,P=null;const L=r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let B=!1,D=0;const V=r.getParameter(r.VERSION);V.indexOf("WebGL")!==-1?(D=parseFloat(/^WebGL (\d)/.exec(V)[1]),B=D>=1):V.indexOf("OpenGL ES")!==-1&&(D=parseFloat(/^OpenGL ES (\d)/.exec(V)[1]),B=D>=2);let z=null,q={};const G=r.getParameter(r.SCISSOR_BOX),Y=r.getParameter(r.VIEWPORT),j=new mt().fromArray(G),X=new mt().fromArray(Y);function ne(K,Me,Ae,qe){const Ve=new Uint8Array(4),Ut=r.createTexture();r.bindTexture(K,Ut),r.texParameteri(K,r.TEXTURE_MIN_FILTER,r.NEAREST),r.texParameteri(K,r.TEXTURE_MAG_FILTER,r.NEAREST);for(let kt=0;kt<Ae;kt++)n&&(K===r.TEXTURE_3D||K===r.TEXTURE_2D_ARRAY)?r.texImage3D(Me,0,r.RGBA,1,1,qe,0,r.RGBA,r.UNSIGNED_BYTE,Ve):r.texImage2D(Me+kt,0,r.RGBA,1,1,0,r.RGBA,r.UNSIGNED_BYTE,Ve);return Ut}const oe={};oe[r.TEXTURE_2D]=ne(r.TEXTURE_2D,r.TEXTURE_2D,1),oe[r.TEXTURE_CUBE_MAP]=ne(r.TEXTURE_CUBE_MAP,r.TEXTURE_CUBE_MAP_POSITIVE_X,6),n&&(oe[r.TEXTURE_2D_ARRAY]=ne(r.TEXTURE_2D_ARRAY,r.TEXTURE_2D_ARRAY,1,1),oe[r.TEXTURE_3D]=ne(r.TEXTURE_3D,r.TEXTURE_3D,1,1)),a.setClear(0,0,0,1),c.setClear(1),l.setClear(0),he(r.DEPTH_TEST),c.setFunc(Vd),Te(!1),O(sx),he(r.CULL_FACE),ie(wo);function he(K){d[K]!==!0&&(r.enable(K),d[K]=!0)}function ce(K){d[K]!==!1&&(r.disable(K),d[K]=!1)}function fe(K,Me){return m[K]!==Me?(r.bindFramebuffer(K,Me),m[K]=Me,n&&(K===r.DRAW_FRAMEBUFFER&&(m[r.FRAMEBUFFER]=Me),K===r.FRAMEBUFFER&&(m[r.DRAW_FRAMEBUFFER]=Me)),!0):!1}function W(K,Me){let Ae=b,qe=!1;if(K)if(Ae=p.get(Me),Ae===void 0&&(Ae=[],p.set(Me,Ae)),K.isWebGLMultipleRenderTargets){const Ve=K.texture;if(Ae.length!==Ve.length||Ae[0]!==r.COLOR_ATTACHMENT0){for(let Ut=0,kt=Ve.length;Ut<kt;Ut++)Ae[Ut]=r.COLOR_ATTACHMENT0+Ut;Ae.length=Ve.length,qe=!0}}else Ae[0]!==r.COLOR_ATTACHMENT0&&(Ae[0]=r.COLOR_ATTACHMENT0,qe=!0);else Ae[0]!==r.BACK&&(Ae[0]=r.BACK,qe=!0);qe&&(t.isWebGL2?r.drawBuffers(Ae):e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Ae))}function ue(K){return g!==K?(r.useProgram(K),g=K,!0):!1}const re={[aa]:r.FUNC_ADD,[OD]:r.FUNC_SUBTRACT,[UD]:r.FUNC_REVERSE_SUBTRACT};if(n)re[cx]=r.MIN,re[lx]=r.MAX;else{const K=e.get("EXT_blend_minmax");K!==null&&(re[cx]=K.MIN_EXT,re[lx]=K.MAX_EXT)}const le={[kD]:r.ZERO,[BD]:r.ONE,[FD]:r.SRC_COLOR,[kg]:r.SRC_ALPHA,[WD]:r.SRC_ALPHA_SATURATE,[HD]:r.DST_COLOR,[zD]:r.DST_ALPHA,[$D]:r.ONE_MINUS_SRC_COLOR,[Bg]:r.ONE_MINUS_SRC_ALPHA,[GD]:r.ONE_MINUS_DST_COLOR,[VD]:r.ONE_MINUS_DST_ALPHA,[qD]:r.CONSTANT_COLOR,[KD]:r.ONE_MINUS_CONSTANT_COLOR,[XD]:r.CONSTANT_ALPHA,[YD]:r.ONE_MINUS_CONSTANT_ALPHA};function ie(K,Me,Ae,qe,Ve,Ut,kt,Sn,_r,Bt){if(K===wo){y===!0&&(ce(r.BLEND),y=!1);return}if(y===!1&&(he(r.BLEND),y=!0),K!==ND){if(K!==v||Bt!==F){if((w!==aa||E!==aa)&&(r.blendEquation(r.FUNC_ADD),w=aa,E=aa),Bt)switch(K){case xc:r.blendFuncSeparate(r.ONE,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA);break;case oa:r.blendFunc(r.ONE,r.ONE);break;case ox:r.blendFuncSeparate(r.ZERO,r.ONE_MINUS_SRC_COLOR,r.ZERO,r.ONE);break;case ax:r.blendFuncSeparate(r.ZERO,r.SRC_COLOR,r.ZERO,r.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",K);break}else switch(K){case xc:r.blendFuncSeparate(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA);break;case oa:r.blendFunc(r.SRC_ALPHA,r.ONE);break;case ox:r.blendFuncSeparate(r.ZERO,r.ONE_MINUS_SRC_COLOR,r.ZERO,r.ONE);break;case ax:r.blendFunc(r.ZERO,r.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",K);break}_=null,M=null,C=null,I=null,x.set(0,0,0),T=0,v=K,F=Bt}return}Ve=Ve||Me,Ut=Ut||Ae,kt=kt||qe,(Me!==w||Ve!==E)&&(r.blendEquationSeparate(re[Me],re[Ve]),w=Me,E=Ve),(Ae!==_||qe!==M||Ut!==C||kt!==I)&&(r.blendFuncSeparate(le[Ae],le[qe],le[Ut],le[kt]),_=Ae,M=qe,C=Ut,I=kt),(Sn.equals(x)===!1||_r!==T)&&(r.blendColor(Sn.r,Sn.g,Sn.b,_r),x.copy(Sn),T=_r),v=K,F=!1}function Oe(K,Me){K.side===qi?ce(r.CULL_FACE):he(r.CULL_FACE);let Ae=K.side===yr;Me&&(Ae=!Ae),Te(Ae),K.blending===xc&&K.transparent===!1?ie(wo):ie(K.blending,K.blendEquation,K.blendSrc,K.blendDst,K.blendEquationAlpha,K.blendSrcAlpha,K.blendDstAlpha,K.blendColor,K.blendAlpha,K.premultipliedAlpha),c.setFunc(K.depthFunc),c.setTest(K.depthTest),c.setMask(K.depthWrite),a.setMask(K.colorWrite);const qe=K.stencilWrite;l.setTest(qe),qe&&(l.setMask(K.stencilWriteMask),l.setFunc(K.stencilFunc,K.stencilRef,K.stencilFuncMask),l.setOp(K.stencilFail,K.stencilZFail,K.stencilZPass)),J(K.polygonOffset,K.polygonOffsetFactor,K.polygonOffsetUnits),K.alphaToCoverage===!0?he(r.SAMPLE_ALPHA_TO_COVERAGE):ce(r.SAMPLE_ALPHA_TO_COVERAGE)}function Te(K){$!==K&&(K?r.frontFace(r.CW):r.frontFace(r.CCW),$=K)}function O(K){K!==DD?(he(r.CULL_FACE),K!==H&&(K===sx?r.cullFace(r.BACK):K===LD?r.cullFace(r.FRONT):r.cullFace(r.FRONT_AND_BACK))):ce(r.CULL_FACE),H=K}function R(K){K!==S&&(B&&r.lineWidth(K),S=K)}function J(K,Me,Ae){K?(he(r.POLYGON_OFFSET_FILL),(A!==Me||P!==Ae)&&(r.polygonOffset(Me,Ae),A=Me,P=Ae)):ce(r.POLYGON_OFFSET_FILL)}function ge(K){K?he(r.SCISSOR_TEST):ce(r.SCISSOR_TEST)}function pe(K){K===void 0&&(K=r.TEXTURE0+L-1),z!==K&&(r.activeTexture(K),z=K)}function de(K,Me,Ae){Ae===void 0&&(z===null?Ae=r.TEXTURE0+L-1:Ae=z);let qe=q[Ae];qe===void 0&&(qe={type:void 0,texture:void 0},q[Ae]=qe),(qe.type!==K||qe.texture!==Me)&&(z!==Ae&&(r.activeTexture(Ae),z=Ae),r.bindTexture(K,Me||oe[K]),qe.type=K,qe.texture=Me)}function Le(){const K=q[z];K!==void 0&&K.type!==void 0&&(r.bindTexture(K.type,null),K.type=void 0,K.texture=void 0)}function Ee(){try{r.compressedTexImage2D.apply(r,arguments)}catch(K){console.error("THREE.WebGLState:",K)}}function Pe(){try{r.compressedTexImage3D.apply(r,arguments)}catch(K){console.error("THREE.WebGLState:",K)}}function ze(){try{r.texSubImage2D.apply(r,arguments)}catch(K){console.error("THREE.WebGLState:",K)}}function je(){try{r.texSubImage3D.apply(r,arguments)}catch(K){console.error("THREE.WebGLState:",K)}}function me(){try{r.compressedTexSubImage2D.apply(r,arguments)}catch(K){console.error("THREE.WebGLState:",K)}}function _t(){try{r.compressedTexSubImage3D.apply(r,arguments)}catch(K){console.error("THREE.WebGLState:",K)}}function ct(){try{r.texStorage2D.apply(r,arguments)}catch(K){console.error("THREE.WebGLState:",K)}}function Xe(){try{r.texStorage3D.apply(r,arguments)}catch(K){console.error("THREE.WebGLState:",K)}}function ke(){try{r.texImage2D.apply(r,arguments)}catch(K){console.error("THREE.WebGLState:",K)}}function Re(){try{r.texImage3D.apply(r,arguments)}catch(K){console.error("THREE.WebGLState:",K)}}function nt(K){j.equals(K)===!1&&(r.scissor(K.x,K.y,K.z,K.w),j.copy(K))}function Tt(K){X.equals(K)===!1&&(r.viewport(K.x,K.y,K.z,K.w),X.copy(K))}function Zt(K,Me){let Ae=h.get(Me);Ae===void 0&&(Ae=new WeakMap,h.set(Me,Ae));let qe=Ae.get(K);qe===void 0&&(qe=r.getUniformBlockIndex(Me,K.name),Ae.set(K,qe))}function st(K,Me){const qe=h.get(Me).get(K);u.get(Me)!==qe&&(r.uniformBlockBinding(Me,qe,K.__bindingPointIndex),u.set(Me,qe))}function ve(){r.disable(r.BLEND),r.disable(r.CULL_FACE),r.disable(r.DEPTH_TEST),r.disable(r.POLYGON_OFFSET_FILL),r.disable(r.SCISSOR_TEST),r.disable(r.STENCIL_TEST),r.disable(r.SAMPLE_ALPHA_TO_COVERAGE),r.blendEquation(r.FUNC_ADD),r.blendFunc(r.ONE,r.ZERO),r.blendFuncSeparate(r.ONE,r.ZERO,r.ONE,r.ZERO),r.blendColor(0,0,0,0),r.colorMask(!0,!0,!0,!0),r.clearColor(0,0,0,0),r.depthMask(!0),r.depthFunc(r.LESS),r.clearDepth(1),r.stencilMask(4294967295),r.stencilFunc(r.ALWAYS,0,4294967295),r.stencilOp(r.KEEP,r.KEEP,r.KEEP),r.clearStencil(0),r.cullFace(r.BACK),r.frontFace(r.CCW),r.polygonOffset(0,0),r.activeTexture(r.TEXTURE0),r.bindFramebuffer(r.FRAMEBUFFER,null),n===!0&&(r.bindFramebuffer(r.DRAW_FRAMEBUFFER,null),r.bindFramebuffer(r.READ_FRAMEBUFFER,null)),r.useProgram(null),r.lineWidth(1),r.scissor(0,0,r.canvas.width,r.canvas.height),r.viewport(0,0,r.canvas.width,r.canvas.height),d={},z=null,q={},m={},p=new WeakMap,b=[],g=null,y=!1,v=null,w=null,_=null,M=null,E=null,C=null,I=null,x=new ye(0,0,0),T=0,F=!1,$=null,H=null,S=null,A=null,P=null,j.set(0,0,r.canvas.width,r.canvas.height),X.set(0,0,r.canvas.width,r.canvas.height),a.reset(),c.reset(),l.reset()}return{buffers:{color:a,depth:c,stencil:l},enable:he,disable:ce,bindFramebuffer:fe,drawBuffers:W,useProgram:ue,setBlending:ie,setMaterial:Oe,setFlipSided:Te,setCullFace:O,setLineWidth:R,setPolygonOffset:J,setScissorTest:ge,activeTexture:pe,bindTexture:de,unbindTexture:Le,compressedTexImage2D:Ee,compressedTexImage3D:Pe,texImage2D:ke,texImage3D:Re,updateUBOMapping:Zt,uniformBlockBinding:st,texStorage2D:ct,texStorage3D:Xe,texSubImage2D:ze,texSubImage3D:je,compressedTexSubImage2D:me,compressedTexSubImage3D:_t,scissor:nt,viewport:Tt,reset:ve}}function oH(r,e,t,n,i,s,o){const a=i.isWebGL2,c=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,l=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),u=new WeakMap;let h;const d=new WeakMap;let m=!1;try{m=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function p(O,R){return m?new OffscreenCanvas(O,R):ef("canvas")}function b(O,R,J,ge){let pe=1;if((O.width>ge||O.height>ge)&&(pe=ge/Math.max(O.width,O.height)),pe<1||R===!0)if(typeof HTMLImageElement<"u"&&O instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&O instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&O instanceof ImageBitmap){const de=R?zg:Math.floor,Le=de(pe*O.width),Ee=de(pe*O.height);h===void 0&&(h=p(Le,Ee));const Pe=J?p(Le,Ee):h;return Pe.width=Le,Pe.height=Ee,Pe.getContext("2d").drawImage(O,0,0,Le,Ee),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+O.width+"x"+O.height+") to ("+Le+"x"+Ee+")."),Pe}else return"data"in O&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+O.width+"x"+O.height+")."),O;return O}function g(O){return Bx(O.width)&&Bx(O.height)}function y(O){return a?!1:O.wrapS!==gr||O.wrapT!==gr||O.minFilter!==ln&&O.minFilter!==un}function v(O,R){return O.generateMipmaps&&R&&O.minFilter!==ln&&O.minFilter!==un}function w(O){r.generateMipmap(O)}function _(O,R,J,ge,pe=!1){if(a===!1)return R;if(O!==null){if(r[O]!==void 0)return r[O];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+O+"'")}let de=R;if(R===r.RED&&(J===r.FLOAT&&(de=r.R32F),J===r.HALF_FLOAT&&(de=r.R16F),J===r.UNSIGNED_BYTE&&(de=r.R8)),R===r.RED_INTEGER&&(J===r.UNSIGNED_BYTE&&(de=r.R8UI),J===r.UNSIGNED_SHORT&&(de=r.R16UI),J===r.UNSIGNED_INT&&(de=r.R32UI),J===r.BYTE&&(de=r.R8I),J===r.SHORT&&(de=r.R16I),J===r.INT&&(de=r.R32I)),R===r.RG&&(J===r.FLOAT&&(de=r.RG32F),J===r.HALF_FLOAT&&(de=r.RG16F),J===r.UNSIGNED_BYTE&&(de=r.RG8)),R===r.RGBA){const Le=pe?Zd:Ct.getTransfer(ge);J===r.FLOAT&&(de=r.RGBA32F),J===r.HALF_FLOAT&&(de=r.RGBA16F),J===r.UNSIGNED_BYTE&&(de=Le===Ft?r.SRGB8_ALPHA8:r.RGBA8),J===r.UNSIGNED_SHORT_4_4_4_4&&(de=r.RGBA4),J===r.UNSIGNED_SHORT_5_5_5_1&&(de=r.RGB5_A1)}return(de===r.R16F||de===r.R32F||de===r.RG16F||de===r.RG32F||de===r.RGBA16F||de===r.RGBA32F)&&e.get("EXT_color_buffer_float"),de}function M(O,R,J){return v(O,J)===!0||O.isFramebufferTexture&&O.minFilter!==ln&&O.minFilter!==un?Math.log2(Math.max(R.width,R.height))+1:O.mipmaps!==void 0&&O.mipmaps.length>0?O.mipmaps.length:O.isCompressedTexture&&Array.isArray(O.image)?R.mipmaps.length:1}function E(O){return O===ln||O===Fg||O===Ed?r.NEAREST:r.LINEAR}function C(O){const R=O.target;R.removeEventListener("dispose",C),x(R),R.isVideoTexture&&u.delete(R)}function I(O){const R=O.target;R.removeEventListener("dispose",I),F(R)}function x(O){const R=n.get(O);if(R.__webglInit===void 0)return;const J=O.source,ge=d.get(J);if(ge){const pe=ge[R.__cacheKey];pe.usedTimes--,pe.usedTimes===0&&T(O),Object.keys(ge).length===0&&d.delete(J)}n.remove(O)}function T(O){const R=n.get(O);r.deleteTexture(R.__webglTexture);const J=O.source,ge=d.get(J);delete ge[R.__cacheKey],o.memory.textures--}function F(O){const R=O.texture,J=n.get(O),ge=n.get(R);if(ge.__webglTexture!==void 0&&(r.deleteTexture(ge.__webglTexture),o.memory.textures--),O.depthTexture&&O.depthTexture.dispose(),O.isWebGLCubeRenderTarget)for(let pe=0;pe<6;pe++){if(Array.isArray(J.__webglFramebuffer[pe]))for(let de=0;de<J.__webglFramebuffer[pe].length;de++)r.deleteFramebuffer(J.__webglFramebuffer[pe][de]);else r.deleteFramebuffer(J.__webglFramebuffer[pe]);J.__webglDepthbuffer&&r.deleteRenderbuffer(J.__webglDepthbuffer[pe])}else{if(Array.isArray(J.__webglFramebuffer))for(let pe=0;pe<J.__webglFramebuffer.length;pe++)r.deleteFramebuffer(J.__webglFramebuffer[pe]);else r.deleteFramebuffer(J.__webglFramebuffer);if(J.__webglDepthbuffer&&r.deleteRenderbuffer(J.__webglDepthbuffer),J.__webglMultisampledFramebuffer&&r.deleteFramebuffer(J.__webglMultisampledFramebuffer),J.__webglColorRenderbuffer)for(let pe=0;pe<J.__webglColorRenderbuffer.length;pe++)J.__webglColorRenderbuffer[pe]&&r.deleteRenderbuffer(J.__webglColorRenderbuffer[pe]);J.__webglDepthRenderbuffer&&r.deleteRenderbuffer(J.__webglDepthRenderbuffer)}if(O.isWebGLMultipleRenderTargets)for(let pe=0,de=R.length;pe<de;pe++){const Le=n.get(R[pe]);Le.__webglTexture&&(r.deleteTexture(Le.__webglTexture),o.memory.textures--),n.remove(R[pe])}n.remove(R),n.remove(O)}let $=0;function H(){$=0}function S(){const O=$;return O>=i.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+O+" texture units while this GPU supports only "+i.maxTextures),$+=1,O}function A(O){const R=[];return R.push(O.wrapS),R.push(O.wrapT),R.push(O.wrapR||0),R.push(O.magFilter),R.push(O.minFilter),R.push(O.anisotropy),R.push(O.internalFormat),R.push(O.format),R.push(O.type),R.push(O.generateMipmaps),R.push(O.premultiplyAlpha),R.push(O.flipY),R.push(O.unpackAlignment),R.push(O.colorSpace),R.join()}function P(O,R){const J=n.get(O);if(O.isVideoTexture&&Oe(O),O.isRenderTargetTexture===!1&&O.version>0&&J.__version!==O.version){const ge=O.image;if(ge===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(ge.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{j(J,O,R);return}}t.bindTexture(r.TEXTURE_2D,J.__webglTexture,r.TEXTURE0+R)}function L(O,R){const J=n.get(O);if(O.version>0&&J.__version!==O.version){j(J,O,R);return}t.bindTexture(r.TEXTURE_2D_ARRAY,J.__webglTexture,r.TEXTURE0+R)}function B(O,R){const J=n.get(O);if(O.version>0&&J.__version!==O.version){j(J,O,R);return}t.bindTexture(r.TEXTURE_3D,J.__webglTexture,r.TEXTURE0+R)}function D(O,R){const J=n.get(O);if(O.version>0&&J.__version!==O.version){X(J,O,R);return}t.bindTexture(r.TEXTURE_CUBE_MAP,J.__webglTexture,r.TEXTURE0+R)}const V={[Wd]:r.REPEAT,[gr]:r.CLAMP_TO_EDGE,[qd]:r.MIRRORED_REPEAT},z={[ln]:r.NEAREST,[Fg]:r.NEAREST_MIPMAP_NEAREST,[Ed]:r.NEAREST_MIPMAP_LINEAR,[un]:r.LINEAR,[SE]:r.LINEAR_MIPMAP_NEAREST,[Sa]:r.LINEAR_MIPMAP_LINEAR},q={[AL]:r.NEVER,[DL]:r.ALWAYS,[TL]:r.LESS,[LE]:r.LEQUAL,[CL]:r.EQUAL,[RL]:r.GEQUAL,[IL]:r.GREATER,[PL]:r.NOTEQUAL};function G(O,R,J){if(J?(r.texParameteri(O,r.TEXTURE_WRAP_S,V[R.wrapS]),r.texParameteri(O,r.TEXTURE_WRAP_T,V[R.wrapT]),(O===r.TEXTURE_3D||O===r.TEXTURE_2D_ARRAY)&&r.texParameteri(O,r.TEXTURE_WRAP_R,V[R.wrapR]),r.texParameteri(O,r.TEXTURE_MAG_FILTER,z[R.magFilter]),r.texParameteri(O,r.TEXTURE_MIN_FILTER,z[R.minFilter])):(r.texParameteri(O,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(O,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE),(O===r.TEXTURE_3D||O===r.TEXTURE_2D_ARRAY)&&r.texParameteri(O,r.TEXTURE_WRAP_R,r.CLAMP_TO_EDGE),(R.wrapS!==gr||R.wrapT!==gr)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),r.texParameteri(O,r.TEXTURE_MAG_FILTER,E(R.magFilter)),r.texParameteri(O,r.TEXTURE_MIN_FILTER,E(R.minFilter)),R.minFilter!==ln&&R.minFilter!==un&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),R.compareFunction&&(r.texParameteri(O,r.TEXTURE_COMPARE_MODE,r.COMPARE_REF_TO_TEXTURE),r.texParameteri(O,r.TEXTURE_COMPARE_FUNC,q[R.compareFunction])),e.has("EXT_texture_filter_anisotropic")===!0){const ge=e.get("EXT_texture_filter_anisotropic");if(R.magFilter===ln||R.minFilter!==Ed&&R.minFilter!==Sa||R.type===Ki&&e.has("OES_texture_float_linear")===!1||a===!1&&R.type===ku&&e.has("OES_texture_half_float_linear")===!1)return;(R.anisotropy>1||n.get(R).__currentAnisotropy)&&(r.texParameterf(O,ge.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(R.anisotropy,i.getMaxAnisotropy())),n.get(R).__currentAnisotropy=R.anisotropy)}}function Y(O,R){let J=!1;O.__webglInit===void 0&&(O.__webglInit=!0,R.addEventListener("dispose",C));const ge=R.source;let pe=d.get(ge);pe===void 0&&(pe={},d.set(ge,pe));const de=A(R);if(de!==O.__cacheKey){pe[de]===void 0&&(pe[de]={texture:r.createTexture(),usedTimes:0},o.memory.textures++,J=!0),pe[de].usedTimes++;const Le=pe[O.__cacheKey];Le!==void 0&&(pe[O.__cacheKey].usedTimes--,Le.usedTimes===0&&T(R)),O.__cacheKey=de,O.__webglTexture=pe[de].texture}return J}function j(O,R,J){let ge=r.TEXTURE_2D;(R.isDataArrayTexture||R.isCompressedArrayTexture)&&(ge=r.TEXTURE_2D_ARRAY),R.isData3DTexture&&(ge=r.TEXTURE_3D);const pe=Y(O,R),de=R.source;t.bindTexture(ge,O.__webglTexture,r.TEXTURE0+J);const Le=n.get(de);if(de.version!==Le.__version||pe===!0){t.activeTexture(r.TEXTURE0+J);const Ee=Ct.getPrimaries(Ct.workingColorSpace),Pe=R.colorSpace===ti?null:Ct.getPrimaries(R.colorSpace),ze=R.colorSpace===ti||Ee===Pe?r.NONE:r.BROWSER_DEFAULT_WEBGL;r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL,R.flipY),r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,R.premultiplyAlpha),r.pixelStorei(r.UNPACK_ALIGNMENT,R.unpackAlignment),r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL,ze);const je=y(R)&&g(R.image)===!1;let me=b(R.image,je,!1,i.maxTextureSize);me=Te(R,me);const _t=g(me)||a,ct=s.convert(R.format,R.colorSpace);let Xe=s.convert(R.type),ke=_(R.internalFormat,ct,Xe,R.colorSpace,R.isVideoTexture);G(ge,R,_t);let Re;const nt=R.mipmaps,Tt=a&&R.isVideoTexture!==!0&&ke!==PE,Zt=Le.__version===void 0||pe===!0,st=M(R,me,_t);if(R.isDepthTexture)ke=r.DEPTH_COMPONENT,a?R.type===Ki?ke=r.DEPTH_COMPONENT32F:R.type===io?ke=r.DEPTH_COMPONENT24:R.type===ya?ke=r.DEPTH24_STENCIL8:ke=r.DEPTH_COMPONENT16:R.type===Ki&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),R.format===ba&&ke===r.DEPTH_COMPONENT&&R.type!==n0&&R.type!==io&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),R.type=io,Xe=s.convert(R.type)),R.format===Ic&&ke===r.DEPTH_COMPONENT&&(ke=r.DEPTH_STENCIL,R.type!==ya&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),R.type=ya,Xe=s.convert(R.type))),Zt&&(Tt?t.texStorage2D(r.TEXTURE_2D,1,ke,me.width,me.height):t.texImage2D(r.TEXTURE_2D,0,ke,me.width,me.height,0,ct,Xe,null));else if(R.isDataTexture)if(nt.length>0&&_t){Tt&&Zt&&t.texStorage2D(r.TEXTURE_2D,st,ke,nt[0].width,nt[0].height);for(let ve=0,K=nt.length;ve<K;ve++)Re=nt[ve],Tt?t.texSubImage2D(r.TEXTURE_2D,ve,0,0,Re.width,Re.height,ct,Xe,Re.data):t.texImage2D(r.TEXTURE_2D,ve,ke,Re.width,Re.height,0,ct,Xe,Re.data);R.generateMipmaps=!1}else Tt?(Zt&&t.texStorage2D(r.TEXTURE_2D,st,ke,me.width,me.height),t.texSubImage2D(r.TEXTURE_2D,0,0,0,me.width,me.height,ct,Xe,me.data)):t.texImage2D(r.TEXTURE_2D,0,ke,me.width,me.height,0,ct,Xe,me.data);else if(R.isCompressedTexture)if(R.isCompressedArrayTexture){Tt&&Zt&&t.texStorage3D(r.TEXTURE_2D_ARRAY,st,ke,nt[0].width,nt[0].height,me.depth);for(let ve=0,K=nt.length;ve<K;ve++)Re=nt[ve],R.format!==kr?ct!==null?Tt?t.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY,ve,0,0,0,Re.width,Re.height,me.depth,ct,Re.data,0,0):t.compressedTexImage3D(r.TEXTURE_2D_ARRAY,ve,ke,Re.width,Re.height,me.depth,0,Re.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Tt?t.texSubImage3D(r.TEXTURE_2D_ARRAY,ve,0,0,0,Re.width,Re.height,me.depth,ct,Xe,Re.data):t.texImage3D(r.TEXTURE_2D_ARRAY,ve,ke,Re.width,Re.height,me.depth,0,ct,Xe,Re.data)}else{Tt&&Zt&&t.texStorage2D(r.TEXTURE_2D,st,ke,nt[0].width,nt[0].height);for(let ve=0,K=nt.length;ve<K;ve++)Re=nt[ve],R.format!==kr?ct!==null?Tt?t.compressedTexSubImage2D(r.TEXTURE_2D,ve,0,0,Re.width,Re.height,ct,Re.data):t.compressedTexImage2D(r.TEXTURE_2D,ve,ke,Re.width,Re.height,0,Re.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Tt?t.texSubImage2D(r.TEXTURE_2D,ve,0,0,Re.width,Re.height,ct,Xe,Re.data):t.texImage2D(r.TEXTURE_2D,ve,ke,Re.width,Re.height,0,ct,Xe,Re.data)}else if(R.isDataArrayTexture)Tt?(Zt&&t.texStorage3D(r.TEXTURE_2D_ARRAY,st,ke,me.width,me.height,me.depth),t.texSubImage3D(r.TEXTURE_2D_ARRAY,0,0,0,0,me.width,me.height,me.depth,ct,Xe,me.data)):t.texImage3D(r.TEXTURE_2D_ARRAY,0,ke,me.width,me.height,me.depth,0,ct,Xe,me.data);else if(R.isData3DTexture)Tt?(Zt&&t.texStorage3D(r.TEXTURE_3D,st,ke,me.width,me.height,me.depth),t.texSubImage3D(r.TEXTURE_3D,0,0,0,0,me.width,me.height,me.depth,ct,Xe,me.data)):t.texImage3D(r.TEXTURE_3D,0,ke,me.width,me.height,me.depth,0,ct,Xe,me.data);else if(R.isFramebufferTexture){if(Zt)if(Tt)t.texStorage2D(r.TEXTURE_2D,st,ke,me.width,me.height);else{let ve=me.width,K=me.height;for(let Me=0;Me<st;Me++)t.texImage2D(r.TEXTURE_2D,Me,ke,ve,K,0,ct,Xe,null),ve>>=1,K>>=1}}else if(nt.length>0&&_t){Tt&&Zt&&t.texStorage2D(r.TEXTURE_2D,st,ke,nt[0].width,nt[0].height);for(let ve=0,K=nt.length;ve<K;ve++)Re=nt[ve],Tt?t.texSubImage2D(r.TEXTURE_2D,ve,0,0,ct,Xe,Re):t.texImage2D(r.TEXTURE_2D,ve,ke,ct,Xe,Re);R.generateMipmaps=!1}else Tt?(Zt&&t.texStorage2D(r.TEXTURE_2D,st,ke,me.width,me.height),t.texSubImage2D(r.TEXTURE_2D,0,0,0,ct,Xe,me)):t.texImage2D(r.TEXTURE_2D,0,ke,ct,Xe,me);v(R,_t)&&w(ge),Le.__version=de.version,R.onUpdate&&R.onUpdate(R)}O.__version=R.version}function X(O,R,J){if(R.image.length!==6)return;const ge=Y(O,R),pe=R.source;t.bindTexture(r.TEXTURE_CUBE_MAP,O.__webglTexture,r.TEXTURE0+J);const de=n.get(pe);if(pe.version!==de.__version||ge===!0){t.activeTexture(r.TEXTURE0+J);const Le=Ct.getPrimaries(Ct.workingColorSpace),Ee=R.colorSpace===ti?null:Ct.getPrimaries(R.colorSpace),Pe=R.colorSpace===ti||Le===Ee?r.NONE:r.BROWSER_DEFAULT_WEBGL;r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL,R.flipY),r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,R.premultiplyAlpha),r.pixelStorei(r.UNPACK_ALIGNMENT,R.unpackAlignment),r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL,Pe);const ze=R.isCompressedTexture||R.image[0].isCompressedTexture,je=R.image[0]&&R.image[0].isDataTexture,me=[];for(let ve=0;ve<6;ve++)!ze&&!je?me[ve]=b(R.image[ve],!1,!0,i.maxCubemapSize):me[ve]=je?R.image[ve].image:R.image[ve],me[ve]=Te(R,me[ve]);const _t=me[0],ct=g(_t)||a,Xe=s.convert(R.format,R.colorSpace),ke=s.convert(R.type),Re=_(R.internalFormat,Xe,ke,R.colorSpace),nt=a&&R.isVideoTexture!==!0,Tt=de.__version===void 0||ge===!0;let Zt=M(R,_t,ct);G(r.TEXTURE_CUBE_MAP,R,ct);let st;if(ze){nt&&Tt&&t.texStorage2D(r.TEXTURE_CUBE_MAP,Zt,Re,_t.width,_t.height);for(let ve=0;ve<6;ve++){st=me[ve].mipmaps;for(let K=0;K<st.length;K++){const Me=st[K];R.format!==kr?Xe!==null?nt?t.compressedTexSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+ve,K,0,0,Me.width,Me.height,Xe,Me.data):t.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+ve,K,Re,Me.width,Me.height,0,Me.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):nt?t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+ve,K,0,0,Me.width,Me.height,Xe,ke,Me.data):t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+ve,K,Re,Me.width,Me.height,0,Xe,ke,Me.data)}}}else{st=R.mipmaps,nt&&Tt&&(st.length>0&&Zt++,t.texStorage2D(r.TEXTURE_CUBE_MAP,Zt,Re,me[0].width,me[0].height));for(let ve=0;ve<6;ve++)if(je){nt?t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+ve,0,0,0,me[ve].width,me[ve].height,Xe,ke,me[ve].data):t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+ve,0,Re,me[ve].width,me[ve].height,0,Xe,ke,me[ve].data);for(let K=0;K<st.length;K++){const Ae=st[K].image[ve].image;nt?t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+ve,K+1,0,0,Ae.width,Ae.height,Xe,ke,Ae.data):t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+ve,K+1,Re,Ae.width,Ae.height,0,Xe,ke,Ae.data)}}else{nt?t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+ve,0,0,0,Xe,ke,me[ve]):t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+ve,0,Re,Xe,ke,me[ve]);for(let K=0;K<st.length;K++){const Me=st[K];nt?t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+ve,K+1,0,0,Xe,ke,Me.image[ve]):t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+ve,K+1,Re,Xe,ke,Me.image[ve])}}}v(R,ct)&&w(r.TEXTURE_CUBE_MAP),de.__version=pe.version,R.onUpdate&&R.onUpdate(R)}O.__version=R.version}function ne(O,R,J,ge,pe,de){const Le=s.convert(J.format,J.colorSpace),Ee=s.convert(J.type),Pe=_(J.internalFormat,Le,Ee,J.colorSpace);if(!n.get(R).__hasExternalTextures){const je=Math.max(1,R.width>>de),me=Math.max(1,R.height>>de);pe===r.TEXTURE_3D||pe===r.TEXTURE_2D_ARRAY?t.texImage3D(pe,de,Pe,je,me,R.depth,0,Le,Ee,null):t.texImage2D(pe,de,Pe,je,me,0,Le,Ee,null)}t.bindFramebuffer(r.FRAMEBUFFER,O),ie(R)?c.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER,ge,pe,n.get(J).__webglTexture,0,le(R)):(pe===r.TEXTURE_2D||pe>=r.TEXTURE_CUBE_MAP_POSITIVE_X&&pe<=r.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&r.framebufferTexture2D(r.FRAMEBUFFER,ge,pe,n.get(J).__webglTexture,de),t.bindFramebuffer(r.FRAMEBUFFER,null)}function oe(O,R,J){if(r.bindRenderbuffer(r.RENDERBUFFER,O),R.depthBuffer&&!R.stencilBuffer){let ge=a===!0?r.DEPTH_COMPONENT24:r.DEPTH_COMPONENT16;if(J||ie(R)){const pe=R.depthTexture;pe&&pe.isDepthTexture&&(pe.type===Ki?ge=r.DEPTH_COMPONENT32F:pe.type===io&&(ge=r.DEPTH_COMPONENT24));const de=le(R);ie(R)?c.renderbufferStorageMultisampleEXT(r.RENDERBUFFER,de,ge,R.width,R.height):r.renderbufferStorageMultisample(r.RENDERBUFFER,de,ge,R.width,R.height)}else r.renderbufferStorage(r.RENDERBUFFER,ge,R.width,R.height);r.framebufferRenderbuffer(r.FRAMEBUFFER,r.DEPTH_ATTACHMENT,r.RENDERBUFFER,O)}else if(R.depthBuffer&&R.stencilBuffer){const ge=le(R);J&&ie(R)===!1?r.renderbufferStorageMultisample(r.RENDERBUFFER,ge,r.DEPTH24_STENCIL8,R.width,R.height):ie(R)?c.renderbufferStorageMultisampleEXT(r.RENDERBUFFER,ge,r.DEPTH24_STENCIL8,R.width,R.height):r.renderbufferStorage(r.RENDERBUFFER,r.DEPTH_STENCIL,R.width,R.height),r.framebufferRenderbuffer(r.FRAMEBUFFER,r.DEPTH_STENCIL_ATTACHMENT,r.RENDERBUFFER,O)}else{const ge=R.isWebGLMultipleRenderTargets===!0?R.texture:[R.texture];for(let pe=0;pe<ge.length;pe++){const de=ge[pe],Le=s.convert(de.format,de.colorSpace),Ee=s.convert(de.type),Pe=_(de.internalFormat,Le,Ee,de.colorSpace),ze=le(R);J&&ie(R)===!1?r.renderbufferStorageMultisample(r.RENDERBUFFER,ze,Pe,R.width,R.height):ie(R)?c.renderbufferStorageMultisampleEXT(r.RENDERBUFFER,ze,Pe,R.width,R.height):r.renderbufferStorage(r.RENDERBUFFER,Pe,R.width,R.height)}}r.bindRenderbuffer(r.RENDERBUFFER,null)}function he(O,R){if(R&&R.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(r.FRAMEBUFFER,O),!(R.depthTexture&&R.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!n.get(R.depthTexture).__webglTexture||R.depthTexture.image.width!==R.width||R.depthTexture.image.height!==R.height)&&(R.depthTexture.image.width=R.width,R.depthTexture.image.height=R.height,R.depthTexture.needsUpdate=!0),P(R.depthTexture,0);const ge=n.get(R.depthTexture).__webglTexture,pe=le(R);if(R.depthTexture.format===ba)ie(R)?c.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER,r.DEPTH_ATTACHMENT,r.TEXTURE_2D,ge,0,pe):r.framebufferTexture2D(r.FRAMEBUFFER,r.DEPTH_ATTACHMENT,r.TEXTURE_2D,ge,0);else if(R.depthTexture.format===Ic)ie(R)?c.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER,r.DEPTH_STENCIL_ATTACHMENT,r.TEXTURE_2D,ge,0,pe):r.framebufferTexture2D(r.FRAMEBUFFER,r.DEPTH_STENCIL_ATTACHMENT,r.TEXTURE_2D,ge,0);else throw new Error("Unknown depthTexture format")}function ce(O){const R=n.get(O),J=O.isWebGLCubeRenderTarget===!0;if(O.depthTexture&&!R.__autoAllocateDepthBuffer){if(J)throw new Error("target.depthTexture not supported in Cube render targets");he(R.__webglFramebuffer,O)}else if(J){R.__webglDepthbuffer=[];for(let ge=0;ge<6;ge++)t.bindFramebuffer(r.FRAMEBUFFER,R.__webglFramebuffer[ge]),R.__webglDepthbuffer[ge]=r.createRenderbuffer(),oe(R.__webglDepthbuffer[ge],O,!1)}else t.bindFramebuffer(r.FRAMEBUFFER,R.__webglFramebuffer),R.__webglDepthbuffer=r.createRenderbuffer(),oe(R.__webglDepthbuffer,O,!1);t.bindFramebuffer(r.FRAMEBUFFER,null)}function fe(O,R,J){const ge=n.get(O);R!==void 0&&ne(ge.__webglFramebuffer,O,O.texture,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,0),J!==void 0&&ce(O)}function W(O){const R=O.texture,J=n.get(O),ge=n.get(R);O.addEventListener("dispose",I),O.isWebGLMultipleRenderTargets!==!0&&(ge.__webglTexture===void 0&&(ge.__webglTexture=r.createTexture()),ge.__version=R.version,o.memory.textures++);const pe=O.isWebGLCubeRenderTarget===!0,de=O.isWebGLMultipleRenderTargets===!0,Le=g(O)||a;if(pe){J.__webglFramebuffer=[];for(let Ee=0;Ee<6;Ee++)if(a&&R.mipmaps&&R.mipmaps.length>0){J.__webglFramebuffer[Ee]=[];for(let Pe=0;Pe<R.mipmaps.length;Pe++)J.__webglFramebuffer[Ee][Pe]=r.createFramebuffer()}else J.__webglFramebuffer[Ee]=r.createFramebuffer()}else{if(a&&R.mipmaps&&R.mipmaps.length>0){J.__webglFramebuffer=[];for(let Ee=0;Ee<R.mipmaps.length;Ee++)J.__webglFramebuffer[Ee]=r.createFramebuffer()}else J.__webglFramebuffer=r.createFramebuffer();if(de)if(i.drawBuffers){const Ee=O.texture;for(let Pe=0,ze=Ee.length;Pe<ze;Pe++){const je=n.get(Ee[Pe]);je.__webglTexture===void 0&&(je.__webglTexture=r.createTexture(),o.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(a&&O.samples>0&&ie(O)===!1){const Ee=de?R:[R];J.__webglMultisampledFramebuffer=r.createFramebuffer(),J.__webglColorRenderbuffer=[],t.bindFramebuffer(r.FRAMEBUFFER,J.__webglMultisampledFramebuffer);for(let Pe=0;Pe<Ee.length;Pe++){const ze=Ee[Pe];J.__webglColorRenderbuffer[Pe]=r.createRenderbuffer(),r.bindRenderbuffer(r.RENDERBUFFER,J.__webglColorRenderbuffer[Pe]);const je=s.convert(ze.format,ze.colorSpace),me=s.convert(ze.type),_t=_(ze.internalFormat,je,me,ze.colorSpace,O.isXRRenderTarget===!0),ct=le(O);r.renderbufferStorageMultisample(r.RENDERBUFFER,ct,_t,O.width,O.height),r.framebufferRenderbuffer(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0+Pe,r.RENDERBUFFER,J.__webglColorRenderbuffer[Pe])}r.bindRenderbuffer(r.RENDERBUFFER,null),O.depthBuffer&&(J.__webglDepthRenderbuffer=r.createRenderbuffer(),oe(J.__webglDepthRenderbuffer,O,!0)),t.bindFramebuffer(r.FRAMEBUFFER,null)}}if(pe){t.bindTexture(r.TEXTURE_CUBE_MAP,ge.__webglTexture),G(r.TEXTURE_CUBE_MAP,R,Le);for(let Ee=0;Ee<6;Ee++)if(a&&R.mipmaps&&R.mipmaps.length>0)for(let Pe=0;Pe<R.mipmaps.length;Pe++)ne(J.__webglFramebuffer[Ee][Pe],O,R,r.COLOR_ATTACHMENT0,r.TEXTURE_CUBE_MAP_POSITIVE_X+Ee,Pe);else ne(J.__webglFramebuffer[Ee],O,R,r.COLOR_ATTACHMENT0,r.TEXTURE_CUBE_MAP_POSITIVE_X+Ee,0);v(R,Le)&&w(r.TEXTURE_CUBE_MAP),t.unbindTexture()}else if(de){const Ee=O.texture;for(let Pe=0,ze=Ee.length;Pe<ze;Pe++){const je=Ee[Pe],me=n.get(je);t.bindTexture(r.TEXTURE_2D,me.__webglTexture),G(r.TEXTURE_2D,je,Le),ne(J.__webglFramebuffer,O,je,r.COLOR_ATTACHMENT0+Pe,r.TEXTURE_2D,0),v(je,Le)&&w(r.TEXTURE_2D)}t.unbindTexture()}else{let Ee=r.TEXTURE_2D;if((O.isWebGL3DRenderTarget||O.isWebGLArrayRenderTarget)&&(a?Ee=O.isWebGL3DRenderTarget?r.TEXTURE_3D:r.TEXTURE_2D_ARRAY:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),t.bindTexture(Ee,ge.__webglTexture),G(Ee,R,Le),a&&R.mipmaps&&R.mipmaps.length>0)for(let Pe=0;Pe<R.mipmaps.length;Pe++)ne(J.__webglFramebuffer[Pe],O,R,r.COLOR_ATTACHMENT0,Ee,Pe);else ne(J.__webglFramebuffer,O,R,r.COLOR_ATTACHMENT0,Ee,0);v(R,Le)&&w(Ee),t.unbindTexture()}O.depthBuffer&&ce(O)}function ue(O){const R=g(O)||a,J=O.isWebGLMultipleRenderTargets===!0?O.texture:[O.texture];for(let ge=0,pe=J.length;ge<pe;ge++){const de=J[ge];if(v(de,R)){const Le=O.isWebGLCubeRenderTarget?r.TEXTURE_CUBE_MAP:r.TEXTURE_2D,Ee=n.get(de).__webglTexture;t.bindTexture(Le,Ee),w(Le),t.unbindTexture()}}}function re(O){if(a&&O.samples>0&&ie(O)===!1){const R=O.isWebGLMultipleRenderTargets?O.texture:[O.texture],J=O.width,ge=O.height;let pe=r.COLOR_BUFFER_BIT;const de=[],Le=O.stencilBuffer?r.DEPTH_STENCIL_ATTACHMENT:r.DEPTH_ATTACHMENT,Ee=n.get(O),Pe=O.isWebGLMultipleRenderTargets===!0;if(Pe)for(let ze=0;ze<R.length;ze++)t.bindFramebuffer(r.FRAMEBUFFER,Ee.__webglMultisampledFramebuffer),r.framebufferRenderbuffer(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0+ze,r.RENDERBUFFER,null),t.bindFramebuffer(r.FRAMEBUFFER,Ee.__webglFramebuffer),r.framebufferTexture2D(r.DRAW_FRAMEBUFFER,r.COLOR_ATTACHMENT0+ze,r.TEXTURE_2D,null,0);t.bindFramebuffer(r.READ_FRAMEBUFFER,Ee.__webglMultisampledFramebuffer),t.bindFramebuffer(r.DRAW_FRAMEBUFFER,Ee.__webglFramebuffer);for(let ze=0;ze<R.length;ze++){de.push(r.COLOR_ATTACHMENT0+ze),O.depthBuffer&&de.push(Le);const je=Ee.__ignoreDepthValues!==void 0?Ee.__ignoreDepthValues:!1;if(je===!1&&(O.depthBuffer&&(pe|=r.DEPTH_BUFFER_BIT),O.stencilBuffer&&(pe|=r.STENCIL_BUFFER_BIT)),Pe&&r.framebufferRenderbuffer(r.READ_FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.RENDERBUFFER,Ee.__webglColorRenderbuffer[ze]),je===!0&&(r.invalidateFramebuffer(r.READ_FRAMEBUFFER,[Le]),r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER,[Le])),Pe){const me=n.get(R[ze]).__webglTexture;r.framebufferTexture2D(r.DRAW_FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,me,0)}r.blitFramebuffer(0,0,J,ge,0,0,J,ge,pe,r.NEAREST),l&&r.invalidateFramebuffer(r.READ_FRAMEBUFFER,de)}if(t.bindFramebuffer(r.READ_FRAMEBUFFER,null),t.bindFramebuffer(r.DRAW_FRAMEBUFFER,null),Pe)for(let ze=0;ze<R.length;ze++){t.bindFramebuffer(r.FRAMEBUFFER,Ee.__webglMultisampledFramebuffer),r.framebufferRenderbuffer(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0+ze,r.RENDERBUFFER,Ee.__webglColorRenderbuffer[ze]);const je=n.get(R[ze]).__webglTexture;t.bindFramebuffer(r.FRAMEBUFFER,Ee.__webglFramebuffer),r.framebufferTexture2D(r.DRAW_FRAMEBUFFER,r.COLOR_ATTACHMENT0+ze,r.TEXTURE_2D,je,0)}t.bindFramebuffer(r.DRAW_FRAMEBUFFER,Ee.__webglMultisampledFramebuffer)}}function le(O){return Math.min(i.maxSamples,O.samples)}function ie(O){const R=n.get(O);return a&&O.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&R.__useRenderToTexture!==!1}function Oe(O){const R=o.render.frame;u.get(O)!==R&&(u.set(O,R),O.update())}function Te(O,R){const J=O.colorSpace,ge=O.format,pe=O.type;return O.isCompressedTexture===!0||O.isVideoTexture===!0||O.format===$g||J!==Ts&&J!==ti&&(Ct.getTransfer(J)===Ft?a===!1?e.has("EXT_sRGB")===!0&&ge===kr?(O.format=$g,O.minFilter=un,O.generateMipmaps=!1):R=OE.sRGBToLinear(R):(ge!==kr||pe!==_o)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",J)),R}this.allocateTextureUnit=S,this.resetTextureUnits=H,this.setTexture2D=P,this.setTexture2DArray=L,this.setTexture3D=B,this.setTextureCube=D,this.rebindTextures=fe,this.setupRenderTarget=W,this.updateRenderTargetMipmap=ue,this.updateMultisampleRenderTarget=re,this.setupDepthRenderbuffer=ce,this.setupFrameBufferTexture=ne,this.useMultisampledRTT=ie}function KL(r,e,t){const n=t.isWebGL2;function i(s,o=ti){let a;const c=Ct.getTransfer(o);if(s===_o)return r.UNSIGNED_BYTE;if(s===ME)return r.UNSIGNED_SHORT_4_4_4_4;if(s===AE)return r.UNSIGNED_SHORT_5_5_5_1;if(s===dL)return r.BYTE;if(s===fL)return r.SHORT;if(s===n0)return r.UNSIGNED_SHORT;if(s===EE)return r.INT;if(s===io)return r.UNSIGNED_INT;if(s===Ki)return r.FLOAT;if(s===ku)return n?r.HALF_FLOAT:(a=e.get("OES_texture_half_float"),a!==null?a.HALF_FLOAT_OES:null);if(s===pL)return r.ALPHA;if(s===kr)return r.RGBA;if(s===mL)return r.LUMINANCE;if(s===gL)return r.LUMINANCE_ALPHA;if(s===ba)return r.DEPTH_COMPONENT;if(s===Ic)return r.DEPTH_STENCIL;if(s===$g)return a=e.get("EXT_sRGB"),a!==null?a.SRGB_ALPHA_EXT:null;if(s===yL)return r.RED;if(s===TE)return r.RED_INTEGER;if(s===bL)return r.RG;if(s===CE)return r.RG_INTEGER;if(s===IE)return r.RGBA_INTEGER;if(s===ag||s===cg||s===lg||s===ug)if(c===Ft)if(a=e.get("WEBGL_compressed_texture_s3tc_srgb"),a!==null){if(s===ag)return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(s===cg)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(s===lg)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(s===ug)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(a=e.get("WEBGL_compressed_texture_s3tc"),a!==null){if(s===ag)return a.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===cg)return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===lg)return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===ug)return a.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(s===hx||s===dx||s===fx||s===px)if(a=e.get("WEBGL_compressed_texture_pvrtc"),a!==null){if(s===hx)return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===dx)return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===fx)return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===px)return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(s===PE)return a=e.get("WEBGL_compressed_texture_etc1"),a!==null?a.COMPRESSED_RGB_ETC1_WEBGL:null;if(s===mx||s===gx)if(a=e.get("WEBGL_compressed_texture_etc"),a!==null){if(s===mx)return c===Ft?a.COMPRESSED_SRGB8_ETC2:a.COMPRESSED_RGB8_ETC2;if(s===gx)return c===Ft?a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:a.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(s===yx||s===bx||s===wx||s===vx||s===_x||s===xx||s===Sx||s===Ex||s===Mx||s===Ax||s===Tx||s===Cx||s===Ix||s===Px)if(a=e.get("WEBGL_compressed_texture_astc"),a!==null){if(s===yx)return c===Ft?a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:a.COMPRESSED_RGBA_ASTC_4x4_KHR;if(s===bx)return c===Ft?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:a.COMPRESSED_RGBA_ASTC_5x4_KHR;if(s===wx)return c===Ft?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:a.COMPRESSED_RGBA_ASTC_5x5_KHR;if(s===vx)return c===Ft?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:a.COMPRESSED_RGBA_ASTC_6x5_KHR;if(s===_x)return c===Ft?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:a.COMPRESSED_RGBA_ASTC_6x6_KHR;if(s===xx)return c===Ft?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:a.COMPRESSED_RGBA_ASTC_8x5_KHR;if(s===Sx)return c===Ft?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:a.COMPRESSED_RGBA_ASTC_8x6_KHR;if(s===Ex)return c===Ft?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:a.COMPRESSED_RGBA_ASTC_8x8_KHR;if(s===Mx)return c===Ft?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:a.COMPRESSED_RGBA_ASTC_10x5_KHR;if(s===Ax)return c===Ft?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:a.COMPRESSED_RGBA_ASTC_10x6_KHR;if(s===Tx)return c===Ft?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:a.COMPRESSED_RGBA_ASTC_10x8_KHR;if(s===Cx)return c===Ft?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:a.COMPRESSED_RGBA_ASTC_10x10_KHR;if(s===Ix)return c===Ft?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:a.COMPRESSED_RGBA_ASTC_12x10_KHR;if(s===Px)return c===Ft?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:a.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(s===hg||s===Rx||s===Dx)if(a=e.get("EXT_texture_compression_bptc"),a!==null){if(s===hg)return c===Ft?a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:a.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(s===Rx)return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(s===Dx)return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(s===wL||s===Lx||s===Nx||s===Ox)if(a=e.get("EXT_texture_compression_rgtc"),a!==null){if(s===hg)return a.COMPRESSED_RED_RGTC1_EXT;if(s===Lx)return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(s===Nx)return a.COMPRESSED_RED_GREEN_RGTC2_EXT;if(s===Ox)return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return s===ya?n?r.UNSIGNED_INT_24_8:(a=e.get("WEBGL_depth_texture"),a!==null?a.UNSIGNED_INT_24_8_WEBGL:null):r[s]!==void 0?r[s]:null}return{convert:i}}class XL extends In{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e}}class On extends wt{constructor(){super(),this.isGroup=!0,this.type="Group"}}const aH={type:"move"};class Nb{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new On,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new On,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new k,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new k),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new On,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new k,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new k),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const t=this._hand;if(t)for(const n of e.hand.values())this._getHandJoint(t,n)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,n){let i=null,s=null,o=null;const a=this._targetRay,c=this._grip,l=this._hand;if(e&&t.session.visibilityState!=="visible-blurred"){if(l&&e.hand){o=!0;for(const b of e.hand.values()){const g=t.getJointPose(b,n),y=this._getHandJoint(l,b);g!==null&&(y.matrix.fromArray(g.transform.matrix),y.matrix.decompose(y.position,y.rotation,y.scale),y.matrixWorldNeedsUpdate=!0,y.jointRadius=g.radius),y.visible=g!==null}const u=l.joints["index-finger-tip"],h=l.joints["thumb-tip"],d=u.position.distanceTo(h.position),m=.02,p=.005;l.inputState.pinching&&d>m+p?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!l.inputState.pinching&&d<=m-p&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else c!==null&&e.gripSpace&&(s=t.getPose(e.gripSpace,n),s!==null&&(c.matrix.fromArray(s.transform.matrix),c.matrix.decompose(c.position,c.rotation,c.scale),c.matrixWorldNeedsUpdate=!0,s.linearVelocity?(c.hasLinearVelocity=!0,c.linearVelocity.copy(s.linearVelocity)):c.hasLinearVelocity=!1,s.angularVelocity?(c.hasAngularVelocity=!0,c.angularVelocity.copy(s.angularVelocity)):c.hasAngularVelocity=!1));a!==null&&(i=t.getPose(e.targetRaySpace,n),i===null&&s!==null&&(i=s),i!==null&&(a.matrix.fromArray(i.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),a.matrixWorldNeedsUpdate=!0,i.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(i.linearVelocity)):a.hasLinearVelocity=!1,i.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(i.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(aH)))}return a!==null&&(a.visible=i!==null),c!==null&&(c.visible=s!==null),l!==null&&(l.visible=o!==null),this}_getHandJoint(e,t){if(e.joints[t.jointName]===void 0){const n=new On;n.matrixAutoUpdate=!1,n.visible=!1,e.joints[t.jointName]=n,e.add(n)}return e.joints[t.jointName]}}class cH extends Do{constructor(e,t){super();const n=this;let i=null,s=1,o=null,a="local-floor",c=1,l=null,u=null,h=null,d=null,m=null,p=null;const b=t.getContextAttributes();let g=null,y=null;const v=[],w=[],_=new se;let M=null;const E=new In;E.layers.enable(1),E.viewport=new mt;const C=new In;C.layers.enable(2),C.viewport=new mt;const I=[E,C],x=new XL;x.layers.enable(1),x.layers.enable(2);let T=null,F=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(G){let Y=v[G];return Y===void 0&&(Y=new Nb,v[G]=Y),Y.getTargetRaySpace()},this.getControllerGrip=function(G){let Y=v[G];return Y===void 0&&(Y=new Nb,v[G]=Y),Y.getGripSpace()},this.getHand=function(G){let Y=v[G];return Y===void 0&&(Y=new Nb,v[G]=Y),Y.getHandSpace()};function $(G){const Y=w.indexOf(G.inputSource);if(Y===-1)return;const j=v[Y];j!==void 0&&(j.update(G.inputSource,G.frame,l||o),j.dispatchEvent({type:G.type,data:G.inputSource}))}function H(){i.removeEventListener("select",$),i.removeEventListener("selectstart",$),i.removeEventListener("selectend",$),i.removeEventListener("squeeze",$),i.removeEventListener("squeezestart",$),i.removeEventListener("squeezeend",$),i.removeEventListener("end",H),i.removeEventListener("inputsourceschange",S);for(let G=0;G<v.length;G++){const Y=w[G];Y!==null&&(w[G]=null,v[G].disconnect(Y))}T=null,F=null,e.setRenderTarget(g),m=null,d=null,h=null,i=null,y=null,q.stop(),n.isPresenting=!1,e.setPixelRatio(M),e.setSize(_.width,_.height,!1),n.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(G){s=G,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(G){a=G,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return l||o},this.setReferenceSpace=function(G){l=G},this.getBaseLayer=function(){return d!==null?d:m},this.getBinding=function(){return h},this.getFrame=function(){return p},this.getSession=function(){return i},this.setSession=async function(G){if(i=G,i!==null){if(g=e.getRenderTarget(),i.addEventListener("select",$),i.addEventListener("selectstart",$),i.addEventListener("selectend",$),i.addEventListener("squeeze",$),i.addEventListener("squeezestart",$),i.addEventListener("squeezeend",$),i.addEventListener("end",H),i.addEventListener("inputsourceschange",S),b.xrCompatible!==!0&&await t.makeXRCompatible(),M=e.getPixelRatio(),e.getSize(_),i.renderState.layers===void 0||e.capabilities.isWebGL2===!1){const Y={antialias:i.renderState.layers===void 0?b.antialias:!0,alpha:!0,depth:b.depth,stencil:b.stencil,framebufferScaleFactor:s};m=new XRWebGLLayer(i,t,Y),i.updateRenderState({baseLayer:m}),e.setPixelRatio(1),e.setSize(m.framebufferWidth,m.framebufferHeight,!1),y=new ts(m.framebufferWidth,m.framebufferHeight,{format:kr,type:_o,colorSpace:e.outputColorSpace,stencilBuffer:b.stencil})}else{let Y=null,j=null,X=null;b.depth&&(X=b.stencil?t.DEPTH24_STENCIL8:t.DEPTH_COMPONENT24,Y=b.stencil?Ic:ba,j=b.stencil?ya:io);const ne={colorFormat:t.RGBA8,depthFormat:X,scaleFactor:s};h=new XRWebGLBinding(i,t),d=h.createProjectionLayer(ne),i.updateRenderState({layers:[d]}),e.setPixelRatio(1),e.setSize(d.textureWidth,d.textureHeight,!1),y=new ts(d.textureWidth,d.textureHeight,{format:kr,type:_o,depthTexture:new $E(d.textureWidth,d.textureHeight,j,void 0,void 0,void 0,void 0,void 0,void 0,Y),stencilBuffer:b.stencil,colorSpace:e.outputColorSpace,samples:b.antialias?4:0});const oe=e.properties.get(y);oe.__ignoreDepthValues=d.ignoreDepthValues}y.isXRRenderTarget=!0,this.setFoveation(c),l=null,o=await i.requestReferenceSpace(a),q.setContext(i),q.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(i!==null)return i.environmentBlendMode};function S(G){for(let Y=0;Y<G.removed.length;Y++){const j=G.removed[Y],X=w.indexOf(j);X>=0&&(w[X]=null,v[X].disconnect(j))}for(let Y=0;Y<G.added.length;Y++){const j=G.added[Y];let X=w.indexOf(j);if(X===-1){for(let oe=0;oe<v.length;oe++)if(oe>=w.length){w.push(j),X=oe;break}else if(w[oe]===null){w[oe]=j,X=oe;break}if(X===-1)break}const ne=v[X];ne&&ne.connect(j)}}const A=new k,P=new k;function L(G,Y,j){A.setFromMatrixPosition(Y.matrixWorld),P.setFromMatrixPosition(j.matrixWorld);const X=A.distanceTo(P),ne=Y.projectionMatrix.elements,oe=j.projectionMatrix.elements,he=ne[14]/(ne[10]-1),ce=ne[14]/(ne[10]+1),fe=(ne[9]+1)/ne[5],W=(ne[9]-1)/ne[5],ue=(ne[8]-1)/ne[0],re=(oe[8]+1)/oe[0],le=he*ue,ie=he*re,Oe=X/(-ue+re),Te=Oe*-ue;Y.matrixWorld.decompose(G.position,G.quaternion,G.scale),G.translateX(Te),G.translateZ(Oe),G.matrixWorld.compose(G.position,G.quaternion,G.scale),G.matrixWorldInverse.copy(G.matrixWorld).invert();const O=he+Oe,R=ce+Oe,J=le-Te,ge=ie+(X-Te),pe=fe*ce/R*O,de=W*ce/R*O;G.projectionMatrix.makePerspective(J,ge,pe,de,O,R),G.projectionMatrixInverse.copy(G.projectionMatrix).invert()}function B(G,Y){Y===null?G.matrixWorld.copy(G.matrix):G.matrixWorld.multiplyMatrices(Y.matrixWorld,G.matrix),G.matrixWorldInverse.copy(G.matrixWorld).invert()}this.updateCamera=function(G){if(i===null)return;x.near=C.near=E.near=G.near,x.far=C.far=E.far=G.far,(T!==x.near||F!==x.far)&&(i.updateRenderState({depthNear:x.near,depthFar:x.far}),T=x.near,F=x.far);const Y=G.parent,j=x.cameras;B(x,Y);for(let X=0;X<j.length;X++)B(j[X],Y);j.length===2?L(x,E,C):x.projectionMatrix.copy(E.projectionMatrix),D(G,x,Y)};function D(G,Y,j){j===null?G.matrix.copy(Y.matrixWorld):(G.matrix.copy(j.matrixWorld),G.matrix.invert(),G.matrix.multiply(Y.matrixWorld)),G.matrix.decompose(G.position,G.quaternion,G.scale),G.updateMatrixWorld(!0),G.projectionMatrix.copy(Y.projectionMatrix),G.projectionMatrixInverse.copy(Y.projectionMatrixInverse),G.isPerspectiveCamera&&(G.fov=Fu*2*Math.atan(1/G.projectionMatrix.elements[5]),G.zoom=1)}this.getCamera=function(){return x},this.getFoveation=function(){if(!(d===null&&m===null))return c},this.setFoveation=function(G){c=G,d!==null&&(d.fixedFoveation=G),m!==null&&m.fixedFoveation!==void 0&&(m.fixedFoveation=G)};let V=null;function z(G,Y){if(u=Y.getViewerPose(l||o),p=Y,u!==null){const j=u.views;m!==null&&(e.setRenderTargetFramebuffer(y,m.framebuffer),e.setRenderTarget(y));let X=!1;j.length!==x.cameras.length&&(x.cameras.length=0,X=!0);for(let ne=0;ne<j.length;ne++){const oe=j[ne];let he=null;if(m!==null)he=m.getViewport(oe);else{const fe=h.getViewSubImage(d,oe);he=fe.viewport,ne===0&&(e.setRenderTargetTextures(y,fe.colorTexture,d.ignoreDepthValues?void 0:fe.depthStencilTexture),e.setRenderTarget(y))}let ce=I[ne];ce===void 0&&(ce=new In,ce.layers.enable(ne),ce.viewport=new mt,I[ne]=ce),ce.matrix.fromArray(oe.transform.matrix),ce.matrix.decompose(ce.position,ce.quaternion,ce.scale),ce.projectionMatrix.fromArray(oe.projectionMatrix),ce.projectionMatrixInverse.copy(ce.projectionMatrix).invert(),ce.viewport.set(he.x,he.y,he.width,he.height),ne===0&&(x.matrix.copy(ce.matrix),x.matrix.decompose(x.position,x.quaternion,x.scale)),X===!0&&x.cameras.push(ce)}}for(let j=0;j<v.length;j++){const X=w[j],ne=v[j];X!==null&&ne!==void 0&&ne.update(X,Y,l||o)}V&&V(G,Y),Y.detectedPlanes&&n.dispatchEvent({type:"planesdetected",data:Y}),p=null}const q=new zL;q.setAnimationLoop(z),this.setAnimationLoop=function(G){V=G},this.dispose=function(){}}}function lH(r,e){function t(g,y){g.matrixAutoUpdate===!0&&g.updateMatrix(),y.value.copy(g.matrix)}function n(g,y){y.color.getRGB(g.fogColor.value,kL(r)),y.isFog?(g.fogNear.value=y.near,g.fogFar.value=y.far):y.isFogExp2&&(g.fogDensity.value=y.density)}function i(g,y,v,w,_){y.isMeshBasicMaterial||y.isMeshLambertMaterial?s(g,y):y.isMeshToonMaterial?(s(g,y),h(g,y)):y.isMeshPhongMaterial?(s(g,y),u(g,y)):y.isMeshStandardMaterial?(s(g,y),d(g,y),y.isMeshPhysicalMaterial&&m(g,y,_)):y.isMeshMatcapMaterial?(s(g,y),p(g,y)):y.isMeshDepthMaterial?s(g,y):y.isMeshDistanceMaterial?(s(g,y),b(g,y)):y.isMeshNormalMaterial?s(g,y):y.isLineBasicMaterial?(o(g,y),y.isLineDashedMaterial&&a(g,y)):y.isPointsMaterial?c(g,y,v,w):y.isSpriteMaterial?l(g,y):y.isShadowMaterial?(g.color.value.copy(y.color),g.opacity.value=y.opacity):y.isShaderMaterial&&(y.uniformsNeedUpdate=!1)}function s(g,y){g.opacity.value=y.opacity,y.color&&g.diffuse.value.copy(y.color),y.emissive&&g.emissive.value.copy(y.emissive).multiplyScalar(y.emissiveIntensity),y.map&&(g.map.value=y.map,t(y.map,g.mapTransform)),y.alphaMap&&(g.alphaMap.value=y.alphaMap,t(y.alphaMap,g.alphaMapTransform)),y.bumpMap&&(g.bumpMap.value=y.bumpMap,t(y.bumpMap,g.bumpMapTransform),g.bumpScale.value=y.bumpScale,y.side===yr&&(g.bumpScale.value*=-1)),y.normalMap&&(g.normalMap.value=y.normalMap,t(y.normalMap,g.normalMapTransform),g.normalScale.value.copy(y.normalScale),y.side===yr&&g.normalScale.value.negate()),y.displacementMap&&(g.displacementMap.value=y.displacementMap,t(y.displacementMap,g.displacementMapTransform),g.displacementScale.value=y.displacementScale,g.displacementBias.value=y.displacementBias),y.emissiveMap&&(g.emissiveMap.value=y.emissiveMap,t(y.emissiveMap,g.emissiveMapTransform)),y.specularMap&&(g.specularMap.value=y.specularMap,t(y.specularMap,g.specularMapTransform)),y.alphaTest>0&&(g.alphaTest.value=y.alphaTest);const v=e.get(y).envMap;if(v&&(g.envMap.value=v,g.flipEnvMap.value=v.isCubeTexture&&v.isRenderTargetTexture===!1?-1:1,g.reflectivity.value=y.reflectivity,g.ior.value=y.ior,g.refractionRatio.value=y.refractionRatio),y.lightMap){g.lightMap.value=y.lightMap;const w=r._useLegacyLights===!0?Math.PI:1;g.lightMapIntensity.value=y.lightMapIntensity*w,t(y.lightMap,g.lightMapTransform)}y.aoMap&&(g.aoMap.value=y.aoMap,g.aoMapIntensity.value=y.aoMapIntensity,t(y.aoMap,g.aoMapTransform))}function o(g,y){g.diffuse.value.copy(y.color),g.opacity.value=y.opacity,y.map&&(g.map.value=y.map,t(y.map,g.mapTransform))}function a(g,y){g.dashSize.value=y.dashSize,g.totalSize.value=y.dashSize+y.gapSize,g.scale.value=y.scale}function c(g,y,v,w){g.diffuse.value.copy(y.color),g.opacity.value=y.opacity,g.size.value=y.size*v,g.scale.value=w*.5,y.map&&(g.map.value=y.map,t(y.map,g.uvTransform)),y.alphaMap&&(g.alphaMap.value=y.alphaMap,t(y.alphaMap,g.alphaMapTransform)),y.alphaTest>0&&(g.alphaTest.value=y.alphaTest)}function l(g,y){g.diffuse.value.copy(y.color),g.opacity.value=y.opacity,g.rotation.value=y.rotation,y.map&&(g.map.value=y.map,t(y.map,g.mapTransform)),y.alphaMap&&(g.alphaMap.value=y.alphaMap,t(y.alphaMap,g.alphaMapTransform)),y.alphaTest>0&&(g.alphaTest.value=y.alphaTest)}function u(g,y){g.specular.value.copy(y.specular),g.shininess.value=Math.max(y.shininess,1e-4)}function h(g,y){y.gradientMap&&(g.gradientMap.value=y.gradientMap)}function d(g,y){g.metalness.value=y.metalness,y.metalnessMap&&(g.metalnessMap.value=y.metalnessMap,t(y.metalnessMap,g.metalnessMapTransform)),g.roughness.value=y.roughness,y.roughnessMap&&(g.roughnessMap.value=y.roughnessMap,t(y.roughnessMap,g.roughnessMapTransform)),e.get(y).envMap&&(g.envMapIntensity.value=y.envMapIntensity)}function m(g,y,v){g.ior.value=y.ior,y.sheen>0&&(g.sheenColor.value.copy(y.sheenColor).multiplyScalar(y.sheen),g.sheenRoughness.value=y.sheenRoughness,y.sheenColorMap&&(g.sheenColorMap.value=y.sheenColorMap,t(y.sheenColorMap,g.sheenColorMapTransform)),y.sheenRoughnessMap&&(g.sheenRoughnessMap.value=y.sheenRoughnessMap,t(y.sheenRoughnessMap,g.sheenRoughnessMapTransform))),y.clearcoat>0&&(g.clearcoat.value=y.clearcoat,g.clearcoatRoughness.value=y.clearcoatRoughness,y.clearcoatMap&&(g.clearcoatMap.value=y.clearcoatMap,t(y.clearcoatMap,g.clearcoatMapTransform)),y.clearcoatRoughnessMap&&(g.clearcoatRoughnessMap.value=y.clearcoatRoughnessMap,t(y.clearcoatRoughnessMap,g.clearcoatRoughnessMapTransform)),y.clearcoatNormalMap&&(g.clearcoatNormalMap.value=y.clearcoatNormalMap,t(y.clearcoatNormalMap,g.clearcoatNormalMapTransform),g.clearcoatNormalScale.value.copy(y.clearcoatNormalScale),y.side===yr&&g.clearcoatNormalScale.value.negate())),y.iridescence>0&&(g.iridescence.value=y.iridescence,g.iridescenceIOR.value=y.iridescenceIOR,g.iridescenceThicknessMinimum.value=y.iridescenceThicknessRange[0],g.iridescenceThicknessMaximum.value=y.iridescenceThicknessRange[1],y.iridescenceMap&&(g.iridescenceMap.value=y.iridescenceMap,t(y.iridescenceMap,g.iridescenceMapTransform)),y.iridescenceThicknessMap&&(g.iridescenceThicknessMap.value=y.iridescenceThicknessMap,t(y.iridescenceThicknessMap,g.iridescenceThicknessMapTransform))),y.transmission>0&&(g.transmission.value=y.transmission,g.transmissionSamplerMap.value=v.texture,g.transmissionSamplerSize.value.set(v.width,v.height),y.transmissionMap&&(g.transmissionMap.value=y.transmissionMap,t(y.transmissionMap,g.transmissionMapTransform)),g.thickness.value=y.thickness,y.thicknessMap&&(g.thicknessMap.value=y.thicknessMap,t(y.thicknessMap,g.thicknessMapTransform)),g.attenuationDistance.value=y.attenuationDistance,g.attenuationColor.value.copy(y.attenuationColor)),y.anisotropy>0&&(g.anisotropyVector.value.set(y.anisotropy*Math.cos(y.anisotropyRotation),y.anisotropy*Math.sin(y.anisotropyRotation)),y.anisotropyMap&&(g.anisotropyMap.value=y.anisotropyMap,t(y.anisotropyMap,g.anisotropyMapTransform))),g.specularIntensity.value=y.specularIntensity,g.specularColor.value.copy(y.specularColor),y.specularColorMap&&(g.specularColorMap.value=y.specularColorMap,t(y.specularColorMap,g.specularColorMapTransform)),y.specularIntensityMap&&(g.specularIntensityMap.value=y.specularIntensityMap,t(y.specularIntensityMap,g.specularIntensityMapTransform))}function p(g,y){y.matcap&&(g.matcap.value=y.matcap)}function b(g,y){const v=e.get(y).light;g.referencePosition.value.setFromMatrixPosition(v.matrixWorld),g.nearDistance.value=v.shadow.camera.near,g.farDistance.value=v.shadow.camera.far}return{refreshFogUniforms:n,refreshMaterialUniforms:i}}function uH(r,e,t,n){let i={},s={},o=[];const a=t.isWebGL2?r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS):0;function c(v,w){const _=w.program;n.uniformBlockBinding(v,_)}function l(v,w){let _=i[v.id];_===void 0&&(p(v),_=u(v),i[v.id]=_,v.addEventListener("dispose",g));const M=w.program;n.updateUBOMapping(v,M);const E=e.render.frame;s[v.id]!==E&&(d(v),s[v.id]=E)}function u(v){const w=h();v.__bindingPointIndex=w;const _=r.createBuffer(),M=v.__size,E=v.usage;return r.bindBuffer(r.UNIFORM_BUFFER,_),r.bufferData(r.UNIFORM_BUFFER,M,E),r.bindBuffer(r.UNIFORM_BUFFER,null),r.bindBufferBase(r.UNIFORM_BUFFER,w,_),_}function h(){for(let v=0;v<a;v++)if(o.indexOf(v)===-1)return o.push(v),v;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function d(v){const w=i[v.id],_=v.uniforms,M=v.__cache;r.bindBuffer(r.UNIFORM_BUFFER,w);for(let E=0,C=_.length;E<C;E++){const I=Array.isArray(_[E])?_[E]:[_[E]];for(let x=0,T=I.length;x<T;x++){const F=I[x];if(m(F,E,x,M)===!0){const $=F.__offset,H=Array.isArray(F.value)?F.value:[F.value];let S=0;for(let A=0;A<H.length;A++){const P=H[A],L=b(P);typeof P=="number"||typeof P=="boolean"?(F.__data[0]=P,r.bufferSubData(r.UNIFORM_BUFFER,$+S,F.__data)):P.isMatrix3?(F.__data[0]=P.elements[0],F.__data[1]=P.elements[1],F.__data[2]=P.elements[2],F.__data[3]=0,F.__data[4]=P.elements[3],F.__data[5]=P.elements[4],F.__data[6]=P.elements[5],F.__data[7]=0,F.__data[8]=P.elements[6],F.__data[9]=P.elements[7],F.__data[10]=P.elements[8],F.__data[11]=0):(P.toArray(F.__data,S),S+=L.storage/Float32Array.BYTES_PER_ELEMENT)}r.bufferSubData(r.UNIFORM_BUFFER,$,F.__data)}}}r.bindBuffer(r.UNIFORM_BUFFER,null)}function m(v,w,_,M){const E=v.value,C=w+"_"+_;if(M[C]===void 0)return typeof E=="number"||typeof E=="boolean"?M[C]=E:M[C]=E.clone(),!0;{const I=M[C];if(typeof E=="number"||typeof E=="boolean"){if(I!==E)return M[C]=E,!0}else if(I.equals(E)===!1)return I.copy(E),!0}return!1}function p(v){const w=v.uniforms;let _=0;const M=16;for(let C=0,I=w.length;C<I;C++){const x=Array.isArray(w[C])?w[C]:[w[C]];for(let T=0,F=x.length;T<F;T++){const $=x[T],H=Array.isArray($.value)?$.value:[$.value];for(let S=0,A=H.length;S<A;S++){const P=H[S],L=b(P),B=_%M;B!==0&&M-B<L.boundary&&(_+=M-B),$.__data=new Float32Array(L.storage/Float32Array.BYTES_PER_ELEMENT),$.__offset=_,_+=L.storage}}}const E=_%M;return E>0&&(_+=M-E),v.__size=_,v.__cache={},this}function b(v){const w={boundary:0,storage:0};return typeof v=="number"||typeof v=="boolean"?(w.boundary=4,w.storage=4):v.isVector2?(w.boundary=8,w.storage=8):v.isVector3||v.isColor?(w.boundary=16,w.storage=12):v.isVector4?(w.boundary=16,w.storage=16):v.isMatrix3?(w.boundary=48,w.storage=48):v.isMatrix4?(w.boundary=64,w.storage=64):v.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",v),w}function g(v){const w=v.target;w.removeEventListener("dispose",g);const _=o.indexOf(w.__bindingPointIndex);o.splice(_,1),r.deleteBuffer(i[w.id]),delete i[w.id],delete s[w.id]}function y(){for(const v in i)r.deleteBuffer(i[v]);o=[],i={},s={}}return{bind:c,update:l,dispose:y}}class HE{constructor(e={}){const{canvas:t=NL(),context:n=null,depth:i=!0,stencil:s=!0,alpha:o=!1,antialias:a=!1,premultipliedAlpha:c=!0,preserveDrawingBuffer:l=!1,powerPreference:u="default",failIfMajorPerformanceCaveat:h=!1}=e;this.isWebGLRenderer=!0;let d;n!==null?d=n.getContextAttributes().alpha:d=o;const m=new Uint32Array(4),p=new Int32Array(4);let b=null,g=null;const y=[],v=[];this.domElement=t,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=bn,this._useLegacyLights=!1,this.toneMapping=vo,this.toneMappingExposure=1;const w=this;let _=!1,M=0,E=0,C=null,I=-1,x=null;const T=new mt,F=new mt;let $=null;const H=new ye(0);let S=0,A=t.width,P=t.height,L=1,B=null,D=null;const V=new mt(0,0,A,P),z=new mt(0,0,A,P);let q=!1;const G=new tp;let Y=!1,j=!1,X=null;const ne=new $e,oe=new se,he=new k,ce={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function fe(){return C===null?L:1}let W=n;function ue(U,Z){for(let ee=0;ee<U.length;ee++){const te=U[ee],Q=t.getContext(te,Z);if(Q!==null)return Q}return null}try{const U={alpha:!0,depth:i,stencil:s,antialias:a,premultipliedAlpha:c,preserveDrawingBuffer:l,powerPreference:u,failIfMajorPerformanceCaveat:h};if("setAttribute"in t&&t.setAttribute("data-engine",`three.js r${e0}`),t.addEventListener("webglcontextlost",ve,!1),t.addEventListener("webglcontextrestored",K,!1),t.addEventListener("webglcontextcreationerror",Me,!1),W===null){const Z=["webgl2","webgl","experimental-webgl"];if(w.isWebGL1Renderer===!0&&Z.shift(),W=ue(Z,U),W===null)throw ue(Z)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}typeof WebGLRenderingContext<"u"&&W instanceof WebGLRenderingContext&&console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),W.getShaderPrecisionFormat===void 0&&(W.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(U){throw console.error("THREE.WebGLRenderer: "+U.message),U}let re,le,ie,Oe,Te,O,R,J,ge,pe,de,Le,Ee,Pe,ze,je,me,_t,ct,Xe,ke,Re,nt,Tt;function Zt(){re=new E8(W),le=new b8(W,re,e),re.init(le),Re=new KL(W,re,le),ie=new sH(W,re,le),Oe=new T8(W),Te=new KV,O=new oH(W,re,ie,Te,le,Re,Oe),R=new v8(w),J=new S8(w),ge=new OF(W,le),nt=new g8(W,re,ge,le),pe=new M8(W,ge,Oe,nt),de=new R8(W,pe,ge,Oe),ct=new P8(W,le,O),je=new w8(Te),Le=new qV(w,R,J,re,le,nt,je),Ee=new lH(w,Te),Pe=new YV,ze=new tH(re,le),_t=new m8(w,R,J,ie,de,d,c),me=new iH(w,de,le),Tt=new uH(W,Oe,le,ie),Xe=new y8(W,re,Oe,le),ke=new A8(W,re,Oe,le),Oe.programs=Le.programs,w.capabilities=le,w.extensions=re,w.properties=Te,w.renderLists=Pe,w.shadowMap=me,w.state=ie,w.info=Oe}Zt();const st=new cH(w,W);this.xr=st,this.getContext=function(){return W},this.getContextAttributes=function(){return W.getContextAttributes()},this.forceContextLoss=function(){const U=re.get("WEBGL_lose_context");U&&U.loseContext()},this.forceContextRestore=function(){const U=re.get("WEBGL_lose_context");U&&U.restoreContext()},this.getPixelRatio=function(){return L},this.setPixelRatio=function(U){U!==void 0&&(L=U,this.setSize(A,P,!1))},this.getSize=function(U){return U.set(A,P)},this.setSize=function(U,Z,ee=!0){if(st.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}A=U,P=Z,t.width=Math.floor(U*L),t.height=Math.floor(Z*L),ee===!0&&(t.style.width=U+"px",t.style.height=Z+"px"),this.setViewport(0,0,U,Z)},this.getDrawingBufferSize=function(U){return U.set(A*L,P*L).floor()},this.setDrawingBufferSize=function(U,Z,ee){A=U,P=Z,L=ee,t.width=Math.floor(U*ee),t.height=Math.floor(Z*ee),this.setViewport(0,0,U,Z)},this.getCurrentViewport=function(U){return U.copy(T)},this.getViewport=function(U){return U.copy(V)},this.setViewport=function(U,Z,ee,te){U.isVector4?V.set(U.x,U.y,U.z,U.w):V.set(U,Z,ee,te),ie.viewport(T.copy(V).multiplyScalar(L).floor())},this.getScissor=function(U){return U.copy(z)},this.setScissor=function(U,Z,ee,te){U.isVector4?z.set(U.x,U.y,U.z,U.w):z.set(U,Z,ee,te),ie.scissor(F.copy(z).multiplyScalar(L).floor())},this.getScissorTest=function(){return q},this.setScissorTest=function(U){ie.setScissorTest(q=U)},this.setOpaqueSort=function(U){B=U},this.setTransparentSort=function(U){D=U},this.getClearColor=function(U){return U.copy(_t.getClearColor())},this.setClearColor=function(){_t.setClearColor.apply(_t,arguments)},this.getClearAlpha=function(){return _t.getClearAlpha()},this.setClearAlpha=function(){_t.setClearAlpha.apply(_t,arguments)},this.clear=function(U=!0,Z=!0,ee=!0){let te=0;if(U){let Q=!1;if(C!==null){const Ie=C.texture.format;Q=Ie===IE||Ie===CE||Ie===TE}if(Q){const Ie=C.texture.type,Ne=Ie===_o||Ie===io||Ie===n0||Ie===ya||Ie===ME||Ie===AE,Ge=_t.getClearColor(),Ke=_t.getClearAlpha(),it=Ge.r,Je=Ge.g,Qe=Ge.b;Ne?(m[0]=it,m[1]=Je,m[2]=Qe,m[3]=Ke,W.clearBufferuiv(W.COLOR,0,m)):(p[0]=it,p[1]=Je,p[2]=Qe,p[3]=Ke,W.clearBufferiv(W.COLOR,0,p))}else te|=W.COLOR_BUFFER_BIT}Z&&(te|=W.DEPTH_BUFFER_BIT),ee&&(te|=W.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),W.clear(te)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",ve,!1),t.removeEventListener("webglcontextrestored",K,!1),t.removeEventListener("webglcontextcreationerror",Me,!1),Pe.dispose(),ze.dispose(),Te.dispose(),R.dispose(),J.dispose(),de.dispose(),nt.dispose(),Tt.dispose(),Le.dispose(),st.dispose(),st.removeEventListener("sessionstart",_r),st.removeEventListener("sessionend",Bt),X&&(X.dispose(),X=null),xr.stop()};function ve(U){U.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),_=!0}function K(){console.log("THREE.WebGLRenderer: Context Restored."),_=!1;const U=Oe.autoReset,Z=me.enabled,ee=me.autoUpdate,te=me.needsUpdate,Q=me.type;Zt(),Oe.autoReset=U,me.enabled=Z,me.autoUpdate=ee,me.needsUpdate=te,me.type=Q}function Me(U){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",U.statusMessage)}function Ae(U){const Z=U.target;Z.removeEventListener("dispose",Ae),qe(Z)}function qe(U){Ve(U),Te.remove(U)}function Ve(U){const Z=Te.get(U).programs;Z!==void 0&&(Z.forEach(function(ee){Le.releaseProgram(ee)}),U.isShaderMaterial&&Le.releaseShaderCache(U))}this.renderBufferDirect=function(U,Z,ee,te,Q,Ie){Z===null&&(Z=ce);const Ne=Q.isMesh&&Q.matrixWorld.determinant()<0,Ge=t5(U,Z,ee,te,Q);ie.setMaterial(te,Ne);let Ke=ee.index,it=1;if(te.wireframe===!0){if(Ke=pe.getWireframeAttribute(ee),Ke===void 0)return;it=2}const Je=ee.drawRange,Qe=ee.attributes.position;let on=Je.start*it,qr=(Je.start+Je.count)*it;Ie!==null&&(on=Math.max(on,Ie.start*it),qr=Math.min(qr,(Ie.start+Ie.count)*it)),Ke!==null?(on=Math.max(on,0),qr=Math.min(qr,Ke.count)):Qe!=null&&(on=Math.max(on,0),qr=Math.min(qr,Qe.count));const En=qr-on;if(En<0||En===1/0)return;nt.setup(Q,te,Ge,ee,Ke);let Os,qt=Xe;if(Ke!==null&&(Os=ge.get(Ke),qt=ke,qt.setIndex(Os)),Q.isMesh)te.wireframe===!0?(ie.setLineWidth(te.wireframeLinewidth*fe()),qt.setMode(W.LINES)):qt.setMode(W.TRIANGLES);else if(Q.isLine){let ot=te.linewidth;ot===void 0&&(ot=1),ie.setLineWidth(ot*fe()),Q.isLineSegments?qt.setMode(W.LINES):Q.isLineLoop?qt.setMode(W.LINE_LOOP):qt.setMode(W.LINE_STRIP)}else Q.isPoints?qt.setMode(W.POINTS):Q.isSprite&&qt.setMode(W.TRIANGLES);if(Q.isBatchedMesh)qt.renderMultiDraw(Q._multiDrawStarts,Q._multiDrawCounts,Q._multiDrawCount);else if(Q.isInstancedMesh)qt.renderInstances(on,En,Q.count);else if(ee.isInstancedBufferGeometry){const ot=ee._maxInstanceCount!==void 0?ee._maxInstanceCount:1/0,ab=Math.min(ee.instanceCount,ot);qt.renderInstances(on,En,ab)}else qt.render(on,En)};function Ut(U,Z,ee){U.transparent===!0&&U.side===qi&&U.forceSinglePass===!1?(U.side=yr,U.needsUpdate=!0,Ep(U,Z,ee),U.side=Mo,U.needsUpdate=!0,Ep(U,Z,ee),U.side=qi):Ep(U,Z,ee)}this.compile=function(U,Z,ee=null){ee===null&&(ee=U),g=ze.get(ee),g.init(),v.push(g),ee.traverseVisible(function(Q){Q.isLight&&Q.layers.test(Z.layers)&&(g.pushLight(Q),Q.castShadow&&g.pushShadow(Q))}),U!==ee&&U.traverseVisible(function(Q){Q.isLight&&Q.layers.test(Z.layers)&&(g.pushLight(Q),Q.castShadow&&g.pushShadow(Q))}),g.setupLights(w._useLegacyLights);const te=new Set;return U.traverse(function(Q){const Ie=Q.material;if(Ie)if(Array.isArray(Ie))for(let Ne=0;Ne<Ie.length;Ne++){const Ge=Ie[Ne];Ut(Ge,ee,Q),te.add(Ge)}else Ut(Ie,ee,Q),te.add(Ie)}),v.pop(),g=null,te},this.compileAsync=function(U,Z,ee=null){const te=this.compile(U,Z,ee);return new Promise(Q=>{function Ie(){if(te.forEach(function(Ne){Te.get(Ne).currentProgram.isReady()&&te.delete(Ne)}),te.size===0){Q(U);return}setTimeout(Ie,10)}re.get("KHR_parallel_shader_compile")!==null?Ie():setTimeout(Ie,10)})};let kt=null;function Sn(U){kt&&kt(U)}function _r(){xr.stop()}function Bt(){xr.start()}const xr=new zL;xr.setAnimationLoop(Sn),typeof self<"u"&&xr.setContext(self),this.setAnimationLoop=function(U){kt=U,st.setAnimationLoop(U),U===null?xr.stop():xr.start()},st.addEventListener("sessionstart",_r),st.addEventListener("sessionend",Bt),this.render=function(U,Z){if(Z!==void 0&&Z.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(_===!0)return;U.matrixWorldAutoUpdate===!0&&U.updateMatrixWorld(),Z.parent===null&&Z.matrixWorldAutoUpdate===!0&&Z.updateMatrixWorld(),st.enabled===!0&&st.isPresenting===!0&&(st.cameraAutoUpdate===!0&&st.updateCamera(Z),Z=st.getCamera()),U.isScene===!0&&U.onBeforeRender(w,U,Z,C),g=ze.get(U,v.length),g.init(),v.push(g),ne.multiplyMatrices(Z.projectionMatrix,Z.matrixWorldInverse),G.setFromProjectionMatrix(ne),j=this.localClippingEnabled,Y=je.init(this.clippingPlanes,j),b=Pe.get(U,y.length),b.init(),y.push(b),os(U,Z,0,w.sortObjects),b.finish(),w.sortObjects===!0&&b.sort(B,D),this.info.render.frame++,Y===!0&&je.beginShadows();const ee=g.state.shadowsArray;if(me.render(ee,U,Z),Y===!0&&je.endShadows(),this.info.autoReset===!0&&this.info.reset(),_t.render(b,U),g.setupLights(w._useLegacyLights),Z.isArrayCamera){const te=Z.cameras;for(let Q=0,Ie=te.length;Q<Ie;Q++){const Ne=te[Q];uA(b,U,Ne,Ne.viewport)}}else uA(b,U,Z);C!==null&&(O.updateMultisampleRenderTarget(C),O.updateRenderTargetMipmap(C)),U.isScene===!0&&U.onAfterRender(w,U,Z),nt.resetDefaultState(),I=-1,x=null,v.pop(),v.length>0?g=v[v.length-1]:g=null,y.pop(),y.length>0?b=y[y.length-1]:b=null};function os(U,Z,ee,te){if(U.visible===!1)return;if(U.layers.test(Z.layers)){if(U.isGroup)ee=U.renderOrder;else if(U.isLOD)U.autoUpdate===!0&&U.update(Z);else if(U.isLight)g.pushLight(U),U.castShadow&&g.pushShadow(U);else if(U.isSprite){if(!U.frustumCulled||G.intersectsSprite(U)){te&&he.setFromMatrixPosition(U.matrixWorld).applyMatrix4(ne);const Ne=de.update(U),Ge=U.material;Ge.visible&&b.push(U,Ne,Ge,ee,he.z,null)}}else if((U.isMesh||U.isLine||U.isPoints)&&(!U.frustumCulled||G.intersectsObject(U))){const Ne=de.update(U),Ge=U.material;if(te&&(U.boundingSphere!==void 0?(U.boundingSphere===null&&U.computeBoundingSphere(),he.copy(U.boundingSphere.center)):(Ne.boundingSphere===null&&Ne.computeBoundingSphere(),he.copy(Ne.boundingSphere.center)),he.applyMatrix4(U.matrixWorld).applyMatrix4(ne)),Array.isArray(Ge)){const Ke=Ne.groups;for(let it=0,Je=Ke.length;it<Je;it++){const Qe=Ke[it],on=Ge[Qe.materialIndex];on&&on.visible&&b.push(U,Ne,on,ee,he.z,Qe)}}else Ge.visible&&b.push(U,Ne,Ge,ee,he.z,null)}}const Ie=U.children;for(let Ne=0,Ge=Ie.length;Ne<Ge;Ne++)os(Ie[Ne],Z,ee,te)}function uA(U,Z,ee,te){const Q=U.opaque,Ie=U.transmissive,Ne=U.transparent;g.setupLightsView(ee),Y===!0&&je.setGlobalState(w.clippingPlanes,ee),Ie.length>0&&e5(Q,Ie,Z,ee),te&&ie.viewport(T.copy(te)),Q.length>0&&Sp(Q,Z,ee),Ie.length>0&&Sp(Ie,Z,ee),Ne.length>0&&Sp(Ne,Z,ee),ie.buffers.depth.setTest(!0),ie.buffers.depth.setMask(!0),ie.buffers.color.setMask(!0),ie.setPolygonOffset(!1)}function e5(U,Z,ee,te){if((ee.isScene===!0?ee.overrideMaterial:null)!==null)return;const Ie=le.isWebGL2;X===null&&(X=new ts(1,1,{generateMipmaps:!0,type:re.has("EXT_color_buffer_half_float")?ku:_o,minFilter:Sa,samples:Ie?4:0})),w.getDrawingBufferSize(oe),Ie?X.setSize(oe.x,oe.y):X.setSize(zg(oe.x),zg(oe.y));const Ne=w.getRenderTarget();w.setRenderTarget(X),w.getClearColor(H),S=w.getClearAlpha(),S<1&&w.setClearColor(16777215,.5),w.clear();const Ge=w.toneMapping;w.toneMapping=vo,Sp(U,ee,te),O.updateMultisampleRenderTarget(X),O.updateRenderTargetMipmap(X);let Ke=!1;for(let it=0,Je=Z.length;it<Je;it++){const Qe=Z[it],on=Qe.object,qr=Qe.geometry,En=Qe.material,Os=Qe.group;if(En.side===qi&&on.layers.test(te.layers)){const qt=En.side;En.side=yr,En.needsUpdate=!0,hA(on,ee,te,qr,En,Os),En.side=qt,En.needsUpdate=!0,Ke=!0}}Ke===!0&&(O.updateMultisampleRenderTarget(X),O.updateRenderTargetMipmap(X)),w.setRenderTarget(Ne),w.setClearColor(H,S),w.toneMapping=Ge}function Sp(U,Z,ee){const te=Z.isScene===!0?Z.overrideMaterial:null;for(let Q=0,Ie=U.length;Q<Ie;Q++){const Ne=U[Q],Ge=Ne.object,Ke=Ne.geometry,it=te===null?Ne.material:te,Je=Ne.group;Ge.layers.test(ee.layers)&&hA(Ge,Z,ee,Ke,it,Je)}}function hA(U,Z,ee,te,Q,Ie){U.onBeforeRender(w,Z,ee,te,Q,Ie),U.modelViewMatrix.multiplyMatrices(ee.matrixWorldInverse,U.matrixWorld),U.normalMatrix.getNormalMatrix(U.modelViewMatrix),Q.onBeforeRender(w,Z,ee,te,U,Ie),Q.transparent===!0&&Q.side===qi&&Q.forceSinglePass===!1?(Q.side=yr,Q.needsUpdate=!0,w.renderBufferDirect(ee,Z,te,Q,U,Ie),Q.side=Mo,Q.needsUpdate=!0,w.renderBufferDirect(ee,Z,te,Q,U,Ie),Q.side=qi):w.renderBufferDirect(ee,Z,te,Q,U,Ie),U.onAfterRender(w,Z,ee,te,Q,Ie)}function Ep(U,Z,ee){Z.isScene!==!0&&(Z=ce);const te=Te.get(U),Q=g.state.lights,Ie=g.state.shadowsArray,Ne=Q.state.version,Ge=Le.getParameters(U,Q.state,Ie,Z,ee),Ke=Le.getProgramCacheKey(Ge);let it=te.programs;te.environment=U.isMeshStandardMaterial?Z.environment:null,te.fog=Z.fog,te.envMap=(U.isMeshStandardMaterial?J:R).get(U.envMap||te.environment),it===void 0&&(U.addEventListener("dispose",Ae),it=new Map,te.programs=it);let Je=it.get(Ke);if(Je!==void 0){if(te.currentProgram===Je&&te.lightsStateVersion===Ne)return fA(U,Ge),Je}else Ge.uniforms=Le.getUniforms(U),U.onBuild(ee,Ge,w),U.onBeforeCompile(Ge,w),Je=Le.acquireProgram(Ge,Ke),it.set(Ke,Je),te.uniforms=Ge.uniforms;const Qe=te.uniforms;return(!U.isShaderMaterial&&!U.isRawShaderMaterial||U.clipping===!0)&&(Qe.clippingPlanes=je.uniform),fA(U,Ge),te.needsLights=r5(U),te.lightsStateVersion=Ne,te.needsLights&&(Qe.ambientLightColor.value=Q.state.ambient,Qe.lightProbe.value=Q.state.probe,Qe.directionalLights.value=Q.state.directional,Qe.directionalLightShadows.value=Q.state.directionalShadow,Qe.spotLights.value=Q.state.spot,Qe.spotLightShadows.value=Q.state.spotShadow,Qe.rectAreaLights.value=Q.state.rectArea,Qe.ltc_1.value=Q.state.rectAreaLTC1,Qe.ltc_2.value=Q.state.rectAreaLTC2,Qe.pointLights.value=Q.state.point,Qe.pointLightShadows.value=Q.state.pointShadow,Qe.hemisphereLights.value=Q.state.hemi,Qe.directionalShadowMap.value=Q.state.directionalShadowMap,Qe.directionalShadowMatrix.value=Q.state.directionalShadowMatrix,Qe.spotShadowMap.value=Q.state.spotShadowMap,Qe.spotLightMatrix.value=Q.state.spotLightMatrix,Qe.spotLightMap.value=Q.state.spotLightMap,Qe.pointShadowMap.value=Q.state.pointShadowMap,Qe.pointShadowMatrix.value=Q.state.pointShadowMatrix),te.currentProgram=Je,te.uniformsList=null,Je}function dA(U){if(U.uniformsList===null){const Z=U.currentProgram.getUniforms();U.uniformsList=fg.seqWithValue(Z.seq,U.uniforms)}return U.uniformsList}function fA(U,Z){const ee=Te.get(U);ee.outputColorSpace=Z.outputColorSpace,ee.batching=Z.batching,ee.instancing=Z.instancing,ee.instancingColor=Z.instancingColor,ee.skinning=Z.skinning,ee.morphTargets=Z.morphTargets,ee.morphNormals=Z.morphNormals,ee.morphColors=Z.morphColors,ee.morphTargetsCount=Z.morphTargetsCount,ee.numClippingPlanes=Z.numClippingPlanes,ee.numIntersection=Z.numClipIntersection,ee.vertexAlphas=Z.vertexAlphas,ee.vertexTangents=Z.vertexTangents,ee.toneMapping=Z.toneMapping}function t5(U,Z,ee,te,Q){Z.isScene!==!0&&(Z=ce),O.resetTextureUnits();const Ie=Z.fog,Ne=te.isMeshStandardMaterial?Z.environment:null,Ge=C===null?w.outputColorSpace:C.isXRRenderTarget===!0?C.texture.colorSpace:Ts,Ke=(te.isMeshStandardMaterial?J:R).get(te.envMap||Ne),it=te.vertexColors===!0&&!!ee.attributes.color&&ee.attributes.color.itemSize===4,Je=!!ee.attributes.tangent&&(!!te.normalMap||te.anisotropy>0),Qe=!!ee.morphAttributes.position,on=!!ee.morphAttributes.normal,qr=!!ee.morphAttributes.color;let En=vo;te.toneMapped&&(C===null||C.isXRRenderTarget===!0)&&(En=w.toneMapping);const Os=ee.morphAttributes.position||ee.morphAttributes.normal||ee.morphAttributes.color,qt=Os!==void 0?Os.length:0,ot=Te.get(te),ab=g.state.lights;if(Y===!0&&(j===!0||U!==x)){const ci=U===x&&te.id===I;je.setState(te,U,ci)}let Jt=!1;te.version===ot.__version?(ot.needsLights&&ot.lightsStateVersion!==ab.state.version||ot.outputColorSpace!==Ge||Q.isBatchedMesh&&ot.batching===!1||!Q.isBatchedMesh&&ot.batching===!0||Q.isInstancedMesh&&ot.instancing===!1||!Q.isInstancedMesh&&ot.instancing===!0||Q.isSkinnedMesh&&ot.skinning===!1||!Q.isSkinnedMesh&&ot.skinning===!0||Q.isInstancedMesh&&ot.instancingColor===!0&&Q.instanceColor===null||Q.isInstancedMesh&&ot.instancingColor===!1&&Q.instanceColor!==null||ot.envMap!==Ke||te.fog===!0&&ot.fog!==Ie||ot.numClippingPlanes!==void 0&&(ot.numClippingPlanes!==je.numPlanes||ot.numIntersection!==je.numIntersection)||ot.vertexAlphas!==it||ot.vertexTangents!==Je||ot.morphTargets!==Qe||ot.morphNormals!==on||ot.morphColors!==qr||ot.toneMapping!==En||le.isWebGL2===!0&&ot.morphTargetsCount!==qt)&&(Jt=!0):(Jt=!0,ot.__version=te.version);let Oa=ot.currentProgram;Jt===!0&&(Oa=Ep(te,Z,Q));let pA=!1,Nh=!1,cb=!1;const Wn=Oa.getUniforms(),Ua=ot.uniforms;if(ie.useProgram(Oa.program)&&(pA=!0,Nh=!0,cb=!0),te.id!==I&&(I=te.id,Nh=!0),pA||x!==U){Wn.setValue(W,"projectionMatrix",U.projectionMatrix),Wn.setValue(W,"viewMatrix",U.matrixWorldInverse);const ci=Wn.map.cameraPosition;ci!==void 0&&ci.setValue(W,he.setFromMatrixPosition(U.matrixWorld)),le.logarithmicDepthBuffer&&Wn.setValue(W,"logDepthBufFC",2/(Math.log(U.far+1)/Math.LN2)),(te.isMeshPhongMaterial||te.isMeshToonMaterial||te.isMeshLambertMaterial||te.isMeshBasicMaterial||te.isMeshStandardMaterial||te.isShaderMaterial)&&Wn.setValue(W,"isOrthographic",U.isOrthographicCamera===!0),x!==U&&(x=U,Nh=!0,cb=!0)}if(Q.isSkinnedMesh){Wn.setOptional(W,Q,"bindMatrix"),Wn.setOptional(W,Q,"bindMatrixInverse");const ci=Q.skeleton;ci&&(le.floatVertexTextures?(ci.boneTexture===null&&ci.computeBoneTexture(),Wn.setValue(W,"boneTexture",ci.boneTexture,O)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}Q.isBatchedMesh&&(Wn.setOptional(W,Q,"batchingTexture"),Wn.setValue(W,"batchingTexture",Q._matricesTexture,O));const lb=ee.morphAttributes;if((lb.position!==void 0||lb.normal!==void 0||lb.color!==void 0&&le.isWebGL2===!0)&&ct.update(Q,ee,Oa),(Nh||ot.receiveShadow!==Q.receiveShadow)&&(ot.receiveShadow=Q.receiveShadow,Wn.setValue(W,"receiveShadow",Q.receiveShadow)),te.isMeshGouraudMaterial&&te.envMap!==null&&(Ua.envMap.value=Ke,Ua.flipEnvMap.value=Ke.isCubeTexture&&Ke.isRenderTargetTexture===!1?-1:1),Nh&&(Wn.setValue(W,"toneMappingExposure",w.toneMappingExposure),ot.needsLights&&n5(Ua,cb),Ie&&te.fog===!0&&Ee.refreshFogUniforms(Ua,Ie),Ee.refreshMaterialUniforms(Ua,te,L,P,X),fg.upload(W,dA(ot),Ua,O)),te.isShaderMaterial&&te.uniformsNeedUpdate===!0&&(fg.upload(W,dA(ot),Ua,O),te.uniformsNeedUpdate=!1),te.isSpriteMaterial&&Wn.setValue(W,"center",Q.center),Wn.setValue(W,"modelViewMatrix",Q.modelViewMatrix),Wn.setValue(W,"normalMatrix",Q.normalMatrix),Wn.setValue(W,"modelMatrix",Q.matrixWorld),te.isShaderMaterial||te.isRawShaderMaterial){const ci=te.uniformsGroups;for(let ub=0,i5=ci.length;ub<i5;ub++)if(le.isWebGL2){const mA=ci[ub];Tt.update(mA,Oa),Tt.bind(mA,Oa)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return Oa}function n5(U,Z){U.ambientLightColor.needsUpdate=Z,U.lightProbe.needsUpdate=Z,U.directionalLights.needsUpdate=Z,U.directionalLightShadows.needsUpdate=Z,U.pointLights.needsUpdate=Z,U.pointLightShadows.needsUpdate=Z,U.spotLights.needsUpdate=Z,U.spotLightShadows.needsUpdate=Z,U.rectAreaLights.needsUpdate=Z,U.hemisphereLights.needsUpdate=Z}function r5(U){return U.isMeshLambertMaterial||U.isMeshToonMaterial||U.isMeshPhongMaterial||U.isMeshStandardMaterial||U.isShadowMaterial||U.isShaderMaterial&&U.lights===!0}this.getActiveCubeFace=function(){return M},this.getActiveMipmapLevel=function(){return E},this.getRenderTarget=function(){return C},this.setRenderTargetTextures=function(U,Z,ee){Te.get(U.texture).__webglTexture=Z,Te.get(U.depthTexture).__webglTexture=ee;const te=Te.get(U);te.__hasExternalTextures=!0,te.__hasExternalTextures&&(te.__autoAllocateDepthBuffer=ee===void 0,te.__autoAllocateDepthBuffer||re.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),te.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(U,Z){const ee=Te.get(U);ee.__webglFramebuffer=Z,ee.__useDefaultFramebuffer=Z===void 0},this.setRenderTarget=function(U,Z=0,ee=0){C=U,M=Z,E=ee;let te=!0,Q=null,Ie=!1,Ne=!1;if(U){const Ke=Te.get(U);Ke.__useDefaultFramebuffer!==void 0?(ie.bindFramebuffer(W.FRAMEBUFFER,null),te=!1):Ke.__webglFramebuffer===void 0?O.setupRenderTarget(U):Ke.__hasExternalTextures&&O.rebindTextures(U,Te.get(U.texture).__webglTexture,Te.get(U.depthTexture).__webglTexture);const it=U.texture;(it.isData3DTexture||it.isDataArrayTexture||it.isCompressedArrayTexture)&&(Ne=!0);const Je=Te.get(U).__webglFramebuffer;U.isWebGLCubeRenderTarget?(Array.isArray(Je[Z])?Q=Je[Z][ee]:Q=Je[Z],Ie=!0):le.isWebGL2&&U.samples>0&&O.useMultisampledRTT(U)===!1?Q=Te.get(U).__webglMultisampledFramebuffer:Array.isArray(Je)?Q=Je[ee]:Q=Je,T.copy(U.viewport),F.copy(U.scissor),$=U.scissorTest}else T.copy(V).multiplyScalar(L).floor(),F.copy(z).multiplyScalar(L).floor(),$=q;if(ie.bindFramebuffer(W.FRAMEBUFFER,Q)&&le.drawBuffers&&te&&ie.drawBuffers(U,Q),ie.viewport(T),ie.scissor(F),ie.setScissorTest($),Ie){const Ke=Te.get(U.texture);W.framebufferTexture2D(W.FRAMEBUFFER,W.COLOR_ATTACHMENT0,W.TEXTURE_CUBE_MAP_POSITIVE_X+Z,Ke.__webglTexture,ee)}else if(Ne){const Ke=Te.get(U.texture),it=Z||0;W.framebufferTextureLayer(W.FRAMEBUFFER,W.COLOR_ATTACHMENT0,Ke.__webglTexture,ee||0,it)}I=-1},this.readRenderTargetPixels=function(U,Z,ee,te,Q,Ie,Ne){if(!(U&&U.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Ge=Te.get(U).__webglFramebuffer;if(U.isWebGLCubeRenderTarget&&Ne!==void 0&&(Ge=Ge[Ne]),Ge){ie.bindFramebuffer(W.FRAMEBUFFER,Ge);try{const Ke=U.texture,it=Ke.format,Je=Ke.type;if(it!==kr&&Re.convert(it)!==W.getParameter(W.IMPLEMENTATION_COLOR_READ_FORMAT)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const Qe=Je===ku&&(re.has("EXT_color_buffer_half_float")||le.isWebGL2&&re.has("EXT_color_buffer_float"));if(Je!==_o&&Re.convert(Je)!==W.getParameter(W.IMPLEMENTATION_COLOR_READ_TYPE)&&!(Je===Ki&&(le.isWebGL2||re.has("OES_texture_float")||re.has("WEBGL_color_buffer_float")))&&!Qe){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}Z>=0&&Z<=U.width-te&&ee>=0&&ee<=U.height-Q&&W.readPixels(Z,ee,te,Q,Re.convert(it),Re.convert(Je),Ie)}finally{const Ke=C!==null?Te.get(C).__webglFramebuffer:null;ie.bindFramebuffer(W.FRAMEBUFFER,Ke)}}},this.copyFramebufferToTexture=function(U,Z,ee=0){const te=Math.pow(2,-ee),Q=Math.floor(Z.image.width*te),Ie=Math.floor(Z.image.height*te);O.setTexture2D(Z,0),W.copyTexSubImage2D(W.TEXTURE_2D,ee,0,0,U.x,U.y,Q,Ie),ie.unbindTexture()},this.copyTextureToTexture=function(U,Z,ee,te=0){const Q=Z.image.width,Ie=Z.image.height,Ne=Re.convert(ee.format),Ge=Re.convert(ee.type);O.setTexture2D(ee,0),W.pixelStorei(W.UNPACK_FLIP_Y_WEBGL,ee.flipY),W.pixelStorei(W.UNPACK_PREMULTIPLY_ALPHA_WEBGL,ee.premultiplyAlpha),W.pixelStorei(W.UNPACK_ALIGNMENT,ee.unpackAlignment),Z.isDataTexture?W.texSubImage2D(W.TEXTURE_2D,te,U.x,U.y,Q,Ie,Ne,Ge,Z.image.data):Z.isCompressedTexture?W.compressedTexSubImage2D(W.TEXTURE_2D,te,U.x,U.y,Z.mipmaps[0].width,Z.mipmaps[0].height,Ne,Z.mipmaps[0].data):W.texSubImage2D(W.TEXTURE_2D,te,U.x,U.y,Ne,Ge,Z.image),te===0&&ee.generateMipmaps&&W.generateMipmap(W.TEXTURE_2D),ie.unbindTexture()},this.copyTextureToTexture3D=function(U,Z,ee,te,Q=0){if(w.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const Ie=U.max.x-U.min.x+1,Ne=U.max.y-U.min.y+1,Ge=U.max.z-U.min.z+1,Ke=Re.convert(te.format),it=Re.convert(te.type);let Je;if(te.isData3DTexture)O.setTexture3D(te,0),Je=W.TEXTURE_3D;else if(te.isDataArrayTexture||te.isCompressedArrayTexture)O.setTexture2DArray(te,0),Je=W.TEXTURE_2D_ARRAY;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}W.pixelStorei(W.UNPACK_FLIP_Y_WEBGL,te.flipY),W.pixelStorei(W.UNPACK_PREMULTIPLY_ALPHA_WEBGL,te.premultiplyAlpha),W.pixelStorei(W.UNPACK_ALIGNMENT,te.unpackAlignment);const Qe=W.getParameter(W.UNPACK_ROW_LENGTH),on=W.getParameter(W.UNPACK_IMAGE_HEIGHT),qr=W.getParameter(W.UNPACK_SKIP_PIXELS),En=W.getParameter(W.UNPACK_SKIP_ROWS),Os=W.getParameter(W.UNPACK_SKIP_IMAGES),qt=ee.isCompressedTexture?ee.mipmaps[Q]:ee.image;W.pixelStorei(W.UNPACK_ROW_LENGTH,qt.width),W.pixelStorei(W.UNPACK_IMAGE_HEIGHT,qt.height),W.pixelStorei(W.UNPACK_SKIP_PIXELS,U.min.x),W.pixelStorei(W.UNPACK_SKIP_ROWS,U.min.y),W.pixelStorei(W.UNPACK_SKIP_IMAGES,U.min.z),ee.isDataTexture||ee.isData3DTexture?W.texSubImage3D(Je,Q,Z.x,Z.y,Z.z,Ie,Ne,Ge,Ke,it,qt.data):ee.isCompressedArrayTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),W.compressedTexSubImage3D(Je,Q,Z.x,Z.y,Z.z,Ie,Ne,Ge,Ke,qt.data)):W.texSubImage3D(Je,Q,Z.x,Z.y,Z.z,Ie,Ne,Ge,Ke,it,qt),W.pixelStorei(W.UNPACK_ROW_LENGTH,Qe),W.pixelStorei(W.UNPACK_IMAGE_HEIGHT,on),W.pixelStorei(W.UNPACK_SKIP_PIXELS,qr),W.pixelStorei(W.UNPACK_SKIP_ROWS,En),W.pixelStorei(W.UNPACK_SKIP_IMAGES,Os),Q===0&&te.generateMipmaps&&W.generateMipmap(Je),ie.unbindTexture()},this.initTexture=function(U){U.isCubeTexture?O.setTextureCube(U,0):U.isData3DTexture?O.setTexture3D(U,0):U.isDataArrayTexture||U.isCompressedArrayTexture?O.setTexture2DArray(U,0):O.setTexture2D(U,0),ie.unbindTexture()},this.resetState=function(){M=0,E=0,C=null,ie.reset(),nt.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return Xi}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e;const t=this.getContext();t.drawingBufferColorSpace=e===i0?"display-p3":"srgb",t.unpackColorSpace=Ct.workingColorSpace===jf?"display-p3":"srgb"}get outputEncoding(){return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace===bn?wa:DE}set outputEncoding(e){console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace=e===wa?bn:Ts}get useLegacyLights(){return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights}set useLegacyLights(e){console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights=e}}class YL extends HE{}YL.prototype.isWebGL1Renderer=!0;class u0{constructor(e,t=25e-5){this.isFogExp2=!0,this.name="",this.color=new ye(e),this.density=t}clone(){return new u0(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class h0{constructor(e,t=1,n=1e3){this.isFog=!0,this.name="",this.color=new ye(e),this.near=t,this.far=n}clone(){return new h0(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}class GE extends wt{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(t.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(t.object.backgroundIntensity=this.backgroundIntensity),t}}class d0{constructor(e,t){this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=Qd,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.version=0,this.uuid=ii()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}get updateRange(){return console.warn("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,n){e*=this.stride,n*=t.stride;for(let i=0,s=this.stride;i<s;i++)this.array[e+i]=t.array[n+i];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=ii()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(t,this.stride);return n.setUsage(this.usage),n}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=ii()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const Sr=new k;class Rc{constructor(e,t,n,i=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=n,this.normalized=i}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,n=this.data.count;t<n;t++)Sr.fromBufferAttribute(this,t),Sr.applyMatrix4(e),this.setXYZ(t,Sr.x,Sr.y,Sr.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)Sr.fromBufferAttribute(this,t),Sr.applyNormalMatrix(e),this.setXYZ(t,Sr.x,Sr.y,Sr.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)Sr.fromBufferAttribute(this,t),Sr.transformDirection(e),this.setXYZ(t,Sr.x,Sr.y,Sr.z);return this}setX(e,t){return this.normalized&&(t=tt(t,this.array)),this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.normalized&&(t=tt(t,this.array)),this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.normalized&&(t=tt(t,this.array)),this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.normalized&&(t=tt(t,this.array)),this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){let t=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(t=Br(t,this.array)),t}getY(e){let t=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(t=Br(t,this.array)),t}getZ(e){let t=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(t=Br(t,this.array)),t}getW(e){let t=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(t=Br(t,this.array)),t}setXY(e,t,n){return e=e*this.data.stride+this.offset,this.normalized&&(t=tt(t,this.array),n=tt(n,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=n,this}setXYZ(e,t,n,i){return e=e*this.data.stride+this.offset,this.normalized&&(t=tt(t,this.array),n=tt(n,this.array),i=tt(i,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this}setXYZW(e,t,n,i,s){return e=e*this.data.stride+this.offset,this.normalized&&(t=tt(t,this.array),n=tt(n,this.array),i=tt(i,this.array),s=tt(s,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this.data.array[e+3]=s,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)t.push(this.data.array[i+s])}return new It(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new Rc(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)t.push(this.data.array[i+s])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class WE extends wr{constructor(e){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new ye(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}let bl;const Fh=new k,wl=new k,vl=new k,_l=new se,$h=new se,ZL=new $e,Kp=new k,zh=new k,Xp=new k,tT=new se,Ob=new se,nT=new se;class JL extends wt{constructor(e=new WE){if(super(),this.isSprite=!0,this.type="Sprite",bl===void 0){bl=new Ye;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),n=new d0(t,5);bl.setIndex([0,1,2,0,2,3]),bl.setAttribute("position",new Rc(n,3,0,!1)),bl.setAttribute("uv",new Rc(n,2,3,!1))}this.geometry=bl,this.material=e,this.center=new se(.5,.5)}raycast(e,t){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),wl.setFromMatrixScale(this.matrixWorld),ZL.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),vl.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&wl.multiplyScalar(-vl.z);const n=this.material.rotation;let i,s;n!==0&&(s=Math.cos(n),i=Math.sin(n));const o=this.center;Yp(Kp.set(-.5,-.5,0),vl,o,wl,i,s),Yp(zh.set(.5,-.5,0),vl,o,wl,i,s),Yp(Xp.set(.5,.5,0),vl,o,wl,i,s),tT.set(0,0),Ob.set(1,0),nT.set(1,1);let a=e.ray.intersectTriangle(Kp,zh,Xp,!1,Fh);if(a===null&&(Yp(zh.set(-.5,.5,0),vl,o,wl,i,s),Ob.set(0,1),a=e.ray.intersectTriangle(Kp,Xp,zh,!1,Fh),a===null))return;const c=e.ray.origin.distanceTo(Fh);c<e.near||c>e.far||t.push({distance:c,point:Fh.clone(),uv:Ur.getInterpolation(Fh,Kp,zh,Xp,tT,Ob,nT,new se),face:null,object:this})}copy(e,t){return super.copy(e,t),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}function Yp(r,e,t,n,i,s){_l.subVectors(r,t).addScalar(.5).multiply(n),i!==void 0?($h.x=s*_l.x-i*_l.y,$h.y=i*_l.x+s*_l.y):$h.copy(_l),r.copy(e),r.x+=$h.x,r.y+=$h.y,r.applyMatrix4(ZL)}const Zp=new k,rT=new k;class jL extends wt{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(e){super.copy(e,!1);const t=e.levels;for(let n=0,i=t.length;n<i;n++){const s=t[n];this.addLevel(s.object.clone(),s.distance,s.hysteresis)}return this.autoUpdate=e.autoUpdate,this}addLevel(e,t=0,n=0){t=Math.abs(t);const i=this.levels;let s;for(s=0;s<i.length&&!(t<i[s].distance);s++);return i.splice(s,0,{distance:t,hysteresis:n,object:e}),this.add(e),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){const t=this.levels;if(t.length>0){let n,i;for(n=1,i=t.length;n<i;n++){let s=t[n].distance;if(t[n].object.visible&&(s-=s*t[n].hysteresis),e<s)break}return t[n-1].object}return null}raycast(e,t){if(this.levels.length>0){Zp.setFromMatrixPosition(this.matrixWorld);const i=e.ray.origin.distanceTo(Zp);this.getObjectForDistance(i).raycast(e,t)}}update(e){const t=this.levels;if(t.length>1){Zp.setFromMatrixPosition(e.matrixWorld),rT.setFromMatrixPosition(this.matrixWorld);const n=Zp.distanceTo(rT)/e.zoom;t[0].object.visible=!0;let i,s;for(i=1,s=t.length;i<s;i++){let o=t[i].distance;if(t[i].object.visible&&(o-=o*t[i].hysteresis),n>=o)t[i-1].object.visible=!1,t[i].object.visible=!0;else break}for(this._currentLevel=i-1;i<s;i++)t[i].object.visible=!1}}toJSON(e){const t=super.toJSON(e);this.autoUpdate===!1&&(t.object.autoUpdate=!1),t.object.levels=[];const n=this.levels;for(let i=0,s=n.length;i<s;i++){const o=n[i];t.object.levels.push({object:o.object.uuid,distance:o.distance,hysteresis:o.hysteresis})}return t}}const iT=new k,sT=new mt,oT=new mt,hH=new k,aT=new $e,Jp=new k,Ub=new Bn,cT=new $e,kb=new ph;class QL extends De{constructor(e,t){super(e,t),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=ux,this.bindMatrix=new $e,this.bindMatrixInverse=new $e,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const e=this.geometry;this.boundingBox===null&&(this.boundingBox=new br),this.boundingBox.makeEmpty();const t=e.getAttribute("position");for(let n=0;n<t.count;n++)this.getVertexPosition(n,Jp),this.boundingBox.expandByPoint(Jp)}computeBoundingSphere(){const e=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new Bn),this.boundingSphere.makeEmpty();const t=e.getAttribute("position");for(let n=0;n<t.count;n++)this.getVertexPosition(n,Jp),this.boundingSphere.expandByPoint(Jp)}copy(e,t){return super.copy(e,t),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}raycast(e,t){const n=this.material,i=this.matrixWorld;n!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),Ub.copy(this.boundingSphere),Ub.applyMatrix4(i),e.ray.intersectsSphere(Ub)!==!1&&(cT.copy(i).invert(),kb.copy(e.ray).applyMatrix4(cT),!(this.boundingBox!==null&&kb.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(e,t,kb)))}getVertexPosition(e,t){return super.getVertexPosition(e,t),this.applyBoneTransform(e,t),t}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new mt,t=this.geometry.attributes.skinWeight;for(let n=0,i=t.count;n<i;n++){e.fromBufferAttribute(t,n);const s=1/e.manhattanLength();s!==1/0?e.multiplyScalar(s):e.set(1,0,0,0),t.setXYZW(n,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode===ux?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===hL?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(e,t){const n=this.skeleton,i=this.geometry;sT.fromBufferAttribute(i.attributes.skinIndex,e),oT.fromBufferAttribute(i.attributes.skinWeight,e),iT.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let s=0;s<4;s++){const o=oT.getComponent(s);if(o!==0){const a=sT.getComponent(s);aT.multiplyMatrices(n.bones[a].matrixWorld,n.boneInverses[a]),t.addScaledVector(hH.copy(iT).applyMatrix4(aT),o)}}return t.applyMatrix4(this.bindMatrixInverse)}boneTransform(e,t){return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."),this.applyBoneTransform(e,t)}}class qE extends wt{constructor(){super(),this.isBone=!0,this.type="Bone"}}class Ec extends hn{constructor(e=null,t=1,n=1,i,s,o,a,c,l=ln,u=ln,h,d){super(null,o,a,c,l,u,i,s,h,d),this.isDataTexture=!0,this.image={data:e,width:t,height:n},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const lT=new $e,dH=new $e;class f0{constructor(e=[],t=[]){this.uuid=ii(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let n=0,i=this.bones.length;n<i;n++)this.boneInverses.push(new $e)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const n=new $e;this.bones[e]&&n.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(n)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&n.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&(n.parent&&n.parent.isBone?(n.matrix.copy(n.parent.matrixWorld).invert(),n.matrix.multiply(n.matrixWorld)):n.matrix.copy(n.matrixWorld),n.matrix.decompose(n.position,n.quaternion,n.scale))}}update(){const e=this.bones,t=this.boneInverses,n=this.boneMatrices,i=this.boneTexture;for(let s=0,o=e.length;s<o;s++){const a=e[s]?e[s].matrixWorld:dH;lT.multiplyMatrices(a,t[s]),lT.toArray(n,s*16)}i!==null&&(i.needsUpdate=!0)}clone(){return new f0(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(this.bones.length*4);e=Math.ceil(e/4)*4,e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const n=new Ec(t,e,e,kr,Ki);return n.needsUpdate=!0,this.boneMatrices=t,this.boneTexture=n,this}getBoneByName(e){for(let t=0,n=this.bones.length;t<n;t++){const i=this.bones[t];if(i.name===e)return i}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let n=0,i=e.bones.length;n<i;n++){const s=e.bones[n];let o=t[s];o===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",s),o=new qE),this.bones.push(o),this.boneInverses.push(new $e().fromArray(e.boneInverses[n]))}return this.init(),this}toJSON(){const e={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,n=this.boneInverses;for(let i=0,s=t.length;i<s;i++){const o=t[i];e.bones.push(o.uuid);const a=n[i];e.boneInverses.push(a.toArray())}return e}}class zu extends It{constructor(e,t,n,i=1){super(e,t,n),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=i}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const xl=new $e,uT=new $e,jp=[],hT=new br,fH=new $e,Vh=new De,Hh=new Bn;class Vg extends De{constructor(e,t,n){super(e,t),this.isInstancedMesh=!0,this.instanceMatrix=new zu(new Float32Array(n*16),16),this.instanceColor=null,this.count=n,this.boundingBox=null,this.boundingSphere=null;for(let i=0;i<n;i++)this.setMatrixAt(i,fH)}computeBoundingBox(){const e=this.geometry,t=this.count;this.boundingBox===null&&(this.boundingBox=new br),e.boundingBox===null&&e.computeBoundingBox(),this.boundingBox.makeEmpty();for(let n=0;n<t;n++)this.getMatrixAt(n,xl),hT.copy(e.boundingBox).applyMatrix4(xl),this.boundingBox.union(hT)}computeBoundingSphere(){const e=this.geometry,t=this.count;this.boundingSphere===null&&(this.boundingSphere=new Bn),e.boundingSphere===null&&e.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let n=0;n<t;n++)this.getMatrixAt(n,xl),Hh.copy(e.boundingSphere).applyMatrix4(xl),this.boundingSphere.union(Hh)}copy(e,t){return super.copy(e,t),this.instanceMatrix.copy(e.instanceMatrix),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}getColorAt(e,t){t.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,e*16)}raycast(e,t){const n=this.matrixWorld,i=this.count;if(Vh.geometry=this.geometry,Vh.material=this.material,Vh.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),Hh.copy(this.boundingSphere),Hh.applyMatrix4(n),e.ray.intersectsSphere(Hh)!==!1))for(let s=0;s<i;s++){this.getMatrixAt(s,xl),uT.multiplyMatrices(n,xl),Vh.matrixWorld=uT,Vh.raycast(e,jp);for(let o=0,a=jp.length;o<a;o++){const c=jp[o];c.instanceId=s,c.object=this,t.push(c)}jp.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new zu(new Float32Array(this.instanceMatrix.count*3),3)),t.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,e*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}function pH(r,e){return r.z-e.z}function mH(r,e){return e.z-r.z}class gH{constructor(){this.index=0,this.pool=[],this.list=[]}push(e,t){const n=this.pool,i=this.list;this.index>=n.length&&n.push({start:-1,count:-1,z:-1});const s=n[this.index];i.push(s),this.index++,s.start=e.start,s.count=e.count,s.z=t}reset(){this.list.length=0,this.index=0}}const Sl="batchId",Vo=new $e,dT=new $e,yH=new $e,fT=new $e,Bb=new tp,Qp=new br,za=new Bn,Gh=new k,Fb=new gH,Xn=new De,em=[];function bH(r,e,t=0){const n=e.itemSize;if(r.isInterleavedBufferAttribute||r.array.constructor!==e.array.constructor){const i=r.count;for(let s=0;s<i;s++)for(let o=0;o<n;o++)e.setComponent(s+t,o,r.getComponent(s,o))}else e.array.set(r.array,t*n);e.needsUpdate=!0}class e3 extends De{get maxGeometryCount(){return this._maxGeometryCount}constructor(e,t,n=t*2,i){super(new Ye,i),this.isBatchedMesh=!0,this.perObjectFrustumCulled=!0,this.sortObjects=!0,this.boundingBox=null,this.boundingSphere=null,this.customSort=null,this._drawRanges=[],this._reservedRanges=[],this._visibility=[],this._active=[],this._bounds=[],this._maxGeometryCount=e,this._maxVertexCount=t,this._maxIndexCount=n,this._geometryInitialized=!1,this._geometryCount=0,this._multiDrawCounts=new Int32Array(e),this._multiDrawStarts=new Int32Array(e),this._multiDrawCount=0,this._visibilityChanged=!0,this._matricesTexture=null,this._initMatricesTexture()}_initMatricesTexture(){let e=Math.sqrt(this._maxGeometryCount*4);e=Math.ceil(e/4)*4,e=Math.max(e,4);const t=new Float32Array(e*e*4),n=new Ec(t,e,e,kr,Ki);this._matricesTexture=n}_initializeGeometry(e){const t=this.geometry,n=this._maxVertexCount,i=this._maxGeometryCount,s=this._maxIndexCount;if(this._geometryInitialized===!1){for(const a in e.attributes){const c=e.getAttribute(a),{array:l,itemSize:u,normalized:h}=c,d=new l.constructor(n*u),m=new c.constructor(d,u,h);m.setUsage(c.usage),t.setAttribute(a,m)}if(e.getIndex()!==null){const a=n>65536?new Uint32Array(s):new Uint16Array(s);t.setIndex(new It(a,1))}const o=i>65536?new Uint32Array(n):new Uint16Array(n);t.setAttribute(Sl,new It(o,1)),this._geometryInitialized=!0}}_validateGeometry(e){if(e.getAttribute(Sl))throw new Error(`BatchedMesh: Geometry cannot use attribute "${Sl}"`);const t=this.geometry;if(!!e.getIndex()!=!!t.getIndex())throw new Error('BatchedMesh: All geometries must consistently have "index".');for(const n in t.attributes){if(n===Sl)continue;if(!e.hasAttribute(n))throw new Error(`BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);const i=e.getAttribute(n),s=t.getAttribute(n);if(i.itemSize!==s.itemSize||i.normalized!==s.normalized)throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.")}}setCustomSort(e){return this.customSort=e,this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new br);const e=this._geometryCount,t=this.boundingBox,n=this._active;t.makeEmpty();for(let i=0;i<e;i++)n[i]!==!1&&(this.getMatrixAt(i,Vo),this.getBoundingBoxAt(i,Qp).applyMatrix4(Vo),t.union(Qp))}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Bn);const e=this._geometryCount,t=this.boundingSphere,n=this._active;t.makeEmpty();for(let i=0;i<e;i++)n[i]!==!1&&(this.getMatrixAt(i,Vo),this.getBoundingSphereAt(i,za).applyMatrix4(Vo),t.union(za))}addGeometry(e,t=-1,n=-1){if(this._initializeGeometry(e),this._validateGeometry(e),this._geometryCount>=this._maxGeometryCount)throw new Error("BatchedMesh: Maximum geometry count reached.");const i={vertexStart:-1,vertexCount:-1,indexStart:-1,indexCount:-1};let s=null;const o=this._reservedRanges,a=this._drawRanges,c=this._bounds;this._geometryCount!==0&&(s=o[o.length-1]),t===-1?i.vertexCount=e.getAttribute("position").count:i.vertexCount=t,s===null?i.vertexStart=0:i.vertexStart=s.vertexStart+s.vertexCount;const l=e.getIndex(),u=l!==null;if(u&&(n===-1?i.indexCount=l.count:i.indexCount=n,s===null?i.indexStart=0:i.indexStart=s.indexStart+s.indexCount),i.indexStart!==-1&&i.indexStart+i.indexCount>this._maxIndexCount||i.vertexStart+i.vertexCount>this._maxVertexCount)throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");const h=this._visibility,d=this._active,m=this._matricesTexture,p=this._matricesTexture.image.data;h.push(!0),d.push(!0);const b=this._geometryCount;this._geometryCount++,yH.toArray(p,b*16),m.needsUpdate=!0,o.push(i),a.push({start:u?i.indexStart:i.vertexStart,count:-1}),c.push({boxInitialized:!1,box:new br,sphereInitialized:!1,sphere:new Bn});const g=this.geometry.getAttribute(Sl);for(let y=0;y<i.vertexCount;y++)g.setX(i.vertexStart+y,b);return g.needsUpdate=!0,this.setGeometryAt(b,e),b}setGeometryAt(e,t){if(e>=this._geometryCount)throw new Error("BatchedMesh: Maximum geometry count reached.");this._validateGeometry(t);const n=this.geometry,i=n.getIndex()!==null,s=n.getIndex(),o=t.getIndex(),a=this._reservedRanges[e];if(i&&o.count>a.indexCount||t.attributes.position.count>a.vertexCount)throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");const c=a.vertexStart,l=a.vertexCount;for(const m in n.attributes){if(m===Sl)continue;const p=t.getAttribute(m),b=n.getAttribute(m);bH(p,b,c);const g=p.itemSize;for(let y=p.count,v=l;y<v;y++){const w=c+y;for(let _=0;_<g;_++)b.setComponent(w,_,0)}b.needsUpdate=!0}if(i){const m=a.indexStart;for(let p=0;p<o.count;p++)s.setX(m+p,c+o.getX(p));for(let p=o.count,b=a.indexCount;p<b;p++)s.setX(m+p,c);s.needsUpdate=!0}const u=this._bounds[e];t.boundingBox!==null?(u.box.copy(t.boundingBox),u.boxInitialized=!0):u.boxInitialized=!1,t.boundingSphere!==null?(u.sphere.copy(t.boundingSphere),u.sphereInitialized=!0):u.sphereInitialized=!1;const h=this._drawRanges[e],d=t.getAttribute("position");return h.count=i?o.count:d.count,this._visibilityChanged=!0,e}deleteGeometry(e){const t=this._active;return e>=t.length||t[e]===!1?this:(t[e]=!1,this._visibilityChanged=!0,this)}getBoundingBoxAt(e,t){if(this._active[e]===!1)return this;const i=this._bounds[e],s=i.box,o=this.geometry;if(i.boxInitialized===!1){s.makeEmpty();const a=o.index,c=o.attributes.position,l=this._drawRanges[e];for(let u=l.start,h=l.start+l.count;u<h;u++){let d=u;a&&(d=a.getX(d)),s.expandByPoint(Gh.fromBufferAttribute(c,d))}i.boxInitialized=!0}return t.copy(s),t}getBoundingSphereAt(e,t){if(this._active[e]===!1)return this;const i=this._bounds[e],s=i.sphere,o=this.geometry;if(i.sphereInitialized===!1){s.makeEmpty(),this.getBoundingBoxAt(e,Qp),Qp.getCenter(s.center);const a=o.index,c=o.attributes.position,l=this._drawRanges[e];let u=0;for(let h=l.start,d=l.start+l.count;h<d;h++){let m=h;a&&(m=a.getX(m)),Gh.fromBufferAttribute(c,m),u=Math.max(u,s.center.distanceToSquared(Gh))}s.radius=Math.sqrt(u),i.sphereInitialized=!0}return t.copy(s),t}setMatrixAt(e,t){const n=this._active,i=this._matricesTexture,s=this._matricesTexture.image.data,o=this._geometryCount;return e>=o||n[e]===!1?this:(t.toArray(s,e*16),i.needsUpdate=!0,this)}getMatrixAt(e,t){const n=this._active,i=this._matricesTexture.image.data,s=this._geometryCount;return e>=s||n[e]===!1?null:t.fromArray(i,e*16)}setVisibleAt(e,t){const n=this._visibility,i=this._active,s=this._geometryCount;return e>=s||i[e]===!1||n[e]===t?this:(n[e]=t,this._visibilityChanged=!0,this)}getVisibleAt(e){const t=this._visibility,n=this._active,i=this._geometryCount;return e>=i||n[e]===!1?!1:t[e]}raycast(e,t){const n=this._visibility,i=this._active,s=this._drawRanges,o=this._geometryCount,a=this.matrixWorld,c=this.geometry;Xn.material=this.material,Xn.geometry.index=c.index,Xn.geometry.attributes=c.attributes,Xn.geometry.boundingBox===null&&(Xn.geometry.boundingBox=new br),Xn.geometry.boundingSphere===null&&(Xn.geometry.boundingSphere=new Bn);for(let l=0;l<o;l++){if(!n[l]||!i[l])continue;const u=s[l];Xn.geometry.setDrawRange(u.start,u.count),this.getMatrixAt(l,Xn.matrixWorld).premultiply(a),this.getBoundingBoxAt(l,Xn.geometry.boundingBox),this.getBoundingSphereAt(l,Xn.geometry.boundingSphere),Xn.raycast(e,em);for(let h=0,d=em.length;h<d;h++){const m=em[h];m.object=this,m.batchId=l,t.push(m)}em.length=0}Xn.material=null,Xn.geometry.index=null,Xn.geometry.attributes={},Xn.geometry.setDrawRange(0,1/0)}copy(e){return super.copy(e),this.geometry=e.geometry.clone(),this.perObjectFrustumCulled=e.perObjectFrustumCulled,this.sortObjects=e.sortObjects,this.boundingBox=e.boundingBox!==null?e.boundingBox.clone():null,this.boundingSphere=e.boundingSphere!==null?e.boundingSphere.clone():null,this._drawRanges=e._drawRanges.map(t=>({...t})),this._reservedRanges=e._reservedRanges.map(t=>({...t})),this._visibility=e._visibility.slice(),this._active=e._active.slice(),this._bounds=e._bounds.map(t=>({boxInitialized:t.boxInitialized,box:t.box.clone(),sphereInitialized:t.sphereInitialized,sphere:t.sphere.clone()})),this._maxGeometryCount=e._maxGeometryCount,this._maxVertexCount=e._maxVertexCount,this._maxIndexCount=e._maxIndexCount,this._geometryInitialized=e._geometryInitialized,this._geometryCount=e._geometryCount,this._multiDrawCounts=e._multiDrawCounts.slice(),this._multiDrawStarts=e._multiDrawStarts.slice(),this._matricesTexture=e._matricesTexture.clone(),this._matricesTexture.image.data=this._matricesTexture.image.slice(),this}dispose(){return this.geometry.dispose(),this._matricesTexture.dispose(),this._matricesTexture=null,this}onBeforeRender(e,t,n,i,s){if(!this._visibilityChanged&&!this.perObjectFrustumCulled&&!this.sortObjects)return;const o=i.getIndex(),a=o===null?1:o.array.BYTES_PER_ELEMENT,c=this._visibility,l=this._multiDrawStarts,u=this._multiDrawCounts,h=this._drawRanges,d=this.perObjectFrustumCulled;d&&(fT.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse).multiply(this.matrixWorld),Bb.setFromProjectionMatrix(fT,e.isWebGPURenderer?Bu:Xi));let m=0;if(this.sortObjects){dT.copy(this.matrixWorld).invert(),Gh.setFromMatrixPosition(n.matrixWorld).applyMatrix4(dT);for(let g=0,y=c.length;g<y;g++)if(c[g]){this.getMatrixAt(g,Vo),this.getBoundingSphereAt(g,za).applyMatrix4(Vo);let v=!1;if(d&&(v=!Bb.intersectsSphere(za)),!v){const w=Gh.distanceTo(za.center);Fb.push(h[g],w)}}const p=Fb.list,b=this.customSort;b===null?p.sort(s.transparent?mH:pH):b.call(this,p,n);for(let g=0,y=p.length;g<y;g++){const v=p[g];l[m]=v.start*a,u[m]=v.count,m++}Fb.reset()}else for(let p=0,b=c.length;p<b;p++)if(c[p]){let g=!1;if(d&&(this.getMatrixAt(p,Vo),this.getBoundingSphereAt(p,za).applyMatrix4(Vo),g=!Bb.intersectsSphere(za)),!g){const y=h[p];l[m]=y.start*a,u[m]=y.count,m++}}this._multiDrawCount=m,this._visibilityChanged=!1}onBeforeShadow(e,t,n,i,s,o){this.onBeforeRender(e,null,i,s,o)}}class vr extends wr{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new ye(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}const pT=new k,mT=new k,gT=new $e,$b=new ph,tm=new Bn;class To extends wt{constructor(e=new Ye,t=new vr){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,n=[0];for(let i=1,s=t.count;i<s;i++)pT.fromBufferAttribute(t,i-1),mT.fromBufferAttribute(t,i),n[i]=n[i-1],n[i]+=pT.distanceTo(mT);e.setAttribute("lineDistance",new Ce(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,t){const n=this.geometry,i=this.matrixWorld,s=e.params.Line.threshold,o=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),tm.copy(n.boundingSphere),tm.applyMatrix4(i),tm.radius+=s,e.ray.intersectsSphere(tm)===!1)return;gT.copy(i).invert(),$b.copy(e.ray).applyMatrix4(gT);const a=s/((this.scale.x+this.scale.y+this.scale.z)/3),c=a*a,l=new k,u=new k,h=new k,d=new k,m=this.isLineSegments?2:1,p=n.index,g=n.attributes.position;if(p!==null){const y=Math.max(0,o.start),v=Math.min(p.count,o.start+o.count);for(let w=y,_=v-1;w<_;w+=m){const M=p.getX(w),E=p.getX(w+1);if(l.fromBufferAttribute(g,M),u.fromBufferAttribute(g,E),$b.distanceSqToSegment(l,u,d,h)>c)continue;d.applyMatrix4(this.matrixWorld);const I=e.ray.origin.distanceTo(d);I<e.near||I>e.far||t.push({distance:I,point:h.clone().applyMatrix4(this.matrixWorld),index:w,face:null,faceIndex:null,object:this})}}else{const y=Math.max(0,o.start),v=Math.min(g.count,o.start+o.count);for(let w=y,_=v-1;w<_;w+=m){if(l.fromBufferAttribute(g,w),u.fromBufferAttribute(g,w+1),$b.distanceSqToSegment(l,u,d,h)>c)continue;d.applyMatrix4(this.matrixWorld);const E=e.ray.origin.distanceTo(d);E<e.near||E>e.far||t.push({distance:E,point:h.clone().applyMatrix4(this.matrixWorld),index:w,face:null,faceIndex:null,object:this})}}}updateMorphTargets(){const t=this.geometry.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=i.length;s<o;s++){const a=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}}const yT=new k,bT=new k;class Ls extends To{constructor(e,t){super(e,t),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,n=[];for(let i=0,s=t.count;i<s;i+=2)yT.fromBufferAttribute(t,i),bT.fromBufferAttribute(t,i+1),n[i]=i===0?0:n[i-1],n[i+1]=n[i]+yT.distanceTo(bT);e.setAttribute("lineDistance",new Ce(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class t3 extends To{constructor(e,t){super(e,t),this.isLineLoop=!0,this.type="LineLoop"}}class KE extends wr{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new ye(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}const wT=new $e,zx=new ph,nm=new Bn,rm=new k;class XE extends wt{constructor(e=new Ye,t=new KE){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}raycast(e,t){const n=this.geometry,i=this.matrixWorld,s=e.params.Points.threshold,o=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),nm.copy(n.boundingSphere),nm.applyMatrix4(i),nm.radius+=s,e.ray.intersectsSphere(nm)===!1)return;wT.copy(i).invert(),zx.copy(e.ray).applyMatrix4(wT);const a=s/((this.scale.x+this.scale.y+this.scale.z)/3),c=a*a,l=n.index,h=n.attributes.position;if(l!==null){const d=Math.max(0,o.start),m=Math.min(l.count,o.start+o.count);for(let p=d,b=m;p<b;p++){const g=l.getX(p);rm.fromBufferAttribute(h,g),vT(rm,g,c,i,e,t,this)}}else{const d=Math.max(0,o.start),m=Math.min(h.count,o.start+o.count);for(let p=d,b=m;p<b;p++)rm.fromBufferAttribute(h,p),vT(rm,p,c,i,e,t,this)}}updateMorphTargets(){const t=this.geometry.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=i.length;s<o;s++){const a=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}}function vT(r,e,t,n,i,s,o){const a=zx.distanceSqToPoint(r);if(a<t){const c=new k;zx.closestPointToPoint(r,c),c.applyMatrix4(n);const l=i.ray.origin.distanceTo(c);if(l<i.near||l>i.far)return;s.push({distance:l,distanceToRay:Math.sqrt(a),point:c,index:e,face:null,object:o})}}class wH extends hn{constructor(e,t,n,i,s,o,a,c,l){super(e,t,n,i,s,o,a,c,l),this.isVideoTexture=!0,this.minFilter=o!==void 0?o:un,this.magFilter=s!==void 0?s:un,this.generateMipmaps=!1;const u=this;function h(){u.needsUpdate=!0,e.requestVideoFrameCallback(h)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(h)}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class vH extends hn{constructor(e,t){super({width:e,height:t}),this.isFramebufferTexture=!0,this.magFilter=ln,this.minFilter=ln,this.generateMipmaps=!1,this.needsUpdate=!0}}class p0 extends hn{constructor(e,t,n,i,s,o,a,c,l,u,h,d){super(null,o,a,c,l,u,i,s,h,d),this.isCompressedTexture=!0,this.image={width:t,height:n},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}class _H extends p0{constructor(e,t,n,i,s,o){super(e,t,n,s,o),this.isCompressedArrayTexture=!0,this.image.depth=i,this.wrapR=gr}}class xH extends p0{constructor(e,t,n){super(void 0,e[0].width,e[0].height,t,n,Ao),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=e}}class SH extends hn{constructor(e,t,n,i,s,o,a,c,l){super(e,t,n,i,s,o,a,c,l),this.isCanvasTexture=!0,this.needsUpdate=!0}}class is{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,t){const n=this.getUtoTmapping(e);return this.getPoint(n,t)}getPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return t}getSpacedPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPointAt(n/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let n,i=this.getPoint(0),s=0;t.push(0);for(let o=1;o<=e;o++)n=this.getPoint(o/e),s+=n.distanceTo(i),t.push(s),i=n;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t){const n=this.getLengths();let i=0;const s=n.length;let o;t?o=t:o=e*n[s-1];let a=0,c=s-1,l;for(;a<=c;)if(i=Math.floor(a+(c-a)/2),l=n[i]-o,l<0)a=i+1;else if(l>0)c=i-1;else{c=i;break}if(i=c,n[i]===o)return i/(s-1);const u=n[i],d=n[i+1]-u,m=(o-u)/d;return(i+m)/(s-1)}getTangent(e,t){let i=e-1e-4,s=e+1e-4;i<0&&(i=0),s>1&&(s=1);const o=this.getPoint(i),a=this.getPoint(s),c=t||(o.isVector2?new se:new k);return c.copy(a).sub(o).normalize(),c}getTangentAt(e,t){const n=this.getUtoTmapping(e);return this.getTangent(n,t)}computeFrenetFrames(e,t){const n=new k,i=[],s=[],o=[],a=new k,c=new $e;for(let m=0;m<=e;m++){const p=m/e;i[m]=this.getTangentAt(p,new k)}s[0]=new k,o[0]=new k;let l=Number.MAX_VALUE;const u=Math.abs(i[0].x),h=Math.abs(i[0].y),d=Math.abs(i[0].z);u<=l&&(l=u,n.set(1,0,0)),h<=l&&(l=h,n.set(0,1,0)),d<=l&&n.set(0,0,1),a.crossVectors(i[0],n).normalize(),s[0].crossVectors(i[0],a),o[0].crossVectors(i[0],s[0]);for(let m=1;m<=e;m++){if(s[m]=s[m-1].clone(),o[m]=o[m-1].clone(),a.crossVectors(i[m-1],i[m]),a.length()>Number.EPSILON){a.normalize();const p=Math.acos(rn(i[m-1].dot(i[m]),-1,1));s[m].applyMatrix4(c.makeRotationAxis(a,p))}o[m].crossVectors(i[m],s[m])}if(t===!0){let m=Math.acos(rn(s[0].dot(s[e]),-1,1));m/=e,i[0].dot(a.crossVectors(s[0],s[e]))>0&&(m=-m);for(let p=1;p<=e;p++)s[p].applyMatrix4(c.makeRotationAxis(i[p],m*p)),o[p].crossVectors(i[p],s[p])}return{tangents:i,normals:s,binormals:o}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class m0 extends is{constructor(e=0,t=0,n=1,i=1,s=0,o=Math.PI*2,a=!1,c=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=n,this.yRadius=i,this.aStartAngle=s,this.aEndAngle=o,this.aClockwise=a,this.aRotation=c}getPoint(e,t){const n=t||new se,i=Math.PI*2;let s=this.aEndAngle-this.aStartAngle;const o=Math.abs(s)<Number.EPSILON;for(;s<0;)s+=i;for(;s>i;)s-=i;s<Number.EPSILON&&(o?s=0:s=i),this.aClockwise===!0&&!o&&(s===i?s=-i:s=s-i);const a=this.aStartAngle+e*s;let c=this.aX+this.xRadius*Math.cos(a),l=this.aY+this.yRadius*Math.sin(a);if(this.aRotation!==0){const u=Math.cos(this.aRotation),h=Math.sin(this.aRotation),d=c-this.aX,m=l-this.aY;c=d*u-m*h+this.aX,l=d*h+m*u+this.aY}return n.set(c,l)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}class n3 extends m0{constructor(e,t,n,i,s,o){super(e,t,n,n,i,s,o),this.isArcCurve=!0,this.type="ArcCurve"}}function YE(){let r=0,e=0,t=0,n=0;function i(s,o,a,c){r=s,e=a,t=-3*s+3*o-2*a-c,n=2*s-2*o+a+c}return{initCatmullRom:function(s,o,a,c,l){i(o,a,l*(a-s),l*(c-o))},initNonuniformCatmullRom:function(s,o,a,c,l,u,h){let d=(o-s)/l-(a-s)/(l+u)+(a-o)/u,m=(a-o)/u-(c-o)/(u+h)+(c-a)/h;d*=u,m*=u,i(o,a,d,m)},calc:function(s){const o=s*s,a=o*s;return r+e*s+t*o+n*a}}}const im=new k,zb=new YE,Vb=new YE,Hb=new YE;class r3 extends is{constructor(e=[],t=!1,n="centripetal",i=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=n,this.tension=i}getPoint(e,t=new k){const n=t,i=this.points,s=i.length,o=(s-(this.closed?0:1))*e;let a=Math.floor(o),c=o-a;this.closed?a+=a>0?0:(Math.floor(Math.abs(a)/s)+1)*s:c===0&&a===s-1&&(a=s-2,c=1);let l,u;this.closed||a>0?l=i[(a-1)%s]:(im.subVectors(i[0],i[1]).add(i[0]),l=im);const h=i[a%s],d=i[(a+1)%s];if(this.closed||a+2<s?u=i[(a+2)%s]:(im.subVectors(i[s-1],i[s-2]).add(i[s-1]),u=im),this.curveType==="centripetal"||this.curveType==="chordal"){const m=this.curveType==="chordal"?.5:.25;let p=Math.pow(l.distanceToSquared(h),m),b=Math.pow(h.distanceToSquared(d),m),g=Math.pow(d.distanceToSquared(u),m);b<1e-4&&(b=1),p<1e-4&&(p=b),g<1e-4&&(g=b),zb.initNonuniformCatmullRom(l.x,h.x,d.x,u.x,p,b,g),Vb.initNonuniformCatmullRom(l.y,h.y,d.y,u.y,p,b,g),Hb.initNonuniformCatmullRom(l.z,h.z,d.z,u.z,p,b,g)}else this.curveType==="catmullrom"&&(zb.initCatmullRom(l.x,h.x,d.x,u.x,this.tension),Vb.initCatmullRom(l.y,h.y,d.y,u.y,this.tension),Hb.initCatmullRom(l.z,h.z,d.z,u.z,this.tension));return n.set(zb.calc(c),Vb.calc(c),Hb.calc(c)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(i.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const i=this.points[t];e.points.push(i.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(new k().fromArray(i))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}function _T(r,e,t,n,i){const s=(n-e)*.5,o=(i-t)*.5,a=r*r,c=r*a;return(2*t-2*n+s+o)*c+(-3*t+3*n-2*s-o)*a+s*r+t}function EH(r,e){const t=1-r;return t*t*e}function MH(r,e){return 2*(1-r)*r*e}function AH(r,e){return r*r*e}function Td(r,e,t,n){return EH(r,e)+MH(r,t)+AH(r,n)}function TH(r,e){const t=1-r;return t*t*t*e}function CH(r,e){const t=1-r;return 3*t*t*r*e}function IH(r,e){return 3*(1-r)*r*r*e}function PH(r,e){return r*r*r*e}function Cd(r,e,t,n,i){return TH(r,e)+CH(r,t)+IH(r,n)+PH(r,i)}class ZE extends is{constructor(e=new se,t=new se,n=new se,i=new se){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=n,this.v3=i}getPoint(e,t=new se){const n=t,i=this.v0,s=this.v1,o=this.v2,a=this.v3;return n.set(Cd(e,i.x,s.x,o.x,a.x),Cd(e,i.y,s.y,o.y,a.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class i3 extends is{constructor(e=new k,t=new k,n=new k,i=new k){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=n,this.v3=i}getPoint(e,t=new k){const n=t,i=this.v0,s=this.v1,o=this.v2,a=this.v3;return n.set(Cd(e,i.x,s.x,o.x,a.x),Cd(e,i.y,s.y,o.y,a.y),Cd(e,i.z,s.z,o.z,a.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class JE extends is{constructor(e=new se,t=new se){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new se){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t=new se){return t.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,t){return this.getTangent(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class s3 extends is{constructor(e=new k,t=new k){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=e,this.v2=t}getPoint(e,t=new k){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t=new k){return t.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,t){return this.getTangent(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class jE extends is{constructor(e=new se,t=new se,n=new se){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new se){const n=t,i=this.v0,s=this.v1,o=this.v2;return n.set(Td(e,i.x,s.x,o.x),Td(e,i.y,s.y,o.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class QE extends is{constructor(e=new k,t=new k,n=new k){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new k){const n=t,i=this.v0,s=this.v1,o=this.v2;return n.set(Td(e,i.x,s.x,o.x),Td(e,i.y,s.y,o.y),Td(e,i.z,s.z,o.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class e1 extends is{constructor(e=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=e}getPoint(e,t=new se){const n=t,i=this.points,s=(i.length-1)*e,o=Math.floor(s),a=s-o,c=i[o===0?o:o-1],l=i[o],u=i[o>i.length-2?i.length-1:o+1],h=i[o>i.length-3?i.length-1:o+2];return n.set(_T(a,c.x,l.x,u.x,h.x),_T(a,c.y,l.y,u.y,h.y)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const i=this.points[t];e.points.push(i.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(new se().fromArray(i))}return this}}var Hg=Object.freeze({__proto__:null,ArcCurve:n3,CatmullRomCurve3:r3,CubicBezierCurve:ZE,CubicBezierCurve3:i3,EllipseCurve:m0,LineCurve:JE,LineCurve3:s3,QuadraticBezierCurve:jE,QuadraticBezierCurve3:QE,SplineCurve:e1});class o3 extends is{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);if(!e.equals(t)){const n=e.isVector2===!0?"LineCurve":"LineCurve3";this.curves.push(new Hg[n](t,e))}return this}getPoint(e,t){const n=e*this.getLength(),i=this.getCurveLengths();let s=0;for(;s<i.length;){if(i[s]>=n){const o=i[s]-n,a=this.curves[s],c=a.getLength(),l=c===0?0:1-o/c;return a.getPointAt(l,t)}s++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let n=0,i=this.curves.length;n<i;n++)t+=this.curves[n].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let n;for(let i=0,s=this.curves;i<s.length;i++){const o=s[i],a=o.isEllipseCurve?e*2:o.isLineCurve||o.isLineCurve3?1:o.isSplineCurve?e*o.points.length:e,c=o.getPoints(a);for(let l=0;l<c.length;l++){const u=c[l];n&&n.equals(u)||(t.push(u),n=u)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const i=e.curves[t];this.curves.push(i.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,n=this.curves.length;t<n;t++){const i=this.curves[t];e.curves.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const i=e.curves[t];this.curves.push(new Hg[i.type]().fromJSON(i))}return this}}class tf extends o3{constructor(e){super(),this.type="Path",this.currentPoint=new se,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,n=e.length;t<n;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const n=new JE(this.currentPoint.clone(),new se(e,t));return this.curves.push(n),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,n,i){const s=new jE(this.currentPoint.clone(),new se(e,t),new se(n,i));return this.curves.push(s),this.currentPoint.set(n,i),this}bezierCurveTo(e,t,n,i,s,o){const a=new ZE(this.currentPoint.clone(),new se(e,t),new se(n,i),new se(s,o));return this.curves.push(a),this.currentPoint.set(s,o),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),n=new e1(t);return this.curves.push(n),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,n,i,s,o){const a=this.currentPoint.x,c=this.currentPoint.y;return this.absarc(e+a,t+c,n,i,s,o),this}absarc(e,t,n,i,s,o){return this.absellipse(e,t,n,n,i,s,o),this}ellipse(e,t,n,i,s,o,a,c){const l=this.currentPoint.x,u=this.currentPoint.y;return this.absellipse(e+l,t+u,n,i,s,o,a,c),this}absellipse(e,t,n,i,s,o,a,c){const l=new m0(e,t,n,i,s,o,a,c);if(this.curves.length>0){const h=l.getPoint(0);h.equals(this.currentPoint)||this.lineTo(h.x,h.y)}this.curves.push(l);const u=l.getPoint(1);return this.currentPoint.copy(u),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class np extends Ye{constructor(e=[new se(0,-.5),new se(.5,0),new se(0,.5)],t=12,n=0,i=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:n,phiLength:i},t=Math.floor(t),i=rn(i,0,Math.PI*2);const s=[],o=[],a=[],c=[],l=[],u=1/t,h=new k,d=new se,m=new k,p=new k,b=new k;let g=0,y=0;for(let v=0;v<=e.length-1;v++)switch(v){case 0:g=e[v+1].x-e[v].x,y=e[v+1].y-e[v].y,m.x=y*1,m.y=-g,m.z=y*0,b.copy(m),m.normalize(),c.push(m.x,m.y,m.z);break;case e.length-1:c.push(b.x,b.y,b.z);break;default:g=e[v+1].x-e[v].x,y=e[v+1].y-e[v].y,m.x=y*1,m.y=-g,m.z=y*0,p.copy(m),m.x+=b.x,m.y+=b.y,m.z+=b.z,m.normalize(),c.push(m.x,m.y,m.z),b.copy(p)}for(let v=0;v<=t;v++){const w=n+v*u*i,_=Math.sin(w),M=Math.cos(w);for(let E=0;E<=e.length-1;E++){h.x=e[E].x*_,h.y=e[E].y,h.z=e[E].x*M,o.push(h.x,h.y,h.z),d.x=v/t,d.y=E/(e.length-1),a.push(d.x,d.y);const C=c[3*E+0]*_,I=c[3*E+1],x=c[3*E+0]*M;l.push(C,I,x)}}for(let v=0;v<t;v++)for(let w=0;w<e.length-1;w++){const _=w+v*e.length,M=_,E=_+e.length,C=_+e.length+1,I=_+1;s.push(M,E,I),s.push(C,I,E)}this.setIndex(s),this.setAttribute("position",new Ce(o,3)),this.setAttribute("uv",new Ce(a,2)),this.setAttribute("normal",new Ce(l,3))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new np(e.points,e.segments,e.phiStart,e.phiLength)}}class g0 extends np{constructor(e=1,t=1,n=4,i=8){const s=new tf;s.absarc(0,-t/2,e,Math.PI*1.5,0),s.absarc(0,t/2,e,0,Math.PI*.5),super(s.getPoints(n),i),this.type="CapsuleGeometry",this.parameters={radius:e,length:t,capSegments:n,radialSegments:i}}static fromJSON(e){return new g0(e.radius,e.length,e.capSegments,e.radialSegments)}}class y0 extends Ye{constructor(e=1,t=32,n=0,i=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:n,thetaLength:i},t=Math.max(3,t);const s=[],o=[],a=[],c=[],l=new k,u=new se;o.push(0,0,0),a.push(0,0,1),c.push(.5,.5);for(let h=0,d=3;h<=t;h++,d+=3){const m=n+h/t*i;l.x=e*Math.cos(m),l.y=e*Math.sin(m),o.push(l.x,l.y,l.z),a.push(0,0,1),u.x=(o[d]/e+1)/2,u.y=(o[d+1]/e+1)/2,c.push(u.x,u.y)}for(let h=1;h<=t;h++)s.push(h,h+1,0);this.setIndex(s),this.setAttribute("position",new Ce(o,3)),this.setAttribute("normal",new Ce(a,3)),this.setAttribute("uv",new Ce(c,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new y0(e.radius,e.segments,e.thetaStart,e.thetaLength)}}class Or extends Ye{constructor(e=1,t=1,n=1,i=32,s=1,o=!1,a=0,c=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:n,radialSegments:i,heightSegments:s,openEnded:o,thetaStart:a,thetaLength:c};const l=this;i=Math.floor(i),s=Math.floor(s);const u=[],h=[],d=[],m=[];let p=0;const b=[],g=n/2;let y=0;v(),o===!1&&(e>0&&w(!0),t>0&&w(!1)),this.setIndex(u),this.setAttribute("position",new Ce(h,3)),this.setAttribute("normal",new Ce(d,3)),this.setAttribute("uv",new Ce(m,2));function v(){const _=new k,M=new k;let E=0;const C=(t-e)/n;for(let I=0;I<=s;I++){const x=[],T=I/s,F=T*(t-e)+e;for(let $=0;$<=i;$++){const H=$/i,S=H*c+a,A=Math.sin(S),P=Math.cos(S);M.x=F*A,M.y=-T*n+g,M.z=F*P,h.push(M.x,M.y,M.z),_.set(A,C,P).normalize(),d.push(_.x,_.y,_.z),m.push(H,1-T),x.push(p++)}b.push(x)}for(let I=0;I<i;I++)for(let x=0;x<s;x++){const T=b[x][I],F=b[x+1][I],$=b[x+1][I+1],H=b[x][I+1];u.push(T,F,H),u.push(F,$,H),E+=6}l.addGroup(y,E,0),y+=E}function w(_){const M=p,E=new se,C=new k;let I=0;const x=_===!0?e:t,T=_===!0?1:-1;for(let $=1;$<=i;$++)h.push(0,g*T,0),d.push(0,T,0),m.push(.5,.5),p++;const F=p;for(let $=0;$<=i;$++){const S=$/i*c+a,A=Math.cos(S),P=Math.sin(S);C.x=x*P,C.y=g*T,C.z=x*A,h.push(C.x,C.y,C.z),d.push(0,T,0),E.x=A*.5+.5,E.y=P*.5*T+.5,m.push(E.x,E.y),p++}for(let $=0;$<i;$++){const H=M+$,S=F+$;_===!0?u.push(S,S+1,H):u.push(S+1,S,H),I+=3}l.addGroup(y,I,_===!0?1:2),y+=I}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Or(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class jr extends Or{constructor(e=1,t=1,n=32,i=1,s=!1,o=0,a=Math.PI*2){super(0,e,t,n,i,s,o,a),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:n,heightSegments:i,openEnded:s,thetaStart:o,thetaLength:a}}static fromJSON(e){return new jr(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class Da extends Ye{constructor(e=[],t=[],n=1,i=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:n,detail:i};const s=[],o=[];a(i),l(n),u(),this.setAttribute("position",new Ce(s,3)),this.setAttribute("normal",new Ce(s.slice(),3)),this.setAttribute("uv",new Ce(o,2)),i===0?this.computeVertexNormals():this.normalizeNormals();function a(v){const w=new k,_=new k,M=new k;for(let E=0;E<t.length;E+=3)m(t[E+0],w),m(t[E+1],_),m(t[E+2],M),c(w,_,M,v)}function c(v,w,_,M){const E=M+1,C=[];for(let I=0;I<=E;I++){C[I]=[];const x=v.clone().lerp(_,I/E),T=w.clone().lerp(_,I/E),F=E-I;for(let $=0;$<=F;$++)$===0&&I===E?C[I][$]=x:C[I][$]=x.clone().lerp(T,$/F)}for(let I=0;I<E;I++)for(let x=0;x<2*(E-I)-1;x++){const T=Math.floor(x/2);x%2===0?(d(C[I][T+1]),d(C[I+1][T]),d(C[I][T])):(d(C[I][T+1]),d(C[I+1][T+1]),d(C[I+1][T]))}}function l(v){const w=new k;for(let _=0;_<s.length;_+=3)w.x=s[_+0],w.y=s[_+1],w.z=s[_+2],w.normalize().multiplyScalar(v),s[_+0]=w.x,s[_+1]=w.y,s[_+2]=w.z}function u(){const v=new k;for(let w=0;w<s.length;w+=3){v.x=s[w+0],v.y=s[w+1],v.z=s[w+2];const _=g(v)/2/Math.PI+.5,M=y(v)/Math.PI+.5;o.push(_,1-M)}p(),h()}function h(){for(let v=0;v<o.length;v+=6){const w=o[v+0],_=o[v+2],M=o[v+4],E=Math.max(w,_,M),C=Math.min(w,_,M);E>.9&&C<.1&&(w<.2&&(o[v+0]+=1),_<.2&&(o[v+2]+=1),M<.2&&(o[v+4]+=1))}}function d(v){s.push(v.x,v.y,v.z)}function m(v,w){const _=v*3;w.x=e[_+0],w.y=e[_+1],w.z=e[_+2]}function p(){const v=new k,w=new k,_=new k,M=new k,E=new se,C=new se,I=new se;for(let x=0,T=0;x<s.length;x+=9,T+=6){v.set(s[x+0],s[x+1],s[x+2]),w.set(s[x+3],s[x+4],s[x+5]),_.set(s[x+6],s[x+7],s[x+8]),E.set(o[T+0],o[T+1]),C.set(o[T+2],o[T+3]),I.set(o[T+4],o[T+5]),M.copy(v).add(w).add(_).divideScalar(3);const F=g(M);b(E,T+0,v,F),b(C,T+2,w,F),b(I,T+4,_,F)}}function b(v,w,_,M){M<0&&v.x===1&&(o[w]=v.x-1),_.x===0&&_.z===0&&(o[w]=M/2/Math.PI+.5)}function g(v){return Math.atan2(v.z,-v.x)}function y(v){return Math.atan2(-v.y,Math.sqrt(v.x*v.x+v.z*v.z))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Da(e.vertices,e.indices,e.radius,e.details)}}class b0 extends Da{constructor(e=1,t=0){const n=(1+Math.sqrt(5))/2,i=1/n,s=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-n,0,-i,n,0,i,-n,0,i,n,-i,-n,0,-i,n,0,i,-n,0,i,n,0,-n,0,-i,n,0,-i,-n,0,i,n,0,i],o=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(s,o,e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new b0(e.radius,e.detail)}}const sm=new k,om=new k,Gb=new k,am=new Ur;class a3 extends Ye{constructor(e=null,t=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:e,thresholdAngle:t},e!==null){const i=Math.pow(10,4),s=Math.cos(Sc*t),o=e.getIndex(),a=e.getAttribute("position"),c=o?o.count:a.count,l=[0,0,0],u=["a","b","c"],h=new Array(3),d={},m=[];for(let p=0;p<c;p+=3){o?(l[0]=o.getX(p),l[1]=o.getX(p+1),l[2]=o.getX(p+2)):(l[0]=p,l[1]=p+1,l[2]=p+2);const{a:b,b:g,c:y}=am;if(b.fromBufferAttribute(a,l[0]),g.fromBufferAttribute(a,l[1]),y.fromBufferAttribute(a,l[2]),am.getNormal(Gb),h[0]=`${Math.round(b.x*i)},${Math.round(b.y*i)},${Math.round(b.z*i)}`,h[1]=`${Math.round(g.x*i)},${Math.round(g.y*i)},${Math.round(g.z*i)}`,h[2]=`${Math.round(y.x*i)},${Math.round(y.y*i)},${Math.round(y.z*i)}`,!(h[0]===h[1]||h[1]===h[2]||h[2]===h[0]))for(let v=0;v<3;v++){const w=(v+1)%3,_=h[v],M=h[w],E=am[u[v]],C=am[u[w]],I=`${_}_${M}`,x=`${M}_${_}`;x in d&&d[x]?(Gb.dot(d[x].normal)<=s&&(m.push(E.x,E.y,E.z),m.push(C.x,C.y,C.z)),d[x]=null):I in d||(d[I]={index0:l[v],index1:l[w],normal:Gb.clone()})}}for(const p in d)if(d[p]){const{index0:b,index1:g}=d[p];sm.fromBufferAttribute(a,b),om.fromBufferAttribute(a,g),m.push(sm.x,sm.y,sm.z),m.push(om.x,om.y,om.z)}this.setAttribute("position",new Ce(m,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}class Mc extends tf{constructor(e){super(e),this.uuid=ii(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let n=0,i=this.holes.length;n<i;n++)t[n]=this.holes[n].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const i=e.holes[t];this.holes.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,n=this.holes.length;t<n;t++){const i=this.holes[t];e.holes.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const i=e.holes[t];this.holes.push(new tf().fromJSON(i))}return this}}const RH={triangulate:function(r,e,t=2){const n=e&&e.length,i=n?e[0]*t:r.length;let s=c3(r,0,i,t,!0);const o=[];if(!s||s.next===s.prev)return o;let a,c,l,u,h,d,m;if(n&&(s=UH(r,e,s,t)),r.length>80*t){a=l=r[0],c=u=r[1];for(let p=t;p<i;p+=t)h=r[p],d=r[p+1],h<a&&(a=h),d<c&&(c=d),h>l&&(l=h),d>u&&(u=d);m=Math.max(l-a,u-c),m=m!==0?32767/m:0}return nf(s,o,t,a,c,m,0),o}};function c3(r,e,t,n,i){let s,o;if(i===KH(r,e,t,n)>0)for(s=e;s<t;s+=n)o=xT(s,r[s],r[s+1],o);else for(s=t-n;s>=e;s-=n)o=xT(s,r[s],r[s+1],o);return o&&w0(o,o.next)&&(sf(o),o=o.next),o}function Dc(r,e){if(!r)return r;e||(e=r);let t=r,n;do if(n=!1,!t.steiner&&(w0(t,t.next)||Xt(t.prev,t,t.next)===0)){if(sf(t),t=e=t.prev,t===t.next)break;n=!0}else t=t.next;while(n||t!==e);return e}function nf(r,e,t,n,i,s,o){if(!r)return;!o&&s&&zH(r,n,i,s);let a=r,c,l;for(;r.prev!==r.next;){if(c=r.prev,l=r.next,s?LH(r,n,i,s):DH(r)){e.push(c.i/t|0),e.push(r.i/t|0),e.push(l.i/t|0),sf(r),r=l.next,a=l.next;continue}if(r=l,r===a){o?o===1?(r=NH(Dc(r),e,t),nf(r,e,t,n,i,s,2)):o===2&&OH(r,e,t,n,i,s):nf(Dc(r),e,t,n,i,s,1);break}}}function DH(r){const e=r.prev,t=r,n=r.next;if(Xt(e,t,n)>=0)return!1;const i=e.x,s=t.x,o=n.x,a=e.y,c=t.y,l=n.y,u=i<s?i<o?i:o:s<o?s:o,h=a<c?a<l?a:l:c<l?c:l,d=i>s?i>o?i:o:s>o?s:o,m=a>c?a>l?a:l:c>l?c:l;let p=n.next;for(;p!==e;){if(p.x>=u&&p.x<=d&&p.y>=h&&p.y<=m&&Nl(i,a,s,c,o,l,p.x,p.y)&&Xt(p.prev,p,p.next)>=0)return!1;p=p.next}return!0}function LH(r,e,t,n){const i=r.prev,s=r,o=r.next;if(Xt(i,s,o)>=0)return!1;const a=i.x,c=s.x,l=o.x,u=i.y,h=s.y,d=o.y,m=a<c?a<l?a:l:c<l?c:l,p=u<h?u<d?u:d:h<d?h:d,b=a>c?a>l?a:l:c>l?c:l,g=u>h?u>d?u:d:h>d?h:d,y=Vx(m,p,e,t,n),v=Vx(b,g,e,t,n);let w=r.prevZ,_=r.nextZ;for(;w&&w.z>=y&&_&&_.z<=v;){if(w.x>=m&&w.x<=b&&w.y>=p&&w.y<=g&&w!==i&&w!==o&&Nl(a,u,c,h,l,d,w.x,w.y)&&Xt(w.prev,w,w.next)>=0||(w=w.prevZ,_.x>=m&&_.x<=b&&_.y>=p&&_.y<=g&&_!==i&&_!==o&&Nl(a,u,c,h,l,d,_.x,_.y)&&Xt(_.prev,_,_.next)>=0))return!1;_=_.nextZ}for(;w&&w.z>=y;){if(w.x>=m&&w.x<=b&&w.y>=p&&w.y<=g&&w!==i&&w!==o&&Nl(a,u,c,h,l,d,w.x,w.y)&&Xt(w.prev,w,w.next)>=0)return!1;w=w.prevZ}for(;_&&_.z<=v;){if(_.x>=m&&_.x<=b&&_.y>=p&&_.y<=g&&_!==i&&_!==o&&Nl(a,u,c,h,l,d,_.x,_.y)&&Xt(_.prev,_,_.next)>=0)return!1;_=_.nextZ}return!0}function NH(r,e,t){let n=r;do{const i=n.prev,s=n.next.next;!w0(i,s)&&l3(i,n,n.next,s)&&rf(i,s)&&rf(s,i)&&(e.push(i.i/t|0),e.push(n.i/t|0),e.push(s.i/t|0),sf(n),sf(n.next),n=r=s),n=n.next}while(n!==r);return Dc(n)}function OH(r,e,t,n,i,s){let o=r;do{let a=o.next.next;for(;a!==o.prev;){if(o.i!==a.i&&GH(o,a)){let c=u3(o,a);o=Dc(o,o.next),c=Dc(c,c.next),nf(o,e,t,n,i,s,0),nf(c,e,t,n,i,s,0);return}a=a.next}o=o.next}while(o!==r)}function UH(r,e,t,n){const i=[];let s,o,a,c,l;for(s=0,o=e.length;s<o;s++)a=e[s]*n,c=s<o-1?e[s+1]*n:r.length,l=c3(r,a,c,n,!1),l===l.next&&(l.steiner=!0),i.push(HH(l));for(i.sort(kH),s=0;s<i.length;s++)t=BH(i[s],t);return t}function kH(r,e){return r.x-e.x}function BH(r,e){const t=FH(r,e);if(!t)return e;const n=u3(t,r);return Dc(n,n.next),Dc(t,t.next)}function FH(r,e){let t=e,n=-1/0,i;const s=r.x,o=r.y;do{if(o<=t.y&&o>=t.next.y&&t.next.y!==t.y){const d=t.x+(o-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(d<=s&&d>n&&(n=d,i=t.x<t.next.x?t:t.next,d===s))return i}t=t.next}while(t!==e);if(!i)return null;const a=i,c=i.x,l=i.y;let u=1/0,h;t=i;do s>=t.x&&t.x>=c&&s!==t.x&&Nl(o<l?s:n,o,c,l,o<l?n:s,o,t.x,t.y)&&(h=Math.abs(o-t.y)/(s-t.x),rf(t,r)&&(h<u||h===u&&(t.x>i.x||t.x===i.x&&$H(i,t)))&&(i=t,u=h)),t=t.next;while(t!==a);return i}function $H(r,e){return Xt(r.prev,r,e.prev)<0&&Xt(e.next,r,r.next)<0}function zH(r,e,t,n){let i=r;do i.z===0&&(i.z=Vx(i.x,i.y,e,t,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==r);i.prevZ.nextZ=null,i.prevZ=null,VH(i)}function VH(r){let e,t,n,i,s,o,a,c,l=1;do{for(t=r,r=null,s=null,o=0;t;){for(o++,n=t,a=0,e=0;e<l&&(a++,n=n.nextZ,!!n);e++);for(c=l;a>0||c>0&&n;)a!==0&&(c===0||!n||t.z<=n.z)?(i=t,t=t.nextZ,a--):(i=n,n=n.nextZ,c--),s?s.nextZ=i:r=i,i.prevZ=s,s=i;t=n}s.nextZ=null,l*=2}while(o>1);return r}function Vx(r,e,t,n,i){return r=(r-t)*i|0,e=(e-n)*i|0,r=(r|r<<8)&16711935,r=(r|r<<4)&252645135,r=(r|r<<2)&858993459,r=(r|r<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,r|e<<1}function HH(r){let e=r,t=r;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==r);return t}function Nl(r,e,t,n,i,s,o,a){return(i-o)*(e-a)>=(r-o)*(s-a)&&(r-o)*(n-a)>=(t-o)*(e-a)&&(t-o)*(s-a)>=(i-o)*(n-a)}function GH(r,e){return r.next.i!==e.i&&r.prev.i!==e.i&&!WH(r,e)&&(rf(r,e)&&rf(e,r)&&qH(r,e)&&(Xt(r.prev,r,e.prev)||Xt(r,e.prev,e))||w0(r,e)&&Xt(r.prev,r,r.next)>0&&Xt(e.prev,e,e.next)>0)}function Xt(r,e,t){return(e.y-r.y)*(t.x-e.x)-(e.x-r.x)*(t.y-e.y)}function w0(r,e){return r.x===e.x&&r.y===e.y}function l3(r,e,t,n){const i=lm(Xt(r,e,t)),s=lm(Xt(r,e,n)),o=lm(Xt(t,n,r)),a=lm(Xt(t,n,e));return!!(i!==s&&o!==a||i===0&&cm(r,t,e)||s===0&&cm(r,n,e)||o===0&&cm(t,r,n)||a===0&&cm(t,e,n))}function cm(r,e,t){return e.x<=Math.max(r.x,t.x)&&e.x>=Math.min(r.x,t.x)&&e.y<=Math.max(r.y,t.y)&&e.y>=Math.min(r.y,t.y)}function lm(r){return r>0?1:r<0?-1:0}function WH(r,e){let t=r;do{if(t.i!==r.i&&t.next.i!==r.i&&t.i!==e.i&&t.next.i!==e.i&&l3(t,t.next,r,e))return!0;t=t.next}while(t!==r);return!1}function rf(r,e){return Xt(r.prev,r,r.next)<0?Xt(r,e,r.next)>=0&&Xt(r,r.prev,e)>=0:Xt(r,e,r.prev)<0||Xt(r,r.next,e)<0}function qH(r,e){let t=r,n=!1;const i=(r.x+e.x)/2,s=(r.y+e.y)/2;do t.y>s!=t.next.y>s&&t.next.y!==t.y&&i<(t.next.x-t.x)*(s-t.y)/(t.next.y-t.y)+t.x&&(n=!n),t=t.next;while(t!==r);return n}function u3(r,e){const t=new Hx(r.i,r.x,r.y),n=new Hx(e.i,e.x,e.y),i=r.next,s=e.prev;return r.next=e,e.prev=r,t.next=i,i.prev=t,n.next=t,t.prev=n,s.next=n,n.prev=s,n}function xT(r,e,t,n){const i=new Hx(r,e,t);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function sf(r){r.next.prev=r.prev,r.prev.next=r.next,r.prevZ&&(r.prevZ.nextZ=r.nextZ),r.nextZ&&(r.nextZ.prevZ=r.prevZ)}function Hx(r,e,t){this.i=r,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function KH(r,e,t,n){let i=0;for(let s=e,o=t-n;s<t;s+=n)i+=(r[o]-r[s])*(r[s+1]+r[o+1]),o=s;return i}class Es{static area(e){const t=e.length;let n=0;for(let i=t-1,s=0;s<t;i=s++)n+=e[i].x*e[s].y-e[s].x*e[i].y;return n*.5}static isClockWise(e){return Es.area(e)<0}static triangulateShape(e,t){const n=[],i=[],s=[];ST(e),ET(n,e);let o=e.length;t.forEach(ST);for(let c=0;c<t.length;c++)i.push(o),o+=t[c].length,ET(n,t[c]);const a=RH.triangulate(n,i);for(let c=0;c<a.length;c+=3)s.push(a.slice(c,c+3));return s}}function ST(r){const e=r.length;e>2&&r[e-1].equals(r[0])&&r.pop()}function ET(r,e){for(let t=0;t<e.length;t++)r.push(e[t].x),r.push(e[t].y)}class v0 extends Ye{constructor(e=new Mc([new se(.5,.5),new se(-.5,.5),new se(-.5,-.5),new se(.5,-.5)]),t={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const n=this,i=[],s=[];for(let a=0,c=e.length;a<c;a++){const l=e[a];o(l)}this.setAttribute("position",new Ce(i,3)),this.setAttribute("uv",new Ce(s,2)),this.computeVertexNormals();function o(a){const c=[],l=t.curveSegments!==void 0?t.curveSegments:12,u=t.steps!==void 0?t.steps:1,h=t.depth!==void 0?t.depth:1;let d=t.bevelEnabled!==void 0?t.bevelEnabled:!0,m=t.bevelThickness!==void 0?t.bevelThickness:.2,p=t.bevelSize!==void 0?t.bevelSize:m-.1,b=t.bevelOffset!==void 0?t.bevelOffset:0,g=t.bevelSegments!==void 0?t.bevelSegments:3;const y=t.extrudePath,v=t.UVGenerator!==void 0?t.UVGenerator:XH;let w,_=!1,M,E,C,I;y&&(w=y.getSpacedPoints(u),_=!0,d=!1,M=y.computeFrenetFrames(u,!1),E=new k,C=new k,I=new k),d||(g=0,m=0,p=0,b=0);const x=a.extractPoints(l);let T=x.shape;const F=x.holes;if(!Es.isClockWise(T)){T=T.reverse();for(let W=0,ue=F.length;W<ue;W++){const re=F[W];Es.isClockWise(re)&&(F[W]=re.reverse())}}const H=Es.triangulateShape(T,F),S=T;for(let W=0,ue=F.length;W<ue;W++){const re=F[W];T=T.concat(re)}function A(W,ue,re){return ue||console.error("THREE.ExtrudeGeometry: vec does not exist"),W.clone().addScaledVector(ue,re)}const P=T.length,L=H.length;function B(W,ue,re){let le,ie,Oe;const Te=W.x-ue.x,O=W.y-ue.y,R=re.x-W.x,J=re.y-W.y,ge=Te*Te+O*O,pe=Te*J-O*R;if(Math.abs(pe)>Number.EPSILON){const de=Math.sqrt(ge),Le=Math.sqrt(R*R+J*J),Ee=ue.x-O/de,Pe=ue.y+Te/de,ze=re.x-J/Le,je=re.y+R/Le,me=((ze-Ee)*J-(je-Pe)*R)/(Te*J-O*R);le=Ee+Te*me-W.x,ie=Pe+O*me-W.y;const _t=le*le+ie*ie;if(_t<=2)return new se(le,ie);Oe=Math.sqrt(_t/2)}else{let de=!1;Te>Number.EPSILON?R>Number.EPSILON&&(de=!0):Te<-Number.EPSILON?R<-Number.EPSILON&&(de=!0):Math.sign(O)===Math.sign(J)&&(de=!0),de?(le=-O,ie=Te,Oe=Math.sqrt(ge)):(le=Te,ie=O,Oe=Math.sqrt(ge/2))}return new se(le/Oe,ie/Oe)}const D=[];for(let W=0,ue=S.length,re=ue-1,le=W+1;W<ue;W++,re++,le++)re===ue&&(re=0),le===ue&&(le=0),D[W]=B(S[W],S[re],S[le]);const V=[];let z,q=D.concat();for(let W=0,ue=F.length;W<ue;W++){const re=F[W];z=[];for(let le=0,ie=re.length,Oe=ie-1,Te=le+1;le<ie;le++,Oe++,Te++)Oe===ie&&(Oe=0),Te===ie&&(Te=0),z[le]=B(re[le],re[Oe],re[Te]);V.push(z),q=q.concat(z)}for(let W=0;W<g;W++){const ue=W/g,re=m*Math.cos(ue*Math.PI/2),le=p*Math.sin(ue*Math.PI/2)+b;for(let ie=0,Oe=S.length;ie<Oe;ie++){const Te=A(S[ie],D[ie],le);ne(Te.x,Te.y,-re)}for(let ie=0,Oe=F.length;ie<Oe;ie++){const Te=F[ie];z=V[ie];for(let O=0,R=Te.length;O<R;O++){const J=A(Te[O],z[O],le);ne(J.x,J.y,-re)}}}const G=p+b;for(let W=0;W<P;W++){const ue=d?A(T[W],q[W],G):T[W];_?(C.copy(M.normals[0]).multiplyScalar(ue.x),E.copy(M.binormals[0]).multiplyScalar(ue.y),I.copy(w[0]).add(C).add(E),ne(I.x,I.y,I.z)):ne(ue.x,ue.y,0)}for(let W=1;W<=u;W++)for(let ue=0;ue<P;ue++){const re=d?A(T[ue],q[ue],G):T[ue];_?(C.copy(M.normals[W]).multiplyScalar(re.x),E.copy(M.binormals[W]).multiplyScalar(re.y),I.copy(w[W]).add(C).add(E),ne(I.x,I.y,I.z)):ne(re.x,re.y,h/u*W)}for(let W=g-1;W>=0;W--){const ue=W/g,re=m*Math.cos(ue*Math.PI/2),le=p*Math.sin(ue*Math.PI/2)+b;for(let ie=0,Oe=S.length;ie<Oe;ie++){const Te=A(S[ie],D[ie],le);ne(Te.x,Te.y,h+re)}for(let ie=0,Oe=F.length;ie<Oe;ie++){const Te=F[ie];z=V[ie];for(let O=0,R=Te.length;O<R;O++){const J=A(Te[O],z[O],le);_?ne(J.x,J.y+w[u-1].y,w[u-1].x+re):ne(J.x,J.y,h+re)}}}Y(),j();function Y(){const W=i.length/3;if(d){let ue=0,re=P*ue;for(let le=0;le<L;le++){const ie=H[le];oe(ie[2]+re,ie[1]+re,ie[0]+re)}ue=u+g*2,re=P*ue;for(let le=0;le<L;le++){const ie=H[le];oe(ie[0]+re,ie[1]+re,ie[2]+re)}}else{for(let ue=0;ue<L;ue++){const re=H[ue];oe(re[2],re[1],re[0])}for(let ue=0;ue<L;ue++){const re=H[ue];oe(re[0]+P*u,re[1]+P*u,re[2]+P*u)}}n.addGroup(W,i.length/3-W,0)}function j(){const W=i.length/3;let ue=0;X(S,ue),ue+=S.length;for(let re=0,le=F.length;re<le;re++){const ie=F[re];X(ie,ue),ue+=ie.length}n.addGroup(W,i.length/3-W,1)}function X(W,ue){let re=W.length;for(;--re>=0;){const le=re;let ie=re-1;ie<0&&(ie=W.length-1);for(let Oe=0,Te=u+g*2;Oe<Te;Oe++){const O=P*Oe,R=P*(Oe+1),J=ue+le+O,ge=ue+ie+O,pe=ue+ie+R,de=ue+le+R;he(J,ge,pe,de)}}}function ne(W,ue,re){c.push(W),c.push(ue),c.push(re)}function oe(W,ue,re){ce(W),ce(ue),ce(re);const le=i.length/3,ie=v.generateTopUV(n,i,le-3,le-2,le-1);fe(ie[0]),fe(ie[1]),fe(ie[2])}function he(W,ue,re,le){ce(W),ce(ue),ce(le),ce(ue),ce(re),ce(le);const ie=i.length/3,Oe=v.generateSideWallUV(n,i,ie-6,ie-3,ie-2,ie-1);fe(Oe[0]),fe(Oe[1]),fe(Oe[3]),fe(Oe[1]),fe(Oe[2]),fe(Oe[3])}function ce(W){i.push(c[W*3+0]),i.push(c[W*3+1]),i.push(c[W*3+2])}function fe(W){s.push(W.x),s.push(W.y)}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),t=this.parameters.shapes,n=this.parameters.options;return YH(t,n,e)}static fromJSON(e,t){const n=[];for(let s=0,o=e.shapes.length;s<o;s++){const a=t[e.shapes[s]];n.push(a)}const i=e.options.extrudePath;return i!==void 0&&(e.options.extrudePath=new Hg[i.type]().fromJSON(i)),new v0(n,e.options)}}const XH={generateTopUV:function(r,e,t,n,i){const s=e[t*3],o=e[t*3+1],a=e[n*3],c=e[n*3+1],l=e[i*3],u=e[i*3+1];return[new se(s,o),new se(a,c),new se(l,u)]},generateSideWallUV:function(r,e,t,n,i,s){const o=e[t*3],a=e[t*3+1],c=e[t*3+2],l=e[n*3],u=e[n*3+1],h=e[n*3+2],d=e[i*3],m=e[i*3+1],p=e[i*3+2],b=e[s*3],g=e[s*3+1],y=e[s*3+2];return Math.abs(a-u)<Math.abs(o-l)?[new se(o,1-c),new se(l,1-h),new se(d,1-p),new se(b,1-y)]:[new se(a,1-c),new se(u,1-h),new se(m,1-p),new se(g,1-y)]}};function YH(r,e,t){if(t.shapes=[],Array.isArray(r))for(let n=0,i=r.length;n<i;n++){const s=r[n];t.shapes.push(s.uuid)}else t.shapes.push(r.uuid);return t.options=Object.assign({},e),e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}class _0 extends Da{constructor(e=1,t=0){const n=(1+Math.sqrt(5))/2,i=[-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1],s=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(i,s,e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new _0(e.radius,e.detail)}}class rp extends Da{constructor(e=1,t=0){const n=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],i=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(n,i,e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new rp(e.radius,e.detail)}}class x0 extends Ye{constructor(e=.5,t=1,n=32,i=1,s=0,o=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:n,phiSegments:i,thetaStart:s,thetaLength:o},n=Math.max(3,n),i=Math.max(1,i);const a=[],c=[],l=[],u=[];let h=e;const d=(t-e)/i,m=new k,p=new se;for(let b=0;b<=i;b++){for(let g=0;g<=n;g++){const y=s+g/n*o;m.x=h*Math.cos(y),m.y=h*Math.sin(y),c.push(m.x,m.y,m.z),l.push(0,0,1),p.x=(m.x/t+1)/2,p.y=(m.y/t+1)/2,u.push(p.x,p.y)}h+=d}for(let b=0;b<i;b++){const g=b*(n+1);for(let y=0;y<n;y++){const v=y+g,w=v,_=v+n+1,M=v+n+2,E=v+1;a.push(w,_,E),a.push(_,M,E)}}this.setIndex(a),this.setAttribute("position",new Ce(c,3)),this.setAttribute("normal",new Ce(l,3)),this.setAttribute("uv",new Ce(u,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new x0(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}}class S0 extends Ye{constructor(e=new Mc([new se(0,.5),new se(-.5,-.5),new se(.5,-.5)]),t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const n=[],i=[],s=[],o=[];let a=0,c=0;if(Array.isArray(e)===!1)l(e);else for(let u=0;u<e.length;u++)l(e[u]),this.addGroup(a,c,u),a+=c,c=0;this.setIndex(n),this.setAttribute("position",new Ce(i,3)),this.setAttribute("normal",new Ce(s,3)),this.setAttribute("uv",new Ce(o,2));function l(u){const h=i.length/3,d=u.extractPoints(t);let m=d.shape;const p=d.holes;Es.isClockWise(m)===!1&&(m=m.reverse());for(let g=0,y=p.length;g<y;g++){const v=p[g];Es.isClockWise(v)===!0&&(p[g]=v.reverse())}const b=Es.triangulateShape(m,p);for(let g=0,y=p.length;g<y;g++){const v=p[g];m=m.concat(v)}for(let g=0,y=m.length;g<y;g++){const v=m[g];i.push(v.x,v.y,0),s.push(0,0,1),o.push(v.x,v.y)}for(let g=0,y=b.length;g<y;g++){const v=b[g],w=v[0]+h,_=v[1]+h,M=v[2]+h;n.push(w,_,M),c+=3}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),t=this.parameters.shapes;return ZH(t,e)}static fromJSON(e,t){const n=[];for(let i=0,s=e.shapes.length;i<s;i++){const o=t[e.shapes[i]];n.push(o)}return new S0(n,e.curveSegments)}}function ZH(r,e){if(e.shapes=[],Array.isArray(r))for(let t=0,n=r.length;t<n;t++){const i=r[t];e.shapes.push(i.uuid)}else e.shapes.push(r.uuid);return e}class vs extends Ye{constructor(e=1,t=32,n=16,i=0,s=Math.PI*2,o=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:n,phiStart:i,phiLength:s,thetaStart:o,thetaLength:a},t=Math.max(3,Math.floor(t)),n=Math.max(2,Math.floor(n));const c=Math.min(o+a,Math.PI);let l=0;const u=[],h=new k,d=new k,m=[],p=[],b=[],g=[];for(let y=0;y<=n;y++){const v=[],w=y/n;let _=0;y===0&&o===0?_=.5/t:y===n&&c===Math.PI&&(_=-.5/t);for(let M=0;M<=t;M++){const E=M/t;h.x=-e*Math.cos(i+E*s)*Math.sin(o+w*a),h.y=e*Math.cos(o+w*a),h.z=e*Math.sin(i+E*s)*Math.sin(o+w*a),p.push(h.x,h.y,h.z),d.copy(h).normalize(),b.push(d.x,d.y,d.z),g.push(E+_,1-w),v.push(l++)}u.push(v)}for(let y=0;y<n;y++)for(let v=0;v<t;v++){const w=u[y][v+1],_=u[y][v],M=u[y+1][v],E=u[y+1][v+1];(y!==0||o>0)&&m.push(w,_,E),(y!==n-1||c<Math.PI)&&m.push(_,M,E)}this.setIndex(m),this.setAttribute("position",new Ce(p,3)),this.setAttribute("normal",new Ce(b,3)),this.setAttribute("uv",new Ce(g,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new vs(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class E0 extends Da{constructor(e=1,t=0){const n=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],i=[2,1,0,0,3,2,1,3,0,2,3,1];super(n,i,e,t),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new E0(e.radius,e.detail)}}class M0 extends Ye{constructor(e=1,t=.4,n=12,i=48,s=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:n,tubularSegments:i,arc:s},n=Math.floor(n),i=Math.floor(i);const o=[],a=[],c=[],l=[],u=new k,h=new k,d=new k;for(let m=0;m<=n;m++)for(let p=0;p<=i;p++){const b=p/i*s,g=m/n*Math.PI*2;h.x=(e+t*Math.cos(g))*Math.cos(b),h.y=(e+t*Math.cos(g))*Math.sin(b),h.z=t*Math.sin(g),a.push(h.x,h.y,h.z),u.x=e*Math.cos(b),u.y=e*Math.sin(b),d.subVectors(h,u).normalize(),c.push(d.x,d.y,d.z),l.push(p/i),l.push(m/n)}for(let m=1;m<=n;m++)for(let p=1;p<=i;p++){const b=(i+1)*m+p-1,g=(i+1)*(m-1)+p-1,y=(i+1)*(m-1)+p,v=(i+1)*m+p;o.push(b,g,v),o.push(g,y,v)}this.setIndex(o),this.setAttribute("position",new Ce(a,3)),this.setAttribute("normal",new Ce(c,3)),this.setAttribute("uv",new Ce(l,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new M0(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}class A0 extends Ye{constructor(e=1,t=.4,n=64,i=8,s=2,o=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:n,radialSegments:i,p:s,q:o},n=Math.floor(n),i=Math.floor(i);const a=[],c=[],l=[],u=[],h=new k,d=new k,m=new k,p=new k,b=new k,g=new k,y=new k;for(let w=0;w<=n;++w){const _=w/n*s*Math.PI*2;v(_,s,o,e,m),v(_+.01,s,o,e,p),g.subVectors(p,m),y.addVectors(p,m),b.crossVectors(g,y),y.crossVectors(b,g),b.normalize(),y.normalize();for(let M=0;M<=i;++M){const E=M/i*Math.PI*2,C=-t*Math.cos(E),I=t*Math.sin(E);h.x=m.x+(C*y.x+I*b.x),h.y=m.y+(C*y.y+I*b.y),h.z=m.z+(C*y.z+I*b.z),c.push(h.x,h.y,h.z),d.subVectors(h,m).normalize(),l.push(d.x,d.y,d.z),u.push(w/n),u.push(M/i)}}for(let w=1;w<=n;w++)for(let _=1;_<=i;_++){const M=(i+1)*(w-1)+(_-1),E=(i+1)*w+(_-1),C=(i+1)*w+_,I=(i+1)*(w-1)+_;a.push(M,E,I),a.push(E,C,I)}this.setIndex(a),this.setAttribute("position",new Ce(c,3)),this.setAttribute("normal",new Ce(l,3)),this.setAttribute("uv",new Ce(u,2));function v(w,_,M,E,C){const I=Math.cos(w),x=Math.sin(w),T=M/_*w,F=Math.cos(T);C.x=E*(2+F)*.5*I,C.y=E*(2+F)*x*.5,C.z=E*Math.sin(T)*.5}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new A0(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}}class ha extends Ye{constructor(e=new QE(new k(-1,-1,0),new k(-1,1,0),new k(1,1,0)),t=64,n=1,i=8,s=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:n,radialSegments:i,closed:s};const o=e.computeFrenetFrames(t,s);this.tangents=o.tangents,this.normals=o.normals,this.binormals=o.binormals;const a=new k,c=new k,l=new se;let u=new k;const h=[],d=[],m=[],p=[];b(),this.setIndex(p),this.setAttribute("position",new Ce(h,3)),this.setAttribute("normal",new Ce(d,3)),this.setAttribute("uv",new Ce(m,2));function b(){for(let w=0;w<t;w++)g(w);g(s===!1?t:0),v(),y()}function g(w){u=e.getPointAt(w/t,u);const _=o.normals[w],M=o.binormals[w];for(let E=0;E<=i;E++){const C=E/i*Math.PI*2,I=Math.sin(C),x=-Math.cos(C);c.x=x*_.x+I*M.x,c.y=x*_.y+I*M.y,c.z=x*_.z+I*M.z,c.normalize(),d.push(c.x,c.y,c.z),a.x=u.x+n*c.x,a.y=u.y+n*c.y,a.z=u.z+n*c.z,h.push(a.x,a.y,a.z)}}function y(){for(let w=1;w<=t;w++)for(let _=1;_<=i;_++){const M=(i+1)*(w-1)+(_-1),E=(i+1)*w+(_-1),C=(i+1)*w+_,I=(i+1)*(w-1)+_;p.push(M,E,I),p.push(E,C,I)}}function v(){for(let w=0;w<=t;w++)for(let _=0;_<=i;_++)l.x=w/t,l.y=_/i,m.push(l.x,l.y)}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON();return e.path=this.parameters.path.toJSON(),e}static fromJSON(e){return new ha(new Hg[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)}}class h3 extends Ye{constructor(e=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:e},e!==null){const t=[],n=new Set,i=new k,s=new k;if(e.index!==null){const o=e.attributes.position,a=e.index;let c=e.groups;c.length===0&&(c=[{start:0,count:a.count,materialIndex:0}]);for(let l=0,u=c.length;l<u;++l){const h=c[l],d=h.start,m=h.count;for(let p=d,b=d+m;p<b;p+=3)for(let g=0;g<3;g++){const y=a.getX(p+g),v=a.getX(p+(g+1)%3);i.fromBufferAttribute(o,y),s.fromBufferAttribute(o,v),MT(i,s,n)===!0&&(t.push(i.x,i.y,i.z),t.push(s.x,s.y,s.z))}}}else{const o=e.attributes.position;for(let a=0,c=o.count/3;a<c;a++)for(let l=0;l<3;l++){const u=3*a+l,h=3*a+(l+1)%3;i.fromBufferAttribute(o,u),s.fromBufferAttribute(o,h),MT(i,s,n)===!0&&(t.push(i.x,i.y,i.z),t.push(s.x,s.y,s.z))}}this.setAttribute("position",new Ce(t,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}function MT(r,e,t){const n=`${r.x},${r.y},${r.z}-${e.x},${e.y},${e.z}`,i=`${e.x},${e.y},${e.z}-${r.x},${r.y},${r.z}`;return t.has(n)===!0||t.has(i)===!0?!1:(t.add(n),t.add(i),!0)}var AT=Object.freeze({__proto__:null,BoxGeometry:Qt,CapsuleGeometry:g0,CircleGeometry:y0,ConeGeometry:jr,CylinderGeometry:Or,DodecahedronGeometry:b0,EdgesGeometry:a3,ExtrudeGeometry:v0,IcosahedronGeometry:_0,LatheGeometry:np,OctahedronGeometry:rp,PlaneGeometry:Pc,PolyhedronGeometry:Da,RingGeometry:x0,ShapeGeometry:S0,SphereGeometry:vs,TetrahedronGeometry:E0,TorusGeometry:M0,TorusKnotGeometry:A0,TubeGeometry:ha,WireframeGeometry:h3});class d3 extends wr{constructor(e){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new ye(0),this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.fog=e.fog,this}}class f3 extends Fr{constructor(e){super(e),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class t1 extends wr{constructor(e){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new ye(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ye(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Ra,this.normalScale=new se(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class p3 extends t1{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new se(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return rn(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new ye(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new ye(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new ye(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(e)}get anisotropy(){return this._anisotropy}set anisotropy(e){this._anisotropy>0!=e>0&&this.version++,this._anisotropy=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=e.anisotropy,this.anisotropyRotation=e.anisotropyRotation,this.anisotropyMap=e.anisotropyMap,this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}class na extends wr{constructor(e){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new ye(16777215),this.specular=new ye(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ye(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Ra,this.normalScale=new se(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Jf,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class m3 extends wr{constructor(e){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new ye(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ye(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Ra,this.normalScale=new se(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}class g3 extends wr{constructor(e){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Ra,this.normalScale=new se(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}class Pt extends wr{constructor(e){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new ye(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ye(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Ra,this.normalScale=new se(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Jf,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class y3 extends wr{constructor(e){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new ye(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Ra,this.normalScale=new se(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this.fog=e.fog,this}}class b3 extends vr{constructor(e){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}function oc(r,e,t){return!r||!t&&r.constructor===e?r:typeof e.BYTES_PER_ELEMENT=="number"?new e(r):Array.prototype.slice.call(r)}function w3(r){return ArrayBuffer.isView(r)&&!(r instanceof DataView)}function v3(r){function e(i,s){return r[i]-r[s]}const t=r.length,n=new Array(t);for(let i=0;i!==t;++i)n[i]=i;return n.sort(e),n}function Gx(r,e,t){const n=r.length,i=new r.constructor(n);for(let s=0,o=0;o!==n;++s){const a=t[s]*e;for(let c=0;c!==e;++c)i[o++]=r[a+c]}return i}function n1(r,e,t,n){let i=1,s=r[0];for(;s!==void 0&&s[n]===void 0;)s=r[i++];if(s===void 0)return;let o=s[n];if(o!==void 0)if(Array.isArray(o))do o=s[n],o!==void 0&&(e.push(s.time),t.push.apply(t,o)),s=r[i++];while(s!==void 0);else if(o.toArray!==void 0)do o=s[n],o!==void 0&&(e.push(s.time),o.toArray(t,t.length)),s=r[i++];while(s!==void 0);else do o=s[n],o!==void 0&&(e.push(s.time),t.push(o)),s=r[i++];while(s!==void 0)}function JH(r,e,t,n,i=30){const s=r.clone();s.name=e;const o=[];for(let c=0;c<s.tracks.length;++c){const l=s.tracks[c],u=l.getValueSize(),h=[],d=[];for(let m=0;m<l.times.length;++m){const p=l.times[m]*i;if(!(p<t||p>=n)){h.push(l.times[m]);for(let b=0;b<u;++b)d.push(l.values[m*u+b])}}h.length!==0&&(l.times=oc(h,l.times.constructor),l.values=oc(d,l.values.constructor),o.push(l))}s.tracks=o;let a=1/0;for(let c=0;c<s.tracks.length;++c)a>s.tracks[c].times[0]&&(a=s.tracks[c].times[0]);for(let c=0;c<s.tracks.length;++c)s.tracks[c].shift(-1*a);return s.resetDuration(),s}function jH(r,e=0,t=r,n=30){n<=0&&(n=30);const i=t.tracks.length,s=e/n;for(let o=0;o<i;++o){const a=t.tracks[o],c=a.ValueTypeName;if(c==="bool"||c==="string")continue;const l=r.tracks.find(function(y){return y.name===a.name&&y.ValueTypeName===c});if(l===void 0)continue;let u=0;const h=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(u=h/3);let d=0;const m=l.getValueSize();l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=m/3);const p=a.times.length-1;let b;if(s<=a.times[0]){const y=u,v=h-u;b=a.values.slice(y,v)}else if(s>=a.times[p]){const y=p*h+u,v=y+h-u;b=a.values.slice(y,v)}else{const y=a.createInterpolant(),v=u,w=h-u;y.evaluate(s),b=y.resultBuffer.slice(v,w)}c==="quaternion"&&new Hr().fromArray(b).normalize().conjugate().toArray(b);const g=l.times.length;for(let y=0;y<g;++y){const v=y*m+d;if(c==="quaternion")Hr.multiplyQuaternionsFlat(l.values,v,b,0,l.values,v);else{const w=m-d*2;for(let _=0;_<w;++_)l.values[v+_]-=b[_]}}}return r.blendMode=RE,r}const QH={convertArray:oc,isTypedArray:w3,getKeyframeOrder:v3,sortedArray:Gx,flattenJSON:n1,subclip:JH,makeClipAdditive:jH};class ip{constructor(e,t,n,i){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new t.constructor(n),this.sampleValues=t,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let n=this._cachedIndex,i=t[n],s=t[n-1];e:{t:{let o;n:{r:if(!(e<i)){for(let a=n+2;;){if(i===void 0){if(e<s)break r;return n=t.length,this._cachedIndex=n,this.copySampleValue_(n-1)}if(n===a)break;if(s=i,i=t[++n],e<i)break t}o=t.length;break n}if(!(e>=s)){const a=t[1];e<a&&(n=2,s=a);for(let c=n-2;;){if(s===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(n===c)break;if(i=s,s=t[--n-1],e>=s)break t}o=n,n=0;break n}break e}for(;n<o;){const a=n+o>>>1;e<t[a]?o=a:n=a+1}if(i=t[n],s=t[n-1],s===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===void 0)return n=t.length,this._cachedIndex=n,this.copySampleValue_(n-1)}this._cachedIndex=n,this.intervalChanged_(n,s,i)}return this.interpolate_(n,s,e,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,i=this.valueSize,s=e*i;for(let o=0;o!==i;++o)t[o]=n[s+o];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class _3 extends ip{constructor(e,t,n,i){super(e,t,n,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:rc,endingEnd:rc}}intervalChanged_(e,t,n){const i=this.parameterPositions;let s=e-2,o=e+1,a=i[s],c=i[o];if(a===void 0)switch(this.getSettings_().endingStart){case ic:s=e,a=2*t-n;break;case Yd:s=i.length-2,a=t+i[s]-i[s+1];break;default:s=e,a=n}if(c===void 0)switch(this.getSettings_().endingEnd){case ic:o=e,c=2*n-t;break;case Yd:o=1,c=n+i[1]-i[0];break;default:o=e-1,c=t}const l=(n-t)*.5,u=this.valueSize;this._weightPrev=l/(t-a),this._weightNext=l/(c-n),this._offsetPrev=s*u,this._offsetNext=o*u}interpolate_(e,t,n,i){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,c=e*a,l=c-a,u=this._offsetPrev,h=this._offsetNext,d=this._weightPrev,m=this._weightNext,p=(n-t)/(i-t),b=p*p,g=b*p,y=-d*g+2*d*b-d*p,v=(1+d)*g+(-1.5-2*d)*b+(-.5+d)*p+1,w=(-1-m)*g+(1.5+m)*b+.5*p,_=m*g-m*b;for(let M=0;M!==a;++M)s[M]=y*o[u+M]+v*o[l+M]+w*o[c+M]+_*o[h+M];return s}}class r1 extends ip{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e,t,n,i){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,c=e*a,l=c-a,u=(n-t)/(i-t),h=1-u;for(let d=0;d!==a;++d)s[d]=o[l+d]*h+o[c+d]*u;return s}}class x3 extends ip{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e){return this.copySampleValue_(e-1)}}class ss{constructor(e,t,n,i){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=oc(t,this.TimeBufferType),this.values=oc(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let n;if(t.toJSON!==this.toJSON)n=t.toJSON(e);else{n={name:e.name,times:oc(e.times,Array),values:oc(e.values,Array)};const i=e.getInterpolation();i!==e.DefaultInterpolation&&(n.interpolation=i)}return n.type=e.ValueTypeName,n}InterpolantFactoryMethodDiscrete(e){return new x3(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new r1(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new _3(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case Kd:t=this.InterpolantFactoryMethodDiscrete;break;case Xd:t=this.InterpolantFactoryMethodLinear;break;case dg:t=this.InterpolantFactoryMethodSmooth;break}if(t===void 0){const n="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(n);return console.warn("THREE.KeyframeTrack:",n),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Kd;case this.InterpolantFactoryMethodLinear:return Xd;case this.InterpolantFactoryMethodSmooth:return dg}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]*=e}return this}trim(e,t){const n=this.times,i=n.length;let s=0,o=i-1;for(;s!==i&&n[s]<e;)++s;for(;o!==-1&&n[o]>t;)--o;if(++o,s!==0||o!==i){s>=o&&(o=Math.max(o,1),s=o-1);const a=this.getValueSize();this.times=n.slice(s,o),this.values=this.values.slice(s*a,o*a)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const n=this.times,i=this.values,s=n.length;s===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let o=null;for(let a=0;a!==s;a++){const c=n[a];if(typeof c=="number"&&isNaN(c)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,a,c),e=!1;break}if(o!==null&&o>c){console.error("THREE.KeyframeTrack: Out of order keys.",this,a,c,o),e=!1;break}o=c}if(i!==void 0&&w3(i))for(let a=0,c=i.length;a!==c;++a){const l=i[a];if(isNaN(l)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,a,l),e=!1;break}}return e}optimize(){const e=this.times.slice(),t=this.values.slice(),n=this.getValueSize(),i=this.getInterpolation()===dg,s=e.length-1;let o=1;for(let a=1;a<s;++a){let c=!1;const l=e[a],u=e[a+1];if(l!==u&&(a!==1||l!==e[0]))if(i)c=!0;else{const h=a*n,d=h-n,m=h+n;for(let p=0;p!==n;++p){const b=t[h+p];if(b!==t[d+p]||b!==t[m+p]){c=!0;break}}}if(c){if(a!==o){e[o]=e[a];const h=a*n,d=o*n;for(let m=0;m!==n;++m)t[d+m]=t[h+m]}++o}}if(s>0){e[o]=e[s];for(let a=s*n,c=o*n,l=0;l!==n;++l)t[c+l]=t[a+l];++o}return o!==e.length?(this.times=e.slice(0,o),this.values=t.slice(0,o*n)):(this.times=e,this.values=t),this}clone(){const e=this.times.slice(),t=this.values.slice(),n=this.constructor,i=new n(this.name,e,t);return i.createInterpolant=this.createInterpolant,i}}ss.prototype.TimeBufferType=Float32Array;ss.prototype.ValueBufferType=Float32Array;ss.prototype.DefaultInterpolation=Xd;class Yc extends ss{}Yc.prototype.ValueTypeName="bool";Yc.prototype.ValueBufferType=Array;Yc.prototype.DefaultInterpolation=Kd;Yc.prototype.InterpolantFactoryMethodLinear=void 0;Yc.prototype.InterpolantFactoryMethodSmooth=void 0;class i1 extends ss{}i1.prototype.ValueTypeName="color";class of extends ss{}of.prototype.ValueTypeName="number";class S3 extends ip{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e,t,n,i){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,c=(n-t)/(i-t);let l=e*a;for(let u=l+a;l!==u;l+=4)Hr.slerpFlat(s,0,o,l-a,o,l,c);return s}}class gh extends ss{InterpolantFactoryMethodLinear(e){return new S3(this.times,this.values,this.getValueSize(),e)}}gh.prototype.ValueTypeName="quaternion";gh.prototype.DefaultInterpolation=Xd;gh.prototype.InterpolantFactoryMethodSmooth=void 0;class Zc extends ss{}Zc.prototype.ValueTypeName="string";Zc.prototype.ValueBufferType=Array;Zc.prototype.DefaultInterpolation=Kd;Zc.prototype.InterpolantFactoryMethodLinear=void 0;Zc.prototype.InterpolantFactoryMethodSmooth=void 0;class af extends ss{}af.prototype.ValueTypeName="vector";class cf{constructor(e,t=-1,n,i=r0){this.name=e,this.tracks=n,this.duration=t,this.blendMode=i,this.uuid=ii(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],n=e.tracks,i=1/(e.fps||1);for(let o=0,a=n.length;o!==a;++o)t.push(tG(n[o]).scale(i));const s=new this(e.name,e.duration,t,e.blendMode);return s.uuid=e.uuid,s}static toJSON(e){const t=[],n=e.tracks,i={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let s=0,o=n.length;s!==o;++s)t.push(ss.toJSON(n[s]));return i}static CreateFromMorphTargetSequence(e,t,n,i){const s=t.length,o=[];for(let a=0;a<s;a++){let c=[],l=[];c.push((a+s-1)%s,a,(a+1)%s),l.push(0,1,0);const u=v3(c);c=Gx(c,1,u),l=Gx(l,1,u),!i&&c[0]===0&&(c.push(s),l.push(l[0])),o.push(new of(".morphTargetInfluences["+t[a].name+"]",c,l).scale(1/n))}return new this(e,-1,o)}static findByName(e,t){let n=e;if(!Array.isArray(e)){const i=e;n=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<n.length;i++)if(n[i].name===t)return n[i];return null}static CreateClipsFromMorphTargetSequences(e,t,n){const i={},s=/^([\w-]*?)([\d]+)$/;for(let a=0,c=e.length;a<c;a++){const l=e[a],u=l.name.match(s);if(u&&u.length>1){const h=u[1];let d=i[h];d||(i[h]=d=[]),d.push(l)}}const o=[];for(const a in i)o.push(this.CreateFromMorphTargetSequence(a,i[a],t,n));return o}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(h,d,m,p,b){if(m.length!==0){const g=[],y=[];n1(m,g,y,p),g.length!==0&&b.push(new h(d,g,y))}},i=[],s=e.name||"default",o=e.fps||30,a=e.blendMode;let c=e.length||-1;const l=e.hierarchy||[];for(let h=0;h<l.length;h++){const d=l[h].keys;if(!(!d||d.length===0))if(d[0].morphTargets){const m={};let p;for(p=0;p<d.length;p++)if(d[p].morphTargets)for(let b=0;b<d[p].morphTargets.length;b++)m[d[p].morphTargets[b]]=-1;for(const b in m){const g=[],y=[];for(let v=0;v!==d[p].morphTargets.length;++v){const w=d[p];g.push(w.time),y.push(w.morphTarget===b?1:0)}i.push(new of(".morphTargetInfluence["+b+"]",g,y))}c=m.length*o}else{const m=".bones["+t[h].name+"]";n(af,m+".position",d,"pos",i),n(gh,m+".quaternion",d,"rot",i),n(af,m+".scale",d,"scl",i)}}return i.length===0?null:new this(s,c,i,a)}resetDuration(){const e=this.tracks;let t=0;for(let n=0,i=e.length;n!==i;++n){const s=this.tracks[n];t=Math.max(t,s.times[s.times.length-1])}return this.duration=t,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function eG(r){switch(r.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return of;case"vector":case"vector2":case"vector3":case"vector4":return af;case"color":return i1;case"quaternion":return gh;case"bool":case"boolean":return Yc;case"string":return Zc}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+r)}function tG(r){if(r.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=eG(r.type);if(r.times===void 0){const t=[],n=[];n1(r.keys,t,n,"value"),r.times=t,r.values=n}return e.parse!==void 0?e.parse(r):new e(r.name,r.times,r.values,r.interpolation)}const so={enabled:!1,files:{},add:function(r,e){this.enabled!==!1&&(this.files[r]=e)},get:function(r){if(this.enabled!==!1)return this.files[r]},remove:function(r){delete this.files[r]},clear:function(){this.files={}}};class s1{constructor(e,t,n){const i=this;let s=!1,o=0,a=0,c;const l=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=n,this.itemStart=function(u){a++,s===!1&&i.onStart!==void 0&&i.onStart(u,o,a),s=!0},this.itemEnd=function(u){o++,i.onProgress!==void 0&&i.onProgress(u,o,a),o===a&&(s=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(u){i.onError!==void 0&&i.onError(u)},this.resolveURL=function(u){return c?c(u):u},this.setURLModifier=function(u){return c=u,this},this.addHandler=function(u,h){return l.push(u,h),this},this.removeHandler=function(u){const h=l.indexOf(u);return h!==-1&&l.splice(h,2),this},this.getHandler=function(u){for(let h=0,d=l.length;h<d;h+=2){const m=l[h],p=l[h+1];if(m.global&&(m.lastIndex=0),m.test(u))return p}return null}}}const E3=new s1;class Wr{constructor(e){this.manager=e!==void 0?e:E3,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const n=this;return new Promise(function(i,s){n.load(e,i,t,s)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}Wr.DEFAULT_MATERIAL_NAME="__DEFAULT";const zs={};class nG extends Error{constructor(e,t){super(e),this.response=t}}class Co extends Wr{constructor(e){super(e)}load(e,t,n,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=so.get(e);if(s!==void 0)return this.manager.itemStart(e),setTimeout(()=>{t&&t(s),this.manager.itemEnd(e)},0),s;if(zs[e]!==void 0){zs[e].push({onLoad:t,onProgress:n,onError:i});return}zs[e]=[],zs[e].push({onLoad:t,onProgress:n,onError:i});const o=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),a=this.mimeType,c=this.responseType;fetch(o).then(l=>{if(l.status===200||l.status===0){if(l.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||l.body===void 0||l.body.getReader===void 0)return l;const u=zs[e],h=l.body.getReader(),d=l.headers.get("Content-Length")||l.headers.get("X-File-Size"),m=d?parseInt(d):0,p=m!==0;let b=0;const g=new ReadableStream({start(y){v();function v(){h.read().then(({done:w,value:_})=>{if(w)y.close();else{b+=_.byteLength;const M=new ProgressEvent("progress",{lengthComputable:p,loaded:b,total:m});for(let E=0,C=u.length;E<C;E++){const I=u[E];I.onProgress&&I.onProgress(M)}y.enqueue(_),v()}})}}});return new Response(g)}else throw new nG(`fetch for "${l.url}" responded with ${l.status}: ${l.statusText}`,l)}).then(l=>{switch(c){case"arraybuffer":return l.arrayBuffer();case"blob":return l.blob();case"document":return l.text().then(u=>new DOMParser().parseFromString(u,a));case"json":return l.json();default:if(a===void 0)return l.text();{const h=/charset="?([^;"\s]*)"?/i.exec(a),d=h&&h[1]?h[1].toLowerCase():void 0,m=new TextDecoder(d);return l.arrayBuffer().then(p=>m.decode(p))}}}).then(l=>{so.add(e,l);const u=zs[e];delete zs[e];for(let h=0,d=u.length;h<d;h++){const m=u[h];m.onLoad&&m.onLoad(l)}}).catch(l=>{const u=zs[e];if(u===void 0)throw this.manager.itemError(e),l;delete zs[e];for(let h=0,d=u.length;h<d;h++){const m=u[h];m.onError&&m.onError(l)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class rG extends Wr{constructor(e){super(e)}load(e,t,n,i){const s=this,o=new Co(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(a){try{t(s.parse(JSON.parse(a)))}catch(c){i?i(c):console.error(c),s.manager.itemError(e)}},n,i)}parse(e){const t=[];for(let n=0;n<e.length;n++){const i=cf.parse(e[n]);t.push(i)}return t}}class iG extends Wr{constructor(e){super(e)}load(e,t,n,i){const s=this,o=[],a=new p0,c=new Co(this.manager);c.setPath(this.path),c.setResponseType("arraybuffer"),c.setRequestHeader(this.requestHeader),c.setWithCredentials(s.withCredentials);let l=0;function u(h){c.load(e[h],function(d){const m=s.parse(d,!0);o[h]={width:m.width,height:m.height,format:m.format,mipmaps:m.mipmaps},l+=1,l===6&&(m.mipmapCount===1&&(a.minFilter=un),a.image=o,a.format=m.format,a.needsUpdate=!0,t&&t(a))},n,i)}if(Array.isArray(e))for(let h=0,d=e.length;h<d;++h)u(h);else c.load(e,function(h){const d=s.parse(h,!0);if(d.isCubemap){const m=d.mipmaps.length/d.mipmapCount;for(let p=0;p<m;p++){o[p]={mipmaps:[]};for(let b=0;b<d.mipmapCount;b++)o[p].mipmaps.push(d.mipmaps[p*d.mipmapCount+b]),o[p].format=d.format,o[p].width=d.width,o[p].height=d.height}a.image=o}else a.image.width=d.width,a.image.height=d.height,a.mipmaps=d.mipmaps;d.mipmapCount===1&&(a.minFilter=un),a.format=d.format,a.needsUpdate=!0,t&&t(a)},n,i);return a}}class lf extends Wr{constructor(e){super(e)}load(e,t,n,i){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,o=so.get(e);if(o!==void 0)return s.manager.itemStart(e),setTimeout(function(){t&&t(o),s.manager.itemEnd(e)},0),o;const a=ef("img");function c(){u(),so.add(e,this),t&&t(this),s.manager.itemEnd(e)}function l(h){u(),i&&i(h),s.manager.itemError(e),s.manager.itemEnd(e)}function u(){a.removeEventListener("load",c,!1),a.removeEventListener("error",l,!1)}return a.addEventListener("load",c,!1),a.addEventListener("error",l,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(a.crossOrigin=this.crossOrigin),s.manager.itemStart(e),a.src=e,a}}class sG extends Wr{constructor(e){super(e)}load(e,t,n,i){const s=new ep;s.colorSpace=bn;const o=new lf(this.manager);o.setCrossOrigin(this.crossOrigin),o.setPath(this.path);let a=0;function c(l){o.load(e[l],function(u){s.images[l]=u,a++,a===6&&(s.needsUpdate=!0,t&&t(s))},void 0,i)}for(let l=0;l<e.length;++l)c(l);return s}}class oG extends Wr{constructor(e){super(e)}load(e,t,n,i){const s=this,o=new Ec,a=new Co(this.manager);return a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setPath(this.path),a.setWithCredentials(s.withCredentials),a.load(e,function(c){let l;try{l=s.parse(c)}catch(u){if(i!==void 0)i(u);else{console.error(u);return}}l.image!==void 0?o.image=l.image:l.data!==void 0&&(o.image.width=l.width,o.image.height=l.height,o.image.data=l.data),o.wrapS=l.wrapS!==void 0?l.wrapS:gr,o.wrapT=l.wrapT!==void 0?l.wrapT:gr,o.magFilter=l.magFilter!==void 0?l.magFilter:un,o.minFilter=l.minFilter!==void 0?l.minFilter:un,o.anisotropy=l.anisotropy!==void 0?l.anisotropy:1,l.colorSpace!==void 0?o.colorSpace=l.colorSpace:l.encoding!==void 0&&(o.encoding=l.encoding),l.flipY!==void 0&&(o.flipY=l.flipY),l.format!==void 0&&(o.format=l.format),l.type!==void 0&&(o.type=l.type),l.mipmaps!==void 0&&(o.mipmaps=l.mipmaps,o.minFilter=Sa),l.mipmapCount===1&&(o.minFilter=un),l.generateMipmaps!==void 0&&(o.generateMipmaps=l.generateMipmaps),o.needsUpdate=!0,t&&t(o,l)},n,i),o}}class aG extends Wr{constructor(e){super(e)}load(e,t,n,i){const s=new hn,o=new lf(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(e,function(a){s.image=a,s.needsUpdate=!0,t!==void 0&&t(s)},n,i),s}}class La extends wt{constructor(e,t=1){super(),this.isLight=!0,this.type="Light",this.color=new ye(e),this.intensity=t}dispose(){}copy(e,t){return super.copy(e,t),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}}class M3 extends La{constructor(e,t,n){super(e,n),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(wt.DEFAULT_UP),this.updateMatrix(),this.groundColor=new ye(t)}copy(e,t){return super.copy(e,t),this.groundColor.copy(e.groundColor),this}}const Wb=new $e,TT=new k,CT=new k;class o1{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new se(512,512),this.map=null,this.mapPass=null,this.matrix=new $e,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new tp,this._frameExtents=new se(1,1),this._viewportCount=1,this._viewports=[new mt(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,n=this.matrix;TT.setFromMatrixPosition(e.matrixWorld),t.position.copy(TT),CT.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(CT),t.updateMatrixWorld(),Wb.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Wb),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(Wb)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class cG extends o1{constructor(){super(new In(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(e){const t=this.camera,n=Fu*2*e.angle*this.focus,i=this.mapSize.width/this.mapSize.height,s=e.distance||t.far;(n!==t.fov||i!==t.aspect||s!==t.far)&&(t.fov=n,t.aspect=i,t.far=s,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class A3 extends La{constructor(e,t,n=0,i=Math.PI/3,s=0,o=2){super(e,t),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(wt.DEFAULT_UP),this.updateMatrix(),this.target=new wt,this.distance=n,this.angle=i,this.penumbra=s,this.decay=o,this.map=null,this.shadow=new cG}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}const IT=new $e,Wh=new k,qb=new k;class lG extends o1{constructor(){super(new In(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new se(4,2),this._viewportCount=6,this._viewports=[new mt(2,1,1,1),new mt(0,1,1,1),new mt(3,1,1,1),new mt(1,1,1,1),new mt(3,0,1,1),new mt(1,0,1,1)],this._cubeDirections=[new k(1,0,0),new k(-1,0,0),new k(0,0,1),new k(0,0,-1),new k(0,1,0),new k(0,-1,0)],this._cubeUps=[new k(0,1,0),new k(0,1,0),new k(0,1,0),new k(0,1,0),new k(0,0,1),new k(0,0,-1)]}updateMatrices(e,t=0){const n=this.camera,i=this.matrix,s=e.distance||n.far;s!==n.far&&(n.far=s,n.updateProjectionMatrix()),Wh.setFromMatrixPosition(e.matrixWorld),n.position.copy(Wh),qb.copy(n.position),qb.add(this._cubeDirections[t]),n.up.copy(this._cubeUps[t]),n.lookAt(qb),n.updateMatrixWorld(),i.makeTranslation(-Wh.x,-Wh.y,-Wh.z),IT.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(IT)}}class Id extends La{constructor(e,t,n=0,i=2){super(e,t),this.isPointLight=!0,this.type="PointLight",this.distance=n,this.decay=i,this.shadow=new lG}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}class uG extends o1{constructor(){super(new c0(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class a1 extends La{constructor(e,t){super(e,t),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(wt.DEFAULT_UP),this.updateMatrix(),this.target=new wt,this.shadow=new uG}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class c1 extends La{constructor(e,t){super(e,t),this.isAmbientLight=!0,this.type="AmbientLight"}}class T3 extends La{constructor(e,t,n=10,i=10){super(e,t),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=n,this.height=i}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}class C3{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new k)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const n=e.x,i=e.y,s=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.282095),t.addScaledVector(o[1],.488603*i),t.addScaledVector(o[2],.488603*s),t.addScaledVector(o[3],.488603*n),t.addScaledVector(o[4],1.092548*(n*i)),t.addScaledVector(o[5],1.092548*(i*s)),t.addScaledVector(o[6],.315392*(3*s*s-1)),t.addScaledVector(o[7],1.092548*(n*s)),t.addScaledVector(o[8],.546274*(n*n-i*i)),t}getIrradianceAt(e,t){const n=e.x,i=e.y,s=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.886227),t.addScaledVector(o[1],2*.511664*i),t.addScaledVector(o[2],2*.511664*s),t.addScaledVector(o[3],2*.511664*n),t.addScaledVector(o[4],2*.429043*n*i),t.addScaledVector(o[5],2*.429043*i*s),t.addScaledVector(o[6],.743125*s*s-.247708),t.addScaledVector(o[7],2*.429043*n*s),t.addScaledVector(o[8],.429043*(n*n-i*i)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(e.coefficients[n],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let n=0;n<9;n++)this.coefficients[n].lerp(e.coefficients[n],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].fromArray(e,t+i*3);return this}toArray(e=[],t=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].toArray(e,t+i*3);return e}static getBasisAt(e,t){const n=e.x,i=e.y,s=e.z;t[0]=.282095,t[1]=.488603*i,t[2]=.488603*s,t[3]=.488603*n,t[4]=1.092548*n*i,t[5]=1.092548*i*s,t[6]=.315392*(3*s*s-1),t[7]=1.092548*n*s,t[8]=.546274*(n*n-i*i)}}class I3 extends La{constructor(e=new C3,t=1){super(void 0,t),this.isLightProbe=!0,this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}class T0 extends Wr{constructor(e){super(e),this.textures={}}load(e,t,n,i){const s=this,o=new Co(s.manager);o.setPath(s.path),o.setRequestHeader(s.requestHeader),o.setWithCredentials(s.withCredentials),o.load(e,function(a){try{t(s.parse(JSON.parse(a)))}catch(c){i?i(c):console.error(c),s.manager.itemError(e)}},n,i)}parse(e){const t=this.textures;function n(s){return t[s]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",s),t[s]}const i=T0.createMaterialFromType(e.type);if(e.uuid!==void 0&&(i.uuid=e.uuid),e.name!==void 0&&(i.name=e.name),e.color!==void 0&&i.color!==void 0&&i.color.setHex(e.color),e.roughness!==void 0&&(i.roughness=e.roughness),e.metalness!==void 0&&(i.metalness=e.metalness),e.sheen!==void 0&&(i.sheen=e.sheen),e.sheenColor!==void 0&&(i.sheenColor=new ye().setHex(e.sheenColor)),e.sheenRoughness!==void 0&&(i.sheenRoughness=e.sheenRoughness),e.emissive!==void 0&&i.emissive!==void 0&&i.emissive.setHex(e.emissive),e.specular!==void 0&&i.specular!==void 0&&i.specular.setHex(e.specular),e.specularIntensity!==void 0&&(i.specularIntensity=e.specularIntensity),e.specularColor!==void 0&&i.specularColor!==void 0&&i.specularColor.setHex(e.specularColor),e.shininess!==void 0&&(i.shininess=e.shininess),e.clearcoat!==void 0&&(i.clearcoat=e.clearcoat),e.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=e.clearcoatRoughness),e.iridescence!==void 0&&(i.iridescence=e.iridescence),e.iridescenceIOR!==void 0&&(i.iridescenceIOR=e.iridescenceIOR),e.iridescenceThicknessRange!==void 0&&(i.iridescenceThicknessRange=e.iridescenceThicknessRange),e.transmission!==void 0&&(i.transmission=e.transmission),e.thickness!==void 0&&(i.thickness=e.thickness),e.attenuationDistance!==void 0&&(i.attenuationDistance=e.attenuationDistance),e.attenuationColor!==void 0&&i.attenuationColor!==void 0&&i.attenuationColor.setHex(e.attenuationColor),e.anisotropy!==void 0&&(i.anisotropy=e.anisotropy),e.anisotropyRotation!==void 0&&(i.anisotropyRotation=e.anisotropyRotation),e.fog!==void 0&&(i.fog=e.fog),e.flatShading!==void 0&&(i.flatShading=e.flatShading),e.blending!==void 0&&(i.blending=e.blending),e.combine!==void 0&&(i.combine=e.combine),e.side!==void 0&&(i.side=e.side),e.shadowSide!==void 0&&(i.shadowSide=e.shadowSide),e.opacity!==void 0&&(i.opacity=e.opacity),e.transparent!==void 0&&(i.transparent=e.transparent),e.alphaTest!==void 0&&(i.alphaTest=e.alphaTest),e.alphaHash!==void 0&&(i.alphaHash=e.alphaHash),e.depthFunc!==void 0&&(i.depthFunc=e.depthFunc),e.depthTest!==void 0&&(i.depthTest=e.depthTest),e.depthWrite!==void 0&&(i.depthWrite=e.depthWrite),e.colorWrite!==void 0&&(i.colorWrite=e.colorWrite),e.blendSrc!==void 0&&(i.blendSrc=e.blendSrc),e.blendDst!==void 0&&(i.blendDst=e.blendDst),e.blendEquation!==void 0&&(i.blendEquation=e.blendEquation),e.blendSrcAlpha!==void 0&&(i.blendSrcAlpha=e.blendSrcAlpha),e.blendDstAlpha!==void 0&&(i.blendDstAlpha=e.blendDstAlpha),e.blendEquationAlpha!==void 0&&(i.blendEquationAlpha=e.blendEquationAlpha),e.blendColor!==void 0&&i.blendColor!==void 0&&i.blendColor.setHex(e.blendColor),e.blendAlpha!==void 0&&(i.blendAlpha=e.blendAlpha),e.stencilWriteMask!==void 0&&(i.stencilWriteMask=e.stencilWriteMask),e.stencilFunc!==void 0&&(i.stencilFunc=e.stencilFunc),e.stencilRef!==void 0&&(i.stencilRef=e.stencilRef),e.stencilFuncMask!==void 0&&(i.stencilFuncMask=e.stencilFuncMask),e.stencilFail!==void 0&&(i.stencilFail=e.stencilFail),e.stencilZFail!==void 0&&(i.stencilZFail=e.stencilZFail),e.stencilZPass!==void 0&&(i.stencilZPass=e.stencilZPass),e.stencilWrite!==void 0&&(i.stencilWrite=e.stencilWrite),e.wireframe!==void 0&&(i.wireframe=e.wireframe),e.wireframeLinewidth!==void 0&&(i.wireframeLinewidth=e.wireframeLinewidth),e.wireframeLinecap!==void 0&&(i.wireframeLinecap=e.wireframeLinecap),e.wireframeLinejoin!==void 0&&(i.wireframeLinejoin=e.wireframeLinejoin),e.rotation!==void 0&&(i.rotation=e.rotation),e.linewidth!==void 0&&(i.linewidth=e.linewidth),e.dashSize!==void 0&&(i.dashSize=e.dashSize),e.gapSize!==void 0&&(i.gapSize=e.gapSize),e.scale!==void 0&&(i.scale=e.scale),e.polygonOffset!==void 0&&(i.polygonOffset=e.polygonOffset),e.polygonOffsetFactor!==void 0&&(i.polygonOffsetFactor=e.polygonOffsetFactor),e.polygonOffsetUnits!==void 0&&(i.polygonOffsetUnits=e.polygonOffsetUnits),e.dithering!==void 0&&(i.dithering=e.dithering),e.alphaToCoverage!==void 0&&(i.alphaToCoverage=e.alphaToCoverage),e.premultipliedAlpha!==void 0&&(i.premultipliedAlpha=e.premultipliedAlpha),e.forceSinglePass!==void 0&&(i.forceSinglePass=e.forceSinglePass),e.visible!==void 0&&(i.visible=e.visible),e.toneMapped!==void 0&&(i.toneMapped=e.toneMapped),e.userData!==void 0&&(i.userData=e.userData),e.vertexColors!==void 0&&(typeof e.vertexColors=="number"?i.vertexColors=e.vertexColors>0:i.vertexColors=e.vertexColors),e.uniforms!==void 0)for(const s in e.uniforms){const o=e.uniforms[s];switch(i.uniforms[s]={},o.type){case"t":i.uniforms[s].value=n(o.value);break;case"c":i.uniforms[s].value=new ye().setHex(o.value);break;case"v2":i.uniforms[s].value=new se().fromArray(o.value);break;case"v3":i.uniforms[s].value=new k().fromArray(o.value);break;case"v4":i.uniforms[s].value=new mt().fromArray(o.value);break;case"m3":i.uniforms[s].value=new rt().fromArray(o.value);break;case"m4":i.uniforms[s].value=new $e().fromArray(o.value);break;default:i.uniforms[s].value=o.value}}if(e.defines!==void 0&&(i.defines=e.defines),e.vertexShader!==void 0&&(i.vertexShader=e.vertexShader),e.fragmentShader!==void 0&&(i.fragmentShader=e.fragmentShader),e.glslVersion!==void 0&&(i.glslVersion=e.glslVersion),e.extensions!==void 0)for(const s in e.extensions)i.extensions[s]=e.extensions[s];if(e.lights!==void 0&&(i.lights=e.lights),e.clipping!==void 0&&(i.clipping=e.clipping),e.size!==void 0&&(i.size=e.size),e.sizeAttenuation!==void 0&&(i.sizeAttenuation=e.sizeAttenuation),e.map!==void 0&&(i.map=n(e.map)),e.matcap!==void 0&&(i.matcap=n(e.matcap)),e.alphaMap!==void 0&&(i.alphaMap=n(e.alphaMap)),e.bumpMap!==void 0&&(i.bumpMap=n(e.bumpMap)),e.bumpScale!==void 0&&(i.bumpScale=e.bumpScale),e.normalMap!==void 0&&(i.normalMap=n(e.normalMap)),e.normalMapType!==void 0&&(i.normalMapType=e.normalMapType),e.normalScale!==void 0){let s=e.normalScale;Array.isArray(s)===!1&&(s=[s,s]),i.normalScale=new se().fromArray(s)}return e.displacementMap!==void 0&&(i.displacementMap=n(e.displacementMap)),e.displacementScale!==void 0&&(i.displacementScale=e.displacementScale),e.displacementBias!==void 0&&(i.displacementBias=e.displacementBias),e.roughnessMap!==void 0&&(i.roughnessMap=n(e.roughnessMap)),e.metalnessMap!==void 0&&(i.metalnessMap=n(e.metalnessMap)),e.emissiveMap!==void 0&&(i.emissiveMap=n(e.emissiveMap)),e.emissiveIntensity!==void 0&&(i.emissiveIntensity=e.emissiveIntensity),e.specularMap!==void 0&&(i.specularMap=n(e.specularMap)),e.specularIntensityMap!==void 0&&(i.specularIntensityMap=n(e.specularIntensityMap)),e.specularColorMap!==void 0&&(i.specularColorMap=n(e.specularColorMap)),e.envMap!==void 0&&(i.envMap=n(e.envMap)),e.envMapIntensity!==void 0&&(i.envMapIntensity=e.envMapIntensity),e.reflectivity!==void 0&&(i.reflectivity=e.reflectivity),e.refractionRatio!==void 0&&(i.refractionRatio=e.refractionRatio),e.lightMap!==void 0&&(i.lightMap=n(e.lightMap)),e.lightMapIntensity!==void 0&&(i.lightMapIntensity=e.lightMapIntensity),e.aoMap!==void 0&&(i.aoMap=n(e.aoMap)),e.aoMapIntensity!==void 0&&(i.aoMapIntensity=e.aoMapIntensity),e.gradientMap!==void 0&&(i.gradientMap=n(e.gradientMap)),e.clearcoatMap!==void 0&&(i.clearcoatMap=n(e.clearcoatMap)),e.clearcoatRoughnessMap!==void 0&&(i.clearcoatRoughnessMap=n(e.clearcoatRoughnessMap)),e.clearcoatNormalMap!==void 0&&(i.clearcoatNormalMap=n(e.clearcoatNormalMap)),e.clearcoatNormalScale!==void 0&&(i.clearcoatNormalScale=new se().fromArray(e.clearcoatNormalScale)),e.iridescenceMap!==void 0&&(i.iridescenceMap=n(e.iridescenceMap)),e.iridescenceThicknessMap!==void 0&&(i.iridescenceThicknessMap=n(e.iridescenceThicknessMap)),e.transmissionMap!==void 0&&(i.transmissionMap=n(e.transmissionMap)),e.thicknessMap!==void 0&&(i.thicknessMap=n(e.thicknessMap)),e.anisotropyMap!==void 0&&(i.anisotropyMap=n(e.anisotropyMap)),e.sheenColorMap!==void 0&&(i.sheenColorMap=n(e.sheenColorMap)),e.sheenRoughnessMap!==void 0&&(i.sheenRoughnessMap=n(e.sheenRoughnessMap)),i}setTextures(e){return this.textures=e,this}static createMaterialFromType(e){const t={ShadowMaterial:d3,SpriteMaterial:WE,RawShaderMaterial:f3,ShaderMaterial:Fr,PointsMaterial:KE,MeshPhysicalMaterial:p3,MeshStandardMaterial:t1,MeshPhongMaterial:na,MeshToonMaterial:m3,MeshNormalMaterial:g3,MeshLambertMaterial:Pt,MeshDepthMaterial:zE,MeshDistanceMaterial:VE,MeshBasicMaterial:Ar,MeshMatcapMaterial:y3,LineDashedMaterial:b3,LineBasicMaterial:vr,Material:wr};return new t[e]}}class Wx{static decodeText(e){if(typeof TextDecoder<"u")return new TextDecoder().decode(e);let t="";for(let n=0,i=e.length;n<i;n++)t+=String.fromCharCode(e[n]);try{return decodeURIComponent(escape(t))}catch{return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.slice(0,t+1)}static resolveURL(e,t){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class P3 extends Ye{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}toJSON(){const e=super.toJSON();return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}class R3 extends Wr{constructor(e){super(e)}load(e,t,n,i){const s=this,o=new Co(s.manager);o.setPath(s.path),o.setRequestHeader(s.requestHeader),o.setWithCredentials(s.withCredentials),o.load(e,function(a){try{t(s.parse(JSON.parse(a)))}catch(c){i?i(c):console.error(c),s.manager.itemError(e)}},n,i)}parse(e){const t={},n={};function i(m,p){if(t[p]!==void 0)return t[p];const g=m.interleavedBuffers[p],y=s(m,g.buffer),v=Rl(g.type,y),w=new d0(v,g.stride);return w.uuid=g.uuid,t[p]=w,w}function s(m,p){if(n[p]!==void 0)return n[p];const g=m.arrayBuffers[p],y=new Uint32Array(g).buffer;return n[p]=y,y}const o=e.isInstancedBufferGeometry?new P3:new Ye,a=e.data.index;if(a!==void 0){const m=Rl(a.type,a.array);o.setIndex(new It(m,1))}const c=e.data.attributes;for(const m in c){const p=c[m];let b;if(p.isInterleavedBufferAttribute){const g=i(e.data,p.data);b=new Rc(g,p.itemSize,p.offset,p.normalized)}else{const g=Rl(p.type,p.array),y=p.isInstancedBufferAttribute?zu:It;b=new y(g,p.itemSize,p.normalized)}p.name!==void 0&&(b.name=p.name),p.usage!==void 0&&b.setUsage(p.usage),o.setAttribute(m,b)}const l=e.data.morphAttributes;if(l)for(const m in l){const p=l[m],b=[];for(let g=0,y=p.length;g<y;g++){const v=p[g];let w;if(v.isInterleavedBufferAttribute){const _=i(e.data,v.data);w=new Rc(_,v.itemSize,v.offset,v.normalized)}else{const _=Rl(v.type,v.array);w=new It(_,v.itemSize,v.normalized)}v.name!==void 0&&(w.name=v.name),b.push(w)}o.morphAttributes[m]=b}e.data.morphTargetsRelative&&(o.morphTargetsRelative=!0);const h=e.data.groups||e.data.drawcalls||e.data.offsets;if(h!==void 0)for(let m=0,p=h.length;m!==p;++m){const b=h[m];o.addGroup(b.start,b.count,b.materialIndex)}const d=e.data.boundingSphere;if(d!==void 0){const m=new k;d.center!==void 0&&m.fromArray(d.center),o.boundingSphere=new Bn(m,d.radius)}return e.name&&(o.name=e.name),e.userData&&(o.userData=e.userData),o}}class hG extends Wr{constructor(e){super(e)}load(e,t,n,i){const s=this,o=this.path===""?Wx.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||o;const a=new Co(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(c){let l=null;try{l=JSON.parse(c)}catch(h){i!==void 0&&i(h),console.error("THREE:ObjectLoader: Can't parse "+e+".",h.message);return}const u=l.metadata;if(u===void 0||u.type===void 0||u.type.toLowerCase()==="geometry"){i!==void 0&&i(new Error("THREE.ObjectLoader: Can't load "+e)),console.error("THREE.ObjectLoader: Can't load "+e);return}s.parse(l,t)},n,i)}async loadAsync(e,t){const n=this,i=this.path===""?Wx.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||i;const s=new Co(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials);const o=await s.loadAsync(e,t),a=JSON.parse(o),c=a.metadata;if(c===void 0||c.type===void 0||c.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+e);return await n.parseAsync(a)}parse(e,t){const n=this.parseAnimations(e.animations),i=this.parseShapes(e.shapes),s=this.parseGeometries(e.geometries,i),o=this.parseImages(e.images,function(){t!==void 0&&t(l)}),a=this.parseTextures(e.textures,o),c=this.parseMaterials(e.materials,a),l=this.parseObject(e.object,s,c,a,n),u=this.parseSkeletons(e.skeletons,l);if(this.bindSkeletons(l,u),t!==void 0){let h=!1;for(const d in o)if(o[d].data instanceof HTMLImageElement){h=!0;break}h===!1&&t(l)}return l}async parseAsync(e){const t=this.parseAnimations(e.animations),n=this.parseShapes(e.shapes),i=this.parseGeometries(e.geometries,n),s=await this.parseImagesAsync(e.images),o=this.parseTextures(e.textures,s),a=this.parseMaterials(e.materials,o),c=this.parseObject(e.object,i,a,o,t),l=this.parseSkeletons(e.skeletons,c);return this.bindSkeletons(c,l),c}parseShapes(e){const t={};if(e!==void 0)for(let n=0,i=e.length;n<i;n++){const s=new Mc().fromJSON(e[n]);t[s.uuid]=s}return t}parseSkeletons(e,t){const n={},i={};if(t.traverse(function(s){s.isBone&&(i[s.uuid]=s)}),e!==void 0)for(let s=0,o=e.length;s<o;s++){const a=new f0().fromJSON(e[s],i);n[a.uuid]=a}return n}parseGeometries(e,t){const n={};if(e!==void 0){const i=new R3;for(let s=0,o=e.length;s<o;s++){let a;const c=e[s];switch(c.type){case"BufferGeometry":case"InstancedBufferGeometry":a=i.parse(c);break;default:c.type in AT?a=AT[c.type].fromJSON(c,t):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${c.type}"`)}a.uuid=c.uuid,c.name!==void 0&&(a.name=c.name),c.userData!==void 0&&(a.userData=c.userData),n[c.uuid]=a}}return n}parseMaterials(e,t){const n={},i={};if(e!==void 0){const s=new T0;s.setTextures(t);for(let o=0,a=e.length;o<a;o++){const c=e[o];n[c.uuid]===void 0&&(n[c.uuid]=s.parse(c)),i[c.uuid]=n[c.uuid]}}return i}parseAnimations(e){const t={};if(e!==void 0)for(let n=0;n<e.length;n++){const i=e[n],s=cf.parse(i);t[s.uuid]=s}return t}parseImages(e,t){const n=this,i={};let s;function o(c){return n.manager.itemStart(c),s.load(c,function(){n.manager.itemEnd(c)},void 0,function(){n.manager.itemError(c),n.manager.itemEnd(c)})}function a(c){if(typeof c=="string"){const l=c,u=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(l)?l:n.resourcePath+l;return o(u)}else return c.data?{data:Rl(c.type,c.data),width:c.width,height:c.height}:null}if(e!==void 0&&e.length>0){const c=new s1(t);s=new lf(c),s.setCrossOrigin(this.crossOrigin);for(let l=0,u=e.length;l<u;l++){const h=e[l],d=h.url;if(Array.isArray(d)){const m=[];for(let p=0,b=d.length;p<b;p++){const g=d[p],y=a(g);y!==null&&(y instanceof HTMLImageElement?m.push(y):m.push(new Ec(y.data,y.width,y.height)))}i[h.uuid]=new sc(m)}else{const m=a(h.url);i[h.uuid]=new sc(m)}}}return i}async parseImagesAsync(e){const t=this,n={};let i;async function s(o){if(typeof o=="string"){const a=o,c=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(a)?a:t.resourcePath+a;return await i.loadAsync(c)}else return o.data?{data:Rl(o.type,o.data),width:o.width,height:o.height}:null}if(e!==void 0&&e.length>0){i=new lf(this.manager),i.setCrossOrigin(this.crossOrigin);for(let o=0,a=e.length;o<a;o++){const c=e[o],l=c.url;if(Array.isArray(l)){const u=[];for(let h=0,d=l.length;h<d;h++){const m=l[h],p=await s(m);p!==null&&(p instanceof HTMLImageElement?u.push(p):u.push(new Ec(p.data,p.width,p.height)))}n[c.uuid]=new sc(u)}else{const u=await s(c.url);n[c.uuid]=new sc(u)}}}return n}parseTextures(e,t){function n(s,o){return typeof s=="number"?s:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",s),o[s])}const i={};if(e!==void 0)for(let s=0,o=e.length;s<o;s++){const a=e[s];a.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',a.uuid),t[a.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",a.image);const c=t[a.image],l=c.data;let u;Array.isArray(l)?(u=new ep,l.length===6&&(u.needsUpdate=!0)):(l&&l.data?u=new Ec:u=new hn,l&&(u.needsUpdate=!0)),u.source=c,u.uuid=a.uuid,a.name!==void 0&&(u.name=a.name),a.mapping!==void 0&&(u.mapping=n(a.mapping,dG)),a.channel!==void 0&&(u.channel=a.channel),a.offset!==void 0&&u.offset.fromArray(a.offset),a.repeat!==void 0&&u.repeat.fromArray(a.repeat),a.center!==void 0&&u.center.fromArray(a.center),a.rotation!==void 0&&(u.rotation=a.rotation),a.wrap!==void 0&&(u.wrapS=n(a.wrap[0],PT),u.wrapT=n(a.wrap[1],PT)),a.format!==void 0&&(u.format=a.format),a.internalFormat!==void 0&&(u.internalFormat=a.internalFormat),a.type!==void 0&&(u.type=a.type),a.colorSpace!==void 0&&(u.colorSpace=a.colorSpace),a.encoding!==void 0&&(u.encoding=a.encoding),a.minFilter!==void 0&&(u.minFilter=n(a.minFilter,RT)),a.magFilter!==void 0&&(u.magFilter=n(a.magFilter,RT)),a.anisotropy!==void 0&&(u.anisotropy=a.anisotropy),a.flipY!==void 0&&(u.flipY=a.flipY),a.generateMipmaps!==void 0&&(u.generateMipmaps=a.generateMipmaps),a.premultiplyAlpha!==void 0&&(u.premultiplyAlpha=a.premultiplyAlpha),a.unpackAlignment!==void 0&&(u.unpackAlignment=a.unpackAlignment),a.compareFunction!==void 0&&(u.compareFunction=a.compareFunction),a.userData!==void 0&&(u.userData=a.userData),i[a.uuid]=u}return i}parseObject(e,t,n,i,s){let o;function a(d){return t[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",d),t[d]}function c(d){if(d!==void 0){if(Array.isArray(d)){const m=[];for(let p=0,b=d.length;p<b;p++){const g=d[p];n[g]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",g),m.push(n[g])}return m}return n[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",d),n[d]}}function l(d){return i[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined texture",d),i[d]}let u,h;switch(e.type){case"Scene":o=new GE,e.background!==void 0&&(Number.isInteger(e.background)?o.background=new ye(e.background):o.background=l(e.background)),e.environment!==void 0&&(o.environment=l(e.environment)),e.fog!==void 0&&(e.fog.type==="Fog"?o.fog=new h0(e.fog.color,e.fog.near,e.fog.far):e.fog.type==="FogExp2"&&(o.fog=new u0(e.fog.color,e.fog.density)),e.fog.name!==""&&(o.fog.name=e.fog.name)),e.backgroundBlurriness!==void 0&&(o.backgroundBlurriness=e.backgroundBlurriness),e.backgroundIntensity!==void 0&&(o.backgroundIntensity=e.backgroundIntensity);break;case"PerspectiveCamera":o=new In(e.fov,e.aspect,e.near,e.far),e.focus!==void 0&&(o.focus=e.focus),e.zoom!==void 0&&(o.zoom=e.zoom),e.filmGauge!==void 0&&(o.filmGauge=e.filmGauge),e.filmOffset!==void 0&&(o.filmOffset=e.filmOffset),e.view!==void 0&&(o.view=Object.assign({},e.view));break;case"OrthographicCamera":o=new c0(e.left,e.right,e.top,e.bottom,e.near,e.far),e.zoom!==void 0&&(o.zoom=e.zoom),e.view!==void 0&&(o.view=Object.assign({},e.view));break;case"AmbientLight":o=new c1(e.color,e.intensity);break;case"DirectionalLight":o=new a1(e.color,e.intensity);break;case"PointLight":o=new Id(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":o=new T3(e.color,e.intensity,e.width,e.height);break;case"SpotLight":o=new A3(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":o=new M3(e.color,e.groundColor,e.intensity);break;case"LightProbe":o=new I3().fromJSON(e);break;case"SkinnedMesh":u=a(e.geometry),h=c(e.material),o=new QL(u,h),e.bindMode!==void 0&&(o.bindMode=e.bindMode),e.bindMatrix!==void 0&&o.bindMatrix.fromArray(e.bindMatrix),e.skeleton!==void 0&&(o.skeleton=e.skeleton);break;case"Mesh":u=a(e.geometry),h=c(e.material),o=new De(u,h);break;case"InstancedMesh":u=a(e.geometry),h=c(e.material);const d=e.count,m=e.instanceMatrix,p=e.instanceColor;o=new Vg(u,h,d),o.instanceMatrix=new zu(new Float32Array(m.array),16),p!==void 0&&(o.instanceColor=new zu(new Float32Array(p.array),p.itemSize));break;case"BatchedMesh":u=a(e.geometry),h=c(e.material),o=new e3(e.maxGeometryCount,e.maxVertexCount,e.maxIndexCount,h),o.geometry=u,o.perObjectFrustumCulled=e.perObjectFrustumCulled,o.sortObjects=e.sortObjects,o._drawRanges=e.drawRanges,o._reservedRanges=e.reservedRanges,o._visibility=e.visibility,o._active=e.active,o._bounds=e.bounds.map(b=>{const g=new br;g.min.fromArray(b.boxMin),g.max.fromArray(b.boxMax);const y=new Bn;return y.radius=b.sphereRadius,y.center.fromArray(b.sphereCenter),{boxInitialized:b.boxInitialized,box:g,sphereInitialized:b.sphereInitialized,sphere:y}}),o._maxGeometryCount=e.maxGeometryCount,o._maxVertexCount=e.maxVertexCount,o._maxIndexCount=e.maxIndexCount,o._geometryInitialized=e.geometryInitialized,o._geometryCount=e.geometryCount,o._matricesTexture=l(e.matricesTexture.uuid);break;case"LOD":o=new jL;break;case"Line":o=new To(a(e.geometry),c(e.material));break;case"LineLoop":o=new t3(a(e.geometry),c(e.material));break;case"LineSegments":o=new Ls(a(e.geometry),c(e.material));break;case"PointCloud":case"Points":o=new XE(a(e.geometry),c(e.material));break;case"Sprite":o=new JL(c(e.material));break;case"Group":o=new On;break;case"Bone":o=new qE;break;default:o=new wt}if(o.uuid=e.uuid,e.name!==void 0&&(o.name=e.name),e.matrix!==void 0?(o.matrix.fromArray(e.matrix),e.matrixAutoUpdate!==void 0&&(o.matrixAutoUpdate=e.matrixAutoUpdate),o.matrixAutoUpdate&&o.matrix.decompose(o.position,o.quaternion,o.scale)):(e.position!==void 0&&o.position.fromArray(e.position),e.rotation!==void 0&&o.rotation.fromArray(e.rotation),e.quaternion!==void 0&&o.quaternion.fromArray(e.quaternion),e.scale!==void 0&&o.scale.fromArray(e.scale)),e.up!==void 0&&o.up.fromArray(e.up),e.castShadow!==void 0&&(o.castShadow=e.castShadow),e.receiveShadow!==void 0&&(o.receiveShadow=e.receiveShadow),e.shadow&&(e.shadow.bias!==void 0&&(o.shadow.bias=e.shadow.bias),e.shadow.normalBias!==void 0&&(o.shadow.normalBias=e.shadow.normalBias),e.shadow.radius!==void 0&&(o.shadow.radius=e.shadow.radius),e.shadow.mapSize!==void 0&&o.shadow.mapSize.fromArray(e.shadow.mapSize),e.shadow.camera!==void 0&&(o.shadow.camera=this.parseObject(e.shadow.camera))),e.visible!==void 0&&(o.visible=e.visible),e.frustumCulled!==void 0&&(o.frustumCulled=e.frustumCulled),e.renderOrder!==void 0&&(o.renderOrder=e.renderOrder),e.userData!==void 0&&(o.userData=e.userData),e.layers!==void 0&&(o.layers.mask=e.layers),e.children!==void 0){const d=e.children;for(let m=0;m<d.length;m++)o.add(this.parseObject(d[m],t,n,i,s))}if(e.animations!==void 0){const d=e.animations;for(let m=0;m<d.length;m++){const p=d[m];o.animations.push(s[p])}}if(e.type==="LOD"){e.autoUpdate!==void 0&&(o.autoUpdate=e.autoUpdate);const d=e.levels;for(let m=0;m<d.length;m++){const p=d[m],b=o.getObjectByProperty("uuid",p.object);b!==void 0&&o.addLevel(b,p.distance,p.hysteresis)}}return o}bindSkeletons(e,t){Object.keys(t).length!==0&&e.traverse(function(n){if(n.isSkinnedMesh===!0&&n.skeleton!==void 0){const i=t[n.skeleton];i===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",n.skeleton):n.bind(i,n.bindMatrix)}})}}const dG={UVMapping:t0,CubeReflectionMapping:Ao,CubeRefractionMapping:xa,EquirectangularReflectionMapping:Hd,EquirectangularRefractionMapping:Gd,CubeUVReflectionMapping:fh},PT={RepeatWrapping:Wd,ClampToEdgeWrapping:gr,MirroredRepeatWrapping:qd},RT={NearestFilter:ln,NearestMipmapNearestFilter:Fg,NearestMipmapLinearFilter:Ed,LinearFilter:un,LinearMipmapNearestFilter:SE,LinearMipmapLinearFilter:Sa};class fG extends Wr{constructor(e){super(e),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,n,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,o=so.get(e);if(o!==void 0){if(s.manager.itemStart(e),o.then){o.then(l=>{t&&t(l),s.manager.itemEnd(e)}).catch(l=>{i&&i(l)});return}return setTimeout(function(){t&&t(o),s.manager.itemEnd(e)},0),o}const a={};a.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",a.headers=this.requestHeader;const c=fetch(e,a).then(function(l){return l.blob()}).then(function(l){return createImageBitmap(l,Object.assign(s.options,{colorSpaceConversion:"none"}))}).then(function(l){return so.add(e,l),t&&t(l),s.manager.itemEnd(e),l}).catch(function(l){i&&i(l),so.remove(e),s.manager.itemError(e),s.manager.itemEnd(e)});so.add(e,c),s.manager.itemStart(e)}}let um;class l1{static getContext(){return um===void 0&&(um=new(window.AudioContext||window.webkitAudioContext)),um}static setContext(e){um=e}}class pG extends Wr{constructor(e){super(e)}load(e,t,n,i){const s=this,o=new Co(this.manager);o.setResponseType("arraybuffer"),o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(c){try{const l=c.slice(0);l1.getContext().decodeAudioData(l,function(h){t(h)}).catch(a)}catch(l){a(l)}},n,i);function a(c){i?i(c):console.error(c),s.manager.itemError(e)}}}const DT=new $e,LT=new $e,Va=new $e;class mG{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new In,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new In,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(e){const t=this._cache;if(t.focus!==e.focus||t.fov!==e.fov||t.aspect!==e.aspect*this.aspect||t.near!==e.near||t.far!==e.far||t.zoom!==e.zoom||t.eyeSep!==this.eyeSep){t.focus=e.focus,t.fov=e.fov,t.aspect=e.aspect*this.aspect,t.near=e.near,t.far=e.far,t.zoom=e.zoom,t.eyeSep=this.eyeSep,Va.copy(e.projectionMatrix);const i=t.eyeSep/2,s=i*t.near/t.focus,o=t.near*Math.tan(Sc*t.fov*.5)/t.zoom;let a,c;LT.elements[12]=-i,DT.elements[12]=i,a=-o*t.aspect+s,c=o*t.aspect+s,Va.elements[0]=2*t.near/(c-a),Va.elements[8]=(c+a)/(c-a),this.cameraL.projectionMatrix.copy(Va),a=-o*t.aspect-s,c=o*t.aspect-s,Va.elements[0]=2*t.near/(c-a),Va.elements[8]=(c+a)/(c-a),this.cameraR.projectionMatrix.copy(Va)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(LT),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(DT)}}class D3{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=NT(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=NT();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function NT(){return(typeof performance>"u"?Date:performance).now()}const Ha=new k,OT=new Hr,gG=new k,Ga=new k;class yG extends wt{constructor(){super(),this.type="AudioListener",this.context=l1.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new D3}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const t=this.context.listener,n=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(Ha,OT,gG),Ga.set(0,0,-1).applyQuaternion(OT),t.positionX){const i=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(Ha.x,i),t.positionY.linearRampToValueAtTime(Ha.y,i),t.positionZ.linearRampToValueAtTime(Ha.z,i),t.forwardX.linearRampToValueAtTime(Ga.x,i),t.forwardY.linearRampToValueAtTime(Ga.y,i),t.forwardZ.linearRampToValueAtTime(Ga.z,i),t.upX.linearRampToValueAtTime(n.x,i),t.upY.linearRampToValueAtTime(n.y,i),t.upZ.linearRampToValueAtTime(n.z,i)}else t.setPosition(Ha.x,Ha.y,Ha.z),t.setOrientation(Ga.x,Ga.y,Ga.z,n.x,n.y,n.z)}}class L3 extends wt{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source!==null&&(this.source.stop(),this.source.onended=null),this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this._connected!==!1){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}const Wa=new k,UT=new Hr,bG=new k,qa=new k;class wG extends L3{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){super.connect(),this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,t,n){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=n,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(Wa,UT,bG),qa.set(0,0,1).applyQuaternion(UT);const t=this.panner;if(t.positionX){const n=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(Wa.x,n),t.positionY.linearRampToValueAtTime(Wa.y,n),t.positionZ.linearRampToValueAtTime(Wa.z,n),t.orientationX.linearRampToValueAtTime(qa.x,n),t.orientationY.linearRampToValueAtTime(qa.y,n),t.orientationZ.linearRampToValueAtTime(qa.z,n)}else t.setPosition(Wa.x,Wa.y,Wa.z),t.setOrientation(qa.x,qa.y,qa.z)}}class vG{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let n=0;n<t.length;n++)e+=t[n];return e/t.length}}class N3{constructor(e,t,n){this.binding=e,this.valueSize=n;let i,s,o;switch(t){case"quaternion":i=this._slerp,s=this._slerpAdditive,o=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(n*6),this._workIndex=5;break;case"string":case"bool":i=this._select,s=this._select,o=this._setAdditiveIdentityOther,this.buffer=new Array(n*5);break;default:i=this._lerp,s=this._lerpAdditive,o=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(n*5)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=s,this._setIdentity=o,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const n=this.buffer,i=this.valueSize,s=e*i+i;let o=this.cumulativeWeight;if(o===0){for(let a=0;a!==i;++a)n[s+a]=n[a];o=t}else{o+=t;const a=t/o;this._mixBufferRegion(n,s,0,a,i)}this.cumulativeWeight=o}accumulateAdditive(e){const t=this.buffer,n=this.valueSize,i=n*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(t,i,0,e,n),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,n=this.buffer,i=e*t+t,s=this.cumulativeWeight,o=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,s<1){const c=t*this._origIndex;this._mixBufferRegion(n,i,c,1-s,t)}o>0&&this._mixBufferRegionAdditive(n,i,this._addIndex*t,1,t);for(let c=t,l=t+t;c!==l;++c)if(n[c]!==n[c+t]){a.setValue(n,i);break}}saveOriginalState(){const e=this.binding,t=this.buffer,n=this.valueSize,i=n*this._origIndex;e.getValue(t,i);for(let s=n,o=i;s!==o;++s)t[s]=t[i+s%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=this.valueSize*3;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let n=e;n<t;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[t+n]=this.buffer[e+n]}_select(e,t,n,i,s){if(i>=.5)for(let o=0;o!==s;++o)e[t+o]=e[n+o]}_slerp(e,t,n,i){Hr.slerpFlat(e,t,e,t,e,n,i)}_slerpAdditive(e,t,n,i,s){const o=this._workIndex*s;Hr.multiplyQuaternionsFlat(e,o,e,t,e,n),Hr.slerpFlat(e,t,e,t,e,o,i)}_lerp(e,t,n,i,s){const o=1-i;for(let a=0;a!==s;++a){const c=t+a;e[c]=e[c]*o+e[n+a]*i}}_lerpAdditive(e,t,n,i,s){for(let o=0;o!==s;++o){const a=t+o;e[a]=e[a]+e[n+o]*i}}}const u1="\\[\\]\\.:\\/",_G=new RegExp("["+u1+"]","g"),h1="[^"+u1+"]",xG="[^"+u1.replace("\\.","")+"]",SG=/((?:WC+[\/:])*)/.source.replace("WC",h1),EG=/(WCOD+)?/.source.replace("WCOD",xG),MG=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",h1),AG=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",h1),TG=new RegExp("^"+SG+EG+MG+AG+"$"),CG=["material","materials","bones","map"];class IG{constructor(e,t,n){const i=n||ft.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,i)}getValue(e,t){this.bind();const n=this._targetGroup.nCachedObjects_,i=this._bindings[n];i!==void 0&&i.getValue(e,t)}setValue(e,t){const n=this._bindings;for(let i=this._targetGroup.nCachedObjects_,s=n.length;i!==s;++i)n[i].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].unbind()}}class ft{constructor(e,t,n){this.path=t,this.parsedPath=n||ft.parseTrackName(t),this.node=ft.findNode(e,this.parsedPath.nodeName),this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,n){return e&&e.isAnimationObjectGroup?new ft.Composite(e,t,n):new ft(e,t,n)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(_G,"")}static parseTrackName(e){const t=TG.exec(e);if(t===null)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const n={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const s=n.nodeName.substring(i+1);CG.indexOf(s)!==-1&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=s)}if(n.propertyName===null||n.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return n}static findNode(e,t){if(t===void 0||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const n=e.skeleton.getBoneByName(t);if(n!==void 0)return n}if(e.children){const n=function(s){for(let o=0;o<s.length;o++){const a=s[o];if(a.name===t||a.uuid===t)return a;const c=n(a.children);if(c)return c}return null},i=n(e.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)e[t++]=n[i]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)n[i]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)n[i]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)n[i]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,n=t.objectName,i=t.propertyName;let s=t.propertyIndex;if(e||(e=ft.findNode(this.rootNode,t.nodeName),this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(n){let l=t.objectIndex;switch(n){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let u=0;u<e.length;u++)if(e[u].name===l){l=u;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}e=e.material.map;break;default:if(e[n]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[n]}if(l!==void 0){if(e[l]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[l]}}const o=e[i];if(o===void 0){const l=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+l+"."+i+" but it wasn't found.",e);return}let a=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?a=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(a=this.Versioning.MatrixWorldNeedsUpdate);let c=this.BindingType.Direct;if(s!==void 0){if(i==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[s]!==void 0&&(s=e.morphTargetDictionary[s])}c=this.BindingType.ArrayElement,this.resolvedProperty=o,this.propertyIndex=s}else o.fromArray!==void 0&&o.toArray!==void 0?(c=this.BindingType.HasFromToArray,this.resolvedProperty=o):Array.isArray(o)?(c=this.BindingType.EntireArray,this.resolvedProperty=o):this.propertyName=i;this.getValue=this.GetterByBindingType[c],this.setValue=this.SetterByBindingTypeAndVersioning[c][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}ft.Composite=IG;ft.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};ft.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};ft.prototype.GetterByBindingType=[ft.prototype._getValue_direct,ft.prototype._getValue_array,ft.prototype._getValue_arrayElement,ft.prototype._getValue_toArray];ft.prototype.SetterByBindingTypeAndVersioning=[[ft.prototype._setValue_direct,ft.prototype._setValue_direct_setNeedsUpdate,ft.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[ft.prototype._setValue_array,ft.prototype._setValue_array_setNeedsUpdate,ft.prototype._setValue_array_setMatrixWorldNeedsUpdate],[ft.prototype._setValue_arrayElement,ft.prototype._setValue_arrayElement_setNeedsUpdate,ft.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[ft.prototype._setValue_fromArray,ft.prototype._setValue_fromArray_setNeedsUpdate,ft.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class PG{constructor(){this.isAnimationObjectGroup=!0,this.uuid=ii(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let n=0,i=arguments.length;n!==i;++n)e[arguments[n].uuid]=n;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}add(){const e=this._objects,t=this._indicesByUUID,n=this._paths,i=this._parsedPaths,s=this._bindings,o=s.length;let a,c=e.length,l=this.nCachedObjects_;for(let u=0,h=arguments.length;u!==h;++u){const d=arguments[u],m=d.uuid;let p=t[m];if(p===void 0){p=c++,t[m]=p,e.push(d);for(let b=0,g=o;b!==g;++b)s[b].push(new ft(d,n[b],i[b]))}else if(p<l){a=e[p];const b=--l,g=e[b];t[g.uuid]=p,e[p]=g,t[m]=b,e[b]=d;for(let y=0,v=o;y!==v;++y){const w=s[y],_=w[b];let M=w[p];w[p]=_,M===void 0&&(M=new ft(d,n[y],i[y])),w[b]=M}}else e[p]!==a&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=l}remove(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,i=n.length;let s=this.nCachedObjects_;for(let o=0,a=arguments.length;o!==a;++o){const c=arguments[o],l=c.uuid,u=t[l];if(u!==void 0&&u>=s){const h=s++,d=e[h];t[d.uuid]=u,e[u]=d,t[l]=h,e[h]=c;for(let m=0,p=i;m!==p;++m){const b=n[m],g=b[h],y=b[u];b[u]=g,b[h]=y}}}this.nCachedObjects_=s}uncache(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,i=n.length;let s=this.nCachedObjects_,o=e.length;for(let a=0,c=arguments.length;a!==c;++a){const l=arguments[a],u=l.uuid,h=t[u];if(h!==void 0)if(delete t[u],h<s){const d=--s,m=e[d],p=--o,b=e[p];t[m.uuid]=h,e[h]=m,t[b.uuid]=d,e[d]=b,e.pop();for(let g=0,y=i;g!==y;++g){const v=n[g],w=v[d],_=v[p];v[h]=w,v[d]=_,v.pop()}}else{const d=--o,m=e[d];d>0&&(t[m.uuid]=h),e[h]=m,e.pop();for(let p=0,b=i;p!==b;++p){const g=n[p];g[h]=g[d],g.pop()}}}this.nCachedObjects_=s}subscribe_(e,t){const n=this._bindingsIndicesByPath;let i=n[e];const s=this._bindings;if(i!==void 0)return s[i];const o=this._paths,a=this._parsedPaths,c=this._objects,l=c.length,u=this.nCachedObjects_,h=new Array(l);i=s.length,n[e]=i,o.push(e),a.push(t),s.push(h);for(let d=u,m=c.length;d!==m;++d){const p=c[d];h[d]=new ft(p,e,t)}return h}unsubscribe_(e){const t=this._bindingsIndicesByPath,n=t[e];if(n!==void 0){const i=this._paths,s=this._parsedPaths,o=this._bindings,a=o.length-1,c=o[a],l=e[a];t[l]=n,o[n]=c,o.pop(),s[n]=s[a],s.pop(),i[n]=i[a],i.pop()}}}class O3{constructor(e,t,n=null,i=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=n,this.blendMode=i;const s=t.tracks,o=s.length,a=new Array(o),c={endingStart:rc,endingEnd:rc};for(let l=0;l!==o;++l){const u=s[l].createInterpolant(null);a[l]=u,u.settings=c}this._interpolantSettings=c,this._interpolants=a,this._propertyBindings=new Array(o),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=_L,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,n){if(e.fadeOut(t),this.fadeIn(t),n){const i=this._clip.duration,s=e._clip.duration,o=s/i,a=i/s;e.warp(1,o,t),this.warp(a,1,t)}return this}crossFadeTo(e,t,n){return e.crossFadeFrom(this,t,n)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,n){const i=this._mixer,s=i.time,o=this.timeScale;let a=this._timeScaleInterpolant;a===null&&(a=i._lendControlInterpolant(),this._timeScaleInterpolant=a);const c=a.parameterPositions,l=a.sampleValues;return c[0]=s,c[1]=s+n,l[0]=e/o,l[1]=t/o,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,n,i){if(!this.enabled){this._updateWeight(e);return}const s=this._startTime;if(s!==null){const c=(e-s)*n;c<0||n===0?t=0:(this._startTime=null,t=n*c)}t*=this._updateTimeScale(e);const o=this._updateTime(t),a=this._updateWeight(e);if(a>0){const c=this._interpolants,l=this._propertyBindings;switch(this.blendMode){case RE:for(let u=0,h=c.length;u!==h;++u)c[u].evaluate(o),l[u].accumulateAdditive(a);break;case r0:default:for(let u=0,h=c.length;u!==h;++u)c[u].evaluate(o),l[u].accumulate(i,a)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const n=this._weightInterpolant;if(n!==null){const i=n.evaluate(e)[0];t*=i,e>n.parameterPositions[1]&&(this.stopFading(),i===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const n=this._timeScaleInterpolant;if(n!==null){const i=n.evaluate(e)[0];t*=i,e>n.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t)}}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,n=this.loop;let i=this.time+e,s=this._loopCount;const o=n===xL;if(e===0)return s===-1?i:o&&(s&1)===1?t-i:i;if(n===vL){s===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(i>=t)i=t;else if(i<0)i=0;else{this.time=i;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(s===-1&&(e>=0?(s=0,this._setEndings(!0,this.repetitions===0,o)):this._setEndings(this.repetitions===0,!0,o)),i>=t||i<0){const a=Math.floor(i/t);i-=t*a,s+=Math.abs(a);const c=this.repetitions-s;if(c<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=e>0?t:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(c===1){const l=e<0;this._setEndings(l,!l,o)}else this._setEndings(!1,!1,o);this._loopCount=s,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:a})}}else this.time=i;if(o&&(s&1)===1)return t-i}return i}_setEndings(e,t,n){const i=this._interpolantSettings;n?(i.endingStart=ic,i.endingEnd=ic):(e?i.endingStart=this.zeroSlopeAtStart?ic:rc:i.endingStart=Yd,t?i.endingEnd=this.zeroSlopeAtEnd?ic:rc:i.endingEnd=Yd)}_scheduleFading(e,t,n){const i=this._mixer,s=i.time;let o=this._weightInterpolant;o===null&&(o=i._lendControlInterpolant(),this._weightInterpolant=o);const a=o.parameterPositions,c=o.sampleValues;return a[0]=s,c[0]=t,a[1]=s+e,c[1]=n,this}}const RG=new Float32Array(1);class DG extends Do{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const n=e._localRoot||this._root,i=e._clip.tracks,s=i.length,o=e._propertyBindings,a=e._interpolants,c=n.uuid,l=this._bindingsByRootAndName;let u=l[c];u===void 0&&(u={},l[c]=u);for(let h=0;h!==s;++h){const d=i[h],m=d.name;let p=u[m];if(p!==void 0)++p.referenceCount,o[h]=p;else{if(p=o[h],p!==void 0){p._cacheIndex===null&&(++p.referenceCount,this._addInactiveBinding(p,c,m));continue}const b=t&&t._propertyBindings[h].binding.parsedPath;p=new N3(ft.create(n,m,b),d.ValueTypeName,d.getValueSize()),++p.referenceCount,this._addInactiveBinding(p,c,m),o[h]=p}a[h].resultBuffer=p.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const n=(e._localRoot||this._root).uuid,i=e._clip.uuid,s=this._actionsByClip[i];this._bindAction(e,s&&s.knownActions[0]),this._addInactiveAction(e,i,n)}const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const s=t[n];s.useCount++===0&&(this._lendBinding(s),s.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const s=t[n];--s.useCount===0&&(s.restoreOriginalState(),this._takeBackBinding(s))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return t!==null&&t<this._nActiveActions}_addInactiveAction(e,t,n){const i=this._actions,s=this._actionsByClip;let o=s[t];if(o===void 0)o={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,s[t]=o;else{const a=o.knownActions;e._byClipCacheIndex=a.length,a.push(e)}e._cacheIndex=i.length,i.push(e),o.actionByRoot[n]=e}_removeInactiveAction(e){const t=this._actions,n=t[t.length-1],i=e._cacheIndex;n._cacheIndex=i,t[i]=n,t.pop(),e._cacheIndex=null;const s=e._clip.uuid,o=this._actionsByClip,a=o[s],c=a.knownActions,l=c[c.length-1],u=e._byClipCacheIndex;l._byClipCacheIndex=u,c[u]=l,c.pop(),e._byClipCacheIndex=null;const h=a.actionByRoot,d=(e._localRoot||this._root).uuid;delete h[d],c.length===0&&delete o[s],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const s=t[n];--s.referenceCount===0&&this._removeInactiveBinding(s)}}_lendAction(e){const t=this._actions,n=e._cacheIndex,i=this._nActiveActions++,s=t[i];e._cacheIndex=i,t[i]=e,s._cacheIndex=n,t[n]=s}_takeBackAction(e){const t=this._actions,n=e._cacheIndex,i=--this._nActiveActions,s=t[i];e._cacheIndex=i,t[i]=e,s._cacheIndex=n,t[n]=s}_addInactiveBinding(e,t,n){const i=this._bindingsByRootAndName,s=this._bindings;let o=i[t];o===void 0&&(o={},i[t]=o),o[n]=e,e._cacheIndex=s.length,s.push(e)}_removeInactiveBinding(e){const t=this._bindings,n=e.binding,i=n.rootNode.uuid,s=n.path,o=this._bindingsByRootAndName,a=o[i],c=t[t.length-1],l=e._cacheIndex;c._cacheIndex=l,t[l]=c,t.pop(),delete a[s],Object.keys(a).length===0&&delete o[i]}_lendBinding(e){const t=this._bindings,n=e._cacheIndex,i=this._nActiveBindings++,s=t[i];e._cacheIndex=i,t[i]=e,s._cacheIndex=n,t[n]=s}_takeBackBinding(e){const t=this._bindings,n=e._cacheIndex,i=--this._nActiveBindings,s=t[i];e._cacheIndex=i,t[i]=e,s._cacheIndex=n,t[n]=s}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let n=e[t];return n===void 0&&(n=new r1(new Float32Array(2),new Float32Array(2),1,RG),n.__cacheIndex=t,e[t]=n),n}_takeBackControlInterpolant(e){const t=this._controlInterpolants,n=e.__cacheIndex,i=--this._nActiveControlInterpolants,s=t[i];e.__cacheIndex=i,t[i]=e,s.__cacheIndex=n,t[n]=s}clipAction(e,t,n){const i=t||this._root,s=i.uuid;let o=typeof e=="string"?cf.findByName(i,e):e;const a=o!==null?o.uuid:e,c=this._actionsByClip[a];let l=null;if(n===void 0&&(o!==null?n=o.blendMode:n=r0),c!==void 0){const h=c.actionByRoot[s];if(h!==void 0&&h.blendMode===n)return h;l=c.knownActions[0],o===null&&(o=l._clip)}if(o===null)return null;const u=new O3(this,o,t,n);return this._bindAction(u,l),this._addInactiveAction(u,a,s),u}existingAction(e,t){const n=t||this._root,i=n.uuid,s=typeof e=="string"?cf.findByName(n,e):e,o=s?s.uuid:e,a=this._actionsByClip[o];return a!==void 0&&a.actionByRoot[i]||null}stopAllAction(){const e=this._actions,t=this._nActiveActions;for(let n=t-1;n>=0;--n)e[n].stop();return this}update(e){e*=this.timeScale;const t=this._actions,n=this._nActiveActions,i=this.time+=e,s=Math.sign(e),o=this._accuIndex^=1;for(let l=0;l!==n;++l)t[l]._update(i,e,s,o);const a=this._bindings,c=this._nActiveBindings;for(let l=0;l!==c;++l)a[l].apply(o);return this}setTime(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,n=e.uuid,i=this._actionsByClip,s=i[n];if(s!==void 0){const o=s.knownActions;for(let a=0,c=o.length;a!==c;++a){const l=o[a];this._deactivateAction(l);const u=l._cacheIndex,h=t[t.length-1];l._cacheIndex=null,l._byClipCacheIndex=null,h._cacheIndex=u,t[u]=h,t.pop(),this._removeInactiveBindingsForAction(l)}delete i[n]}}uncacheRoot(e){const t=e.uuid,n=this._actionsByClip;for(const o in n){const a=n[o].actionByRoot,c=a[t];c!==void 0&&(this._deactivateAction(c),this._removeInactiveAction(c))}const i=this._bindingsByRootAndName,s=i[t];if(s!==void 0)for(const o in s){const a=s[o];a.restoreOriginalState(),this._removeInactiveBinding(a)}}uncacheAction(e,t){const n=this.existingAction(e,t);n!==null&&(this._deactivateAction(n),this._removeInactiveAction(n))}}class d1{constructor(e){this.value=e}clone(){return new d1(this.value.clone===void 0?this.value:this.value.clone())}}let LG=0;class NG extends Do{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:LG++}),this.name="",this.usage=Qd,this.uniforms=[]}add(e){return this.uniforms.push(e),this}remove(e){const t=this.uniforms.indexOf(e);return t!==-1&&this.uniforms.splice(t,1),this}setName(e){return this.name=e,this}setUsage(e){return this.usage=e,this}dispose(){return this.dispatchEvent({type:"dispose"}),this}copy(e){this.name=e.name,this.usage=e.usage;const t=e.uniforms;this.uniforms.length=0;for(let n=0,i=t.length;n<i;n++){const s=Array.isArray(t[n])?t[n]:[t[n]];for(let o=0;o<s.length;o++)this.uniforms.push(s[o].clone())}return this}clone(){return new this.constructor().copy(this)}}class OG extends d0{constructor(e,t,n=1){super(e,t),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=n}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){const t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}class UG{constructor(e,t,n,i,s){this.isGLBufferAttribute=!0,this.name="",this.buffer=e,this.type=t,this.itemSize=n,this.elementSize=i,this.count=s,this.version=0}set needsUpdate(e){e===!0&&this.version++}setBuffer(e){return this.buffer=e,this}setType(e,t){return this.type=e,this.elementSize=t,this}setItemSize(e){return this.itemSize=e,this}setCount(e){return this.count=e,this}}class kG{constructor(e,t,n=0,i=1/0){this.ray=new ph(e,t),this.near=n,this.far=i,this.camera=null,this.layers=new o0,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,t){this.ray.set(e,t)}setFromCamera(e,t){t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)}intersectObject(e,t=!0,n=[]){return qx(e,this,n,t),n.sort(kT),n}intersectObjects(e,t=!0,n=[]){for(let i=0,s=e.length;i<s;i++)qx(e[i],this,n,t);return n.sort(kT),n}}function kT(r,e){return r.distance-e.distance}function qx(r,e,t,n){if(r.layers.test(e.layers)&&r.raycast(e,t),n===!0){const i=r.children;for(let s=0,o=i.length;s<o;s++)qx(i[s],e,t,!0)}}class BG{constructor(e=1,t=0,n=0){return this.radius=e,this.phi=t,this.theta=n,this}set(e,t,n){return this.radius=e,this.phi=t,this.theta=n,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+t*t+n*n),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,n),this.phi=Math.acos(rn(t/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class FG{constructor(e=1,t=0,n=0){return this.radius=e,this.theta=t,this.y=n,this}set(e,t,n){return this.radius=e,this.theta=t,this.y=n,this}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+n*n),this.theta=Math.atan2(e,n),this.y=t,this}clone(){return new this.constructor().copy(this)}}const BT=new se;class $G{constructor(e=new se(1/0,1/0),t=new se(-1/0,-1/0)){this.isBox2=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=BT.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,BT).distanceTo(e)}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const FT=new k,hm=new k;class zG{constructor(e=new k,t=new k){this.start=e,this.end=t}set(e,t){return this.start.copy(e),this.end.copy(t),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){FT.subVectors(e,this.start),hm.subVectors(this.end,this.start);const n=hm.dot(hm);let s=hm.dot(FT)/n;return t&&(s=rn(s,0,1)),s}closestPointToPoint(e,t,n){const i=this.closestPointToPointParameter(e,t);return this.delta(n).multiplyScalar(i).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const $T=new k;class VG extends wt{constructor(e,t){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=t,this.type="SpotLightHelper";const n=new Ye,i=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let o=0,a=1,c=32;o<c;o++,a++){const l=o/c*Math.PI*2,u=a/c*Math.PI*2;i.push(Math.cos(l),Math.sin(l),1,Math.cos(u),Math.sin(u),1)}n.setAttribute("position",new Ce(i,3));const s=new vr({fog:!1,toneMapped:!1});this.cone=new Ls(n,s),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1);const e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),$T.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt($T),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const Ho=new k,dm=new $e,Kb=new $e;class HG extends Ls{constructor(e){const t=U3(e),n=new Ye,i=[],s=[],o=new ye(0,0,1),a=new ye(0,1,0);for(let l=0;l<t.length;l++){const u=t[l];u.parent&&u.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),s.push(o.r,o.g,o.b),s.push(a.r,a.g,a.b))}n.setAttribute("position",new Ce(i,3)),n.setAttribute("color",new Ce(s,3));const c=new vr({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(n,c),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,n=this.geometry,i=n.getAttribute("position");Kb.copy(this.root.matrixWorld).invert();for(let s=0,o=0;s<t.length;s++){const a=t[s];a.parent&&a.parent.isBone&&(dm.multiplyMatrices(Kb,a.matrixWorld),Ho.setFromMatrixPosition(dm),i.setXYZ(o,Ho.x,Ho.y,Ho.z),dm.multiplyMatrices(Kb,a.parent.matrixWorld),Ho.setFromMatrixPosition(dm),i.setXYZ(o+1,Ho.x,Ho.y,Ho.z),o+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose()}}function U3(r){const e=[];r.isBone===!0&&e.push(r);for(let t=0;t<r.children.length;t++)e.push.apply(e,U3(r.children[t]));return e}class GG extends De{constructor(e,t,n){const i=new vs(t,4,2),s=new Ar({wireframe:!0,fog:!1,toneMapped:!1});super(i,s),this.light=e,this.color=n,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const WG=new k,zT=new ye,VT=new ye;class qG extends wt{constructor(e,t,n){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,this.type="HemisphereLightHelper";const i=new rp(t);i.rotateY(Math.PI*.5),this.material=new Ar({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const s=i.getAttribute("position"),o=new Float32Array(s.count*3);i.setAttribute("color",new It(o,3)),this.add(new De(i,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");zT.copy(this.light.color),VT.copy(this.light.groundColor);for(let n=0,i=t.count;n<i;n++){const s=n<i/2?zT:VT;t.setXYZ(n,s.r,s.g,s.b)}t.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),e.lookAt(WG.setFromMatrixPosition(this.light.matrixWorld).negate())}}class KG extends Ls{constructor(e=10,t=10,n=4473924,i=8947848){n=new ye(n),i=new ye(i);const s=t/2,o=e/t,a=e/2,c=[],l=[];for(let d=0,m=0,p=-a;d<=t;d++,p+=o){c.push(-a,0,p,a,0,p),c.push(p,0,-a,p,0,a);const b=d===s?n:i;b.toArray(l,m),m+=3,b.toArray(l,m),m+=3,b.toArray(l,m),m+=3,b.toArray(l,m),m+=3}const u=new Ye;u.setAttribute("position",new Ce(c,3)),u.setAttribute("color",new Ce(l,3));const h=new vr({vertexColors:!0,toneMapped:!1});super(u,h),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class XG extends Ls{constructor(e=10,t=16,n=8,i=64,s=4473924,o=8947848){s=new ye(s),o=new ye(o);const a=[],c=[];if(t>1)for(let h=0;h<t;h++){const d=h/t*(Math.PI*2),m=Math.sin(d)*e,p=Math.cos(d)*e;a.push(0,0,0),a.push(m,0,p);const b=h&1?s:o;c.push(b.r,b.g,b.b),c.push(b.r,b.g,b.b)}for(let h=0;h<n;h++){const d=h&1?s:o,m=e-e/n*h;for(let p=0;p<i;p++){let b=p/i*(Math.PI*2),g=Math.sin(b)*m,y=Math.cos(b)*m;a.push(g,0,y),c.push(d.r,d.g,d.b),b=(p+1)/i*(Math.PI*2),g=Math.sin(b)*m,y=Math.cos(b)*m,a.push(g,0,y),c.push(d.r,d.g,d.b)}}const l=new Ye;l.setAttribute("position",new Ce(a,3)),l.setAttribute("color",new Ce(c,3));const u=new vr({vertexColors:!0,toneMapped:!1});super(l,u),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const HT=new k,fm=new k,GT=new k;class YG extends wt{constructor(e,t,n){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,this.type="DirectionalLightHelper",t===void 0&&(t=1);let i=new Ye;i.setAttribute("position",new Ce([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const s=new vr({fog:!1,toneMapped:!1});this.lightPlane=new To(i,s),this.add(this.lightPlane),i=new Ye,i.setAttribute("position",new Ce([0,0,0,0,0,1],3)),this.targetLine=new To(i,s),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),HT.setFromMatrixPosition(this.light.matrixWorld),fm.setFromMatrixPosition(this.light.target.matrixWorld),GT.subVectors(fm,HT),this.lightPlane.lookAt(fm),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(fm),this.targetLine.scale.z=GT.length()}}const pm=new k,jt=new a0;class ZG extends Ls{constructor(e){const t=new Ye,n=new vr({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],s=[],o={};a("n1","n2"),a("n2","n4"),a("n4","n3"),a("n3","n1"),a("f1","f2"),a("f2","f4"),a("f4","f3"),a("f3","f1"),a("n1","f1"),a("n2","f2"),a("n3","f3"),a("n4","f4"),a("p","n1"),a("p","n2"),a("p","n3"),a("p","n4"),a("u1","u2"),a("u2","u3"),a("u3","u1"),a("c","t"),a("p","c"),a("cn1","cn2"),a("cn3","cn4"),a("cf1","cf2"),a("cf3","cf4");function a(p,b){c(p),c(b)}function c(p){i.push(0,0,0),s.push(0,0,0),o[p]===void 0&&(o[p]=[]),o[p].push(i.length/3-1)}t.setAttribute("position",new Ce(i,3)),t.setAttribute("color",new Ce(s,3)),super(t,n),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=o,this.update();const l=new ye(16755200),u=new ye(16711680),h=new ye(43775),d=new ye(16777215),m=new ye(3355443);this.setColors(l,u,h,d,m)}setColors(e,t,n,i,s){const a=this.geometry.getAttribute("color");a.setXYZ(0,e.r,e.g,e.b),a.setXYZ(1,e.r,e.g,e.b),a.setXYZ(2,e.r,e.g,e.b),a.setXYZ(3,e.r,e.g,e.b),a.setXYZ(4,e.r,e.g,e.b),a.setXYZ(5,e.r,e.g,e.b),a.setXYZ(6,e.r,e.g,e.b),a.setXYZ(7,e.r,e.g,e.b),a.setXYZ(8,e.r,e.g,e.b),a.setXYZ(9,e.r,e.g,e.b),a.setXYZ(10,e.r,e.g,e.b),a.setXYZ(11,e.r,e.g,e.b),a.setXYZ(12,e.r,e.g,e.b),a.setXYZ(13,e.r,e.g,e.b),a.setXYZ(14,e.r,e.g,e.b),a.setXYZ(15,e.r,e.g,e.b),a.setXYZ(16,e.r,e.g,e.b),a.setXYZ(17,e.r,e.g,e.b),a.setXYZ(18,e.r,e.g,e.b),a.setXYZ(19,e.r,e.g,e.b),a.setXYZ(20,e.r,e.g,e.b),a.setXYZ(21,e.r,e.g,e.b),a.setXYZ(22,e.r,e.g,e.b),a.setXYZ(23,e.r,e.g,e.b),a.setXYZ(24,t.r,t.g,t.b),a.setXYZ(25,t.r,t.g,t.b),a.setXYZ(26,t.r,t.g,t.b),a.setXYZ(27,t.r,t.g,t.b),a.setXYZ(28,t.r,t.g,t.b),a.setXYZ(29,t.r,t.g,t.b),a.setXYZ(30,t.r,t.g,t.b),a.setXYZ(31,t.r,t.g,t.b),a.setXYZ(32,n.r,n.g,n.b),a.setXYZ(33,n.r,n.g,n.b),a.setXYZ(34,n.r,n.g,n.b),a.setXYZ(35,n.r,n.g,n.b),a.setXYZ(36,n.r,n.g,n.b),a.setXYZ(37,n.r,n.g,n.b),a.setXYZ(38,i.r,i.g,i.b),a.setXYZ(39,i.r,i.g,i.b),a.setXYZ(40,s.r,s.g,s.b),a.setXYZ(41,s.r,s.g,s.b),a.setXYZ(42,s.r,s.g,s.b),a.setXYZ(43,s.r,s.g,s.b),a.setXYZ(44,s.r,s.g,s.b),a.setXYZ(45,s.r,s.g,s.b),a.setXYZ(46,s.r,s.g,s.b),a.setXYZ(47,s.r,s.g,s.b),a.setXYZ(48,s.r,s.g,s.b),a.setXYZ(49,s.r,s.g,s.b),a.needsUpdate=!0}update(){const e=this.geometry,t=this.pointMap,n=1,i=1;jt.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),an("c",t,e,jt,0,0,-1),an("t",t,e,jt,0,0,1),an("n1",t,e,jt,-n,-i,-1),an("n2",t,e,jt,n,-i,-1),an("n3",t,e,jt,-n,i,-1),an("n4",t,e,jt,n,i,-1),an("f1",t,e,jt,-n,-i,1),an("f2",t,e,jt,n,-i,1),an("f3",t,e,jt,-n,i,1),an("f4",t,e,jt,n,i,1),an("u1",t,e,jt,n*.7,i*1.1,-1),an("u2",t,e,jt,-n*.7,i*1.1,-1),an("u3",t,e,jt,0,i*2,-1),an("cf1",t,e,jt,-n,0,1),an("cf2",t,e,jt,n,0,1),an("cf3",t,e,jt,0,-i,1),an("cf4",t,e,jt,0,i,1),an("cn1",t,e,jt,-n,0,-1),an("cn2",t,e,jt,n,0,-1),an("cn3",t,e,jt,0,-i,-1),an("cn4",t,e,jt,0,i,-1),e.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function an(r,e,t,n,i,s,o){pm.set(i,s,o).unproject(n);const a=e[r];if(a!==void 0){const c=t.getAttribute("position");for(let l=0,u=a.length;l<u;l++)c.setXYZ(a[l],pm.x,pm.y,pm.z)}}const mm=new br;class JG extends Ls{constructor(e,t=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(24),s=new Ye;s.setIndex(new It(n,1)),s.setAttribute("position",new It(i,3)),super(s,new vr({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(e!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&mm.setFromObject(this.object),mm.isEmpty())return;const t=mm.min,n=mm.max,i=this.geometry.attributes.position,s=i.array;s[0]=n.x,s[1]=n.y,s[2]=n.z,s[3]=t.x,s[4]=n.y,s[5]=n.z,s[6]=t.x,s[7]=t.y,s[8]=n.z,s[9]=n.x,s[10]=t.y,s[11]=n.z,s[12]=n.x,s[13]=n.y,s[14]=t.z,s[15]=t.x,s[16]=n.y,s[17]=t.z,s[18]=t.x,s[19]=t.y,s[20]=t.z,s[21]=n.x,s[22]=t.y,s[23]=t.z,i.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e,t){return super.copy(e,t),this.object=e.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class jG extends Ls{constructor(e,t=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],s=new Ye;s.setIndex(new It(n,1)),s.setAttribute("position",new Ce(i,3)),super(s,new vr({color:t,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}dispose(){this.geometry.dispose(),this.material.dispose()}}class QG extends To{constructor(e,t=1,n=16776960){const i=n,s=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],o=new Ye;o.setAttribute("position",new Ce(s,3)),o.computeBoundingSphere(),super(o,new vr({color:i,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=t;const a=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],c=new Ye;c.setAttribute("position",new Ce(a,3)),c.computeBoundingSphere(),this.add(new De(c,new Ar({color:i,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const WT=new k;let gm,Xb;class e9 extends wt{constructor(e=new k(0,0,1),t=new k(0,0,0),n=1,i=16776960,s=n*.2,o=s*.2){super(),this.type="ArrowHelper",gm===void 0&&(gm=new Ye,gm.setAttribute("position",new Ce([0,0,0,0,1,0],3)),Xb=new Or(0,.5,1,5,1),Xb.translate(0,-.5,0)),this.position.copy(t),this.line=new To(gm,new vr({color:i,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new De(Xb,new Ar({color:i,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(n,s,o)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{WT.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(WT,t)}}setLength(e,t=e*.2,n=t*.2){this.line.scale.set(1,Math.max(1e-4,e-t),1),this.line.updateMatrix(),this.cone.scale.set(n,t,n),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class t9 extends Ls{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],n=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],i=new Ye;i.setAttribute("position",new Ce(t,3)),i.setAttribute("color",new Ce(n,3));const s=new vr({vertexColors:!0,toneMapped:!1});super(i,s),this.type="AxesHelper"}setColors(e,t,n){const i=new ye,s=this.geometry.attributes.color.array;return i.set(e),i.toArray(s,0),i.toArray(s,3),i.set(t),i.toArray(s,6),i.toArray(s,9),i.set(n),i.toArray(s,12),i.toArray(s,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class n9{constructor(){this.type="ShapePath",this.color=new ye,this.subPaths=[],this.currentPath=null}moveTo(e,t){return this.currentPath=new tf,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this}lineTo(e,t){return this.currentPath.lineTo(e,t),this}quadraticCurveTo(e,t,n,i){return this.currentPath.quadraticCurveTo(e,t,n,i),this}bezierCurveTo(e,t,n,i,s,o){return this.currentPath.bezierCurveTo(e,t,n,i,s,o),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e){function t(y){const v=[];for(let w=0,_=y.length;w<_;w++){const M=y[w],E=new Mc;E.curves=M.curves,v.push(E)}return v}function n(y,v){const w=v.length;let _=!1;for(let M=w-1,E=0;E<w;M=E++){let C=v[M],I=v[E],x=I.x-C.x,T=I.y-C.y;if(Math.abs(T)>Number.EPSILON){if(T<0&&(C=v[E],x=-x,I=v[M],T=-T),y.y<C.y||y.y>I.y)continue;if(y.y===C.y){if(y.x===C.x)return!0}else{const F=T*(y.x-C.x)-x*(y.y-C.y);if(F===0)return!0;if(F<0)continue;_=!_}}else{if(y.y!==C.y)continue;if(I.x<=y.x&&y.x<=C.x||C.x<=y.x&&y.x<=I.x)return!0}}return _}const i=Es.isClockWise,s=this.subPaths;if(s.length===0)return[];let o,a,c;const l=[];if(s.length===1)return a=s[0],c=new Mc,c.curves=a.curves,l.push(c),l;let u=!i(s[0].getPoints());u=e?!u:u;const h=[],d=[];let m=[],p=0,b;d[p]=void 0,m[p]=[];for(let y=0,v=s.length;y<v;y++)a=s[y],b=a.getPoints(),o=i(b),o=e?!o:o,o?(!u&&d[p]&&p++,d[p]={s:new Mc,p:b},d[p].s.curves=a.curves,u&&p++,m[p]=[]):m[p].push({h:a,p:b[0]});if(!d[0])return t(s);if(d.length>1){let y=!1,v=0;for(let w=0,_=d.length;w<_;w++)h[w]=[];for(let w=0,_=d.length;w<_;w++){const M=m[w];for(let E=0;E<M.length;E++){const C=M[E];let I=!0;for(let x=0;x<d.length;x++)n(C.p,d[x].p)&&(w!==x&&v++,I?(I=!1,h[x].push(C)):y=!0);I&&h[w].push(C)}}v>0&&y===!1&&(m=h)}let g;for(let y=0,v=d.length;y<v;y++){c=d[y].s,l.push(c),g=m[y];for(let w=0,_=g.length;w<_;w++)c.holes.push(g[w].h)}return l}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:e0}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=e0);const r9=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping:cL,AddEquation:aa,AddOperation:iL,AdditiveAnimationBlendMode:RE,AdditiveBlending:oa,AgXToneMapping:uL,AlphaFormat:pL,AlwaysCompare:DL,AlwaysDepth:JD,AlwaysStencilFunc:Ux,AmbientLight:c1,AnimationAction:O3,AnimationClip:cf,AnimationLoader:rG,AnimationMixer:DG,AnimationObjectGroup:PG,AnimationUtils:QH,ArcCurve:n3,ArrayCamera:XL,ArrowHelper:e9,AttachedBindMode:ux,Audio:L3,AudioAnalyser:vG,AudioContext:l1,AudioListener:yG,AudioLoader:pG,AxesHelper:t9,BackSide:yr,BasicDepthPacking:SL,BasicShadowMap:u5,BatchedMesh:e3,Bone:qE,BooleanKeyframeTrack:Yc,Box2:$G,Box3:br,Box3Helper:jG,BoxGeometry:Qt,BoxHelper:JG,BufferAttribute:It,BufferGeometry:Ye,BufferGeometryLoader:R3,ByteType:dL,Cache:so,Camera:a0,CameraHelper:ZG,CanvasTexture:SH,CapsuleGeometry:g0,CatmullRomCurve3:r3,CineonToneMapping:aL,CircleGeometry:y0,ClampToEdgeWrapping:gr,Clock:D3,Color:ye,ColorKeyframeTrack:i1,ColorManagement:Ct,CompressedArrayTexture:_H,CompressedCubeTexture:xH,CompressedTexture:p0,CompressedTextureLoader:iG,ConeGeometry:jr,ConstantAlphaFactor:XD,ConstantColorFactor:qD,CubeCamera:FL,CubeReflectionMapping:Ao,CubeRefractionMapping:xa,CubeTexture:ep,CubeTextureLoader:sG,CubeUVReflectionMapping:fh,CubicBezierCurve:ZE,CubicBezierCurve3:i3,CubicInterpolant:_3,CullFaceBack:sx,CullFaceFront:LD,CullFaceFrontBack:l5,CullFaceNone:DD,Curve:is,CurvePath:o3,CustomBlending:ND,CustomToneMapping:lL,CylinderGeometry:Or,Cylindrical:FG,Data3DTexture:UE,DataArrayTexture:s0,DataTexture:Ec,DataTextureLoader:oG,DataUtils:vF,DecrementStencilOp:x5,DecrementWrapStencilOp:E5,DefaultLoadingManager:E3,DepthFormat:ba,DepthStencilFormat:Ic,DepthTexture:$E,DetachedBindMode:hL,DirectionalLight:a1,DirectionalLightHelper:YG,DiscreteInterpolant:x3,DisplayP3ColorSpace:i0,DodecahedronGeometry:b0,DoubleSide:qi,DstAlphaFactor:zD,DstColorFactor:HD,DynamicCopyUsage:F5,DynamicDrawUsage:L5,DynamicReadUsage:U5,EdgesGeometry:a3,EllipseCurve:m0,EqualCompare:CL,EqualDepth:QD,EqualStencilFunc:C5,EquirectangularReflectionMapping:Hd,EquirectangularRefractionMapping:Gd,Euler:Qf,EventDispatcher:Do,ExtrudeGeometry:v0,FileLoader:Co,Float16BufferAttribute:AF,Float32BufferAttribute:Ce,Float64BufferAttribute:TF,FloatType:Ki,Fog:h0,FogExp2:u0,FramebufferTexture:vH,FrontSide:Mo,Frustum:tp,GLBufferAttribute:UG,GLSL1:z5,GLSL3:kx,GreaterCompare:IL,GreaterDepth:tL,GreaterEqualCompare:RL,GreaterEqualDepth:eL,GreaterEqualStencilFunc:D5,GreaterStencilFunc:P5,GridHelper:KG,Group:On,HalfFloatType:ku,HemisphereLight:M3,HemisphereLightHelper:qG,IcosahedronGeometry:_0,ImageBitmapLoader:fG,ImageLoader:lf,ImageUtils:OE,IncrementStencilOp:_5,IncrementWrapStencilOp:S5,InstancedBufferAttribute:zu,InstancedBufferGeometry:P3,InstancedInterleavedBuffer:OG,InstancedMesh:Vg,Int16BufferAttribute:EF,Int32BufferAttribute:MF,Int8BufferAttribute:_F,IntType:EE,InterleavedBuffer:d0,InterleavedBufferAttribute:Rc,Interpolant:ip,InterpolateDiscrete:Kd,InterpolateLinear:Xd,InterpolateSmooth:dg,InvertStencilOp:M5,KeepStencilOp:Ya,KeyframeTrack:ss,LOD:jL,LatheGeometry:np,Layers:o0,LessCompare:TL,LessDepth:jD,LessEqualCompare:LE,LessEqualDepth:Vd,LessEqualStencilFunc:I5,LessStencilFunc:T5,Light:La,LightProbe:I3,Line:To,Line3:zG,LineBasicMaterial:vr,LineCurve:JE,LineCurve3:s3,LineDashedMaterial:b3,LineLoop:t3,LineSegments:Ls,LinearDisplayP3ColorSpace:jf,LinearEncoding:DE,LinearFilter:un,LinearInterpolant:r1,LinearMipMapLinearFilter:m5,LinearMipMapNearestFilter:p5,LinearMipmapLinearFilter:Sa,LinearMipmapNearestFilter:SE,LinearSRGBColorSpace:Ts,LinearToneMapping:sL,LinearTransfer:Zd,Loader:Wr,LoaderUtils:Wx,LoadingManager:s1,LoopOnce:vL,LoopPingPong:xL,LoopRepeat:_L,LuminanceAlphaFormat:gL,LuminanceFormat:mL,MOUSE:a5,Material:wr,MaterialLoader:T0,MathUtils:nF,Matrix3:rt,Matrix4:$e,MaxEquation:lx,Mesh:De,MeshBasicMaterial:Ar,MeshDepthMaterial:zE,MeshDistanceMaterial:VE,MeshLambertMaterial:Pt,MeshMatcapMaterial:y3,MeshNormalMaterial:g3,MeshPhongMaterial:na,MeshPhysicalMaterial:p3,MeshStandardMaterial:t1,MeshToonMaterial:m3,MinEquation:cx,MirroredRepeatWrapping:qd,MixOperation:rL,MultiplyBlending:ax,MultiplyOperation:Jf,NearestFilter:ln,NearestMipMapLinearFilter:f5,NearestMipMapNearestFilter:d5,NearestMipmapLinearFilter:Ed,NearestMipmapNearestFilter:Fg,NeverCompare:AL,NeverDepth:ZD,NeverStencilFunc:A5,NoBlending:wo,NoColorSpace:ti,NoToneMapping:vo,NormalAnimationBlendMode:r0,NormalBlending:xc,NotEqualCompare:PL,NotEqualDepth:nL,NotEqualStencilFunc:R5,NumberKeyframeTrack:of,Object3D:wt,ObjectLoader:hG,ObjectSpaceNormalMap:ML,OctahedronGeometry:rp,OneFactor:BD,OneMinusConstantAlphaFactor:YD,OneMinusConstantColorFactor:KD,OneMinusDstAlphaFactor:VD,OneMinusDstColorFactor:GD,OneMinusSrcAlphaFactor:Bg,OneMinusSrcColorFactor:$D,OrthographicCamera:c0,P3Primaries:jd,PCFShadowMap:_E,PCFSoftShadowMap:xE,PMREMGenerator:Fx,Path:tf,PerspectiveCamera:In,Plane:ta,PlaneGeometry:Pc,PlaneHelper:QG,PointLight:Id,PointLightHelper:GG,Points:XE,PointsMaterial:KE,PolarGridHelper:XG,PolyhedronGeometry:Da,PositionalAudio:wG,PropertyBinding:ft,PropertyMixer:N3,QuadraticBezierCurve:jE,QuadraticBezierCurve3:QE,Quaternion:Hr,QuaternionKeyframeTrack:gh,QuaternionLinearInterpolant:S3,RED_GREEN_RGTC2_Format:Nx,RED_RGTC1_Format:wL,REVISION:e0,RGBADepthPacking:EL,RGBAFormat:kr,RGBAIntegerFormat:IE,RGBA_ASTC_10x10_Format:Cx,RGBA_ASTC_10x5_Format:Mx,RGBA_ASTC_10x6_Format:Ax,RGBA_ASTC_10x8_Format:Tx,RGBA_ASTC_12x10_Format:Ix,RGBA_ASTC_12x12_Format:Px,RGBA_ASTC_4x4_Format:yx,RGBA_ASTC_5x4_Format:bx,RGBA_ASTC_5x5_Format:wx,RGBA_ASTC_6x5_Format:vx,RGBA_ASTC_6x6_Format:_x,RGBA_ASTC_8x5_Format:xx,RGBA_ASTC_8x6_Format:Sx,RGBA_ASTC_8x8_Format:Ex,RGBA_BPTC_Format:hg,RGBA_ETC2_EAC_Format:gx,RGBA_PVRTC_2BPPV1_Format:px,RGBA_PVRTC_4BPPV1_Format:fx,RGBA_S3TC_DXT1_Format:cg,RGBA_S3TC_DXT3_Format:lg,RGBA_S3TC_DXT5_Format:ug,RGB_BPTC_SIGNED_Format:Rx,RGB_BPTC_UNSIGNED_Format:Dx,RGB_ETC1_Format:PE,RGB_ETC2_Format:mx,RGB_PVRTC_2BPPV1_Format:dx,RGB_PVRTC_4BPPV1_Format:hx,RGB_S3TC_DXT1_Format:ag,RGFormat:bL,RGIntegerFormat:CE,RawShaderMaterial:f3,Ray:ph,Raycaster:kG,Rec709Primaries:Jd,RectAreaLight:T3,RedFormat:yL,RedIntegerFormat:TE,ReinhardToneMapping:oL,RenderTarget:OL,RepeatWrapping:Wd,ReplaceStencilOp:v5,ReverseSubtractEquation:UD,RingGeometry:x0,SIGNED_RED_GREEN_RGTC2_Format:Ox,SIGNED_RED_RGTC1_Format:Lx,SRGBColorSpace:bn,SRGBTransfer:Ft,Scene:GE,ShaderChunk:et,ShaderLib:Wi,ShaderMaterial:Fr,ShadowMaterial:d3,Shape:Mc,ShapeGeometry:S0,ShapePath:n9,ShapeUtils:Es,ShortType:fL,Skeleton:f0,SkeletonHelper:HG,SkinnedMesh:QL,Source:sc,Sphere:Bn,SphereGeometry:vs,Spherical:BG,SphericalHarmonics3:C3,SplineCurve:e1,SpotLight:A3,SpotLightHelper:VG,Sprite:JL,SpriteMaterial:WE,SrcAlphaFactor:kg,SrcAlphaSaturateFactor:WD,SrcColorFactor:FD,StaticCopyUsage:B5,StaticDrawUsage:Qd,StaticReadUsage:O5,StereoCamera:mG,StreamCopyUsage:$5,StreamDrawUsage:N5,StreamReadUsage:k5,StringKeyframeTrack:Zc,SubtractEquation:OD,SubtractiveBlending:ox,TOUCH:c5,TangentSpaceNormalMap:Ra,TetrahedronGeometry:E0,Texture:hn,TextureLoader:aG,TorusGeometry:M0,TorusKnotGeometry:A0,Triangle:Ur,TriangleFanDrawMode:b5,TriangleStripDrawMode:y5,TrianglesDrawMode:g5,TubeGeometry:ha,TwoPassDoubleSide:h5,UVMapping:t0,Uint16BufferAttribute:kE,Uint32BufferAttribute:BE,Uint8BufferAttribute:xF,Uint8ClampedBufferAttribute:SF,Uniform:d1,UniformsGroup:NG,UniformsLib:we,UniformsUtils:BL,UnsignedByteType:_o,UnsignedInt248Type:ya,UnsignedIntType:io,UnsignedShort4444Type:ME,UnsignedShort5551Type:AE,UnsignedShortType:n0,VSMShadowMap:hs,Vector2:se,Vector3:k,Vector4:mt,VectorKeyframeTrack:af,VideoTexture:wH,WebGL1Renderer:YL,WebGL3DRenderTarget:cF,WebGLArrayRenderTarget:aF,WebGLCoordinateSystem:Xi,WebGLCubeRenderTarget:$L,WebGLMultipleRenderTargets:lF,WebGLRenderTarget:ts,WebGLRenderer:HE,WebGLUtils:KL,WebGPUCoordinateSystem:Bu,WireframeGeometry:h3,WrapAroundEnding:Yd,ZeroCurvatureEnding:rc,ZeroFactor:kD,ZeroSlopeEnding:ic,ZeroStencilOp:w5,_SRGBAFormat:$g,createCanvasElement:NL,sRGBEncoding:wa},Symbol.toStringTag,{value:"Module"}));var mv;let yh=(mv=class extends Error{constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}},f(mv,"name","InvalidParametersError"),mv);var gv;let k3=(gv=class extends Error{constructor(e="Invalid public key"){super(e),this.name="InvalidPublicKeyError"}},f(gv,"name","InvalidPublicKeyError"),gv);var yv;let B3=(yv=class extends Error{constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}},f(yv,"name","UnsupportedKeyTypeError"),yv);var fs,$P;let Pr=($P=class extends EventTarget{constructor(){super();xe(this,fs,new Map)}listenerCount(t){const n=N(this,fs).get(t);return n==null?0:n.length}addEventListener(t,n,i){super.addEventListener(t,n,i);let s=N(this,fs).get(t);s==null&&(s=[],N(this,fs).set(t,s)),s.push({callback:n,once:(i!==!0&&i!==!1&&(i==null?void 0:i.once))??!1})}removeEventListener(t,n,i){super.removeEventListener(t.toString(),n??null,i);let s=N(this,fs).get(t);s!=null&&(s=s.filter(({callback:o})=>o!==n),N(this,fs).set(t,s))}dispatchEvent(t){const n=super.dispatchEvent(t);let i=N(this,fs).get(t.type);return i==null||(i=i.filter(({once:s})=>!s),N(this,fs).set(t.type,i)),n}safeDispatchEvent(t,n={}){return this.dispatchEvent(new CustomEvent(t,n))}},fs=new WeakMap,$P);function i9(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}function C0(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function s9(r){return new TextEncoder().encode(r)}function o9(r){return new TextDecoder().decode(r)}function a9(r,e){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),n=0;n<t.length;n++)t[n]=255;for(var i=0;i<r.length;i++){var s=r.charAt(i),o=s.charCodeAt(0);if(t[o]!==255)throw new TypeError(s+" is ambiguous");t[o]=i}var a=r.length,c=r.charAt(0),l=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function h(p){if(p instanceof Uint8Array||(ArrayBuffer.isView(p)?p=new Uint8Array(p.buffer,p.byteOffset,p.byteLength):Array.isArray(p)&&(p=Uint8Array.from(p))),!(p instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(p.length===0)return"";for(var b=0,g=0,y=0,v=p.length;y!==v&&p[y]===0;)y++,b++;for(var w=(v-y)*u+1>>>0,_=new Uint8Array(w);y!==v;){for(var M=p[y],E=0,C=w-1;(M!==0||E<g)&&C!==-1;C--,E++)M+=256*_[C]>>>0,_[C]=M%a>>>0,M=M/a>>>0;if(M!==0)throw new Error("Non-zero carry");g=E,y++}for(var I=w-g;I!==w&&_[I]===0;)I++;for(var x=c.repeat(b);I<w;++I)x+=r.charAt(_[I]);return x}function d(p){if(typeof p!="string")throw new TypeError("Expected String");if(p.length===0)return new Uint8Array;var b=0;if(p[b]!==" "){for(var g=0,y=0;p[b]===c;)g++,b++;for(var v=(p.length-b)*l+1>>>0,w=new Uint8Array(v);p[b];){var _=t[p.charCodeAt(b)];if(_===255)return;for(var M=0,E=v-1;(_!==0||M<y)&&E!==-1;E--,M++)_+=a*w[E]>>>0,w[E]=_%256>>>0,_=_/256>>>0;if(_!==0)throw new Error("Non-zero carry");y=M,b++}if(p[b]!==" "){for(var C=v-y;C!==v&&w[C]===0;)C++;for(var I=new Uint8Array(g+(v-C)),x=g;C!==v;)I[x++]=w[C++];return I}}}function m(p){var b=d(p);if(b)return b;throw new Error(`Non-${e} character`)}return{encode:h,decodeUnsafe:d,decode:m}}var c9=a9,l9=c9;let u9=class{constructor(e,t,n){f(this,"name");f(this,"prefix");f(this,"baseEncode");this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},h9=class{constructor(e,t,n){f(this,"name");f(this,"prefix");f(this,"baseDecode");f(this,"prefixCodePoint");this.name=e,this.prefix=t;const i=t.codePointAt(0);if(i===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=i,this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return F3(this,e)}},d9=class{constructor(e){f(this,"decoders");this.decoders=e}or(e){return F3(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(n!=null)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};function F3(r,e){return new d9({...r.decoders??{[r.prefix]:r},...e.decoders??{[e.prefix]:e}})}let f9=class{constructor(e,t,n,i){f(this,"name");f(this,"prefix");f(this,"baseEncode");f(this,"baseDecode");f(this,"encoder");f(this,"decoder");this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=i,this.encoder=new u9(e,t,n),this.decoder=new h9(e,t,i)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}};function I0({name:r,prefix:e,encode:t,decode:n}){return new f9(r,e,t,n)}function sp({name:r,prefix:e,alphabet:t}){const{encode:n,decode:i}=l9(t,r);return I0({prefix:e,name:r,encode:n,decode:s=>C0(i(s))})}function p9(r,e,t,n){let i=r.length;for(;r[i-1]==="=";)--i;const s=new Uint8Array(i*t/8|0);let o=0,a=0,c=0;for(let l=0;l<i;++l){const u=e[r[l]];if(u===void 0)throw new SyntaxError(`Non-${n} character`);a=a<<t|u,o+=t,o>=8&&(o-=8,s[c++]=255&a>>o)}if(o>=t||(255&a<<8-o)!==0)throw new SyntaxError("Unexpected end of data");return s}function m9(r,e,t){const n=e[e.length-1]==="=",i=(1<<t)-1;let s="",o=0,a=0;for(let c=0;c<r.length;++c)for(a=a<<8|r[c],o+=8;o>t;)o-=t,s+=e[i&a>>o];if(o!==0&&(s+=e[i&a<<t-o]),n)for(;(s.length*t&7)!==0;)s+="=";return s}function g9(r){const e={};for(let t=0;t<r.length;++t)e[r[t]]=t;return e}function Hn({name:r,prefix:e,bitsPerChar:t,alphabet:n}){const i=g9(n);return I0({prefix:e,name:r,encode(s){return m9(s,n,t)},decode(s){return p9(s,i,t,r)}})}const gt=sp({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),y9=sp({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),b9=Object.freeze(Object.defineProperty({__proto__:null,base58btc:gt,base58flickr:y9},Symbol.toStringTag,{value:"Module"})),Rn=Hn({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),w9=Hn({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),v9=Hn({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),_9=Hn({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),x9=Hn({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),S9=Hn({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),E9=Hn({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),M9=Hn({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),A9=Hn({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),T9=Object.freeze(Object.defineProperty({__proto__:null,base32:Rn,base32hex:x9,base32hexpad:E9,base32hexpadupper:M9,base32hexupper:S9,base32pad:v9,base32padupper:_9,base32upper:w9,base32z:A9},Symbol.toStringTag,{value:"Module"})),pg=sp({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),C9=sp({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),I9=Object.freeze(Object.defineProperty({__proto__:null,base36:pg,base36upper:C9},Symbol.toStringTag,{value:"Module"}));var P9=$3,qT=128,R9=-128,D9=Math.pow(2,31);function $3(r,e,t){e=e||[],t=t||0;for(var n=t;r>=D9;)e[t++]=r&255|qT,r/=128;for(;r&R9;)e[t++]=r&255|qT,r>>>=7;return e[t]=r|0,$3.bytes=t-n+1,e}var L9=Kx,N9=128,KT=127;function Kx(r,n){var t=0,n=n||0,i=0,s=n,o,a=r.length;do{if(s>=a)throw Kx.bytes=0,new RangeError("Could not decode varint");o=r[s++],t+=i<28?(o&KT)<<i:(o&KT)*Math.pow(2,i),i+=7}while(o>=N9);return Kx.bytes=s-n,t}var O9=Math.pow(2,7),U9=Math.pow(2,14),k9=Math.pow(2,21),B9=Math.pow(2,28),F9=Math.pow(2,35),$9=Math.pow(2,42),z9=Math.pow(2,49),V9=Math.pow(2,56),H9=Math.pow(2,63),G9=function(r){return r<O9?1:r<U9?2:r<k9?3:r<B9?4:r<F9?5:r<$9?6:r<z9?7:r<V9?8:r<H9?9:10},W9={encode:P9,decode:L9,encodingLength:G9},Gg=W9;function Xx(r,e=0){return[Gg.decode(r,e),Gg.decode.bytes]}function Wg(r,e,t=0){return Gg.encode(r,e,t),e}function qg(r){return Gg.encodingLength(r)}function P0(r,e){const t=e.byteLength,n=qg(r),i=n+qg(t),s=new Uint8Array(i+t);return Wg(r,s,0),Wg(t,s,n),s.set(e,i),new f1(r,t,e,s)}function Lo(r){const e=C0(r),[t,n]=Xx(e),[i,s]=Xx(e.subarray(n)),o=e.subarray(n+s);if(o.byteLength!==i)throw new Error("Incorrect length");return new f1(t,i,o,e)}function q9(r,e){if(r===e)return!0;{const t=e;return r.code===t.code&&r.size===t.size&&t.bytes instanceof Uint8Array&&i9(r.bytes,t.bytes)}}let f1=class{constructor(e,t,n,i){f(this,"code");f(this,"size");f(this,"digest");f(this,"bytes");this.code=e,this.size=t,this.digest=n,this.bytes=i}};function XT(r,e){const{bytes:t,version:n}=r;switch(n){case 0:return X9(t,Yx(r),e??gt.encoder);default:return Y9(t,Yx(r),e??Rn.encoder)}}const YT=new WeakMap;function Yx(r){const e=YT.get(r);if(e==null){const t=new Map;return YT.set(r,t),t}return e}var zP;let Ze=class Jn{constructor(e,t,n,i){f(this,"code");f(this,"version");f(this,"multihash");f(this,"bytes");f(this,"/");f(this,zP,"CID");this.code=t,this.version=e,this.multihash=n,this.bytes=i,this["/"]=i}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==qh)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==Z9)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return Jn.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,n=P0(e,t);return Jn.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return Jn.equals(this,e)}static equals(e,t){const n=t;return n!=null&&e.code===n.code&&e.version===n.version&&q9(e.multihash,n.multihash)}toString(e){return XT(this,e)}toJSON(){return{"/":XT(this)}}link(){return this}[(zP=Symbol.toStringTag,Symbol.for("nodejs.util.inspect.custom"))](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const t=e;if(t instanceof Jn)return t;if(t["/"]!=null&&t["/"]===t.bytes||t.asCID===t){const{version:n,code:i,multihash:s,bytes:o}=t;return new Jn(n,i,s,o??ZT(n,i,s.bytes))}else if(t[J9]===!0){const{version:n,multihash:i,code:s}=t,o=Lo(i);return Jn.create(n,s,o)}else return null}static create(e,t,n){if(typeof t!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(t!==qh)throw new Error(`Version 0 CID must use dag-pb (code: ${qh}) block encoding`);return new Jn(e,t,n,n.bytes)}case 1:{const i=ZT(e,t,n.bytes);return new Jn(e,t,n,i)}default:throw new Error("Invalid version")}}static createV0(e){return Jn.create(0,qh,e)}static createV1(e,t){return Jn.create(1,e,t)}static decode(e){const[t,n]=Jn.decodeFirst(e);if(n.length!==0)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=Jn.inspectBytes(e),n=t.size-t.multihashSize,i=C0(e.subarray(n,n+t.multihashSize));if(i.byteLength!==t.multihashSize)throw new Error("Incorrect length");const s=i.subarray(t.multihashSize-t.digestSize),o=new f1(t.multihashCode,t.digestSize,s,i);return[t.version===0?Jn.createV0(o):Jn.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0;const n=()=>{const[h,d]=Xx(e.subarray(t));return t+=d,h};let i=n(),s=qh;if(i===18?(i=0,t=0):s=n(),i!==0&&i!==1)throw new RangeError(`Invalid CID version ${i}`);const o=t,a=n(),c=n(),l=t+c,u=l-o;return{version:i,codec:s,multihashCode:a,digestSize:c,multihashSize:u,size:l}}static parse(e,t){const[n,i]=K9(e,t),s=Jn.decode(i);if(s.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return Yx(s).set(n,e),s}};function K9(r,e){switch(r[0]){case"Q":{const t=e??gt;return[gt.prefix,t.decode(`${gt.prefix}${r}`)]}case gt.prefix:{const t=e??gt;return[gt.prefix,t.decode(r)]}case Rn.prefix:{const t=e??Rn;return[Rn.prefix,t.decode(r)]}case pg.prefix:{const t=e??pg;return[pg.prefix,t.decode(r)]}default:{if(e==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],e.decode(r)]}}}function X9(r,e,t){const{prefix:n}=t;if(n!==gt.prefix)throw Error(`Cannot string encode V0 in ${t.name} encoding`);const i=e.get(n);if(i==null){const s=t.encode(r).slice(1);return e.set(n,s),s}else return i}function Y9(r,e,t){const{prefix:n}=t,i=e.get(n);if(i==null){const s=t.encode(r);return e.set(n,s),s}else return i}const qh=112,Z9=18;function ZT(r,e,t){const n=qg(r),i=n+qg(e),s=new Uint8Array(i+t.byteLength);return Wg(r,s,0),Wg(e,s,n),s.set(t,i),s}const J9=Symbol.for("@ipld/js-cid/CID"),z3=0,j9="identity",V3=C0;function Q9(r,e){if((e==null?void 0:e.truncate)!=null&&e.truncate!==r.byteLength){if(e.truncate<0||e.truncate>r.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${r.byteLength}`);r=r.subarray(0,e.truncate)}return P0(z3,V3(r))}const dn={code:z3,name:j9,encode:V3,digest:Q9};function We(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}function xt(r=0){return new Uint8Array(r)}function ns(r=0){return new Uint8Array(r)}function ut(r,e){e==null&&(e=r.reduce((i,s)=>i+s.length,0));const t=ns(e);let n=0;for(const i of r)t.set(i,n),n+=i.length;return t}const H3=Symbol.for("@achingbrain/uint8arraylist");function JT(r,e){if(e==null||e<0)throw new RangeError("index is out of bounds");let t=0;for(const n of r){const i=t+n.byteLength;if(e<i)return{buf:n,index:e-t};t=i}throw new RangeError("index is out of bounds")}function ym(r){return!!(r!=null&&r[H3])}var VP;let vt=class mg{constructor(...e){f(this,"bufs");f(this,"length");f(this,VP,!0);this.bufs=[],this.length=0,e.length>0&&this.appendAll(e)}*[(VP=H3,Symbol.iterator)](){yield*this.bufs}get byteLength(){return this.length}append(...e){this.appendAll(e)}appendAll(e){let t=0;for(const n of e)if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.push(n);else if(ym(n))t+=n.byteLength,this.bufs.push(...n.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}prepend(...e){this.prependAll(e)}prependAll(e){let t=0;for(const n of e.reverse())if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.unshift(n);else if(ym(n))t+=n.byteLength,this.bufs.unshift(...n.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}get(e){const t=JT(this.bufs,e);return t.buf[t.index]}set(e,t){const n=JT(this.bufs,e);n.buf[n.index]=t}write(e,t=0){if(e instanceof Uint8Array)for(let n=0;n<e.length;n++)this.set(t+n,e[n]);else if(ym(e))for(let n=0;n<e.length;n++)this.set(t+n,e.get(n));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(e){if(e=Math.trunc(e),!(Number.isNaN(e)||e<=0)){if(e===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(e>=this.bufs[0].byteLength)e-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(e),this.length-=e;break}}}slice(e,t){const{bufs:n,length:i}=this._subList(e,t);return ut(n,i)}subarray(e,t){const{bufs:n,length:i}=this._subList(e,t);return n.length===1?n[0]:ut(n,i)}sublist(e,t){const{bufs:n,length:i}=this._subList(e,t),s=new mg;return s.length=i,s.bufs=[...n],s}_subList(e,t){if(e=e??0,t=t??this.length,e<0&&(e=this.length+e),t<0&&(t=this.length+t),e<0||t>this.length)throw new RangeError("index is out of bounds");if(e===t)return{bufs:[],length:0};if(e===0&&t===this.length)return{bufs:this.bufs,length:this.length};const n=[];let i=0;for(let s=0;s<this.bufs.length;s++){const o=this.bufs[s],a=i,c=a+o.byteLength;if(i=c,e>=c)continue;const l=e>=a&&e<c,u=t>a&&t<=c;if(l&&u){if(e===a&&t===c){n.push(o);break}const h=e-a;n.push(o.subarray(h,h+(t-e)));break}if(l){if(e===0){n.push(o);continue}n.push(o.subarray(e-a));continue}if(u){if(t===c){n.push(o);break}n.push(o.subarray(0,t-a));break}n.push(o)}return{bufs:n,length:t-e}}indexOf(e,t=0){if(!ym(e)&&!(e instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const n=e instanceof Uint8Array?e:e.subarray();if(t=Number(t??0),isNaN(t)&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),e.length===0)return t>this.length?this.length:t;const i=n.byteLength;if(i===0)throw new TypeError("search must be at least 1 byte long");const s=256,o=new Int32Array(s);for(let h=0;h<s;h++)o[h]=-1;for(let h=0;h<i;h++)o[n[h]]=h;const a=o,c=this.byteLength-n.byteLength,l=n.byteLength-1;let u;for(let h=t;h<=c;h+=u){u=0;for(let d=l;d>=0;d--){const m=this.get(h+d);if(n[d]!==m){u=Math.max(1,d-a[m]);break}}if(u===0)return h}return-1}getInt8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getInt8(0)}setInt8(e,t){const n=ns(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt8(0,t),this.write(n,e)}getInt16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt16(0,t)}setInt16(e,t,n){const i=xt(2);new DataView(i.buffer,i.byteOffset,i.byteLength).setInt16(0,t,n),this.write(i,e)}getInt32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt32(0,t)}setInt32(e,t,n){const i=xt(4);new DataView(i.buffer,i.byteOffset,i.byteLength).setInt32(0,t,n),this.write(i,e)}getBigInt64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigInt64(0,t)}setBigInt64(e,t,n){const i=xt(8);new DataView(i.buffer,i.byteOffset,i.byteLength).setBigInt64(0,t,n),this.write(i,e)}getUint8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getUint8(0)}setUint8(e,t){const n=ns(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint8(0,t),this.write(n,e)}getUint16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint16(0,t)}setUint16(e,t,n){const i=xt(2);new DataView(i.buffer,i.byteOffset,i.byteLength).setUint16(0,t,n),this.write(i,e)}getUint32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint32(0,t)}setUint32(e,t,n){const i=xt(4);new DataView(i.buffer,i.byteOffset,i.byteLength).setUint32(0,t,n),this.write(i,e)}getBigUint64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigUint64(0,t)}setBigUint64(e,t,n){const i=xt(8);new DataView(i.buffer,i.byteOffset,i.byteLength).setBigUint64(0,t,n),this.write(i,e)}getFloat32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat32(0,t)}setFloat32(e,t,n){const i=xt(4);new DataView(i.buffer,i.byteOffset,i.byteLength).setFloat32(0,t,n),this.write(i,e)}getFloat64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat64(0,t)}setFloat64(e,t,n){const i=xt(8);new DataView(i.buffer,i.byteOffset,i.byteLength).setFloat64(0,t,n),this.write(i,e)}equals(e){if(e==null||!(e instanceof mg)||e.bufs.length!==this.bufs.length)return!1;for(let t=0;t<this.bufs.length;t++)if(!We(this.bufs[t],e.bufs[t]))return!1;return!0}static fromUint8Arrays(e,t){const n=new mg;return n.bufs=e,t==null&&(t=e.reduce((i,s)=>i+s.byteLength,0)),n.length=t,n}};const eW=sp({prefix:"9",name:"base10",alphabet:"0123456789"}),tW=Object.freeze(Object.defineProperty({__proto__:null,base10:eW},Symbol.toStringTag,{value:"Module"})),nW=Hn({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),rW=Hn({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),iW=Object.freeze(Object.defineProperty({__proto__:null,base16:nW,base16upper:rW},Symbol.toStringTag,{value:"Module"})),sW=Hn({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),oW=Object.freeze(Object.defineProperty({__proto__:null,base2:sW},Symbol.toStringTag,{value:"Module"})),G3=Array.from(""),aW=G3.reduce((r,e,t)=>(r[t]=e,r),[]),cW=G3.reduce((r,e,t)=>{const n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);return r[n]=t,r},[]);function lW(r){return r.reduce((e,t)=>(e+=aW[t],e),"")}function uW(r){const e=[];for(const t of r){const n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);const i=cW[n];if(i==null)throw new Error(`Non-base256emoji character: ${t}`);e.push(i)}return new Uint8Array(e)}const hW=I0({prefix:"",name:"base256emoji",encode:lW,decode:uW}),dW=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:hW},Symbol.toStringTag,{value:"Module"})),W3=Hn({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),fW=Hn({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Mi=Hn({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),pW=Hn({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),mW=Object.freeze(Object.defineProperty({__proto__:null,base64:W3,base64pad:fW,base64url:Mi,base64urlpad:pW},Symbol.toStringTag,{value:"Module"})),gW=Hn({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),yW=Object.freeze(Object.defineProperty({__proto__:null,base8:gW},Symbol.toStringTag,{value:"Module"})),bW=I0({prefix:"\0",name:"identity",encode:r=>o9(r),decode:r=>s9(r)}),wW=Object.freeze(Object.defineProperty({__proto__:null,identity:bW},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const vW=20;function _W({name:r,code:e,encode:t,minDigestLength:n,maxDigestLength:i}){return new xW(r,e,t,n,i)}let xW=class{constructor(e,t,n,i,s){f(this,"name");f(this,"code");f(this,"encode");f(this,"minDigestLength");f(this,"maxDigestLength");this.name=e,this.code=t,this.encode=n,this.minDigestLength=i??vW,this.maxDigestLength=s}digest(e,t){if((t==null?void 0:t.truncate)!=null){if(t.truncate<this.minDigestLength)throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);if(this.maxDigestLength!=null&&t.truncate>this.maxDigestLength)throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`)}if(e instanceof Uint8Array){const n=this.encode(e);return n instanceof Uint8Array?jT(n,this.code,t==null?void 0:t.truncate):n.then(i=>jT(i,this.code,t==null?void 0:t.truncate))}else throw Error("Unknown type, must be binary type")}};function jT(r,e,t){if(t!=null&&t!==r.byteLength){if(t>r.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${r.byteLength}`);r=r.subarray(0,t)}return P0(e,r)}function SW(r){return async e=>new Uint8Array(await crypto.subtle.digest(r,e))}const Ns=_W({name:"sha2-256",code:18,encode:SW("SHA-256")}),oi={...wW,...oW,...yW,...tW,...iW,...T9,...I9,...b9,...mW,...dW};function q3(r,e,t,n){return{name:r,prefix:e,encoder:{name:r,prefix:e,encode:t},decoder:{decode:n}}}const QT=q3("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),Yb=q3("ascii","a",r=>{let e="a";for(let t=0;t<r.length;t++)e+=String.fromCharCode(r[t]);return e},r=>{r=r.substring(1);const e=ns(r.length);for(let t=0;t<r.length;t++)e[t]=r.charCodeAt(t);return e}),K3={utf8:QT,"utf-8":QT,hex:oi.base16,latin1:Yb,ascii:Yb,binary:Yb,...oi};function Se(r,e="utf8"){const t=K3[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.decoder.decode(`${t.prefix}${r}`)}function ae(r,e="utf8"){const t=K3[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.encoder.encode(r).substring(1)}const EW=parseInt("11111",2),Zx=parseInt("10000000",2),MW=parseInt("01111111",2),e2={0:Kh,1:Kh,2:AW,3:IW,4:PW,5:CW,6:TW,16:Kh,22:Kh,48:Kh};function op(r,e={offset:0}){const t=r[e.offset]&EW;if(e.offset++,e2[t]!=null)return e2[t](r,e);throw new Error("No decoder for tag "+t)}function ap(r,e){let t=0;if((r[e.offset]&Zx)===Zx){const n=r[e.offset]&MW;let i="0x";e.offset++;for(let s=0;s<n;s++,e.offset++)i+=r[e.offset].toString(16).padStart(2,"0");t=parseInt(i,16)}else t=r[e.offset],e.offset++;return t}function Kh(r,e){ap(r,e);const t=[];for(;!(e.offset>=r.byteLength);){const n=op(r,e);if(n===null)break;t.push(n)}return t}function AW(r,e){const t=ap(r,e),n=e.offset,i=e.offset+t,s=[];for(let o=n;o<i;o++)o===n&&r[o]===0||s.push(r[o]);return e.offset+=t,Uint8Array.from(s)}function TW(r,e){const t=ap(r,e),n=e.offset+t,i=r[e.offset];e.offset++;let s=0,o=0;i<40?(s=0,o=i):i<80?(s=1,o=i-40):(s=2,o=i-80);let a=`${s}.${o}`,c=[];for(;e.offset<n;){const l=r[e.offset];if(e.offset++,c.push(l&127),l<128){c.reverse();let u=0;for(let h=0;h<c.length;h++)u+=c[h]<<h*7;a+=`.${u}`,c=[]}}return a}function CW(r,e){return e.offset++,null}function IW(r,e){const t=ap(r,e),n=r[e.offset];e.offset++;const i=r.subarray(e.offset,e.offset+t-1);if(e.offset+=t,n!==0)throw new Error("Unused bits in bit string is unimplemented");return i}function PW(r,e){const t=ap(r,e),n=r.subarray(e.offset,e.offset+t);return e.offset+=t,n}function RW(r){let e=r.toString(16);e.length%2===1&&(e="0"+e);const t=new vt;for(let n=0;n<e.length;n+=2)t.append(Uint8Array.from([parseInt(`${e[n]}${e[n+1]}`,16)]));return t}function p1(r){if(r.byteLength<128)return Uint8Array.from([r.byteLength]);const e=RW(r.byteLength);return new vt(Uint8Array.from([e.byteLength|Zx]),e)}function Jx(r){const e=new vt,t=128;return(r.subarray()[0]&t)===t&&e.append(Uint8Array.from([0])),e.append(r),new vt(Uint8Array.from([2]),p1(e),e)}function X3(r){const e=Uint8Array.from([0]),t=new vt(e,r);return new vt(Uint8Array.from([3]),p1(t),t)}function Pd(r,e=48){const t=new vt;for(const n of r)t.append(n);return new vt(Uint8Array.from([e]),p1(t),t)}const DW="1.2.840.10045.3.1.7",LW="1.3.132.0.34",NW="1.3.132.0.35";async function OW(r,e,t,n){var o,a;const i=await crypto.subtle.importKey("jwk",r,{name:"ECDSA",namedCurve:r.crv??"P-256"},!1,["verify"]);(o=n==null?void 0:n.signal)==null||o.throwIfAborted();const s=await crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},i,e,t.subarray());return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),s}const UW=Uint8Array.from([6,8,42,134,72,206,61,3,1,7]),kW=Uint8Array.from([6,5,43,129,4,0,34]),BW=Uint8Array.from([6,5,43,129,4,0,35]),FW={ext:!0,kty:"EC",crv:"P-256"},$W={ext:!0,kty:"EC",crv:"P-384"},zW={ext:!0,kty:"EC",crv:"P-521"},Zb=32,Jb=48,jb=66;function Y3(r){const e=op(r);return Z3(e)}function Z3(r){const e=r[1][1][0],t=1;let n,i;if(e.byteLength===Zb*2+1)return n=ae(e.subarray(t,t+Zb),"base64url"),i=ae(e.subarray(t+Zb),"base64url"),new Qb({...FW,key_ops:["verify"],x:n,y:i});if(e.byteLength===Jb*2+1)return n=ae(e.subarray(t,t+Jb),"base64url"),i=ae(e.subarray(t+Jb),"base64url"),new Qb({...$W,key_ops:["verify"],x:n,y:i});if(e.byteLength===jb*2+1)return n=ae(e.subarray(t,t+jb),"base64url"),i=ae(e.subarray(t+jb),"base64url"),new Qb({...zW,key_ops:["verify"],x:n,y:i});throw new yh(`coordinates were wrong length, got ${e.byteLength}, expected 65, 97 or 133`)}function VW(r){return Pd([Jx(Uint8Array.from([1])),Pd([HW(r.crv)],160),Pd([X3(new vt(Uint8Array.from([4]),Se(r.x??"","base64url"),Se(r.y??"","base64url")))],161)]).subarray()}function HW(r){if(r==="P-256")return UW;if(r==="P-384")return kW;if(r==="P-521")return BW;throw new yh(`Invalid curve ${r}`)}let Qb=class{constructor(e){f(this,"type","ECDSA");f(this,"jwk");f(this,"_raw");this.jwk=e}get raw(){return this._raw==null&&(this._raw=VW(this.jwk)),this._raw}toMultihash(){return dn.digest(Ms(this))}toCID(){return Ze.createV1(114,this.toMultihash())}toString(){return gt.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:We(this.raw,e.raw)}async verify(e,t,n){return OW(this.jwk,t,e,n)}};/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function R0(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Ea(r,e=""){if(!Number.isSafeInteger(r)||r<0){const t=e&&`"${e}" `;throw new Error(`${t}expected integer >= 0, got ${r}`)}}function lt(r,e,t=""){const n=R0(r),i=r==null?void 0:r.length,s=e!==void 0;if(!n||s&&i!==e){const o=t&&`"${t}" `,a=s?` of length ${e}`:"",c=n?`length=${i}`:`type=${typeof r}`;throw new Error(o+"expected Uint8Array"+a+", got "+c)}return r}function D0(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash must wrapped by utils.createHasher");Ea(r.outputLen),Ea(r.blockLen)}function Kg(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function GW(r,e){lt(r,void 0,"digestInto() output");const t=e.outputLen;if(r.length<t)throw new Error('"digestInto() output" expected to be of length >='+t)}function Lc(...r){for(let e=0;e<r.length;e++)r[e].fill(0)}function ew(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}function as(r,e){return r<<32-e|r>>>e}const J3=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",WW=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function cp(r){if(lt(r),J3)return r.toHex();let e="";for(let t=0;t<r.length;t++)e+=WW[r[t]];return e}const Vs={_0:48,_9:57,A:65,F:70,a:97,f:102};function t2(r){if(r>=Vs._0&&r<=Vs._9)return r-Vs._0;if(r>=Vs.A&&r<=Vs.F)return r-(Vs.A-10);if(r>=Vs.a&&r<=Vs.f)return r-(Vs.a-10)}function uf(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);if(J3)return Uint8Array.fromHex(r);const e=r.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(t);for(let i=0,s=0;i<t;i++,s+=2){const o=t2(r.charCodeAt(s)),a=t2(r.charCodeAt(s+1));if(o===void 0||a===void 0){const c=r[s]+r[s+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+s)}n[i]=o*16+a}return n}function _s(...r){let e=0;for(let n=0;n<r.length;n++){const i=r[n];lt(i),e+=i.length}const t=new Uint8Array(e);for(let n=0,i=0;n<r.length;n++){const s=r[n];t.set(s,i),i+=s.length}return t}function j3(r,e={}){const t=(i,s)=>r(s).update(i).digest(),n=r(void 0);return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=i=>r(i),Object.assign(t,e),Object.freeze(t)}function lp(r=32){const e=typeof globalThis=="object"?globalThis.crypto:null;if(typeof(e==null?void 0:e.getRandomValues)!="function")throw new Error("crypto.getRandomValues must be defined");return e.getRandomValues(new Uint8Array(r))}const Q3=r=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,r])});function qW(r,e,t){return r&e^~r&t}function KW(r,e,t){return r&e^r&t^e&t}let eN=class{constructor(e,t,n,i){f(this,"blockLen");f(this,"outputLen");f(this,"padOffset");f(this,"isLE");f(this,"buffer");f(this,"view");f(this,"finished",!1);f(this,"length",0);f(this,"pos",0);f(this,"destroyed",!1);this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=i,this.buffer=new Uint8Array(e),this.view=ew(this.buffer)}update(e){Kg(this),lt(e);const{view:t,buffer:n,blockLen:i}=this,s=e.length;for(let o=0;o<s;){const a=Math.min(i-this.pos,s-o);if(a===i){const c=ew(e);for(;i<=s-o;o+=i)this.process(c,o);continue}n.set(e.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===i&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Kg(this),GW(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:i,isLE:s}=this;let{pos:o}=this;t[o++]=128,Lc(this.buffer.subarray(o)),this.padOffset>i-o&&(this.process(n,0),o=0);for(let h=o;h<i;h++)t[h]=0;n.setBigUint64(i-8,BigInt(this.length*8),s),this.process(n,0);const a=ew(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen must be aligned to 32bit");const l=c/4,u=this.get();if(l>u.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<l;h++)a.setUint32(4*h,u[h],s)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:i,finished:s,destroyed:o,pos:a}=this;return e.destroyed=o,e.finished=s,e.length=i,e.pos=a,i%t&&e.buffer.set(n),e}clone(){return this._cloneInto()}};const Go=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Yn=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),bm=BigInt(2**32-1),n2=BigInt(32);function XW(r,e=!1){return e?{h:Number(r&bm),l:Number(r>>n2&bm)}:{h:Number(r>>n2&bm)|0,l:Number(r&bm)|0}}function YW(r,e=!1){const t=r.length;let n=new Uint32Array(t),i=new Uint32Array(t);for(let s=0;s<t;s++){const{h:o,l:a}=XW(r[s],e);[n[s],i[s]]=[o,a]}return[n,i]}const r2=(r,e,t)=>r>>>t,i2=(r,e,t)=>r<<32-t|e>>>t,El=(r,e,t)=>r>>>t|e<<32-t,Ml=(r,e,t)=>r<<32-t|e>>>t,wm=(r,e,t)=>r<<64-t|e>>>t-32,vm=(r,e,t)=>r>>>t-32|e<<64-t;function Hs(r,e,t,n){const i=(e>>>0)+(n>>>0);return{h:r+t+(i/2**32|0)|0,l:i|0}}const ZW=(r,e,t)=>(r>>>0)+(e>>>0)+(t>>>0),JW=(r,e,t,n)=>e+t+n+(r/2**32|0)|0,jW=(r,e,t,n)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0),QW=(r,e,t,n,i)=>e+t+n+i+(r/2**32|0)|0,e7=(r,e,t,n,i)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0)+(i>>>0),t7=(r,e,t,n,i,s)=>e+t+n+i+s+(r/2**32|0)|0,n7=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Wo=new Uint32Array(64);let r7=class extends eN{constructor(e){super(64,e,8,!1)}get(){const{A:e,B:t,C:n,D:i,E:s,F:o,G:a,H:c}=this;return[e,t,n,i,s,o,a,c]}set(e,t,n,i,s,o,a,c){this.A=e|0,this.B=t|0,this.C=n|0,this.D=i|0,this.E=s|0,this.F=o|0,this.G=a|0,this.H=c|0}process(e,t){for(let h=0;h<16;h++,t+=4)Wo[h]=e.getUint32(t,!1);for(let h=16;h<64;h++){const d=Wo[h-15],m=Wo[h-2],p=as(d,7)^as(d,18)^d>>>3,b=as(m,17)^as(m,19)^m>>>10;Wo[h]=b+Wo[h-7]+p+Wo[h-16]|0}let{A:n,B:i,C:s,D:o,E:a,F:c,G:l,H:u}=this;for(let h=0;h<64;h++){const d=as(a,6)^as(a,11)^as(a,25),m=u+d+qW(a,c,l)+n7[h]+Wo[h]|0,b=(as(n,2)^as(n,13)^as(n,22))+KW(n,i,s)|0;u=l,l=c,c=a,a=o+m|0,o=s,s=i,i=n,n=m+b|0}n=n+this.A|0,i=i+this.B|0,s=s+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,l=l+this.G|0,u=u+this.H|0,this.set(n,i,s,o,a,c,l,u)}roundClean(){Lc(Wo)}destroy(){this.set(0,0,0,0,0,0,0,0),Lc(this.buffer)}},i7=class extends r7{constructor(){super(32);f(this,"A",Go[0]|0);f(this,"B",Go[1]|0);f(this,"C",Go[2]|0);f(this,"D",Go[3]|0);f(this,"E",Go[4]|0);f(this,"F",Go[5]|0);f(this,"G",Go[6]|0);f(this,"H",Go[7]|0)}};const tN=YW(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),s7=tN[0],o7=tN[1],qo=new Uint32Array(80),Ko=new Uint32Array(80);let a7=class extends eN{constructor(e){super(128,e,16,!1)}get(){const{Ah:e,Al:t,Bh:n,Bl:i,Ch:s,Cl:o,Dh:a,Dl:c,Eh:l,El:u,Fh:h,Fl:d,Gh:m,Gl:p,Hh:b,Hl:g}=this;return[e,t,n,i,s,o,a,c,l,u,h,d,m,p,b,g]}set(e,t,n,i,s,o,a,c,l,u,h,d,m,p,b,g){this.Ah=e|0,this.Al=t|0,this.Bh=n|0,this.Bl=i|0,this.Ch=s|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=l|0,this.El=u|0,this.Fh=h|0,this.Fl=d|0,this.Gh=m|0,this.Gl=p|0,this.Hh=b|0,this.Hl=g|0}process(e,t){for(let w=0;w<16;w++,t+=4)qo[w]=e.getUint32(t),Ko[w]=e.getUint32(t+=4);for(let w=16;w<80;w++){const _=qo[w-15]|0,M=Ko[w-15]|0,E=El(_,M,1)^El(_,M,8)^r2(_,M,7),C=Ml(_,M,1)^Ml(_,M,8)^i2(_,M,7),I=qo[w-2]|0,x=Ko[w-2]|0,T=El(I,x,19)^wm(I,x,61)^r2(I,x,6),F=Ml(I,x,19)^vm(I,x,61)^i2(I,x,6),$=jW(C,F,Ko[w-7],Ko[w-16]),H=QW($,E,T,qo[w-7],qo[w-16]);qo[w]=H|0,Ko[w]=$|0}let{Ah:n,Al:i,Bh:s,Bl:o,Ch:a,Cl:c,Dh:l,Dl:u,Eh:h,El:d,Fh:m,Fl:p,Gh:b,Gl:g,Hh:y,Hl:v}=this;for(let w=0;w<80;w++){const _=El(h,d,14)^El(h,d,18)^wm(h,d,41),M=Ml(h,d,14)^Ml(h,d,18)^vm(h,d,41),E=h&m^~h&b,C=d&p^~d&g,I=e7(v,M,C,o7[w],Ko[w]),x=t7(I,y,_,E,s7[w],qo[w]),T=I|0,F=El(n,i,28)^wm(n,i,34)^wm(n,i,39),$=Ml(n,i,28)^vm(n,i,34)^vm(n,i,39),H=n&s^n&a^s&a,S=i&o^i&c^o&c;y=b|0,v=g|0,b=m|0,g=p|0,m=h|0,p=d|0,{h,l:d}=Hs(l|0,u|0,x|0,T|0),l=a|0,u=c|0,a=s|0,c=o|0,s=n|0,o=i|0;const A=ZW(T,$,S);n=JW(A,x,F,H),i=A|0}({h:n,l:i}=Hs(this.Ah|0,this.Al|0,n|0,i|0)),{h:s,l:o}=Hs(this.Bh|0,this.Bl|0,s|0,o|0),{h:a,l:c}=Hs(this.Ch|0,this.Cl|0,a|0,c|0),{h:l,l:u}=Hs(this.Dh|0,this.Dl|0,l|0,u|0),{h,l:d}=Hs(this.Eh|0,this.El|0,h|0,d|0),{h:m,l:p}=Hs(this.Fh|0,this.Fl|0,m|0,p|0),{h:b,l:g}=Hs(this.Gh|0,this.Gl|0,b|0,g|0),{h:y,l:v}=Hs(this.Hh|0,this.Hl|0,y|0,v|0),this.set(n,i,s,o,a,c,l,u,h,d,m,p,b,g,y,v)}roundClean(){Lc(qo,Ko)}destroy(){Lc(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}},c7=class extends a7{constructor(){super(64);f(this,"Ah",Yn[0]|0);f(this,"Al",Yn[1]|0);f(this,"Bh",Yn[2]|0);f(this,"Bl",Yn[3]|0);f(this,"Ch",Yn[4]|0);f(this,"Cl",Yn[5]|0);f(this,"Dh",Yn[6]|0);f(this,"Dl",Yn[7]|0);f(this,"Eh",Yn[8]|0);f(this,"El",Yn[9]|0);f(this,"Fh",Yn[10]|0);f(this,"Fl",Yn[11]|0);f(this,"Gh",Yn[12]|0);f(this,"Gl",Yn[13]|0);f(this,"Hh",Yn[14]|0);f(this,"Hl",Yn[15]|0)}};const Rd=j3(()=>new i7,Q3(1)),l7=j3(()=>new c7,Q3(3));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const m1=BigInt(0),jx=BigInt(1);function Nc(r,e=""){if(typeof r!="boolean"){const t=e&&`"${e}" `;throw new Error(t+"expected boolean, got type="+typeof r)}return r}function nN(r){if(typeof r=="bigint"){if(!gg(r))throw new Error("positive bigint expected, got "+r)}else Ea(r);return r}function _m(r){const e=nN(r).toString(16);return e.length&1?"0"+e:e}function rN(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?m1:BigInt("0x"+r)}function L0(r){return rN(cp(r))}function Oc(r){return rN(cp(hf(lt(r)).reverse()))}function g1(r,e){Ea(e),r=nN(r);const t=uf(r.toString(16).padStart(e*2,"0"));if(t.length!==e)throw new Error("number too large");return t}function y1(r,e){return g1(r,e).reverse()}function hf(r){return Uint8Array.from(r)}const gg=r=>typeof r=="bigint"&&m1<=r;function u7(r,e,t){return gg(r)&&gg(e)&&gg(t)&&e<=r&&r<t}function df(r,e,t,n){if(!u7(e,t,n))throw new Error("expected valid "+r+": "+t+" <= n < "+n+", got "+e)}function h7(r){let e;for(e=0;r>m1;r>>=jx,e+=1);return e}const b1=r=>(jx<<BigInt(r))-jx;function d7(r,e,t){if(Ea(r,"hashLen"),Ea(e,"qByteLen"),typeof t!="function")throw new Error("hmacFn must be a function");const n=g=>new Uint8Array(g),i=Uint8Array.of(),s=Uint8Array.of(0),o=Uint8Array.of(1),a=1e3;let c=n(r),l=n(r),u=0;const h=()=>{c.fill(1),l.fill(0),u=0},d=(...g)=>t(l,_s(c,...g)),m=(g=i)=>{l=d(s,g),c=d(),g.length!==0&&(l=d(o,g),c=d())},p=()=>{if(u++>=a)throw new Error("drbg: tried max amount of iterations");let g=0;const y=[];for(;g<e;){c=d();const v=c.slice();y.push(v),g+=c.length}return _s(...y)};return(g,y)=>{h(),m(g);let v;for(;!(v=y(p()));)m();return h(),v}}function bh(r,e={},t={}){if(!r||typeof r!="object")throw new Error("expected valid options object");function n(s,o,a){const c=r[s];if(a&&c===void 0)return;const l=typeof c;if(l!==o||c===null)throw new Error(`param "${s}" is invalid: expected ${o}, got ${l}`)}const i=(s,o)=>Object.entries(s).forEach(([a,c])=>n(a,c,o));i(e,!1),i(t,!0)}function Xg(r){const e=new WeakMap;return(t,...n)=>{const i=e.get(t);if(i!==void 0)return i;const s=r(t,...n);return e.set(t,s),s}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const $r=BigInt(0),Fn=BigInt(1),ac=BigInt(2),iN=BigInt(3),sN=BigInt(4),oN=BigInt(5),f7=BigInt(7),aN=BigInt(8),p7=BigInt(9),cN=BigInt(16);function nn(r,e){const t=r%e;return t>=$r?t:e+t}function Kt(r,e,t){let n=r;for(;e-- >$r;)n*=n,n%=t;return n}function s2(r,e){if(r===$r)throw new Error("invert: expected non-zero number");if(e<=$r)throw new Error("invert: expected positive modulus, got "+e);let t=nn(r,e),n=e,i=$r,s=Fn;for(;t!==$r;){const a=n/t,c=n%t,l=i-s*a;n=t,t=c,i=s,s=l}if(n!==Fn)throw new Error("invert: does not exist");return nn(i,e)}function w1(r,e,t){if(!r.eql(r.sqr(e),t))throw new Error("Cannot find square root")}function lN(r,e){const t=(r.ORDER+Fn)/sN,n=r.pow(e,t);return w1(r,n,e),n}function m7(r,e){const t=(r.ORDER-oN)/aN,n=r.mul(e,ac),i=r.pow(n,t),s=r.mul(e,i),o=r.mul(r.mul(s,ac),i),a=r.mul(s,r.sub(o,r.ONE));return w1(r,a,e),a}function g7(r){const e=N0(r),t=uN(r),n=t(e,e.neg(e.ONE)),i=t(e,n),s=t(e,e.neg(n)),o=(r+f7)/cN;return(a,c)=>{let l=a.pow(c,o),u=a.mul(l,n);const h=a.mul(l,i),d=a.mul(l,s),m=a.eql(a.sqr(u),c),p=a.eql(a.sqr(h),c);l=a.cmov(l,u,m),u=a.cmov(d,h,p);const b=a.eql(a.sqr(u),c),g=a.cmov(l,u,b);return w1(a,g,c),g}}function uN(r){if(r<iN)throw new Error("sqrt is not defined for small field");let e=r-Fn,t=0;for(;e%ac===$r;)e/=ac,t++;let n=ac;const i=N0(r);for(;o2(i,n)===1;)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return lN;let s=i.pow(n,e);const o=(e+Fn)/ac;return function(c,l){if(c.is0(l))return l;if(o2(c,l)!==1)throw new Error("Cannot find square root");let u=t,h=c.mul(c.ONE,s),d=c.pow(l,e),m=c.pow(l,o);for(;!c.eql(d,c.ONE);){if(c.is0(d))return c.ZERO;let p=1,b=c.sqr(d);for(;!c.eql(b,c.ONE);)if(p++,b=c.sqr(b),p===u)throw new Error("Cannot find square root");const g=Fn<<BigInt(u-p-1),y=c.pow(h,g);u=p,h=c.sqr(y),d=c.mul(d,h),m=c.mul(m,y)}return m}}function y7(r){return r%sN===iN?lN:r%aN===oN?m7:r%cN===p7?g7(r):uN(r)}const b7=(r,e)=>(nn(r,e)&Fn)===Fn,w7=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function v7(r){const e={ORDER:"bigint",BYTES:"number",BITS:"number"},t=w7.reduce((n,i)=>(n[i]="function",n),e);return bh(r,t),r}function _7(r,e,t){if(t<$r)throw new Error("invalid exponent, negatives unsupported");if(t===$r)return r.ONE;if(t===Fn)return e;let n=r.ONE,i=e;for(;t>$r;)t&Fn&&(n=r.mul(n,i)),i=r.sqr(i),t>>=Fn;return n}function hN(r,e,t=!1){const n=new Array(e.length).fill(t?r.ZERO:void 0),i=e.reduce((o,a,c)=>r.is0(a)?o:(n[c]=o,r.mul(o,a)),r.ONE),s=r.inv(i);return e.reduceRight((o,a,c)=>r.is0(a)?o:(n[c]=r.mul(o,n[c]),r.mul(o,a)),s),n}function o2(r,e){const t=(r.ORDER-Fn)/ac,n=r.pow(e,t),i=r.eql(n,r.ONE),s=r.eql(n,r.ZERO),o=r.eql(n,r.neg(r.ONE));if(!i&&!s&&!o)throw new Error("invalid Legendre symbol result");return i?1:s?0:-1}function x7(r,e){e!==void 0&&Ea(e);const t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}let S7=class{constructor(e,t={}){f(this,"ORDER");f(this,"BITS");f(this,"BYTES");f(this,"isLE");f(this,"ZERO",$r);f(this,"ONE",Fn);f(this,"_lengths");f(this,"_sqrt");f(this,"_mod");var o;if(e<=$r)throw new Error("invalid field: expected ORDER > 0, got "+e);let n;this.isLE=!1,t!=null&&typeof t=="object"&&(typeof t.BITS=="number"&&(n=t.BITS),typeof t.sqrt=="function"&&(this.sqrt=t.sqrt),typeof t.isLE=="boolean"&&(this.isLE=t.isLE),t.allowedLengths&&(this._lengths=(o=t.allowedLengths)==null?void 0:o.slice()),typeof t.modFromBytes=="boolean"&&(this._mod=t.modFromBytes));const{nBitLength:i,nByteLength:s}=x7(e,n);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=e,this.BITS=i,this.BYTES=s,this._sqrt=void 0,Object.preventExtensions(this)}create(e){return nn(e,this.ORDER)}isValid(e){if(typeof e!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof e);return $r<=e&&e<this.ORDER}is0(e){return e===$r}isValidNot0(e){return!this.is0(e)&&this.isValid(e)}isOdd(e){return(e&Fn)===Fn}neg(e){return nn(-e,this.ORDER)}eql(e,t){return e===t}sqr(e){return nn(e*e,this.ORDER)}add(e,t){return nn(e+t,this.ORDER)}sub(e,t){return nn(e-t,this.ORDER)}mul(e,t){return nn(e*t,this.ORDER)}pow(e,t){return _7(this,e,t)}div(e,t){return nn(e*s2(t,this.ORDER),this.ORDER)}sqrN(e){return e*e}addN(e,t){return e+t}subN(e,t){return e-t}mulN(e,t){return e*t}inv(e){return s2(e,this.ORDER)}sqrt(e){return this._sqrt||(this._sqrt=y7(this.ORDER)),this._sqrt(this,e)}toBytes(e){return this.isLE?y1(e,this.BYTES):g1(e,this.BYTES)}fromBytes(e,t=!1){lt(e);const{_lengths:n,BYTES:i,isLE:s,ORDER:o,_mod:a}=this;if(n){if(!n.includes(e.length)||e.length>i)throw new Error("Field.fromBytes: expected "+n+" bytes, got "+e.length);const l=new Uint8Array(i);l.set(e,s?0:l.length-e.length),e=l}if(e.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+e.length);let c=s?Oc(e):L0(e);if(a&&(c=nn(c,o)),!t&&!this.isValid(c))throw new Error("invalid field element: outside of range 0..ORDER");return c}invertBatch(e){return hN(this,e)}cmov(e,t,n){return n?t:e}};function N0(r,e={}){return new S7(r,e)}function dN(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const e=r.toString(2).length;return Math.ceil(e/8)}function fN(r){const e=dN(r);return e+Math.ceil(e/2)}function E7(r,e,t=!1){lt(r);const n=r.length,i=dN(e),s=fN(e);if(n<16||n<s||n>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+n);const o=t?Oc(r):L0(r),a=nn(o,e-Fn)+Fn;return t?y1(a,i):g1(a,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Vu=BigInt(0),cc=BigInt(1);function Yg(r,e){const t=e.negate();return r?t:e}function Dd(r,e){const t=hN(r.Fp,e.map(n=>n.Z));return e.map((n,i)=>r.fromAffine(n.toAffine(t[i])))}function pN(r,e){if(!Number.isSafeInteger(r)||r<=0||r>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+r)}function tw(r,e){pN(r,e);const t=Math.ceil(e/r)+1,n=2**(r-1),i=2**r,s=b1(r),o=BigInt(r);return{windows:t,windowSize:n,mask:s,maxNumber:i,shiftBy:o}}function a2(r,e,t){const{windowSize:n,mask:i,maxNumber:s,shiftBy:o}=t;let a=Number(r&i),c=r>>o;a>n&&(a-=s,c+=cc);const l=e*n,u=l+Math.abs(a)-1,h=a===0,d=a<0,m=e%2!==0;return{nextN:c,offset:u,isZero:h,isNeg:d,isNegF:m,offsetF:l}}const nw=new WeakMap,mN=new WeakMap;function rw(r){return mN.get(r)||1}function c2(r){if(r!==Vu)throw new Error("invalid wNAF")}let gN=class{constructor(e,t){f(this,"BASE");f(this,"ZERO");f(this,"Fn");f(this,"bits");this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=t}_unsafeLadder(e,t,n=this.ZERO){let i=e;for(;t>Vu;)t&cc&&(n=n.add(i)),i=i.double(),t>>=cc;return n}precomputeWindow(e,t){const{windows:n,windowSize:i}=tw(t,this.bits),s=[];let o=e,a=o;for(let c=0;c<n;c++){a=o,s.push(a);for(let l=1;l<i;l++)a=a.add(o),s.push(a);o=a.double()}return s}wNAF(e,t,n){if(!this.Fn.isValid(n))throw new Error("invalid scalar");let i=this.ZERO,s=this.BASE;const o=tw(e,this.bits);for(let a=0;a<o.windows;a++){const{nextN:c,offset:l,isZero:u,isNeg:h,isNegF:d,offsetF:m}=a2(n,a,o);n=c,u?s=s.add(Yg(d,t[m])):i=i.add(Yg(h,t[l]))}return c2(n),{p:i,f:s}}wNAFUnsafe(e,t,n,i=this.ZERO){const s=tw(e,this.bits);for(let o=0;o<s.windows&&n!==Vu;o++){const{nextN:a,offset:c,isZero:l,isNeg:u}=a2(n,o,s);if(n=a,!l){const h=t[c];i=i.add(u?h.negate():h)}}return c2(n),i}getPrecomputes(e,t,n){let i=nw.get(t);return i||(i=this.precomputeWindow(t,e),e!==1&&(typeof n=="function"&&(i=n(i)),nw.set(t,i))),i}cached(e,t,n){const i=rw(e);return this.wNAF(i,this.getPrecomputes(i,e,n),t)}unsafe(e,t,n,i){const s=rw(e);return s===1?this._unsafeLadder(e,t,i):this.wNAFUnsafe(s,this.getPrecomputes(s,e,n),t,i)}createCache(e,t){pN(t,this.bits),mN.set(e,t),nw.delete(e)}hasCache(e){return rw(e)!==1}};function M7(r,e,t,n){let i=e,s=r.ZERO,o=r.ZERO;for(;t>Vu||n>Vu;)t&cc&&(s=s.add(i)),n&cc&&(o=o.add(i)),i=i.double(),t>>=cc,n>>=cc;return{p1:s,p2:o}}function l2(r,e,t){if(e){if(e.ORDER!==r)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return v7(e),e}else return N0(r,{isLE:t})}function yN(r,e,t={},n){if(n===void 0&&(n=r==="edwards"),!e||typeof e!="object")throw new Error(`expected valid ${r} CURVE object`);for(const c of["p","n","h"]){const l=e[c];if(!(typeof l=="bigint"&&l>Vu))throw new Error(`CURVE.${c} must be positive bigint`)}const i=l2(e.p,t.Fp,n),s=l2(e.n,t.Fn,n),a=["Gx","Gy","a",r==="weierstrass"?"b":"d"];for(const c of a)if(!i.isValid(e[c]))throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);return e=Object.freeze(Object.assign({},e)),{CURVE:e,Fp:i,Fn:s}}function v1(r,e){return function(n){const i=r(n);return{secretKey:i,publicKey:e(i)}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Xo=BigInt(0),An=BigInt(1),iw=BigInt(2),A7=BigInt(8);function T7(r,e,t,n){const i=r.sqr(t),s=r.sqr(n),o=r.add(r.mul(e.a,i),s),a=r.add(r.ONE,r.mul(e.d,r.mul(i,s)));return r.eql(o,a)}function C7(r,e={}){const t=yN("edwards",r,e,e.FpFnLE),{Fp:n,Fn:i}=t;let s=t.CURVE;const{h:o}=s;bh(e,{},{uvRatio:"function"});const a=iw<<BigInt(i.BYTES*8)-An,c=y=>n.create(y),l=e.uvRatio||((y,v)=>{try{return{isValid:!0,value:n.sqrt(n.div(y,v))}}catch{return{isValid:!1,value:Xo}}});if(!T7(n,s,s.Gx,s.Gy))throw new Error("bad curve params: generator point");function u(y,v,w=!1){const _=w?An:Xo;return df("coordinate "+y,v,_,a),v}function h(y){if(!(y instanceof p))throw new Error("EdwardsPoint expected")}const d=Xg((y,v)=>{const{X:w,Y:_,Z:M}=y,E=y.is0();v==null&&(v=E?A7:n.inv(M));const C=c(w*v),I=c(_*v),x=n.mul(M,v);if(E)return{x:Xo,y:An};if(x!==An)throw new Error("invZ was invalid");return{x:C,y:I}}),m=Xg(y=>{const{a:v,d:w}=s;if(y.is0())throw new Error("bad point: ZERO");const{X:_,Y:M,Z:E,T:C}=y,I=c(_*_),x=c(M*M),T=c(E*E),F=c(T*T),$=c(I*v),H=c(T*c($+x)),S=c(F+c(w*c(I*x)));if(H!==S)throw new Error("bad point: equation left != right (1)");const A=c(_*M),P=c(E*C);if(A!==P)throw new Error("bad point: equation left != right (2)");return!0}),g=class g{constructor(v,w,_,M){f(this,"X");f(this,"Y");f(this,"Z");f(this,"T");this.X=u("x",v),this.Y=u("y",w),this.Z=u("z",_,!0),this.T=u("t",M),Object.freeze(this)}static CURVE(){return s}static fromAffine(v){if(v instanceof g)throw new Error("extended point not allowed");const{x:w,y:_}=v||{};return u("x",w),u("y",_),new g(w,_,An,c(w*_))}static fromBytes(v,w=!1){const _=n.BYTES,{a:M,d:E}=s;v=hf(lt(v,_,"point")),Nc(w,"zip215");const C=hf(v),I=v[_-1];C[_-1]=I&-129;const x=Oc(C),T=w?a:n.ORDER;df("point.y",x,Xo,T);const F=c(x*x),$=c(F-An),H=c(E*F-M);let{isValid:S,value:A}=l($,H);if(!S)throw new Error("bad point: invalid y coordinate");const P=(A&An)===An,L=(I&128)!==0;if(!w&&A===Xo&&L)throw new Error("bad point: x=0 and x_0=1");return L!==P&&(A=c(-A)),g.fromAffine({x:A,y:x})}static fromHex(v,w=!1){return g.fromBytes(uf(v),w)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(v=8,w=!0){return b.createCache(this,v),w||this.multiply(iw),this}assertValidity(){m(this)}equals(v){h(v);const{X:w,Y:_,Z:M}=this,{X:E,Y:C,Z:I}=v,x=c(w*I),T=c(E*M),F=c(_*I),$=c(C*M);return x===T&&F===$}is0(){return this.equals(g.ZERO)}negate(){return new g(c(-this.X),this.Y,this.Z,c(-this.T))}double(){const{a:v}=s,{X:w,Y:_,Z:M}=this,E=c(w*w),C=c(_*_),I=c(iw*c(M*M)),x=c(v*E),T=w+_,F=c(c(T*T)-E-C),$=x+C,H=$-I,S=x-C,A=c(F*H),P=c($*S),L=c(F*S),B=c(H*$);return new g(A,P,B,L)}add(v){h(v);const{a:w,d:_}=s,{X:M,Y:E,Z:C,T:I}=this,{X:x,Y:T,Z:F,T:$}=v,H=c(M*x),S=c(E*T),A=c(I*_*$),P=c(C*F),L=c((M+E)*(x+T)-H-S),B=P-A,D=P+A,V=c(S-w*H),z=c(L*B),q=c(D*V),G=c(L*V),Y=c(B*D);return new g(z,q,Y,G)}subtract(v){return this.add(v.negate())}multiply(v){if(!i.isValidNot0(v))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:w,f:_}=b.cached(this,v,M=>Dd(g,M));return Dd(g,[w,_])[0]}multiplyUnsafe(v,w=g.ZERO){if(!i.isValid(v))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return v===Xo?g.ZERO:this.is0()||v===An?this:b.unsafe(this,v,_=>Dd(g,_),w)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}isTorsionFree(){return b.unsafe(this,s.n).is0()}toAffine(v){return d(this,v)}clearCofactor(){return o===An?this:this.multiplyUnsafe(o)}toBytes(){const{x:v,y:w}=this.toAffine(),_=n.toBytes(w);return _[_.length-1]|=v&An?128:0,_}toHex(){return cp(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}};f(g,"BASE",new g(s.Gx,s.Gy,An,c(s.Gx*s.Gy))),f(g,"ZERO",new g(Xo,An,An,Xo)),f(g,"Fp",n),f(g,"Fn",i);let p=g;const b=new gN(p,i.BITS);return p.BASE.precompute(8),p}function I7(r,e,t={}){if(typeof e!="function")throw new Error('"hash" function param is required');bh(t,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:n}=t,{BASE:i,Fp:s,Fn:o}=r,a=t.randomBytes||lp,c=t.adjustScalarBytes||(I=>I),l=t.domain||((I,x,T)=>{if(Nc(T,"phflag"),x.length||T)throw new Error("Contexts/pre-hash are not supported");return I});function u(I){return o.create(Oc(I))}function h(I){const x=w.secretKey;lt(I,w.secretKey,"secretKey");const T=lt(e(I),2*x,"hashedSecretKey"),F=c(T.slice(0,x)),$=T.slice(x,2*x),H=u(F);return{head:F,prefix:$,scalar:H}}function d(I){const{head:x,prefix:T,scalar:F}=h(I),$=i.multiply(F),H=$.toBytes();return{head:x,prefix:T,scalar:F,point:$,pointBytes:H}}function m(I){return d(I).pointBytes}function p(I=Uint8Array.of(),...x){const T=_s(...x);return u(e(l(T,lt(I,void 0,"context"),!!n)))}function b(I,x,T={}){I=lt(I,void 0,"message"),n&&(I=n(I));const{prefix:F,scalar:$,pointBytes:H}=d(x),S=p(T.context,F,I),A=i.multiply(S).toBytes(),P=p(T.context,A,H,I),L=o.create(S+P*$);if(!o.isValid(L))throw new Error("sign failed: invalid s");const B=_s(A,o.toBytes(L));return lt(B,w.signature,"result")}const g={zip215:!0};function y(I,x,T,F=g){const{context:$,zip215:H}=F,S=w.signature;I=lt(I,S,"signature"),x=lt(x,void 0,"message"),T=lt(T,w.publicKey,"publicKey"),H!==void 0&&Nc(H,"zip215"),n&&(x=n(x));const A=S/2,P=I.subarray(0,A),L=Oc(I.subarray(A,S));let B,D,V;try{B=r.fromBytes(T,H),D=r.fromBytes(P,H),V=i.multiplyUnsafe(L)}catch{return!1}if(!H&&B.isSmallOrder())return!1;const z=p($,D.toBytes(),B.toBytes(),x);return D.add(B.multiplyUnsafe(z)).subtract(V).clearCofactor().is0()}const v=s.BYTES,w={secretKey:v,publicKey:v,signature:2*v,seed:v};function _(I=a(w.seed)){return lt(I,w.seed,"seed")}function M(I){return R0(I)&&I.length===o.BYTES}function E(I,x){try{return!!r.fromBytes(I,x)}catch{return!1}}const C={getExtendedPublicKey:d,randomSecretKey:_,isValidSecretKey:M,isValidPublicKey:E,toMontgomery(I){const{y:x}=r.fromBytes(I),T=w.publicKey,F=T===32;if(!F&&T!==57)throw new Error("only defined for 25519 and 448");const $=F?s.div(An+x,An-x):s.div(x-An,x+An);return s.toBytes($)},toMontgomerySecret(I){const x=w.secretKey;lt(I,x);const T=e(I.subarray(0,x));return c(T).subarray(0,x)}};return Object.freeze({keygen:v1(_,m),getPublicKey:m,sign:b,verify:y,utils:C,Point:r,lengths:w})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Xh=BigInt(0),Al=BigInt(1),xm=BigInt(2);function P7(r){return bh(r,{adjustScalarBytes:"function",powPminus2:"function"}),Object.freeze({...r})}function R7(r){const e=P7(r),{P:t,type:n,adjustScalarBytes:i,powPminus2:s,randomBytes:o}=e,a=n==="x25519";if(!a&&n!=="x448")throw new Error("invalid type");const c=o||lp,l=a?255:448,u=a?32:56,h=BigInt(a?9:5),d=BigInt(a?121665:39081),m=a?xm**BigInt(254):xm**BigInt(447),p=a?BigInt(8)*xm**BigInt(251)-Al:BigInt(4)*xm**BigInt(445)-Al,b=m+p+Al,g=S=>nn(S,t),y=v(h);function v(S){return y1(g(S),u)}function w(S){const A=hf(lt(S,u,"uCoordinate"));return a&&(A[31]&=127),g(Oc(A))}function _(S){return Oc(i(hf(lt(S,u,"scalar"))))}function M(S,A){const P=T(w(A),_(S));if(P===Xh)throw new Error("invalid private or public key received");return v(P)}function E(S){return M(S,y)}const C=E,I=M;function x(S,A,P){const L=g(S*(A-P));return A=g(A-L),P=g(P+L),{x_2:A,x_3:P}}function T(S,A){df("u",S,Xh,t),df("scalar",A,m,b);const P=A,L=S;let B=Al,D=Xh,V=S,z=Al,q=Xh;for(let Y=BigInt(l-1);Y>=Xh;Y--){const j=P>>Y&Al;q^=j,{x_2:B,x_3:V}=x(q,B,V),{x_2:D,x_3:z}=x(q,D,z),q=j;const X=B+D,ne=g(X*X),oe=B-D,he=g(oe*oe),ce=ne-he,fe=V+z,W=V-z,ue=g(W*X),re=g(fe*oe),le=ue+re,ie=ue-re;V=g(le*le),z=g(L*g(ie*ie)),B=g(ne*he),D=g(ce*(ne+g(d*ce)))}({x_2:B,x_3:V}=x(q,B,V)),{x_2:D,x_3:z}=x(q,D,z);const G=s(D);return g(B*G)}const F={secretKey:u,publicKey:u,seed:u},$=(S=c(u))=>(lt(S,F.seed,"seed"),S),H={randomSecretKey:$};return Object.freeze({keygen:v1($,C),getSharedSecret:I,getPublicKey:C,scalarMult:M,scalarMultBase:E,utils:H,GuBytes:y.slice(),lengths:F})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const D7=BigInt(1),u2=BigInt(2),L7=BigInt(3),N7=BigInt(5),O7=BigInt(8),O0=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),U7={p:O0,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:O7,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function bN(r){const e=BigInt(10),t=BigInt(20),n=BigInt(40),i=BigInt(80),s=O0,a=r*r%s*r%s,c=Kt(a,u2,s)*a%s,l=Kt(c,D7,s)*r%s,u=Kt(l,N7,s)*l%s,h=Kt(u,e,s)*u%s,d=Kt(h,t,s)*h%s,m=Kt(d,n,s)*d%s,p=Kt(m,i,s)*m%s,b=Kt(p,i,s)*m%s,g=Kt(b,e,s)*u%s;return{pow_p_5_8:Kt(g,u2,s)*r%s,b2:a}}function wN(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}const h2=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function k7(r,e){const t=O0,n=nn(e*e*e,t),i=nn(n*n*e,t),s=bN(r*i).pow_p_5_8;let o=nn(r*n*s,t);const a=nn(e*o*o,t),c=o,l=nn(o*h2,t),u=a===r,h=a===nn(-r,t),d=a===nn(-r*h2,t);return u&&(o=c),(h||d)&&(o=l),b7(o,t)&&(o=nn(-o,t)),{isValid:u||h,value:o}}const B7=C7(U7,{uvRatio:k7});function F7(r){return I7(B7,l7,Object.assign({adjustScalarBytes:wN},r))}const Zg=F7({}),Sm=(()=>{const r=O0;return R7({P:r,type:"x25519",powPminus2:e=>{const{pow_p_5_8:t,b2:n}=bN(e);return nn(Kt(t,L7,r)*n,r)},adjustScalarBytes:wN})})();let d2=class extends Error{constructor(e="An error occurred while verifying a message"){super(e),this.name="VerificationError"}},$7=class extends Error{constructor(e="Missing Web Crypto API"){super(e),this.name="WebCryptoMissingError"}};const Uc={get(r=globalThis){const e=r.crypto;if((e==null?void 0:e.subtle)==null)throw new $7("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return e}},_1=32,x1=64,Qx=32;let Yl;const vN=(async()=>{try{return await Uc.get().subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),!0}catch{return!1}})();function z7(){const r=Zg.utils.randomSecretKey(),e=Zg.getPublicKey(r);return{privateKey:X7(r,e),publicKey:e}}async function V7(r,e){let t;r.length===x1?t=r.subarray(0,32):t=r;const n={crv:"Ed25519",kty:"OKP",x:ae(r.subarray(32),"base64url"),d:ae(t,"base64url"),ext:!0,key_ops:["sign"]},i=await Uc.get().subtle.importKey("jwk",n,{name:"Ed25519"},!0,["sign"]),s=await Uc.get().subtle.sign({name:"Ed25519"},i,e instanceof Uint8Array?e:e.subarray());return new Uint8Array(s,0,s.byteLength)}function H7(r,e){const t=r.subarray(0,Qx);return Zg.sign(e instanceof Uint8Array?e:e.subarray(),t)}async function G7(r,e){return Yl==null&&(Yl=await vN),Yl?V7(r,e):H7(r,e)}async function W7(r,e,t){if(r.buffer instanceof ArrayBuffer){const n=await Uc.get().subtle.importKey("raw",r.buffer,{name:"Ed25519"},!1,["verify"]);return await Uc.get().subtle.verify({name:"Ed25519"},n,e,t instanceof Uint8Array?t:t.subarray())}throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys")}function q7(r,e,t){return Zg.verify(e,t instanceof Uint8Array?t:t.subarray(),r)}async function K7(r,e,t){return Yl==null&&(Yl=await vN),Yl?W7(r,e,t):q7(r,e,t)}function X7(r,e){const t=new Uint8Array(x1);for(let n=0;n<Qx;n++)t[n]=r[n],t[Qx+n]=e[n];return t}function S1(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}let _N=class{constructor(e){f(this,"type","Ed25519");f(this,"raw");this.raw=M1(e,_1)}toMultihash(){return dn.digest(Ms(this))}toCID(){return Ze.createV1(114,this.toMultihash())}toString(){return gt.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:We(this.raw,e.raw)}verify(e,t,n){var s;(s=n==null?void 0:n.signal)==null||s.throwIfAborted();const i=K7(this.raw,t,e);return S1(i)?i.then(o=>{var a;return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),o}):i}};class Y7{constructor(e,t){f(this,"type","Ed25519");f(this,"raw");f(this,"publicKey");this.raw=M1(e,x1),this.publicKey=new _N(t)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:We(this.raw,e.raw)}sign(e,t){var i,s;(i=t==null?void 0:t.signal)==null||i.throwIfAborted();const n=G7(this.raw,e);return S1(n)?n.then(o=>{var a;return(a=t==null?void 0:t.signal)==null||a.throwIfAborted(),o}):((s=t==null?void 0:t.signal)==null||s.throwIfAborted(),n)}}function E1(r){return r=M1(r,_1),new _N(r)}async function Z7(){const{privateKey:r,publicKey:e}=z7();return new Y7(r,e)}function M1(r,e){if(r=Uint8Array.from(r??[]),r.length!==e)throw new yh(`Key must be a Uint8Array of length ${e}, got ${r.length}`);return r}const J7=Math.pow(2,7),j7=Math.pow(2,14),Q7=Math.pow(2,21),A1=Math.pow(2,28),T1=Math.pow(2,35),C1=Math.pow(2,42),I1=Math.pow(2,49),Et=128,ur=127;function Ue(r){if(r<J7)return 1;if(r<j7)return 2;if(r<Q7)return 3;if(r<A1)return 4;if(r<T1)return 5;if(r<C1)return 6;if(r<I1)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function sn(r,e,t=0){switch(Ue(r)){case 8:e[t++]=r&255|Et,r/=128;case 7:e[t++]=r&255|Et,r/=128;case 6:e[t++]=r&255|Et,r/=128;case 5:e[t++]=r&255|Et,r/=128;case 4:e[t++]=r&255|Et,r>>>=7;case 3:e[t++]=r&255|Et,r>>>=7;case 2:e[t++]=r&255|Et,r>>>=7;case 1:{e[t++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return e}function eq(r,e,t=0){switch(Ue(r)){case 8:e.set(t++,r&255|Et),r/=128;case 7:e.set(t++,r&255|Et),r/=128;case 6:e.set(t++,r&255|Et),r/=128;case 5:e.set(t++,r&255|Et),r/=128;case 4:e.set(t++,r&255|Et),r>>>=7;case 3:e.set(t++,r&255|Et),r>>>=7;case 2:e.set(t++,r&255|Et),r>>>=7;case 1:{e.set(t++,r&255),r>>>=7;break}default:throw new Error("unreachable")}return e}function xN(r,e){let t=r[e],n=0;if(n+=t&ur,t<Et||(t=r[e+1],n+=(t&ur)<<7,t<Et)||(t=r[e+2],n+=(t&ur)<<14,t<Et)||(t=r[e+3],n+=(t&ur)<<21,t<Et)||(t=r[e+4],n+=(t&ur)*A1,t<Et)||(t=r[e+5],n+=(t&ur)*T1,t<Et)||(t=r[e+6],n+=(t&ur)*C1,t<Et)||(t=r[e+7],n+=(t&ur)*I1,t<Et))return n;throw new RangeError("Could not decode varint")}function tq(r,e){let t=r.get(e),n=0;if(n+=t&ur,t<Et||(t=r.get(e+1),n+=(t&ur)<<7,t<Et)||(t=r.get(e+2),n+=(t&ur)<<14,t<Et)||(t=r.get(e+3),n+=(t&ur)<<21,t<Et)||(t=r.get(e+4),n+=(t&ur)*A1,t<Et)||(t=r.get(e+5),n+=(t&ur)*T1,t<Et)||(t=r.get(e+6),n+=(t&ur)*C1,t<Et)||(t=r.get(e+7),n+=(t&ur)*I1,t<Et))return n;throw new RangeError("Could not decode varint")}function Zl(r,e,t=0){return e==null&&(e=ns(Ue(r))),e instanceof Uint8Array?sn(r,e,t):eq(r,e,t)}function Yt(r,e=0){return r instanceof Uint8Array?xN(r,e):tq(r,e)}const P1=new Float32Array([-0]),da=new Uint8Array(P1.buffer);function nq(r,e,t){P1[0]=r,e[t]=da[0],e[t+1]=da[1],e[t+2]=da[2],e[t+3]=da[3]}function rq(r,e){return da[0]=r[e],da[1]=r[e+1],da[2]=r[e+2],da[3]=r[e+3],P1[0]}const R1=new Float64Array([-0]),hr=new Uint8Array(R1.buffer);function iq(r,e,t){R1[0]=r,e[t]=hr[0],e[t+1]=hr[1],e[t+2]=hr[2],e[t+3]=hr[3],e[t+4]=hr[4],e[t+5]=hr[5],e[t+6]=hr[6],e[t+7]=hr[7]}function sq(r,e){return hr[0]=r[e],hr[1]=r[e+1],hr[2]=r[e+2],hr[3]=r[e+3],hr[4]=r[e+4],hr[5]=r[e+5],hr[6]=r[e+6],hr[7]=r[e+7],R1[0]}const oq=BigInt(Number.MAX_SAFE_INTEGER),aq=BigInt(Number.MIN_SAFE_INTEGER);let js=class Ja{constructor(e,t){f(this,"lo");f(this,"hi");this.lo=e|0,this.hi=t|0}toNumber(e=!1){if(!e&&this.hi>>>31>0){const t=~this.lo+1>>>0;let n=~this.hi>>>0;return t===0&&(n=n+1>>>0),-(t+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(e=!1){if(e)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const t=~this.lo+1>>>0;let n=~this.hi>>>0;return t===0&&(n=n+1>>>0),-(BigInt(t)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(e=!1){return this.toBigInt(e).toString()}zzEncode(){const e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this}zzDecode(){const e=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this}length(){const e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?t===0?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:n<128?9:10}static fromBigInt(e){if(e===0n)return Ac;if(e<oq&&e>aq)return this.fromNumber(Number(e));const t=e<0n;t&&(e=-e);let n=e>>32n,i=e-(n<<32n);return t&&(n=~n|0n,i=~i|0n,++i>f2&&(i=0n,++n>f2&&(n=0n))),new Ja(Number(i),Number(n))}static fromNumber(e){if(e===0)return Ac;const t=e<0;t&&(e=-e);let n=e>>>0,i=(e-n)/4294967296>>>0;return t&&(i=~i>>>0,n=~n>>>0,++n>4294967295&&(n=0,++i>4294967295&&(i=0))),new Ja(n,i)}static from(e){return typeof e=="number"?Ja.fromNumber(e):typeof e=="bigint"?Ja.fromBigInt(e):typeof e=="string"?Ja.fromBigInt(BigInt(e)):e.low!=null||e.high!=null?new Ja(e.low>>>0,e.high>>>0):Ac}};const Ac=new js(0,0);Ac.toBigInt=function(){return 0n};Ac.zzEncode=Ac.zzDecode=function(){return this};Ac.length=function(){return 1};const f2=4294967296n;function cq(r){let e=0,t=0;for(let n=0;n<r.length;++n)t=r.charCodeAt(n),t<128?e+=1:t<2048?e+=2:(t&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,e+=4):e+=3;return e}function lq(r,e,t){if(t-e<1)return"";let i;const s=[];let o=0,a;for(;e<t;)a=r[e++],a<128?s[o++]=a:a>191&&a<224?s[o++]=(a&31)<<6|r[e++]&63:a>239&&a<365?(a=((a&7)<<18|(r[e++]&63)<<12|(r[e++]&63)<<6|r[e++]&63)-65536,s[o++]=55296+(a>>10),s[o++]=56320+(a&1023)):s[o++]=(a&15)<<12|(r[e++]&63)<<6|r[e++]&63,o>8191&&((i??(i=[])).push(String.fromCharCode.apply(String,s)),o=0);return i!=null?(o>0&&i.push(String.fromCharCode.apply(String,s.slice(0,o))),i.join("")):String.fromCharCode.apply(String,s.slice(0,o))}function SN(r,e,t){const n=t;let i,s;for(let o=0;o<r.length;++o)i=r.charCodeAt(o),i<128?e[t++]=i:i<2048?(e[t++]=i>>6|192,e[t++]=i&63|128):(i&64512)===55296&&((s=r.charCodeAt(o+1))&64512)===56320?(i=65536+((i&1023)<<10)+(s&1023),++o,e[t++]=i>>18|240,e[t++]=i>>12&63|128,e[t++]=i>>6&63|128,e[t++]=i&63|128):(e[t++]=i>>12|224,e[t++]=i>>6&63|128,e[t++]=i&63|128);return t-n}function Ri(r,e){return RangeError(`index out of range: ${r.pos} + ${e??1} > ${r.len}`)}function Em(r,e){return(r[e-4]|r[e-3]<<8|r[e-2]<<16|r[e-1]<<24)>>>0}let uq=class{constructor(e){f(this,"buf");f(this,"pos");f(this,"len");f(this,"_slice",Uint8Array.prototype.subarray);this.buf=e,this.pos=0,this.len=e.length}uint32(){let e=4294967295;if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,Ri(this,10);return e}int32(){return this.uint32()|0}sint32(){const e=this.uint32();return e>>>1^-(e&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw Ri(this,4);return Em(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw Ri(this,4);return Em(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw Ri(this,4);const e=rq(this.buf,this.pos);return this.pos+=4,e}double(){if(this.pos+8>this.len)throw Ri(this,4);const e=sq(this.buf,this.pos);return this.pos+=8,e}bytes(){const e=this.uint32(),t=this.pos,n=this.pos+e;if(n>this.len)throw Ri(this,e);return this.pos+=e,t===n?new Uint8Array(0):this.buf.subarray(t,n)}string(){const e=this.bytes();return lq(e,0,e.length)}skip(e){if(typeof e=="number"){if(this.pos+e>this.len)throw Ri(this,e);this.pos+=e}else do if(this.pos>=this.len)throw Ri(this);while((this.buf[this.pos++]&128)!==0);return this}skipType(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(e=this.uint32()&7)!==4;)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${e} at offset ${this.pos}`)}return this}readLongVarint(){const e=new js(0,0);let t=0;if(this.len-this.pos>4){for(;t<4;++t)if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(this.buf[this.pos]&127)<<28)>>>0,e.hi=(e.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return e;t=0}else{for(;t<3;++t){if(this.pos>=this.len)throw Ri(this);if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(this.buf[this.pos++]&127)<<t*7)>>>0,e}if(this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw Ri(this);if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw Ri(this,8);const e=Em(this.buf,this.pos+=4),t=Em(this.buf,this.pos+=4);return new js(e,t)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const e=xN(this.buf,this.pos);return this.pos+=Ue(e),e}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}};function hq(r){return new uq(r instanceof Uint8Array?r:r.subarray())}function Vt(r,e,t){const n=hq(r);return e.decode(n,void 0,t)}function dq(r){let n,i=8192;return function(o){if(o<1||o>4096)return ns(o);i+o>8192&&(n=ns(8192),i=0);const a=n.subarray(i,i+=o);return(i&7)!==0&&(i=(i|7)+1),a}}let id=class{constructor(e,t,n){f(this,"fn");f(this,"len");f(this,"next");f(this,"val");this.fn=e,this.len=t,this.next=void 0,this.val=n}};function sw(){}let fq=class{constructor(e){f(this,"head");f(this,"tail");f(this,"len");f(this,"next");this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}};const pq=dq();function mq(r){return globalThis.Buffer!=null?ns(r):pq(r)}let eS=class{constructor(){f(this,"len");f(this,"head");f(this,"tail");f(this,"states");this.len=0,this.head=new id(sw,0,0),this.tail=this.head,this.states=null}_push(e,t,n){return this.tail=this.tail.next=new id(e,t,n),this.len+=t,this}uint32(e){return this.len+=(this.tail=this.tail.next=new yq((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this}int32(e){return e<0?this._push(Mm,10,js.fromNumber(e)):this.uint32(e)}sint32(e){return this.uint32((e<<1^e>>31)>>>0)}uint64(e){const t=js.fromBigInt(e);return this._push(Mm,t.length(),t)}uint64Number(e){return this._push(sn,Ue(e),e)}uint64String(e){return this.uint64(BigInt(e))}int64(e){return this.uint64(e)}int64Number(e){return this.uint64Number(e)}int64String(e){return this.uint64String(e)}sint64(e){const t=js.fromBigInt(e).zzEncode();return this._push(Mm,t.length(),t)}sint64Number(e){const t=js.fromNumber(e).zzEncode();return this._push(Mm,t.length(),t)}sint64String(e){return this.sint64(BigInt(e))}bool(e){return this._push(ow,1,e?1:0)}fixed32(e){return this._push(Yh,4,e>>>0)}sfixed32(e){return this.fixed32(e)}fixed64(e){const t=js.fromBigInt(e);return this._push(Yh,4,t.lo)._push(Yh,4,t.hi)}fixed64Number(e){const t=js.fromNumber(e);return this._push(Yh,4,t.lo)._push(Yh,4,t.hi)}fixed64String(e){return this.fixed64(BigInt(e))}sfixed64(e){return this.fixed64(e)}sfixed64Number(e){return this.fixed64Number(e)}sfixed64String(e){return this.fixed64String(e)}float(e){return this._push(nq,4,e)}double(e){return this._push(iq,8,e)}bytes(e){const t=e.length>>>0;return t===0?this._push(ow,1,0):this.uint32(t)._push(bq,t,e)}string(e){const t=cq(e);return t!==0?this.uint32(t)._push(SN,t,e):this._push(ow,1,0)}fork(){return this.states=new fq(this),this.head=this.tail=new id(sw,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new id(sw,0,0),this.len=0),this}ldelim(){const e=this.head,t=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=e.next,this.tail=t,this.len+=n),this}finish(){let e=this.head.next;const t=mq(this.len);let n=0;for(;e!=null;)e.fn(e.val,t,n),n+=e.len,e=e.next;return t}};function ow(r,e,t){e[t]=r&255}function gq(r,e,t){for(;r>127;)e[t++]=r&127|128,r>>>=7;e[t]=r}let yq=class extends id{constructor(t,n){super(gq,t,n);f(this,"next");this.next=void 0}};function Mm(r,e,t){for(;r.hi!==0;)e[t++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)e[t++]=r.lo&127|128,r.lo=r.lo>>>7;e[t++]=r.lo}function Yh(r,e,t){e[t]=r&255,e[t+1]=r>>>8&255,e[t+2]=r>>>16&255,e[t+3]=r>>>24}function bq(r,e,t){e.set(r,t)}globalThis.Buffer!=null&&(eS.prototype.bytes=function(r){const e=r.length>>>0;return this.uint32(e),e>0&&this._push(wq,e,r),this},eS.prototype.string=function(r){const e=globalThis.Buffer.byteLength(r);return this.uint32(e),e>0&&this._push(vq,e,r),this});function wq(r,e,t){e.set(r,t)}function vq(r,e,t){r.length<40?SN(r,e,t):e.utf8Write!=null?e.utf8Write(r,t):e.set(Se(r),t)}function _q(){return new eS}function Ht(r,e){const t=_q();return e.encode(r,t,{lengthDelimited:!1}),t.finish()}var Jg;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})(Jg||(Jg={}));function EN(r,e,t,n){return{name:r,type:e,encode:t,decode:n}}function Jc(r){function e(i){if(r[i.toString()]==null)throw new Error("Invalid enum value");return r[i]}const t=function(s,o){const a=e(s);o.int32(a)},n=function(s){const o=s.int32();return e(o)};return EN("enum",Jg.VARINT,t,n)}function Gt(r,e){return EN("message",Jg.LENGTH_DELIMITED,r,e)}let Cs=class extends Error{constructor(){super(...arguments);f(this,"code","ERR_MAX_LENGTH");f(this,"name","MaxLengthError")}};class p2 extends Error{constructor(){super(...arguments);f(this,"code","ERR_MAX_SIZE");f(this,"name","MaxSizeError")}}var Un;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1",r.ECDSA="ECDSA"})(Un||(Un={}));var tS;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1",r[r.ECDSA=3]="ECDSA"})(tS||(tS={}));(function(r){r.codec=()=>Jc(tS)})(Un||(Un={}));var Hu;(function(r){let e;r.codec=()=>(e==null&&(e=Gt((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.Type!=null&&(n.uint32(8),Un.codec().encode(t.Type,n)),t.Data!=null&&(n.uint32(18),n.bytes(t.Data)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.Type=Un.codec().decode(t);break}case 2:{s.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Ht(t,r.codec()),r.decode=(t,n)=>Vt(t,r.codec(),n)})(Hu||(Hu={}));var m2;(function(r){let e;r.codec=()=>(e==null&&(e=Gt((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.Type!=null&&(n.uint32(8),Un.codec().encode(t.Type,n)),t.Data!=null&&(n.uint32(18),n.bytes(t.Data)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.Type=Un.codec().decode(t);break}case 2:{s.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Ht(t,r.codec()),r.decode=(t,n)=>Vt(t,r.codec(),n)})(m2||(m2={}));function D1(r){if(isNaN(r)||r<=0)throw new yh("random bytes length must be a Number bigger than 0");return lp(r)}let xq=class{constructor(e,t){f(this,"type","RSA");f(this,"jwk");f(this,"_raw");f(this,"_multihash");this.jwk=e,this._multihash=t}get raw(){return this._raw==null&&(this._raw=Tq(this.jwk)),this._raw}toMultihash(){return this._multihash}toCID(){return Ze.createV1(114,this._multihash)}toString(){return gt.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:We(this.raw,e.raw)}verify(e,t,n){return Pq(this.jwk,t,e,n)}};const Sq=18,Eq=1062,Mq=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function Aq(r){const e=op(r[1],{offset:0});return{kty:"RSA",n:ae(e[0],"base64url"),e:ae(e[1],"base64url")}}function Tq(r){if(r.n==null||r.e==null)throw new yh("JWK was missing components");return Pd([Mq,X3(Pd([Jx(Se(r.n,"base64url")),Jx(Se(r.e,"base64url"))]))]).subarray()}function Cq(r,e){if(r.byteLength>=Eq)throw new k3("Key size is too large");const t=op(r,{offset:0});return MN(t,r,e)}function MN(r,e,t){const n=Aq(r);if(t==null){const i=Rd(Hu.encode({Type:Un.RSA,Data:e}));t=P0(Sq,i)}return new xq(n,t)}const Iq="1.2.840.113549.1.1.1";async function Pq(r,e,t,n){var o,a;const i=await Uc.get().subtle.importKey("jwk",r,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);(o=n==null?void 0:n.signal)==null||o.throwIfAborted();const s=await Uc.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},i,e,t instanceof Uint8Array?t:t.subarray());return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),s}let AN=class{constructor(e,t){f(this,"oHash");f(this,"iHash");f(this,"blockLen");f(this,"outputLen");f(this,"finished",!1);f(this,"destroyed",!1);if(D0(e),lt(t,void 0,"key"),this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,i=new Uint8Array(n);i.set(t.length>n?e.create().update(t).digest():t);for(let s=0;s<i.length;s++)i[s]^=54;this.iHash.update(i),this.oHash=e.create();for(let s=0;s<i.length;s++)i[s]^=106;this.oHash.update(i),Lc(i)}update(e){return Kg(this),this.iHash.update(e),this}digestInto(e){Kg(this),lt(e,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:i,destroyed:s,blockLen:o,outputLen:a}=this;return e=e,e.finished=i,e.destroyed=s,e.blockLen=o,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};const U0=(r,e,t)=>new AN(r,e).update(t).digest();U0.create=(r,e)=>new AN(r,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const g2=(r,e)=>(r+(r>=0?e:-e)/TN)/e;function Rq(r,e,t){const[[n,i],[s,o]]=e,a=g2(o*r,t),c=g2(-i*r,t);let l=r-a*n-c*s,u=-a*i-c*o;const h=l<oo,d=u<oo;h&&(l=-l),d&&(u=-u);const m=b1(Math.ceil(h7(t)/2))+Jl;if(l<oo||l>=m||u<oo||u>=m)throw new Error("splitScalar (endomorphism): failed, k="+r);return{k1neg:h,k1:l,k2neg:d,k2:u}}function nS(r){if(!["compact","recovered","der"].includes(r))throw new Error('Signature format must be "compact", "recovered", or "der"');return r}function aw(r,e){const t={};for(let n of Object.keys(e))t[n]=r[n]===void 0?e[n]:r[n];return Nc(t.lowS,"lowS"),Nc(t.prehash,"prehash"),t.format!==void 0&&nS(t.format),t}let Dq=class extends Error{constructor(e=""){super(e)}};const ra={Err:Dq,_tlv:{encode:(r,e)=>{const{Err:t}=ra;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const n=e.length/2,i=_m(n);if(i.length/2&128)throw new t("tlv.encode: long form length too big");const s=n>127?_m(i.length/2|128):"";return _m(r)+s+i+e},decode(r,e){const{Err:t}=ra;let n=0;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[n++]!==r)throw new t("tlv.decode: wrong tlv");const i=e[n++],s=!!(i&128);let o=0;if(!s)o=i;else{const c=i&127;if(!c)throw new t("tlv.decode(long): indefinite length not supported");if(c>4)throw new t("tlv.decode(long): byte length is too big");const l=e.subarray(n,n+c);if(l.length!==c)throw new t("tlv.decode: length bytes not complete");if(l[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const u of l)o=o<<8|u;if(n+=c,o<128)throw new t("tlv.decode(long): not minimal encoding")}const a=e.subarray(n,n+o);if(a.length!==o)throw new t("tlv.decode: wrong value length");return{v:a,l:e.subarray(n+o)}}},_int:{encode(r){const{Err:e}=ra;if(r<oo)throw new e("integer: negative integers are not allowed");let t=_m(r);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(r){const{Err:e}=ra;if(r[0]&128)throw new e("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return L0(r)}},toSig(r){const{Err:e,_int:t,_tlv:n}=ra,i=lt(r,void 0,"signature"),{v:s,l:o}=n.decode(48,i);if(o.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,s),{v:l,l:u}=n.decode(2,c);if(u.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(l)}},hexFromSig(r){const{_tlv:e,_int:t}=ra,n=e.encode(2,t.encode(r.r)),i=e.encode(2,t.encode(r.s)),s=n+i;return e.encode(48,s)}},oo=BigInt(0),Jl=BigInt(1),TN=BigInt(2),Am=BigInt(3),Lq=BigInt(4);function Nq(r,e={}){const t=yN("weierstrass",r,e),{Fp:n,Fn:i}=t;let s=t.CURVE;const{h:o,n:a}=s;bh(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});const{endo:c}=e;if(c&&(!n.is0(s.a)||typeof c.beta!="bigint"||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const l=IN(n,i);function u(){if(!n.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function h(H,S,A){const{x:P,y:L}=S.toAffine(),B=n.toBytes(P);if(Nc(A,"isCompressed"),A){u();const D=!n.isOdd(L);return _s(CN(D),B)}else return _s(Uint8Array.of(4),B,n.toBytes(L))}function d(H){lt(H,void 0,"Point");const{publicKey:S,publicKeyUncompressed:A}=l,P=H.length,L=H[0],B=H.subarray(1);if(P===S&&(L===2||L===3)){const D=n.fromBytes(B);if(!n.isValid(D))throw new Error("bad point: is not on curve, wrong x");const V=b(D);let z;try{z=n.sqrt(V)}catch(Y){const j=Y instanceof Error?": "+Y.message:"";throw new Error("bad point: is not on curve, sqrt error"+j)}u();const q=n.isOdd(z);return(L&1)===1!==q&&(z=n.neg(z)),{x:D,y:z}}else if(P===A&&L===4){const D=n.BYTES,V=n.fromBytes(B.subarray(0,D)),z=n.fromBytes(B.subarray(D,D*2));if(!g(V,z))throw new Error("bad point: is not on curve");return{x:V,y:z}}else throw new Error(`bad point: got length ${P}, expected compressed=${S} or uncompressed=${A}`)}const m=e.toBytes||h,p=e.fromBytes||d;function b(H){const S=n.sqr(H),A=n.mul(S,H);return n.add(n.add(A,n.mul(H,s.a)),s.b)}function g(H,S){const A=n.sqr(S),P=b(H);return n.eql(A,P)}if(!g(s.Gx,s.Gy))throw new Error("bad curve params: generator point");const y=n.mul(n.pow(s.a,Am),Lq),v=n.mul(n.sqr(s.b),BigInt(27));if(n.is0(n.add(y,v)))throw new Error("bad curve params: a or b");function w(H,S,A=!1){if(!n.isValid(S)||A&&n.is0(S))throw new Error(`bad point coordinate ${H}`);return S}function _(H){if(!(H instanceof x))throw new Error("Weierstrass Point expected")}function M(H){if(!c||!c.basises)throw new Error("no endo");return Rq(H,c.basises,i.ORDER)}const E=Xg((H,S)=>{const{X:A,Y:P,Z:L}=H;if(n.eql(L,n.ONE))return{x:A,y:P};const B=H.is0();S==null&&(S=B?n.ONE:n.inv(L));const D=n.mul(A,S),V=n.mul(P,S),z=n.mul(L,S);if(B)return{x:n.ZERO,y:n.ZERO};if(!n.eql(z,n.ONE))throw new Error("invZ was invalid");return{x:D,y:V}}),C=Xg(H=>{if(H.is0()){if(e.allowInfinityPoint&&!n.is0(H.Y))return;throw new Error("bad point: ZERO")}const{x:S,y:A}=H.toAffine();if(!n.isValid(S)||!n.isValid(A))throw new Error("bad point: x or y not field elements");if(!g(S,A))throw new Error("bad point: equation left != right");if(!H.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function I(H,S,A,P,L){return A=new x(n.mul(A.X,H),A.Y,A.Z),S=Yg(P,S),A=Yg(L,A),S.add(A)}const $=class ${constructor(S,A,P){f(this,"X");f(this,"Y");f(this,"Z");this.X=w("x",S),this.Y=w("y",A,!0),this.Z=w("z",P),Object.freeze(this)}static CURVE(){return s}static fromAffine(S){const{x:A,y:P}=S||{};if(!S||!n.isValid(A)||!n.isValid(P))throw new Error("invalid affine point");if(S instanceof $)throw new Error("projective point not allowed");return n.is0(A)&&n.is0(P)?$.ZERO:new $(A,P,n.ONE)}static fromBytes(S){const A=$.fromAffine(p(lt(S,void 0,"point")));return A.assertValidity(),A}static fromHex(S){return $.fromBytes(uf(S))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(S=8,A=!0){return F.createCache(this,S),A||this.multiply(Am),this}assertValidity(){C(this)}hasEvenY(){const{y:S}=this.toAffine();if(!n.isOdd)throw new Error("Field doesn't support isOdd");return!n.isOdd(S)}equals(S){_(S);const{X:A,Y:P,Z:L}=this,{X:B,Y:D,Z:V}=S,z=n.eql(n.mul(A,V),n.mul(B,L)),q=n.eql(n.mul(P,V),n.mul(D,L));return z&&q}negate(){return new $(this.X,n.neg(this.Y),this.Z)}double(){const{a:S,b:A}=s,P=n.mul(A,Am),{X:L,Y:B,Z:D}=this;let V=n.ZERO,z=n.ZERO,q=n.ZERO,G=n.mul(L,L),Y=n.mul(B,B),j=n.mul(D,D),X=n.mul(L,B);return X=n.add(X,X),q=n.mul(L,D),q=n.add(q,q),V=n.mul(S,q),z=n.mul(P,j),z=n.add(V,z),V=n.sub(Y,z),z=n.add(Y,z),z=n.mul(V,z),V=n.mul(X,V),q=n.mul(P,q),j=n.mul(S,j),X=n.sub(G,j),X=n.mul(S,X),X=n.add(X,q),q=n.add(G,G),G=n.add(q,G),G=n.add(G,j),G=n.mul(G,X),z=n.add(z,G),j=n.mul(B,D),j=n.add(j,j),G=n.mul(j,X),V=n.sub(V,G),q=n.mul(j,Y),q=n.add(q,q),q=n.add(q,q),new $(V,z,q)}add(S){_(S);const{X:A,Y:P,Z:L}=this,{X:B,Y:D,Z:V}=S;let z=n.ZERO,q=n.ZERO,G=n.ZERO;const Y=s.a,j=n.mul(s.b,Am);let X=n.mul(A,B),ne=n.mul(P,D),oe=n.mul(L,V),he=n.add(A,P),ce=n.add(B,D);he=n.mul(he,ce),ce=n.add(X,ne),he=n.sub(he,ce),ce=n.add(A,L);let fe=n.add(B,V);return ce=n.mul(ce,fe),fe=n.add(X,oe),ce=n.sub(ce,fe),fe=n.add(P,L),z=n.add(D,V),fe=n.mul(fe,z),z=n.add(ne,oe),fe=n.sub(fe,z),G=n.mul(Y,ce),z=n.mul(j,oe),G=n.add(z,G),z=n.sub(ne,G),G=n.add(ne,G),q=n.mul(z,G),ne=n.add(X,X),ne=n.add(ne,X),oe=n.mul(Y,oe),ce=n.mul(j,ce),ne=n.add(ne,oe),oe=n.sub(X,oe),oe=n.mul(Y,oe),ce=n.add(ce,oe),X=n.mul(ne,ce),q=n.add(q,X),X=n.mul(fe,ce),z=n.mul(he,z),z=n.sub(z,X),X=n.mul(he,ne),G=n.mul(fe,G),G=n.add(G,X),new $(z,q,G)}subtract(S){return this.add(S.negate())}is0(){return this.equals($.ZERO)}multiply(S){const{endo:A}=e;if(!i.isValidNot0(S))throw new Error("invalid scalar: out of range");let P,L;const B=D=>F.cached(this,D,V=>Dd($,V));if(A){const{k1neg:D,k1:V,k2neg:z,k2:q}=M(S),{p:G,f:Y}=B(V),{p:j,f:X}=B(q);L=Y.add(X),P=I(A.beta,G,j,D,z)}else{const{p:D,f:V}=B(S);P=D,L=V}return Dd($,[P,L])[0]}multiplyUnsafe(S){const{endo:A}=e,P=this;if(!i.isValid(S))throw new Error("invalid scalar: out of range");if(S===oo||P.is0())return $.ZERO;if(S===Jl)return P;if(F.hasCache(this))return this.multiply(S);if(A){const{k1neg:L,k1:B,k2neg:D,k2:V}=M(S),{p1:z,p2:q}=M7($,P,B,V);return I(A.beta,z,q,L,D)}else return F.unsafe(P,S)}toAffine(S){return E(this,S)}isTorsionFree(){const{isTorsionFree:S}=e;return o===Jl?!0:S?S($,this):F.unsafe(this,a).is0()}clearCofactor(){const{clearCofactor:S}=e;return o===Jl?this:S?S($,this):this.multiplyUnsafe(o)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}toBytes(S=!0){return Nc(S,"isCompressed"),this.assertValidity(),m($,this,S)}toHex(S=!0){return cp(this.toBytes(S))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}};f($,"BASE",new $(s.Gx,s.Gy,n.ONE)),f($,"ZERO",new $(n.ZERO,n.ONE,n.ZERO)),f($,"Fp",n),f($,"Fn",i);let x=$;const T=i.BITS,F=new gN(x,e.endo?Math.ceil(T/2):T);return x.BASE.precompute(8),x}function CN(r){return Uint8Array.of(r?2:3)}function IN(r,e){return{secretKey:e.BYTES,publicKey:1+r.BYTES,publicKeyUncompressed:1+2*r.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}function Oq(r,e={}){const{Fn:t}=r,n=e.randomBytes||lp,i=Object.assign(IN(r.Fp,t),{seed:fN(t.ORDER)});function s(m){try{const p=t.fromBytes(m);return t.isValidNot0(p)}catch{return!1}}function o(m,p){const{publicKey:b,publicKeyUncompressed:g}=i;try{const y=m.length;return p===!0&&y!==b||p===!1&&y!==g?!1:!!r.fromBytes(m)}catch{return!1}}function a(m=n(i.seed)){return E7(lt(m,i.seed,"seed"),t.ORDER)}function c(m,p=!0){return r.BASE.multiply(t.fromBytes(m)).toBytes(p)}function l(m){const{secretKey:p,publicKey:b,publicKeyUncompressed:g}=i;if(!R0(m)||"_lengths"in t&&t._lengths||p===b)return;const y=lt(m,void 0,"key").length;return y===b||y===g}function u(m,p,b=!0){if(l(m)===!0)throw new Error("first arg must be private key");if(l(p)===!1)throw new Error("second arg must be public key");const g=t.fromBytes(m);return r.fromBytes(p).multiply(g).toBytes(b)}const h={isValidSecretKey:s,isValidPublicKey:o,randomSecretKey:a},d=v1(a,c);return Object.freeze({getPublicKey:c,getSharedSecret:u,keygen:d,Point:r,utils:h,lengths:i})}function Uq(r,e,t={}){D0(e),bh(t,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"}),t=Object.assign({},t);const n=t.randomBytes||lp,i=t.hmac||((S,A)=>U0(e,S,A)),{Fp:s,Fn:o}=r,{ORDER:a,BITS:c}=o,{keygen:l,getPublicKey:u,getSharedSecret:h,utils:d,lengths:m}=Oq(r,t),p={prehash:!0,lowS:typeof t.lowS=="boolean"?t.lowS:!0,format:"compact",extraEntropy:!1},b=a*TN<s.ORDER;function g(S){const A=a>>Jl;return S>A}function y(S,A){if(!o.isValidNot0(A))throw new Error(`invalid signature ${S}: out of range 1..Point.Fn.ORDER`);return A}function v(){if(b)throw new Error('"recovered" sig type is not supported for cofactor >2 curves')}function w(S,A){nS(A);const P=m.signature,L=A==="compact"?P:A==="recovered"?P+1:void 0;return lt(S,L)}class _{constructor(A,P,L){f(this,"r");f(this,"s");f(this,"recovery");if(this.r=y("r",A),this.s=y("s",P),L!=null){if(v(),![0,1,2,3].includes(L))throw new Error("invalid recovery id");this.recovery=L}Object.freeze(this)}static fromBytes(A,P=p.format){w(A,P);let L;if(P==="der"){const{r:z,s:q}=ra.toSig(lt(A));return new _(z,q)}P==="recovered"&&(L=A[0],P="compact",A=A.subarray(1));const B=m.signature/2,D=A.subarray(0,B),V=A.subarray(B,B*2);return new _(o.fromBytes(D),o.fromBytes(V),L)}static fromHex(A,P){return this.fromBytes(uf(A),P)}assertRecovery(){const{recovery:A}=this;if(A==null)throw new Error("invalid recovery id: must be present");return A}addRecoveryBit(A){return new _(this.r,this.s,A)}recoverPublicKey(A){const{r:P,s:L}=this,B=this.assertRecovery(),D=B===2||B===3?P+a:P;if(!s.isValid(D))throw new Error("invalid recovery id: sig.r+curve.n != R.x");const V=s.toBytes(D),z=r.fromBytes(_s(CN((B&1)===0),V)),q=o.inv(D),G=E(lt(A,void 0,"msgHash")),Y=o.create(-G*q),j=o.create(L*q),X=r.BASE.multiplyUnsafe(Y).add(z.multiplyUnsafe(j));if(X.is0())throw new Error("invalid recovery: point at infinify");return X.assertValidity(),X}hasHighS(){return g(this.s)}toBytes(A=p.format){if(nS(A),A==="der")return uf(ra.hexFromSig(this));const{r:P,s:L}=this,B=o.toBytes(P),D=o.toBytes(L);return A==="recovered"?(v(),_s(Uint8Array.of(this.assertRecovery()),B,D)):_s(B,D)}toHex(A){return cp(this.toBytes(A))}}const M=t.bits2int||function(A){if(A.length>8192)throw new Error("input is too large");const P=L0(A),L=A.length*8-c;return L>0?P>>BigInt(L):P},E=t.bits2int_modN||function(A){return o.create(M(A))},C=b1(c);function I(S){return df("num < 2^"+c,S,oo,C),o.toBytes(S)}function x(S,A){return lt(S,void 0,"message"),A?lt(e(S),void 0,"prehashed message"):S}function T(S,A,P){const{lowS:L,prehash:B,extraEntropy:D}=aw(P,p);S=x(S,B);const V=E(S),z=o.fromBytes(A);if(!o.isValidNot0(z))throw new Error("invalid private key");const q=[I(z),I(V)];if(D!=null&&D!==!1){const X=D===!0?n(m.secretKey):D;q.push(lt(X,void 0,"extraEntropy"))}const G=_s(...q),Y=V;function j(X){const ne=M(X);if(!o.isValidNot0(ne))return;const oe=o.inv(ne),he=r.BASE.multiply(ne).toAffine(),ce=o.create(he.x);if(ce===oo)return;const fe=o.create(oe*o.create(Y+ce*z));if(fe===oo)return;let W=(he.x===ce?0:2)|Number(he.y&Jl),ue=fe;return L&&g(fe)&&(ue=o.neg(fe),W^=1),new _(ce,ue,b?void 0:W)}return{seed:G,k2sig:j}}function F(S,A,P={}){const{seed:L,k2sig:B}=T(S,A,P);return d7(e.outputLen,o.BYTES,i)(L,B).toBytes(P.format)}function $(S,A,P,L={}){const{lowS:B,prehash:D,format:V}=aw(L,p);if(P=lt(P,void 0,"publicKey"),A=x(A,D),!R0(S)){const z=S instanceof _?", use sig.toBytes()":"";throw new Error("verify expects Uint8Array signature"+z)}w(S,V);try{const z=_.fromBytes(S,V),q=r.fromBytes(P);if(B&&z.hasHighS())return!1;const{r:G,s:Y}=z,j=E(A),X=o.inv(Y),ne=o.create(j*X),oe=o.create(G*X),he=r.BASE.multiplyUnsafe(ne).add(q.multiplyUnsafe(oe));return he.is0()?!1:o.create(he.x)===G}catch{return!1}}function H(S,A,P={}){const{prehash:L}=aw(P,p);return A=x(A,L),_.fromBytes(S,"recovered").recoverPublicKey(A).toBytes()}return Object.freeze({keygen:l,getPublicKey:u,getSharedSecret:h,utils:d,lengths:m,Point:r,sign:F,verify:$,recoverPublicKey:H,Signature:_,hash:e})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const L1={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},kq={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},y2=BigInt(2);function Bq(r){const e=L1.p,t=BigInt(3),n=BigInt(6),i=BigInt(11),s=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),l=r*r*r%e,u=l*l*r%e,h=Kt(u,t,e)*u%e,d=Kt(h,t,e)*u%e,m=Kt(d,y2,e)*l%e,p=Kt(m,i,e)*m%e,b=Kt(p,s,e)*p%e,g=Kt(b,a,e)*b%e,y=Kt(g,c,e)*g%e,v=Kt(y,a,e)*b%e,w=Kt(v,t,e)*u%e,_=Kt(w,o,e)*p%e,M=Kt(_,n,e)*l%e,E=Kt(M,y2,e);if(!rS.eql(rS.sqr(E),r))throw new Error("Cannot find square root");return E}const rS=N0(L1.p,{sqrt:Bq}),Fq=Nq(L1,{Fp:rS,endo:kq}),jg=Uq(Fq,Rd),$q=33;function zq(r,e,t,n){var s;const i=Ns.digest(t instanceof Uint8Array?t:t.subarray());if(S1(i))return i.then(({digest:o})=>{var a;return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),jg.verify(e,o,r,{prehash:!1,format:"der"})}).catch(o=>{throw o.name==="AbortError"?o:new d2(String(o))});try{return(s=n==null?void 0:n.signal)==null||s.throwIfAborted(),jg.verify(e,i.digest,r,{prehash:!1,format:"der"})}catch(o){throw new d2(String(o))}}let Vq=class{constructor(e){f(this,"type","secp256k1");f(this,"raw");f(this,"_key");this._key=Gq(e),this.raw=Hq(this._key)}toMultihash(){return dn.digest(Ms(this))}toCID(){return Ze.createV1(114,this.toMultihash())}toString(){return gt.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:We(this.raw,e.raw)}verify(e,t,n){return zq(this._key,t,e,n)}};function N1(r){return new Vq(r)}function Hq(r){return jg.Point.fromBytes(r).toBytes()}function Gq(r){try{return jg.Point.fromBytes(r),r}catch(e){throw new k3(String(e))}}async function Wq(r,e){return Z7()}function Io(r,e){const{Type:t,Data:n}=Hu.decode(r),i=n??new Uint8Array;switch(t){case Un.RSA:return Cq(i,e);case Un.Ed25519:return E1(i);case Un.secp256k1:return N1(i);case Un.ECDSA:return Y3(i);default:throw new B3}}function qq(r){var n,i;if(r.byteLength===_1)return E1(r);if(r.byteLength===$q)return N1(r);const e=op(r),t=(n=e[1])==null?void 0:n[0];if(t===DW||t===LW||t===NW)return Z3(e);if(((i=e[0])==null?void 0:i[0])===Iq)return MN(e,r);throw new yh("Could not extract public key from raw bytes")}function No(r){const{Type:e,Data:t}=Hu.decode(r.digest),n=t??new Uint8Array;switch(e){case Un.Ed25519:return E1(n);case Un.secp256k1:return N1(n);case Un.ECDSA:return Y3(n);default:throw new B3}}function Ms(r){return Hu.encode({Type:Un[r.type],Data:r.raw})}const Kq=Symbol.for("@libp2p/connection"),b2=Symbol.for("@libp2p/content-routing");var bv;let Xq=(bv=class extends Error{constructor(e="The operation was aborted"){super(e),this.name="AbortError"}},f(bv,"name","AbortError"),bv);var wv;let ai=(wv=class extends Error{constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}},f(wv,"name","InvalidParametersError"),wv);class Qg extends Error{constructor(e="The connection is closed"){super(e),this.name="ConnectionClosedError"}}f(Qg,"name","ConnectionClosedError");var vv;let Yq=(vv=class extends Error{constructor(e="Not found"){super(e),this.name="NotFoundError"}},f(vv,"name","NotFoundError"),vv);class O1 extends Error{constructor(e="Invalid PeerID"){super(e),this.name="InvalidPeerIdError"}}f(O1,"name","InvalidPeerIdError");var _v;let U1=(_v=class extends Error{constructor(e="Invalid multiaddr"){super(e),this.name="InvalidMultiaddrError"}},f(_v,"name","InvalidMultiaddrError"),_v);var xv;let Zq=(xv=class extends Error{constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}},f(xv,"name","InvalidCIDError"),xv);var Sv;let Jq=(Sv=class extends Error{constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}},f(Sv,"name","InvalidMultihashError"),Sv);var Ev;let jq=(Ev=class extends Error{constructor(e="Timed out"){super(e),this.name="TimeoutError"}},f(Ev,"name","TimeoutError"),Ev);var Mv;let ey=(Mv=class extends Error{constructor(e="Not started"){super(e),this.name="NotStartedError"}},f(Mv,"name","NotStartedError"),Mv);var Av;let cw=(Av=class extends Error{constructor(e="Dial error"){super(e),this.name="DialError"}},f(Av,"name","DialError"),Av);class iS extends Error{constructor(e="Limited connection"){super(e),this.name="LimitedConnectionError"}}f(iS,"name","LimitedConnectionError");class PN extends Error{constructor(e="Too many inbound protocol streams"){super(e),this.name="TooManyInboundProtocolStreamsError"}}f(PN,"name","TooManyInboundProtocolStreamsError");var Tv;let Qq=(Tv=class extends Error{constructor(e="Too many outbound protocol streams"){super(e),this.name="TooManyOutboundProtocolStreamsError"}},f(Tv,"name","TooManyOutboundProtocolStreamsError"),Tv);var Cv;let eK=(Cv=class extends Error{constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}},f(Cv,"name","UnsupportedKeyTypeError"),Cv),tK=class extends Event{constructor(t,n,i){super("close",i);f(this,"error");f(this,"local");this.error=n,this.local=t}};const w2=Symbol.for("@libp2p/peer-discovery"),k1=Symbol.for("@libp2p/peer-id");function nK(r){return!!(r!=null&&r[k1])}const v2=Symbol.for("@libp2p/peer-routing"),RN="keep-alive";function B1(r){return r!=null&&typeof r.start=="function"&&typeof r.stop=="function"}async function rK(...r){const e=[];for(const t of r)B1(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStart!=null&&await t.beforeStart()})),await Promise.all(e.map(async t=>{await t.start()})),await Promise.all(e.map(async t=>{t.afterStart!=null&&await t.afterStart()}))}async function iK(...r){const e=[];for(const t of r)B1(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStop!=null&&await t.beforeStop()})),await Promise.all(e.map(async t=>{await t.stop()})),await Promise.all(e.map(async t=>{t.afterStop!=null&&await t.afterStop()}))}var ty;(function(r){r[r.FATAL_ALL=0]="FATAL_ALL",r[r.NO_FATAL=1]="NO_FATAL"})(ty||(ty={}));const sS=Symbol.for("@libp2p/service-capabilities"),_2=Symbol.for("@libp2p/service-dependencies"),DN=Symbol.for("nodejs.util.inspect.custom"),sK=114;var HP;let F1=class{constructor(e){f(this,"type");f(this,"multihash");f(this,"publicKey");f(this,"string");f(this,HP,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=gt.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return Ze.createV1(sK,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return We(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return We(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(HP=k1,DN)](){return`PeerId(${this.toString()})`}},LN=class extends F1{constructor(t){super({...t,type:"RSA"});f(this,"type","RSA");f(this,"publicKey");this.publicKey=t.publicKey}},NN=class extends F1{constructor(t){super({...t,type:"Ed25519"});f(this,"type","Ed25519");f(this,"publicKey");this.publicKey=t.publicKey}},ON=class extends F1{constructor(t){super({...t,type:"secp256k1"});f(this,"type","secp256k1");f(this,"publicKey");this.publicKey=t.publicKey}};const oK=2336;var GP,WP;let UN=class{constructor(e){f(this,"type","url");f(this,"multihash");f(this,"publicKey");f(this,"url");f(this,GP,!0);this.url=e.toString(),this.multihash=dn.digest(Se(this.url))}[(WP=DN,GP=k1,WP)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return Ze.createV1(oK,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=ae(e)),e.toString()===this.toString())}};const aK=114,x2=2336;function Gu(r,e){let t;if(r.charAt(0)==="1"||r.charAt(0)==="Q")t=Lo(gt.decode(`z${r}`));else{if(r.startsWith("k51qzi5uqu5")||r.startsWith("kzwfwjn5ji4")||r.startsWith("k2k4r8")||r.startsWith("bafz"))return uK(Ze.parse(r));throw new ai('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return kN(t)}function cK(r){if(r.type==="Ed25519")return new NN({multihash:r.toCID().multihash,publicKey:r});if(r.type==="secp256k1")return new ON({multihash:r.toCID().multihash,publicKey:r});if(r.type==="RSA")return new LN({multihash:r.toCID().multihash,publicKey:r});throw new eK}function lK(r){return cK(r.publicKey)}function kN(r){if(dK(r))return new LN({multihash:r});if(hK(r))try{const e=No(r);if(e.type==="Ed25519")return new NN({multihash:r,publicKey:e});if(e.type==="secp256k1")return new ON({multihash:r,publicKey:e})}catch{const t=ae(r.digest);return new UN(new URL(t))}throw new Jq("Supplied PeerID Multihash is invalid")}function uK(r){if((r==null?void 0:r.multihash)==null||r.version==null||r.version===1&&r.code!==aK&&r.code!==x2)throw new Zq("Supplied PeerID CID is invalid");if(r.code===x2){const e=ae(r.multihash.digest);return new UN(new URL(e))}return kN(r.multihash)}function hK(r){return r.code===dn.code}function dK(r){return r.code===Ns.code}async function fK(r){var e,t;if(r.connectionProtector===null&&((t=(e=globalThis.process)==null?void 0:e.env)==null?void 0:t.LIBP2P_FORCE_PNET)!=null)throw new ai("Private network is enforced, but no protector was provided");return r}const Wu=1e3,qu=Wu*60,Ku=qu*60,kc=Ku*24,ff=kc*7,Xu=kc*365.25,pf=Xu/12;function pK(r,e){if(typeof r=="string")return mK(r);if(typeof r=="number")return bK(r,e);throw Error(`Value provided to ms() must be a string or number. value=${JSON.stringify(r)}`)}var BN=pK;function mK(r){if(typeof r!="string"||r.length===0||r.length>100)throw Error(`Value provided to ms.parse() must be a string with length between 1 and 99. value=${JSON.stringify(r)}`);let e=/^(?<value>-?\d*\.?\d+) *(?<unit>milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|months?|mo|years?|yrs?|y)?$/i.exec(r);if(!(e!=null&&e.groups))return NaN;let{value:t,unit:n="ms"}=e.groups,i=parseFloat(t),s=n.toLowerCase();switch(s){case"years":case"year":case"yrs":case"yr":case"y":return i*Xu;case"months":case"month":case"mo":return i*pf;case"weeks":case"week":case"w":return i*ff;case"days":case"day":case"d":return i*kc;case"hours":case"hour":case"hrs":case"hr":case"h":return i*Ku;case"minutes":case"minute":case"mins":case"min":case"m":return i*qu;case"seconds":case"second":case"secs":case"sec":case"s":return i*Wu;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return i;default:throw Error(`Unknown unit "${s}" provided to ms.parse(). value=${JSON.stringify(r)}`)}}function gK(r){let e=Math.abs(r);return e>=Xu?`${Math.round(r/Xu)}y`:e>=pf?`${Math.round(r/pf)}mo`:e>=ff?`${Math.round(r/ff)}w`:e>=kc?`${Math.round(r/kc)}d`:e>=Ku?`${Math.round(r/Ku)}h`:e>=qu?`${Math.round(r/qu)}m`:e>=Wu?`${Math.round(r/Wu)}s`:`${r}ms`}function yK(r){let e=Math.abs(r);return e>=Xu?Ka(r,e,Xu,"year"):e>=pf?Ka(r,e,pf,"month"):e>=ff?Ka(r,e,ff,"week"):e>=kc?Ka(r,e,kc,"day"):e>=Ku?Ka(r,e,Ku,"hour"):e>=qu?Ka(r,e,qu,"minute"):e>=Wu?Ka(r,e,Wu,"second"):`${r} ms`}function bK(r,e){if(typeof r!="number"||!Number.isFinite(r))throw Error("Value provided to ms.format() must be of type number.");return e!=null&&e.long?yK(r):gK(r)}function Ka(r,e,t,n){let i=e>=t*1.5;return`${Math.round(r/t)} ${n}${i?"s":""}`}function wK(r){t.debug=t,t.default=t,t.coerce=c,t.disable=s,t.enable=i,t.enabled=o,t.humanize=BN,t.destroy=l,Object.keys(r).forEach(u=>{t[u]=r[u]}),t.names=[],t.skips=[],t.formatters={};function e(u){let h=0;for(let d=0;d<u.length;d++)h=(h<<5)-h+u.charCodeAt(d),h|=0;return t.colors[Math.abs(h)%t.colors.length]}t.selectColor=e;function t(u,h){let d,m=null,p,b;function g(...y){if(!g.enabled)return;const v=g,w=Number(new Date),_=w-(d||w);v.diff=_,v.prev=d,v.curr=w,d=w,y[0]=t.coerce(y[0]),typeof y[0]!="string"&&y.unshift("%O");let M=0;y[0]=y[0].replace(/%([a-zA-Z%])/g,(C,I)=>{if(C==="%%")return"%";M++;const x=t.formatters[I];if(typeof x=="function"){const T=y[M];C=x.call(v,T),y.splice(M,1),M--}return C}),t.formatArgs.call(v,y),(h==null?void 0:h.onLog)!=null&&h.onLog(...y),(v.log||t.log).apply(v,y)}return g.namespace=u,g.useColors=t.useColors(),g.color=t.selectColor(u),g.extend=n,g.destroy=t.destroy,Object.defineProperty(g,"enabled",{enumerable:!0,configurable:!1,get:()=>m!==null?m:(p!==t.namespaces&&(p=t.namespaces,b=t.enabled(u)),b),set:y=>{m=y}}),typeof t.init=="function"&&t.init(g),g}function n(u,h){const d=t(this.namespace+(typeof h>"u"?":":h)+u);return d.log=this.log,d}function i(u){t.save(u),t.namespaces=u,t.names=[],t.skips=[];let h;const d=(typeof u=="string"?u:"").split(/[\s,]+/),m=d.length;for(h=0;h<m;h++)d[h]&&(u=d[h].replace(/\*/g,".*?"),u[0]==="-"?t.skips.push(new RegExp("^"+u.substr(1)+"$")):t.names.push(new RegExp("^"+u+"$")))}function s(){const u=[...t.names.map(a),...t.skips.map(a).map(h=>"-"+h)].join(",");return t.enable(""),u}function o(u){if(u[u.length-1]==="*")return!0;let h,d;for(h=0,d=t.skips.length;h<d;h++)if(t.skips[h].test(u))return!1;for(h=0,d=t.names.length;h<d;h++)if(t.names[h].test(u))return!0;return!1}function a(u){return u.toString().substring(2,u.toString().length-2).replace(/\.\*\?$/,"*")}function c(u){return u instanceof Error?u.stack??u.message:u}function l(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return t.setupFormatters(t.formatters),t.enable(t.load()),t}var vK={};const ws=TK(),_K=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function xK(){var r,e,t,n,i;return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&((r=navigator.userAgent)==null?void 0:r.toLowerCase().match(/(edge|trident)\/(\d+)/))!=null?!1:typeof document<"u"&&((t=(e=document.documentElement)==null?void 0:e.style)==null?void 0:t.WebkitAppearance)||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&((n=navigator.userAgent)==null?void 0:n.toLowerCase().match(/firefox\/(\d+)/))!=null&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&((i=navigator.userAgent)==null?void 0:i.toLowerCase().match(/applewebkit\/(\d+)/))}function SK(r){if(r[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+r[0]+(this.useColors?"%c ":" ")+"+"+BN(this.diff),!this.useColors)return;const e="color: "+this.color;r.splice(1,0,e,"color: inherit");let t=0,n=0;r[0].replace(/%[a-zA-Z%]/g,i=>{i!=="%%"&&(t++,i==="%c"&&(n=t))}),r.splice(n,0,e)}const EK=console.debug??console.log??(()=>{});function MK(r){try{r?ws==null||ws.setItem("debug",r):ws==null||ws.removeItem("debug")}catch{}}function AK(){let r;try{r=ws==null?void 0:ws.getItem("debug")}catch{}return!r&&typeof globalThis.process<"u"&&"env"in globalThis.process&&(r=vK.DEBUG),r}function TK(){try{return localStorage}catch{}}function CK(r){r.j=function(e){try{return JSON.stringify(e)}catch(t){return"[UnexpectedJSONParseError]: "+t.message}}}const ni=wK({formatArgs:SK,save:MK,load:AK,useColors:xK,setupFormatters:CK,colors:_K,storage:ws,log:EK});ni.formatters.b=r=>r==null?"undefined":gt.baseEncode(r);ni.formatters.t=r=>r==null?"undefined":Rn.baseEncode(r);ni.formatters.m=r=>r==null?"undefined":W3.baseEncode(r);ni.formatters.p=r=>r==null?"undefined":r.toString();ni.formatters.c=r=>r==null?"undefined":r.toString();ni.formatters.k=r=>r==null?"undefined":r.toString();ni.formatters.a=r=>r==null?"undefined":r.toString();function S2(r,e=""){const t=E2(r.message),n=E2(r.stack);return t!=null&&n!=null?n.includes(t)?`${n.split(`
`).join(`
${e}`)}`:`${t}
${e}${n.split(`
`).join(`
${e}`)}`:n!=null?`${n.split(`
`).join(`
${e}`)}`:t!=null?`${t}`:`${r.toString()}`}function IK(r){return r instanceof AggregateError||(r==null?void 0:r.name)==="AggregateError"&&Array.isArray(r.errors)}function FN(r,e=""){if(IK(r)){let t=S2(r,e);return r.errors.length>0?(e=`${e}    `,t+=`
${e}${r.errors.map(n=>`${FN(n,`${e}`)}`).join(`
${e}`)}`):t+=`
${e}[Error list was empty]`,t.trim()}return S2(r,e)}ni.formatters.e=r=>r==null?"undefined":FN(r);function PK(r){const e=()=>{};return e.enabled=!1,e.color="",e.diff=0,e.log=()=>{},e.namespace=r,e.destroy=()=>!0,e.extend=()=>e,e}function $N(r){return{forComponent(e){return zN(e,r)}}}function zN(r,e){let t=PK(`${r}:trace`);return ni.enabled(`${r}:trace`)&&ni.names.map(n=>n.toString()).find(n=>n.includes(":trace"))!=null&&(t=ni(`${r}:trace`,e)),Object.assign(ni(r,e),{error:ni(`${r}:error`,e),trace:t,newScope:n=>zN(`${r}:${n}`,e)})}function E2(r){if(r!=null&&(r=r.trim(),r.length!==0))return r}var Iv;let RK=(Iv=class extends Error{constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}},f(Iv,"name","InvalidMultihashError"),Iv);const VN=Symbol.for("@libp2p/peer-id"),HN=Symbol.for("nodejs.util.inspect.custom"),DK=114;var qP;let $1=class{constructor(e){f(this,"type");f(this,"multihash");f(this,"publicKey");f(this,"string");f(this,qP,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=gt.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return Ze.createV1(DK,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return We(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return We(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(qP=VN,HN)](){return`PeerId(${this.toString()})`}},LK=class extends $1{constructor(t){super({...t,type:"RSA"});f(this,"type","RSA");f(this,"publicKey");this.publicKey=t.publicKey}},NK=class extends $1{constructor(t){super({...t,type:"Ed25519"});f(this,"type","Ed25519");f(this,"publicKey");this.publicKey=t.publicKey}},OK=class extends $1{constructor(t){super({...t,type:"secp256k1"});f(this,"type","secp256k1");f(this,"publicKey");this.publicKey=t.publicKey}};const UK=2336;var KP,XP;let kK=class{constructor(e){f(this,"type","url");f(this,"multihash");f(this,"publicKey");f(this,"url");f(this,KP,!0);this.url=e.toString(),this.multihash=dn.digest(Se(this.url))}[(XP=HN,KP=VN,XP)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return Ze.createV1(UK,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=ae(e)),e.toString()===this.toString())}};function BK(r){if($K(r))return new LK({multihash:r});if(FK(r))try{const e=No(r);if(e.type==="Ed25519")return new NK({multihash:r,publicKey:e});if(e.type==="secp256k1")return new OK({multihash:r,publicKey:e})}catch{const t=ae(r.digest);return new kK(new URL(t))}throw new RK("Supplied PeerID Multihash is invalid")}function FK(r){return r.code===dn.code}function $K(r){return r.code===Ns.code}function Ld(r,e){const t={[Symbol.iterator]:()=>t,next:()=>{const n=r.next(),i=n.value;return n.done===!0||i==null?{done:!0,value:void 0}:{done:!1,value:e(i)}}};return t}function lw(r){const e=Lo(gt.decode(`z${r}`));return BK(e)}let wh=class{constructor(e){f(this,"map");if(this.map=new Map,e!=null)for(const[t,n]of e.entries())this.map.set(t.toString(),{key:t,value:n})}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(e){return this.map.delete(e.toString())}entries(){return Ld(this.map.entries(),e=>[e[1].key,e[1].value])}forEach(e){this.map.forEach((t,n)=>{e(t.value,t.key,this)})}get(e){var t;return(t=this.map.get(e.toString()))==null?void 0:t.value}has(e){return this.map.has(e.toString())}set(e,t){this.map.set(e.toString(),{key:e,value:t})}keys(){return Ld(this.map.values(),e=>e.key)}values(){return Ld(this.map.values(),e=>e.value)}get size(){return this.map.size}},GN=class yg{constructor(e){f(this,"set");if(this.set=new Set,e!=null)for(const t of e)this.set.add(t.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(e){this.set.add(e.toString())}clear(){this.set.clear()}delete(e){this.set.delete(e.toString())}entries(){return Ld(this.set.entries(),e=>{const t=lw(e[0]);return[t,t]})}forEach(e){this.set.forEach(t=>{const n=lw(t);e(n,n,this)})}has(e){return this.set.has(e.toString())}values(){return Ld(this.set.values(),e=>lw(e))}intersection(e){const t=new yg;for(const n of e)this.has(n)&&t.add(n);return t}difference(e){const t=new yg;for(const n of this)e.has(n)||t.add(n);return t}union(e){const t=new yg;for(const n of e)t.add(n);for(const n of this)t.add(n);return t}};const z1={32:16777619n,64:1099511628211n,128:309485009821345068724781371n,256:374144419156711147060143317175368453031918731002211n,512:35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,1024:5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n},WN={32:2166136261n,64:14695981039346656037n,128:144066263297769815596495629667062367629n,256:100029257958052580907070968620625704837092796014241193945225284501741471925557n,512:9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,1024:14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n},qN=new globalThis.TextEncoder;function zK(r,e){const t=z1[e];let n=WN[e];for(let i=0;i<r.length;i++)n^=BigInt(r[i]),n=BigInt.asUintN(e,n*t);return n}function VK(r,e,t){if(t.length===0)throw new Error("The `utf8Buffer` option must have a length greater than zero");const n=z1[e];let i=WN[e],s=r;for(;s.length>0;){const o=qN.encodeInto(s,t);s=s.slice(o.read);for(let a=0;a<o.written;a++)i^=BigInt(t[a]),i=BigInt.asUintN(e,i*n)}return i}function HK(r,{size:e=32,utf8Buffer:t}={}){if(!z1[e])throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");if(typeof r=="string"){if(t)return VK(r,e,t);r=qN.encode(r)}return zK(r,e)}const V1={hash:r=>Number(HK(r,{size:32})),hashV:(r,e)=>GK(V1.hash(r,e))};function GK(r){let e=r.toString(16);return e.length%2===1&&(e=`0${e}`),Se(e,"base16")}const KN=64;class lc{constructor(e,t,n,i=2){f(this,"fp");f(this,"h");f(this,"seed");if(i>KN)throw new TypeError("Invalid Fingerprint Size");const s=t.hashV(e,n),o=xt(i);for(let a=0;a<o.length;a++)o[a]=s[a];o.length===0&&(o[0]=7),this.fp=o,this.h=t,this.seed=n}hash(){return this.h.hash(this.fp,this.seed)}equals(e){return(e==null?void 0:e.fp)instanceof Uint8Array?We(this.fp,e.fp):!1}}function ny(r,e){return Math.floor(Math.random()*(e-r))+r}class Tm{constructor(e){f(this,"contents");this.contents=new Array(e).fill(null)}has(e){if(!(e instanceof lc))throw new TypeError("Invalid Fingerprint");return this.contents.some(t=>e.equals(t))}add(e){if(!(e instanceof lc))throw new TypeError("Invalid Fingerprint");for(let t=0;t<this.contents.length;t++)if(this.contents[t]==null)return this.contents[t]=e,!0;return!0}swap(e){if(!(e instanceof lc))throw new TypeError("Invalid Fingerprint");const t=ny(0,this.contents.length-1),n=this.contents[t];return this.contents[t]=e,n}remove(e){if(!(e instanceof lc))throw new TypeError("Invalid Fingerprint");const t=this.contents.findIndex(n=>e.equals(n));return t>-1?(this.contents[t]=null,!0):!1}}const WK=500;class M2{constructor(e){f(this,"bucketSize");f(this,"filterSize");f(this,"fingerprintSize");f(this,"buckets");f(this,"count");f(this,"hash");f(this,"seed");this.filterSize=e.filterSize,this.bucketSize=e.bucketSize??4,this.fingerprintSize=e.fingerprintSize??2,this.count=0,this.buckets=[],this.hash=e.hash??V1,this.seed=e.seed??ny(0,Math.pow(2,10))}add(e){typeof e=="string"&&(e=Se(e));const t=new lc(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,i=(n^t.hash())%this.filterSize;if(this.buckets[n]==null&&(this.buckets[n]=new Tm(this.bucketSize)),this.buckets[i]==null&&(this.buckets[i]=new Tm(this.bucketSize)),this.buckets[n].add(t)||this.buckets[i].add(t))return this.count++,!0;const s=[n,i];let o=s[ny(0,s.length-1)];this.buckets[o]==null&&(this.buckets[o]=new Tm(this.bucketSize));for(let a=0;a<WK;a++){const c=this.buckets[o].swap(t);if(c!=null&&(o=(o^c.hash())%this.filterSize,this.buckets[o]==null&&(this.buckets[o]=new Tm(this.bucketSize)),this.buckets[o].add(c)))return this.count++,!0}return!1}has(e){var o,a;typeof e=="string"&&(e=Se(e));const t=new lc(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,i=((o=this.buckets[n])==null?void 0:o.has(t))??!1;if(i)return i;const s=(n^t.hash())%this.filterSize;return((a=this.buckets[s])==null?void 0:a.has(t))??!1}remove(e){var a,c;typeof e=="string"&&(e=Se(e));const t=new lc(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,i=((a=this.buckets[n])==null?void 0:a.remove(t))??!1;if(i)return this.count--,i;const s=(n^t.hash())%this.filterSize,o=((c=this.buckets[s])==null?void 0:c.remove(t))??!1;return o&&this.count--,o}get reliable(){return Math.floor(100*(this.count/this.filterSize))<=90}}const qK={1:.5,2:.84,4:.95,8:.98};function KK(r=.001){return r>.002?2:r>1e-5?4:8}function XK(r,e=.001){const t=KK(e),n=qK[t],i=Math.round(r/n),s=Math.min(Math.ceil(Math.log2(1/e)+Math.log2(2*t)),KN);return{filterSize:i,bucketSize:t,fingerprintSize:s}}class YK{constructor(e){f(this,"filterSize");f(this,"bucketSize");f(this,"fingerprintSize");f(this,"scale");f(this,"filterSeries");f(this,"hash");f(this,"seed");this.bucketSize=e.bucketSize??4,this.filterSize=e.filterSize??(1<<18)/this.bucketSize,this.fingerprintSize=e.fingerprintSize??2,this.scale=e.scale??2,this.hash=e.hash??V1,this.seed=e.seed??ny(0,Math.pow(2,10)),this.filterSeries=[new M2({filterSize:this.filterSize,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed})]}add(e){if(typeof e=="string"&&(e=Se(e)),this.has(e))return!0;let t=this.filterSeries.find(n=>n.reliable);if(t==null){const n=this.filterSize*Math.pow(this.scale,this.filterSeries.length);t=new M2({filterSize:n,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed}),this.filterSeries.push(t)}return t.add(e)}has(e){typeof e=="string"&&(e=Se(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].has(e))return!0;return!1}remove(e){typeof e=="string"&&(e=Se(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].remove(e))return!0;return!1}get count(){return this.filterSeries.reduce((e,t)=>e+t.count,0)}}function mf(r,e=.001,t){return new YK({...XK(r,e)})}var Pv;let ry=(Pv=class extends Error{constructor(e="The operation was aborted"){super(e),this.name="AbortError"}},f(Pv,"name","AbortError"),Pv);var Rv;let H1=(Rv=class extends Error{constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}},f(Rv,"name","InvalidParametersError"),Rv);var Dv;let ZK=(Dv=class extends Error{constructor(e="The muxer is closed"){super(e),this.name="MuxerClosedError"}},f(Dv,"name","MuxerClosedError"),Dv);var Lv;let JK=(Lv=class extends Error{constructor(e="The stream has been reset"){super(e),this.name="StreamResetError"}},f(Lv,"name","StreamResetError"),Lv);var Nv;let Zh=(Nv=class extends Error{constructor(e="The stream is in an invalid state"){super(e),this.name="StreamStateError"}},f(Nv,"name","StreamStateError"),Nv);class oS extends Error{constructor(e="The stream buffer was full"){super(e),this.name="StreamBufferError"}}f(oS,"name","StreamBufferError");class jK extends Event{constructor(t,n){super("message",n);f(this,"data");this.data=t}}class G1 extends Event{constructor(t,n,i){super("close",i);f(this,"error");f(this,"local");this.error=n,this.local=t}}class QK extends G1{constructor(e,t){super(!0,e,t)}}class eX extends G1{constructor(e,t){super(!1,e,t)}}function zt(r){var i,s,o,a,c,l;const e=r.getComponents(),t={};let n=0;if(((i=e[n])==null?void 0:i.name)==="ip6zone"&&(t.zone=`${e[n].value}`,n++),e[n].name==="ip4"||e[n].name==="ip6"||e[n].name==="dns"||e[n].name==="dns4"||e[n].name==="dns6"?(t.type=e[n].name,t.host=e[n].value,n++):e[n].name==="dnsaddr"&&(t.type=e[n].name,t.host=`_dnsaddr.${e[n].value}`,n++),(((s=e[n])==null?void 0:s.name)==="tcp"||((o=e[n])==null?void 0:o.name)==="udp")&&(t.protocol=e[n].name==="tcp"?"tcp":"udp",t.port=parseInt(`${e[n].value}`),n++),((a=e[n])==null?void 0:a.name)==="ipcidr"&&(t.type==="ip4"?t.cidr=parseInt(`${e[n].value}`):t.type==="ip6"&&(t.cidr=`${e[n].value}`),n++),t.type==null||t.host==null)throw new H1(`Multiaddr ${r} was not an IPv4, IPv6, DNS, DNS4, DNS6 or DNSADDR address`);return((c=e[n])==null?void 0:c.name)==="tls"&&((l=e[n+1])==null?void 0:l.name)==="sni"&&(t.sni=e[n+1].value,n+=2),t}class tX{constructor(){f(this,"index",0);f(this,"input","")}new(e){return this.index=0,this.input=e,this}readAtomically(e){const t=this.index,n=e();return n===void 0&&(this.index=t),n}parseWith(e){const t=e();if(this.index===this.input.length)return t}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(e){return this.readAtomically(()=>{const t=this.readChar();if(t===e)return t})}readSeparator(e,t,n){return this.readAtomically(()=>{if(!(t>0&&this.readGivenChar(e)===void 0))return n()})}readNumber(e,t,n,i){return this.readAtomically(()=>{let s=0,o=0;const a=this.peekChar();if(a===void 0)return;const c=a==="0",l=2**(8*i)-1;for(;;){const u=this.readAtomically(()=>{const h=this.readChar();if(h===void 0)return;const d=Number.parseInt(h,e);if(!Number.isNaN(d))return d});if(u===void 0)break;if(s*=e,s+=u,s>l||(o+=1,t!==void 0&&o>t))return}if(o!==0)return!n&&c&&o>1?void 0:s})}readIPv4Addr(){return this.readAtomically(()=>{const e=new Uint8Array(4);for(let t=0;t<e.length;t++){const n=this.readSeparator(".",t,()=>this.readNumber(10,3,!1,1));if(n===void 0)return;e[t]=n}return e})}readIPv6Addr(){const e=t=>{for(let n=0;n<t.length/2;n++){const i=n*2;if(n<t.length-3){const o=this.readSeparator(":",n,()=>this.readIPv4Addr());if(o!==void 0)return t[i]=o[0],t[i+1]=o[1],t[i+2]=o[2],t[i+3]=o[3],[i+4,!0]}const s=this.readSeparator(":",n,()=>this.readNumber(16,4,!0,2));if(s===void 0)return[i,!1];t[i]=s>>8,t[i+1]=s&255}return[t.length,!1]};return this.readAtomically(()=>{const t=new Uint8Array(16),[n,i]=e(t);if(n===16)return t;if(i||this.readGivenChar(":")===void 0||this.readGivenChar(":")===void 0)return;const s=new Uint8Array(14),o=16-(n+2),[a]=e(s.subarray(0,o));return t.set(s.subarray(0,a),16-a),t})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}}const XN=45,nX=15,Yu=new tX;function YN(r){if(!(r.length>nX))return Yu.new(r).parseWith(()=>Yu.readIPv4Addr())}function ZN(r){if(r.includes("%")&&(r=r.split("%")[0]),!(r.length>XN))return Yu.new(r).parseWith(()=>Yu.readIPv6Addr())}function aS(r,e=!1){if(r.includes("%")&&(r=r.split("%")[0]),r.length>XN)return;const t=Yu.new(r).parseWith(()=>Yu.readIPAddr());if(t)return e&&t.length===4?Uint8Array.from([0,0,0,0,0,0,0,0,0,0,255,255,t[0],t[1],t[2],t[3]]):t}function rX(r,e,t){let n=0;for(const i of r)if(!(n<e)){if(n>t)break;if(i!==255)return!1;n++}return!0}function iX(r,e,t,n){let i=0;for(const s of r)if(!(i<t)){if(i>n)break;if(s!==e[i])return!1;i++}return!0}function sX(r){switch(r.length){case gf:return r.join(".");case yf:{const e=[];for(let t=0;t<r.length;t++)t%2===0&&e.push(r[t].toString(16).padStart(2,"0")+r[t+1].toString(16).padStart(2,"0"));return e.join(":")}default:throw new Error("Invalid ip length")}}function oX(r){let e=0;for(let[t,n]of r.entries()){if(n===255){e+=8;continue}for(;(n&128)!=0;)e++,n=n<<1;if((n&128)!=0)return-1;for(let i=t+1;i<r.length;i++)if(r[i]!=0)return-1;break}return e}function aX(r){let e="0x";for(const t of r)e+=(t>>4).toString(16)+(t&15).toString(16);return e}const gf=4,yf=16,cX=new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]);function JN(r,e){e.length===yf&&r.length===gf&&rX(e,0,11)&&(e=e.slice(12)),e.length===gf&&r.length===yf&&iX(r,cX,0,11)&&(r=r.slice(12));const t=r.length;if(t!=e.length)throw new Error("Failed to mask ip");const n=new Uint8Array(t);for(let i=0;i<t;i++)n[i]=r[i]&e[i];return n}function lX(r,e){if(typeof e=="string"&&(e=aS(e)),e==null)throw new Error("Invalid ip");if(e.length!==r.network.length)return!1;for(let t=0;t<e.length;t++)if((r.network[t]&r.mask[t])!==(e[t]&r.mask[t]))return!1;return!0}function uX(r){const[e,t]=r.split("/");if(!e||!t)throw new Error("Failed to parse given CIDR: "+r);let n=gf,i=YN(e);if(i==null&&(n=yf,i=ZN(e),i==null))throw new Error("Failed to parse given CIDR: "+r);const s=parseInt(t,10);if(Number.isNaN(s)||String(s).length!==t.length||s<0||s>n*8)throw new Error("Failed to parse given CIDR: "+r);const o=jN(s,8*n);return{network:JN(i,o),mask:o}}function jN(r,e){if(e!==8*gf&&e!==8*yf)throw new Error("Invalid CIDR mask");if(r<0||r>e)throw new Error("Invalid CIDR mask");const t=e/8,n=new Uint8Array(t);for(let i=0;i<t;i++){if(r>=8){n[i]=255,r-=8;continue}n[i]=255-(255>>r),r=0}return n}class QN{constructor(e,t){if(t==null)({network:this.network,mask:this.mask}=uX(e));else{const n=aS(e);if(n==null)throw new Error("Failed to parse network");t=String(t);const i=parseInt(t,10);if(Number.isNaN(i)||String(i).length!==t.length||i<0||i>n.length*8){const s=aS(t);if(s==null)throw new Error("Failed to parse mask");this.mask=s}else this.mask=jN(i,8*n.length);this.network=JN(n,this.mask)}}contains(e){return lX({network:this.network,mask:this.mask},e)}toString(){const e=oX(this.mask),t=e!==-1?String(e):aX(this.mask);return sX(this.network)+"/"+t}}function hX(r,e){return new QN(r).contains(e)}function dX(r){try{const e=zt(r);switch(e.type){case"ip6":return hX("2000::/3",e.host);default:return!1}}catch{return!1}}function fX(r){try{const e=zt(r);switch(e.type){case"ip4":return e.host.startsWith("169.254.");case"ip6":return e.host.toLowerCase().startsWith("fe80");default:return!1}}catch{return!1}}function pX(r){return/^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(r)||/^::1$/.test(r)}function cS(r){try{const e=zt(r);switch(e.type){case"ip4":case"ip6":return pX(e.host);default:return!1}}catch{return!1}}function Zi(r){try{return zt(r),!0}catch{return!1}}function $t(r){return!!YN(r)}function Ai(r){return!!ZN(r)}function W1(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}var Tl={},A2;function mX(){return A2||(A2=1,(function(){var r,e,t,n,i,s,o,a;a=function(c){var l,u,h,d;return l=(c&255<<24)>>>24,u=(c&255<<16)>>>16,h=(c&65280)>>>8,d=c&255,[l,u,h,d].join(".")},o=function(c){var l,u,h,d,m,p;for(l=[],h=d=0;d<=3&&c.length!==0;h=++d){if(h>0){if(c[0]!==".")throw new Error("Invalid IP");c=c.substring(1)}p=e(c),m=p[0],u=p[1],c=c.substring(u),l.push(m)}if(c.length!==0)throw new Error("Invalid IP");switch(l.length){case 1:if(l[0]>4294967295)throw new Error("Invalid IP");return l[0]>>>0;case 2:if(l[0]>255||l[1]>16777215)throw new Error("Invalid IP");return(l[0]<<24|l[1])>>>0;case 3:if(l[0]>255||l[1]>255||l[2]>65535)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2])>>>0;case 4:if(l[0]>255||l[1]>255||l[2]>255||l[3]>255)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2]<<8|l[3])>>>0;default:throw new Error("Invalid IP")}},t=function(c){return c.charCodeAt(0)},n=t("0"),s=t("a"),i=t("A"),e=function(c){var l,u,h,d,m;for(d=0,l=10,u="9",h=0,c.length>1&&c[h]==="0"&&(c[h+1]==="x"||c[h+1]==="X"?(h+=2,l=16):"0"<=c[h+1]&&c[h+1]<="9"&&(h++,l=8,u="7")),m=h;h<c.length;){if("0"<=c[h]&&c[h]<=u)d=d*l+(t(c[h])-n)>>>0;else if(l===16)if("a"<=c[h]&&c[h]<="f")d=d*l+(10+t(c[h])-s)>>>0;else if("A"<=c[h]&&c[h]<="F")d=d*l+(10+t(c[h])-i)>>>0;else break;else break;if(d>4294967295)throw new Error("too large");h++}if(h===m)throw new Error("empty octet");return[d,h]},r=(function(){function c(l,u){var h,d,m;if(typeof l!="string")throw new Error("Missing `net' parameter");if(u||(m=l.split("/",2),l=m[0],u=m[1]),u||(u=32),typeof u=="string"&&u.indexOf(".")>-1){try{this.maskLong=o(u)}catch{throw new Error("Invalid mask: "+u)}for(h=d=32;d>=0;h=--d)if(this.maskLong===4294967295<<32-h>>>0){this.bitmask=h;break}}else if(u||u===0)this.bitmask=parseInt(u,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0);else throw new Error("Invalid mask: empty");try{this.netLong=(o(l)&this.maskLong)>>>0}catch{throw new Error("Invalid net address: "+l)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+u);this.size=Math.pow(2,32-this.bitmask),this.base=a(this.netLong),this.mask=a(this.maskLong),this.hostmask=a(~this.maskLong),this.first=this.bitmask<=30?a(this.netLong+1):this.base,this.last=this.bitmask<=30?a(this.netLong+this.size-2):a(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?a(this.netLong+this.size-1):void 0}return c.prototype.contains=function(l){return typeof l=="string"&&(l.indexOf("/")>0||l.split(".").length!==4)&&(l=new c(l)),l instanceof c?this.contains(l.base)&&this.contains(l.broadcast||l.last):(o(l)&this.maskLong)>>>0===(this.netLong&this.maskLong)>>>0},c.prototype.next=function(l){return l==null&&(l=1),new c(a(this.netLong+this.size*l),this.mask)},c.prototype.forEach=function(l){var u,h,d;for(d=o(this.first),h=o(this.last),u=0;d<=h;)l(a(d),d,u),u++,d++},c.prototype.toString=function(){return this.base+"/"+this.bitmask},c})(),Tl.ip2long=o,Tl.long2ip=a,Tl.Netmask=r}).call(Tl)),Tl}var gX=mX();const yX=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"],bX=yX.map(r=>new gX.Netmask(r));function q1(r){for(const e of bX)if(e.contains(r))return!0;return!1}function wX(r){return/^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(r)}function vX(r){const e=r.split(":");if(e.length<2)return!1;const t=e[e.length-1].padStart(4,"0"),n=e[e.length-2].padStart(4,"0"),i=`${parseInt(n.substring(0,2),16)}.${parseInt(n.substring(2),16)}.${parseInt(t.substring(0,2),16)}.${parseInt(t.substring(2),16)}`;return q1(i)}function _X(r){return/^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)}function xX(r){const e=r.split(":"),t=e[e.length-1];return q1(t)}function SX(r){return/^::$/.test(r)||/^::1$/.test(r)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(r)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(r)||/^ff([0-9a-fA-F]{2,2}):/i.test(r)}function K1(r){if($t(r))return q1(r);if(wX(r))return vX(r);if(_X(r))return xX(r);if(Ai(r))return SX(r)}function Zu(r){try{const e=zt(r);switch(e.type){case"ip4":case"ip6":return K1(e.host)??!1;default:return e.host==="localhost"}}catch{return!1}}function mi(){const r={};return r.promise=new Promise((e,t)=>{r.resolve=e,r.reject=t}),r}class T2{constructor(e){f(this,"buffer");f(this,"mask");f(this,"top");f(this,"btm");f(this,"next");if(!(e>0)||(e-1&e)!==0)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){const e=this.buffer[this.btm];if(e!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return this.buffer[this.btm]===void 0}}class uw{constructor(e={}){f(this,"size");f(this,"hwm");f(this,"head");f(this,"tail");this.hwm=e.splitLimit??16,this.head=new T2(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return(e==null?void 0:e.byteLength)!=null?e.byteLength:1}push(e){if((e==null?void 0:e.value)!=null&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){const t=this.head;this.head=t.next=new T2(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(e===void 0&&this.tail.next!=null){const t=this.tail.next;this.tail.next=null,this.tail=t,e=this.tail.shift()}return(e==null?void 0:e.value)!=null&&(this.size-=this.calculateSize(e.value)),e}isEmpty(){return this.head.isEmpty()}}let EX=class extends Error{constructor(t,n){super(t??"The operation was aborted");f(this,"type");f(this,"code");this.type="aborted",this.code=n??"ABORT_ERR"}};function k0(r={}){return MX(t=>{const n=t.shift();if(n==null)return{done:!0};if(n.error!=null)throw n.error;return{done:n.done===!0,value:n.value}},r)}function MX(r,e){e=e??{};let t=e.onEnd,n=new uw,i,s,o,a=mi();const c=async()=>{try{return n.isEmpty()?o?{done:!0}:await new Promise((g,y)=>{s=v=>{s=null,n.push(v);try{g(r(n))}catch(w){y(w)}return i}}):r(n)}finally{n.isEmpty()&&queueMicrotask(()=>{a.resolve(),a=mi()})}},l=g=>s!=null?s(g):(n.push(g),i),u=g=>(n=new uw,s!=null?s({error:g}):(n.push({error:g}),i)),h=g=>{if(o)return i;if((e==null?void 0:e.objectMode)!==!0&&(g==null?void 0:g.byteLength)==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return l({done:!1,value:g})},d=g=>o?i:(o=!0,g!=null?u(g):l({done:!0})),m=()=>(n=new uw,d(),{done:!0}),p=g=>(d(g),{done:!0});if(i={[Symbol.asyncIterator](){return this},next:c,return:m,throw:p,push:h,end:d,get readableLength(){return n.size},onEmpty:async g=>{const y=g==null?void 0:g.signal;if(y==null||y.throwIfAborted(),n.isEmpty())return;let v,w;y!=null&&(v=new Promise((_,M)=>{w=()=>{M(new EX)},y.addEventListener("abort",w)}));try{await Promise.race([a.promise,v])}finally{w!=null&&y!=null&&(y==null||y.removeEventListener("abort",w))}}},t==null)return i;const b=i;return i={[Symbol.asyncIterator](){return this},next(){return b.next()},throw(g){return b.throw(g),t!=null&&(t(g),t=void 0),{done:!0}},return(){return b.return(),t!=null&&(t(),t=void 0),{done:!0}},push:h,end(g){return b.end(g),t!=null&&(t(g),t=void 0),i},get readableLength(){return b.readableLength},onEmpty:g=>b.onEmpty(g)},i}let AX=class extends Error{constructor(e){super(e),this.name="TimeoutError"}},TX=class extends Error{constructor(e){super(),this.name="AbortError",this.message=e}};const C2=r=>globalThis.DOMException===void 0?new TX(r):new DOMException(r),I2=r=>{const e=r.reason===void 0?C2("This operation was aborted."):r.reason;return e instanceof Error?e:C2(e)};function CX(r,e){const{milliseconds:t,fallback:n,message:i,customTimers:s={setTimeout,clearTimeout}}=e;let o,a;const l=new Promise((u,h)=>{if(typeof t!="number"||Math.sign(t)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${t}\``);if(e.signal){const{signal:m}=e;m.aborted&&h(I2(m)),a=()=>{h(I2(m))},m.addEventListener("abort",a,{once:!0})}if(t===Number.POSITIVE_INFINITY){r.then(u,h);return}const d=new AX;o=s.setTimeout.call(void 0,()=>{if(n){try{u(n())}catch(m){h(m)}return}typeof r.cancel=="function"&&r.cancel(),i===!1?u():i instanceof Error?h(i):(d.message=i??`Promise timed out after ${t} milliseconds`,h(d))},t),(async()=>{try{u(await r)}catch(m){h(m)}})()}).finally(()=>{l.clear(),a&&e.signal&&e.signal.removeEventListener("abort",a)});return l.clear=()=>{s.clearTimeout.call(void 0,o),o=void 0},l}const IX=r=>{const e=r.addEventListener||r.on||r.addListener,t=r.removeEventListener||r.off||r.removeListener;if(!e||!t)throw new TypeError("Emitter is not compatible");return{addListener:e.bind(r),removeListener:t.bind(r)}};function PX(r,e,t){let n;const i=new Promise((s,o)=>{var m;if(t={rejectionEvents:["error"],multiArgs:!1,rejectionMultiArgs:!1,resolveImmediately:!1,...t},!(t.count>=0&&(t.count===Number.POSITIVE_INFINITY||Number.isInteger(t.count))))throw new TypeError("The `count` option should be at least 0 or more");(m=t.signal)==null||m.throwIfAborted();const a=[e].flat(),c=[],{addListener:l,removeListener:u}=IX(r),h=async(...p)=>{const b=t.multiArgs?p:p[0];if(t.filter)try{if(!await t.filter(b))return}catch(g){n(),o(g);return}c.push(b),t.count===c.length&&(n(),s(c))},d=(...p)=>{n(),o(t.rejectionMultiArgs?p:p[0])};n=()=>{for(const p of a)u(p,h);for(const p of t.rejectionEvents)a.includes(p)||u(p,d)};for(const p of a)l(p,h);for(const p of t.rejectionEvents)a.includes(p)||l(p,d);t.signal&&t.signal.addEventListener("abort",()=>{d(t.signal.reason)},{once:!0}),t.resolveImmediately&&s(c)});if(i.cancel=n,typeof t.timeout=="number"){const s=CX(i,{milliseconds:t.timeout});return s.cancel=()=>{n(),s.clear()},s}return i}function Dn(r,e,t){typeof t=="function"&&(t={filter:t}),t={...t,count:1,resolveImmediately:!1};const n=PX(r,e,t),i=n.then(s=>s[0]);return i.cancel=n.cancel,i}function iy(r,e){let t;const n=function(){const i=function(){t=void 0,r()};clearTimeout(t),t=setTimeout(i,e)};return n.start=()=>{},n.stop=()=>{clearTimeout(t)},n}class RX extends Error{constructor(t="Rate limit exceeded",n){super(t);f(this,"remainingPoints");f(this,"msBeforeNext");f(this,"consumedPoints");f(this,"isFirstInDuration");this.name="RateLimitError",this.remainingPoints=n.remainingPoints,this.msBeforeNext=n.msBeforeNext,this.consumedPoints=n.consumedPoints,this.isFirstInDuration=n.isFirstInDuration}}var Ov;let DX=(Ov=class extends Error{constructor(e="The queue was full"){super(e),this.name="QueueFullError"}},f(Ov,"name","QueueFullError"),Ov);var Uv;let sy=(Uv=class extends Error{constructor(){super(...arguments);f(this,"name","UnexpectedEOFError")}},f(Uv,"name","UnexpectedEOFError"),Uv);class eO extends Error{constructor(){super(...arguments);f(this,"name","MaxEarlyStreamsError")}}f(eO,"name","MaxEarlyStreamsError");class tO extends Error{constructor(){super(...arguments);f(this,"name","StreamClosedError")}}f(tO,"name","StreamClosedError");function LX(r){return r.reason}async function rs(r,e,t){if(e==null)return r;const n=LX;if(e.aborted)return r.catch(()=>{}),Promise.reject(n(e));let i;try{return await Promise.race([r,new Promise((s,o)=>{i=()=>{o(n(e))},e.addEventListener("abort",i)})])}finally{i!=null&&e.removeEventListener("abort",i)}}let NX=class{constructor(e){f(this,"deferred");f(this,"signal");var t;this.signal=e,this.deferred=mi(),this.onAbort=this.onAbort.bind(this),(t=this.signal)==null||t.addEventListener("abort",this.onAbort)}onAbort(){var e;this.deferred.reject(((e=this.signal)==null?void 0:e.reason)??new ry)}cleanup(){var e;(e=this.signal)==null||e.removeEventListener("abort",this.onAbort)}};function OX(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}let UX=class{constructor(e,t){f(this,"id");f(this,"fn");f(this,"options");f(this,"recipients");f(this,"status");f(this,"timeline");f(this,"controller");this.id=OX(),this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((t,n)=>{var i;return t&&((i=n.signal)==null?void 0:i.aborted)===!0},!0)&&(this.controller.abort(new ry),this.cleanup())}async join(e={}){var n;const t=new NX(e.signal);return this.recipients.push(t),(n=e.signal)==null||n.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await rs(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{var t;e.cleanup(),(t=e.signal)==null||t.removeEventListener("abort",this.onAbort)})}},nO=class extends Pr{constructor(t={}){var n;super();f(this,"concurrency");f(this,"maxSize");f(this,"queue");f(this,"pending");f(this,"sort");f(this,"paused");this.concurrency=t.concurrency??Number.POSITIVE_INFINITY,this.maxSize=t.maxSize??Number.POSITIVE_INFINITY,this.pending=0,this.paused=!1,t.metricName!=null&&((n=t.metrics)==null||n.registerMetricGroup(t.metricName,{calculate:()=>({size:this.queue.length,running:this.pending,queued:this.queue.length-this.pending})})),this.sort=t.sort,this.queue=[],this.emitEmpty=iy(this.emitEmpty.bind(this),1),this.emitIdle=iy(this.emitIdle.bind(this),1)}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}pause(){this.paused=!0}resume(){this.paused&&(this.paused=!1,this.tryToStartAnother())}tryToStartAnother(){if(this.paused)return!1;if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let t;for(const n of this.queue)if(n.status==="queued"){t=n;break}return t==null?!1:(this.safeDispatchEvent("active"),this.pending++,t.run().finally(()=>{for(let n=0;n<this.queue.length;n++)if(this.queue[n]===t){this.queue.splice(n,1);break}this.pending--,this.tryToStartAnother(),this.safeDispatchEvent("next")}),!0)}return!1}enqueue(t){this.queue.push(t),this.sort!=null&&this.queue.sort(this.sort)}async add(t,n){var s;if((s=n==null?void 0:n.signal)==null||s.throwIfAborted(),this.size===this.maxSize)throw new DX;const i=new UX(t,n);return this.enqueue(i),this.safeDispatchEvent("add"),this.tryToStartAnother(),i.join(n).then(o=>(this.safeDispatchEvent("completed",{detail:o}),this.safeDispatchEvent("success",{detail:{job:i,result:o}}),o)).catch(o=>{if(i.status==="queued"){for(let a=0;a<this.queue.length;a++)if(this.queue[a]===i){this.queue.splice(a,1);break}}throw this.safeDispatchEvent("failure",{detail:{job:i,error:o}}),o})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(t=>{t.abort(new ry)}),this.clear()}async onEmpty(t){this.size!==0&&await Dn(this,"empty",t)}async onSizeLessThan(t,n){this.size<t||await Dn(this,"next",{...n,filter:()=>this.size<t})}async onIdle(t){this.pending===0&&this.size===0||await Dn(this,"idle",t)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(t){var l,u,h;(l=t==null?void 0:t.signal)==null||l.throwIfAborted();const n=k0({objectMode:!0}),i=d=>{d!=null?this.abort():this.clear(),n.end(d)},s=d=>{d.detail!=null&&n.push(d.detail)},o=d=>{i(d.detail.error)},a=()=>{i()},c=()=>{i(new ry("Queue aborted"))};this.addEventListener("completed",s),this.addEventListener("failure",o),this.addEventListener("idle",a),(u=t==null?void 0:t.signal)==null||u.addEventListener("abort",c);try{yield*n}finally{this.removeEventListener("completed",s),this.removeEventListener("failure",o),this.removeEventListener("idle",a),(h=t==null?void 0:t.signal)==null||h.removeEventListener("abort",c),i()}}};const kX=Math.pow(2,20)*4;class X1 extends Pr{constructor(t){super();f(this,"status");f(this,"timeline");f(this,"inactivityTimeout");f(this,"maxReadBufferLength");f(this,"maxWriteBufferLength");f(this,"log");f(this,"direction");f(this,"maxMessageSize");f(this,"readStatus");f(this,"writeStatus");f(this,"remoteReadStatus");f(this,"remoteWriteStatus");f(this,"writableNeedsDrain");f(this,"readBuffer");f(this,"writeBuffer");f(this,"sendingData");f(this,"onDrainPromise");this.status="open",this.log=t.log,this.direction=t.direction??"outbound",this.inactivityTimeout=t.inactivityTimeout??12e4,this.maxReadBufferLength=t.maxReadBufferLength??kX,this.maxWriteBufferLength=t.maxWriteBufferLength,this.maxMessageSize=t.maxMessageSize,this.readBuffer=new vt,this.writeBuffer=new vt,this.readStatus="readable",this.remoteReadStatus="readable",this.writeStatus="writable",this.remoteWriteStatus="writable",this.sendingData=!1,this.writableNeedsDrain=!1,this.timeline={open:Date.now()},this.processSendQueue=this.processSendQueue.bind(this);const n=()=>{var s;this.writableNeedsDrain&&(this.log.trace("drain event received, continue sending data"),this.writableNeedsDrain=!1,this.processSendQueue()),(s=this.onDrainPromise)==null||s.resolve()};this.addEventListener("drain",n);const i=s=>{var o;(o=this.onDrainPromise)==null||o.reject(s.error??new tO)};this.addEventListener("close",i)}get readBufferLength(){return this.readBuffer.byteLength}get writeBufferLength(){return this.writeBuffer.byteLength}async onDrain(t){return this.writableNeedsDrain!==!0?Promise.resolve():(this.onDrainPromise==null&&(this.onDrainPromise=Promise.withResolvers()),rs(this.onDrainPromise.promise,t==null?void 0:t.signal))}async*[Symbol.asyncIterator](){if(this.readStatus!=="readable"&&this.readStatus!=="paused")return;const t=k0(),n=o=>{t.push(o.data)};this.addEventListener("message",n);const i=o=>{t.end(o.error)};this.addEventListener("close",i);const s=()=>{t.end()};this.addEventListener("remoteCloseWrite",s);try{yield*t}finally{this.removeEventListener("message",n),this.removeEventListener("close",i),this.removeEventListener("remoteCloseWrite",s)}}isReadable(){return this.status==="open"}send(t){if(this.writeStatus==="closed"||this.writeStatus==="closing")throw new Zh(`Cannot write to a stream that is ${this.writeStatus}`);return this.log.trace("append %d bytes to write buffer",t.byteLength),this.writeBuffer.append(t),this.processSendQueue()}abort(t){if(!(this.status==="aborted"||this.status==="reset"||this.status==="closed")){this.log.error("abort with error - %e",t),this.status="aborted",this.readBuffer.byteLength>0&&this.readBuffer.consume(this.readBuffer.byteLength),this.writeBuffer.byteLength>0&&(this.writeBuffer.consume(this.writeBuffer.byteLength),this.safeDispatchEvent("idle")),this.writeStatus="closed",this.remoteWriteStatus="closed",this.readStatus="closed",this.remoteReadStatus="closed",this.timeline.close=Date.now();try{this.sendReset(t)}catch(n){this.log("failed to send reset to remote - %e",n)}this.dispatchEvent(new QK(t))}}pause(){if(this.readStatus==="closed"||this.readStatus==="closing")throw new Zh("Cannot pause a stream that is closing/closed");this.readStatus!=="paused"&&(this.readStatus="paused",this.sendPause())}resume(){if(this.readStatus==="closed"||this.readStatus==="closing")throw new Zh("Cannot resume a stream that is closing/closed");this.readStatus!=="readable"&&(this.readStatus="readable",this.dispatchReadBuffer(),this.sendResume())}push(t){if(this.readStatus==="closed"||this.readStatus==="closing")throw new Zh(`Cannot push data onto a stream that is ${this.readStatus}`);if(t.byteLength!==0){if(this.readBuffer.append(t),this.readStatus==="paused"||this.listenerCount("message")===0){this.checkReadBufferLength();return}setTimeout(()=>{this.dispatchReadBuffer()},0)}}unshift(t){if(this.readStatus==="closed"||this.readStatus==="closing")throw new Zh(`Cannot push data onto a stream that is ${this.readStatus}`);if(t.byteLength!==0){if(this.readBuffer.prepend(t),this.readStatus==="paused"||this.listenerCount("message")===0){this.checkReadBufferLength();return}setTimeout(()=>{this.dispatchReadBuffer()},0)}}onData(t){if(t.byteLength!==0){if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("ignoring data - read status %s",this.readStatus);return}this.readBuffer.append(t),this.dispatchReadBuffer()}}addEventListener(...t){super.addEventListener.apply(this,t),t[0]==="message"&&this.readBuffer.byteLength>0&&queueMicrotask(()=>{this.dispatchReadBuffer()})}onRemoteReset(){this.log("remote reset"),this.status="reset",this.writeStatus="closed",this.remoteWriteStatus="closed",this.remoteReadStatus="closed",this.timeline.close=Date.now(),this.readBuffer.byteLength===0&&(this.readStatus="closed");const t=new JK;this.dispatchEvent(new eX(t))}onTransportClosed(t){this.log("transport closed"),this.readStatus==="readable"&&this.readBuffer.byteLength===0&&(this.log("close readable end after transport closed and read buffer is empty"),this.readStatus="closed"),this.remoteReadStatus!=="closed"&&(this.remoteReadStatus="closed"),this.remoteWriteStatus!=="closed"&&(this.remoteWriteStatus="closed"),this.writeStatus!=="closed"&&(this.writeStatus="closed"),t!=null?this.abort(t):(this.status==="open"||this.status==="closing")&&(this.timeline.close=Date.now(),this.status="closed",this.writeStatus="closed",this.remoteWriteStatus="closed",this.remoteReadStatus="closed",this.dispatchEvent(new G1))}onRemoteCloseWrite(){this.remoteWriteStatus!=="closed"&&(this.log.trace("on remote close write"),this.remoteWriteStatus="closed",this.safeDispatchEvent("remoteCloseWrite"),this.writeStatus==="closed"&&this.onTransportClosed())}onRemoteCloseRead(){this.log.trace("on remote close read"),this.remoteReadStatus="closed",this.writeBuffer.byteLength>0&&(this.writeBuffer.consume(this.writeBuffer.byteLength),this.safeDispatchEvent("idle"))}processSendQueue(){if(this.writableNeedsDrain)return this.log.trace("not processing send queue as drain is required"),this.checkWriteBufferLength(),!1;if(this.writeBuffer.byteLength===0)return this.log.trace("not processing send queue as no bytes to send"),!0;if(this.sendingData)return this.log.trace("not processing send queue as already sending data"),!0;this.sendingData=!0,this.log.trace("processing send queue with %d queued bytes",this.writeBuffer.byteLength);try{let t=!0;const n=this.writeBuffer.byteLength;let i=0;for(;this.writeBuffer.byteLength>0;){const s=Math.min(this.maxMessageSize??this.writeBuffer.byteLength,this.writeBuffer.byteLength);if(s===0){t=!1;break}const o=this.writeBuffer.sublist(0,s),a=new vt(o);this.writeBuffer.consume(o.byteLength);const c=this.sendData(o);if(t=c.canSendMore,i+=c.sentBytes,c.sentBytes!==a.byteLength&&(a.consume(c.sentBytes),this.writeBuffer.prepend(a)),!t)break}return t||(this.log.trace("sent %d/%d bytes, pausing sending because underlying stream is full, %d bytes left in the write buffer",i,n,this.writeBuffer.byteLength),this.writableNeedsDrain=!0,this.checkWriteBufferLength()),this.writeBuffer.byteLength===0&&this.safeDispatchEvent("idle"),t}finally{this.sendingData=!1}}dispatchReadBuffer(){try{if(this.listenerCount("message")===0){this.log.trace("not dispatching pause buffer as there are no listeners for the message event");return}if(this.readBuffer.byteLength===0){this.log.trace("not dispatching pause buffer as there is no data to dispatch");return}if(this.readStatus==="paused"){this.log.trace("not dispatching pause buffer we are paused");return}if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("dropping %d bytes because the readable end is %s",this.readBuffer.byteLength,this.readStatus),this.readBuffer.consume(this.readBuffer.byteLength);return}const t=this.readBuffer.sublist();this.readBuffer.consume(t.byteLength),this.dispatchEvent(new jK(t))}finally{this.readBuffer.byteLength===0&&this.remoteWriteStatus==="closed"&&(this.log("close readable end after dispatching read buffer and remote writable end is closed"),this.readStatus="closed"),this.checkReadBufferLength()}}checkReadBufferLength(){this.readBuffer.byteLength>this.maxReadBufferLength&&this.abort(new oS(`Read buffer length of ${this.readBuffer.byteLength} exceeded limit of ${this.maxReadBufferLength}, read status is ${this.readStatus}`))}checkWriteBufferLength(){this.maxWriteBufferLength!=null&&this.writeBuffer.byteLength>this.maxWriteBufferLength&&this.abort(new oS(`Write buffer length of ${this.writeBuffer.byteLength} exceeded limit of ${this.maxWriteBufferLength}, write status is ${this.writeStatus}`))}onMuxerNeedsDrain(){this.writableNeedsDrain=!0}onMuxerDrain(){this.safeDispatchEvent("drain")}}class Y1 extends X1{constructor(t){super(t);f(this,"remoteAddr");f(this,"metricPrefix");f(this,"metrics");this.metricPrefix=t.metricPrefix??"",this.metrics=t.metrics,this.remoteAddr=t.remoteAddr,this.addEventListener("close",n=>{var i,s,o,a,c;(i=this.metrics)==null||i.increment({[`${this.metricPrefix}end`]:!0}),n.error!=null?n.local?(s=this.metrics)==null||s.increment({[`${this.metricPrefix}abort`]:!0}):(o=this.metrics)==null||o.increment({[`${this.metricPrefix}reset`]:!0}):n.local?(a=this.metrics)==null||a.increment({[`${this.metricPrefix}_local_close`]:!0}):(c=this.metrics)==null||c.increment({[`${this.metricPrefix}_remote_close`]:!0})})}async close(t){this.status==="open"&&(this.status="closing",this.writeStatus="closing",this.remoteWriteStatus="closing",this.remoteReadStatus="closing",(this.sendingData||this.writeBuffer.byteLength>0)&&(this.log("waiting for write queue to become idle before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await Dn(this,"idle",{...t,rejectionEvents:["close"]})),this.writableNeedsDrain&&(this.log("waiting for write queue to drain before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await Dn(this,"drain",{...t,rejectionEvents:["close"]})),await this.sendClose(t),this.onTransportClosed())}}function BX(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}class rO extends Pr{constructor(t,n){super();f(this,"streams");f(this,"protocol");f(this,"status");f(this,"log");f(this,"maConn");f(this,"streamOptions");f(this,"earlyStreams");f(this,"maxEarlyStreams");f(this,"metrics");this.maConn=t,this.protocol=n.protocol,this.streams=[],this.earlyStreams=[],this.status="open",this.log=t.log.newScope(n.name),this.streamOptions=n.streamOptions,this.maxEarlyStreams=n.maxEarlyStreams??10,this.metrics=n.metrics;const i=a=>{try{this.onData(a.data)}catch(c){this.abort(c),this.maConn.abort(c)}};this.maConn.addEventListener("message",i);const s=()=>{this.log("underlying stream drained, signal %d streams to continue writing",this.streams.length),this.streams.forEach(a=>{a.onMuxerDrain()})};this.maConn.addEventListener("drain",s);const o=()=>{this.log("underlying stream closed with status %s and %d streams",this.status,this.streams.length),this.onTransportClosed()};this.maConn.addEventListener("close",o)}send(t){const n=this.maConn.send(t);return n===!1&&(this.log("underlying stream saturated, signal %d streams to pause writing",this.streams.length),this.streams.forEach(i=>{i.onMuxerNeedsDrain()})),n}async close(t){this.status==="closed"||this.status==="closing"||(this.status="closing",await rs(Promise.all([...this.streams].map(async n=>{await n.close(t)})),t==null?void 0:t.signal),this.status="closed")}abort(t){this.status!=="closed"&&(this.status="closing",[...this.streams].forEach(n=>{n.abort(t)}),this.status="closed")}onTransportClosed(t){this.status="closing";try{[...this.streams].forEach(n=>{n.onTransportClosed(t)})}catch(n){this.abort(n)}this.status="closed"}async createStream(t){if(this.status!=="open")throw new ZK;let n=this.onCreateStream({...this.streamOptions,...t});return BX(n)&&(n=await n),this.streams.push(n),this.cleanUpStream(n),n}onRemoteStream(t){if(this.streams.push(t),this.cleanUpStream(t),this.listenerCount("stream")===0){this.earlyStreams.push(t),this.earlyStreams.length>this.maxEarlyStreams&&this.abort(new eO(`Too many early streams were opened - ${this.earlyStreams.length}/${this.maxEarlyStreams}`));return}this.safeDispatchEvent("stream",{detail:t})}cleanUpStream(t){var i;const n=s=>{var a,c,l;const o=this.streams.findIndex(u=>u===t);o!==-1&&this.streams.splice(o,1),s.error!=null?s.local?(a=this.metrics)==null||a.increment({[`${t.direction}_stream_reset`]:!0}):(c=this.metrics)==null||c.increment({[`${t.direction}_stream_abort`]:!0}):(l=this.metrics)==null||l.increment({[`${t.direction}_stream_end`]:!0})};t.addEventListener("close",n),(i=this.metrics)==null||i.increment({[`${t.direction}_stream`]:!0})}addEventListener(...t){super.addEventListener.apply(this,t),t[0]==="stream"&&this.earlyStreams.length>0&&queueMicrotask(()=>{this.earlyStreams.forEach(n=>{this.safeDispatchEvent("stream",{detail:n})}),this.earlyStreams=[]})}}class iO extends X1{constructor(t){super(t);f(this,"id");f(this,"protocol");this.id=t.id,this.protocol=t.protocol??""}async close(t){this.writeStatus==="closing"||this.writeStatus==="closed"||(this.writeStatus="closing",(this.sendingData||this.writeBuffer.byteLength>0)&&(this.log("waiting for write queue to become idle before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await Dn(this,"idle",{...t,rejectionEvents:["close"]})),this.writableNeedsDrain&&(this.log("waiting for write queue to drain before closing writable end of stream, %d unsent bytes, sending %s",this.writeBuffer.byteLength,this.sendingData),await Dn(this,"drain",{...t,rejectionEvents:["close"]}),this.log("write queue drained, closing writable end of stream, %d unsent bytes, sending %s",this.writeBuffer.byteLength,this.sendingData)),await this.sendCloseWrite(t),this.writeStatus="closed",this.log("closed writable end gracefully"),this.remoteWriteStatus==="closed"&&this.onTransportClosed())}async closeRead(t){this.readStatus==="closing"||this.readStatus==="closed"||(this.readBuffer.byteLength>0&&this.readBuffer.consume(this.readBuffer.byteLength),this.readStatus="closing",await this.sendCloseRead(t),this.readStatus="closed",this.log("closed readable end gracefully"))}}function Bc(r){const e=new globalThis.AbortController;function t(){e.abort();for(const s of r)(s==null?void 0:s.removeEventListener)!=null&&s.removeEventListener("abort",t)}for(const s of r){if((s==null?void 0:s.aborted)===!0){t();break}(s==null?void 0:s.addEventListener)!=null&&s.addEventListener("abort",t)}function n(){for(const s of r)(s==null?void 0:s.removeEventListener)!=null&&s.removeEventListener("abort",t)}const i=e.signal;return i.clear=n,i}class hw{constructor(e){f(this,"movingAverage");f(this,"variance");f(this,"deviation");f(this,"forecast");f(this,"timeSpan");f(this,"previousTime");this.timeSpan=e,this.movingAverage=0,this.variance=0,this.deviation=0,this.forecast=0}alpha(e,t){return 1-Math.exp(-(e-t)/this.timeSpan)}push(e,t=Date.now()){if(this.previousTime!=null){const n=this.alpha(t,this.previousTime),i=e-this.movingAverage,s=n*i;this.movingAverage=n*e+(1-n)*this.movingAverage,this.variance=(1-n)*(this.variance+i*s),this.deviation=Math.sqrt(this.variance),this.forecast=this.movingAverage+n*i}else this.movingAverage=e;this.previousTime=t}}const FX=1.2,$X=2,zX=5e3,VX=6e4,HX=5e3;class GX{constructor(e={}){f(this,"success");f(this,"failure");f(this,"next");f(this,"metric");f(this,"timeoutMultiplier");f(this,"failureMultiplier");f(this,"minTimeout");f(this,"maxTimeout");var n;const t=e.interval??HX;this.success=new hw(t),this.failure=new hw(t),this.next=new hw(t),this.failureMultiplier=e.failureMultiplier??$X,this.timeoutMultiplier=e.timeoutMultiplier??FX,this.minTimeout=e.minTimeout??zX,this.maxTimeout=e.maxTimeout??VX,e.metricName!=null&&(this.metric=(n=e.metrics)==null?void 0:n.registerMetricGroup(e.metricName))}getTimeoutSignal(e={}){let t=Math.round(this.next.movingAverage*(e.timeoutFactor??this.timeoutMultiplier));t<this.minTimeout&&(t=this.minTimeout),t>this.maxTimeout&&(t=this.maxTimeout);const n=AbortSignal.timeout(t),i=Bc([e.signal,n]);return i.start=Date.now(),i.timeout=t,i}cleanUp(e){var n,i;const t=Date.now()-e.start;e.aborted?(this.failure.push(t),this.next.push(t*this.failureMultiplier),(n=this.metric)==null||n.update({failureMovingAverage:this.failure.movingAverage,failureDeviation:this.failure.deviation,failureForecast:this.failure.forecast,failureVariance:this.failure.variance,failure:t})):(this.success.push(t),this.next.push(t),(i=this.metric)==null||i.update({successMovingAverage:this.success.movingAverage,successDeviation:this.success.deviation,successForecast:this.success.forecast,successVariance:this.success.variance,success:t}))}}let P2=class extends Error{constructor(t,n,i){super(t??"The operation was aborted");f(this,"type");f(this,"code");this.type="aborted",this.name=i??"AbortError",this.code=n??"ABORT_ERR"}};async function WX(r,e,t){if(e==null)return r;if(e.aborted)return r.catch(()=>{}),Promise.reject(new P2(t==null?void 0:t.errorMessage,t==null?void 0:t.errorCode,t==null?void 0:t.errorName));let n;const i=new P2(t==null?void 0:t.errorMessage,t==null?void 0:t.errorCode,t==null?void 0:t.errorName);try{return await Promise.race([r,new Promise((s,o)=>{n=()=>{o(i)},e.addEventListener("abort",n)})])}finally{n!=null&&e.removeEventListener("abort",n)}}class qX{constructor(){f(this,"readNext");f(this,"haveNext");f(this,"ended");f(this,"nextResult");f(this,"error");this.ended=!1,this.readNext=mi(),this.haveNext=mi()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=mi(),e}async throw(e){return this.ended=!0,this.error=e,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){e!=null?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(e!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=mi(),await WX(this.readNext.promise,t==null?void 0:t.signal,t)}}function KX(){return new qX}function XX(r){return r[Symbol.asyncIterator]!=null}async function YX(r,e,t){try{await Promise.all(r.map(async n=>{for await(const i of n)await e.push(i,{signal:t}),t.throwIfAborted()})),await e.end(void 0,{signal:t})}catch(n){await e.end(n,{signal:t}).catch(()=>{})}}async function*ZX(r){const e=new AbortController,t=KX();YX(r,t,e.signal).catch(()=>{});try{yield*t}finally{e.abort()}}function*JX(r){for(const e of r)yield*e}function lS(...r){const e=[];for(const t of r)XX(t)||e.push(t);return e.length===r.length?JX(e):ZX(r)}const jX=4194304;var kv;let R2=(kv=class extends Error{constructor(){super(...arguments);f(this,"name","UnwrappedError")}},f(kv,"name","UnwrappedError"),kv),sO=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidMessageLengthError");f(this,"code","ERR_INVALID_MSG_LENGTH")}},QX=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidDataLengthError");f(this,"code","ERR_MSG_DATA_TOO_LONG")}},eY=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidDataLengthLengthError");f(this,"code","ERR_MSG_LENGTH_TOO_LONG")}};function tY(r){return typeof(r==null?void 0:r.closeRead)=="function"}function nY(r){return typeof(r==null?void 0:r.close)=="function"}function dw(r){return tY(r)?r.remoteWriteStatus!=="writable"&&r.readBufferLength===0:nY(r)?r.status!=="open":!1}function rY(r){return(r==null?void 0:r.addEventListener)!=null&&(r==null?void 0:r.removeEventListener)!=null&&(r==null?void 0:r.send)!=null&&(r==null?void 0:r.push)!=null&&(r==null?void 0:r.log)!=null}function oO(r,e){const t=(e==null?void 0:e.maxBufferSize)??jX,n=new vt;let i,s=!1;if(!rY(r))throw new H1("Argument should be a Stream or a Multiaddr");const o=u=>{if(n.append(u.data),n.byteLength>t){const h=n.byteLength;n.consume(n.byteLength),i==null||i.reject(new Error(`Read buffer overflow - ${h} > ${t}`))}i==null||i.resolve()};r.addEventListener("message",o);const a=u=>{u.error!=null?i==null||i.reject(u.error):i==null||i.resolve()};r.addEventListener("close",a);const c=()=>{i==null||i.resolve()};r.addEventListener("remoteCloseWrite",c);const l={readBuffer:n,async read(u){if(s===!0)throw new R2("Stream was unwrapped");if(dw(r)){if((u==null?void 0:u.bytes)==null)return null;if(n.byteLength<u.bytes)throw r.log.error("closed after reading %d/%d bytes",n.byteLength,u.bytes),new sy(`Unexpected EOF - stream closed after reading ${n.byteLength}/${u.bytes} bytes`)}const h=(u==null?void 0:u.bytes)??1;for(i=Promise.withResolvers();;){if(n.byteLength>=h){i.resolve();break}if(await rs(i.promise,u==null?void 0:u.signal),dw(r)){if(n.byteLength===0&&(u==null?void 0:u.bytes)==null)return null;break}i=Promise.withResolvers()}const d=(u==null?void 0:u.bytes)??n.byteLength;if(n.byteLength<d){if(dw(r))throw r.log.error("closed while reading %d/%d bytes",n.byteLength,d),new sy(`Unexpected EOF - stream closed while reading ${n.byteLength}/${d} bytes`);return l.read(u)}const m=n.sublist(0,d);return n.consume(d),m},async write(u,h){if(s===!0)throw new R2("Stream was unwrapped");r.send(u)||await Dn(r,"drain",{signal:h==null?void 0:h.signal,rejectionEvents:["close"]})},unwrap(){return s||(s=!0,r.removeEventListener("message",o),r.removeEventListener("close",a),r.removeEventListener("remoteCloseWrite",c),n.byteLength>0&&(r.log("stream unwrapped with %d unread bytes",n.byteLength),r.push(n))),r}};return l}function bf(r,e={}){const t=oO(r,e);e.maxDataLength!=null&&e.maxLengthLength==null&&(e.maxLengthLength=Ue(e.maxDataLength));const n=(e==null?void 0:e.lengthDecoder)??Yt,i=(e==null?void 0:e.lengthEncoder)??Zl;return{async read(o){let a=-1;const c=new vt;for(;;){const u=await t.read({...o,bytes:1});if(u==null)break;c.append(u);try{a=n(c)}catch(h){if(h instanceof RangeError)continue;throw h}if(a<0)throw new sO("Invalid message length");if((e==null?void 0:e.maxLengthLength)!=null&&c.byteLength>e.maxLengthLength)throw new eY(`Message length length too long - ${c.byteLength} > ${e.maxLengthLength}`);if(a>-1)break}if((e==null?void 0:e.maxDataLength)!=null&&a>e.maxDataLength)throw new QX(`Message length too long - ${a} > ${e.maxDataLength}`);const l=await t.read({...o,bytes:a});if(l==null)throw r.log.error("tried to read %d bytes but the stream closed",a),new sy(`Unexpected EOF - tried to read ${a} bytes but the stream closed`);if(l.byteLength!==a)throw r.log.error("read %d/%d bytes before the stream closed",l.byteLength,a),new sy(`Unexpected EOF - read ${l.byteLength}/${a} bytes before the stream closed`);return l},async write(o,a){await t.write(new vt(i(o.byteLength),o),a)},async writeV(o,a){const c=new vt(...o.flatMap(l=>[i(l.byteLength),l]));await t.write(c,a)},unwrap(){return t.unwrap()}}}function Ma(r,e){const t=bf(r,e),n={read:async(i,s)=>{const o=await t.read(s);return i.decode(o)},write:async(i,s,o)=>{await t.write(s.encode(i),o)},writeV:async(i,s,o)=>{await t.writeV(i.map(a=>s.encode(a)),o)},pb:i=>({read:async s=>n.read(i,s),write:async(s,o)=>n.write(s,i,o),writeV:async(s,o)=>n.writeV(s,i,o),unwrap:()=>n}),unwrap:()=>t.unwrap()};return n}const iY=1024*1024*4,sY=1024*1024*4;class oY{constructor(e={}){f(this,"buffer");f(this,"maxBufferSize");f(this,"lengthDecoder");f(this,"maxDataLength");f(this,"encodingLength");this.buffer=new vt,this.maxBufferSize=e.maxBufferSize??iY,this.maxDataLength=e.maxDataLength??sY,this.lengthDecoder=e.lengthDecoder??Yt,this.encodingLength=e.encodingLength??Ue}*decode(e){if(this.buffer.append(e),this.buffer.byteLength>this.maxBufferSize)throw new H1(`Buffer length limit exceeded - ${this.buffer.byteLength}/${this.maxBufferSize}`);for(;;){let t;try{t=this.lengthDecoder(this.buffer)}catch(s){if(s instanceof RangeError)break;throw s}if(t<0||t>this.maxDataLength)throw new sO("Invalid message length");const n=this.encodingLength(t),i=n+t;if(this.buffer.byteLength>=i){const s=this.buffer.sublist(n,i);this.buffer.consume(i),s.byteLength>0&&(yield s)}else break}}}class Z1 extends nO{has(e){return this.find(e)!=null}find(e){return this.queue.find(t=>e.equals(t.options.peerId))}}let aY=class extends nO{constructor(e={}){super({...e,sort:(t,n)=>t.options.priority>n.options.priority?-1:t.options.priority<n.options.priority?1:0})}};class cY{constructor(e={}){f(this,"memoryStorage");f(this,"points");f(this,"duration");f(this,"blockDuration");f(this,"keyPrefix");this.points=e.points??4,this.duration=e.duration??1,this.blockDuration=e.blockDuration??0,this.keyPrefix=e.keyPrefix??"rlflx",this.memoryStorage=new lY}consume(e,t=1,n={}){const i=this.getKey(e),s=this._getKeySecDuration(n);let o=this.memoryStorage.incrby(i,t,s);if(o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o.consumedPoints>this.points)throw this.blockDuration>0&&o.consumedPoints<=this.points+t&&(o=this.memoryStorage.set(i,o.consumedPoints,this.blockDuration)),new RX("Rate limit exceeded",o);return o}penalty(e,t=1,n={}){const i=this.getKey(e),s=this._getKeySecDuration(n),o=this.memoryStorage.incrby(i,t,s);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}reward(e,t=1,n={}){const i=this.getKey(e),s=this._getKeySecDuration(n),o=this.memoryStorage.incrby(i,-t,s);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}block(e,t){const n=t*1e3,i=this.points+1;return this.memoryStorage.set(this.getKey(e),i,t),{remainingPoints:0,msBeforeNext:n===0?-1:n,consumedPoints:i,isFirstInDuration:!1}}set(e,t,n=0){const i=(n>=0?n:this.duration)*1e3;return this.memoryStorage.set(this.getKey(e),t,n),{remainingPoints:0,msBeforeNext:i===0?-1:i,consumedPoints:t,isFirstInDuration:!1}}get(e){const t=this.memoryStorage.get(this.getKey(e));return t!=null&&(t.remainingPoints=Math.max(this.points-t.consumedPoints,0)),t}delete(e){this.memoryStorage.delete(this.getKey(e))}_getKeySecDuration(e){return(e==null?void 0:e.customDuration)!=null&&e.customDuration>=0?e.customDuration:this.duration}getKey(e){return this.keyPrefix.length>0?`${this.keyPrefix}:${e}`:e}parseKey(e){return e.substring(this.keyPrefix.length)}}class lY{constructor(){f(this,"storage");this.storage=new Map}incrby(e,t,n){const i=this.storage.get(e);if(i!=null){const s=i.expiresAt!=null?i.expiresAt.getTime()-new Date().getTime():-1;return i.expiresAt==null||s>0?(i.value+=t,{remainingPoints:0,msBeforeNext:s,consumedPoints:i.value,isFirstInDuration:!1}):this.set(e,t,n)}return this.set(e,t,n)}set(e,t,n){const i=n*1e3,s=this.storage.get(e);s!=null&&clearTimeout(s.timeoutId);const o={value:t,expiresAt:i>0?new Date(Date.now()+i):void 0};return this.storage.set(e,o),i>0&&(o.timeoutId=setTimeout(()=>{this.storage.delete(e)},i),o.timeoutId.unref!=null&&o.timeoutId.unref()),{remainingPoints:0,msBeforeNext:i===0?-1:i,consumedPoints:o.value,isFirstInDuration:!0}}get(e){const t=this.storage.get(e);if(t!=null)return{remainingPoints:0,msBeforeNext:t.expiresAt!=null?t.expiresAt.getTime()-new Date().getTime():-1,consumedPoints:t.value,isFirstInDuration:!1}}delete(e){const t=this.storage.get(e);return t!=null?(t.timeoutId!=null&&clearTimeout(t.timeoutId),this.storage.delete(e),!0):!1}}function aO(r,e,t){let n,i,s=!1;function o(){const l={signal:i.signal};if((t==null?void 0:t.timeout)!=null){const u=Bc([i.signal,AbortSignal.timeout(t.timeout)]);l.signal=u}s=!0,Promise.resolve().then(async()=>{await r(l)}).catch(()=>{}).finally(()=>{s=!1,!i.signal.aborted&&(n=setTimeout(o,e))})}const a=iy(o,(t==null?void 0:t.debounce)??100);let c=!1;return{setInterval:l=>{e!==l&&(e=l,n!=null&&(clearTimeout(n),n=setTimeout(o,e)))},setTimeout:l=>{t??(t={}),t.timeout=l},run:()=>{s||(clearTimeout(n),a())},start:()=>{c||(c=!0,i=new AbortController,i.signal,(t==null?void 0:t.runImmediately)===!0?queueMicrotask(()=>{o()}):n=setTimeout(o,e))},stop:()=>{clearTimeout(n),i==null||i.abort(),c=!1}}}class uY extends Map{constructor(t){super();f(this,"metric");const{name:n,metrics:i}=t;this.metric=i.registerMetric(n),this.updateComponentMetric()}set(t,n){return super.set(t,n),this.updateComponentMetric(),this}delete(t){const n=super.delete(t);return this.updateComponentMetric(),n}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function Po(r){const{name:e,metrics:t}=r;let n;return t!=null?n=new uY({name:e,metrics:t}):n=new Map,n}class hY{constructor(e,t){f(this,"filter");this.filter=mf(e,t)}has(e){return this.filter.has(e.toMultihash().bytes)}add(e){this.filter.add(e.toMultihash().bytes)}remove(e){var t,n;(n=(t=this.filter).remove)==null||n.call(t,e.toMultihash().bytes)}}function dY(r,e=.001){return new hY(r,e)}class fY extends wh{constructor(t){super();f(this,"metric");const{name:n,metrics:i}=t;this.metric=i.registerMetric(n),this.updateComponentMetric()}set(t,n){return super.set(t,n),this.updateComponentMetric(),this}delete(t){const n=super.delete(t);return this.updateComponentMetric(),n}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function pY(r){const{name:e,metrics:t}=r;let n;return t!=null?n=new fY({name:e,metrics:t}):n=new wh,n}var Bv;let di=(Bv=class extends Error{constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}},f(Bv,"name","InvalidParametersError"),Bv);var Fv;let D2=(Fv=class extends Error{constructor(e="Not found"){super(e),this.name="NotFoundError"}},f(Fv,"name","NotFoundError"),Fv);var $v;let mY=($v=class extends Error{constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}},f($v,"name","InvalidCIDError"),$v);var zv;let gY=(zv=class extends Error{constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}},f(zv,"name","InvalidMultihashError"),zv);var Vv;let yY=(Vv=class extends Error{constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}},f(Vv,"name","UnsupportedKeyTypeError"),Vv);const J1=Symbol.for("@libp2p/peer-id");function bg(r){return!!(r!=null&&r[J1])}const cO=Symbol.for("nodejs.util.inspect.custom"),bY=114;var YP;let j1=class{constructor(e){f(this,"type");f(this,"multihash");f(this,"publicKey");f(this,"string");f(this,YP,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=gt.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return Ze.createV1(bY,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return We(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return We(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(YP=J1,cO)](){return`PeerId(${this.toString()})`}},lO=class extends j1{constructor(t){super({...t,type:"RSA"});f(this,"type","RSA");f(this,"publicKey");this.publicKey=t.publicKey}},uO=class extends j1{constructor(t){super({...t,type:"Ed25519"});f(this,"type","Ed25519");f(this,"publicKey");this.publicKey=t.publicKey}},hO=class extends j1{constructor(t){super({...t,type:"secp256k1"});f(this,"type","secp256k1");f(this,"publicKey");this.publicKey=t.publicKey}};const wY=2336;var ZP,JP;let dO=class{constructor(e){f(this,"type","url");f(this,"multihash");f(this,"publicKey");f(this,"url");f(this,ZP,!0);this.url=e.toString(),this.multihash=dn.digest(Se(this.url))}[(JP=cO,ZP=J1,JP)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return Ze.createV1(wY,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=ae(e)),e.toString()===this.toString())}};const vY=114,L2=2336;function _Y(r){if(r.type==="Ed25519")return new uO({multihash:r.toCID().multihash,publicKey:r});if(r.type==="secp256k1")return new hO({multihash:r.toCID().multihash,publicKey:r});if(r.type==="RSA")return new lO({multihash:r.toCID().multihash,publicKey:r});throw new yY}function xY(r){if(EY(r))return new lO({multihash:r});if(SY(r))try{const e=No(r);if(e.type==="Ed25519")return new uO({multihash:r,publicKey:e});if(e.type==="secp256k1")return new hO({multihash:r,publicKey:e})}catch{const t=ae(r.digest);return new dO(new URL(t))}throw new gY("Supplied PeerID Multihash is invalid")}function fO(r){if((r==null?void 0:r.multihash)==null||r.version==null||r.version===1&&r.code!==vY&&r.code!==L2)throw new mY("Supplied PeerID CID is invalid");if(r.code===L2){const e=ae(r.multihash.digest);return new dO(new URL(e))}return xY(r.multihash)}function SY(r){return r.code===dn.code}function EY(r){return r.code===Ns.code}var oy;(function(r){let e;r.codec=()=>(e==null&&(e=Gt((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(n.uint32(10),n.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(n.uint32(18),n.bytes(t.payloadType)),t.payload!=null&&t.payload.byteLength>0&&(n.uint32(26),n.bytes(t.payload)),t.signature!=null&&t.signature.byteLength>0&&(n.uint32(42),n.bytes(t.signature)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={publicKey:xt(0),payloadType:xt(0),payload:xt(0),signature:xt(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.publicKey=t.bytes();break}case 2:{s.payloadType=t.bytes();break}case 3:{s.payload=t.bytes();break}case 5:{s.signature=t.bytes();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Ht(t,r.codec()),r.decode=(t,n)=>Vt(t,r.codec(),n)})(oy||(oy={}));class MY extends Error{constructor(e="Invalid signature"){super(e),this.name="InvalidSignatureError"}}const sa=class sa{constructor(e){f(this,"publicKey");f(this,"payloadType");f(this,"payload");f(this,"signature");f(this,"marshaled");const{publicKey:t,payloadType:n,payload:i,signature:s}=e;this.publicKey=t,this.payloadType=n,this.payload=i,this.signature=s}marshal(){return this.marshaled==null&&(this.marshaled=oy.encode({publicKey:Ms(this.publicKey),payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(e){return e==null?!1:We(this.marshal(),e.marshal())}async validate(e,t){const n=N2(e,this.payloadType,this.payload);return this.publicKey.verify(n.subarray(),this.signature,t)}};f(sa,"createFromProtobuf",e=>{const t=oy.decode(e),n=Io(t.publicKey);return new sa({publicKey:n,payloadType:t.payloadType,payload:t.payload,signature:t.signature})}),f(sa,"seal",async(e,t,n)=>{if(t==null)throw new Error("Missing private key");const i=e.domain,s=e.codec,o=e.marshal(),a=N2(i,s,o),c=await t.sign(a.subarray(),n);return new sa({publicKey:t.publicKey,payloadType:s,payload:o,signature:c})}),f(sa,"openAndCertify",async(e,t,n)=>{const i=sa.createFromProtobuf(e);if(!await i.validate(t,n))throw new MY("Envelope signature is not valid for the given domain");return i});let Fc=sa;const N2=(r,e,t)=>{const n=Se(r),i=Zl(n.byteLength),s=Zl(e.length),o=Zl(t.length);return new vt(i,n,s,e,o,t)};var Hv;let AY=(Hv=class extends Error{constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}},f(Hv,"name","InvalidMultihashError"),Hv);const pO=Symbol.for("@libp2p/peer-id"),mO=Symbol.for("nodejs.util.inspect.custom"),TY=114;var jP;let Q1=class{constructor(e){f(this,"type");f(this,"multihash");f(this,"publicKey");f(this,"string");f(this,jP,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=gt.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return Ze.createV1(TY,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return We(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return We(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(jP=pO,mO)](){return`PeerId(${this.toString()})`}},CY=class extends Q1{constructor(t){super({...t,type:"RSA"});f(this,"type","RSA");f(this,"publicKey");this.publicKey=t.publicKey}},IY=class extends Q1{constructor(t){super({...t,type:"Ed25519"});f(this,"type","Ed25519");f(this,"publicKey");this.publicKey=t.publicKey}},PY=class extends Q1{constructor(t){super({...t,type:"secp256k1"});f(this,"type","secp256k1");f(this,"publicKey");this.publicKey=t.publicKey}};const RY=2336;var QP,eR;let DY=class{constructor(e){f(this,"type","url");f(this,"multihash");f(this,"publicKey");f(this,"url");f(this,QP,!0);this.url=e.toString(),this.multihash=dn.digest(Se(this.url))}[(eR=mO,QP=pO,eR)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return Ze.createV1(RY,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=ae(e)),e.toString()===this.toString())}};function LY(r){if(OY(r))return new CY({multihash:r});if(NY(r))try{const e=No(r);if(e.type==="Ed25519")return new IY({multihash:r,publicKey:e});if(e.type==="secp256k1")return new PY({multihash:r,publicKey:e})}catch{const t=ae(r.digest);return new DY(new URL(t))}throw new AY("Supplied PeerID Multihash is invalid")}function NY(r){return r.code===dn.code}function OY(r){return r.code===Ns.code}var Gv;let gi=(Gv=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidMultiaddrError")}},f(Gv,"name","InvalidMultiaddrError"),Gv);var Wv;let wf=(Wv=class extends Error{constructor(){super(...arguments);f(this,"name","ValidationError")}},f(Wv,"name","ValidationError"),Wv);var qv;let UY=(qv=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidParametersError")}},f(qv,"name","InvalidParametersError"),qv);var Kv;let kY=(Kv=class extends Error{constructor(){super(...arguments);f(this,"name","UnknownProtocolError")}},f(Kv,"name","UnknownProtocolError"),Kv);const BY=4,FY=6,$Y=273,zY=33,VY=41,HY=42,GY=43,WY=53,qY=54,KY=55,XY=56,YY=132,ZY=301,JY=302,jY=400,QY=421,eZ=444,tZ=445,nZ=446,rZ=447,iZ=448,sZ=449,oZ=454,aZ=460,cZ=461,lZ=465,uZ=466,hZ=480,dZ=481,fZ=443,pZ=477,mZ=478,gZ=479,yZ=277,bZ=275,wZ=276,vZ=280,_Z=281,xZ=290,SZ=777;function O2(r){return e=>ae(e,r)}function U2(r){return e=>Se(e,r)}function sd(r){return new DataView(r.buffer).getUint16(r.byteOffset).toString()}function Ol(r){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof r=="string"?parseInt(r):r),new Uint8Array(e)}function EZ(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=Se(e[0],"base32"),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=Ol(n);return ut([t,i],t.length+i.length)}function MZ(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=Rn.decode(`b${e[0]}`),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=Ol(n);return ut([t,i],t.length+i.length)}function k2(r){const e=r.subarray(0,r.length-2),t=r.subarray(r.length-2),n=ae(e,"base32"),i=sd(t);return`${n}:${i}`}const gO=function(r){r=r.toString().trim();const e=new Uint8Array(4);return r.split(/\./g).forEach((t,n)=>{const i=parseInt(t,10);if(isNaN(i)||i<0||i>255)throw new gi("Invalid byte value in IP address");e[n]=i}),e},AZ=function(r){let e=0;r=r.toString().trim();const t=r.split(":",8);let n;for(n=0;n<t.length;n++){const s=$t(t[n]);let o;s&&(o=gO(t[n]),t[n]=ae(o.subarray(0,2),"base16")),o!=null&&++n<8&&t.splice(n,0,ae(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(n=0;n<t.length&&t[n]!=="";n++);const s=[n,1];for(n=9-t.length;n>0;n--)s.push("0");t.splice.apply(t,s)}const i=new Uint8Array(e+16);for(n=0;n<t.length;n++){t[n]===""&&(t[n]="0");const s=parseInt(t[n],16);if(isNaN(s)||s<0||s>65535)throw new gi("Invalid byte value in IP address");i[e++]=s>>8&255,i[e++]=s&255}return i},TZ=function(r){if(r.byteLength!==4)throw new gi("IPv4 address was incorrect length");const e=[];for(let t=0;t<r.byteLength;t++)e.push(r[t]);return e.join(".")},CZ=function(r){if(r.byteLength!==16)throw new gi("IPv6 address was incorrect length");const e=[];for(let n=0;n<r.byteLength;n+=2){const i=r[n],s=r[n+1],o=`${i.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const n=new URL(`http://[${t}]`);return n.hostname.substring(1,n.hostname.length-1)}catch{throw new gi(`Invalid IPv6 address "${t}"`)}};function IZ(r){try{const e=new URL(`http://[${r}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new gi(`Invalid IPv6 address "${r}"`)}}const fw=Object.values(oi).map(r=>r.decoder),PZ=(function(){let r=fw[0].or(fw[1]);return fw.slice(2).forEach(e=>r=r.or(e)),r})();function RZ(r){return PZ.decode(r)}function DZ(r){return e=>r.encoder.encode(e)}function LZ(r){if(parseInt(r).toString()!==r)throw new wf("Value must be an integer")}function NZ(r){if(r<0)throw new wf("Value must be a positive integer, or zero")}function OZ(r){return e=>{if(e>r)throw new wf(`Value must be smaller than or equal to ${r}`)}}function UZ(...r){return e=>{for(const t of r)t(e)}}const Cm=UZ(LZ,NZ,OZ(65535)),jn=-1;let kZ=class{constructor(){f(this,"protocolsByCode",new Map);f(this,"protocolsByName",new Map)}getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new kY(`Protocol ${e} was unknown`);return t}addProtocol(e){var t;this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),(t=e.aliases)==null||t.forEach(n=>{this.protocolsByName.set(n,e)})}removeProtocol(e){var n;const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),(n=t.aliases)==null||n.forEach(i=>{this.protocolsByName.delete(i)}))}};const vh=new kZ,BZ=[{code:BY,name:"ip4",size:32,valueToBytes:gO,bytesToValue:TZ,validate:r=>{if(!$t(r))throw new wf(`Invalid IPv4 address "${r}"`)}},{code:FY,name:"tcp",size:16,valueToBytes:Ol,bytesToValue:sd,validate:Cm},{code:$Y,name:"udp",size:16,valueToBytes:Ol,bytesToValue:sd,validate:Cm},{code:zY,name:"dccp",size:16,valueToBytes:Ol,bytesToValue:sd,validate:Cm},{code:VY,name:"ip6",size:128,valueToBytes:AZ,bytesToValue:CZ,stringToValue:IZ,validate:r=>{if(!Ai(r))throw new wf(`Invalid IPv6 address "${r}"`)}},{code:HY,name:"ip6zone",size:jn},{code:GY,name:"ipcidr",size:8,bytesToValue:O2("base10"),valueToBytes:U2("base10")},{code:WY,name:"dns",size:jn},{code:qY,name:"dns4",size:jn},{code:KY,name:"dns6",size:jn},{code:XY,name:"dnsaddr",size:jn},{code:YY,name:"sctp",size:16,valueToBytes:Ol,bytesToValue:sd,validate:Cm},{code:ZY,name:"udt"},{code:JY,name:"utp"},{code:jY,name:"unix",size:jn,stringToValue:r=>decodeURIComponent(r),valueToString:r=>encodeURIComponent(r)},{code:QY,name:"p2p",aliases:["ipfs"],size:jn,bytesToValue:O2("base58btc"),valueToBytes:r=>r.startsWith("Q")||r.startsWith("1")?U2("base58btc")(r):Ze.parse(r).multihash.bytes},{code:eZ,name:"onion",size:96,bytesToValue:k2,valueToBytes:EZ},{code:tZ,name:"onion3",size:296,bytesToValue:k2,valueToBytes:MZ},{code:nZ,name:"garlic64",size:jn},{code:rZ,name:"garlic32",size:jn},{code:iZ,name:"tls"},{code:sZ,name:"sni",size:jn},{code:oZ,name:"noise"},{code:aZ,name:"quic"},{code:cZ,name:"quic-v1"},{code:lZ,name:"webtransport"},{code:uZ,name:"certhash",size:jn,bytesToValue:DZ(Mi),valueToBytes:RZ},{code:hZ,name:"http"},{code:dZ,name:"http-path",size:jn,stringToValue:r=>`/${decodeURIComponent(r)}`,valueToString:r=>encodeURIComponent(r.substring(1))},{code:fZ,name:"https"},{code:pZ,name:"ws"},{code:mZ,name:"wss"},{code:gZ,name:"p2p-websocket-star"},{code:yZ,name:"p2p-stardust"},{code:bZ,name:"p2p-webrtc-star"},{code:wZ,name:"p2p-webrtc-direct"},{code:vZ,name:"webrtc-direct"},{code:_Z,name:"webrtc"},{code:xZ,name:"p2p-circuit"},{code:SZ,name:"memory",size:jn}];BZ.forEach(r=>{vh.addProtocol(r)});function FZ(r){var n;const e=[];let t=0;for(;t<r.length;){const i=Yt(r,t),s=vh.getProtocol(i),o=Ue(i),a=HZ(s,r,t+o);let c=0;a>0&&s.size===jn&&(c=Ue(a));const l=o+c+a,u={code:i,name:s.name,bytes:r.subarray(t,t+l)};if(a>0){const h=t+o+c,d=r.subarray(h,h+a);u.value=((n=s.bytesToValue)==null?void 0:n.call(s,d))??ae(d)}e.push(u),t+=l}return e}function $Z(r){var n;let e=0;const t=[];for(const i of r){if(i.bytes==null){const s=vh.getProtocol(i.code),o=Ue(i.code);let a,c=0,l=0;i.value!=null&&(a=((n=s.valueToBytes)==null?void 0:n.call(s,i.value))??Se(i.value),c=a.byteLength,s.size===jn&&(l=Ue(c)));const u=new Uint8Array(o+l+c);let h=0;sn(i.code,u,h),h+=o,a!=null&&(s.size===jn&&(sn(c,u,h),h+=l),u.set(a,h)),i.bytes=u}t.push(i.bytes),e+=i.bytes.byteLength}return ut(t,e)}function zZ(r){var s;if(r.charAt(0)!=="/")throw new gi('String multiaddr must start with "/"');const e=[];let t="protocol",n="",i="";for(let o=1;o<r.length;o++){const a=r.charAt(o);a!=="/"&&(t==="protocol"?i+=r.charAt(o):n+=r.charAt(o));const c=o===r.length-1;if(a==="/"||c){const l=vh.getProtocol(i);if(t==="protocol"){if(l.size==null||l.size===0){e.push({code:l.code,name:l.name}),n="",i="",t="protocol";continue}else if(c)throw new gi(`Component ${i} was missing value`);t="value"}else if(t==="value"){const u={code:l.code,name:l.name};if(l.size!=null&&l.size!==0){if(n==="")throw new gi(`Component ${i} was missing value`);u.value=((s=l.stringToValue)==null?void 0:s.call(l,n))??n}e.push(u),n="",i="",t="protocol"}}}if(i!==""&&n!=="")throw new gi("Incomplete multiaddr");return e}function VZ(r){return`/${r.flatMap(e=>{var n;if(e.value==null)return e.name;const t=vh.getProtocol(e.code);if(t==null)throw new gi(`Unknown protocol code ${e.code}`);return[e.name,((n=t.valueToString)==null?void 0:n.call(t,e.value))??e.value]}).join("/")}`}function HZ(r,e,t){return r.size==null||r.size===0?0:r.size>0?r.size/8:Yt(e,t)}const GZ=Symbol.for("nodejs.util.inspect.custom"),yO=Symbol.for("@multiformats/multiaddr");function WZ(r){if(r==null&&(r="/"),XZ(r))return r.getComponents();if(r instanceof Uint8Array)return FZ(r);if(typeof r=="string")return r=r.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),r===""&&(r="/"),zZ(r);if(Array.isArray(r))return r;throw new gi("Must be a string, Uint8Array, Component[], or another Multiaddr")}var tR,Ni,ou,au,lo;let qZ=(lo=class{constructor(e="/",t={}){f(this,tR,!0);xe(this,Ni);xe(this,ou);xe(this,au);_e(this,Ni,WZ(e)),t.validate!==!1&&KZ(this)}get bytes(){return N(this,au)==null&&_e(this,au,$Z(N(this,Ni))),N(this,au)}toString(){return N(this,ou)==null&&_e(this,ou,VZ(N(this,Ni))),N(this,ou)}toJSON(){return this.toString()}getComponents(){return[...N(this,Ni).map(e=>({...e}))]}encapsulate(e){const t=new lo(e);return new lo([...N(this,Ni),...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),n=this.toString(),i=n.lastIndexOf(t);if(i<0)throw new UY(`Address ${this.toString()} does not contain subaddress: ${t}`);return new lo(n.slice(0,i),{validate:!1})}decapsulateCode(e){let t;for(let n=N(this,Ni).length-1;n>-1;n--)if(N(this,Ni)[n].code===e){t=n;break}return new lo(N(this,Ni).slice(0,t),{validate:!1})}equals(e){return We(this.bytes,e.bytes)}[(tR=yO,GZ)](){return`Multiaddr(${this.toString()})`}},Ni=new WeakMap,ou=new WeakMap,au=new WeakMap,lo);function KZ(r){r.getComponents().forEach(e=>{var n;const t=vh.getProtocol(e.code);e.value!=null&&((n=t.validate)==null||n.call(t,e.value))})}function XZ(r){return!!(r!=null&&r[yO])}function YZ(r){return new qZ(r)}const ZZ="libp2p-peer-record",JZ=Uint8Array.from([3,1]);var ay;(function(r){(function(t){let n;t.codec=()=>(n==null&&(n=Gt((i,s,o={})=>{o.lengthDelimited!==!1&&s.fork(),i.multiaddr!=null&&i.multiaddr.byteLength>0&&(s.uint32(10),s.bytes(i.multiaddr)),o.lengthDelimited!==!1&&s.ldelim()},(i,s,o={})=>{const a={multiaddr:xt(0)},c=s==null?i.len:i.pos+s;for(;i.pos<c;){const l=i.uint32();switch(l>>>3){case 1:{a.multiaddr=i.bytes();break}default:{i.skipType(l&7);break}}}return a})),n),t.encode=i=>Ht(i,t.codec()),t.decode=(i,s)=>Vt(i,t.codec(),s)})(r.AddressInfo||(r.AddressInfo={}));let e;r.codec=()=>(e==null&&(e=Gt((t,n,i={})=>{if(i.lengthDelimited!==!1&&n.fork(),t.peerId!=null&&t.peerId.byteLength>0&&(n.uint32(10),n.bytes(t.peerId)),t.seq!=null&&t.seq!==0n&&(n.uint32(16),n.uint64(t.seq)),t.addresses!=null)for(const s of t.addresses)n.uint32(26),r.AddressInfo.codec().encode(s,n);i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{var a,c;const s={peerId:xt(0),seq:0n,addresses:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const l=t.uint32();switch(l>>>3){case 1:{s.peerId=t.bytes();break}case 2:{s.seq=t.uint64();break}case 3:{if(((a=i.limits)==null?void 0:a.addresses)!=null&&s.addresses.length===i.limits.addresses)throw new Cs('Decode error - map field "addresses" had too many elements');s.addresses.push(r.AddressInfo.codec().decode(t,t.uint32(),{limits:(c=i.limits)==null?void 0:c.addresses$}));break}default:{t.skipType(l&7);break}}}return s})),e),r.encode=t=>Ht(t,r.codec()),r.decode=(t,n)=>Vt(t,r.codec(),n)})(ay||(ay={}));function jZ(r,e){const t=(n,i)=>n.toString().localeCompare(i.toString());return r.length!==e.length?!1:(e.sort(t),r.sort(t).every((n,i)=>e[i].equals(n)))}const Js=class Js{constructor(e){f(this,"peerId");f(this,"multiaddrs");f(this,"seqNumber");f(this,"domain",Js.DOMAIN);f(this,"codec",Js.CODEC);f(this,"marshaled");const{peerId:t,multiaddrs:n,seqNumber:i}=e;this.peerId=t,this.multiaddrs=n??[],this.seqNumber=i??BigInt(Date.now())}marshal(){return this.marshaled==null&&(this.marshaled=ay.encode({peerId:this.peerId.toMultihash().bytes,seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map(e=>({multiaddr:e.bytes}))})),this.marshaled}equals(e){return!(!(e instanceof Js)||!this.peerId.equals(e.peerId)||this.seqNumber!==e.seqNumber||!jZ(this.multiaddrs,e.multiaddrs))}};f(Js,"createFromProtobuf",e=>{const t=ay.decode(e),n=LY(Lo(t.peerId)),i=(t.addresses??[]).map(o=>YZ(o.multiaddr)),s=t.seq;return new Js({peerId:n,multiaddrs:i,seqNumber:s})}),f(Js,"DOMAIN",ZZ),f(Js,"CODEC",JZ);let xo=Js;function QZ(r){return r[Symbol.asyncIterator]!=null}function uS(r){if(QZ(r))return(async()=>{const t=[];for await(const n of r)t.push(n);return t})();const e=[];for(const t of r)e.push(t);return e}var Xv;let Ju=(Xv=class extends Error{constructor(t="The operation was aborted",...n){super(t,...n);f(this,"name","AbortError")}},f(Xv,"name","AbortError"),Xv);async function pw(r,e,t,n){const i=new Ju(n==null?void 0:n.errorMessage);(n==null?void 0:n.errorCode)!=null&&(i.code=n.errorCode);const s=(n==null?void 0:n.errorEvent)??"error";return(t==null?void 0:t.aborted)===!0?Promise.reject(i):new Promise((o,a)=>{function c(){gw(t,"abort",h),gw(r,e,l),gw(r,s,u)}const l=d=>{var m;try{if(((m=n==null?void 0:n.filter)==null?void 0:m.call(n,d))===!1)return}catch(p){c(),a(p);return}c(),o(d)},u=d=>{if(c(),d instanceof Error){a(d);return}a(d.detail??(n==null?void 0:n.error)??new Error(`The "${n==null?void 0:n.errorEvent}" event was emitted but the event had no '.detail' field. Pass an 'error' option to race-event to change this message.`))},h=()=>{c(),a(i)};mw(t,"abort",h),mw(r,e,l),mw(r,s,u)})}function mw(r,e,t){r!=null&&(bO(r)?r.addEventListener(e,t):r.addListener(e,t))}function gw(r,e,t){r!=null&&(bO(r)?r.removeEventListener(e,t):r.removeListener(e,t))}function bO(r){return typeof r.addEventListener=="function"&&typeof r.removeEventListener=="function"}class wO extends Error{constructor(e="The queue was full"){super(e),this.name="QueueFullError"}}f(wO,"name","QueueFullError");let B2=class extends Error{constructor(t,n,i){super(t??"The operation was aborted");f(this,"type");f(this,"code");this.type="aborted",this.name=i??"AbortError",this.code=n??"ABORT_ERR"}};async function eJ(r,e,t){if(e==null)return r;if(e.aborted)return r.catch(()=>{}),Promise.reject(new B2(t==null?void 0:t.errorMessage,t==null?void 0:t.errorCode,t==null?void 0:t.errorName));let n;const i=new B2(t==null?void 0:t.errorMessage,t==null?void 0:t.errorCode,t==null?void 0:t.errorName);try{return await Promise.race([r,new Promise((s,o)=>{n=()=>{o(i)},e.addEventListener("abort",n)})])}finally{n!=null&&e.removeEventListener("abort",n)}}class tJ{constructor(e){f(this,"deferred");f(this,"signal");var t;this.signal=e,this.deferred=Promise.withResolvers(),this.onAbort=this.onAbort.bind(this),(t=this.signal)==null||t.addEventListener("abort",this.onAbort)}onAbort(){var e;this.deferred.reject(((e=this.signal)==null?void 0:e.reason)??new Ju)}cleanup(){var e;(e=this.signal)==null||e.removeEventListener("abort",this.onAbort)}}function nJ(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}class rJ{constructor(e,t){f(this,"id");f(this,"fn");f(this,"options");f(this,"recipients");f(this,"status");f(this,"timeline");f(this,"controller");this.id=nJ(),this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((t,n)=>{var i;return t&&((i=n.signal)==null?void 0:i.aborted)===!0},!0)&&(this.controller.abort(new Ju),this.cleanup())}async join(e={}){var n;const t=new tJ(e.signal);return this.recipients.push(t),(n=e.signal)==null||n.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await eJ(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{var t;e.cleanup(),(t=e.signal)==null||t.removeEventListener("abort",this.onAbort)})}}function F2(r,e){let t;const n=function(){const i=function(){t=void 0,r()};clearTimeout(t),t=setTimeout(i,e)};return n.start=()=>{},n.stop=()=>{clearTimeout(t)},n}class $2 extends Pr{constructor(t={}){super();f(this,"concurrency");f(this,"maxSize");f(this,"queue");f(this,"pending");f(this,"sort");f(this,"autoStart");this.concurrency=t.concurrency??Number.POSITIVE_INFINITY,this.maxSize=t.maxSize??Number.POSITIVE_INFINITY,this.pending=0,this.autoStart=t.autoStart??!0,this.sort=t.sort,this.queue=[],this.emitEmpty=F2(this.emitEmpty.bind(this),1),this.emitIdle=F2(this.emitIdle.bind(this),1)}[Symbol.asyncIterator](){return this.toGenerator()}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let t;for(const n of this.queue)if(n.status==="queued"){t=n;break}return t==null?!1:(this.safeDispatchEvent("active"),this.pending++,t.run().finally(()=>{for(let n=0;n<this.queue.length;n++)if(this.queue[n]===t){this.queue.splice(n,1);break}this.pending--,this.safeDispatchEvent("next"),this.autoStart&&this.tryToStartAnother()}),!0)}return!1}enqueue(t){this.queue.push(t),this.sort!=null&&this.queue.sort(this.sort)}start(){this.autoStart===!1&&(this.autoStart=!0,this.tryToStartAnother())}pause(){this.autoStart=!1}async add(t,n){var s;if((s=n==null?void 0:n.signal)==null||s.throwIfAborted(),this.size===this.maxSize)throw new wO;const i=new rJ(t,n);return this.enqueue(i),this.safeDispatchEvent("add"),this.autoStart&&this.tryToStartAnother(),i.join(n).then(o=>(this.safeDispatchEvent("success",{detail:{job:i,result:o}}),o)).catch(o=>{if(i.status==="queued"){for(let a=0;a<this.queue.length;a++)if(this.queue[a]===i){this.queue.splice(a,1);break}}throw this.safeDispatchEvent("failure",{detail:{job:i,error:o}}),o})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(t=>{t.abort(new Ju)}),this.clear()}async onEmpty(t){this.size!==0&&await pw(this,"empty",t==null?void 0:t.signal)}async onSizeLessThan(t,n){this.size<t||await pw(this,"next",n==null?void 0:n.signal,{filter:()=>this.size<t})}async onIdle(t){this.pending===0&&this.size===0||await pw(this,"idle",t==null?void 0:t.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(t){var l,u,h;(l=t==null?void 0:t.signal)==null||l.throwIfAborted();const n=k0({objectMode:!0}),i=d=>{d!=null?this.abort():this.clear(),n.end(d)},s=d=>{d.detail!=null&&n.push(d.detail.result)},o=d=>{i(d.detail.error)},a=()=>{i()},c=()=>{i(new Ju("Queue aborted"))};this.addEventListener("success",s),this.addEventListener("failure",o),this.addEventListener("idle",a),(u=t==null?void 0:t.signal)==null||u.addEventListener("abort",c);try{yield*n}finally{this.removeEventListener("success",s),this.removeEventListener("failure",o),this.removeEventListener("idle",a),(h=t==null?void 0:t.signal)==null||h.removeEventListener("abort",c),i()}}}const vO="lock:worker:request-read",_O="lock:worker:abort-read-request",xO="lock:worker:release-read",SO="lock:master:grant-read",EO="lock:master:error-read",MO="lock:worker:request-write",AO="lock:worker:abort-write-request",TO="lock:worker:release-write",CO="lock:master:grant-write",IO="lock:master:error-write",PO="lock:worker:finalize",RO="mortice",iJ={singleProcess:!1},z2=(r,e,t,n,i,s,o,a,c)=>l=>{if(l.data==null)return;const u={type:l.data.type,name:l.data.name,identifier:l.data.identifier};u.type===i&&r.safeDispatchEvent(t,{detail:{name:u.name,identifier:u.identifier,handler:async()=>{e.postMessage({type:c,name:u.name,identifier:u.identifier}),await new Promise(h=>{const d=m=>{if((m==null?void 0:m.data)==null)return;const p={type:m.data.type,name:m.data.name,identifier:m.data.identifier};p.type===a&&p.identifier===u.identifier&&(e.removeEventListener("message",d),h())};e.addEventListener("message",d)})},onError:h=>{e.postMessage({type:o,name:u.name,identifier:u.identifier,error:{message:h.message,name:h.name,stack:h.stack}})}}}),u.type===s&&r.safeDispatchEvent(n,{detail:{name:u.name,identifier:u.identifier}}),u.type===PO&&r.safeDispatchEvent("finalizeRequest",{detail:{name:u.name}})},sJ=(r=10)=>Math.random().toString().substring(2,r+2);class oJ{constructor(e){f(this,"name");f(this,"channel");this.name=e,this.channel=new BroadcastChannel(RO)}readLock(e){return this.sendRequest(vO,_O,SO,EO,xO,e)}writeLock(e){return this.sendRequest(MO,AO,CO,IO,TO,e)}finalize(){this.channel.postMessage({type:PO,name:this.name}),this.channel.close()}async sendRequest(e,t,n,i,s,o){var c;(c=o==null?void 0:o.signal)==null||c.throwIfAborted();const a=sJ();return this.channel.postMessage({type:e,identifier:a,name:this.name}),new Promise((l,u)=>{var m;const h=()=>{this.channel.postMessage({type:t,identifier:a,name:this.name})};(m=o==null?void 0:o.signal)==null||m.addEventListener("abort",h,{once:!0});const d=p=>{var b,g,y,v;if(((b=p.data)==null?void 0:b.identifier)===a&&(((g=p.data)==null?void 0:g.type)===n&&(this.channel.removeEventListener("message",d),(y=o==null?void 0:o.signal)==null||y.removeEventListener("abort",h),l(()=>{this.channel.postMessage({type:s,identifier:a,name:this.name})})),p.data.type===i)){this.channel.removeEventListener("message",d),(v=o==null?void 0:o.signal)==null||v.removeEventListener("abort",h);const w=new Error;p.data.error!=null&&(w.message=p.data.error.message,w.name=p.data.error.name,w.stack=p.data.error.stack),u(w)}};this.channel.addEventListener("message",d)})}}const aJ=r=>{if(r=Object.assign({},iJ,r),!!globalThis.document||r.singleProcess){const t=new BroadcastChannel(RO),n=new Pr;return t.addEventListener("message",z2(n,t,"requestReadLock","abortReadLockRequest",vO,_O,EO,xO,SO)),t.addEventListener("message",z2(n,t,"requestWriteLock","abortWriteLockRequest",MO,AO,IO,TO,CO)),n}return new oJ(r.name)},uc=new Map;let Jh;function DO(r){return typeof(r==null?void 0:r.readLock)=="function"&&typeof(r==null?void 0:r.writeLock)=="function"}function cJ(r){if(Jh==null&&(Jh=aJ(r),!DO(Jh))){const e=Jh;e.addEventListener("requestReadLock",t=>{const n=t.detail.name,i=t.detail.identifier,s=uc.get(n);if(s==null)return;const o=new AbortController,a=c=>{c.detail.name!==n||c.detail.identifier!==i||o.abort()};e.addEventListener("abortReadLockRequest",a),s.readLock({signal:o.signal}).then(async c=>{await t.detail.handler().finally(()=>{c()})}).catch(c=>{t.detail.onError(c)}).finally(()=>{e.removeEventListener("abortReadLockRequest",a)})}),e.addEventListener("requestWriteLock",t=>{const n=t.detail.name,i=t.detail.identifier,s=uc.get(n);if(s==null)return;const o=new AbortController,a=c=>{c.detail.name!==n||c.detail.identifier!==i||o.abort()};e.addEventListener("abortWriteLockRequest",a),s.writeLock({signal:o.signal}).then(async c=>{await t.detail.handler().finally(()=>{c()})}).catch(c=>{t.detail.onError(c)}).finally(()=>{e.removeEventListener("abortWriteLockRequest",a)})}),e.addEventListener("finalizeRequest",t=>{const n=t.detail.name,i=uc.get(n);i!=null&&i.finalize()})}return Jh}async function yw(r,e){var o;let t,n;const i=new Promise((a,c)=>{t=a,n=c}),s=()=>{n(new Ju)};return(o=e==null?void 0:e.signal)==null||o.addEventListener("abort",s,{once:!0}),r.add(async()=>{await new Promise(a=>{t(()=>{var c;(c=e==null?void 0:e.signal)==null||c.removeEventListener("abort",s),a()})})},{signal:e==null?void 0:e.signal}).catch(a=>{n(a)}),i}const lJ=(r,e)=>{let t=uc.get(r);if(t!=null)return t;const n=cJ(e);if(DO(n))return t=n,uc.set(r,t),t;const i=new $2({concurrency:1});let s;return t={async readLock(o){if(s!=null)return yw(s,o);s=new $2({concurrency:e.concurrency,autoStart:!1});const a=s,c=yw(s,o);return i.add(async()=>{a.start(),await a.onIdle().then(()=>{s===a&&(s=null)})}),c},async writeLock(o){return s=null,yw(i,o)},finalize:()=>{uc.delete(r)},queue:i},uc.set(r,t),e.autoFinalize===!0&&i.addEventListener("idle",()=>{t.finalize()},{once:!0}),t},uJ={name:"lock",concurrency:1/0,singleProcess:!1,autoFinalize:!1};function hJ(r){const e=Object.assign({},uJ,r);return lJ(e.name,e)}const dJ=36e5,fJ=216e5;var hc;(function(r){(function(t){let n;t.codec=()=>(n==null&&(n=Gt((i,s,o={})=>{o.lengthDelimited!==!1&&s.fork(),i.key!=null&&i.key!==""&&(s.uint32(10),s.string(i.key)),i.value!=null&&i.value.byteLength>0&&(s.uint32(18),s.bytes(i.value)),o.lengthDelimited!==!1&&s.ldelim()},(i,s,o={})=>{const a={key:"",value:xt(0)},c=s==null?i.len:i.pos+s;for(;i.pos<c;){const l=i.uint32();switch(l>>>3){case 1:{a.key=i.string();break}case 2:{a.value=i.bytes();break}default:{i.skipType(l&7);break}}}return a})),n),t.encode=i=>Ht(i,t.codec()),t.decode=(i,s)=>Vt(i,t.codec(),s)})(r.Peer$metadataEntry||(r.Peer$metadataEntry={})),(function(t){let n;t.codec=()=>(n==null&&(n=Gt((i,s,o={})=>{o.lengthDelimited!==!1&&s.fork(),i.key!=null&&i.key!==""&&(s.uint32(10),s.string(i.key)),i.value!=null&&(s.uint32(18),ly.codec().encode(i.value,s)),o.lengthDelimited!==!1&&s.ldelim()},(i,s,o={})=>{var l;const a={key:""},c=s==null?i.len:i.pos+s;for(;i.pos<c;){const u=i.uint32();switch(u>>>3){case 1:{a.key=i.string();break}case 2:{a.value=ly.codec().decode(i,i.uint32(),{limits:(l=o.limits)==null?void 0:l.value});break}default:{i.skipType(u&7);break}}}return a})),n),t.encode=i=>Ht(i,t.codec()),t.decode=(i,s)=>Vt(i,t.codec(),s)})(r.Peer$tagsEntry||(r.Peer$tagsEntry={}));let e;r.codec=()=>(e==null&&(e=Gt((t,n,i={})=>{if(i.lengthDelimited!==!1&&n.fork(),t.addresses!=null)for(const s of t.addresses)n.uint32(10),cy.codec().encode(s,n);if(t.protocols!=null)for(const s of t.protocols)n.uint32(18),n.string(s);if(t.publicKey!=null&&(n.uint32(34),n.bytes(t.publicKey)),t.peerRecordEnvelope!=null&&(n.uint32(42),n.bytes(t.peerRecordEnvelope)),t.metadata!=null&&t.metadata.size!==0)for(const[s,o]of t.metadata.entries())n.uint32(50),r.Peer$metadataEntry.codec().encode({key:s,value:o},n);if(t.tags!=null&&t.tags.size!==0)for(const[s,o]of t.tags.entries())n.uint32(58),r.Peer$tagsEntry.codec().encode({key:s,value:o},n);t.updated!=null&&(n.uint32(64),n.uint64Number(t.updated)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{var a,c,l,u,h,d;const s={addresses:[],protocols:[],metadata:new Map,tags:new Map},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const m=t.uint32();switch(m>>>3){case 1:{if(((a=i.limits)==null?void 0:a.addresses)!=null&&s.addresses.length===i.limits.addresses)throw new Cs('Decode error - map field "addresses" had too many elements');s.addresses.push(cy.codec().decode(t,t.uint32(),{limits:(c=i.limits)==null?void 0:c.addresses$}));break}case 2:{if(((l=i.limits)==null?void 0:l.protocols)!=null&&s.protocols.length===i.limits.protocols)throw new Cs('Decode error - map field "protocols" had too many elements');s.protocols.push(t.string());break}case 4:{s.publicKey=t.bytes();break}case 5:{s.peerRecordEnvelope=t.bytes();break}case 6:{if(((u=i.limits)==null?void 0:u.metadata)!=null&&s.metadata.size===i.limits.metadata)throw new p2('Decode error - map field "metadata" had too many elements');const p=r.Peer$metadataEntry.codec().decode(t,t.uint32());s.metadata.set(p.key,p.value);break}case 7:{if(((h=i.limits)==null?void 0:h.tags)!=null&&s.tags.size===i.limits.tags)throw new p2('Decode error - map field "tags" had too many elements');const p=r.Peer$tagsEntry.codec().decode(t,t.uint32(),{limits:{value:(d=i.limits)==null?void 0:d.tags$value}});s.tags.set(p.key,p.value);break}case 8:{s.updated=t.uint64Number();break}default:{t.skipType(m&7);break}}}return s})),e),r.encode=t=>Ht(t,r.codec()),r.decode=(t,n)=>Vt(t,r.codec(),n)})(hc||(hc={}));var cy;(function(r){let e;r.codec=()=>(e==null&&(e=Gt((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.multiaddr!=null&&t.multiaddr.byteLength>0&&(n.uint32(10),n.bytes(t.multiaddr)),t.isCertified!=null&&(n.uint32(16),n.bool(t.isCertified)),t.observed!=null&&(n.uint32(24),n.uint64Number(t.observed)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={multiaddr:xt(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.multiaddr=t.bytes();break}case 2:{s.isCertified=t.bool();break}case 3:{s.observed=t.uint64Number();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Ht(t,r.codec()),r.decode=(t,n)=>Vt(t,r.codec(),n)})(cy||(cy={}));var ly;(function(r){let e;r.codec=()=>(e==null&&(e=Gt((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.value!=null&&t.value!==0&&(n.uint32(8),n.uint32(t.value)),t.expiry!=null&&(n.uint32(16),n.uint64(t.expiry)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={value:0},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.value=t.uint32();break}case 2:{s.expiry=t.uint64();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Ht(t,r.codec()),r.decode=(t,n)=>Vt(t,r.codec(),n)})(ly||(ly={}));var Yv;let yi=(Yv=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidMultiaddrError")}},f(Yv,"name","InvalidMultiaddrError"),Yv);var Zv;let vf=(Zv=class extends Error{constructor(){super(...arguments);f(this,"name","ValidationError")}},f(Zv,"name","ValidationError"),Zv);var Jv;let pJ=(Jv=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidParametersError")}},f(Jv,"name","InvalidParametersError"),Jv);var jv;let mJ=(jv=class extends Error{constructor(){super(...arguments);f(this,"name","UnknownProtocolError")}},f(jv,"name","UnknownProtocolError"),jv);const gJ=4,yJ=6,bJ=273,wJ=33,vJ=41,_J=42,xJ=43,SJ=53,EJ=54,MJ=55,AJ=56,TJ=132,CJ=301,IJ=302,PJ=400,LO=421,RJ=444,DJ=445,LJ=446,NJ=447,OJ=448,UJ=449,kJ=454,BJ=460,FJ=461,$J=465,zJ=466,VJ=480,HJ=481,GJ=443,WJ=477,qJ=478,KJ=479,XJ=277,YJ=275,ZJ=276,JJ=280,jJ=281,QJ=290,ej=777;function V2(r){return e=>ae(e,r)}function H2(r){return e=>Se(e,r)}function od(r){return new DataView(r.buffer).getUint16(r.byteOffset).toString()}function Ul(r){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof r=="string"?parseInt(r):r),new Uint8Array(e)}function tj(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=Se(e[0],"base32"),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=Ul(n);return ut([t,i],t.length+i.length)}function nj(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=Rn.decode(`b${e[0]}`),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=Ul(n);return ut([t,i],t.length+i.length)}function G2(r){const e=r.subarray(0,r.length-2),t=r.subarray(r.length-2),n=ae(e,"base32"),i=od(t);return`${n}:${i}`}const NO=function(r){r=r.toString().trim();const e=new Uint8Array(4);return r.split(/\./g).forEach((t,n)=>{const i=parseInt(t,10);if(isNaN(i)||i<0||i>255)throw new yi("Invalid byte value in IP address");e[n]=i}),e},rj=function(r){let e=0;r=r.toString().trim();const t=r.split(":",8);let n;for(n=0;n<t.length;n++){const s=$t(t[n]);let o;s&&(o=NO(t[n]),t[n]=ae(o.subarray(0,2),"base16")),o!=null&&++n<8&&t.splice(n,0,ae(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(n=0;n<t.length&&t[n]!=="";n++);const s=[n,1];for(n=9-t.length;n>0;n--)s.push("0");t.splice.apply(t,s)}const i=new Uint8Array(e+16);for(n=0;n<t.length;n++){t[n]===""&&(t[n]="0");const s=parseInt(t[n],16);if(isNaN(s)||s<0||s>65535)throw new yi("Invalid byte value in IP address");i[e++]=s>>8&255,i[e++]=s&255}return i},ij=function(r){if(r.byteLength!==4)throw new yi("IPv4 address was incorrect length");const e=[];for(let t=0;t<r.byteLength;t++)e.push(r[t]);return e.join(".")},sj=function(r){if(r.byteLength!==16)throw new yi("IPv6 address was incorrect length");const e=[];for(let n=0;n<r.byteLength;n+=2){const i=r[n],s=r[n+1],o=`${i.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const n=new URL(`http://[${t}]`);return n.hostname.substring(1,n.hostname.length-1)}catch{throw new yi(`Invalid IPv6 address "${t}"`)}};function oj(r){try{const e=new URL(`http://[${r}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new yi(`Invalid IPv6 address "${r}"`)}}const bw=Object.values(oi).map(r=>r.decoder),aj=(function(){let r=bw[0].or(bw[1]);return bw.slice(2).forEach(e=>r=r.or(e)),r})();function cj(r){return aj.decode(r)}function lj(r){return e=>r.encoder.encode(e)}function uj(r){if(parseInt(r).toString()!==r)throw new vf("Value must be an integer")}function hj(r){if(r<0)throw new vf("Value must be a positive integer, or zero")}function dj(r){return e=>{if(e>r)throw new vf(`Value must be smaller than or equal to ${r}`)}}function fj(...r){return e=>{for(const t of r)t(e)}}const Im=fj(uj,hj,dj(65535)),Qn=-1;let pj=class{constructor(){f(this,"protocolsByCode",new Map);f(this,"protocolsByName",new Map)}getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new mJ(`Protocol ${e} was unknown`);return t}addProtocol(e){var t;this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),(t=e.aliases)==null||t.forEach(n=>{this.protocolsByName.set(n,e)})}removeProtocol(e){var n;const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),(n=t.aliases)==null||n.forEach(i=>{this.protocolsByName.delete(i)}))}};const _h=new pj,mj=[{code:gJ,name:"ip4",size:32,valueToBytes:NO,bytesToValue:ij,validate:r=>{if(!$t(r))throw new vf(`Invalid IPv4 address "${r}"`)}},{code:yJ,name:"tcp",size:16,valueToBytes:Ul,bytesToValue:od,validate:Im},{code:bJ,name:"udp",size:16,valueToBytes:Ul,bytesToValue:od,validate:Im},{code:wJ,name:"dccp",size:16,valueToBytes:Ul,bytesToValue:od,validate:Im},{code:vJ,name:"ip6",size:128,valueToBytes:rj,bytesToValue:sj,stringToValue:oj,validate:r=>{if(!Ai(r))throw new vf(`Invalid IPv6 address "${r}"`)}},{code:_J,name:"ip6zone",size:Qn},{code:xJ,name:"ipcidr",size:8,bytesToValue:V2("base10"),valueToBytes:H2("base10")},{code:SJ,name:"dns",size:Qn},{code:EJ,name:"dns4",size:Qn},{code:MJ,name:"dns6",size:Qn},{code:AJ,name:"dnsaddr",size:Qn},{code:TJ,name:"sctp",size:16,valueToBytes:Ul,bytesToValue:od,validate:Im},{code:CJ,name:"udt"},{code:IJ,name:"utp"},{code:PJ,name:"unix",size:Qn,stringToValue:r=>decodeURIComponent(r),valueToString:r=>encodeURIComponent(r)},{code:LO,name:"p2p",aliases:["ipfs"],size:Qn,bytesToValue:V2("base58btc"),valueToBytes:r=>r.startsWith("Q")||r.startsWith("1")?H2("base58btc")(r):Ze.parse(r).multihash.bytes},{code:RJ,name:"onion",size:96,bytesToValue:G2,valueToBytes:tj},{code:DJ,name:"onion3",size:296,bytesToValue:G2,valueToBytes:nj},{code:LJ,name:"garlic64",size:Qn},{code:NJ,name:"garlic32",size:Qn},{code:OJ,name:"tls"},{code:UJ,name:"sni",size:Qn},{code:kJ,name:"noise"},{code:BJ,name:"quic"},{code:FJ,name:"quic-v1"},{code:$J,name:"webtransport"},{code:zJ,name:"certhash",size:Qn,bytesToValue:lj(Mi),valueToBytes:cj},{code:VJ,name:"http"},{code:HJ,name:"http-path",size:Qn,stringToValue:r=>`/${decodeURIComponent(r)}`,valueToString:r=>encodeURIComponent(r.substring(1))},{code:GJ,name:"https"},{code:WJ,name:"ws"},{code:qJ,name:"wss"},{code:KJ,name:"p2p-websocket-star"},{code:XJ,name:"p2p-stardust"},{code:YJ,name:"p2p-webrtc-star"},{code:ZJ,name:"p2p-webrtc-direct"},{code:JJ,name:"webrtc-direct"},{code:jJ,name:"webrtc"},{code:QJ,name:"p2p-circuit"},{code:ej,name:"memory",size:Qn}];mj.forEach(r=>{_h.addProtocol(r)});function gj(r){var n;const e=[];let t=0;for(;t<r.length;){const i=Yt(r,t),s=_h.getProtocol(i),o=Ue(i),a=vj(s,r,t+o);let c=0;a>0&&s.size===Qn&&(c=Ue(a));const l=o+c+a,u={code:i,name:s.name,bytes:r.subarray(t,t+l)};if(a>0){const h=t+o+c,d=r.subarray(h,h+a);u.value=((n=s.bytesToValue)==null?void 0:n.call(s,d))??ae(d)}e.push(u),t+=l}return e}function yj(r){var n;let e=0;const t=[];for(const i of r){if(i.bytes==null){const s=_h.getProtocol(i.code),o=Ue(i.code);let a,c=0,l=0;i.value!=null&&(a=((n=s.valueToBytes)==null?void 0:n.call(s,i.value))??Se(i.value),c=a.byteLength,s.size===Qn&&(l=Ue(c)));const u=new Uint8Array(o+l+c);let h=0;sn(i.code,u,h),h+=o,a!=null&&(s.size===Qn&&(sn(c,u,h),h+=l),u.set(a,h)),i.bytes=u}t.push(i.bytes),e+=i.bytes.byteLength}return ut(t,e)}function bj(r){var s;if(r.charAt(0)!=="/")throw new yi('String multiaddr must start with "/"');const e=[];let t="protocol",n="",i="";for(let o=1;o<r.length;o++){const a=r.charAt(o);a!=="/"&&(t==="protocol"?i+=r.charAt(o):n+=r.charAt(o));const c=o===r.length-1;if(a==="/"||c){const l=_h.getProtocol(i);if(t==="protocol"){if(l.size==null||l.size===0){e.push({code:l.code,name:l.name}),n="",i="",t="protocol";continue}else if(c)throw new yi(`Component ${i} was missing value`);t="value"}else if(t==="value"){const u={code:l.code,name:l.name};if(l.size!=null&&l.size!==0){if(n==="")throw new yi(`Component ${i} was missing value`);u.value=((s=l.stringToValue)==null?void 0:s.call(l,n))??n}e.push(u),n="",i="",t="protocol"}}}if(i!==""&&n!=="")throw new yi("Incomplete multiaddr");return e}function wj(r){return`/${r.flatMap(e=>{var n;if(e.value==null)return e.name;const t=_h.getProtocol(e.code);if(t==null)throw new yi(`Unknown protocol code ${e.code}`);return[e.name,((n=t.valueToString)==null?void 0:n.call(t,e.value))??e.value]}).join("/")}`}function vj(r,e,t){return r.size==null||r.size===0?0:r.size>0?r.size/8:Yt(e,t)}const _j=Symbol.for("nodejs.util.inspect.custom"),OO=Symbol.for("@multiformats/multiaddr");function xj(r){if(r==null&&(r="/"),UO(r))return r.getComponents();if(r instanceof Uint8Array)return gj(r);if(typeof r=="string")return r=r.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),r===""&&(r="/"),bj(r);if(Array.isArray(r))return r;throw new yi("Must be a string, Uint8Array, Component[], or another Multiaddr")}var nR,Oi,cu,lu,uo;let Sj=(uo=class{constructor(e="/",t={}){f(this,nR,!0);xe(this,Oi);xe(this,cu);xe(this,lu);_e(this,Oi,xj(e)),t.validate!==!1&&Ej(this)}get bytes(){return N(this,lu)==null&&_e(this,lu,yj(N(this,Oi))),N(this,lu)}toString(){return N(this,cu)==null&&_e(this,cu,wj(N(this,Oi))),N(this,cu)}toJSON(){return this.toString()}getComponents(){return[...N(this,Oi).map(e=>({...e}))]}encapsulate(e){const t=new uo(e);return new uo([...N(this,Oi),...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),n=this.toString(),i=n.lastIndexOf(t);if(i<0)throw new pJ(`Address ${this.toString()} does not contain subaddress: ${t}`);return new uo(n.slice(0,i),{validate:!1})}decapsulateCode(e){let t;for(let n=N(this,Oi).length-1;n>-1;n--)if(N(this,Oi)[n].code===e){t=n;break}return new uo(N(this,Oi).slice(0,t),{validate:!1})}equals(e){return We(this.bytes,e.bytes)}[(nR=OO,_j)](){return`Multiaddr(${this.toString()})`}},Oi=new WeakMap,cu=new WeakMap,lu=new WeakMap,uo);function Ej(r){r.getComponents().forEach(e=>{var n;const t=_h.getProtocol(e.code);e.value!=null&&((n=t.validate)==null||n.call(t,e.value))})}function UO(r){return!!(r!=null&&r[OO])}function hS(r){return new Sj(r)}function Mj(r,e){if(r.publicKey!=null||e.publicKey==null)return r;let t;r.type==="RSA"&&(t=r.toMultihash());const n=Io(e.publicKey,t);return _Y(n)}function Aj(r,e,t){const n=hc.decode(e);return ad(r,n,t)}function ad(r,e,t){const n=new Map,i=BigInt(Date.now());for(const[s,o]of e.tags.entries())o.expiry!=null&&o.expiry<i||n.set(s,o);return{...e,id:Mj(r,e),addresses:e.addresses.filter(({observed:s})=>s!=null&&s>Date.now()-t).map(({multiaddr:s,isCertified:o})=>({multiaddr:hS(s),isCertified:o??!1})),metadata:e.metadata,peerRecordEnvelope:e.peerRecordEnvelope??void 0,tags:n}}function Tj(r,e){return Cj(r.addresses,e.addresses)&&Ij(r.protocols,e.protocols)&&Pj(r.publicKey,e.publicKey)&&Rj(r.peerRecordEnvelope,e.peerRecordEnvelope)&&Dj(r.metadata,e.metadata)&&Lj(r.tags,e.tags)}function Cj(r,e){return BO(r,e,(t,n)=>!(t.isCertified!==n.isCertified||!We(t.multiaddr,n.multiaddr)))}function Ij(r,e){return BO(r,e,(t,n)=>t===n)}function Pj(r,e){return kO(r,e)}function Rj(r,e){return kO(r,e)}function Dj(r,e){return FO(r,e,(t,n)=>We(t,n))}function Lj(r,e){return FO(r,e,(t,n)=>t.value===n.value&&t.expiry===n.expiry)}function kO(r,e){return r==null&&e==null?!0:r!=null&&e!=null?We(r,e):!1}function BO(r,e,t){if(r.length!==e.length)return!1;for(let n=0;n<r.length;n++)if(!t(r[n],e[n]))return!1;return!0}function FO(r,e,t){if(r.size!==e.size)return!1;for(const[n,i]of r.entries()){const s=e.get(n);if(s==null||!t(i,s))return!1}return!0}const Ks="/",$O=new TextEncoder().encode(Ks),Pm=$O[0];class Mr{constructor(e,t){f(this,"_buf");if(typeof e=="string")this._buf=Se(e);else if(e instanceof Uint8Array)this._buf=e;else throw new Error("Invalid key, should be String of Uint8Array");if(t==null&&(t=!0),t&&this.clean(),this._buf.byteLength===0||this._buf[0]!==Pm)throw new Error("Invalid key")}toString(e="utf8"){return ae(this._buf,e)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(e){return new Mr(e.join(Ks))}static random(){return new Mr(Math.random().toString().substring(2))}static asKey(e){return e instanceof Uint8Array||typeof e=="string"?new Mr(e):typeof e.uint8Array=="function"?new Mr(e.uint8Array()):null}clean(){if((this._buf==null||this._buf.byteLength===0)&&(this._buf=$O),this._buf[0]!==Pm){const e=new Uint8Array(this._buf.byteLength+1);e.fill(Pm,0,1),e.set(this._buf,1),this._buf=e}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===Pm;)this._buf=this._buf.subarray(0,-1)}less(e){const t=this.list(),n=e.list();for(let i=0;i<t.length;i++){if(n.length<i+1)return!1;const s=t[i],o=n[i];if(s<o)return!0;if(s>o)return!1}return t.length<n.length}reverse(){return Mr.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(Ks).slice(1)}type(){return Nj(this.baseNamespace())}name(){return Oj(this.baseNamespace())}instance(e){return new Mr(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(Ks)||(e+=Ks),e+=this.type(),new Mr(e)}parent(){const e=this.list();return e.length===1?new Mr(Ks):new Mr(e.slice(0,-1).join(Ks))}child(e){return this.toString()===Ks?e:e.toString()===Ks?this:new Mr(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()===this.toString()?!1:e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()===this.toString()?!1:this.toString().startsWith(e.toString())}isTopLevel(){return this.list().length===1}concat(...e){return Mr.withNamespaces([...this.namespaces(),...Uj(e.map(t=>t.namespaces()))])}}function Nj(r){const e=r.split(":");return e.length<2?"":e.slice(0,-1).join(":")}function Oj(r){const e=r.split(":");return e[e.length-1]}function Uj(r){return[].concat(...r)}const zO="/peers/";function Rm(r){if(!bg(r)||r.type==null)throw new di("Invalid PeerId");const e=r.toCID().toString();return new Mr(`${zO}${e}`)}async function kj(r,e,t,n,i){const s=new Map;for(const o of t){if(o==null)continue;if(o.multiaddr instanceof Uint8Array&&(o.multiaddr=hS(o.multiaddr)),!UO(o.multiaddr))throw new di("Multiaddr was invalid");if(!await e(r,o.multiaddr,i))continue;const a=o.isCertified??!1,c=o.multiaddr.toString(),l=s.get(c);l!=null?o.isCertified=l.isCertified||a:s.set(c,{multiaddr:o.multiaddr,isCertified:a})}return[...s.values()].sort((o,a)=>o.multiaddr.toString().localeCompare(a.multiaddr.toString())).map(({isCertified:o,multiaddr:a})=>{var l;const c=(l=a.getComponents().find(u=>u.code===LO))==null?void 0:l.value;return r.equals(c)&&(a=a.decapsulate(hS(`/p2p/${r}`))),{isCertified:o,multiaddr:a.bytes}})}async function ww(r,e,t,n){var d,m;if(e==null)throw new di("Invalid PeerData");if(e.publicKey!=null&&r.publicKey!=null&&!e.publicKey.equals(r.publicKey))throw new di("publicKey bytes do not match peer id publicKey bytes");const i=(d=n.existingPeer)==null?void 0:d.peer;if(i!=null&&!r.equals(i.id))throw new di("peer id did not match existing peer id");let s=(i==null?void 0:i.addresses)??[],o=new Set((i==null?void 0:i.protocols)??[]),a=(i==null?void 0:i.metadata)??new Map,c=(i==null?void 0:i.tags)??new Map,l=i==null?void 0:i.peerRecordEnvelope;if(t==="patch"){if((e.multiaddrs!=null||e.addresses!=null)&&(s=[],e.multiaddrs!=null&&s.push(...e.multiaddrs.map(p=>({isCertified:!1,multiaddr:p}))),e.addresses!=null&&s.push(...e.addresses)),e.protocols!=null&&(o=new Set(e.protocols)),e.metadata!=null){const p=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);a=Dm(p,{validate:W2})}if(e.tags!=null){const p=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags);c=Dm(p,{validate:q2,map:K2})}e.peerRecordEnvelope!=null&&(l=e.peerRecordEnvelope)}if(t==="merge"){if(e.multiaddrs!=null&&s.push(...e.multiaddrs.map(p=>({isCertified:!1,multiaddr:p}))),e.addresses!=null&&s.push(...e.addresses),e.protocols!=null&&(o=new Set([...o,...e.protocols])),e.metadata!=null){const p=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);for(const[b,g]of p)g==null?a.delete(b):a.set(b,g);a=Dm([...a.entries()],{validate:W2})}if(e.tags!=null){const p=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags),b=new Map(c);for(const[g,y]of p)y==null?b.delete(g):b.set(g,y);c=Dm([...b.entries()],{validate:q2,map:K2})}e.peerRecordEnvelope!=null&&(l=e.peerRecordEnvelope)}let u;(i==null?void 0:i.id.publicKey)!=null?u=Ms(i.id.publicKey):e.publicKey!=null?u=Ms(e.publicKey):r.publicKey!=null&&(u=Ms(r.publicKey));const h={addresses:await kj(r,n.addressFilter??(async()=>!0),s,(m=n.existingPeer)==null?void 0:m.peerPB.addresses,n),protocols:[...o.values()].sort((p,b)=>p.localeCompare(b)),metadata:a,tags:c,publicKey:u,peerRecordEnvelope:l};return h.addresses.forEach(p=>{var b,g,y;p.observed=((y=(g=(b=n.existingPeer)==null?void 0:b.peerPB.addresses)==null?void 0:g.find(v=>We(v.multiaddr,v.multiaddr)))==null?void 0:y.observed)??Date.now()}),r.type!=="RSA"&&delete h.publicKey,h}function Dm(r,e){var n;const t=new Map;for(const[i,s]of r)s!=null&&e.validate(i,s);for(const[i,s]of r.sort(([o],[a])=>o.localeCompare(a)))s!=null&&t.set(i,((n=e.map)==null?void 0:n.call(e,i,s))??s);return t}function W2(r,e){if(typeof r!="string")throw new di("Metadata key must be a string");if(!(e instanceof Uint8Array))throw new di("Metadata value must be a Uint8Array")}function q2(r,e){if(typeof r!="string")throw new di("Tag name must be a string");if(e.value!=null){if(parseInt(`${e.value}`,10)!==e.value)throw new di("Tag value must be an integer");if(e.value<0||e.value>100)throw new di("Tag value must be between 0-100")}if(e.ttl!=null){if(parseInt(`${e.ttl}`,10)!==e.ttl)throw new di("Tag ttl must be an integer");if(e.ttl<0)throw new di("Tag ttl must be between greater than 0")}}function K2(r,e){let t;e.expiry!=null&&(t=e.expiry),e.ttl!=null&&(t=BigInt(Date.now()+Number(e.ttl)));const n={value:e.value??0};return t!=null&&(n.expiry=t),n}function VO(r){const e=r.toString().split("/")[2],t=Ze.parse(e,Rn);return fO(t)}function vw(r,e,t){const n=VO(r);return Aj(n,e,t)}function Bj(r,e){return{prefix:zO,filters:(r.filters??[]).map(t=>({key:n,value:i})=>t(vw(n,i,e))),orders:(r.orders??[]).map(t=>(n,i)=>t(vw(n.key,n.value,e),vw(i.key,i.value,e)))}}var Gr,wg,vg,_g;class Fj{constructor(e,t={}){xe(this,Gr);f(this,"peerId");f(this,"datastore");f(this,"locks");f(this,"addressFilter");f(this,"log");f(this,"maxAddressAge");f(this,"maxPeerAge");this.log=e.logger.forComponent("libp2p:peer-store"),this.peerId=e.peerId,this.datastore=e.datastore,this.addressFilter=t.addressFilter,this.locks=pY({name:"libp2p_peer_store_locks",metrics:e.metrics}),this.maxAddressAge=t.maxAddressAge??dJ,this.maxPeerAge=t.maxPeerAge??fJ}getLock(e){let t=this.locks.get(e);return t==null&&(t={refs:0,lock:hJ({name:e.toString(),singleProcess:!0})},this.locks.set(e,t)),t.refs++,t}maybeRemoveLock(e,t){t.refs--,t.refs===0&&(t.lock.finalize(),this.locks.delete(e))}async getReadLock(e,t){const n=this.getLock(e);try{const i=await n.lock.readLock(t);return()=>{i(),this.maybeRemoveLock(e,n)}}catch(i){throw this.maybeRemoveLock(e,n),i}}async getWriteLock(e,t){const n=this.getLock(e);try{const i=await n.lock.writeLock(t);return()=>{i(),this.maybeRemoveLock(e,n)}}catch(i){throw this.maybeRemoveLock(e,n),i}}async has(e,t){try{return await this.load(e,t),!0}catch(n){if(n.name!=="NotFoundError")throw n}return!1}async delete(e,t){this.peerId.equals(e)||await this.datastore.delete(Rm(e),t)}async load(e,t){const n=Rm(e),i=await this.datastore.get(n,t),s=hc.decode(i);if(be(this,Gr,_g).call(this,e,s))throw await this.datastore.delete(n,t),new D2;return ad(e,s,this.peerId.equals(e)?1/0:this.maxAddressAge)}async save(e,t,n){const i=await be(this,Gr,wg).call(this,e,n),s=await ww(e,t,"patch",{...n,addressFilter:this.addressFilter});return be(this,Gr,vg).call(this,e,s,i)}async patch(e,t,n){const i=await be(this,Gr,wg).call(this,e,n),s=await ww(e,t,"patch",{...n,addressFilter:this.addressFilter,existingPeer:i});return be(this,Gr,vg).call(this,e,s,i)}async merge(e,t,n){const i=await be(this,Gr,wg).call(this,e,n),s=await ww(e,t,"merge",{addressFilter:this.addressFilter,existingPeer:i});return be(this,Gr,vg).call(this,e,s,i)}async*all(e){for await(const{key:t,value:n}of this.datastore.query(Bj(e??{},this.maxAddressAge),e)){const i=VO(t);if(i.equals(this.peerId))continue;const s=hc.decode(n);if(be(this,Gr,_g).call(this,i,s)){await this.datastore.delete(t,e);continue}yield ad(i,s,this.peerId.equals(i)?1/0:this.maxAddressAge)}}}Gr=new WeakSet,wg=async function(e,t){try{const n=Rm(e),i=await this.datastore.get(n,t),s=hc.decode(i);if(be(this,Gr,_g).call(this,e,s))throw await this.datastore.delete(n,t),new D2;return{peerPB:s,peer:ad(e,s,this.maxAddressAge)}}catch(n){n.name!=="NotFoundError"&&this.log.error("invalid peer data found in peer store - %e",n)}},vg=async function(e,t,n,i){t.updated=Date.now();const s=hc.encode(t);return await this.datastore.put(Rm(e),s,i),{peer:ad(e,t,this.maxAddressAge),previous:n==null?void 0:n.peer,updated:n==null||!Tj(t,n.peerPB)}},_g=function(e,t){if(t.updated==null)return!0;if(this.peerId.equals(e))return!1;const n=t.updated<Date.now()-this.maxPeerAge,i=Date.now()-this.maxAddressAge,s=t.addresses.filter(o=>o.observed!=null&&o.observed>i);return n&&s.length===0};var rR,uu,xg;rR=Symbol.toStringTag;class $j{constructor(e,t={}){xe(this,uu);f(this,"store");f(this,"events");f(this,"peerId");f(this,"log");f(this,rR,"@libp2p/peer-store");this.log=e.logger.forComponent("libp2p:peer-store"),this.events=e.events,this.peerId=e.peerId,this.store=new Fj(e,t)}async forEach(e,t){for await(const n of this.store.all(t))e(n)}async all(e){return uS(this.store.all(e))}async delete(e,t){const n=await this.store.getReadLock(e,t);try{await this.store.delete(e,t)}finally{n()}}async has(e,t){const n=await this.store.getReadLock(e,t);try{return await this.store.has(e,t)}finally{this.log.trace("has release read lock"),n==null||n()}}async get(e,t){const n=await this.store.getReadLock(e,t);try{return await this.store.load(e,t)}finally{n==null||n()}}async getInfo(e,t){const n=await this.get(e,t);return{id:n.id,multiaddrs:n.addresses.map(({multiaddr:i})=>i)}}async save(e,t,n){const i=await this.store.getWriteLock(e,n);try{const s=await this.store.save(e,t,n);return be(this,uu,xg).call(this,e,s),s.peer}finally{i==null||i()}}async patch(e,t,n){const i=await this.store.getWriteLock(e,n);try{const s=await this.store.patch(e,t,n);return be(this,uu,xg).call(this,e,s),s.peer}finally{i==null||i()}}async merge(e,t,n){const i=await this.store.getWriteLock(e,n);try{const s=await this.store.merge(e,t,n);return be(this,uu,xg).call(this,e,s),s.peer}finally{i==null||i()}}async consumePeerRecord(e,t,n){const i=bg(t)?t:bg(t==null?void 0:t.expectedPeer)?t.expectedPeer:void 0,s=bg(t)||t===void 0?n:t,o=await Fc.openAndCertify(e,xo.DOMAIN,s),a=fO(o.publicKey.toCID());if((i==null?void 0:i.equals(a))===!1)return this.log("envelope peer id was not the expected peer id - expected: %p received: %p",i,a),!1;const c=xo.createFromProtobuf(o.payload);let l;try{l=await this.get(a,s)}catch(u){if(u.name!=="NotFoundError")throw u}if((l==null?void 0:l.peerRecordEnvelope)!=null){const u=Fc.createFromProtobuf(l.peerRecordEnvelope),h=xo.createFromProtobuf(u.payload);if(h.seqNumber>=c.seqNumber)return this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d",h.seqNumber,c.seqNumber),!1}return await this.patch(c.peerId,{peerRecordEnvelope:e,addresses:c.multiaddrs.map(u=>({isCertified:!0,multiaddr:u}))},s),!0}}uu=new WeakSet,xg=function(e,t){t.updated&&(this.peerId.equals(e)?this.events.safeDispatchEvent("self:peer:update",{detail:t}):this.events.safeDispatchEvent("peer:update",{detail:t}))};function zj(r,e={}){return new $j(r,e)}var Qv;let bi=(Qv=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidMultiaddrError")}},f(Qv,"name","InvalidMultiaddrError"),Qv);var e_;let _f=(e_=class extends Error{constructor(){super(...arguments);f(this,"name","ValidationError")}},f(e_,"name","ValidationError"),e_);var t_;let Vj=(t_=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidParametersError")}},f(t_,"name","InvalidParametersError"),t_);var n_;let Hj=(n_=class extends Error{constructor(){super(...arguments);f(this,"name","UnknownProtocolError")}},f(n_,"name","UnknownProtocolError"),n_);const dS=4,Gj=6,Wj=273,qj=33,fS=41,Kj=42,Xj=43,Yj=53,Zj=54,Jj=55,jj=56,Qj=132,eQ=301,tQ=302,nQ=400,Is=421,rQ=444,iQ=445,sQ=446,oQ=447,HO=448,pS=449,aQ=454,cQ=460,lQ=461,uQ=465,hQ=466,dQ=480,fQ=481,pQ=443,mQ=477,gQ=478,yQ=479,bQ=277,wQ=275,vQ=276,_Q=280,xQ=281,SQ=290,EQ=777;function X2(r){return e=>ae(e,r)}function Y2(r){return e=>Se(e,r)}function cd(r){return new DataView(r.buffer).getUint16(r.byteOffset).toString()}function kl(r){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof r=="string"?parseInt(r):r),new Uint8Array(e)}function MQ(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=Se(e[0],"base32"),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=kl(n);return ut([t,i],t.length+i.length)}function AQ(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=Rn.decode(`b${e[0]}`),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=kl(n);return ut([t,i],t.length+i.length)}function Z2(r){const e=r.subarray(0,r.length-2),t=r.subarray(r.length-2),n=ae(e,"base32"),i=cd(t);return`${n}:${i}`}const GO=function(r){r=r.toString().trim();const e=new Uint8Array(4);return r.split(/\./g).forEach((t,n)=>{const i=parseInt(t,10);if(isNaN(i)||i<0||i>255)throw new bi("Invalid byte value in IP address");e[n]=i}),e},TQ=function(r){let e=0;r=r.toString().trim();const t=r.split(":",8);let n;for(n=0;n<t.length;n++){const s=$t(t[n]);let o;s&&(o=GO(t[n]),t[n]=ae(o.subarray(0,2),"base16")),o!=null&&++n<8&&t.splice(n,0,ae(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(n=0;n<t.length&&t[n]!=="";n++);const s=[n,1];for(n=9-t.length;n>0;n--)s.push("0");t.splice.apply(t,s)}const i=new Uint8Array(e+16);for(n=0;n<t.length;n++){t[n]===""&&(t[n]="0");const s=parseInt(t[n],16);if(isNaN(s)||s<0||s>65535)throw new bi("Invalid byte value in IP address");i[e++]=s>>8&255,i[e++]=s&255}return i},CQ=function(r){if(r.byteLength!==4)throw new bi("IPv4 address was incorrect length");const e=[];for(let t=0;t<r.byteLength;t++)e.push(r[t]);return e.join(".")},IQ=function(r){if(r.byteLength!==16)throw new bi("IPv6 address was incorrect length");const e=[];for(let n=0;n<r.byteLength;n+=2){const i=r[n],s=r[n+1],o=`${i.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const n=new URL(`http://[${t}]`);return n.hostname.substring(1,n.hostname.length-1)}catch{throw new bi(`Invalid IPv6 address "${t}"`)}};function PQ(r){try{const e=new URL(`http://[${r}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new bi(`Invalid IPv6 address "${r}"`)}}const _w=Object.values(oi).map(r=>r.decoder),RQ=(function(){let r=_w[0].or(_w[1]);return _w.slice(2).forEach(e=>r=r.or(e)),r})();function DQ(r){return RQ.decode(r)}function LQ(r){return e=>r.encoder.encode(e)}function NQ(r){if(parseInt(r).toString()!==r)throw new _f("Value must be an integer")}function OQ(r){if(r<0)throw new _f("Value must be a positive integer, or zero")}function UQ(r){return e=>{if(e>r)throw new _f(`Value must be smaller than or equal to ${r}`)}}function kQ(...r){return e=>{for(const t of r)t(e)}}const Lm=kQ(NQ,OQ,UQ(65535)),er=-1;let BQ=class{constructor(){f(this,"protocolsByCode",new Map);f(this,"protocolsByName",new Map)}getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new Hj(`Protocol ${e} was unknown`);return t}addProtocol(e){var t;this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),(t=e.aliases)==null||t.forEach(n=>{this.protocolsByName.set(n,e)})}removeProtocol(e){var n;const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),(n=t.aliases)==null||n.forEach(i=>{this.protocolsByName.delete(i)}))}};const xh=new BQ,FQ=[{code:dS,name:"ip4",size:32,valueToBytes:GO,bytesToValue:CQ,validate:r=>{if(!$t(r))throw new _f(`Invalid IPv4 address "${r}"`)}},{code:Gj,name:"tcp",size:16,valueToBytes:kl,bytesToValue:cd,validate:Lm},{code:Wj,name:"udp",size:16,valueToBytes:kl,bytesToValue:cd,validate:Lm},{code:qj,name:"dccp",size:16,valueToBytes:kl,bytesToValue:cd,validate:Lm},{code:fS,name:"ip6",size:128,valueToBytes:TQ,bytesToValue:IQ,stringToValue:PQ,validate:r=>{if(!Ai(r))throw new _f(`Invalid IPv6 address "${r}"`)}},{code:Kj,name:"ip6zone",size:er},{code:Xj,name:"ipcidr",size:8,bytesToValue:X2("base10"),valueToBytes:Y2("base10")},{code:Yj,name:"dns",size:er},{code:Zj,name:"dns4",size:er},{code:Jj,name:"dns6",size:er},{code:jj,name:"dnsaddr",size:er},{code:Qj,name:"sctp",size:16,valueToBytes:kl,bytesToValue:cd,validate:Lm},{code:eQ,name:"udt"},{code:tQ,name:"utp"},{code:nQ,name:"unix",size:er,stringToValue:r=>decodeURIComponent(r),valueToString:r=>encodeURIComponent(r)},{code:Is,name:"p2p",aliases:["ipfs"],size:er,bytesToValue:X2("base58btc"),valueToBytes:r=>r.startsWith("Q")||r.startsWith("1")?Y2("base58btc")(r):Ze.parse(r).multihash.bytes},{code:rQ,name:"onion",size:96,bytesToValue:Z2,valueToBytes:MQ},{code:iQ,name:"onion3",size:296,bytesToValue:Z2,valueToBytes:AQ},{code:sQ,name:"garlic64",size:er},{code:oQ,name:"garlic32",size:er},{code:HO,name:"tls"},{code:pS,name:"sni",size:er},{code:aQ,name:"noise"},{code:cQ,name:"quic"},{code:lQ,name:"quic-v1"},{code:uQ,name:"webtransport"},{code:hQ,name:"certhash",size:er,bytesToValue:LQ(Mi),valueToBytes:DQ},{code:dQ,name:"http"},{code:fQ,name:"http-path",size:er,stringToValue:r=>`/${decodeURIComponent(r)}`,valueToString:r=>encodeURIComponent(r.substring(1))},{code:pQ,name:"https"},{code:mQ,name:"ws"},{code:gQ,name:"wss"},{code:yQ,name:"p2p-websocket-star"},{code:bQ,name:"p2p-stardust"},{code:wQ,name:"p2p-webrtc-star"},{code:vQ,name:"p2p-webrtc-direct"},{code:_Q,name:"webrtc-direct"},{code:xQ,name:"webrtc"},{code:SQ,name:"p2p-circuit"},{code:EQ,name:"memory",size:er}];FQ.forEach(r=>{xh.addProtocol(r)});function $Q(r){var n;const e=[];let t=0;for(;t<r.length;){const i=Yt(r,t),s=xh.getProtocol(i),o=Ue(i),a=GQ(s,r,t+o);let c=0;a>0&&s.size===er&&(c=Ue(a));const l=o+c+a,u={code:i,name:s.name,bytes:r.subarray(t,t+l)};if(a>0){const h=t+o+c,d=r.subarray(h,h+a);u.value=((n=s.bytesToValue)==null?void 0:n.call(s,d))??ae(d)}e.push(u),t+=l}return e}function zQ(r){var n;let e=0;const t=[];for(const i of r){if(i.bytes==null){const s=xh.getProtocol(i.code),o=Ue(i.code);let a,c=0,l=0;i.value!=null&&(a=((n=s.valueToBytes)==null?void 0:n.call(s,i.value))??Se(i.value),c=a.byteLength,s.size===er&&(l=Ue(c)));const u=new Uint8Array(o+l+c);let h=0;sn(i.code,u,h),h+=o,a!=null&&(s.size===er&&(sn(c,u,h),h+=l),u.set(a,h)),i.bytes=u}t.push(i.bytes),e+=i.bytes.byteLength}return ut(t,e)}function VQ(r){var s;if(r.charAt(0)!=="/")throw new bi('String multiaddr must start with "/"');const e=[];let t="protocol",n="",i="";for(let o=1;o<r.length;o++){const a=r.charAt(o);a!=="/"&&(t==="protocol"?i+=r.charAt(o):n+=r.charAt(o));const c=o===r.length-1;if(a==="/"||c){const l=xh.getProtocol(i);if(t==="protocol"){if(l.size==null||l.size===0){e.push({code:l.code,name:l.name}),n="",i="",t="protocol";continue}else if(c)throw new bi(`Component ${i} was missing value`);t="value"}else if(t==="value"){const u={code:l.code,name:l.name};if(l.size!=null&&l.size!==0){if(n==="")throw new bi(`Component ${i} was missing value`);u.value=((s=l.stringToValue)==null?void 0:s.call(l,n))??n}e.push(u),n="",i="",t="protocol"}}}if(i!==""&&n!=="")throw new bi("Incomplete multiaddr");return e}function HQ(r){return`/${r.flatMap(e=>{var n;if(e.value==null)return e.name;const t=xh.getProtocol(e.code);if(t==null)throw new bi(`Unknown protocol code ${e.code}`);return[e.name,((n=t.valueToString)==null?void 0:n.call(t,e.value))??e.value]}).join("/")}`}function GQ(r,e,t){return r.size==null||r.size===0?0:r.size>0?r.size/8:Yt(e,t)}const WQ=Symbol.for("nodejs.util.inspect.custom"),WO=Symbol.for("@multiformats/multiaddr");function qQ(r){if(r==null&&(r="/"),eM(r))return r.getComponents();if(r instanceof Uint8Array)return $Q(r);if(typeof r=="string")return r=r.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),r===""&&(r="/"),VQ(r);if(Array.isArray(r))return r;throw new bi("Must be a string, Uint8Array, Component[], or another Multiaddr")}var iR,Ui,hu,du,ho;let KQ=(ho=class{constructor(e="/",t={}){f(this,iR,!0);xe(this,Ui);xe(this,hu);xe(this,du);_e(this,Ui,qQ(e)),t.validate!==!1&&XQ(this)}get bytes(){return N(this,du)==null&&_e(this,du,zQ(N(this,Ui))),N(this,du)}toString(){return N(this,hu)==null&&_e(this,hu,HQ(N(this,Ui))),N(this,hu)}toJSON(){return this.toString()}getComponents(){return[...N(this,Ui).map(e=>({...e}))]}encapsulate(e){const t=new ho(e);return new ho([...N(this,Ui),...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),n=this.toString(),i=n.lastIndexOf(t);if(i<0)throw new Vj(`Address ${this.toString()} does not contain subaddress: ${t}`);return new ho(n.slice(0,i),{validate:!1})}decapsulateCode(e){let t;for(let n=N(this,Ui).length-1;n>-1;n--)if(N(this,Ui)[n].code===e){t=n;break}return new ho(N(this,Ui).slice(0,t),{validate:!1})}equals(e){return We(this.bytes,e.bytes)}[(iR=WO,WQ)](){return`Multiaddr(${this.toString()})`}},Ui=new WeakMap,hu=new WeakMap,du=new WeakMap,ho);function XQ(r){r.getComponents().forEach(e=>{var n;const t=xh.getProtocol(e.code);e.value!=null&&((n=t.validate)==null||n.call(t,e.value))})}function eM(r){return!!(r!=null&&r[WO])}function pr(r){return new KQ(r)}const ql=class ql extends Error{constructor(t="Not Found"){super(t);f(this,"name",ql.name);f(this,"code",ql.code)}};f(ql,"name","NotFoundError"),f(ql,"code","ERR_NOT_FOUND");let mS=ql;function YQ(r){return r[Symbol.asyncIterator]!=null}function J2(r){if(YQ(r))return(async()=>{for await(const e of r);})();for(const e of r);}function ZQ(r){const[e,t]=r[Symbol.asyncIterator]!=null?[r[Symbol.asyncIterator](),Symbol.asyncIterator]:[r[Symbol.iterator](),Symbol.iterator],n=[];return{peek:()=>e.next(),push:i=>{n.push(i)},next:()=>n.length>0?{done:!1,value:n.shift()}:e.next(),[t](){return this}}}function JQ(r){return r[Symbol.asyncIterator]!=null}function Cl(r,e){let t=0;if(JQ(r))return(async function*(){for await(const c of r)await e(c,t++)&&(yield c)})();const n=ZQ(r),{value:i,done:s}=n.next();if(s===!0)return(function*(){})();const o=e(i,t++);if(typeof o.then=="function")return(async function*(){await o&&(yield i);for(const c of n)await e(c,t++)&&(yield c)})();const a=e;return(function*(){o===!0&&(yield i);for(const c of n)a(c,t++)&&(yield c)})()}function jQ(r){return r[Symbol.asyncIterator]!=null}function j2(r,e){return jQ(r)?(async function*(){yield*(await uS(r)).sort(e)})():(function*(){yield*uS(r).sort(e)})()}function QQ(r){return r[Symbol.asyncIterator]!=null}function Q2(r,e){return QQ(r)?(async function*(){let t=0;if(!(e<1)){for await(const n of r)if(yield n,t++,t===e)return}})():(function*(){let t=0;if(!(e<1)){for(const n of r)if(yield n,t++,t===e)return}})()}class eee{put(e,t,n){return Promise.reject(new Error(".put is not implemented"))}get(e,t){return Promise.reject(new Error(".get is not implemented"))}has(e,t){return Promise.reject(new Error(".has is not implemented"))}delete(e,t){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(e,t={}){for await(const{key:n,value:i}of e)await this.put(n,i,t),yield n}async*getMany(e,t={}){for await(const n of e)yield{key:n,value:await this.get(n,t)}}async*deleteMany(e,t={}){for await(const n of e)await this.delete(n,t),yield n}batch(){let e=[],t=[];return{put(n,i){e.push({key:n,value:i})},delete(n){t.push(n)},commit:async n=>{await J2(this.putMany(e,n)),e=[],await J2(this.deleteMany(t,n)),t=[]}}}async*_all(e,t){throw new Error("._all is not implemented")}async*_allKeys(e,t){throw new Error("._allKeys is not implemented")}query(e,t){let n=this._all(e,t);if(e.prefix!=null){const i=e.prefix;n=Cl(n,s=>s.key.toString().startsWith(i))}if(Array.isArray(e.filters)&&(n=e.filters.reduce((i,s)=>Cl(i,s),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((i,s)=>j2(i,s),n)),e.offset!=null){let i=0;const s=e.offset;n=Cl(n,()=>i++>=s)}return e.limit!=null&&(n=Q2(n,e.limit)),n}queryKeys(e,t){let n=this._allKeys(e,t);if(e.prefix!=null){const i=e.prefix;n=Cl(n,s=>s.toString().startsWith(i))}if(Array.isArray(e.filters)&&(n=e.filters.reduce((i,s)=>Cl(i,s),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((i,s)=>j2(i,s),n)),e.offset!=null){const i=e.offset;let s=0;n=Cl(n,()=>s++>=i)}return e.limit!=null&&(n=Q2(n,e.limit)),n}}class tee extends eee{constructor(){super();f(this,"data");this.data=new Map}put(t,n,i){var s;return(s=i==null?void 0:i.signal)==null||s.throwIfAborted(),this.data.set(t.toString(),n),t}get(t,n){var s;(s=n==null?void 0:n.signal)==null||s.throwIfAborted();const i=this.data.get(t.toString());if(i==null)throw new mS;return i}has(t,n){var i;return(i=n==null?void 0:n.signal)==null||i.throwIfAborted(),this.data.has(t.toString())}delete(t,n){var i;(i=n==null?void 0:n.signal)==null||i.throwIfAborted(),this.data.delete(t.toString())}*_all(t,n){var i,s;(i=n==null?void 0:n.signal)==null||i.throwIfAborted();for(const[o,a]of this.data.entries())yield{key:new Mr(o),value:a},(s=n==null?void 0:n.signal)==null||s.throwIfAborted()}*_allKeys(t,n){var i,s;(i=n==null?void 0:n.signal)==null||i.throwIfAborted();for(const o of this.data.keys())yield new Mr(o),(s=n==null?void 0:n.signal)==null||s.throwIfAborted()}}var r_;let ju=(r_=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidMultiaddrError")}},f(r_,"name","InvalidMultiaddrError"),r_);var i_;let xf=(i_=class extends Error{constructor(){super(...arguments);f(this,"name","ValidationError")}},f(i_,"name","ValidationError"),i_);var s_;let nee=(s_=class extends Error{constructor(){super(...arguments);f(this,"name","UnknownProtocolError")}},f(s_,"name","UnknownProtocolError"),s_);const qO=4,jl=6,KO=273,ree=33,XO=41,YO=42,tM=43,ZO=53,JO=54,jO=55,QO=56,iee=132,see=301,oee=302,eU=400,Dt=421,aee=444,cee=445,lee=446,uee=447,Nd=448,tU=449,hee=454,nU=460,rU=461,iU=465,Sf=466,Ql=480,dee=481,gS=443,nM=477,sU=478,fee=479,pee=277,mee=275,gee=276,oU=280,Od=281,rM=290,aU=777;function eC(r){return e=>ae(e,r)}function tC(r){return e=>Se(e,r)}function ld(r){return new DataView(r.buffer).getUint16(r.byteOffset).toString()}function Bl(r){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof r=="string"?parseInt(r):r),new Uint8Array(e)}function yee(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=Se(e[0],"base32"),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=Bl(n);return ut([t,i],t.length+i.length)}function bee(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=Rn.decode(`b${e[0]}`),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=Bl(n);return ut([t,i],t.length+i.length)}function nC(r){const e=r.subarray(0,r.length-2),t=r.subarray(r.length-2),n=ae(e,"base32"),i=ld(t);return`${n}:${i}`}const cU=function(r){r=r.toString().trim();const e=new Uint8Array(4);return r.split(/\./g).forEach((t,n)=>{const i=parseInt(t,10);if(isNaN(i)||i<0||i>255)throw new ju("Invalid byte value in IP address");e[n]=i}),e},wee=function(r){let e=0;r=r.toString().trim();const t=r.split(":",8);let n;for(n=0;n<t.length;n++){const s=$t(t[n]);let o;s&&(o=cU(t[n]),t[n]=ae(o.subarray(0,2),"base16")),o!=null&&++n<8&&t.splice(n,0,ae(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(n=0;n<t.length&&t[n]!=="";n++);const s=[n,1];for(n=9-t.length;n>0;n--)s.push("0");t.splice.apply(t,s)}const i=new Uint8Array(e+16);for(n=0;n<t.length;n++){t[n]===""&&(t[n]="0");const s=parseInt(t[n],16);if(isNaN(s)||s<0||s>65535)throw new ju("Invalid byte value in IP address");i[e++]=s>>8&255,i[e++]=s&255}return i},vee=function(r){if(r.byteLength!==4)throw new ju("IPv4 address was incorrect length");const e=[];for(let t=0;t<r.byteLength;t++)e.push(r[t]);return e.join(".")},_ee=function(r){if(r.byteLength!==16)throw new ju("IPv6 address was incorrect length");const e=[];for(let n=0;n<r.byteLength;n+=2){const i=r[n],s=r[n+1],o=`${i.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const n=new URL(`http://[${t}]`);return n.hostname.substring(1,n.hostname.length-1)}catch{throw new ju(`Invalid IPv6 address "${t}"`)}};function xee(r){try{const e=new URL(`http://[${r}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new ju(`Invalid IPv6 address "${r}"`)}}const xw=Object.values(oi).map(r=>r.decoder),See=(function(){let r=xw[0].or(xw[1]);return xw.slice(2).forEach(e=>r=r.or(e)),r})();function Eee(r){return See.decode(r)}function Mee(r){return e=>r.encoder.encode(e)}function Aee(r){if(parseInt(r).toString()!==r)throw new xf("Value must be an integer")}function Tee(r){if(r<0)throw new xf("Value must be a positive integer, or zero")}function Cee(r){return e=>{if(e>r)throw new xf(`Value must be smaller than or equal to ${r}`)}}function Iee(...r){return e=>{for(const t of r)t(e)}}const Nm=Iee(Aee,Tee,Cee(65535)),Yr=-1;let Pee=class{constructor(){f(this,"protocolsByCode",new Map);f(this,"protocolsByName",new Map)}getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new nee(`Protocol ${e} was unknown`);return t}addProtocol(e){var t;this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),(t=e.aliases)==null||t.forEach(n=>{this.protocolsByName.set(n,e)})}removeProtocol(e){var n;const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),(n=t.aliases)==null||n.forEach(i=>{this.protocolsByName.delete(i)}))}};const Ree=new Pee,Dee=[{code:qO,name:"ip4",size:32,valueToBytes:cU,bytesToValue:vee,validate:r=>{if(!$t(r))throw new xf(`Invalid IPv4 address "${r}"`)}},{code:jl,name:"tcp",size:16,valueToBytes:Bl,bytesToValue:ld,validate:Nm},{code:KO,name:"udp",size:16,valueToBytes:Bl,bytesToValue:ld,validate:Nm},{code:ree,name:"dccp",size:16,valueToBytes:Bl,bytesToValue:ld,validate:Nm},{code:XO,name:"ip6",size:128,valueToBytes:wee,bytesToValue:_ee,stringToValue:xee,validate:r=>{if(!Ai(r))throw new xf(`Invalid IPv6 address "${r}"`)}},{code:YO,name:"ip6zone",size:Yr},{code:tM,name:"ipcidr",size:8,bytesToValue:eC("base10"),valueToBytes:tC("base10")},{code:ZO,name:"dns",size:Yr},{code:JO,name:"dns4",size:Yr},{code:jO,name:"dns6",size:Yr},{code:QO,name:"dnsaddr",size:Yr},{code:iee,name:"sctp",size:16,valueToBytes:Bl,bytesToValue:ld,validate:Nm},{code:see,name:"udt"},{code:oee,name:"utp"},{code:eU,name:"unix",size:Yr,stringToValue:r=>decodeURIComponent(r),valueToString:r=>encodeURIComponent(r)},{code:Dt,name:"p2p",aliases:["ipfs"],size:Yr,bytesToValue:eC("base58btc"),valueToBytes:r=>r.startsWith("Q")||r.startsWith("1")?tC("base58btc")(r):Ze.parse(r).multihash.bytes},{code:aee,name:"onion",size:96,bytesToValue:nC,valueToBytes:yee},{code:cee,name:"onion3",size:296,bytesToValue:nC,valueToBytes:bee},{code:lee,name:"garlic64",size:Yr},{code:uee,name:"garlic32",size:Yr},{code:Nd,name:"tls"},{code:tU,name:"sni",size:Yr},{code:hee,name:"noise"},{code:nU,name:"quic"},{code:rU,name:"quic-v1"},{code:iU,name:"webtransport"},{code:Sf,name:"certhash",size:Yr,bytesToValue:Mee(Mi),valueToBytes:Eee},{code:Ql,name:"http"},{code:dee,name:"http-path",size:Yr,stringToValue:r=>`/${decodeURIComponent(r)}`,valueToString:r=>encodeURIComponent(r.substring(1))},{code:gS,name:"https"},{code:nM,name:"ws"},{code:sU,name:"wss"},{code:fee,name:"p2p-websocket-star"},{code:pee,name:"p2p-stardust"},{code:mee,name:"p2p-webrtc-star"},{code:gee,name:"p2p-webrtc-direct"},{code:oU,name:"webrtc-direct"},{code:Od,name:"webrtc"},{code:rM,name:"p2p-circuit"},{code:aU,name:"memory",size:Yr}];Dee.forEach(r=>{Ree.addProtocol(r)});const Nt=r=>({match:e=>{const t=e[0];return t==null||t.code!==r||t.value!=null?!1:e.slice(1)}}),He=(r,e)=>({match:t=>{const n=t[0];return(n==null?void 0:n.code)!==r||n.value==null||e!=null&&n.value!==e?!1:t.slice(1)}}),Lee=r=>({match:e=>r.match(e)===!1?e:!1}),dt=r=>({match:e=>{const t=r.match(e);return t===!1?e:t}}),Rr=(...r)=>({match:e=>{let t;for(const n of r){const i=n.match(e);i!==!1&&(t==null||i.length<t.length)&&(t=i)}return t??!1}}),At=(...r)=>({match:e=>{for(const t of r){const n=t.match(e);if(n===!1)return!1;e=n}return e}});function Ot(...r){function e(i){if(i==null)return!1;let s=i.getComponents();for(const o of r){const a=o.match(s);if(a===!1)return!1;s=a}return s}function t(i){return e(i)!==!1}function n(i){const s=e(i);return s===!1?!1:s.length===0}return{matchers:r,matches:t,exactMatch:n}}const Nee=He(Dt),Oee=Ot(Nee),B0=He(JO),F0=He(jO),$0=He(QO),iM=He(ZO);Ot(B0,dt(He(Dt)));Ot(F0,dt(He(Dt)));Ot($0,dt(He(Dt)));Ot(Rr(iM,$0,B0,F0),dt(He(Dt)));const lU=At(He(qO),dt(He(tM))),uU=At(dt(He(YO)),He(XO),dt(He(tM))),sM=Rr(lU,uU),$c=Rr(sM,iM,B0,F0,$0),Uee=Ot(Rr(sM,At(Rr(iM,$0,B0,F0),dt(He(Dt))))),rC=Ot(lU),iC=Ot(uU);Ot(sM);const oM=At($c,He(jl)),up=At($c,He(KO)),uy=Ot(At(oM,dt(He(Dt))));Ot(up);const aM=At(up,Nt(nU),dt(He(Dt))),z0=At(up,Nt(rU),dt(He(Dt))),kee=Rr(aM,z0);Ot(aM);const Bee=Ot(z0),yS=Rr($c,oM,up,aM,z0),hU=Rr(At(yS,Nt(nM),dt(He(Dt)))),Ef=Ot(hU),dU=Rr(At(yS,Nt(sU),dt(He(Dt))),At(yS,Nt(Nd),dt(He(tU)),Nt(nM),dt(He(Dt)))),hy=Ot(dU),fU=At(up,Nt(oU),dt(He(Sf)),dt(He(Sf)),dt(He(Dt))),sC=Ot(fU),pU=At(z0,Nt(iU),dt(He(Sf)),dt(He(Sf)),dt(He(Dt))),oC=Ot(pU),dy=Rr(hU,dU,At(oM,dt(He(Dt))),At(kee,dt(He(Dt))),At($c,dt(He(Dt))),fU,pU,He(Dt)),cM=Ot(dy),Fee=At(dt(dy),Nt(rM),Lee(Nt(Od)),dt(He(Dt))),Qu=Ot(Fee),$ee=Rr(At(dy,Nt(rM),Nt(Od),dt(He(Dt))),At(dy,Nt(Od),dt(He(Dt))),At(Nt(Od),dt(He(Dt)))),bS=Ot($ee),zee=Rr(At($c,He(jl),Nt(Ql),dt(He(Dt))),At($c,Nt(Ql),dt(He(Dt))));Ot(zee);const Vee=At($c,Rr(At(He(jl,"443"),Nt(Ql)),At(He(jl),Nt(gS)),At(He(jl),Nt(Nd),Nt(Ql)),At(Nt(Nd),Nt(Ql)),Nt(Nd),Nt(gS)),dt(He(Dt)));Ot(Vee);const Hee=Rr(At(He(aU),dt(He(Dt))));Ot(Hee);const Gee=Rr(At(He(eU),dt(He(Dt))));Ot(Gee);const aC=864e13;class Wee{constructor(e,t={}){f(this,"log");f(this,"mappings");this.log=e.logger.forComponent("libp2p:address-manager:dns-mappings"),this.mappings=Po({name:"libp2p_address_manager_dns_mappings",metrics:e.metrics})}has(e){const t=zt(e);let n=t.host;(t.type==="ip4"||t.type==="ip6")&&t.sni!=null&&(n=t.sni);for(const i of this.mappings.values())if(i.domain===n)return!0;return!1}add(e,t){t.forEach(n=>{this.log("add DNS mapping %s to %s",n,e);const i=K1(n)===!0;this.mappings.set(n,{domain:e,verified:i,expires:i?aC-Date.now():0,lastVerified:i?aC-Date.now():void 0})})}remove(e){const t=zt(e);if(t.type!=="ip4"&&t.type!=="ip6")return!1;let n=!1;for(const[i,s]of this.mappings.entries())s.domain===t.sni&&(this.log("removing %s to %s DNS mapping %e",i,s.domain),this.mappings.delete(i),n=n||s.verified);return n}getAll(e){const t=[];for(let n=0;n<e.length;n++){const i=e[n].multiaddr;if(!Zi(i))continue;const s=zt(i);for(const[o,a]of this.mappings.entries()){if(s.host!==o)continue;const c=this.maybeAddSNIComponent(i,a.domain);c!=null&&(e.splice(n,1),n--,t.push({multiaddr:c,verified:a.verified,type:"dns-mapping",expires:a.expires,lastVerified:a.lastVerified}))}}return t}maybeAddSNIComponent(e,t){var i;const n=e.getComponents();for(let s=0;s<n.length;s++)if(n[s].code===HO&&((i=n[s+1])==null?void 0:i.code)!==pS)return n.splice(s+1,0,{name:"sni",code:pS,value:t}),pr(n)}confirm(e,t){const n=zt(e);let i=n.host;(n.type==="ip4"||n.type==="ip6")&&n.sni!=null&&(i=n.sni);let s=!1;for(const[o,a]of this.mappings.entries())a.domain===i&&(this.log("marking %s to %s DNS mapping as verified",o,a.domain),s=a.verified,a.verified=!0,a.expires=Date.now()+t,a.lastVerified=Date.now());return s}unconfirm(e,t){const n=zt(e);if(n.type!=="ip4"&&n.type!=="ip6")return!1;const i=n.sni??n.host;let s=!1;for(const[o,a]of this.mappings.entries())a.domain===i&&(this.log("removing verification of %s to %s DNS mapping",o,a.domain),s=s||a.verified,a.verified=!1,a.expires=Date.now()+t);return s}}class qee{constructor(e,t={}){f(this,"log");f(this,"mappings");this.log=e.logger.forComponent("libp2p:address-manager:ip-mappings"),this.mappings=Po({name:"libp2p_address_manager_ip_mappings",metrics:e.metrics})}has(e){const t=zt(e);if(t.type!=="ip4"&&t.type!=="ip6")return!1;for(const n of this.mappings.values())for(const i of n)if(i.externalIp===t.host)return!0;return!1}add(e,t,n,i=t,s="tcp"){const o=`${e}-${t}-${s}`,a=this.mappings.get(o)??[],c={internalIp:e,internalPort:t,externalIp:n,externalPort:i,externalFamily:$t(n)?4:6,protocol:s,verified:!1,expires:0};a.push(c),this.mappings.set(o,a)}remove(e){const t=zt(e);if(t.type!=="ip4"&&t.type!=="ip6")return!1;let n=!1;for(const[i,s]of this.mappings.entries()){for(let o=0;o<s.length;o++){const a=s[o];a.externalIp===t.host&&a.externalPort===t.port&&a.protocol===t.protocol&&(this.log("removing %s:%s to %s:%s %s IP mapping",a.externalIp,a.externalPort,t.host,t.port,t.protocol),n=n||a.verified,s.splice(o,1),o--)}s.length===0&&this.mappings.delete(i)}return n}getAll(e){const t=[];for(const{multiaddr:n}of e){if(!Zi(n))continue;const i=zt(n);if(i.type!=="ip4"&&i.type!=="ip6")continue;let s;if(i.protocol==="tcp"?s=`${i.host}-${i.port}-tcp`:i.protocol==="udp"&&(s=`${i.host}-${i.port}-udp`),s==null)continue;const o=this.mappings.get(s);if(o!=null)for(const a of o)t.push({multiaddr:this.maybeOverrideIp(n,a.externalIp,a.externalFamily,a.protocol,a.externalPort),verified:a.verified,type:"ip-mapping",expires:a.expires,lastVerified:a.lastVerified})}return t}maybeOverrideIp(e,t,n,i,s){const o=e.getComponents(),a=o.findIndex(l=>l.code===dS||l.code===fS),c=o.findIndex(l=>l.name===i);return a>-1&&c>-1?(o[a].value=t,o[a].code=n===4?dS:fS,o[c].value=`${s}`,pr(o)):e}confirm(e,t){if(!Zi(e))return!1;const n=zt(e);let i=!1;for(const s of this.mappings.values())for(const o of s)o.externalIp===n.host&&(this.log("marking %s to %s IP mapping as verified",o.internalIp,o.externalIp),i=o.verified,o.verified=!0,o.expires=Date.now()+t,o.lastVerified=Date.now());return i}unconfirm(e,t){if(!Zi(e))return!1;const n=zt(e);let i=!1;for(const s of this.mappings.values())for(let o=0;o<s.length;o++){const a=s[o];a.externalIp===n.host&&a.externalPort===n.port&&a.protocol===n.protocol&&(this.log("removing verification of %s:%s to %s:%s %s IP mapping",a.externalIp,a.externalPort,n.host,n.port,n.protocol),i=i||a.verified,a.verified=!1,a.expires=Date.now()+t)}return i}}const Kee={maxObservedAddresses:10};class Xee{constructor(e,t={}){f(this,"log");f(this,"addresses");f(this,"maxObservedAddresses");this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=Po({name:"libp2p_address_manager_observed_addresses",metrics:e.metrics}),this.maxObservedAddresses=t.maxObservedAddresses??Kee.maxObservedAddresses}has(e){return this.addresses.has(e.toString())}removePrefixed(e){for(const t of this.addresses.keys())t.toString().startsWith(e)&&this.addresses.delete(t)}add(e){this.addresses.size!==this.maxObservedAddresses&&(Zu(e)||fX(e)||(this.log("adding observed address %a",e),this.addresses.set(e.toString(),{verified:!1,expires:0})))}getAll(){return Array.from(this.addresses).map(([e,t])=>({multiaddr:pr(e),verified:t.verified,type:"observed",expires:t.expires,lastVerified:t.lastVerified}))}remove(e){var n;const t=((n=this.addresses.get(e.toString()))==null?void 0:n.verified)??!1;return this.log("removing observed address %a",e),this.addresses.delete(e.toString()),t}confirm(e,t){const n=e.toString(),i=this.addresses.get(n)??{verified:!1,expires:Date.now()+t,lastVerified:Date.now()},s=i.verified;return i.verified=!0,i.expires=Date.now()+t,i.lastVerified=Date.now(),this.log("marking observed address %a as verified",n),this.addresses.set(n,i),s}}const Yee={maxObservedAddresses:10};class Zee{constructor(e,t={}){f(this,"log");f(this,"addresses");f(this,"maxObservedAddresses");this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=Po({name:"libp2p_address_manager_transport_addresses",metrics:e.metrics}),this.maxObservedAddresses=t.maxObservedAddresses??Yee.maxObservedAddresses}get(e,t){if(Zu(e))return{multiaddr:e,verified:!0,type:"transport",expires:Date.now()+t,lastVerified:Date.now()};const n=this.toKey(e);let i=this.addresses.get(n);return i==null&&(i={verified:!Zi(e),expires:0},this.addresses.set(n,i)),{multiaddr:e,verified:i.verified,type:"transport",expires:i.expires,lastVerified:i.lastVerified}}has(e){const t=this.toKey(e);return this.addresses.has(t)}remove(e){var i;const t=this.toKey(e),n=((i=this.addresses.get(t))==null?void 0:i.verified)??!1;return this.log("removing observed address %a",e),this.addresses.delete(t),n}confirm(e,t){const n=this.toKey(e),i=this.addresses.get(n)??{verified:!1,expires:0,lastVerified:0},s=i.verified;return i.verified=!0,i.expires=Date.now()+t,i.lastVerified=Date.now(),this.addresses.set(n,i),s}unconfirm(e,t){const n=this.toKey(e),i=this.addresses.get(n)??{verified:!1,expires:0},s=i.verified;return i.verified=!1,i.expires=Date.now()+t,this.addresses.set(n,i),s}toKey(e){if(!Zi(e))return e.toString();const t=zt(e);return`${t.host}-${t.port}-${t.protocol}`}}const cC=6e4,lC={addressVerificationTTL:cC*10,addressVerificationRetry:cC*5},Jee=r=>r;function Sw(r,e){var n;const t=(n=r.getComponents().findLast(i=>i.code===Is))==null?void 0:n.value;return t!=null&&Gu(t).equals(e)&&(r=r.decapsulate(pr(`/p2p/${e.toString()}`))),r}var sR;sR=Symbol.toStringTag;class jee{constructor(e,t={}){f(this,"log");f(this,"components");f(this,"listen");f(this,"announce");f(this,"appendAnnounce");f(this,"announceFilter");f(this,"observed");f(this,"dnsMappings");f(this,"ipMappings");f(this,"transportAddresses");f(this,"observedAddressFilter");f(this,"addressVerificationTTL");f(this,"addressVerificationRetry");f(this,sR,"@libp2p/address-manager");const{listen:n=[],announce:i=[],appendAnnounce:s=[]}=t;this.components=e,this.log=e.logger.forComponent("libp2p:address-manager"),this.listen=n.map(o=>o.toString()),this.announce=new Set(i.map(o=>o.toString())),this.appendAnnounce=new Set(s.map(o=>o.toString())),this.observed=new Xee(e,t),this.dnsMappings=new Wee(e,t),this.ipMappings=new qee(e,t),this.transportAddresses=new Zee(e,t),this.announceFilter=t.announceFilter??Jee,this.observedAddressFilter=mf(1024),this.addressVerificationTTL=t.addressVerificationTTL??lC.addressVerificationTTL,this.addressVerificationRetry=t.addressVerificationRetry??lC.addressVerificationRetry,this._updatePeerStoreAddresses=iy(this._updatePeerStoreAddresses.bind(this),1e3),e.events.addEventListener("transport:listening",()=>{this._updatePeerStoreAddresses()}),e.events.addEventListener("transport:close",()=>{this._updatePeerStoreAddresses()})}_updatePeerStoreAddresses(){const e=this.getAddresses().map(t=>{var n;return((n=t.getComponents().findLast(i=>i.code===Is))==null?void 0:n.value)===this.components.peerId.toString()?t.decapsulate(`/p2p/${this.components.peerId.toString()}`):t});this.components.peerStore.patch(this.components.peerId,{multiaddrs:e}).catch(t=>{this.log.error("error updating addresses - %e",t)})}getListenAddrs(){return Array.from(this.listen).map(e=>pr(e))}getAnnounceAddrs(){return Array.from(this.announce).map(e=>pr(e))}getAppendAnnounceAddrs(){return Array.from(this.appendAnnounce).map(e=>pr(e))}getObservedAddrs(){return this.observed.getAll().map(e=>e.multiaddr)}addObservedAddr(e){const t=zt(e);let n;switch(t.type){case"ip4":{n=`${t.host}:${t.port}`;break}case"ip6":{n=`[${t.host}]:${t.port}`;break}default:return}this.observedAddressFilter.has(n)||(this.observedAddressFilter.add(n),e=Sw(e,this.components.peerId),!this.ipMappings.has(e)&&(this.dnsMappings.has(e)||this.observed.add(e)))}confirmObservedAddr(e,t){e=Sw(e,this.components.peerId);let n=!0;((t==null?void 0:t.type)==="transport"||this.transportAddresses.has(e))&&!this.transportAddresses.confirm(e,(t==null?void 0:t.ttl)??this.addressVerificationTTL)&&n&&(n=!1),((t==null?void 0:t.type)==="dns-mapping"||this.dnsMappings.has(e))&&!this.dnsMappings.confirm(e,(t==null?void 0:t.ttl)??this.addressVerificationTTL)&&n&&(n=!1),((t==null?void 0:t.type)==="ip-mapping"||this.ipMappings.has(e))&&!this.ipMappings.confirm(e,(t==null?void 0:t.ttl)??this.addressVerificationTTL)&&n&&(n=!1),((t==null?void 0:t.type)==="observed"||this.observed.has(e))&&(this.maybeUpgradeToIPMapping(e)?(this.ipMappings.confirm(e,(t==null?void 0:t.ttl)??this.addressVerificationTTL),n=!1):!this.observed.confirm(e,(t==null?void 0:t.ttl)??this.addressVerificationTTL)&&n&&(n=!1)),n||this._updatePeerStoreAddresses()}removeObservedAddr(e,t){e=Sw(e,this.components.peerId),this.observed.has(e)&&this.observed.remove(e),this.transportAddresses.has(e)&&this.transportAddresses.unconfirm(e,(t==null?void 0:t.ttl)??this.addressVerificationRetry),this.dnsMappings.has(e)&&this.dnsMappings.unconfirm(e,(t==null?void 0:t.ttl)??this.addressVerificationRetry),this.ipMappings.has(e)&&this.ipMappings.unconfirm(e,(t==null?void 0:t.ttl)??this.addressVerificationRetry)}getAddresses(){const e=new Set,t=this.getAddressesWithMetadata().filter(n=>{if(!n.verified)return!1;const i=n.multiaddr.toString();return e.has(i)?!1:(e.add(i),!0)}).map(n=>n.multiaddr);return this.announceFilter(t.map(n=>{const i=pr(n),s=i.getComponents().pop();return(s==null?void 0:s.value)===this.components.peerId.toString()?i:i.encapsulate(`/p2p/${this.components.peerId.toString()}`)}))}getAddressesWithMetadata(){const e=this.getAnnounceAddrs();if(e.length>0)return this.components.transportManager.getListeners().forEach(i=>{i.updateAnnounceAddrs(e)}),e.map(i=>({multiaddr:i,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()}));let t=[];t=t.concat(this.components.transportManager.getAddrs().map(i=>this.transportAddresses.get(i,this.addressVerificationTTL)));const n=this.getAppendAnnounceAddrs();return n.length>0&&(this.components.transportManager.getListeners().forEach(i=>{i.updateAnnounceAddrs(n)}),t=t.concat(n.map(i=>({multiaddr:i,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()})))),t=t.concat(this.observed.getAll()),t=t.concat(this.ipMappings.getAll(t)),t=t.concat(this.dnsMappings.getAll(t)),t}addDNSMapping(e,t){this.dnsMappings.add(e,t)}removeDNSMapping(e){this.dnsMappings.remove(pr(`/dns/${e}`))&&this._updatePeerStoreAddresses()}addPublicAddressMapping(e,t,n,i=t,s="tcp"){this.ipMappings.add(e,t,n,i,s),this.observed.removePrefixed(`/ip${$t(n)?4:6}/${n}/${s}/${i}`)}removePublicAddressMapping(e,t,n,i=t,s="tcp"){this.ipMappings.remove(pr(`/ip${$t(n)?4:6}/${n}/${s}/${i}`))&&this._updatePeerStoreAddresses()}maybeUpgradeToIPMapping(e){if(this.ipMappings.has(e)||!Zi(e))return!1;const t=zt(e);if(t.type!=="ip4"||K1(t.host)===!0)return!1;const n=this.components.transportManager.getListeners(),i=[s=>Ef.exactMatch(s)||hy.exactMatch(s),s=>uy.exactMatch(s),s=>Bee.exactMatch(s)];for(const s of i){if(!s(e))continue;const o=n.filter(l=>l.getAddrs().filter(u=>zt(u).type==="ip4"&&s(u)).length>0);if(o.length!==1)continue;const a=o[0].getAddrs().filter(l=>!cS(l)).pop();if(a==null)continue;const c=zt(a);return c.port==null?!1:(this.observed.remove(e),this.ipMappings.add(c.host,c.port,t.host,t.port,t.protocol),!0)}return!1}}var uC;(function(r){r.NOT_STARTED_YET="The libp2p node is not started yet",r.NOT_FOUND="Not found"})(uC||(uC={}));class Qee extends Error{constructor(e="Missing service"){super(e),this.name="MissingServiceError"}}class ete extends Error{constructor(e="Unmet service dependencies"){super(e),this.name="UnmetServiceDependenciesError"}}class Ew extends Error{constructor(e="No content routers available"){super(e),this.name="NoContentRoutersError"}}class hC extends Error{constructor(e="No peer routers available"){super(e),this.name="NoPeerRoutersError"}}class tte extends Error{constructor(e="Should not try to find self"){super(e),this.name="QueriedForSelfError"}}class nte extends Error{constructor(e="Unhandled protocol error"){super(e),this.name="UnhandledProtocolError"}}class rte extends Error{constructor(e="Duplicate protocol handler error"){super(e),this.name="DuplicateProtocolHandlerError"}}class dC extends Error{constructor(e="Dial denied error"){super(e),this.name="DialDeniedError"}}class ite extends Error{constructor(e="No transport was configured to listen on this address"){super(e),this.name="UnsupportedListenAddressError"}}class ste extends Error{constructor(e="Configured listen addresses could not be listened on"){super(e),this.name="UnsupportedListenAddressesError"}}class ote extends Error{constructor(e="No valid addresses"){super(e),this.name="NoValidAddressesError"}}class ate extends Error{constructor(e="Connection intercepted"){super(e),this.name="ConnectionInterceptedError"}}class cte extends Error{constructor(e="Connection denied"){super(e),this.name="ConnectionDeniedError"}}class Sg extends Error{constructor(e="Stream is not multiplexed"){super(e),this.name="MuxerUnavailableError"}}class Om extends Error{constructor(e="Encryption failed"){super(e),this.name="EncryptionFailedError"}}class lte extends Error{constructor(e="Transport unavailable"){super(e),this.name="TransportUnavailableError"}}class ute extends Error{constructor(e="Max recursive depth reached"){super(e),this.name="RecursionLimitError"}}class hte{constructor(e={}){f(this,"components",{});f(this,"_started",!1);this.components={};for(const[t,n]of Object.entries(e))this.components[t]=n;this.components.logger==null&&(this.components.logger=$N())}isStarted(){return this._started}async _invokeStartableMethod(e){await Promise.all(Object.values(this.components).filter(t=>B1(t)).map(async t=>{var n;await((n=t[e])==null?void 0:n.call(t))}))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const dte=["metrics","connectionProtector","dns"],fte=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function pte(r={}){const e=new hte(r);return new Proxy(e,{get(n,i,s){if(typeof i=="string"&&!fte.includes(i)){const o=e.components[i];if(o==null&&!dte.includes(i))throw new Qee(`${i} not set`);return o}return Reflect.get(n,i,s)},set(n,i,s){return typeof i=="string"?e.components[i]=s:Reflect.set(n,i,s),!0}})}function mte(r){const e={};for(const t of Object.values(r.components))for(const n of gte(t))e[n]=!0;for(const t of Object.values(r.components))for(const n of yte(t))if(e[n]!==!0)throw new ete(`Service "${bte(t)}" required capability "${n}" but it was not provided by any component, you may need to add additional configuration when creating your node.`)}function gte(r){return Array.isArray(r==null?void 0:r[sS])?r[sS]:[]}function yte(r){return Array.isArray(r==null?void 0:r[_2])?r[_2]:[]}function bte(r){return(r==null?void 0:r[Symbol.toStringTag])??(r==null?void 0:r.toString())??"unknown"}function wte(r={}){return r.denyDialMultiaddr==null&&(r.denyDialMultiaddr=e=>Ef.matches(e)?!0:Zu(e)),r}class Rt extends Event{constructor(t,n){super(t);f(this,"type");f(this,"detail");this.type=t,this.detail=n}}function mU(r){var n;if(nK(r))return{peerId:r,multiaddrs:[]};let e=Array.isArray(r)?r:[r],t;if(e.length>0){const i=(n=e[0].getComponents().findLast(s=>s.code===Is))==null?void 0:n.value;t=i==null?void 0:Gu(i),e.forEach(s=>{var a;if(!eM(s))throw new U1("Invalid multiaddr");const o=(a=s.getComponents().findLast(c=>c.code===Is))==null?void 0:a.value;if(o==null){if(t!=null)throw new ai("Multiaddrs must all have the same peer id or have no peer id")}else{const c=Gu(o);if((t==null?void 0:t.equals(c))!==!0)throw new ai("Multiaddrs must all have the same peer id or have no peer id")}})}return e=e.filter(i=>!Oee.exactMatch(i)),{peerId:t,multiaddrs:e}}const vte=["/ipfs/id/1.0.0","/ipfs/id/push/1.0.0","/libp2p/autonat/1.0.0","/libp2p/dcutr"];async function _te(r,e){var i;const t=((i=r==null?void 0:r.streams)==null?void 0:i.map(s=>s.protocol))??[],n=(e==null?void 0:e.closableProtocols)??vte;if(!(t.filter(s=>s!=null&&!n.includes(s)).length>0))try{await(r==null?void 0:r.close(e))}catch(s){r==null||r.abort(s)}}function wS(r){const e=zt(r);let t=e.cidr;if(e.type!=="ip4"&&e.type!=="ip6")throw new ai(`Multiaddr ${r} was not an IPv4 or IPv6 address`);if(t==null)switch(e.type){case"ip4":{t=32;break}case"ip6":{t=128;break}default:throw new ai(`Multiaddr ${r} was not an IPv4 or IPv6 address`)}return new QN(e.host,t)}function gU(r){return!Qu.exactMatch(r)}function yU(r,e,t){if(r==null||e==null)return;const n=e.sort((s,o)=>s.direct?-1:o.direct?1:0).find(s=>s.limits==null);if(n==null||n.direct||t==null)return n;if(!t.some(s=>gU(s)))return n}class xte{constructor(e,t={}){f(this,"connectionManager");f(this,"peerStore");f(this,"allow");f(this,"events");f(this,"log");this.allow=(t.allow??[]).map(n=>wS(n)),this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager:connection-pruner"),this.maybePruneConnections=this.maybePruneConnections.bind(this)}start(){this.events.addEventListener("connection:open",this.maybePruneConnections)}stop(){this.events.removeEventListener("connection:open",this.maybePruneConnections)}maybePruneConnections(){this._maybePruneConnections().catch(e=>{this.log.error("error while pruning connections - %e",e)})}async _maybePruneConnections(){const e=this.connectionManager.getConnections(),t=e.length,n=this.connectionManager.getMaxConnections();if(this.log("checking max connections limit %d/%d",t,n),t<=n)return;const i=new wh;for(const c of e){const l=c.remotePeer;if(!i.has(l)){i.set(l,0);try{const u=await this.peerStore.get(l);i.set(l,[...u.tags.values()].reduce((h,d)=>h+d.value,0))}catch(u){u.name!=="NotFoundError"&&this.log.error("error loading peer tags - %e",u)}}}const s=this.sortConnections(e,i),o=Math.max(t-n,0),a=[];for(const c of s)if(this.log("too many connections open - closing a connection to %p",c.remotePeer),this.allow.some(u=>{if(Zi(c.remoteAddr)){const h=zt(c.remoteAddr);return u.contains(h.host)}return!0})||a.push(c),a.length===o)break;await Promise.all(a.map(async c=>{await _te(c,{signal:AbortSignal.timeout(1e3)})})),this.events.safeDispatchEvent("connection:prune",{detail:a})}sortConnections(e,t){return e.sort((n,i)=>{const s=n.timeline.open,o=i.timeline.open;return s<o?1:s>o?-1:0}).sort((n,i)=>n.direction==="outbound"&&i.direction==="inbound"?1:n.direction==="inbound"&&i.direction==="outbound"?-1:0).sort((n,i)=>n.streams.length>i.streams.length?1:n.streams.length<i.streams.length?-1:0).sort((n,i)=>{const s=t.get(n.remotePeer)??0,o=t.get(i.remotePeer)??0;return s>o?1:s<o?-1:0})}}const bU=1e4,wU=1e3,Ste=1e4,fy=1e4,vU=25,Ete=5,Mte=10,Ate=5,Tte="last-dial-failure",Cte="last-dial-success",_U=500,Ite=32,Pte=100,xU=50;function Rte(r,e){const t=uy.exactMatch(r.multiaddr),n=uy.exactMatch(e.multiaddr);if(t&&!n)return-1;if(!t&&n)return 1;const i=hy.exactMatch(r.multiaddr),s=hy.exactMatch(e.multiaddr);if(i&&!s)return-1;if(!i&&s)return 1;const o=Ef.exactMatch(r.multiaddr),a=Ef.exactMatch(e.multiaddr);if(o&&!a)return-1;if(!o&&a)return 1;const c=bS.exactMatch(r.multiaddr),l=bS.exactMatch(e.multiaddr);if(c&&!l)return-1;if(!c&&l)return 1;const u=sC.exactMatch(r.multiaddr),h=sC.exactMatch(e.multiaddr);if(u&&!h)return-1;if(!u&&h)return 1;const d=oC.exactMatch(r.multiaddr),m=oC.exactMatch(e.multiaddr);return d&&!m?-1:!d&&m?1:0}function Dte(r,e){const t=cS(r.multiaddr),n=cS(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function Lte(r,e){const t=Zu(r.multiaddr),n=Zu(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function Nte(r,e){return r.isCertified&&!e.isCertified?-1:!r.isCertified&&e.isCertified?1:0}function Ote(r,e){const t=Qu.exactMatch(r.multiaddr),n=Qu.exactMatch(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function Ute(r){return r.sort(Rte).sort(Nte).sort(Ote).sort(Lte).sort(Dte)}var Mw={exports:{}},fC;function kte(){return fC||(fC=1,(function(r){var e=Object.prototype.hasOwnProperty,t="~";function n(){}Object.create&&(n.prototype=Object.create(null),new n().__proto__||(t=!1));function i(c,l,u){this.fn=c,this.context=l,this.once=u||!1}function s(c,l,u,h,d){if(typeof u!="function")throw new TypeError("The listener must be a function");var m=new i(u,h||c,d),p=t?t+l:l;return c._events[p]?c._events[p].fn?c._events[p]=[c._events[p],m]:c._events[p].push(m):(c._events[p]=m,c._eventsCount++),c}function o(c,l){--c._eventsCount===0?c._events=new n:delete c._events[l]}function a(){this._events=new n,this._eventsCount=0}a.prototype.eventNames=function(){var l=[],u,h;if(this._eventsCount===0)return l;for(h in u=this._events)e.call(u,h)&&l.push(t?h.slice(1):h);return Object.getOwnPropertySymbols?l.concat(Object.getOwnPropertySymbols(u)):l},a.prototype.listeners=function(l){var u=t?t+l:l,h=this._events[u];if(!h)return[];if(h.fn)return[h.fn];for(var d=0,m=h.length,p=new Array(m);d<m;d++)p[d]=h[d].fn;return p},a.prototype.listenerCount=function(l){var u=t?t+l:l,h=this._events[u];return h?h.fn?1:h.length:0},a.prototype.emit=function(l,u,h,d,m,p){var b=t?t+l:l;if(!this._events[b])return!1;var g=this._events[b],y=arguments.length,v,w;if(g.fn){switch(g.once&&this.removeListener(l,g.fn,void 0,!0),y){case 1:return g.fn.call(g.context),!0;case 2:return g.fn.call(g.context,u),!0;case 3:return g.fn.call(g.context,u,h),!0;case 4:return g.fn.call(g.context,u,h,d),!0;case 5:return g.fn.call(g.context,u,h,d,m),!0;case 6:return g.fn.call(g.context,u,h,d,m,p),!0}for(w=1,v=new Array(y-1);w<y;w++)v[w-1]=arguments[w];g.fn.apply(g.context,v)}else{var _=g.length,M;for(w=0;w<_;w++)switch(g[w].once&&this.removeListener(l,g[w].fn,void 0,!0),y){case 1:g[w].fn.call(g[w].context);break;case 2:g[w].fn.call(g[w].context,u);break;case 3:g[w].fn.call(g[w].context,u,h);break;case 4:g[w].fn.call(g[w].context,u,h,d);break;default:if(!v)for(M=1,v=new Array(y-1);M<y;M++)v[M-1]=arguments[M];g[w].fn.apply(g[w].context,v)}}return!0},a.prototype.on=function(l,u,h){return s(this,l,u,h,!1)},a.prototype.once=function(l,u,h){return s(this,l,u,h,!0)},a.prototype.removeListener=function(l,u,h,d){var m=t?t+l:l;if(!this._events[m])return this;if(!u)return o(this,m),this;var p=this._events[m];if(p.fn)p.fn===u&&(!d||p.once)&&(!h||p.context===h)&&o(this,m);else{for(var b=0,g=[],y=p.length;b<y;b++)(p[b].fn!==u||d&&!p[b].once||h&&p[b].context!==h)&&g.push(p[b]);g.length?this._events[m]=g.length===1?g[0]:g:o(this,m)}return this},a.prototype.removeAllListeners=function(l){var u;return l?(u=t?t+l:l,this._events[u]&&o(this,u)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=t,a.EventEmitter=a,r.exports=a})(Mw)),Mw.exports}var Bte=kte();const Fte=W1(Bte);let $te=class SU extends Error{constructor(t,n){var i;super(t,n);f(this,"name","TimeoutError");(i=Error.captureStackTrace)==null||i.call(Error,this,SU)}};const pC=r=>r.reason??new DOMException("This operation was aborted.","AbortError");function zte(r,e){const{milliseconds:t,fallback:n,message:i,customTimers:s={setTimeout,clearTimeout},signal:o}=e;let a,c;const u=new Promise((h,d)=>{if(typeof t!="number"||Math.sign(t)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${t}\``);if(o!=null&&o.aborted){d(pC(o));return}if(o&&(c=()=>{d(pC(o))},o.addEventListener("abort",c,{once:!0})),r.then(h,d),t===Number.POSITIVE_INFINITY)return;const m=new $te;a=s.setTimeout.call(void 0,()=>{if(n){try{h(n())}catch(p){d(p)}return}typeof r.cancel=="function"&&r.cancel(),i===!1?h():i instanceof Error?d(i):(m.message=i??`Promise timed out after ${t} milliseconds`,d(m))},t)}).finally(()=>{u.clear(),c&&o&&o.removeEventListener("abort",c)});return u.clear=()=>{s.clearTimeout.call(void 0,a),a=void 0},u}function Vte(r,e,t){let n=0,i=r.length;for(;i>0;){const s=Math.trunc(i/2);let o=n+s;t(r[o],e)<=0?(n=++o,i-=s+1):i=s}return n}var ui,oR;let Hte=(oR=class{constructor(){xe(this,ui,[])}enqueue(e,t){const{priority:n=0,id:i}=t??{},s={priority:n,id:i,run:e};if(this.size===0||N(this,ui)[this.size-1].priority>=n){N(this,ui).push(s);return}const o=Vte(N(this,ui),s,(a,c)=>c.priority-a.priority);N(this,ui).splice(o,0,s)}setPriority(e,t){const n=N(this,ui).findIndex(s=>s.id===e);if(n===-1)throw new ReferenceError(`No promise function with the id "${e}" exists in the queue.`);const[i]=N(this,ui).splice(n,1);this.enqueue(i.run,{priority:t,id:e})}dequeue(){const e=N(this,ui).shift();return e==null?void 0:e.run}filter(e){return N(this,ui).filter(t=>t.priority===e.priority).map(t=>t.run)}get size(){return N(this,ui).length}},ui=new WeakMap,oR);var fu,ki,ps,pu,mu,gu,la,qf,yu,ms,Qs,pn,Kf,cr,yc,eo,jy,bc,Be,EU,MU,AU,TU,CU,vS,_S,IU,Eg,xS,SS,Mg,ja,PU,ud,ES,aR;let Gte=(aR=class extends Fte{constructor(t){var n,i;super();xe(this,Be);xe(this,fu);xe(this,ki);xe(this,ps,0);xe(this,pu);xe(this,mu,!1);xe(this,gu,!1);xe(this,la);xe(this,qf,0);xe(this,yu,0);xe(this,ms);xe(this,Qs);xe(this,pn);xe(this,Kf);xe(this,cr,0);xe(this,yc);xe(this,eo);xe(this,jy,1n);xe(this,bc,new Map);f(this,"timeout");if(t={carryoverIntervalCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:Hte,...t},!(typeof t.intervalCap=="number"&&t.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${((n=t.intervalCap)==null?void 0:n.toString())??""}\` (${typeof t.intervalCap})`);if(t.interval===void 0||!(Number.isFinite(t.interval)&&t.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${((i=t.interval)==null?void 0:i.toString())??""}\` (${typeof t.interval})`);if(_e(this,fu,t.carryoverIntervalCount??t.carryoverConcurrencyCount??!1),_e(this,ki,t.intervalCap===Number.POSITIVE_INFINITY||t.interval===0),_e(this,pu,t.intervalCap),_e(this,la,t.interval),_e(this,pn,new t.queueClass),_e(this,Kf,t.queueClass),this.concurrency=t.concurrency,t.timeout!==void 0&&!(Number.isFinite(t.timeout)&&t.timeout>0))throw new TypeError(`Expected \`timeout\` to be a positive finite number, got \`${t.timeout}\` (${typeof t.timeout})`);this.timeout=t.timeout,_e(this,eo,t.autoStart===!1),be(this,Be,PU).call(this)}get concurrency(){return N(this,yc)}set concurrency(t){if(!(typeof t=="number"&&t>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${t}\` (${typeof t})`);_e(this,yc,t),be(this,Be,Mg).call(this)}setPriority(t,n){if(typeof n!="number"||!Number.isFinite(n))throw new TypeError(`Expected \`priority\` to be a finite number, got \`${n}\` (${typeof n})`);N(this,pn).setPriority(t,n)}async add(t,n={}){return n.id??(n.id=(Ti(this,jy)._++).toString()),n={timeout:this.timeout,...n},new Promise((i,s)=>{const o=Symbol(`task-${n.id}`);N(this,pn).enqueue(async()=>{var c,l;Ti(this,cr)._++,N(this,bc).set(o,{id:n.id,priority:n.priority??0,startTime:Date.now(),timeout:n.timeout});let a;try{try{(c=n.signal)==null||c.throwIfAborted()}catch(d){throw N(this,ki)||Ti(this,ps)._--,N(this,bc).delete(o),d}let u=t({signal:n.signal});if(n.timeout&&(u=zte(Promise.resolve(u),{milliseconds:n.timeout,message:`Task timed out after ${n.timeout}ms (queue has ${N(this,cr)} running, ${N(this,pn).size} waiting)`})),n.signal){const{signal:d}=n;u=Promise.race([u,new Promise((m,p)=>{a=()=>{p(d.reason)},d.addEventListener("abort",a,{once:!0})})])}const h=await u;i(h),this.emit("completed",h)}catch(u){s(u),this.emit("error",u)}finally{a&&((l=n.signal)==null||l.removeEventListener("abort",a)),N(this,bc).delete(o),queueMicrotask(()=>{be(this,Be,AU).call(this)})}},n),this.emit("add"),be(this,Be,Eg).call(this)})}async addAll(t,n){return Promise.all(t.map(async i=>this.add(i,n)))}start(){return N(this,eo)?(_e(this,eo,!1),be(this,Be,Mg).call(this),this):this}pause(){_e(this,eo,!0)}clear(){_e(this,pn,new(N(this,Kf))),be(this,Be,ES).call(this)}async onEmpty(){N(this,pn).size!==0&&await be(this,Be,ja).call(this,"empty")}async onSizeLessThan(t){N(this,pn).size<t||await be(this,Be,ja).call(this,"next",()=>N(this,pn).size<t)}async onIdle(){N(this,cr)===0&&N(this,pn).size===0||await be(this,Be,ja).call(this,"idle")}async onPendingZero(){N(this,cr)!==0&&await be(this,Be,ja).call(this,"pendingZero")}async onRateLimit(){this.isRateLimited||await be(this,Be,ja).call(this,"rateLimit")}async onRateLimitCleared(){this.isRateLimited&&await be(this,Be,ja).call(this,"rateLimitCleared")}async onError(){return new Promise((t,n)=>{const i=s=>{this.off("error",i),n(s)};this.on("error",i)})}get size(){return N(this,pn).size}sizeBy(t){return N(this,pn).filter(t).length}get pending(){return N(this,cr)}get isPaused(){return N(this,eo)}get isRateLimited(){return N(this,mu)}get isSaturated(){return N(this,cr)===N(this,yc)&&N(this,pn).size>0||this.isRateLimited&&N(this,pn).size>0}get runningTasks(){return[...N(this,bc).values()].map(t=>({...t}))}},fu=new WeakMap,ki=new WeakMap,ps=new WeakMap,pu=new WeakMap,mu=new WeakMap,gu=new WeakMap,la=new WeakMap,qf=new WeakMap,yu=new WeakMap,ms=new WeakMap,Qs=new WeakMap,pn=new WeakMap,Kf=new WeakMap,cr=new WeakMap,yc=new WeakMap,eo=new WeakMap,jy=new WeakMap,bc=new WeakMap,Be=new WeakSet,EU=function(){return N(this,ki)||N(this,ps)<N(this,pu)},MU=function(){return N(this,cr)<N(this,yc)},AU=function(){Ti(this,cr)._--,N(this,cr)===0&&this.emit("pendingZero"),be(this,Be,Eg).call(this),this.emit("next")},TU=function(){be(this,Be,SS).call(this),be(this,Be,xS).call(this),_e(this,Qs,void 0)},CU=function(){const t=Date.now();if(N(this,ms)===void 0){const n=N(this,qf)-t;if(n<0){if(N(this,yu)>0){const i=t-N(this,yu);if(i<N(this,la))return be(this,Be,vS).call(this,N(this,la)-i),!0}_e(this,ps,N(this,fu)?N(this,cr):0)}else return be(this,Be,vS).call(this,n),!0}return!1},vS=function(t){N(this,Qs)===void 0&&_e(this,Qs,setTimeout(()=>{be(this,Be,TU).call(this)},t))},_S=function(){N(this,ms)&&(clearInterval(N(this,ms)),_e(this,ms,void 0))},IU=function(){N(this,Qs)&&(clearTimeout(N(this,Qs)),_e(this,Qs,void 0))},Eg=function(){if(N(this,pn).size===0)return be(this,Be,_S).call(this),this.emit("empty"),N(this,cr)===0&&(be(this,Be,IU).call(this),this.emit("idle")),!1;let t=!1;if(!N(this,eo)){const n=!N(this,Be,CU);if(N(this,Be,EU)&&N(this,Be,MU)){const i=N(this,pn).dequeue();N(this,ki)||(Ti(this,ps)._++,be(this,Be,ud).call(this)),this.emit("active"),_e(this,yu,Date.now()),i(),n&&be(this,Be,xS).call(this),t=!0}}return t},xS=function(){N(this,ki)||N(this,ms)!==void 0||(_e(this,ms,setInterval(()=>{be(this,Be,SS).call(this)},N(this,la))),_e(this,qf,Date.now()+N(this,la)))},SS=function(){N(this,ps)===0&&N(this,cr)===0&&N(this,ms)&&be(this,Be,_S).call(this),_e(this,ps,N(this,fu)?N(this,cr):0),be(this,Be,Mg).call(this),be(this,Be,ud).call(this)},Mg=function(){for(;be(this,Be,Eg).call(this););},ja=async function(t,n){return new Promise(i=>{const s=()=>{n&&!n()||(this.off(t,s),i())};this.on(t,s)})},PU=function(){N(this,ki)||(this.on("add",()=>{N(this,pn).size>0&&be(this,Be,ud).call(this)}),this.on("next",()=>{be(this,Be,ud).call(this)}))},ud=function(){N(this,ki)||N(this,gu)||(_e(this,gu,!0),queueMicrotask(()=>{_e(this,gu,!1),be(this,Be,ES).call(this)}))},ES=function(){const t=N(this,mu),n=!N(this,ki)&&N(this,ps)>=N(this,pu)&&N(this,pn).size>0;n!==t&&(_e(this,mu,n),this.emit(n?"rateLimit":"rateLimitCleared"))},aR);function RU(r){const e=[Aa.A];return r==null?e:Array.isArray(r)?r.length===0?e:r:[r]}const DU=60;function LU(r){return{Status:r.Status??0,TC:r.TC??r.flag_tc??!1,RD:r.RD??r.flag_rd??!1,RA:r.RA??r.flag_ra??!1,AD:r.AD??r.flag_ad??!1,CD:r.CD??r.flag_cd??!1,Question:(r.Question??r.questions??[]).map(e=>({name:e.name,type:Aa[e.type]})),Answer:(r.Answer??r.answers??[]).map(e=>({name:e.name,type:Aa[e.type],TTL:e.TTL??e.ttl??DU,data:e.data instanceof Uint8Array?ae(e.data):e.data}))}}const Wte=4;function mC(r,e={}){const t=new Gte({concurrency:e.queryConcurrency??Wte});return async(n,i={})=>{var a;const s=new URLSearchParams;s.set("name",n),RU(i.types).forEach(c=>{s.append("type",Aa[c])}),(a=i.onProgress)==null||a.call(i,new Rt("dns:query",n));const o=await t.add(async()=>{var u;const c=await fetch(`${r}?${s}`,{headers:{accept:"application/dns-json"},signal:i==null?void 0:i.signal});if(c.status!==200)throw new Error(`Unexpected HTTP status: ${c.status} - ${c.statusText}`);const l=LU(await c.json());return(u=i.onProgress)==null||u.call(i,new Rt("dns:response",l)),l},{signal:i.signal});if(o==null)throw new Error("No DNS response received");return o}}function qte(){return[mC("https://cloudflare-dns.com/dns-query"),mC("https://dns.google/resolve")]}var Aw,gC;function Kte(){return gC||(gC=1,Aw=function(r){if(!r)throw Error("hashlru must have a max value, of type number, greater than 0");var e=0,t=Object.create(null),n=Object.create(null);function i(s,o){t[s]=o,e++,e>=r&&(e=0,n=t,t=Object.create(null))}return{has:function(s){return t[s]!==void 0||n[s]!==void 0},remove:function(s){t[s]!==void 0&&(t[s]=void 0),n[s]!==void 0&&(n[s]=void 0)},get:function(s){var o=t[s];if(o!==void 0)return o;if((o=n[s])!==void 0)return i(s,o),o},set:function(s,o){t[s]!==void 0?t[s]=o:i(s,o)},clear:function(){t=Object.create(null),n=Object.create(null)}}}),Aw}var Xte=Kte();const Yte=W1(Xte);class Zte{constructor(e){f(this,"lru");this.lru=Yte(e)}get(e,t){let n=!0;const i=[];for(const s of t){const o=this.getAnswers(e,s);if(o.length===0){n=!1;break}i.push(...o)}if(n)return LU({answers:i})}getAnswers(e,t){const n=`${e.toLowerCase()}-${t}`,i=this.lru.get(n);if(i!=null){const s=i.filter(o=>o.expires>Date.now()).map(({expires:o,value:a})=>({...a,TTL:Math.round((o-Date.now())/1e3),type:Aa[a.type]}));return s.length===0&&this.lru.remove(n),s}return[]}add(e,t){const n=`${e.toLowerCase()}-${t.type}`,i=this.lru.get(n)??[];i.push({expires:Date.now()+(t.TTL??DU)*1e3,value:t}),this.lru.set(n,i)}remove(e,t){const n=`${e.toLowerCase()}-${t}`;this.lru.remove(n)}clear(){this.lru.clear()}}function Jte(r){return new Zte(r)}const jte=1e3;class Qte{constructor(e){f(this,"resolvers");f(this,"cache");this.resolvers={},this.cache=Jte(e.cacheSize??jte),Object.entries(e.resolvers??{}).forEach(([t,n])=>{Array.isArray(n)||(n=[n]),t.endsWith(".")||(t=`${t}.`),this.resolvers[t]=n}),this.resolvers["."]==null&&(this.resolvers["."]=qte())}async query(e,t={}){var c,l,u;const n=RU(t.types),i=t.cached!==!1?this.cache.get(e,n):void 0;if(i!=null)return(c=t.onProgress)==null||c.call(t,new Rt("dns:cache",i)),i;const s=`${e.split(".").pop()}.`,o=(this.resolvers[s]??this.resolvers["."]).sort(()=>Math.random()>.5?-1:1),a=[];for(const h of o){if(((l=t.signal)==null?void 0:l.aborted)===!0)break;try{const d=await h(e,{...t,types:n});for(const m of d.Answer)this.cache.add(e,m);return d}catch(d){a.push(d),(u=t.onProgress)==null||u.call(t,new Rt("dns:error",d))}}throw a.length===1?a[0]:new AggregateError(a,`DNS lookup of ${e} ${n} failed`)}}var Aa;(function(r){r[r.A=1]="A",r[r.CNAME=5]="CNAME",r[r.TXT=16]="TXT",r[r.AAAA=28]="AAAA"})(Aa||(Aa={}));function ene(r={}){return new Qte(r)}class tne{constructor(){f(this,"dns")}canResolve(e){return e.getComponents().some(({name:t})=>t==="dnsaddr")}async resolve(e,t){var c,l;const n=(c=e.getComponents().find(u=>u.name==="dnsaddr"))==null?void 0:c.value;if(n==null)return[e];const s=await this.getDNS(t).query(`_dnsaddr.${n}`,{signal:t==null?void 0:t.signal,types:[Aa.TXT]}),o=(l=e.getComponents().find(u=>u.name==="p2p"))==null?void 0:l.value,a=[];for(const u of s.Answer){const h=u.data.replace(/["']/g,"").trim().split("=")[1];h!=null&&(o!=null&&!h.includes(o)||a.push(pr(h)))}return a}getDNS(e){return e.dns!=null?e.dns:(this.dns==null&&(this.dns=ene()),this.dns)}}const NU=new tne;async function OU(r,e,t){const n=t.depth??0;if(n>(t.maxRecursiveDepth??Ite))throw new ute("Max recursive depth reached");let i=!1;const s=[];for(const o of Object.values(e))if(o.canResolve(r)){i=!0;const a=await o.resolve(r,t);for(const c of a)s.push(...await OU(c,e,{...t,depth:n+1}))}return i===!1&&s.push(r),s}const jh={maxParallelDials:xU,maxDialQueueLength:_U,maxPeerAddrsToDial:vU,dialTimeout:bU,resolvers:{dnsaddr:NU}};class nne{constructor(e,t={}){f(this,"queue");f(this,"components");f(this,"addressSorter");f(this,"maxPeerAddrsToDial");f(this,"maxDialQueueLength");f(this,"dialTimeout");f(this,"shutDownController");f(this,"connections");f(this,"log");f(this,"resolvers");this.addressSorter=t.addressSorter,this.maxPeerAddrsToDial=t.maxPeerAddrsToDial??jh.maxPeerAddrsToDial,this.maxDialQueueLength=t.maxDialQueueLength??jh.maxDialQueueLength,this.dialTimeout=t.dialTimeout??jh.dialTimeout,this.connections=t.connections??new wh,this.log=e.logger.forComponent("libp2p:connection-manager:dial-queue"),this.components=e,this.resolvers=t.resolvers??jh.resolvers,this.shutDownController=new AbortController,this.shutDownController.signal,this.queue=new aY({concurrency:t.maxParallelDials??jh.maxParallelDials,metricName:"libp2p_dial_queue",metrics:e.metrics}),this.queue.addEventListener("failure",n=>{var i;((i=n.detail)==null?void 0:i.error.name)!==Xq.name&&this.log.error("error in dial queue - %e",n.detail.error)})}start(){this.shutDownController=new AbortController,this.shutDownController.signal}stop(){this.shutDownController.abort(),this.queue.abort()}async dial(e,t={}){var o,a,c;const{peerId:n,multiaddrs:i}=mU(e);if(n!=null&&t.force!==!0){const l=yU(n,this.connections.get(n),i);if(l!=null)return this.log("already connected to %a",l.remoteAddr),(o=t.onProgress)==null||o.call(t,new Rt("dial-queue:already-connected")),l}const s=this.queue.queue.find(l=>{if((n==null?void 0:n.equals(l.options.peerId))===!0)return!0;const u=l.options.multiaddrs;if(u==null)return!1;for(const h of i)if(u.has(h.toString()))return!0;return!1});if(s!=null){this.log("joining existing dial target for %p",n);for(const l of i)s.options.multiaddrs.add(l.toString());return(a=t.onProgress)==null||a.call(t,new Rt("dial-queue:already-in-dial-queue")),s.join(t)}if(this.queue.size>=this.maxDialQueueLength)throw new cw("Dial queue is full");return this.log("creating dial target for %p",n,i.map(l=>l.toString())),(c=t.onProgress)==null||c.call(t,new Rt("dial-queue:add-to-dial-queue")),this.queue.add(async l=>{var h;(h=l.onProgress)==null||h.call(l,new Rt("dial-queue:start-dial"));const u=Bc([this.shutDownController.signal,l.signal]);try{return await this.dialPeer(l,u)}finally{u.clear()}},{peerId:n,priority:t.priority??UU,multiaddrs:new Set(i.map(l=>l.toString())),signal:t.signal??AbortSignal.timeout(this.dialTimeout),onProgress:t.onProgress})}async dialPeer(e,t){var u;const n=e.peerId,i=e.multiaddrs,s=new Set;let o=e.multiaddrs.size===0,a=0,c=0;const l=[];for(this.log("starting dial to %p",n);o||i.size>0;){c++,o=!1;const h=[],d=new Set(e.multiaddrs);i.clear(),this.log("calculating addrs to dial %p from %s",n,[...d]);const m=await this.calculateMultiaddrs(n,d,{...e,signal:t});for(const p of m){if(s.has(p.multiaddr.toString())){this.log.trace("skipping previously failed multiaddr %a while dialing %p",p.multiaddr,n);continue}h.push(p)}this.log("%s dial to %p with %s",c===1?"starting":"continuing",n,h.map(p=>p.multiaddr.toString())),(u=e==null?void 0:e.onProgress)==null||u.call(e,new Rt("dial-queue:calculated-addresses",h));for(const p of h){if(a===this.maxPeerAddrsToDial)throw this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others",a,e.peerId),new cw("Peer had more than maxPeerAddrsToDial");a++;try{const b=await this.components.transportManager.dial(p.multiaddr,{...e,signal:t});this.log("dial to %a succeeded",p.multiaddr);try{await this.components.peerStore.merge(b.remotePeer,{multiaddrs:[b.remoteAddr],metadata:{[Cte]:Se(Date.now().toString())}})}catch(g){this.log.error("could not update last dial failure key for %p - %e",n,g)}return b}catch(b){if(this.log.error("dial failed to %a - %e",p.multiaddr,b),s.add(p.multiaddr.toString()),n!=null)try{await this.components.peerStore.merge(n,{metadata:{[Tte]:Se(Date.now().toString())}})}catch(g){this.log.error("could not update last dial failure key for %p - %e",n,g)}if(t.aborted)throw new jq(b.message);l.push(b)}}}throw l.length===1?l[0]:new AggregateError(l,"All multiaddr dials failed")}async calculateMultiaddrs(e,t=new Set,n={}){var h,d;const i=[...t].map(m=>({multiaddr:pr(m),isCertified:!1}));if(e!=null){if(this.components.peerId.equals(e))throw new cw("Tried to dial self");if(await((d=(h=this.components.connectionGater).denyDialPeer)==null?void 0:d.call(h,e))===!0)throw new dC("The dial request is blocked by gater.allowDialPeer");if(i.length===0){this.log("loading multiaddrs for %p",e);try{const m=await this.components.peerStore.get(e);i.push(...m.addresses),this.log("loaded multiaddrs for %p",e,i.map(({multiaddr:p})=>p.toString()))}catch(m){if(m.name!=="NotFoundError")throw m}}if(i.length===0){this.log("looking up multiaddrs for %p in the peer routing",e);try{const m=await this.components.peerRouting.findPeer(e,n);this.log("found multiaddrs for %p in the peer routing",e,i.map(({multiaddr:p})=>p.toString())),i.push(...m.multiaddrs.map(p=>({multiaddr:p,isCertified:!1})))}catch(m){m.name==="NoPeerRoutersError"?this.log("no peer routers configured",e):this.log.error("looking up multiaddrs for %p in the peer routing failed - %e",e,m)}}}let s=(await Promise.all(i.map(async m=>{const p=await OU(m.multiaddr,this.resolvers,{dns:this.components.dns,log:this.log,...n});return p.length===1&&p[0].equals(m.multiaddr)?m:p.map(b=>({multiaddr:b,isCertified:!1}))}))).flat();if(e!=null){const m=`/p2p/${e.toString()}`;s=s.map(p=>{const b=p.multiaddr.getComponents().pop();return(b==null?void 0:b.name)!=="p2p"?{multiaddr:p.multiaddr.encapsulate(m),isCertified:p.isCertified}:p})}const o=s.filter(m=>{var b;if(this.components.transportManager.dialTransportForMultiaddr(m.multiaddr)==null)return!1;const p=(b=m.multiaddr.getComponents().findLast(g=>g.code===Is))==null?void 0:b.value;return e!=null&&p!=null?e.equals(p):!0}),a=new Map;for(const m of o){const p=m.multiaddr.toString(),b=a.get(p);if(b!=null){b.isCertified=b.isCertified||m.isCertified||!1;continue}a.set(p,m)}const c=[...a.values()];if(c.length===0)throw new ote("The dial request has no valid addresses");const l=[];for(const m of c)this.components.connectionGater.denyDialMultiaddr!=null&&await this.components.connectionGater.denyDialMultiaddr(m.multiaddr)||l.push(m);const u=this.addressSorter==null?Ute(l):l.sort(this.addressSorter);if(u.length===0)throw new dC("The connection gater denied all addresses in the dial request");return this.log.trace("addresses for %p before filtering",e??"unknown peer",s.map(({multiaddr:m})=>m.toString())),this.log.trace("addresses for %p after filtering",e??"unknown peer",u.map(({multiaddr:m})=>m.toString())),u}async isDialable(e,t={}){Array.isArray(e)||(e=[e]);try{const n=await this.calculateMultiaddrs(void 0,new Set(e.map(i=>i.toString())),t);return t.runOnLimitedConnection===!1?n.find(i=>!Qu.matches(i.multiaddr))!=null:!0}catch{}return!1}}const rne=Object.prototype.toString,ine=r=>rne.call(r)==="[object Error]",sne=new Set(["network error","Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Network request failed","fetch failed","terminated"," A network error occurred.","Network connection lost"]);function one(r){if(!(r&&ine(r)&&r.name==="TypeError"&&typeof r.message=="string"))return!1;const{message:t,stack:n}=r;return t==="Load failed"?n===void 0||"__sentry_captured__"in r:t.startsWith("error sending request for url")?!0:sne.has(t)}function ane(r){if(typeof r=="number"){if(r<0)throw new TypeError("Expected `retries` to be a non-negative number.");if(Number.isNaN(r))throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.")}else if(r!==void 0)throw new TypeError("Expected `retries` to be a number or Infinity.")}function Um(r,e,{min:t=0,allowInfinity:n=!1}={}){if(e!==void 0){if(typeof e!="number"||Number.isNaN(e))throw new TypeError(`Expected \`${r}\` to be a number${n?" or Infinity":""}.`);if(!n&&!Number.isFinite(e))throw new TypeError(`Expected \`${r}\` to be a finite number.`);if(e<t)throw new TypeError(`Expected \`${r}\` to be  ${t}.`)}}let cne=class extends Error{constructor(e){super(),e instanceof Error?(this.originalError=e,{message:e}=e):(this.originalError=new Error(e),this.originalError.stack=this.stack),this.name="AbortError",this.message=e}};function lne(r,e){const t=Math.max(1,r+1),n=e.randomize?Math.random()+1:1;let i=Math.round(n*e.minTimeout*e.factor**(t-1));return i=Math.min(i,e.maxTimeout),i}function yC(r,e){return Number.isFinite(e)?e-(performance.now()-r):e}async function une({error:r,attemptNumber:e,retriesConsumed:t,startTime:n,options:i}){var m,p,b;const s=r instanceof Error?r:new TypeError(`Non-error was thrown: "${r}". You should only throw errors.`);if(s instanceof cne)throw s.originalError;const o=Number.isFinite(i.retries)?Math.max(0,i.retries-t):i.retries,a=i.maxRetryTime??Number.POSITIVE_INFINITY,c=Object.freeze({error:s,attemptNumber:e,retriesLeft:o,retriesConsumed:t});if(await i.onFailedAttempt(c),yC(n,a)<=0)throw s;const l=await i.shouldConsumeRetry(c),u=yC(n,a);if(u<=0||o<=0)throw s;if(s instanceof TypeError&&!one(s)){if(l)throw s;return(m=i.signal)==null||m.throwIfAborted(),!1}if(!await i.shouldRetry(c))throw s;if(!l)return(p=i.signal)==null||p.throwIfAborted(),!1;const h=lne(t,i),d=Math.min(h,u);return d>0&&await new Promise((g,y)=>{var _,M;const v=()=>{var E;clearTimeout(w),(E=i.signal)==null||E.removeEventListener("abort",v),y(i.signal.reason)},w=setTimeout(()=>{var E;(E=i.signal)==null||E.removeEventListener("abort",v),g()},d);i.unref&&((_=w.unref)==null||_.call(w)),(M=i.signal)==null||M.addEventListener("abort",v,{once:!0})}),(b=i.signal)==null||b.throwIfAborted(),!0}async function hne(r,e={}){var s,o,a;if(e={...e},ane(e.retries),Object.hasOwn(e,"forever"))throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");e.retries??(e.retries=10),e.factor??(e.factor=2),e.minTimeout??(e.minTimeout=1e3),e.maxTimeout??(e.maxTimeout=Number.POSITIVE_INFINITY),e.maxRetryTime??(e.maxRetryTime=Number.POSITIVE_INFINITY),e.randomize??(e.randomize=!1),e.onFailedAttempt??(e.onFailedAttempt=()=>{}),e.shouldRetry??(e.shouldRetry=()=>!0),e.shouldConsumeRetry??(e.shouldConsumeRetry=()=>!0),Um("factor",e.factor,{min:0,allowInfinity:!1}),Um("minTimeout",e.minTimeout,{min:0,allowInfinity:!1}),Um("maxTimeout",e.maxTimeout,{min:0,allowInfinity:!0}),Um("maxRetryTime",e.maxRetryTime,{min:0,allowInfinity:!0}),e.factor>0||(e.factor=1),(s=e.signal)==null||s.throwIfAborted();let t=0,n=0;const i=performance.now();for(;!Number.isFinite(e.retries)||n<=e.retries;){t++;try{(o=e.signal)==null||o.throwIfAborted();const c=await r(t);return(a=e.signal)==null||a.throwIfAborted(),c}catch(c){await une({error:c,attemptNumber:t,retriesConsumed:n,startTime:i,options:e})&&n++}}throw new Error("Retry attempts exhausted without throwing an error.")}class dne{constructor(e,t={}){f(this,"log");f(this,"queue");f(this,"started");f(this,"peerStore");f(this,"retries");f(this,"retryInterval");f(this,"backoffFactor");f(this,"connectionManager");f(this,"events");this.log=e.logger.forComponent("libp2p:reconnect-queue"),this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.queue=new Z1({concurrency:t.maxParallelReconnects??Ate,metricName:"libp2p_reconnect_queue",metrics:e.metrics}),this.started=!1,this.retries=t.retries??5,this.backoffFactor=t.backoffFactor,this.retryInterval=t.retryInterval,this.events=e.events,e.events.addEventListener("peer:disconnect",n=>{this.maybeReconnect(n.detail).catch(i=>{this.log.error("failed to maybe reconnect to %p - %e",n.detail,i)})})}async maybeReconnect(e){if(!this.started)return;const t=await this.peerStore.get(e);bC(t)&&(this.queue.has(e)||this.queue.add(async n=>{await hne(async i=>{if(this.started)try{await this.connectionManager.openConnection(e,{signal:n==null?void 0:n.signal})}catch(s){throw this.log("reconnecting to %p attempt %d of %d failed - %e",e,i,this.retries,s),s}},{signal:n==null?void 0:n.signal,retries:this.retries,factor:this.backoffFactor,minTimeout:this.retryInterval})},{peerId:e}).catch(async n=>{this.log.error("failed to reconnect to %p - %e",e,n);const i={};[...t.tags.keys()].forEach(s=>{s.startsWith(RN)&&(i[s]=void 0)}),await this.peerStore.merge(e,{tags:i}),this.events.safeDispatchEvent("peer:reconnect-failure",{detail:e})}).catch(async n=>{this.log.error("failed to remove keep-alive tag from %p - %e",e,n)}))}start(){this.started=!0}async afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[t=>bC(t)]});await Promise.all(e.map(async t=>{await this.connectionManager.openConnection(t.id).catch(n=>{this.log.error("could not open connection to keepalive peer - %e",n)})}))}).catch(e=>{this.log.error("error reconnect to peers after start - %e",e)})}stop(){this.started=!1,this.queue.abort()}}function bC(r){for(const e of r.tags.keys())if(e.startsWith(RN))return!0;return!1}const UU=50,Tw={maxConnections:Pte,inboundConnectionThreshold:Ete,maxIncomingPendingConnections:Mte};var cR;cR=Symbol.toStringTag;class fne{constructor(e,t={}){f(this,"started");f(this,"connections");f(this,"allow");f(this,"deny");f(this,"maxIncomingPendingConnections");f(this,"incomingPendingConnections");f(this,"outboundPendingConnections");f(this,"maxConnections");f(this,"dialQueue");f(this,"reconnectQueue");f(this,"connectionPruner");f(this,"inboundConnectionRateLimiter");f(this,"peerStore");f(this,"metrics");f(this,"events");f(this,"log");f(this,"peerId");f(this,cR,"@libp2p/connection-manager");var n;if(this.maxConnections=t.maxConnections??Tw.maxConnections,this.maxConnections<1)throw new ai("Connection Manager maxConnections must be greater than 0");this.connections=new wh,this.started=!1,this.peerId=e.peerId,this.peerStore=e.peerStore,this.metrics=e.metrics,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager"),this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.allow=(t.allow??[]).map(i=>wS(pr(i))),this.deny=(t.deny??[]).map(i=>wS(pr(i))),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=t.maxIncomingPendingConnections??Tw.maxIncomingPendingConnections,this.outboundPendingConnections=0,this.inboundConnectionRateLimiter=new cY({points:t.inboundConnectionThreshold??Tw.inboundConnectionThreshold,duration:1}),this.connectionPruner=new xte({connectionManager:this,peerStore:e.peerStore,events:e.events,logger:e.logger},{allow:(n=t.allow)==null?void 0:n.map(i=>pr(i))}),this.dialQueue=new nne(e,{addressSorter:t.addressSorter,maxParallelDials:t.maxParallelDials??xU,maxDialQueueLength:t.maxDialQueueLength??_U,maxPeerAddrsToDial:t.maxPeerAddrsToDial??vU,dialTimeout:t.dialTimeout??bU,resolvers:t.resolvers??{dnsaddr:NU},connections:this.connections}),this.reconnectQueue=new dne({events:e.events,peerStore:e.peerStore,logger:e.logger,connectionManager:this},{retries:t.reconnectRetries,retryInterval:t.reconnectRetryInterval,backoffFactor:t.reconnectBackoffFactor,maxParallelReconnects:t.maxParallelReconnects})}async start(){var e,t,n;(e=this.metrics)==null||e.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const i={inbound:0,"inbound pending":this.incomingPendingConnections,outbound:0,"outbound pending":this.outboundPendingConnections};for(const s of this.connections.values())for(const o of s)i[o.direction]++;return i}}),(t=this.metrics)==null||t.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const i={};for(const s of this.connections.values())for(const o of s)for(const a of o.streams){const c=`${a.direction} ${a.protocol??"unnegotiated"}`;i[c]=(i[c]??0)+1}return i}}),(n=this.metrics)==null||n.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const i={};for(const o of this.connections.values())for(const a of o){const c={};for(const l of a.streams){const u=`${l.direction} ${l.protocol??"unnegotiated"}`;c[u]=(c[u]??0)+1}for(const[l,u]of Object.entries(c))i[l]=i[l]??[],i[l].push(u)}const s={};for(let[o,a]of Object.entries(i)){a=a.sort((l,u)=>l-u);const c=Math.floor(a.length*.9);s[o]=a[c]}return s}}),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),await rK(this.dialQueue,this.reconnectQueue,this.connectionPruner),this.started=!0,this.log("started")}async stop(){this.events.removeEventListener("connection:open",this.onConnect),this.events.removeEventListener("connection:close",this.onDisconnect),await iK(this.reconnectQueue,this.dialQueue,this.connectionPruner);const e=[];for(const t of this.connections.values())for(const n of t)e.push(Promise.all([Dn(n,"close",{signal:AbortSignal.timeout(500)}),n.close({signal:AbortSignal.timeout(500)})]).catch(i=>{n.abort(i)}));this.log("closing %d connections",e.length),await Promise.all(e),this.connections.clear(),this.log("stopped")}getMaxConnections(){return this.maxConnections}setMaxConnections(e){if(this.maxConnections<1)throw new ai("Connection Manager maxConnections must be greater than 0");let t=!1;e<this.maxConnections&&(t=!0),this.maxConnections=e,t&&this.connectionPruner.maybePruneConnections()}onConnect(e){this._onConnect(e).catch(t=>{this.log.error("could not connect - %e",t)})}async _onConnect(e){const{detail:t}=e;if(!this.started){await t.close();return}if(t.status!=="open")return;const n=t.remotePeer,i=!this.connections.has(n),s=this.connections.get(n)??[];s.push(t),this.connections.set(n,s),n.publicKey!=null&&n.type==="RSA"&&await this.peerStore.patch(n,{publicKey:n.publicKey}),i&&this.events.safeDispatchEvent("peer:connect",{detail:t.remotePeer})}onDisconnect(e){const{detail:t}=e,n=t.remotePeer,s=(this.connections.get(n)??[]).filter(o=>o.id!==t.id);this.connections.set(n,s),s.length===0&&(this.log.trace("peer %p disconnected, removing connection map entry",n),this.connections.delete(n),this.events.safeDispatchEvent("peer:disconnect",{detail:n}))}getConnections(e){if(e!=null)return this.connections.get(e)??[];let t=[];for(const n of this.connections.values())t=t.concat(n);return t}getConnectionsMap(){return this.connections}async openConnection(e,t={}){var n,i;if(!this.started)throw new ey("Not started");this.outboundPendingConnections++;try{(n=t.signal)==null||n.throwIfAborted();const{peerId:s,multiaddrs:o}=mU(e);if(this.peerId.equals(s))throw new O1("Can not dial self");if(s!=null&&t.force!==!0){this.log("dial %p",s);const u=yU(s,this.getConnections(s),o);if(u!=null)return this.log("had an existing connection to %p as %a",s,u.remoteAddr),(i=t.onProgress)==null||i.call(t,new Rt("dial-queue:already-connected")),u}const a=await this.dialQueue.dial(e,{...t,priority:t.priority??UU});if(a.status!=="open")throw new Qg("Remote closed connection during opening");let c=this.connections.get(a.remotePeer);c==null&&(c=[],this.connections.set(a.remotePeer,c));let l=!1;for(const u of c)if(u.id===a.id&&(l=!0),t.force!==!0&&u.id!==a.id&&u.remoteAddr.equals(a.remoteAddr))return a.abort(new U1("Duplicate multiaddr connection")),u;return l||c.push(a),a}finally{this.outboundPendingConnections--}}async openStream(e,t,n={}){return(await this.openConnection(e,n)).newStream(t,n)}async closeConnections(e,t={}){const n=this.connections.get(e)??[];await Promise.all(n.map(async i=>{try{await Promise.all([Dn(i,"close",t),i.close(t)])}catch(s){i.abort(s)}}))}acceptIncomingConnection(e){if(this.deny.some(i=>{if(Zi(e.remoteAddr)){const s=zt(e.remoteAddr);return i.contains(s.host)}return!1}))return this.log("connection from %a refused - connection remote address was in deny list",e.remoteAddr),!1;if(this.allow.some(i=>{if(Zi(e.remoteAddr)){const s=zt(e.remoteAddr);return i.contains(s.host)}return!0}))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return this.log("connection from %a refused - incomingPendingConnections exceeded by host",e.remoteAddr),!1;if(Zi(e.remoteAddr)){const i=zt(e.remoteAddr);try{this.inboundConnectionRateLimiter.consume(i.host,1)}catch{return this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s",e.remoteAddr,i.host),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(this.log("connection from %a refused - maxConnections exceeded",e.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){const e={queued:"queued",running:"active",errored:"error",complete:"success"};return this.dialQueue.queue.queue.map(t=>({id:t.id,status:e[t.status],peerId:t.options.peerId,multiaddrs:[...t.options.multiaddrs].map(n=>pr(n))}))}async isDialable(e,t={}){return this.dialQueue.isDialable(e,t)}}const pne=1e4,mne="1.0.0",gne="ping",yne="ipfs",wC=32,bne=!0;var lR,uR;uR=Symbol.toStringTag,lR=sS;class wne{constructor(e,t={}){f(this,"protocol");f(this,"components");f(this,"log");f(this,"heartbeatInterval");f(this,"pingIntervalMs");f(this,"abortController");f(this,"timeout");f(this,"abortConnectionOnPingFailure");f(this,uR,"@libp2p/connection-monitor");f(this,lR,["@libp2p/connection-monitor"]);this.components=e,this.protocol=`/${t.protocolPrefix??yne}/${gne}/${mne}`,this.log=e.logger.forComponent("libp2p:connection-monitor"),this.pingIntervalMs=t.pingInterval??pne,this.abortConnectionOnPingFailure=t.abortConnectionOnPingFailure??bne,this.timeout=new GX({...t.pingTimeout??{},metrics:e.metrics,metricName:"libp2p_connection_monitor_ping_time_milliseconds"})}start(){this.abortController=new AbortController,this.abortController.signal,this.heartbeatInterval=setInterval(()=>{this.components.connectionManager.getConnections().forEach(e=>{Promise.resolve().then(async()=>{var n;let t=Date.now();try{const i=this.timeout.getTimeoutSignal({signal:(n=this.abortController)==null?void 0:n.signal}),s=await e.newStream(this.protocol,{signal:i,runOnLimitedConnection:!0}),o=oO(s);t=Date.now(),await Promise.all([o.write(D1(wC),{signal:i}),o.read({bytes:wC,signal:i})]),e.rtt=Date.now()-t,await s.close({signal:i})}catch(i){if(i.name!=="UnsupportedProtocolError")throw i;e.rtt=(Date.now()-t)/2}}).catch(t=>{this.log.error("error during heartbeat - %e",t),this.abortConnectionOnPingFailure?(this.log.error("aborting connection due to ping failure"),e.abort(t)):this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag")})})},this.pingIntervalMs)}stop(){var e;(e=this.abortController)==null||e.abort(),this.heartbeatInterval!=null&&clearInterval(this.heartbeatInterval)}}var hR;hR=Symbol.toStringTag;class vne{constructor(e,t){f(this,"routers");f(this,"started");f(this,"components");f(this,hR,"@libp2p/content-routing");var n,i,s,o,a;this.routers=t.routers??[],this.started=!1,this.components=e,this.findProviders=((n=e.metrics)==null?void 0:n.traceFunction("libp2p.contentRouting.findProviders",this.findProviders.bind(this),{optionsIndex:1,getAttributesFromArgs:([c],l)=>({...l,cid:c.toString()}),getAttributesFromYieldedValue:(c,l)=>({...l,providers:[...Array.isArray(l.providers)?l.providers:[],c.id.toString()]})}))??this.findProviders,this.provide=((i=e.metrics)==null?void 0:i.traceFunction("libp2p.contentRouting.provide",this.provide.bind(this),{optionsIndex:1,getAttributesFromArgs:([c],l)=>({...l,cid:c.toString()})}))??this.provide,this.cancelReprovide=((s=e.metrics)==null?void 0:s.traceFunction("libp2p.contentRouting.cancelReprovide",this.cancelReprovide.bind(this),{optionsIndex:1,getAttributesFromArgs:([c],l)=>({...l,cid:c.toString()})}))??this.cancelReprovide,this.put=((o=e.metrics)==null?void 0:o.traceFunction("libp2p.contentRouting.put",this.put.bind(this),{optionsIndex:2,getAttributesFromArgs:([c])=>({key:ae(c,"base36")})}))??this.put,this.get=((a=e.metrics)==null?void 0:a.traceFunction("libp2p.contentRouting.get",this.get.bind(this),{optionsIndex:1,getAttributesFromArgs:([c])=>({key:ae(c,"base36")})}))??this.get}isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(e,t={}){if(this.routers.length===0)throw new Ew("No content routers available");const n=this,i=new GN;for await(const s of lS(...n.routers.filter(o=>o.findProviders instanceof Function).map(o=>o.findProviders(e,t))))s!=null&&(s.multiaddrs.length>0&&await this.components.peerStore.merge(s.id,{multiaddrs:s.multiaddrs},t),!i.has(s.id)&&(i.add(s.id),yield s))}async provide(e,t={}){if(this.routers.length===0)throw new Ew("No content routers available");await Promise.all(this.routers.filter(n=>n.provide instanceof Function).map(async n=>{await n.provide(e,t)}))}async cancelReprovide(e,t={}){if(this.routers.length===0)throw new Ew("No content routers available");await Promise.all(this.routers.filter(n=>n.cancelReprovide instanceof Function).map(async n=>{await n.cancelReprovide(e,t)}))}async put(e,t,n){if(!this.isStarted())throw new ey;await Promise.all(this.routers.filter(i=>i.put instanceof Function).map(async i=>{await i.put(e,t,n)}))}async get(e,t){if(!this.isStarted())throw new ey;return Promise.any(this.routers.filter(n=>n.get instanceof Function).map(async n=>n.get(e,t)))}}const km=globalThis.CustomEvent??Event;async function*_ne(r,e={}){let t=e.concurrency??1/0;t<1&&(t=1/0);const n=e.ordered??!1,i=new EventTarget,s=[];let o=mi(),a=mi(),c=!1,l,u=!1;i.addEventListener("task-complete",()=>{a.resolve()}),Promise.resolve().then(async()=>{try{for await(const p of r){if(s.length===t&&(o=mi(),await o.promise),u)break;const b={done:!1};s.push(b),p().then(g=>{b.done=!0,b.ok=!0,b.value=g,i.dispatchEvent(new km("task-complete"))},g=>{b.done=!0,b.err=g,i.dispatchEvent(new km("task-complete"))})}c=!0,i.dispatchEvent(new km("task-complete"))}catch(p){l=p,i.dispatchEvent(new km("task-complete"))}});function h(){var p;return n?(p=s[0])==null?void 0:p.done:!!s.find(b=>b.done)}function*d(){for(;s.length>0&&s[0].done;){const p=s[0];if(s.shift(),p.ok)yield p.value;else throw u=!0,o.resolve(),p.err;o.resolve()}}function*m(){for(;h();)for(let p=0;p<s.length;p++)if(s[p].done){const b=s[p];if(s.splice(p,1),p--,b.ok)yield b.value;else throw u=!0,o.resolve(),b.err;o.resolve()}}for(;;){if(h()||(a=mi(),await a.promise),l!=null||(n?yield*d():yield*m(),l!=null))throw l;if(c&&s.length===0)break}}var dR;dR=Symbol.toStringTag;class xne{constructor(e,t={}){f(this,"log");f(this,"peerId");f(this,"peerStore");f(this,"routers");f(this,dR,"@libp2p/peer-routing");var n,i;this.log=e.logger.forComponent("libp2p:peer-routing"),this.peerId=e.peerId,this.peerStore=e.peerStore,this.routers=t.routers??[],this.findPeer=((n=e.metrics)==null?void 0:n.traceFunction("libp2p.peerRouting.findPeer",this.findPeer.bind(this),{optionsIndex:1,getAttributesFromArgs:([s],o)=>({...o,peer:s.toString()})}))??this.findPeer,this.getClosestPeers=((i=e.metrics)==null?void 0:i.traceFunction("libp2p.peerRouting.getClosestPeers",this.getClosestPeers.bind(this),{optionsIndex:1,getAttributesFromArgs:([s],o)=>({...o,key:ae(s,"base36")}),getAttributesFromYieldedValue:(s,o)=>({...o,peers:[...Array.isArray(o.peers)?o.peers:[],s.id.toString()]})}))??this.getClosestPeers}async findPeer(e,t){if(this.routers.length===0)throw new hC("No peer routers available");if(e.toString()===this.peerId.toString())throw new tte("Should not try to find self");const n=this,i=lS(...this.routers.filter(s=>s.findPeer instanceof Function).map(s=>(async function*(){try{yield await s.findPeer(e,t)}catch(o){n.log.error("router failed to find peer - %e",o)}})()));for await(const s of i)if(s!=null)return s.multiaddrs.length>0&&await this.peerStore.merge(s.id,{multiaddrs:s.multiaddrs},t),s;throw new Yq}async*getClosestPeers(e,t={}){if(this.routers.length===0)throw new hC("No peer routers available");const n=this,i=mf(1024);for await(const s of _ne((async function*(){const o=lS(...n.routers.filter(a=>a.getClosestPeers instanceof Function).map(a=>a.getClosestPeers(e,t)));for await(let a of o)yield async()=>{if(a.multiaddrs.length===0)try{a=await n.findPeer(a.id,{...t,useCache:!1})}catch(c){n.log.error("could not find peer multiaddrs - %e",c);return}return a}})()))s!=null&&(s.multiaddrs.length>0&&await this.peerStore.merge(s.id,{multiaddrs:s.multiaddrs},t),!i.has(s.id.toMultihash().bytes)&&(i.add(s.id.toMultihash().bytes),yield s))}}var fR,pR;class Sne extends(pR=Pr,fR=Symbol.toStringTag,pR){constructor(t){super();f(this,"peerRouting");f(this,"log");f(this,"walking");f(this,"walkers");f(this,"shutdownController");f(this,"walkController");f(this,"needNext");f(this,fR,"@libp2p/random-walk");this.log=t.logger.forComponent("libp2p:random-walk"),this.peerRouting=t.peerRouting,this.walkers=0,this.walking=!1,this.shutdownController=new AbortController,this.shutdownController.signal}start(){this.shutdownController=new AbortController,this.shutdownController.signal}stop(){this.shutdownController.abort()}async*walk(t){var i,s;this.walking||this.startWalk(),this.walkers++;const n=Bc([this.shutdownController.signal,t==null?void 0:t.signal]);try{for(;;)(i=this.needNext)==null||i.resolve(),this.needNext=mi(),yield(await Dn(this,"walk:peer",{signal:n,rejectionEvents:["walk:error"]})).detail}catch(o){throw o.detail!=null?o.detail:o}finally{n.clear(),this.walkers--,this.walkers===0&&((s=this.walkController)==null||s.abort(),this.walkController=void 0)}}startWalk(){this.walking=!0,this.walkController=new AbortController,this.walkController.signal;const t=Bc([this.walkController.signal,this.shutdownController.signal]),n=Date.now();let i=0;Promise.resolve().then(async()=>{for(this.log("start walk");this.walkers>0;)try{const s=D1(32);let o=Date.now();for await(const a of this.peerRouting.getClosestPeers(s,{signal:t}))t.aborted&&this.log("aborting walk"),t.throwIfAborted(),this.log("found peer %p after %dms for %d walkers",a.id,Date.now()-o,this.walkers),i++,this.safeDispatchEvent("walk:peer",{detail:a}),this.walkers===1&&this.needNext!=null&&(this.log("wait for need next"),await rs(this.needNext.promise,t)),o=Date.now();this.log("walk iteration for %b and %d walkers finished, found %d peers",s,this.walkers,i)}catch(s){this.log.error("random walk errored - %e",s),this.safeDispatchEvent("walk:error",{detail:s})}this.log("no walkers left, ended walk")}).catch(s=>{this.log.error("random walk errored - %e",s)}).finally(()=>{this.log("finished walk, found %d peers after %dms",i,Date.now()-n),this.walking=!1})}}const kU=32,BU=64;var mR;mR=Symbol.toStringTag;class Ene{constructor(e){f(this,"log");f(this,"topologies");f(this,"handlers");f(this,"components");f(this,"middleware");f(this,mR,"@libp2p/registrar");var t;this.components=e,this.log=e.logger.forComponent("libp2p:registrar"),this.middleware=new Map,this.topologies=new Map,(t=e.metrics)==null||t.registerMetricGroup("libp2p_registrar_topologies",{calculate:()=>{const n={};for(const[i,s]of this.topologies)n[i]=s.size;return n}}),this.handlers=Po({name:"libp2p_registrar_protocol_handlers",metrics:e.metrics}),this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onPeerIdentify=this._onPeerIdentify.bind(this),this.components.events.addEventListener("peer:disconnect",this._onDisconnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate),this.components.events.addEventListener("peer:identify",this._onPeerIdentify)}getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(e){const t=this.handlers.get(e);if(t==null)throw new nte(`No handler registered for protocol ${e}`);return t}getTopologies(e){const t=this.topologies.get(e);return t==null?[]:[...t.values()]}async handle(e,t,n){if(this.handlers.has(e)&&(n==null?void 0:n.force)!==!0)throw new rte(`Handler already registered for protocol ${e}`);this.handlers.set(e,{handler:t,options:{maxInboundStreams:kU,maxOutboundStreams:BU,...n}}),await this.components.peerStore.merge(this.components.peerId,{protocols:[e]},n)}async unhandle(e,t){(Array.isArray(e)?e:[e]).forEach(i=>{this.handlers.delete(i)}),await this.components.peerStore.patch(this.components.peerId,{protocols:this.getProtocols()},t)}async register(e,t){if(t==null)throw new ai("invalid topology");const n=`${(Math.random()*1e9).toString(36)}${Date.now()}`;let i=this.topologies.get(e);return i==null&&(i=new Map,this.topologies.set(e,i)),i.set(n,t),n}unregister(e){for(const[t,n]of this.topologies.entries())n.has(e)&&(n.delete(e),n.size===0&&this.topologies.delete(t))}use(e,t){this.middleware.set(e,t)}unuse(e){this.middleware.delete(e)}getMiddleware(e){return this.middleware.get(e)??[]}async _onDisconnect(e){const t=e.detail,n={signal:AbortSignal.timeout(5e3)};try{const i=await this.components.peerStore.get(t,n);for(const s of i.protocols){const o=this.topologies.get(s);o!=null&&await Promise.all([...o.values()].map(async a=>{var c,l,u;((c=a.filter)==null?void 0:c.has(t))!==!1&&((l=a.filter)==null||l.remove(t),await((u=a.onDisconnect)==null?void 0:u.call(a,t)))}))}}catch(i){if(i.name==="NotFoundError")return;this.log.error("could not inform topologies of disconnecting peer %p - %e",t,i)}}async _onPeerUpdate(e){const{peer:t,previous:n}=e.detail,i=((n==null?void 0:n.protocols)??[]).filter(s=>!t.protocols.includes(s));try{for(const s of i){const o=this.topologies.get(s);o!=null&&await Promise.all([...o.values()].map(async a=>{var c,l,u;((c=a.filter)==null?void 0:c.has(t.id))!==!1&&((l=a.filter)==null||l.remove(t.id),await((u=a.onDisconnect)==null?void 0:u.call(a,t.id)))}))}}catch(s){this.log.error("could not inform topologies of updated peer %p - %e",t.id,s)}}async _onPeerIdentify(e){const t=e.detail.protocols,n=e.detail.connection,i=e.detail.peerId;try{for(const s of t){const o=this.topologies.get(s);o!=null&&await Promise.all([...o.values()].map(async a=>{var c,l,u;n.limits!=null&&a.notifyOnLimitedConnection!==!0||((c=a.filter)==null?void 0:c.has(i))!==!0&&((l=a.filter)==null||l.add(i),await((u=a.onConnect)==null?void 0:u.call(a,i,n)))}))}}catch(s){this.log.error("could not inform topologies of updated peer after identify %p - %e",i,s)}}}var gR;gR=Symbol.toStringTag;class Mne{constructor(e,t={}){f(this,"log");f(this,"components");f(this,"transports");f(this,"listeners");f(this,"faultTolerance");f(this,"started");f(this,gR,"@libp2p/transport-manager");this.log=e.logger.forComponent("libp2p:transports"),this.components=e,this.started=!1,this.transports=Po({name:"libp2p_transport_manager_transports",metrics:this.components.metrics}),this.listeners=Po({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=t.faultTolerance??ty.FATAL_ALL}add(e){const t=e[Symbol.toStringTag];if(t==null)throw new ai("Transport must have a valid tag");if(this.transports.has(t))throw new ai(`There is already a transport with the tag ${t}`);this.log("adding transport %s",t),this.transports.set(t,e),this.listeners.has(t)||this.listeners.set(t,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const e=this.components.addressManager.getListenAddrs();await this.listen(e)}async stop(){const e=[];for(const[t,n]of this.listeners)for(this.log("closing listeners for %s",t);n.length>0;){const i=n.pop();i!=null&&e.push(i.close())}await Promise.all(e),this.log("all listeners closed");for(const t of this.listeners.keys())this.listeners.set(t,[]);this.started=!1}async dial(e,t){var i;const n=this.dialTransportForMultiaddr(e);if(n==null)throw new lte(`No transport available for address ${String(e)}`);return(i=t==null?void 0:t.onProgress)==null||i.call(t,new Rt("transport-manager:selected-transport",n[Symbol.toStringTag])),n.dial(e,{...t,upgrader:this.components.upgrader})}getAddrs(){let e=[];for(const t of this.listeners.values())for(const n of t)e=[...e,...n.getAddrs()];return e}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}dialTransportForMultiaddr(e){for(const t of this.transports.values())if(t.dialFilter([e]).length>0)return t}listenTransportForMultiaddr(e){for(const t of this.transports.values())if(t.listenFilter([e]).length>0)return t}async listen(e){if(!this.isStarted())throw new ey("Not started");if(e==null||e.length===0){this.log("no addresses were provided for listening, this node is dial only");return}const t={errors:new Map,ipv4:{success:0,attempts:0},ipv6:{success:0,attempts:0}};e.forEach(s=>{t.errors.set(s.toString(),new ite)});const n=[];for(const[s,o]of this.transports.entries()){const a=o.listenFilter(e);for(const c of a){this.log("creating listener for %s on %a",s,c);const l=o.createListener({upgrader:this.components.upgrader});let u=this.listeners.get(s)??[];u==null&&(u=[],this.listeners.set(s,u)),u.push(l),l.addEventListener("listening",()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:l})}),l.addEventListener("close",()=>{const h=u.findIndex(d=>d===l);u.splice(h,1),this.components.events.safeDispatchEvent("transport:close",{detail:l})}),rC.matches(c)?t.ipv4.attempts++:iC.matches(c)&&t.ipv6.attempts++,n.push(l.listen(c).then(()=>{t.errors.delete(c.toString()),rC.matches(c)&&t.ipv4.success++,iC.matches(c)&&t.ipv6.success++},h=>{throw this.log.error("transport %s could not listen on address %a - %e",s,c,h),t.errors.set(c.toString(),h),h}))}}const i=await Promise.allSettled(n);if(!(i.length>0&&i.every(s=>s.status==="fulfilled"))){if(this.ipv6Unsupported(t)){this.log("all IPv4 addresses succeed but all IPv6 failed");return}if(this.faultTolerance===ty.NO_FATAL){this.log("failed to listen on any address but fault tolerance allows this");return}throw new ste(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[...t.errors.entries()].map(([s,o])=>`
  ${s}: ${`${Ane(o)}`.split(`
`).join(`
  `)}
`).join("")}`)}}ipv6Unsupported(e){if(e.ipv4.attempts===0||e.ipv6.attempts===0)return!1;const t=e.ipv4.attempts===e.ipv4.success,n=e.ipv6.success===0;return t&&n}async remove(e){const t=this.listeners.get(e)??[];this.log.trace("removing transport %s",e);const n=[];for(this.log.trace("closing listeners for %s",e);t.length>0;){const i=t.pop();i!=null&&n.push(i.close())}await Promise.all(n),this.transports.delete(e),this.listeners.delete(e)}async removeAll(){const e=[];for(const t of this.transports.keys())e.push(this.remove(t));await Promise.all(e)}}function Ane(r){return r.stack!=null&&r.stack.trim()!==""?r.stack:r.message!=null?r.message:r.toString()}const dc="/multistream/1.0.0",FU=1024;class $U extends Error{constructor(e="Unsupported protocol error"){super(e),this.name="UnsupportedProtocolError"}}f($U,"name","UnsupportedProtocolError");var o_;let Tne=(o_=class extends Error{constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}},f(o_,"name","InvalidMessageError"),o_);const Cne=Se(`
`);async function MS(r,e){const n=(await r.read(e)).subarray();if(n.byteLength===0||n[n.length-1]!==Cne[0])throw new Tne("Missing newline");return ae(n).trimEnd()}async function AS(r,e,t={}){if(e=Array.isArray(e)?[...e]:[e],e.length===0)throw new Error("At least one protocol must be specified");const n=r.log.newScope("mss:select"),i=bf(r,{...t,maxDataLength:FU});for(let s=0;s<e.length;s++){const o=e[s];let a;if(s===0){n.trace('write ["%s", "%s"]',dc,o);const c=Se(`${dc}
`),l=Se(`${o}
`);if(await i.writeV([c,l],t),n.trace("reading multistream-select header"),a=await MS(i,t),n.trace('read "%s"',a),a!==dc){n.error("did not read multistream-select header from response");break}}else n.trace('write "%s"',o),await i.write(Se(`${o}
`),t);if(n.trace("reading protocol response"),a=await MS(i,t),n.trace('read "%s"',a),a===o)return n.trace('selected "%s" after negotiation',a),i.unwrap(),o}throw new $U(`Protocol selection failed - could not negotiate ${e}`)}const zU=1024*1024*4;let Ine=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidDataLengthError");f(this,"code","ERR_MSG_DATA_TOO_LONG")}};function Pne(r){return r[Symbol.asyncIterator]!=null}function VU(r,e){if(r.byteLength>e)throw new Ine("Message length too long")}const V0=r=>{const e=Ue(r),t=ns(e);return Zl(r,t),V0.bytes=e,t};V0.bytes=0;function HU(r,e){e=e??{};const t=e.lengthEncoder??V0,n=(e==null?void 0:e.maxDataLength)??zU;function*i(s){VU(s,n);const o=t(s.byteLength);o instanceof Uint8Array?yield o:yield*o,s instanceof Uint8Array?yield s:yield*s}return Pne(r)?(async function*(){for await(const s of r)yield*i(s)})():(function*(){for(const s of r)yield*i(s)})()}HU.single=(r,e)=>{e=e??{};const t=e.lengthEncoder??V0,n=(e==null?void 0:e.maxDataLength)??zU;return VU(r,n),new vt(t(r.byteLength),r)};var vC;(function(r){r[r.LENGTH=0]="LENGTH",r[r.DATA=1]="DATA"})(vC||(vC={}));async function TS(r,e,t={}){e=Array.isArray(e)?e:[e];const n=r.log.newScope("mss:handle"),i=bf(r,{...t,maxDataLength:FU,maxLengthLength:2});for(;;){n.trace("reading incoming string");const s=await MS(i,t);if(n.trace('read "%s"',s),s===dc){n.trace('respond with "%s" for "%s"',dc,s),await i.write(Se(`${dc}
`),t),n.trace('responded with "%s" for "%s"',dc,s);continue}if(e.includes(s))return n.trace('respond with "%s" for "%s"',s,s),await i.write(Se(`${s}
`),t),n.trace('responded with "%s" for "%s"',s,s),i.unwrap(),s;if(s==="ls"){const o=new vt(...e.map(a=>HU.single(Se(`${a}
`))),Se(`
`));n.trace('respond with "%s" for %s',e,s),await i.write(o,t),n.trace('responded with "%s" for %s',e,s);continue}n.trace('respond with "na" for "%s"',s),await i.write(Se(`na
`),t),n('responded with "na" for "%s"',s)}}var yR,bR,wR;class Rne extends(wR=Pr,bR=Symbol.toStringTag,yR=Kq,wR){constructor(t,n){super();f(this,"id");f(this,"remoteAddr");f(this,"remotePeer");f(this,"direction");f(this,"timeline");f(this,"direct");f(this,"multiplexer");f(this,"encryption");f(this,"limits");f(this,"log");f(this,"maConn");f(this,"muxer");f(this,"components");f(this,"outboundStreamProtocolNegotiationTimeout");f(this,"inboundStreamProtocolNegotiationTimeout");f(this,"closeTimeout");f(this,bR,"Connection");f(this,yR,!0);f(this,"newStream",async(t,n={})=>{var s;if(this.muxer==null)throw new Sg("Connection is not multiplexed");if(this.muxer.status!=="open")throw new Qg(`The connection muxer is "${this.muxer.status}" and not "open"`);if(this.maConn.status!=="open")throw new Qg(`The connection is "${this.status}" and not "open"`);if(this.limits!=null&&(n==null?void 0:n.runOnLimitedConnection)!==!0)throw new iS("Cannot open protocol stream on limited connection");Array.isArray(t)||(t=[t]),this.log.trace("starting new stream for protocols %s",t);const i=await this.muxer.createStream({...n,protocol:t.length===1?t[0]:void 0});this.log.trace("started new stream %s for protocols %s",i.id,t);try{if(n.signal==null){i.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout",t);const l=AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);n={...n,signal:l}}i.protocol===""?(i.log.trace("selecting protocol from protocols %s",t),i.protocol=await AS(i,t,n),i.log("negotiated protocol %s",i.protocol)):i.log("pre-negotiated protocol %s",i.protocol);const o=Nne(i.protocol,this.components.registrar,n),a=_C(i.protocol,"outbound",this);if(a>o){const l=new Qq(`Too many outbound protocol streams for protocol "${i.protocol}" - ${a}/${o}`);throw i.abort(l),l}await this.components.peerStore.merge(this.remotePeer,{protocols:[i.protocol]}),(s=this.components.metrics)==null||s.trackProtocolStream(i);const c=this.components.registrar.getMiddleware(i.protocol);return await this.runMiddlewareChain(i,this,c)}catch(o){throw i.status==="open"?i.abort(o):this.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e",this.direction==="inbound"?"from":"to",this.remoteAddr,t,o),o}});this.components=t,this.id=n.id,this.remoteAddr=n.maConn.remoteAddr,this.remotePeer=n.remotePeer,this.direction=n.direction??"outbound",this.timeline=n.maConn.timeline,this.encryption=n.cryptoProtocol,this.limits=n.limits,this.maConn=n.maConn,this.log=n.maConn.log,this.outboundStreamProtocolNegotiationTimeout=n.outboundStreamProtocolNegotiationTimeout??fy,this.inboundStreamProtocolNegotiationTimeout=n.inboundStreamProtocolNegotiationTimeout??fy,this.closeTimeout=n.closeTimeout??wU,this.direct=gU(n.maConn.remoteAddr),this.onIncomingStream=this.onIncomingStream.bind(this),this.remoteAddr.getComponents().find(i=>i.code===Is)==null&&(this.remoteAddr=this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)),n.muxer!=null&&(this.multiplexer=n.muxer.protocol,this.muxer=n.muxer,this.muxer.addEventListener("stream",this.onIncomingStream)),this.maConn.addEventListener("close",i=>{this.dispatchEvent(new tK(i.local,i.error))})}get streams(){var t;return((t=this.muxer)==null?void 0:t.streams)??[]}get status(){return this.maConn.status}async onIncomingStream(t){var s;const n=t.detail,i=AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout);n.log("start protocol negotiation, timing out after %dms",this.inboundStreamProtocolNegotiationTimeout);try{if(n.protocol===""){const h=this.components.registrar.getProtocols();n.log.trace("selecting protocol from protocols %s",h),n.protocol=await TS(n,h,{signal:i}),n.log("negotiated protocol %s",n.protocol)}else n.log("pre-negotiated protocol %s",n.protocol);const o=Lne(n.protocol,this.components.registrar);if(_C(n.protocol,"inbound",this)>o)throw new PN(`Too many inbound protocol streams for protocol "${n.protocol}" - limit ${o}`);await this.components.peerStore.merge(this.remotePeer,{protocols:[n.protocol]},{signal:i}),(s=this.components.metrics)==null||s.trackProtocolStream(n);const{handler:c,options:l}=this.components.registrar.getHandler(n.protocol);if(this.limits!=null&&l.runOnLimitedConnection!==!0)throw new iS("Cannot open protocol stream on limited connection");const u=this.components.registrar.getMiddleware(n.protocol);u.push(async(h,d,m)=>{await c(h,d),m(h,d)}),await this.runMiddlewareChain(n,this,u)}catch(o){n.abort(o)}}async runMiddlewareChain(t,n,i){for(let s=0;s<i.length;s++){const o=i[s];t.log.trace("running middleware",s,o),await new Promise((a,c)=>{try{const l=o(t,n,(u,h)=>{t=u,n=h,a()});l instanceof Promise&&l.catch(c)}catch(l){c(l)}}),t.log.trace("ran middleware",s,o)}return t}async close(t={}){var n;if(this.log("closing connection to %a",this.remoteAddr),t.signal==null){const i=AbortSignal.timeout(this.closeTimeout);t={...t,signal:i}}await((n=this.muxer)==null?void 0:n.close(t)),await this.maConn.close(t)}abort(t){var n;(n=this.muxer)==null||n.abort(t),this.maConn.abort(t)}}function Dne(r,e){return new Rne(r,e)}function Lne(r,e){try{const{options:t}=e.getHandler(r);if(t.maxInboundStreams!=null)return t.maxInboundStreams}catch(t){if(t.name!=="UnhandledProtocolError")throw t}return kU}function Nne(r,e,t={}){try{const{options:n}=e.getHandler(r);if(n.maxOutboundStreams!=null)return n.maxOutboundStreams}catch(n){if(n.name!=="UnhandledProtocolError")throw n}return t.maxOutboundStreams??BU}function _C(r,e,t){let n=0;return t.streams.forEach(i=>{i.direction===e&&i.protocol===r&&n++}),n}var vR;vR=Symbol.toStringTag;class One{constructor(e,t){f(this,"components");f(this,"connectionEncrypters");f(this,"streamMuxers");f(this,"inboundUpgradeTimeout");f(this,"inboundStreamProtocolNegotiationTimeout");f(this,"outboundStreamProtocolNegotiationTimeout");f(this,"events");f(this,"metrics");f(this,"connectionCloseTimeout");f(this,vR,"@libp2p/upgrader");var n,i,s,o;this.components=e,this.connectionEncrypters=Po({name:"libp2p_upgrader_connection_encrypters",metrics:this.components.metrics}),t.connectionEncrypters.forEach(a=>{this.connectionEncrypters.set(a.protocol,a)}),this.streamMuxers=Po({name:"libp2p_upgrader_stream_multiplexers",metrics:this.components.metrics}),t.streamMuxers.forEach(a=>{this.streamMuxers.set(a.protocol,a)}),this.inboundUpgradeTimeout=t.inboundUpgradeTimeout??Ste,this.inboundStreamProtocolNegotiationTimeout=t.inboundStreamProtocolNegotiationTimeout??fy,this.outboundStreamProtocolNegotiationTimeout=t.outboundStreamProtocolNegotiationTimeout??fy,this.connectionCloseTimeout=t.connectionCloseTimeout??wU,this.events=e.events,this.metrics={dials:(n=e.metrics)==null?void 0:n.registerCounterGroup("libp2p_connection_manager_dials_total"),errors:(i=e.metrics)==null?void 0:i.registerCounterGroup("libp2p_connection_manager_dial_errors_total"),inboundErrors:(s=e.metrics)==null?void 0:s.registerCounterGroup("libp2p_connection_manager_dials_inbound_errors_total"),outboundErrors:(o=e.metrics)==null?void 0:o.registerCounterGroup("libp2p_connection_manager_dials_outbound_errors_total")}}async shouldBlockConnection(e,...t){const n=this.components.connectionGater[e];if(n==null)return;if(await n.apply(this.components.connectionGater,t)===!0)throw new ate(`The multiaddr connection is blocked by gater.${e}`)}createInboundAbortSignal(e){return Bc([AbortSignal.timeout(this.inboundUpgradeTimeout),e])}async upgradeInbound(e,t){var s,o,a;let n=!1;const i=this.createInboundAbortSignal(t.signal);try{if((s=this.metrics.dials)==null||s.increment({inbound:!0}),n=this.components.connectionManager.acceptIncomingConnection(e),!n)throw new cte("Connection denied");await rs(this.shouldBlockConnection("denyInboundConnection",e),i),await this._performUpgrade(e,"inbound",{...t,signal:i})}catch(c){throw(o=this.metrics.errors)==null||o.increment({inbound:!0}),(a=this.metrics.inboundErrors)==null||a.increment({[c.name??"Error"]:!0}),c}finally{i.clear(),n&&this.components.connectionManager.afterUpgradeInbound()}}async upgradeOutbound(e,t){var n,i,s,o;try{(n=this.metrics.dials)==null||n.increment({outbound:!0});const a=(i=e.remoteAddr.getComponents().findLast(u=>u.code===Is))==null?void 0:i.value;let c;a!=null&&(c=Gu(a),await rs(this.shouldBlockConnection("denyOutboundConnection",c,e),t.signal));let l="outbound";return t.initiator===!1&&(l="inbound"),await this._performUpgrade(e,l,t)}catch(a){throw(s=this.metrics.errors)==null||s.increment({outbound:!0}),(o=this.metrics.outboundErrors)==null||o.increment({[a.name??"Error"]:!0}),a}}async _performUpgrade(e,t,n){var h,d,m,p;let i=e,s,o,a,c;const l=`${parseInt(String(Math.random()*1e9)).toString(36)}${Date.now()}`;if(e.log=e.log.newScope(`${t}:${l}`),(h=this.components.metrics)==null||h.trackMultiaddrConnection(e),e.log.trace("starting the %s connection upgrade",t),(n==null?void 0:n.skipProtection)!==!0){const b=this.components.connectionProtector;b!=null&&(e.log("protecting the %s connection",t),i=await b.protect(i,n))}try{if(Une(n)){if(n.remotePeer==null)throw new U1(`${t} connection that skipped encryption must have a peer id`);c="native",s=n.remotePeer}else{const b=(d=e.remoteAddr.getComponents().findLast(y=>y.code===Is))==null?void 0:d.value;let g;b!=null&&(g=Gu(b)),(m=n==null?void 0:n.onProgress)==null||m.call(n,new Rt(`upgrader:encrypt-${t}-connection`)),{connection:i,remotePeer:s,protocol:c,streamMuxer:o}=await(t==="inbound"?this._encryptInbound(i,{...n,remotePeer:g}):this._encryptOutbound(i,{...n,remotePeer:g}))}if(s.equals(this.components.peerId)){const b=new O1("Can not dial self");throw e.abort(b),b}await this.shouldBlockConnection(t==="inbound"?"denyInboundEncryptedConnection":"denyOutboundEncryptedConnection",s,e),(n==null?void 0:n.muxerFactory)!=null?o=n.muxerFactory:o==null&&this.streamMuxers.size>0&&((p=n==null?void 0:n.onProgress)==null||p.call(n,new Rt(`upgrader:multiplex-${t}-connection`)),o=await(t==="inbound"?this._multiplexInbound(i,this.streamMuxers,n):this._multiplexOutbound(i,this.streamMuxers,n)))}catch(b){throw e.log.error("failed to upgrade %s connection %s %a - %e",t,t==="inbound"?"from":"to",e.remoteAddr,b),b}o!=null&&(e.log("create muxer %s",o.protocol),a=o.createStreamMuxer(i)),await this.shouldBlockConnection(t==="inbound"?"denyInboundUpgradedConnection":"denyOutboundUpgradedConnection",s,e);const u=this._createConnection({id:l,cryptoProtocol:c,direction:t,maConn:e,stream:i,muxer:a,remotePeer:s,limits:n==null?void 0:n.limits,closeTimeout:this.connectionCloseTimeout});return u.log("successfully upgraded connection"),u}_createConnection(e){const t=Dne(this.components,{...e,outboundStreamProtocolNegotiationTimeout:this.outboundStreamProtocolNegotiationTimeout,inboundStreamProtocolNegotiationTimeout:this.inboundStreamProtocolNegotiationTimeout});return t.addEventListener("close",()=>{this.events.safeDispatchEvent("connection:close",{detail:t})}),this.events.safeDispatchEvent("connection:open",{detail:t}),t}async _encryptInbound(e,t){const n=Array.from(this.connectionEncrypters.keys());try{const i=await TS(e,n,t),s=this.connectionEncrypters.get(i);if(s==null)throw new Om(`no crypto module found for ${i}`);return e.log("encrypting inbound connection using %s",i),{...await s.secureInbound(e,t),protocol:i}}catch(i){throw new Om(i.message)}}async _encryptOutbound(e,t){const n=Array.from(this.connectionEncrypters.keys());try{e.log.trace("selecting encrypter from %s",n);const i=await AS(e,n,t),s=this.connectionEncrypters.get(i);if(s==null)throw new Om(`no crypto module found for ${i}`);return e.log("encrypting outbound connection using %s",i),{...await s.secureOutbound(e,t),protocol:i}}catch(i){throw new Om(i.message)}}async _multiplexOutbound(e,t,n){const i=Array.from(t.keys());e.log("outbound selecting muxer %s",i);try{e.log.trace("selecting stream muxer from %s",i);const s=await AS(e,i,n),o=t.get(s);if(o==null)throw new Sg(`No muxer configured for protocol "${s}"`);return e.log("selected %s as muxer protocol",s),o}catch(s){throw e.log.error("error multiplexing outbound connection - %e",s),new Sg(String(s))}}async _multiplexInbound(e,t,n){const i=Array.from(t.keys());e.log("inbound handling muxers %s",i);try{e.log.trace("selecting stream muxer from %s",i);const s=await TS(e,i,n),o=t.get(s);if(o==null)throw new Sg(`No muxer configured for protocol "${s}"`);return e.log("selected %s as muxer protocol",s),o}catch(s){throw e.log.error("error multiplexing inbound connection - %e",s),s}}getConnectionEncrypters(){return this.connectionEncrypters}getStreamMuxers(){return this.streamMuxers}}function Une(r){return r.skipEncryption===!0}const GU="3.1.2",WU="js-libp2p";function kne(r,e){return`${r??WU}/${e??GU} browser/${globalThis.navigator.userAgent}`}var Xf,CS;class Bne extends Pr{constructor(t){var u,h,d,m,p,b,g,y,v,w,_;super();xe(this,Xf);f(this,"peerId");f(this,"peerStore");f(this,"contentRouting");f(this,"peerRouting");f(this,"metrics");f(this,"services");f(this,"logger");f(this,"status");f(this,"components");f(this,"log");this.status="stopped";const n=new Pr,i=n.dispatchEvent.bind(n);n.dispatchEvent=M=>{const E=i(M),C=this.dispatchEvent(new CustomEvent(M.type,{detail:M.detail}));return E||C},this.peerId=t.peerId,this.logger=t.logger??$N(),this.log=this.logger.forComponent("libp2p"),this.services={};const s=((u=t.nodeInfo)==null?void 0:u.name)??WU,o=((h=t.nodeInfo)==null?void 0:h.version)??GU,a=this.components=pte({peerId:t.peerId,privateKey:t.privateKey,nodeInfo:{name:s,version:o,userAgent:((d=t.nodeInfo)==null?void 0:d.userAgent)??kne(s,o)},logger:this.logger,events:n,datastore:t.datastore??new tee,connectionGater:wte(t.connectionGater),dns:t.dns});t.metrics!=null&&(this.metrics=this.configureComponent("metrics",t.metrics(this.components))),this.peerStore=this.configureComponent("peerStore",zj(a,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...t.peerStore})),a.events.addEventListener("peer:update",M=>{if(M.detail.previous==null){const E={id:M.detail.peer.id,multiaddrs:M.detail.peer.addresses.map(C=>C.multiaddr)};a.events.safeDispatchEvent("peer:discovery",{detail:E})}}),t.connectionProtector!=null&&this.configureComponent("connectionProtector",t.connectionProtector(a)),this.components.upgrader=new One(this.components,{connectionEncrypters:(t.connectionEncrypters??[]).map((M,E)=>this.configureComponent(`connection-encryption-${E}`,M(this.components))),streamMuxers:(t.streamMuxers??[]).map((M,E)=>this.configureComponent(`stream-muxers-${E}`,M(this.components))),inboundUpgradeTimeout:(m=t.connectionManager)==null?void 0:m.inboundUpgradeTimeout,inboundStreamProtocolNegotiationTimeout:(p=t.connectionManager)==null?void 0:p.inboundStreamProtocolNegotiationTimeout,outboundStreamProtocolNegotiationTimeout:(b=t.connectionManager)==null?void 0:b.outboundStreamProtocolNegotiationTimeout,connectionCloseTimeout:(g=t.connectionManager)==null?void 0:g.connectionCloseTimeout}),this.configureComponent("transportManager",new Mne(this.components,t.transportManager)),this.configureComponent("connectionManager",new fne(this.components,t.connectionManager)),((y=t.connectionMonitor)==null?void 0:y.enabled)!==!1&&this.configureComponent("connectionMonitor",new wne(this.components,t.connectionMonitor)),this.configureComponent("registrar",new Ene(this.components)),this.configureComponent("addressManager",new jee(this.components,t.addresses));const c=(t.peerRouters??[]).map((M,E)=>this.configureComponent(`peer-router-${E}`,M(this.components)));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new xne(this.components,{routers:c}));const l=(t.contentRouters??[]).map((M,E)=>this.configureComponent(`content-router-${E}`,M(this.components)));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new vne(this.components,{routers:l})),this.configureComponent("randomWalk",new Sne(this.components)),(t.peerDiscovery??[]).forEach((M,E)=>{this.configureComponent(`peer-discovery-${E}`,M(this.components)).addEventListener("peer",I=>{be(this,Xf,CS).call(this,I)})}),(v=t.transports)==null||v.forEach((M,E)=>{this.components.transportManager.add(this.configureComponent(`transport-${E}`,M(this.components)))}),t.services!=null)for(const M of Object.keys(t.services)){const E=t.services[M],C=E(this.components);if(C==null){this.log.error("service factory %s returned null or undefined instance",M);continue}this.services[M]=C,this.configureComponent(M,C),C[b2]!=null&&(this.log("registering service %s for content routing",M),l.push(C[b2])),C[v2]!=null&&(this.log("registering service %s for peer routing",M),c.push(C[v2])),C[w2]!=null&&(this.log("registering service %s for peer discovery",M),(_=(w=C[w2]).addEventListener)==null||_.call(w,"peer",I=>{be(this,Xf,CS).call(this,I)}))}mte(a)}configureComponent(t,n){return n==null&&this.log.error("component %s was null or undefined",t),this.components[t]=n,n}async start(){var t,n,i,s;if(this.status==="stopped"){this.status="starting",this.log("libp2p is starting");try{await((n=(t=this.components).beforeStart)==null?void 0:n.call(t)),await this.components.start(),await((s=(i=this.components).afterStart)==null?void 0:s.call(i)),this.status="started",this.safeDispatchEvent("start",{detail:this}),this.log("libp2p has started with peer id %p",this.peerId)}catch(o){throw this.log.error("an error occurred starting libp2p - %e",o),this.status="started",await this.stop(),o}}}async stop(){var t,n,i,s;this.status==="started"&&(this.log("libp2p is stopping"),this.status="stopping",await((n=(t=this.components).beforeStop)==null?void 0:n.call(t)),await this.components.stop(),await((s=(i=this.components).afterStop)==null?void 0:s.call(i)),this.status="stopped",this.safeDispatchEvent("stop",{detail:this}),this.log("libp2p has stopped"))}getConnections(t){return this.components.connectionManager.getConnections(t)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const t=new GN;for(const n of this.components.connectionManager.getConnections())t.add(n.remotePeer);return Array.from(t)}async dial(t,n={}){return this.components.connectionManager.openConnection(t,{priority:75,...n})}async dialProtocol(t,n,i={}){if(n==null)throw new ai("no protocols were provided to open a stream");if(n=Array.isArray(n)?n:[n],n.length===0)throw new ai("no protocols were provided to open a stream");return this.components.connectionManager.openStream(t,n,i)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(t,n={}){var i;eM(t)&&(t=Gu(((i=t.getComponents().findLast(s=>s.code===Is))==null?void 0:i.value)??"")),await this.components.connectionManager.closeConnections(t,n)}async getPublicKey(t,n={}){if(this.log("getPublicKey %p",t),t.publicKey!=null)return t.publicKey;try{const a=await this.peerStore.get(t,n);if(a.id.publicKey!=null)return a.id.publicKey}catch(a){if(a.name!=="NotFoundError")throw a}const i=ut([Se("/pk/"),t.toMultihash().bytes]),s=await this.contentRouting.get(i,n),o=Io(s);return await this.peerStore.patch(t,{publicKey:o},n),o}async handle(t,n,i){Array.isArray(t)||(t=[t]),await Promise.all(t.map(async s=>{await this.components.registrar.handle(s,n,i)}))}async unhandle(t,n){Array.isArray(t)||(t=[t]),await Promise.all(t.map(async i=>{await this.components.registrar.unhandle(i,n)}))}async register(t,n,i){return this.components.registrar.register(t,n,i)}unregister(t){this.components.registrar.unregister(t)}use(t,n){this.components.registrar.use(t,Array.isArray(n)?n:[n])}unuse(t){this.components.registrar.unuse(t)}async isDialable(t,n={}){return this.components.connectionManager.isDialable(t,n)}}Xf=new WeakSet,CS=function(t){const{detail:n}=t;if(n.id.toString()===this.peerId.toString()){this.log.error("peer discovery mechanism discovered self");return}this.components.peerStore.merge(n.id,{multiaddrs:n.multiaddrs}).catch(i=>{this.log.error("could not update multiaddrs of discovered peer - %e",i)})};async function Fne(r={}){r.privateKey??(r.privateKey=await Wq());const e=new Bne({...await fK(r),peerId:lK(r.privateKey)});return r.start!==!1&&await e.start(),e}var a_;let $ne=(a_=class extends Error{constructor(e="Connection failed"){super(e),this.name="ConnectionFailedError"}},f(a_,"name","ConnectionFailedError"),a_);const zne=Symbol.for("@libp2p/transport");var xC;(function(r){r[r.FATAL_ALL=0]="FATAL_ALL",r[r.NO_FATAL=1]="NO_FATAL"})(xC||(xC={}));const Vne=Symbol.for("@libp2p/service-capabilities");var c_;let wi=(c_=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidMultiaddrError")}},f(c_,"name","InvalidMultiaddrError"),c_);var l_;let Mf=(l_=class extends Error{constructor(){super(...arguments);f(this,"name","ValidationError")}},f(l_,"name","ValidationError"),l_);var u_;let Hne=(u_=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidParametersError")}},f(u_,"name","InvalidParametersError"),u_);var h_;let Gne=(h_=class extends Error{constructor(){super(...arguments);f(this,"name","UnknownProtocolError")}},f(h_,"name","UnknownProtocolError"),h_);const Wne=4,qU=6,qne=273,Kne=33,KU=41,Xne=42,Yne=43,XU=53,YU=54,ZU=55,JU=56,Zne=132,Jne=301,jne=302,Qne=400,ere=421,tre=444,nre=445,rre=446,ire=447,jU=448,sre=449,ore=454,are=460,cre=461,lre=465,ure=466,hre=480,dre=481,fre=443,pre=477,mre=478,gre=479,yre=277,bre=275,wre=276,vre=280,_re=281,xre=290,Sre=777;function SC(r){return e=>ae(e,r)}function EC(r){return e=>Se(e,r)}function hd(r){return new DataView(r.buffer).getUint16(r.byteOffset).toString()}function Fl(r){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof r=="string"?parseInt(r):r),new Uint8Array(e)}function Ere(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=Se(e[0],"base32"),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=Fl(n);return ut([t,i],t.length+i.length)}function Mre(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=Rn.decode(`b${e[0]}`),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=Fl(n);return ut([t,i],t.length+i.length)}function MC(r){const e=r.subarray(0,r.length-2),t=r.subarray(r.length-2),n=ae(e,"base32"),i=hd(t);return`${n}:${i}`}const QU=function(r){r=r.toString().trim();const e=new Uint8Array(4);return r.split(/\./g).forEach((t,n)=>{const i=parseInt(t,10);if(isNaN(i)||i<0||i>255)throw new wi("Invalid byte value in IP address");e[n]=i}),e},Are=function(r){let e=0;r=r.toString().trim();const t=r.split(":",8);let n;for(n=0;n<t.length;n++){const s=$t(t[n]);let o;s&&(o=QU(t[n]),t[n]=ae(o.subarray(0,2),"base16")),o!=null&&++n<8&&t.splice(n,0,ae(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(n=0;n<t.length&&t[n]!=="";n++);const s=[n,1];for(n=9-t.length;n>0;n--)s.push("0");t.splice.apply(t,s)}const i=new Uint8Array(e+16);for(n=0;n<t.length;n++){t[n]===""&&(t[n]="0");const s=parseInt(t[n],16);if(isNaN(s)||s<0||s>65535)throw new wi("Invalid byte value in IP address");i[e++]=s>>8&255,i[e++]=s&255}return i},Tre=function(r){if(r.byteLength!==4)throw new wi("IPv4 address was incorrect length");const e=[];for(let t=0;t<r.byteLength;t++)e.push(r[t]);return e.join(".")},Cre=function(r){if(r.byteLength!==16)throw new wi("IPv6 address was incorrect length");const e=[];for(let n=0;n<r.byteLength;n+=2){const i=r[n],s=r[n+1],o=`${i.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const n=new URL(`http://[${t}]`);return n.hostname.substring(1,n.hostname.length-1)}catch{throw new wi(`Invalid IPv6 address "${t}"`)}};function Ire(r){try{const e=new URL(`http://[${r}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new wi(`Invalid IPv6 address "${r}"`)}}const Cw=Object.values(oi).map(r=>r.decoder),Pre=(function(){let r=Cw[0].or(Cw[1]);return Cw.slice(2).forEach(e=>r=r.or(e)),r})();function Rre(r){return Pre.decode(r)}function Dre(r){return e=>r.encoder.encode(e)}function Lre(r){if(parseInt(r).toString()!==r)throw new Mf("Value must be an integer")}function Nre(r){if(r<0)throw new Mf("Value must be a positive integer, or zero")}function Ore(r){return e=>{if(e>r)throw new Mf(`Value must be smaller than or equal to ${r}`)}}function Ure(...r){return e=>{for(const t of r)t(e)}}const Bm=Ure(Lre,Nre,Ore(65535)),tr=-1;let kre=class{constructor(){f(this,"protocolsByCode",new Map);f(this,"protocolsByName",new Map)}getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new Gne(`Protocol ${e} was unknown`);return t}addProtocol(e){var t;this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),(t=e.aliases)==null||t.forEach(n=>{this.protocolsByName.set(n,e)})}removeProtocol(e){var n;const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),(n=t.aliases)==null||n.forEach(i=>{this.protocolsByName.delete(i)}))}};const Sh=new kre,Bre=[{code:Wne,name:"ip4",size:32,valueToBytes:QU,bytesToValue:Tre,validate:r=>{if(!$t(r))throw new Mf(`Invalid IPv4 address "${r}"`)}},{code:qU,name:"tcp",size:16,valueToBytes:Fl,bytesToValue:hd,validate:Bm},{code:qne,name:"udp",size:16,valueToBytes:Fl,bytesToValue:hd,validate:Bm},{code:Kne,name:"dccp",size:16,valueToBytes:Fl,bytesToValue:hd,validate:Bm},{code:KU,name:"ip6",size:128,valueToBytes:Are,bytesToValue:Cre,stringToValue:Ire,validate:r=>{if(!Ai(r))throw new Mf(`Invalid IPv6 address "${r}"`)}},{code:Xne,name:"ip6zone",size:tr},{code:Yne,name:"ipcidr",size:8,bytesToValue:SC("base10"),valueToBytes:EC("base10")},{code:XU,name:"dns",size:tr},{code:YU,name:"dns4",size:tr},{code:ZU,name:"dns6",size:tr},{code:JU,name:"dnsaddr",size:tr},{code:Zne,name:"sctp",size:16,valueToBytes:Fl,bytesToValue:hd,validate:Bm},{code:Jne,name:"udt"},{code:jne,name:"utp"},{code:Qne,name:"unix",size:tr,stringToValue:r=>decodeURIComponent(r),valueToString:r=>encodeURIComponent(r)},{code:ere,name:"p2p",aliases:["ipfs"],size:tr,bytesToValue:SC("base58btc"),valueToBytes:r=>r.startsWith("Q")||r.startsWith("1")?EC("base58btc")(r):Ze.parse(r).multihash.bytes},{code:tre,name:"onion",size:96,bytesToValue:MC,valueToBytes:Ere},{code:nre,name:"onion3",size:296,bytesToValue:MC,valueToBytes:Mre},{code:rre,name:"garlic64",size:tr},{code:ire,name:"garlic32",size:tr},{code:jU,name:"tls"},{code:sre,name:"sni",size:tr},{code:ore,name:"noise"},{code:are,name:"quic"},{code:cre,name:"quic-v1"},{code:lre,name:"webtransport"},{code:ure,name:"certhash",size:tr,bytesToValue:Dre(Mi),valueToBytes:Rre},{code:hre,name:"http"},{code:dre,name:"http-path",size:tr,stringToValue:r=>`/${decodeURIComponent(r)}`,valueToString:r=>encodeURIComponent(r.substring(1))},{code:fre,name:"https"},{code:pre,name:"ws"},{code:mre,name:"wss"},{code:gre,name:"p2p-websocket-star"},{code:yre,name:"p2p-stardust"},{code:bre,name:"p2p-webrtc-star"},{code:wre,name:"p2p-webrtc-direct"},{code:vre,name:"webrtc-direct"},{code:_re,name:"webrtc"},{code:xre,name:"p2p-circuit"},{code:Sre,name:"memory",size:tr}];Bre.forEach(r=>{Sh.addProtocol(r)});function Fre(r){var n;const e=[];let t=0;for(;t<r.length;){const i=Yt(r,t),s=Sh.getProtocol(i),o=Ue(i),a=Hre(s,r,t+o);let c=0;a>0&&s.size===tr&&(c=Ue(a));const l=o+c+a,u={code:i,name:s.name,bytes:r.subarray(t,t+l)};if(a>0){const h=t+o+c,d=r.subarray(h,h+a);u.value=((n=s.bytesToValue)==null?void 0:n.call(s,d))??ae(d)}e.push(u),t+=l}return e}function $re(r){var n;let e=0;const t=[];for(const i of r){if(i.bytes==null){const s=Sh.getProtocol(i.code),o=Ue(i.code);let a,c=0,l=0;i.value!=null&&(a=((n=s.valueToBytes)==null?void 0:n.call(s,i.value))??Se(i.value),c=a.byteLength,s.size===tr&&(l=Ue(c)));const u=new Uint8Array(o+l+c);let h=0;sn(i.code,u,h),h+=o,a!=null&&(s.size===tr&&(sn(c,u,h),h+=l),u.set(a,h)),i.bytes=u}t.push(i.bytes),e+=i.bytes.byteLength}return ut(t,e)}function zre(r){var s;if(r.charAt(0)!=="/")throw new wi('String multiaddr must start with "/"');const e=[];let t="protocol",n="",i="";for(let o=1;o<r.length;o++){const a=r.charAt(o);a!=="/"&&(t==="protocol"?i+=r.charAt(o):n+=r.charAt(o));const c=o===r.length-1;if(a==="/"||c){const l=Sh.getProtocol(i);if(t==="protocol"){if(l.size==null||l.size===0){e.push({code:l.code,name:l.name}),n="",i="",t="protocol";continue}else if(c)throw new wi(`Component ${i} was missing value`);t="value"}else if(t==="value"){const u={code:l.code,name:l.name};if(l.size!=null&&l.size!==0){if(n==="")throw new wi(`Component ${i} was missing value`);u.value=((s=l.stringToValue)==null?void 0:s.call(l,n))??n}e.push(u),n="",i="",t="protocol"}}}if(i!==""&&n!=="")throw new wi("Incomplete multiaddr");return e}function Vre(r){return`/${r.flatMap(e=>{var n;if(e.value==null)return e.name;const t=Sh.getProtocol(e.code);if(t==null)throw new wi(`Unknown protocol code ${e.code}`);return[e.name,((n=t.valueToString)==null?void 0:n.call(t,e.value))??e.value]}).join("/")}`}function Hre(r,e,t){return r.size==null||r.size===0?0:r.size>0?r.size/8:Yt(e,t)}const Gre=Symbol.for("nodejs.util.inspect.custom"),ek=Symbol.for("@multiformats/multiaddr");function Wre(r){if(r==null&&(r="/"),Xre(r))return r.getComponents();if(r instanceof Uint8Array)return Fre(r);if(typeof r=="string")return r=r.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),r===""&&(r="/"),zre(r);if(Array.isArray(r))return r;throw new wi("Must be a string, Uint8Array, Component[], or another Multiaddr")}var _R,Bi,bu,wu,fo;let qre=(fo=class{constructor(e="/",t={}){f(this,_R,!0);xe(this,Bi);xe(this,bu);xe(this,wu);_e(this,Bi,Wre(e)),t.validate!==!1&&Kre(this)}get bytes(){return N(this,wu)==null&&_e(this,wu,$re(N(this,Bi))),N(this,wu)}toString(){return N(this,bu)==null&&_e(this,bu,Vre(N(this,Bi))),N(this,bu)}toJSON(){return this.toString()}getComponents(){return[...N(this,Bi).map(e=>({...e}))]}encapsulate(e){const t=new fo(e);return new fo([...N(this,Bi),...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),n=this.toString(),i=n.lastIndexOf(t);if(i<0)throw new Hne(`Address ${this.toString()} does not contain subaddress: ${t}`);return new fo(n.slice(0,i),{validate:!1})}decapsulateCode(e){let t;for(let n=N(this,Bi).length-1;n>-1;n--)if(N(this,Bi)[n].code===e){t=n;break}return new fo(N(this,Bi).slice(0,t),{validate:!1})}equals(e){return We(this.bytes,e.bytes)}[(_R=ek,Gre)](){return`Multiaddr(${this.toString()})`}},Bi=new WeakMap,bu=new WeakMap,wu=new WeakMap,fo);function Kre(r){r.getComponents().forEach(e=>{var n;const t=Sh.getProtocol(e.code);e.value!=null&&((n=t.validate)==null||n.call(t,e.value))})}function Xre(r){return!!(r!=null&&r[ek])}function Yre(r){return new qre(r)}const Zre=[qU,XU,JU,YU,ZU];function AC(r){var e;return(e=tk("sni",r))==null?void 0:e.value}function TC(r){var t;const e=(t=tk("tcp",r))==null?void 0:t.value;return e==null?"":`:${e}`}function tk(r,e){return e.find(t=>t.name===r)}function CC(r){return r.some(({code:e})=>e===jU)}function Di(r,e){const t=nk[r.name];if(t==null)throw new Error(`Can't interpret protocol ${r.name}`);const n=t(r,e);return r.code===KU?`[${n}]`:n}const nk={ip4:(r,e)=>r.value,ip6:(r,e)=>e.length===0?r.value:`[${r.value}]`,tcp:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`tcp://${Di(t,e)}:${r.value}`},udp:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`udp://${Di(t,e)}:${r.value}`},dnsaddr:(r,e)=>r.value,dns4:(r,e)=>r.value,dns6:(r,e)=>r.value,dns:(r,e)=>r.value,ipfs:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`${Di(t,e)}`},p2p:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`${Di(t,e)}`},http:(r,e)=>{const t=CC(e),n=AC(e),i=TC(e);if(t&&n!=null)return`https://${n}${i}`;const s=t?"https://":"http://",o=e.pop();if(o==null)throw new Error("Unexpected end of multiaddr");let a=Di(o,e);return a=a==null?void 0:a.replace("tcp://",""),`${s}${a}`},"http-path":(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");const n=Di(t,e),i=decodeURIComponent(r.value??"");return`${n}${i}`},tls:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return Di(t,e)},sni:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return Di(t,e)},https:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");let n=Di(t,e);return n=n==null?void 0:n.replace("tcp://",""),`https://${n}`},ws:(r,e)=>{const t=CC(e),n=AC(e),i=TC(e);if(t&&n!=null)return`wss://${n}${i}`;const s=t?"wss://":"ws://",o=e.pop();if(o==null)throw new Error("Unexpected end of multiaddr");let a=Di(o,e);return a=a==null?void 0:a.replace("tcp://",""),`${s}${a}`},wss:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");let n=Di(t,e);return n=n==null?void 0:n.replace("tcp://",""),`wss://${n}`}};function Jre(r,e){const n=Yre(r).getComponents(),i=n.pop();if(i==null)throw new Error("Unexpected end of multiaddr");const s=nk[i.name];if(s==null)throw new Error(`No interpreter found for ${i.name}`);let o=s(i,n)??"";return Zre.includes(i.code)&&(o=o.replace(/^.*:\/\//,""),i.value==="443"?o=`https://${o}`:o=`http://${o}`),(o.startsWith("http://")||o.startsWith("https://")||o.startsWith("ws://")||o.startsWith("wss://"))&&(o=new URL(o).toString(),o.endsWith("/")&&(o=o.substring(0,o.length-1))),o}function jre(){throw new Error("WebSocket Servers can not be created in the browser!")}const Qre=1024*1024*4,eie=10;class tie extends Y1{constructor(t){super(t);f(this,"websocket");f(this,"maxBufferedAmount");f(this,"checkBufferedAmountTask");this.websocket=t.websocket,this.maxBufferedAmount=t.maxBufferedAmount??Qre,this.checkBufferedAmountTask=aO(this.checkBufferedAmount.bind(this),t.bufferedAmountPollInterval??eie),this.websocket.addEventListener("close",n=>{if(this.log('closed - code %d, reason "%s", wasClean %s',n.code,n.reason,n.wasClean),this.checkBufferedAmountTask.stop(),!n.wasClean){this.onRemoteReset();return}this.onTransportClosed()},{once:!0}),this.websocket.addEventListener("message",n=>{try{let i;if(typeof n.data=="string")i=Se(n.data);else if(n.data instanceof ArrayBuffer)i=new Uint8Array(n.data,0,n.data.byteLength);else{this.abort(new Error("Incorrect binary type"));return}this.onData(i)}catch(i){this.log.error("error receiving data - %e",i)}})}sendData(t){for(const i of t)this.websocket.send(i);const n=this.websocket.bufferedAmount<this.maxBufferedAmount;return n||this.checkBufferedAmountTask.start(),{sentBytes:t.byteLength,canSendMore:n}}sendReset(){this.websocket.close(1006)}async sendClose(t){var n;this.websocket.close(),(n=t==null?void 0:t.signal)==null||n.throwIfAborted()}sendPause(){}sendResume(){}checkBufferedAmount(){this.log("buffered amount now %d",this.websocket.bufferedAmount),this.websocket.bufferedAmount===0&&(this.checkBufferedAmountTask.stop(),this.safeDispatchEvent("drain"))}}function nie(r){return new tie(r)}var xR,SR,ER;ER=zne,SR=Symbol.toStringTag,xR=Vne;class rie{constructor(e,t={}){f(this,"log");f(this,"init");f(this,"logger");f(this,"metrics");f(this,"components");f(this,ER,!0);f(this,SR,"@libp2p/websockets");f(this,xR,["@libp2p/transport"]);this.log=e.logger.forComponent("libp2p:websockets"),this.logger=e.logger,this.components=e,this.init=t,e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_websockets_dialer_events_total",{label:"event",help:"Total count of WebSockets dialer events by type"})})}async dial(e,t){var s;this.log("dialing %s",e),t=t??{};const n=nie({websocket:await this._connect(e,t),remoteAddr:e,metrics:(s=this.metrics)==null?void 0:s.dialerEvents,direction:"outbound",log:this.components.logger.forComponent("libp2p:websockets:connection"),maxBufferedAmount:this.init.maxBufferedAmount,bufferedAmountPollInterval:this.init.bufferedAmountPollInterval});this.log("new outbound connection %s",n.remoteAddr);const i=await t.upgrader.upgradeOutbound(n,t);return this.log("outbound connection %s upgraded",n.remoteAddr),i}async _connect(e,t){var s,o,a,c,l,u;(s=t==null?void 0:t.signal)==null||s.throwIfAborted();const n=Jre(e);this.log("create websocket connection to %s",n);const i=new WebSocket(n);i.binaryType="arraybuffer";try{(o=t.onProgress)==null||o.call(t,new Rt("websockets:open-connection")),await Dn(i,"open",t)}catch(h){if((a=t.signal)!=null&&a.aborted)throw(c=this.metrics)==null||c.dialerEvents.increment({abort:!0}),new $ne(`Could not connect to ${n}`);(l=this.metrics)==null||l.dialerEvents.increment({error:!0});try{i.close()}catch{}throw h}return this.log("connected %s",e),(u=this.metrics)==null||u.dialerEvents.increment({connect:!0}),i}createListener(e){return jre({logger:this.logger,events:this.components.events,metrics:this.components.metrics},{...this.init,...e})}listenFilter(e){return e.filter(t=>Ef.exactMatch(t)||hy.exactMatch(t))}dialFilter(e){return this.listenFilter(e)}}function iie(r={}){return e=>new rie(e,r)}var d_;let rk=(d_=class extends Error{constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}},f(d_,"name","InvalidParametersError"),d_);class ik extends Error{constructor(e="Connection failed"){super(e),this.name="ConnectionFailedError"}}f(ik,"name","ConnectionFailedError");class sk extends Error{constructor(e="The stream has been reset"){super(e),this.name="StreamResetError"}}f(sk,"name","StreamResetError");class ok extends Error{constructor(e="The stream is in an invalid state"){super(e),this.name="StreamStateError"}}f(ok,"name","StreamStateError");var f_;let sie=(f_=class extends Error{constructor(e="Invalid multiaddr"){super(e),this.name="InvalidMultiaddrError"}},f(f_,"name","InvalidMultiaddrError"),f_);var p_;let oie=(p_=class extends Error{constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}},f(p_,"name","InvalidCIDError"),p_);var m_;let aie=(m_=class extends Error{constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}},f(m_,"name","InvalidMultihashError"),m_);var g_;let cie=(g_=class extends Error{constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}},f(g_,"name","InvalidMessageError"),g_);const ak=Symbol.for("@libp2p/peer-id"),lie=Symbol.for("@libp2p/transport");var IC;(function(r){r[r.FATAL_ALL=0]="FATAL_ALL",r[r.NO_FATAL=1]="NO_FATAL"})(IC||(IC={}));const uie=Symbol.for("@libp2p/service-capabilities"),hie=Symbol.for("@libp2p/service-dependencies"),ck=Symbol.for("nodejs.util.inspect.custom"),die=114;var MR;let lM=class{constructor(e){f(this,"type");f(this,"multihash");f(this,"publicKey");f(this,"string");f(this,MR,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=gt.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return Ze.createV1(die,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return We(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return We(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(MR=ak,ck)](){return`PeerId(${this.toString()})`}},fie=class extends lM{constructor(t){super({...t,type:"RSA"});f(this,"type","RSA");f(this,"publicKey");this.publicKey=t.publicKey}},pie=class extends lM{constructor(t){super({...t,type:"Ed25519"});f(this,"type","Ed25519");f(this,"publicKey");this.publicKey=t.publicKey}},mie=class extends lM{constructor(t){super({...t,type:"secp256k1"});f(this,"type","secp256k1");f(this,"publicKey");this.publicKey=t.publicKey}};const gie=2336;var AR,TR;let lk=class{constructor(e){f(this,"type","url");f(this,"multihash");f(this,"publicKey");f(this,"url");f(this,AR,!0);this.url=e.toString(),this.multihash=dn.digest(Se(this.url))}[(TR=ck,AR=ak,TR)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return Ze.createV1(gie,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=ae(e)),e.toString()===this.toString())}};const yie=114,PC=2336;function uk(r,e){let t;if(r.charAt(0)==="1"||r.charAt(0)==="Q")t=Lo(gt.decode(`z${r}`));else{if(r.startsWith("k51qzi5uqu5")||r.startsWith("kzwfwjn5ji4")||r.startsWith("k2k4r8")||r.startsWith("bafz"))return bie(Ze.parse(r));throw new rk('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return hk(t)}function hk(r){if(vie(r))return new fie({multihash:r});if(wie(r))try{const e=No(r);if(e.type==="Ed25519")return new pie({multihash:r,publicKey:e});if(e.type==="secp256k1")return new mie({multihash:r,publicKey:e})}catch{const t=ae(r.digest);return new lk(new URL(t))}throw new aie("Supplied PeerID Multihash is invalid")}function bie(r){if((r==null?void 0:r.multihash)==null||r.version==null||r.version===1&&r.code!==yie&&r.code!==PC)throw new oie("Supplied PeerID CID is invalid");if(r.code===PC){const e=ae(r.multihash.digest);return new lk(new URL(e))}return hk(r.multihash)}function wie(r){return r.code===dn.code}function vie(r){return r.code===Ns.code}var y_;let vi=(y_=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidMultiaddrError")}},f(y_,"name","InvalidMultiaddrError"),y_);var b_;let Af=(b_=class extends Error{constructor(){super(...arguments);f(this,"name","ValidationError")}},f(b_,"name","ValidationError"),b_);var w_;let _ie=(w_=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidParametersError")}},f(w_,"name","InvalidParametersError"),w_);var v_;let xie=(v_=class extends Error{constructor(){super(...arguments);f(this,"name","UnknownProtocolError")}},f(v_,"name","UnknownProtocolError"),v_);const Sie=4,Eie=6,Mie=273,Aie=33,Tie=41,Cie=42,Iie=43,Pie=53,Rie=54,Die=55,Lie=56,Nie=132,Oie=301,Uie=302,kie=400,Bie=421,Fie=444,$ie=445,zie=446,Vie=447,Hie=448,Gie=449,Wie=454,qie=460,Kie=461,Xie=465,Yie=466,Zie=480,Jie=481,jie=443,Qie=477,ese=478,tse=479,nse=277,rse=275,ise=276,sse=280,ose=281,dk=290,ase=777;function RC(r){return e=>ae(e,r)}function DC(r){return e=>Se(e,r)}function dd(r){return new DataView(r.buffer).getUint16(r.byteOffset).toString()}function $l(r){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof r=="string"?parseInt(r):r),new Uint8Array(e)}function cse(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=Se(e[0],"base32"),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=$l(n);return ut([t,i],t.length+i.length)}function lse(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=Rn.decode(`b${e[0]}`),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=$l(n);return ut([t,i],t.length+i.length)}function LC(r){const e=r.subarray(0,r.length-2),t=r.subarray(r.length-2),n=ae(e,"base32"),i=dd(t);return`${n}:${i}`}const fk=function(r){r=r.toString().trim();const e=new Uint8Array(4);return r.split(/\./g).forEach((t,n)=>{const i=parseInt(t,10);if(isNaN(i)||i<0||i>255)throw new vi("Invalid byte value in IP address");e[n]=i}),e},use=function(r){let e=0;r=r.toString().trim();const t=r.split(":",8);let n;for(n=0;n<t.length;n++){const s=$t(t[n]);let o;s&&(o=fk(t[n]),t[n]=ae(o.subarray(0,2),"base16")),o!=null&&++n<8&&t.splice(n,0,ae(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(n=0;n<t.length&&t[n]!=="";n++);const s=[n,1];for(n=9-t.length;n>0;n--)s.push("0");t.splice.apply(t,s)}const i=new Uint8Array(e+16);for(n=0;n<t.length;n++){t[n]===""&&(t[n]="0");const s=parseInt(t[n],16);if(isNaN(s)||s<0||s>65535)throw new vi("Invalid byte value in IP address");i[e++]=s>>8&255,i[e++]=s&255}return i},hse=function(r){if(r.byteLength!==4)throw new vi("IPv4 address was incorrect length");const e=[];for(let t=0;t<r.byteLength;t++)e.push(r[t]);return e.join(".")},dse=function(r){if(r.byteLength!==16)throw new vi("IPv6 address was incorrect length");const e=[];for(let n=0;n<r.byteLength;n+=2){const i=r[n],s=r[n+1],o=`${i.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const n=new URL(`http://[${t}]`);return n.hostname.substring(1,n.hostname.length-1)}catch{throw new vi(`Invalid IPv6 address "${t}"`)}};function fse(r){try{const e=new URL(`http://[${r}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new vi(`Invalid IPv6 address "${r}"`)}}const Iw=Object.values(oi).map(r=>r.decoder),pse=(function(){let r=Iw[0].or(Iw[1]);return Iw.slice(2).forEach(e=>r=r.or(e)),r})();function mse(r){return pse.decode(r)}function gse(r){return e=>r.encoder.encode(e)}function yse(r){if(parseInt(r).toString()!==r)throw new Af("Value must be an integer")}function bse(r){if(r<0)throw new Af("Value must be a positive integer, or zero")}function wse(r){return e=>{if(e>r)throw new Af(`Value must be smaller than or equal to ${r}`)}}function vse(...r){return e=>{for(const t of r)t(e)}}const Fm=vse(yse,bse,wse(65535)),nr=-1;let _se=class{constructor(){f(this,"protocolsByCode",new Map);f(this,"protocolsByName",new Map)}getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new xie(`Protocol ${e} was unknown`);return t}addProtocol(e){var t;this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),(t=e.aliases)==null||t.forEach(n=>{this.protocolsByName.set(n,e)})}removeProtocol(e){var n;const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),(n=t.aliases)==null||n.forEach(i=>{this.protocolsByName.delete(i)}))}};const Eh=new _se,xse=[{code:Sie,name:"ip4",size:32,valueToBytes:fk,bytesToValue:hse,validate:r=>{if(!$t(r))throw new Af(`Invalid IPv4 address "${r}"`)}},{code:Eie,name:"tcp",size:16,valueToBytes:$l,bytesToValue:dd,validate:Fm},{code:Mie,name:"udp",size:16,valueToBytes:$l,bytesToValue:dd,validate:Fm},{code:Aie,name:"dccp",size:16,valueToBytes:$l,bytesToValue:dd,validate:Fm},{code:Tie,name:"ip6",size:128,valueToBytes:use,bytesToValue:dse,stringToValue:fse,validate:r=>{if(!Ai(r))throw new Af(`Invalid IPv6 address "${r}"`)}},{code:Cie,name:"ip6zone",size:nr},{code:Iie,name:"ipcidr",size:8,bytesToValue:RC("base10"),valueToBytes:DC("base10")},{code:Pie,name:"dns",size:nr},{code:Rie,name:"dns4",size:nr},{code:Die,name:"dns6",size:nr},{code:Lie,name:"dnsaddr",size:nr},{code:Nie,name:"sctp",size:16,valueToBytes:$l,bytesToValue:dd,validate:Fm},{code:Oie,name:"udt"},{code:Uie,name:"utp"},{code:kie,name:"unix",size:nr,stringToValue:r=>decodeURIComponent(r),valueToString:r=>encodeURIComponent(r)},{code:Bie,name:"p2p",aliases:["ipfs"],size:nr,bytesToValue:RC("base58btc"),valueToBytes:r=>r.startsWith("Q")||r.startsWith("1")?DC("base58btc")(r):Ze.parse(r).multihash.bytes},{code:Fie,name:"onion",size:96,bytesToValue:LC,valueToBytes:cse},{code:$ie,name:"onion3",size:296,bytesToValue:LC,valueToBytes:lse},{code:zie,name:"garlic64",size:nr},{code:Vie,name:"garlic32",size:nr},{code:Hie,name:"tls"},{code:Gie,name:"sni",size:nr},{code:Wie,name:"noise"},{code:qie,name:"quic"},{code:Kie,name:"quic-v1"},{code:Xie,name:"webtransport"},{code:Yie,name:"certhash",size:nr,bytesToValue:gse(Mi),valueToBytes:mse},{code:Zie,name:"http"},{code:Jie,name:"http-path",size:nr,stringToValue:r=>`/${decodeURIComponent(r)}`,valueToString:r=>encodeURIComponent(r.substring(1))},{code:jie,name:"https"},{code:Qie,name:"ws"},{code:ese,name:"wss"},{code:tse,name:"p2p-websocket-star"},{code:nse,name:"p2p-stardust"},{code:rse,name:"p2p-webrtc-star"},{code:ise,name:"p2p-webrtc-direct"},{code:sse,name:"webrtc-direct"},{code:ose,name:"webrtc"},{code:dk,name:"p2p-circuit"},{code:ase,name:"memory",size:nr}];xse.forEach(r=>{Eh.addProtocol(r)});function Sse(r){var n;const e=[];let t=0;for(;t<r.length;){const i=Yt(r,t),s=Eh.getProtocol(i),o=Ue(i),a=Tse(s,r,t+o);let c=0;a>0&&s.size===nr&&(c=Ue(a));const l=o+c+a,u={code:i,name:s.name,bytes:r.subarray(t,t+l)};if(a>0){const h=t+o+c,d=r.subarray(h,h+a);u.value=((n=s.bytesToValue)==null?void 0:n.call(s,d))??ae(d)}e.push(u),t+=l}return e}function Ese(r){var n;let e=0;const t=[];for(const i of r){if(i.bytes==null){const s=Eh.getProtocol(i.code),o=Ue(i.code);let a,c=0,l=0;i.value!=null&&(a=((n=s.valueToBytes)==null?void 0:n.call(s,i.value))??Se(i.value),c=a.byteLength,s.size===nr&&(l=Ue(c)));const u=new Uint8Array(o+l+c);let h=0;sn(i.code,u,h),h+=o,a!=null&&(s.size===nr&&(sn(c,u,h),h+=l),u.set(a,h)),i.bytes=u}t.push(i.bytes),e+=i.bytes.byteLength}return ut(t,e)}function Mse(r){var s;if(r.charAt(0)!=="/")throw new vi('String multiaddr must start with "/"');const e=[];let t="protocol",n="",i="";for(let o=1;o<r.length;o++){const a=r.charAt(o);a!=="/"&&(t==="protocol"?i+=r.charAt(o):n+=r.charAt(o));const c=o===r.length-1;if(a==="/"||c){const l=Eh.getProtocol(i);if(t==="protocol"){if(l.size==null||l.size===0){e.push({code:l.code,name:l.name}),n="",i="",t="protocol";continue}else if(c)throw new vi(`Component ${i} was missing value`);t="value"}else if(t==="value"){const u={code:l.code,name:l.name};if(l.size!=null&&l.size!==0){if(n==="")throw new vi(`Component ${i} was missing value`);u.value=((s=l.stringToValue)==null?void 0:s.call(l,n))??n}e.push(u),n="",i="",t="protocol"}}}if(i!==""&&n!=="")throw new vi("Incomplete multiaddr");return e}function Ase(r){return`/${r.flatMap(e=>{var n;if(e.value==null)return e.name;const t=Eh.getProtocol(e.code);if(t==null)throw new vi(`Unknown protocol code ${e.code}`);return[e.name,((n=t.valueToString)==null?void 0:n.call(t,e.value))??e.value]}).join("/")}`}function Tse(r,e,t){return r.size==null||r.size===0?0:r.size>0?r.size/8:Yt(e,t)}const Cse=Symbol.for("nodejs.util.inspect.custom"),pk=Symbol.for("@multiformats/multiaddr");function Ise(r){if(r==null&&(r="/"),Dse(r))return r.getComponents();if(r instanceof Uint8Array)return Sse(r);if(typeof r=="string")return r=r.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),r===""&&(r="/"),Mse(r);if(Array.isArray(r))return r;throw new vi("Must be a string, Uint8Array, Component[], or another Multiaddr")}var CR,Fi,vu,_u,po;let Pse=(po=class{constructor(e="/",t={}){f(this,CR,!0);xe(this,Fi);xe(this,vu);xe(this,_u);_e(this,Fi,Ise(e)),t.validate!==!1&&Rse(this)}get bytes(){return N(this,_u)==null&&_e(this,_u,Ese(N(this,Fi))),N(this,_u)}toString(){return N(this,vu)==null&&_e(this,vu,Ase(N(this,Fi))),N(this,vu)}toJSON(){return this.toString()}getComponents(){return[...N(this,Fi).map(e=>({...e}))]}encapsulate(e){const t=new po(e);return new po([...N(this,Fi),...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),n=this.toString(),i=n.lastIndexOf(t);if(i<0)throw new _ie(`Address ${this.toString()} does not contain subaddress: ${t}`);return new po(n.slice(0,i),{validate:!1})}decapsulateCode(e){let t;for(let n=N(this,Fi).length-1;n>-1;n--)if(N(this,Fi)[n].code===e){t=n;break}return new po(N(this,Fi).slice(0,t),{validate:!1})}equals(e){return We(this.bytes,e.bytes)}[(CR=pk,Cse)](){return`Multiaddr(${this.toString()})`}},Fi=new WeakMap,vu=new WeakMap,_u=new WeakMap,po);function Rse(r){r.getComponents().forEach(e=>{var n;const t=Eh.getProtocol(e.code);e.value!=null&&((n=t.validate)==null||n.call(t,e.value))})}function Dse(r){return!!(r!=null&&r[pk])}function mk(r){return new Pse(r)}var Lr;(function(r){(function(n){n.FIN="FIN",n.STOP_SENDING="STOP_SENDING",n.RESET="RESET",n.FIN_ACK="FIN_ACK"})(r.Flag||(r.Flag={}));let e;(function(n){n[n.FIN=0]="FIN",n[n.STOP_SENDING=1]="STOP_SENDING",n[n.RESET=2]="RESET",n[n.FIN_ACK=3]="FIN_ACK"})(e||(e={})),(function(n){n.codec=()=>Jc(e)})(r.Flag||(r.Flag={}));let t;r.codec=()=>(t==null&&(t=Gt((n,i,s={})=>{s.lengthDelimited!==!1&&i.fork(),n.flag!=null&&(i.uint32(8),r.Flag.codec().encode(n.flag,i)),n.message!=null&&(i.uint32(18),i.bytes(n.message)),s.lengthDelimited!==!1&&i.ldelim()},(n,i,s={})=>{const o={},a=i==null?n.len:n.pos+i;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.flag=r.Flag.codec().decode(n);break}case 2:{o.message=n.bytes();break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>Ht(n,r.codec()),r.decode=(n,i)=>Vt(n,r.codec(),i)})(Lr||(Lr={}));const Lse=["stun:stun.l.google.com:19302","stun:global.stun.twilio.com:3478","stun:stun.cloudflare.com:3478","stun:stun.services.mozilla.com:3478"];Array.from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890");const Nse=2*1024*1024,gk=16*1024;function Ose(r=gk){const e=Ue(r-Ue(r)),t=1+Ue(Object.keys(Lr.Flag).length-1),n=1,i=r-e-t-n,s=Ue(i);return e+t+n+s}const Use=Ose(),kse=1e4,yk="/webrtc",IS="/webrtc-signaling/0.0.1",Bse=8,uM=1024*1024*4;let Fse=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidMessageLengthError");f(this,"code","ERR_INVALID_MSG_LENGTH")}},bk=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidDataLengthError");f(this,"code","ERR_MSG_DATA_TOO_LONG")}},$se=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidDataLengthLengthError");f(this,"code","ERR_MSG_LENGTH_TOO_LONG")}},NC=class extends Error{constructor(){super(...arguments);f(this,"name","UnexpectedEOFError");f(this,"code","ERR_UNEXPECTED_EOF")}};function wk(r){return r[Symbol.asyncIterator]!=null}function vk(r,e){if(r.byteLength>e)throw new bk("Message length too long")}const H0=r=>{const e=Ue(r),t=ns(e);return Zl(r,t),H0.bytes=e,t};H0.bytes=0;function PS(r,e){e=e??{};const t=e.lengthEncoder??H0,n=(e==null?void 0:e.maxDataLength)??uM;function*i(s){vk(s,n);const o=t(s.byteLength);o instanceof Uint8Array?yield o:yield*o,s instanceof Uint8Array?yield s:yield*s}return wk(r)?(async function*(){for await(const s of r)yield*i(s)})():(function*(){for(const s of r)yield*i(s)})()}PS.single=(r,e)=>{e=e??{};const t=e.lengthEncoder??H0,n=(e==null?void 0:e.maxDataLength)??uM;return vk(r,n),new vt(t(r.byteLength),r)};var nc;(function(r){r[r.LENGTH=0]="LENGTH",r[r.DATA=1]="DATA"})(nc||(nc={}));const hM=r=>{const e=Yt(r);return hM.bytes=Ue(e),e};hM.bytes=0;function RS(r,e){const t=new vt;let n=nc.LENGTH,i=-1;const s=(e==null?void 0:e.lengthDecoder)??hM,o=(e==null?void 0:e.maxLengthLength)??Bse,a=(e==null?void 0:e.maxDataLength)??uM;function*c(){for(;t.byteLength>0;){if(n===nc.LENGTH)try{if(i=s(t),i<0)throw new Fse("Invalid message length");if(i>a)throw new bk("Message length too long");const l=s.bytes;t.consume(l),(e==null?void 0:e.onLength)!=null&&e.onLength(i),n=nc.DATA}catch(l){if(l instanceof RangeError){if(t.byteLength>o)throw new $se("Message length length too long");break}throw l}if(n===nc.DATA){if(t.byteLength<i)break;const l=t.sublist(0,i);t.consume(i),(e==null?void 0:e.onData)!=null&&e.onData(l),yield l,n=nc.LENGTH}}}return wk(r)?(async function*(){for await(const l of r)t.append(l),yield*c();if(t.byteLength>0)throw new NC("Unexpected end of input")})():(function*(){for(const l of r)t.append(l),yield*c();if(t.byteLength>0)throw new NC("Unexpected end of input")})()}RS.fromReader=(r,e)=>{let t=1;const n=(async function*(){for(;;)try{const{done:s,value:o}=await r.next(t);if(s===!0)return;o!=null&&(yield o)}catch(s){if(s.code==="ERR_UNDER_READ")return{done:!0,value:null};throw s}finally{t=1}})();return RS(n,{...e??{},onLength:s=>{t=s}})};var OC=function(r,e,t){if(t||arguments.length===2)for(var n=0,i=e.length,s;n<i;n++)(s||!(n in e))&&(s||(s=Array.prototype.slice.call(e,0,n)),s[n]=e[n]);return r.concat(s||Array.prototype.slice.call(e))},zse=(function(){function r(e,t,n){this.name=e,this.version=t,this.os=n,this.type="browser"}return r})(),Vse=(function(){function r(e){this.version=e,this.type="node",this.name="node",this.os=process.platform}return r})(),Hse=(function(){function r(e,t,n,i){this.name=e,this.version=t,this.os=n,this.bot=i,this.type="bot-device"}return r})(),Gse=(function(){function r(){this.type="bot",this.bot=!0,this.name="bot",this.version=null,this.os=null}return r})(),Wse=(function(){function r(){this.type="react-native",this.name="react-native",this.version=null,this.os=null}return r})(),qse=/alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,Kse=/(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,UC=3,Xse=[["aol",/AOLShield\/([0-9\._]+)/],["edge",/Edge\/([0-9\._]+)/],["edge-ios",/EdgiOS\/([0-9\._]+)/],["yandexbrowser",/YaBrowser\/([0-9\._]+)/],["kakaotalk",/KAKAOTALK\s([0-9\.]+)/],["samsung",/SamsungBrowser\/([0-9\.]+)/],["silk",/\bSilk\/([0-9._-]+)\b/],["miui",/MiuiBrowser\/([0-9\.]+)$/],["beaker",/BeakerBrowser\/([0-9\.]+)/],["edge-chromium",/EdgA?\/([0-9\.]+)/],["chromium-webview",/(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["chrome",/(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["phantomjs",/PhantomJS\/([0-9\.]+)(:?\s|$)/],["crios",/CriOS\/([0-9\.]+)(:?\s|$)/],["firefox",/Firefox\/([0-9\.]+)(?:\s|$)/],["fxios",/FxiOS\/([0-9\.]+)/],["opera-mini",/Opera Mini.*Version\/([0-9\.]+)/],["opera",/Opera\/([0-9\.]+)(?:\s|$)/],["opera",/OPR\/([0-9\.]+)(:?\s|$)/],["pie",/^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],["pie",/^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],["netfront",/^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],["ie",/Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],["ie",/MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],["ie",/MSIE\s(7\.0)/],["bb10",/BB10;\sTouch.*Version\/([0-9\.]+)/],["android",/Android\s([0-9\.]+)/],["ios",/Version\/([0-9\._]+).*Mobile.*Safari.*/],["safari",/Version\/([0-9\._]+).*Safari/],["facebook",/FB[AS]V\/([0-9\.]+)/],["instagram",/Instagram\s([0-9\.]+)/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Mobile/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Gecko\)$/],["curl",/^curl\/([0-9\.]+)$/],["searchbot",qse]],kC=[["iOS",/iP(hone|od|ad)/],["Android OS",/Android/],["BlackBerry OS",/BlackBerry|BB10/],["Windows Mobile",/IEMobile/],["Amazon OS",/Kindle/],["Windows 3.11",/Win16/],["Windows 95",/(Windows 95)|(Win95)|(Windows_95)/],["Windows 98",/(Windows 98)|(Win98)/],["Windows 2000",/(Windows NT 5.0)|(Windows 2000)/],["Windows XP",/(Windows NT 5.1)|(Windows XP)/],["Windows Server 2003",/(Windows NT 5.2)/],["Windows Vista",/(Windows NT 6.0)/],["Windows 7",/(Windows NT 6.1)/],["Windows 8",/(Windows NT 6.2)/],["Windows 8.1",/(Windows NT 6.3)/],["Windows 10",/(Windows NT 10.0)/],["Windows ME",/Windows ME/],["Windows CE",/Windows CE|WinCE|Microsoft Pocket Internet Explorer/],["Open BSD",/OpenBSD/],["Sun OS",/SunOS/],["Chrome OS",/CrOS/],["Linux",/(Linux)|(X11)/],["Mac OS",/(Mac_PowerPC)|(Macintosh)/],["QNX",/QNX/],["BeOS",/BeOS/],["OS/2",/OS\/2/]];function Yse(r){return typeof document>"u"&&typeof navigator<"u"&&navigator.product==="ReactNative"?new Wse:typeof navigator<"u"?Jse(navigator.userAgent):Qse()}function Zse(r){return r!==""&&Xse.reduce(function(e,t){var n=t[0],i=t[1];if(e)return e;var s=i.exec(r);return!!s&&[n,s]},!1)}function Jse(r){var e=Zse(r);if(!e)return null;var t=e[0],n=e[1];if(t==="searchbot")return new Gse;var i=n[1]&&n[1].split(".").join("_").split("_").slice(0,3);i?i.length<UC&&(i=OC(OC([],i,!0),eoe(UC-i.length),!0)):i=[];var s=i.join("."),o=jse(r),a=Kse.exec(r);return a&&a[1]?new Hse(t,s,o,a[1]):new zse(t,s,o)}function jse(r){for(var e=0,t=kC.length;e<t;e++){var n=kC[e],i=n[0],s=n[1],o=s.exec(r);if(o)return i}return null}function Qse(){var r=typeof process<"u"&&process.version;return r?new Vse(process.version.slice(1)):null}function eoe(r){for(var e=[],t=0;t<r;t++)e.push("0");return e}const BC=Yse(),toe=BC!=null&&BC.name==="firefox";async function FC(r){return r=r??{},typeof r=="function"&&(r=await r()),r.iceServers=r.iceServers??Lse.map(e=>({urls:[e]})),r}class noe extends iO{constructor(t){super({...t,maxMessageSize:(t.maxMessageSize??gk)-Use});f(this,"channel");f(this,"incomingData");f(this,"maxBufferedAmount");f(this,"receivedFinAck");f(this,"finAckTimeout");this.channel=t.channel,this.channel.binaryType="arraybuffer",this.incomingData=k0(),this.maxBufferedAmount=t.maxBufferedAmount??Nse,this.finAckTimeout=t.finAckTimeout??kse,this.channel.onclose=()=>{this.log.trace("received datachannel close event"),this.onRemoteCloseWrite(),this.onTransportClosed()},this.channel.onerror=i=>{const s=i.error;this.log.trace("received datachannel error event - %e",s),this.abort(s)},this.channel.onmessage=async i=>{this.log("incoming message %d bytes",i.data.byteLength);const{data:s}=i;s===null||s.byteLength===0||this.incomingData.push(new Uint8Array(s,0,s.byteLength))},this.channel.bufferedAmountLowThreshold=0,this.channel.onbufferedamountlow=()=>{this.writableNeedsDrain&&this.safeDispatchEvent("drain")},Promise.resolve().then(async()=>{for await(const i of RS(this.incomingData))this.processIncomingProtobuf(i)}).catch(i=>{this.log.error("error processing incoming data channel messages - %e",i)});const n=()=>{this.channel.readyState==="open"&&(this.log.trace("stream closed, closing underlying datachannel"),this.channel.close())};this.addEventListener("close",n),this.channel.readyState!=="open"&&(this.log('channel ready state is "%s" and not "open", waiting for "open" event before sending data',this.channel.readyState),Dn(this.channel,"open",{rejectionEvents:["close","error"]}).then(()=>{this.log('channel ready state is now "%s", dispatching drain',this.channel.readyState),this.safeDispatchEvent("drain")}).catch(i=>{this.abort(i.error??i)}))}sendNewStream(){}_sendMessage(t){if(this.channel.readyState!=="open")throw new ok(`Invalid datachannel state - ${this.channel.readyState}`);if(this.log.trace('sending message, channel state "%s"',this.channel.readyState),toe){this.channel.send(t.subarray());return}for(const n of t)this.channel.send(n)}sendData(t){return this.channel.readyState!=="open"?{sentBytes:0,canSendMore:!1}:(this._sendMessage(PS.single(Lr.encode({message:t.subarray()}))),{sentBytes:t.byteLength,canSendMore:this.channel.bufferedAmount<this.maxBufferedAmount})}sendReset(t){var n;try{this.log.error("sending reset - %e",t),this._sendFlag(Lr.Flag.RESET),(n=this.receivedFinAck)==null||n.reject(t)}catch(i){this.log.error("failed to send reset - %e",i)}}async sendCloseWrite(t){var s;this._sendFlag(Lr.Flag.FIN),(s=t==null?void 0:t.signal)==null||s.throwIfAborted(),this.receivedFinAck=Promise.withResolvers();const n=(t==null?void 0:t.signal)??AbortSignal.timeout(this.finAckTimeout),i=[Dn(this.channel,"close",{signal:n}),Dn(this.channel,"error",{signal:n})];await Promise.any([rs(this.receivedFinAck.promise,n),...i]).finally(()=>{i.forEach(o=>o.cancel())})}async sendCloseRead(t){var n;this._sendFlag(Lr.Flag.STOP_SENDING),(n=t==null?void 0:t.signal)==null||n.throwIfAborted()}processIncomingProtobuf(t){var i,s;const n=Lr.decode(t);n.message!=null&&(this.readStatus==="readable"||this.readStatus==="paused")&&this.onData(new vt(n.message)),n.flag!==void 0&&(this.log.trace('incoming flag %s, write status "%s", read status "%s"',n.flag,this.writeStatus,this.readStatus),n.flag===Lr.Flag.FIN&&(this._sendFlag(Lr.Flag.FIN_ACK),this.onRemoteCloseWrite()),n.flag===Lr.Flag.RESET&&((i=this.receivedFinAck)==null||i.reject(new sk("The stream was reset")),this.onRemoteReset()),n.flag===Lr.Flag.STOP_SENDING&&this.onRemoteCloseRead(),n.flag===Lr.Flag.FIN_ACK&&((s=this.receivedFinAck)==null||s.resolve()))}_sendFlag(t){if(this.channel.readyState!=="open")return this.log.trace('not sending flag %s because channel is "%s" and not "open"',t.toString(),this.channel.readyState),!1;this.log.trace("sending flag %s",t.toString());const n=Lr.encode({flag:t}),i=PS.single(n);try{return this._sendMessage(i),!0}catch(s){this.log.error("could not send flag %s - %e",t.toString(),s)}return!1}sendPause(){}sendResume(){}}function $C(r){const{channel:e,direction:t,isHandshake:n}=r;return new noe({...r,id:`${e.id}`,log:r.log.newScope(`${n===!0?"handshake":t}:${e.id}`),protocol:""})}class _k{constructor(e){f(this,"protocol");f(this,"peerConnection");f(this,"metrics");f(this,"dataChannelOptions");f(this,"earlyDataChannels");this.onEarlyDataChannel=this.onEarlyDataChannel.bind(this),this.peerConnection=e.peerConnection,this.metrics=e.metrics,this.protocol=e.protocol??yk,this.dataChannelOptions=e.dataChannelOptions??{},this.peerConnection.addEventListener("datachannel",this.onEarlyDataChannel),this.earlyDataChannels=[]}onEarlyDataChannel(e){this.earlyDataChannels.push(e.channel)}createStreamMuxer(e){return this.peerConnection.removeEventListener("datachannel",this.onEarlyDataChannel),new roe(e,{peerConnection:this.peerConnection,dataChannelOptions:this.dataChannelOptions,metrics:this.metrics,protocol:this.protocol,earlyDataChannels:this.earlyDataChannels})}}class roe extends rO{constructor(t,n){super(t,{...n,name:"muxer"});f(this,"peerConnection");f(this,"dataChannelOptions");this.peerConnection=n.peerConnection,this.protocol=n.protocol??yk,this.dataChannelOptions=n.dataChannelOptions??{},this.peerConnection.ondatachannel=({channel:i})=>{this.onDataChannel(i)},queueMicrotask(()=>{if(this.status!=="open"){n.earlyDataChannels.forEach(i=>{i.close()});return}n.earlyDataChannels.forEach(i=>{this.onDataChannel(i)})})}onDataChannel(t){if(this.log("incoming datachannel with channel id %d, protocol %s and status %s",t.id,t.protocol,t.readyState),t.label==="init"){this.log.trace("closing init channel %d",t.id),t.close();return}const n=$C({...this.streamOptions,...this.dataChannelOptions,channel:t,direction:"inbound",log:this.log});this.onRemoteStream(n)}async onCreateStream(t){const n=this.peerConnection.createDataChannel("",{});return this.log("open channel %d for protocol %s",n.id,t==null?void 0:t.protocol),$C({...t,...this.dataChannelOptions,channel:n,direction:"outbound",log:this.log})}onData(){}}class ioe extends Y1{constructor(t){super(t);f(this,"peerConnection");this.peerConnection=t.peerConnection;const n=t.peerConnection.connectionState;this.peerConnection.onconnectionstatechange=()=>{this.log.trace("peer connection state change %s initial state %s",this.peerConnection.connectionState,n),(this.peerConnection.connectionState==="disconnected"||this.peerConnection.connectionState==="failed"||this.peerConnection.connectionState==="closed")&&(this.onTransportClosed(),this.peerConnection.close())}}sendData(t){return{sentBytes:t.byteLength,canSendMore:!0}}async sendClose(t){var n;this.peerConnection.close(),(n=t==null?void 0:t.signal)==null||n.throwIfAborted()}sendReset(){this.peerConnection.close()}sendPause(){}sendResume(){}}const zC=r=>new ioe(r),xk=globalThis.RTCPeerConnection,Sk=globalThis.RTCSessionDescription,soe=globalThis.RTCIceCandidate;class ooe extends Error{constructor(e){super(`WebRTC transport error: ${e}`),this.name="WebRTCTransportError"}}class fa extends ooe{constructor(e="SDP handshake failed"){super(e),this.name="SDPHandshakeFailedError"}}var Yi;(function(r){(function(n){n.SDP_OFFER="SDP_OFFER",n.SDP_ANSWER="SDP_ANSWER",n.ICE_CANDIDATE="ICE_CANDIDATE"})(r.Type||(r.Type={}));let e;(function(n){n[n.SDP_OFFER=0]="SDP_OFFER",n[n.SDP_ANSWER=1]="SDP_ANSWER",n[n.ICE_CANDIDATE=2]="ICE_CANDIDATE"})(e||(e={})),(function(n){n.codec=()=>Jc(e)})(r.Type||(r.Type={}));let t;r.codec=()=>(t==null&&(t=Gt((n,i,s={})=>{s.lengthDelimited!==!1&&i.fork(),n.type!=null&&(i.uint32(8),r.Type.codec().encode(n.type,i)),n.data!=null&&(i.uint32(18),i.string(n.data)),s.lengthDelimited!==!1&&i.ldelim()},(n,i,s={})=>{const o={},a=i==null?n.len:n.pos+i;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.data=n.string();break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>Ht(n,r.codec()),r.decode=(n,i)=>Vt(n,r.codec(),i)})(Yi||(Yi={}));const Ek=async(r,e,t)=>{var n,i,s,o;try{const a=Promise.withResolvers();for(aoe(r,a);;){const c=await Promise.race([a.promise,e.read({signal:t.signal})]);if(c==null){(n=t.signal)==null||n.throwIfAborted();break}if(c.type!==Yi.Type.ICE_CANDIDATE)throw new cie("ICE candidate message expected");const l=JSON.parse(c.data??"null");if(l===""||l===null){(i=t.onProgress)==null||i.call(t,new Rt("webrtc:end-of-ice-candidates")),t.log.trace("end-of-candidates received");continue}const u=new soe(l);t.log.trace("%s received new ICE candidate %o",t.direction,l);try{(s=t.onProgress)==null||s.call(t,new Rt("webrtc:add-ice-candidate",u.candidate)),await r.addIceCandidate(u)}catch(h){t.log.error("%s bad candidate received %o - %e",t.direction,l,h)}}}catch(a){if(t.log.error("%s error parsing ICE candidate - %e",t.direction,a),((o=t.signal)==null?void 0:o.aborted)===!0&&r.connectionState!=="connected")throw a}};function aoe(r,e){if(r.connectionState==="connected"){e.resolve();return}r.onconnectionstatechange=t=>{switch(r.connectionState){case"connected":e.resolve();break;case"failed":case"disconnected":case"closed":e.reject(new ik(`RTCPeerConnection connection state became "${r.connectionState}"`));break}}}function Mk(r){let e;for(const t of r.getComponents())t.name==="p2p"&&(e=uk(t.value??""));if(e==null)throw new sie("Remote peerId must be present in multiaddr");return e}async function coe({rtcConfiguration:r,dataChannel:e,signal:t,metrics:n,multiaddr:i,connectionManager:s,transportManager:o,log:a,logger:c,onProgress:l}){const{circuitAddress:u,targetPeer:h}=hoe(i);n==null||n.dialerEvents.increment({open:!0}),a.trace("dialing circuit address: %a",u);const d=s.getConnections(h);let m;d.length===0?(l==null||l(new Rt("webrtc:dial-relay")),m=await o.dial(u,{signal:t,onProgress:l})):(l==null||l(new Rt("webrtc:reuse-relay-connection")),m=d[0]),l==null||l(new Rt("webrtc:open-signaling-stream"));const p=await m.newStream(IS,{signal:t,runOnLimitedConnection:!0}),b=Ma(p).pb(Yi),g=new xk(r);g.addEventListener("connectionstatechange",()=>{switch(g.connectionState){case"closed":g.close();break}});const y=new _k({peerConnection:g,dataChannelOptions:e});try{const v=g.createDataChannel("init");g.onicecandidate=({candidate:E})=>{if(g.connectionState==="connected"){a.trace("ignore new ice candidate as peer connection is already connected");return}if(E==null||(E==null?void 0:E.candidate)===""){a.trace("initiator detected end of ICE candidates");return}const C=JSON.stringify((E==null?void 0:E.toJSON())??null);a.trace("initiator sending ICE candidate %o",E),b.write({type:Yi.Type.ICE_CANDIDATE,data:C},{signal:t}).catch(I=>{a.error("error sending ICE candidate - %e",I)})},g.onicecandidateerror=E=>{a.error("initiator ICE candidate error",E)};const w=await g.createOffer().catch(E=>{throw a.error("could not execute createOffer - %e",E),new fa("Failed to set createOffer")});a.trace("initiator send SDP offer %s",w.sdp),l==null||l(new Rt("webrtc:send-sdp-offer")),await b.write({type:Yi.Type.SDP_OFFER,data:w.sdp},{signal:t}),await g.setLocalDescription(w).catch(E=>{throw a.error("could not execute setLocalDescription - %e",E),new fa("Failed to set localDescription")}),l==null||l(new Rt("webrtc:read-sdp-answer")),a.trace("initiator read SDP answer");const _=await b.read({signal:t});if(_.type!==Yi.Type.SDP_ANSWER)throw new fa("Remote should send an SDP answer");a.trace("initiator received SDP answer %s",_.data);const M=new Sk({type:"answer",sdp:_.data});return await g.setRemoteDescription(M).catch(E=>{throw a.error("could not execute setRemoteDescription - %e",E),new fa("Failed to set remoteDescription")}),a.trace("initiator read candidates until connected"),l==null||l(new Rt("webrtc:read-ice-candidates")),await Ek(g,b,{direction:"initiator",signal:t,log:a,onProgress:l}),a.trace("initiator connected"),v.readyState!=="open"&&(a.trace("wait for init channel to open"),await Dn(v,"open",{signal:t})),a.trace("closing init channel"),v.close(),a.trace("waiting for init channel to close"),await Dn(v,"close",{signal:t}),l==null||l(new Rt("webrtc:close-signaling-stream")),a.trace("closing signaling channel"),await p.close({signal:t}),a.trace("initiator connected to remote address %s",i),{remoteAddress:i,peerConnection:g,muxerFactory:y}}catch(v){throw a.error("outgoing signaling error - %e",v),g.close(),p.abort(v),v}finally{g.onicecandidate=null,g.onicecandidateerror=null}}const VC=Ot(cM.matchers[0],Nt(dk));class dM extends Pr{constructor(t,n){super();f(this,"transportManager");f(this,"shutdownController");f(this,"events");this.transportManager=t.transportManager,this.events=t.events,this.shutdownController=n.shutdownController,this.onTransportListening=this.onTransportListening.bind(this)}async listen(){this.events.addEventListener("transport:listening",this.onTransportListening)}onTransportListening(t){t.detail.getAddrs().filter(i=>VC.exactMatch(i)).map(i=>i.encapsulate("/webrtc")).length>0&&this.safeDispatchEvent("listening")}getAddrs(){return this.transportManager.getListeners().filter(t=>!(t instanceof dM)).map(t=>t.getAddrs().filter(n=>VC.exactMatch(n)).map(n=>n.encapsulate("/webrtc"))).flat()}updateAnnounceAddrs(){}async close(){this.events.removeEventListener("transport:listening",this.onTransportListening),this.shutdownController.abort(),queueMicrotask(()=>{this.safeDispatchEvent("close")})}}async function loe(r,e,{peerConnection:t,signal:n,log:i}){i.trace("new inbound signaling stream");const s=Ma(r).pb(Yi);try{t.onicecandidate=({candidate:h})=>{if(t.connectionState==="connected"){i.trace("ignore new ice candidate as peer connection is already connected");return}if(h==null||(h==null?void 0:h.candidate)===""){i.trace("recipient detected end of ICE candidates");return}const d=JSON.stringify((h==null?void 0:h.toJSON())??null);i.trace("recipient sending ICE candidate %s",d),s.write({type:Yi.Type.ICE_CANDIDATE,data:d},{signal:n}).catch(m=>{i.error("error sending ICE candidate - %e",m)})},i.trace("recipient read SDP offer");const c=await s.read({signal:n});if(c.type!==Yi.Type.SDP_OFFER)throw new fa(`expected message type SDP_OFFER, received: ${c.type??"undefined"} `);i.trace("recipient received SDP offer %s",c.data);const l=new Sk({type:"offer",sdp:c.data});await t.setRemoteDescription(l).catch(h=>{throw i.error("could not execute setRemoteDescription - %e",h),new fa("Failed to set remoteDescription")});const u=await t.createAnswer().catch(h=>{throw i.error("could not execute createAnswer - %e",h),new fa("Failed to create answer")});i.trace("recipient send SDP answer %s",u.sdp),await s.write({type:Yi.Type.SDP_ANSWER,data:u.sdp},{signal:n}),await t.setLocalDescription(u).catch(h=>{throw i.error("could not execute setLocalDescription - %e",h),new fa("Failed to set localDescription")}),i.trace("recipient read candidates until connected"),await Ek(t,s,{direction:"recipient",signal:n,log:i})}catch(c){if(t.connectionState!=="connected")throw i.error("error while handling signaling stream from peer %a - %e",e.remoteAddr,c),t.close(),c;i("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected",e.remoteAddr,c)}const o=Mk(e.remoteAddr),a=mk(`/webrtc/p2p/${o}`);return i.trace("recipient connected to remote address %s",a),{remoteAddress:a,remotePeer:o}}var IR,PR,RR,DR;DR=lie,RR=Symbol.toStringTag,PR=uie,IR=hie;class uoe{constructor(e,t={}){f(this,"components");f(this,"init");f(this,"log");f(this,"_started",!1);f(this,"metrics");f(this,"shutdownController");f(this,DR,!0);f(this,RR,"@libp2p/webrtc");f(this,PR,["@libp2p/transport"]);f(this,IR,["@libp2p/identify","@libp2p/circuit-relay-v2-transport"]);this.components=e,this.init=t,this.log=e.logger.forComponent("libp2p:webrtc"),this.shutdownController=new AbortController,this.shutdownController.signal,e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total",{label:"event",help:"Total count of WebRTC dialer events by type"}),listenerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total",{label:"event",help:"Total count of WebRTC listener events by type"})})}isStarted(){return this._started}async start(){await this.components.registrar.handle(IS,(e,t)=>{const n=this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);this._onProtocol(e,t,n).catch(i=>{this.log.error("failed to handle incoming connect from %p - %e",t.remotePeer,i)}).finally(()=>{n.clear()})},{runOnLimitedConnection:!0}),this._started=!0}async stop(){await this.components.registrar.unhandle(IS),this._started=!1}createListener(e){return new dM(this.components,{shutdownController:this.shutdownController})}listenFilter(e){return e.filter(bS.exactMatch)}dialFilter(e){return this.listenFilter(e)}async dial(e,t){var c;this.log.trace("dialing address: %a",e);const{remoteAddress:n,peerConnection:i,muxerFactory:s}=await coe({rtcConfiguration:await FC(this.init.rtcConfiguration),dataChannel:this.init.dataChannel,multiaddr:e,dataChannelOptions:this.init.dataChannel,signal:t.signal,connectionManager:this.components.connectionManager,transportManager:this.components.transportManager,log:this.log,logger:this.components.logger,onProgress:t.onProgress}),o=zC({peerConnection:i,remoteAddr:n,metrics:(c=this.metrics)==null?void 0:c.dialerEvents,direction:"outbound",log:this.components.logger.forComponent("libp2p:webrtc:connection")}),a=await t.upgrader.upgradeOutbound(o,{skipProtection:!0,skipEncryption:!0,remotePeer:Mk(e),muxerFactory:s,onProgress:t.onProgress,signal:t.signal});return this._closeOnShutdown(i,o),a}async _onProtocol(e,t,n){var o;const i=new xk(await FC(this.init.rtcConfiguration));i.addEventListener("connectionstatechange",()=>{switch(i.connectionState){case"closed":i.close();break}});const s=new _k({peerConnection:i,dataChannelOptions:this.init.dataChannel});try{const{remoteAddress:a,remotePeer:c}=await loe(e,t,{peerConnection:i,signal:n,log:this.log});await e.close({signal:n});const l=zC({peerConnection:i,remoteAddr:a,metrics:(o=this.metrics)==null?void 0:o.listenerEvents,direction:"inbound",log:this.components.logger.forComponent("libp2p:webrtc:connection")});await this.components.upgrader.upgradeInbound(l,{skipEncryption:!0,skipProtection:!0,remotePeer:c,muxerFactory:s,signal:n}),this._closeOnShutdown(i,l)}catch(a){throw this.log.error("incoming signaling error - %e",a),i.close(),e.abort(a),a}}_closeOnShutdown(e,t){const n=()=>{t.close().catch(i=>{this.log.error("could not close WebRTCMultiaddrConnection - %e",i)})};this.shutdownController.signal.addEventListener("abort",n),e.addEventListener("close",()=>{this.shutdownController.signal.removeEventListener("abort",n)})}}function hoe(r){const e=r.getComponents().filter(({name:n})=>n==="p2p").map(({value:n})=>n).pop();if(e==null)throw new rk("Destination peer id was missing");return{circuitAddress:mk(r.getComponents().filter(({name:n})=>n!=="webrtc")),targetPeer:uk(e)}}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function doe(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function DS(r){if(typeof r!="boolean")throw new Error(`boolean expected, not ${r}`)}function Pw(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function Tr(r,e,t=""){const n=doe(r),i=r==null?void 0:r.length,s=e!==void 0;if(!n||s&&i!==e){const o=t&&`"${t}" `,a=s?` of length ${e}`:"",c=n?`length=${i}`:`type=${typeof r}`;throw new Error(o+"expected Uint8Array"+a+", got "+c)}return r}function HC(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function foe(r,e){Tr(r,void 0,"output");const t=e.outputLen;if(r.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function va(r){return new Uint32Array(r.buffer,r.byteOffset,Math.floor(r.byteLength/4))}function eh(...r){for(let e=0;e<r.length;e++)r[e].fill(0)}function poe(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}const moe=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function goe(r,e){if(e==null||typeof e!="object")throw new Error("options must be defined");return Object.assign(r,e)}function yoe(r,e){if(r.length!==e.length)return!1;let t=0;for(let n=0;n<r.length;n++)t|=r[n]^e[n];return t===0}const boe=(r,e)=>{function t(n,...i){if(Tr(n,void 0,"key"),!moe)throw new Error("Non little-endian hardware is not yet supported");if(r.nonceLength!==void 0){const u=i[0];Tr(u,r.varSizeNonce?void 0:r.nonceLength,"nonce")}const s=r.tagLength;s&&i[1]!==void 0&&Tr(i[1],void 0,"AAD");const o=e(n,...i),a=(u,h)=>{if(h!==void 0){if(u!==2)throw new Error("cipher output not supported");Tr(h,void 0,"output")}};let c=!1;return{encrypt(u,h){if(c)throw new Error("cannot encrypt() twice with same key + nonce");return c=!0,Tr(u),a(o.encrypt.length,h),o.encrypt(u,h)},decrypt(u,h){if(Tr(u),s&&u.length<s)throw new Error('"ciphertext" expected length bigger than tagLength='+s);return a(o.decrypt.length,h),o.decrypt(u,h)}}}return Object.assign(t,r),t};function GC(r,e,t=!0){if(e===void 0)return new Uint8Array(r);if(e.length!==r)throw new Error('"output" expected Uint8Array of length '+r+", got: "+e.length);if(t&&!voe(e))throw new Error("invalid output, must be aligned");return e}function woe(r,e,t){DS(t);const n=new Uint8Array(16),i=poe(n);return i.setBigUint64(0,BigInt(e),t),i.setBigUint64(8,BigInt(r),t),n}function voe(r){return r.byteOffset%4===0}function py(r){return Uint8Array.from(r)}const Ak=r=>Uint8Array.from(r.split(""),e=>e.charCodeAt(0)),_oe=Ak("expand 16-byte k"),xoe=Ak("expand 32-byte k"),Soe=va(_oe),Eoe=va(xoe);function yt(r,e){return r<<e|r>>>32-e}function LS(r){return r.byteOffset%4===0}const $m=64,Moe=16,Tk=2**32-1,WC=Uint32Array.of();function Aoe(r,e,t,n,i,s,o,a){const c=i.length,l=new Uint8Array($m),u=va(l),h=LS(i)&&LS(s),d=h?va(i):WC,m=h?va(s):WC;for(let p=0;p<c;o++){if(r(e,t,n,u,o,a),o>=Tk)throw new Error("arx: counter overflow");const b=Math.min($m,c-p);if(h&&b===$m){const g=p/4;if(p%4!==0)throw new Error("arx: invalid block position");for(let y=0,v;y<Moe;y++)v=g+y,m[v]=d[v]^u[y];p+=$m;continue}for(let g=0,y;g<b;g++)y=p+g,s[y]=i[y]^l[g];p+=b}}function Toe(r,e){const{allowShortKeys:t,extendNonceFn:n,counterLength:i,counterRight:s,rounds:o}=goe({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},e);if(typeof r!="function")throw new Error("core must be a function");return Pw(i),Pw(o),DS(s),DS(t),(a,c,l,u,h=0)=>{Tr(a,void 0,"key"),Tr(c,void 0,"nonce"),Tr(l,void 0,"data");const d=l.length;if(u===void 0&&(u=new Uint8Array(d)),Tr(u,void 0,"output"),Pw(h),h<0||h>=Tk)throw new Error("arx: counter overflow");if(u.length<d)throw new Error(`arx: output (${u.length}) is shorter than data (${d})`);const m=[];let p=a.length,b,g;if(p===32)m.push(b=py(a)),g=Eoe;else if(p===16&&t)b=new Uint8Array(32),b.set(a),b.set(a,16),g=Soe,m.push(b);else throw Tr(a,32,"arx key"),new Error("invalid key size");LS(c)||m.push(c=py(c));const y=va(b);if(n){if(c.length!==24)throw new Error("arx: extended nonce must be 24 bytes");n(g,y,va(c.subarray(0,16)),y),c=c.subarray(16)}const v=16-i;if(v!==c.length)throw new Error(`arx: nonce must be ${v} or 16 bytes`);if(v!==12){const _=new Uint8Array(12);_.set(c,s?0:12-c.length),c=_,m.push(c)}const w=va(c);return Aoe(r,g,y,w,l,u,h,o),eh(...m),u}}function Ln(r,e){return r[e++]&255|(r[e++]&255)<<8}class Coe{constructor(e){f(this,"blockLen",16);f(this,"outputLen",16);f(this,"buffer",new Uint8Array(16));f(this,"r",new Uint16Array(10));f(this,"h",new Uint16Array(10));f(this,"pad",new Uint16Array(8));f(this,"pos",0);f(this,"finished",!1);e=py(Tr(e,32,"key"));const t=Ln(e,0),n=Ln(e,2),i=Ln(e,4),s=Ln(e,6),o=Ln(e,8),a=Ln(e,10),c=Ln(e,12),l=Ln(e,14);this.r[0]=t&8191,this.r[1]=(t>>>13|n<<3)&8191,this.r[2]=(n>>>10|i<<6)&7939,this.r[3]=(i>>>7|s<<9)&8191,this.r[4]=(s>>>4|o<<12)&255,this.r[5]=o>>>1&8190,this.r[6]=(o>>>14|a<<2)&8191,this.r[7]=(a>>>11|c<<5)&8065,this.r[8]=(c>>>8|l<<8)&8191,this.r[9]=l>>>5&127;for(let u=0;u<8;u++)this.pad[u]=Ln(e,16+2*u)}process(e,t,n=!1){const i=n?0:2048,{h:s,r:o}=this,a=o[0],c=o[1],l=o[2],u=o[3],h=o[4],d=o[5],m=o[6],p=o[7],b=o[8],g=o[9],y=Ln(e,t+0),v=Ln(e,t+2),w=Ln(e,t+4),_=Ln(e,t+6),M=Ln(e,t+8),E=Ln(e,t+10),C=Ln(e,t+12),I=Ln(e,t+14);let x=s[0]+(y&8191),T=s[1]+((y>>>13|v<<3)&8191),F=s[2]+((v>>>10|w<<6)&8191),$=s[3]+((w>>>7|_<<9)&8191),H=s[4]+((_>>>4|M<<12)&8191),S=s[5]+(M>>>1&8191),A=s[6]+((M>>>14|E<<2)&8191),P=s[7]+((E>>>11|C<<5)&8191),L=s[8]+((C>>>8|I<<8)&8191),B=s[9]+(I>>>5|i),D=0,V=D+x*a+T*(5*g)+F*(5*b)+$*(5*p)+H*(5*m);D=V>>>13,V&=8191,V+=S*(5*d)+A*(5*h)+P*(5*u)+L*(5*l)+B*(5*c),D+=V>>>13,V&=8191;let z=D+x*c+T*a+F*(5*g)+$*(5*b)+H*(5*p);D=z>>>13,z&=8191,z+=S*(5*m)+A*(5*d)+P*(5*h)+L*(5*u)+B*(5*l),D+=z>>>13,z&=8191;let q=D+x*l+T*c+F*a+$*(5*g)+H*(5*b);D=q>>>13,q&=8191,q+=S*(5*p)+A*(5*m)+P*(5*d)+L*(5*h)+B*(5*u),D+=q>>>13,q&=8191;let G=D+x*u+T*l+F*c+$*a+H*(5*g);D=G>>>13,G&=8191,G+=S*(5*b)+A*(5*p)+P*(5*m)+L*(5*d)+B*(5*h),D+=G>>>13,G&=8191;let Y=D+x*h+T*u+F*l+$*c+H*a;D=Y>>>13,Y&=8191,Y+=S*(5*g)+A*(5*b)+P*(5*p)+L*(5*m)+B*(5*d),D+=Y>>>13,Y&=8191;let j=D+x*d+T*h+F*u+$*l+H*c;D=j>>>13,j&=8191,j+=S*a+A*(5*g)+P*(5*b)+L*(5*p)+B*(5*m),D+=j>>>13,j&=8191;let X=D+x*m+T*d+F*h+$*u+H*l;D=X>>>13,X&=8191,X+=S*c+A*a+P*(5*g)+L*(5*b)+B*(5*p),D+=X>>>13,X&=8191;let ne=D+x*p+T*m+F*d+$*h+H*u;D=ne>>>13,ne&=8191,ne+=S*l+A*c+P*a+L*(5*g)+B*(5*b),D+=ne>>>13,ne&=8191;let oe=D+x*b+T*p+F*m+$*d+H*h;D=oe>>>13,oe&=8191,oe+=S*u+A*l+P*c+L*a+B*(5*g),D+=oe>>>13,oe&=8191;let he=D+x*g+T*b+F*p+$*m+H*d;D=he>>>13,he&=8191,he+=S*h+A*u+P*l+L*c+B*a,D+=he>>>13,he&=8191,D=(D<<2)+D|0,D=D+V|0,V=D&8191,D=D>>>13,z+=D,s[0]=V,s[1]=z,s[2]=q,s[3]=G,s[4]=Y,s[5]=j,s[6]=X,s[7]=ne,s[8]=oe,s[9]=he}finalize(){const{h:e,pad:t}=this,n=new Uint16Array(10);let i=e[1]>>>13;e[1]&=8191;for(let a=2;a<10;a++)e[a]+=i,i=e[a]>>>13,e[a]&=8191;e[0]+=i*5,i=e[0]>>>13,e[0]&=8191,e[1]+=i,i=e[1]>>>13,e[1]&=8191,e[2]+=i,n[0]=e[0]+5,i=n[0]>>>13,n[0]&=8191;for(let a=1;a<10;a++)n[a]=e[a]+i,i=n[a]>>>13,n[a]&=8191;n[9]-=8192;let s=(i^1)-1;for(let a=0;a<10;a++)n[a]&=s;s=~s;for(let a=0;a<10;a++)e[a]=e[a]&s|n[a];e[0]=(e[0]|e[1]<<13)&65535,e[1]=(e[1]>>>3|e[2]<<10)&65535,e[2]=(e[2]>>>6|e[3]<<7)&65535,e[3]=(e[3]>>>9|e[4]<<4)&65535,e[4]=(e[4]>>>12|e[5]<<1|e[6]<<14)&65535,e[5]=(e[6]>>>2|e[7]<<11)&65535,e[6]=(e[7]>>>5|e[8]<<8)&65535,e[7]=(e[8]>>>8|e[9]<<5)&65535;let o=e[0]+t[0];e[0]=o&65535;for(let a=1;a<8;a++)o=(e[a]+t[a]|0)+(o>>>16)|0,e[a]=o&65535;eh(n)}update(e){HC(this),Tr(e),e=py(e);const{buffer:t,blockLen:n}=this,i=e.length;for(let s=0;s<i;){const o=Math.min(n-this.pos,i-s);if(o===n){for(;n<=i-s;s+=n)this.process(e,s);continue}t.set(e.subarray(s,s+o),this.pos),this.pos+=o,s+=o,this.pos===n&&(this.process(t,0,!1),this.pos=0)}return this}destroy(){eh(this.h,this.r,this.buffer,this.pad)}digestInto(e){HC(this),foe(e,this),this.finished=!0;const{buffer:t,h:n}=this;let{pos:i}=this;if(i){for(t[i++]=1;i<16;i++)t[i]=0;this.process(t,0,!0)}this.finalize();let s=0;for(let o=0;o<8;o++)e[s++]=n[o]>>>0,e[s++]=n[o]>>>8;return e}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}}function Ioe(r){const e=(n,i)=>r(i).update(n).digest(),t=r(new Uint8Array(32));return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=n=>r(n),e}const Poe=Ioe(r=>new Coe(r));function Roe(r,e,t,n,i,s=20){let o=r[0],a=r[1],c=r[2],l=r[3],u=e[0],h=e[1],d=e[2],m=e[3],p=e[4],b=e[5],g=e[6],y=e[7],v=i,w=t[0],_=t[1],M=t[2],E=o,C=a,I=c,x=l,T=u,F=h,$=d,H=m,S=p,A=b,P=g,L=y,B=v,D=w,V=_,z=M;for(let G=0;G<s;G+=2)E=E+T|0,B=yt(B^E,16),S=S+B|0,T=yt(T^S,12),E=E+T|0,B=yt(B^E,8),S=S+B|0,T=yt(T^S,7),C=C+F|0,D=yt(D^C,16),A=A+D|0,F=yt(F^A,12),C=C+F|0,D=yt(D^C,8),A=A+D|0,F=yt(F^A,7),I=I+$|0,V=yt(V^I,16),P=P+V|0,$=yt($^P,12),I=I+$|0,V=yt(V^I,8),P=P+V|0,$=yt($^P,7),x=x+H|0,z=yt(z^x,16),L=L+z|0,H=yt(H^L,12),x=x+H|0,z=yt(z^x,8),L=L+z|0,H=yt(H^L,7),E=E+F|0,z=yt(z^E,16),P=P+z|0,F=yt(F^P,12),E=E+F|0,z=yt(z^E,8),P=P+z|0,F=yt(F^P,7),C=C+$|0,B=yt(B^C,16),L=L+B|0,$=yt($^L,12),C=C+$|0,B=yt(B^C,8),L=L+B|0,$=yt($^L,7),I=I+H|0,D=yt(D^I,16),S=S+D|0,H=yt(H^S,12),I=I+H|0,D=yt(D^I,8),S=S+D|0,H=yt(H^S,7),x=x+T|0,V=yt(V^x,16),A=A+V|0,T=yt(T^A,12),x=x+T|0,V=yt(V^x,8),A=A+V|0,T=yt(T^A,7);let q=0;n[q++]=o+E|0,n[q++]=a+C|0,n[q++]=c+I|0,n[q++]=l+x|0,n[q++]=u+T|0,n[q++]=h+F|0,n[q++]=d+$|0,n[q++]=m+H|0,n[q++]=p+S|0,n[q++]=b+A|0,n[q++]=g+P|0,n[q++]=y+L|0,n[q++]=v+B|0,n[q++]=w+D|0,n[q++]=_+V|0,n[q++]=M+z|0}const Doe=Toe(Roe,{counterRight:!1,counterLength:4,allowShortKeys:!1}),Loe=new Uint8Array(16),qC=(r,e)=>{r.update(e);const t=e.length%16;t&&r.update(Loe.subarray(t))},Noe=new Uint8Array(32);function KC(r,e,t,n,i){i!==void 0&&Tr(i,void 0,"AAD");const s=r(e,t,Noe),o=woe(n.length,i?i.length:0,!0),a=Poe.create(s);i&&qC(a,i),qC(a,n),a.update(o);const c=a.digest();return eh(s,o),c}const Ooe=r=>(e,t,n)=>({encrypt(s,o){const a=s.length;o=GC(a+16,o,!1),o.set(s);const c=o.subarray(0,-16);r(e,t,c,c,1);const l=KC(r,e,t,c,n);return o.set(l,a),eh(l),o},decrypt(s,o){o=GC(s.length-16,o,!1);const a=s.subarray(0,-16),c=s.subarray(-16),l=KC(r,e,t,a,n);if(!yoe(c,l))throw new Error("invalid tag");return o.set(s.subarray(0,-16)),r(e,t,o,o,1),eh(l),o}}),XC=boe({blockSize:64,nonceLength:12,tagLength:16},Ooe(Doe));function Uoe(r,e,t){return D0(r),t===void 0&&(t=new Uint8Array(r.outputLen)),U0(r,t,e)}const Rw=Uint8Array.of(0),YC=Uint8Array.of();function koe(r,e,t,n=32){D0(r),Ea(n,"length");const i=r.outputLen;if(n>255*i)throw new Error("Length must be <= 255*HashLen");const s=Math.ceil(n/i);t===void 0?t=YC:lt(t,void 0,"info");const o=new Uint8Array(s*i),a=U0.create(r,e),c=a._cloneInto(),l=new Uint8Array(a.outputLen);for(let u=0;u<s;u++)Rw[0]=u+1,c.update(u===0?YC:l).update(t).update(Rw).digestInto(l),o.set(l,i*u),a._cloneInto(c);return a.destroy(),c.destroy(),Lc(l,Rw),o.slice(0,n)}function Boe(r){return e=>new uoe(e,r)}var __;let Foe=(__=class extends Error{constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}},f(__,"name","InvalidParametersError"),__);var x_;let $oe=(x_=class extends Error{constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}},f(x_,"name","InvalidCIDError"),x_);var S_;let zoe=(S_=class extends Error{constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}},f(S_,"name","InvalidMultihashError"),S_);var E_;let Voe=(E_=class extends Error{constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}},f(E_,"name","InvalidMessageError"),E_);class Ck extends Error{constructor(e="Dial error"){super(e),this.name="DialError"}}f(Ck,"name","DialError");class my extends Error{constructor(e="Listen error"){super(e),this.name="ListenError"}}f(my,"name","ListenError");const Ik=Symbol.for("@libp2p/peer-id"),Hoe="keep-alive";function Pk(r){return r!=null&&typeof r.start=="function"&&typeof r.stop=="function"}async function Goe(...r){const e=[];for(const t of r)Pk(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStart!=null&&await t.beforeStart()})),await Promise.all(e.map(async t=>{await t.start()})),await Promise.all(e.map(async t=>{t.afterStart!=null&&await t.afterStart()}))}async function Woe(...r){const e=[];for(const t of r)Pk(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStop!=null&&await t.beforeStop()})),await Promise.all(e.map(async t=>{await t.stop()})),await Promise.all(e.map(async t=>{t.afterStop!=null&&await t.afterStop()}))}const qoe=Symbol.for("@libp2p/transport");var ZC;(function(r){r[r.FATAL_ALL=0]="FATAL_ALL",r[r.NO_FATAL=1]="NO_FATAL"})(ZC||(ZC={}));const Koe=Symbol.for("@libp2p/service-capabilities"),Xoe=Symbol.for("@libp2p/service-dependencies"),Rk=Symbol.for("nodejs.util.inspect.custom"),Yoe=114;var LR;let fM=class{constructor(e){f(this,"type");f(this,"multihash");f(this,"publicKey");f(this,"string");f(this,LR,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=gt.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return Ze.createV1(Yoe,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return We(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return We(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(LR=Ik,Rk)](){return`PeerId(${this.toString()})`}},Zoe=class extends fM{constructor(t){super({...t,type:"RSA"});f(this,"type","RSA");f(this,"publicKey");this.publicKey=t.publicKey}},Joe=class extends fM{constructor(t){super({...t,type:"Ed25519"});f(this,"type","Ed25519");f(this,"publicKey");this.publicKey=t.publicKey}},joe=class extends fM{constructor(t){super({...t,type:"secp256k1"});f(this,"type","secp256k1");f(this,"publicKey");this.publicKey=t.publicKey}};const Qoe=2336;var NR,OR;let Dk=class{constructor(e){f(this,"type","url");f(this,"multihash");f(this,"publicKey");f(this,"url");f(this,NR,!0);this.url=e.toString(),this.multihash=dn.digest(Se(this.url))}[(OR=Rk,NR=Ik,OR)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return Ze.createV1(Qoe,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=ae(e)),e.toString()===this.toString())}};const eae=114,JC=2336;function jC(r,e){let t;if(r.charAt(0)==="1"||r.charAt(0)==="Q")t=Lo(gt.decode(`z${r}`));else{if(r.startsWith("k51qzi5uqu5")||r.startsWith("kzwfwjn5ji4")||r.startsWith("k2k4r8")||r.startsWith("bafz"))return tae(Ze.parse(r));throw new Foe('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return pM(t)}function pM(r){if(rae(r))return new Zoe({multihash:r});if(nae(r))try{const e=No(r);if(e.type==="Ed25519")return new Joe({multihash:r,publicKey:e});if(e.type==="secp256k1")return new joe({multihash:r,publicKey:e})}catch{const t=ae(r.digest);return new Dk(new URL(t))}throw new zoe("Supplied PeerID Multihash is invalid")}function tae(r){if((r==null?void 0:r.multihash)==null||r.version==null||r.version===1&&r.code!==eae&&r.code!==JC)throw new $oe("Supplied PeerID CID is invalid");if(r.code===JC){const e=ae(r.multihash.digest);return new Dk(new URL(e))}return pM(r.multihash)}function nae(r){return r.code===dn.code}function rae(r){return r.code===Ns.code}var M_;let _i=(M_=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidMultiaddrError")}},f(M_,"name","InvalidMultiaddrError"),M_);var A_;let Tf=(A_=class extends Error{constructor(){super(...arguments);f(this,"name","ValidationError")}},f(A_,"name","ValidationError"),A_);var T_;let iae=(T_=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidParametersError")}},f(T_,"name","InvalidParametersError"),T_);var C_;let sae=(C_=class extends Error{constructor(){super(...arguments);f(this,"name","UnknownProtocolError")}},f(C_,"name","UnknownProtocolError"),C_);const oae=4,aae=6,cae=273,lae=33,uae=41,hae=42,dae=43,fae=53,pae=54,mae=55,gae=56,yae=132,bae=301,wae=302,vae=400,gy=421,_ae=444,xae=445,Sae=446,Eae=447,Mae=448,Aae=449,Tae=454,Cae=460,Iae=461,Pae=465,Rae=466,Dae=480,Lae=481,Nae=443,Oae=477,Uae=478,kae=479,Bae=277,Fae=275,$ae=276,zae=280,Vae=281,mM=290,Hae=777;function QC(r){return e=>ae(e,r)}function eI(r){return e=>Se(e,r)}function fd(r){return new DataView(r.buffer).getUint16(r.byteOffset).toString()}function zl(r){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof r=="string"?parseInt(r):r),new Uint8Array(e)}function Gae(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=Se(e[0],"base32"),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=zl(n);return ut([t,i],t.length+i.length)}function Wae(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=Rn.decode(`b${e[0]}`),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=zl(n);return ut([t,i],t.length+i.length)}function tI(r){const e=r.subarray(0,r.length-2),t=r.subarray(r.length-2),n=ae(e,"base32"),i=fd(t);return`${n}:${i}`}const Lk=function(r){r=r.toString().trim();const e=new Uint8Array(4);return r.split(/\./g).forEach((t,n)=>{const i=parseInt(t,10);if(isNaN(i)||i<0||i>255)throw new _i("Invalid byte value in IP address");e[n]=i}),e},qae=function(r){let e=0;r=r.toString().trim();const t=r.split(":",8);let n;for(n=0;n<t.length;n++){const s=$t(t[n]);let o;s&&(o=Lk(t[n]),t[n]=ae(o.subarray(0,2),"base16")),o!=null&&++n<8&&t.splice(n,0,ae(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(n=0;n<t.length&&t[n]!=="";n++);const s=[n,1];for(n=9-t.length;n>0;n--)s.push("0");t.splice.apply(t,s)}const i=new Uint8Array(e+16);for(n=0;n<t.length;n++){t[n]===""&&(t[n]="0");const s=parseInt(t[n],16);if(isNaN(s)||s<0||s>65535)throw new _i("Invalid byte value in IP address");i[e++]=s>>8&255,i[e++]=s&255}return i},Kae=function(r){if(r.byteLength!==4)throw new _i("IPv4 address was incorrect length");const e=[];for(let t=0;t<r.byteLength;t++)e.push(r[t]);return e.join(".")},Xae=function(r){if(r.byteLength!==16)throw new _i("IPv6 address was incorrect length");const e=[];for(let n=0;n<r.byteLength;n+=2){const i=r[n],s=r[n+1],o=`${i.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const n=new URL(`http://[${t}]`);return n.hostname.substring(1,n.hostname.length-1)}catch{throw new _i(`Invalid IPv6 address "${t}"`)}};function Yae(r){try{const e=new URL(`http://[${r}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new _i(`Invalid IPv6 address "${r}"`)}}const Dw=Object.values(oi).map(r=>r.decoder),Zae=(function(){let r=Dw[0].or(Dw[1]);return Dw.slice(2).forEach(e=>r=r.or(e)),r})();function Jae(r){return Zae.decode(r)}function jae(r){return e=>r.encoder.encode(e)}function Qae(r){if(parseInt(r).toString()!==r)throw new Tf("Value must be an integer")}function ece(r){if(r<0)throw new Tf("Value must be a positive integer, or zero")}function tce(r){return e=>{if(e>r)throw new Tf(`Value must be smaller than or equal to ${r}`)}}function nce(...r){return e=>{for(const t of r)t(e)}}const zm=nce(Qae,ece,tce(65535)),rr=-1;let rce=class{constructor(){f(this,"protocolsByCode",new Map);f(this,"protocolsByName",new Map)}getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new sae(`Protocol ${e} was unknown`);return t}addProtocol(e){var t;this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),(t=e.aliases)==null||t.forEach(n=>{this.protocolsByName.set(n,e)})}removeProtocol(e){var n;const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),(n=t.aliases)==null||n.forEach(i=>{this.protocolsByName.delete(i)}))}};const Mh=new rce,ice=[{code:oae,name:"ip4",size:32,valueToBytes:Lk,bytesToValue:Kae,validate:r=>{if(!$t(r))throw new Tf(`Invalid IPv4 address "${r}"`)}},{code:aae,name:"tcp",size:16,valueToBytes:zl,bytesToValue:fd,validate:zm},{code:cae,name:"udp",size:16,valueToBytes:zl,bytesToValue:fd,validate:zm},{code:lae,name:"dccp",size:16,valueToBytes:zl,bytesToValue:fd,validate:zm},{code:uae,name:"ip6",size:128,valueToBytes:qae,bytesToValue:Xae,stringToValue:Yae,validate:r=>{if(!Ai(r))throw new Tf(`Invalid IPv6 address "${r}"`)}},{code:hae,name:"ip6zone",size:rr},{code:dae,name:"ipcidr",size:8,bytesToValue:QC("base10"),valueToBytes:eI("base10")},{code:fae,name:"dns",size:rr},{code:pae,name:"dns4",size:rr},{code:mae,name:"dns6",size:rr},{code:gae,name:"dnsaddr",size:rr},{code:yae,name:"sctp",size:16,valueToBytes:zl,bytesToValue:fd,validate:zm},{code:bae,name:"udt"},{code:wae,name:"utp"},{code:vae,name:"unix",size:rr,stringToValue:r=>decodeURIComponent(r),valueToString:r=>encodeURIComponent(r)},{code:gy,name:"p2p",aliases:["ipfs"],size:rr,bytesToValue:QC("base58btc"),valueToBytes:r=>r.startsWith("Q")||r.startsWith("1")?eI("base58btc")(r):Ze.parse(r).multihash.bytes},{code:_ae,name:"onion",size:96,bytesToValue:tI,valueToBytes:Gae},{code:xae,name:"onion3",size:296,bytesToValue:tI,valueToBytes:Wae},{code:Sae,name:"garlic64",size:rr},{code:Eae,name:"garlic32",size:rr},{code:Mae,name:"tls"},{code:Aae,name:"sni",size:rr},{code:Tae,name:"noise"},{code:Cae,name:"quic"},{code:Iae,name:"quic-v1"},{code:Pae,name:"webtransport"},{code:Rae,name:"certhash",size:rr,bytesToValue:jae(Mi),valueToBytes:Jae},{code:Dae,name:"http"},{code:Lae,name:"http-path",size:rr,stringToValue:r=>`/${decodeURIComponent(r)}`,valueToString:r=>encodeURIComponent(r.substring(1))},{code:Nae,name:"https"},{code:Oae,name:"ws"},{code:Uae,name:"wss"},{code:kae,name:"p2p-websocket-star"},{code:Bae,name:"p2p-stardust"},{code:Fae,name:"p2p-webrtc-star"},{code:$ae,name:"p2p-webrtc-direct"},{code:zae,name:"webrtc-direct"},{code:Vae,name:"webrtc"},{code:mM,name:"p2p-circuit"},{code:Hae,name:"memory",size:rr}];ice.forEach(r=>{Mh.addProtocol(r)});function sce(r){var n;const e=[];let t=0;for(;t<r.length;){const i=Yt(r,t),s=Mh.getProtocol(i),o=Ue(i),a=lce(s,r,t+o);let c=0;a>0&&s.size===rr&&(c=Ue(a));const l=o+c+a,u={code:i,name:s.name,bytes:r.subarray(t,t+l)};if(a>0){const h=t+o+c,d=r.subarray(h,h+a);u.value=((n=s.bytesToValue)==null?void 0:n.call(s,d))??ae(d)}e.push(u),t+=l}return e}function oce(r){var n;let e=0;const t=[];for(const i of r){if(i.bytes==null){const s=Mh.getProtocol(i.code),o=Ue(i.code);let a,c=0,l=0;i.value!=null&&(a=((n=s.valueToBytes)==null?void 0:n.call(s,i.value))??Se(i.value),c=a.byteLength,s.size===rr&&(l=Ue(c)));const u=new Uint8Array(o+l+c);let h=0;sn(i.code,u,h),h+=o,a!=null&&(s.size===rr&&(sn(c,u,h),h+=l),u.set(a,h)),i.bytes=u}t.push(i.bytes),e+=i.bytes.byteLength}return ut(t,e)}function ace(r){var s;if(r.charAt(0)!=="/")throw new _i('String multiaddr must start with "/"');const e=[];let t="protocol",n="",i="";for(let o=1;o<r.length;o++){const a=r.charAt(o);a!=="/"&&(t==="protocol"?i+=r.charAt(o):n+=r.charAt(o));const c=o===r.length-1;if(a==="/"||c){const l=Mh.getProtocol(i);if(t==="protocol"){if(l.size==null||l.size===0){e.push({code:l.code,name:l.name}),n="",i="",t="protocol";continue}else if(c)throw new _i(`Component ${i} was missing value`);t="value"}else if(t==="value"){const u={code:l.code,name:l.name};if(l.size!=null&&l.size!==0){if(n==="")throw new _i(`Component ${i} was missing value`);u.value=((s=l.stringToValue)==null?void 0:s.call(l,n))??n}e.push(u),n="",i="",t="protocol"}}}if(i!==""&&n!=="")throw new _i("Incomplete multiaddr");return e}function cce(r){return`/${r.flatMap(e=>{var n;if(e.value==null)return e.name;const t=Mh.getProtocol(e.code);if(t==null)throw new _i(`Unknown protocol code ${e.code}`);return[e.name,((n=t.valueToString)==null?void 0:n.call(t,e.value))??e.value]}).join("/")}`}function lce(r,e,t){return r.size==null||r.size===0?0:r.size>0?r.size/8:Yt(e,t)}const uce=Symbol.for("nodejs.util.inspect.custom"),Nk=Symbol.for("@multiformats/multiaddr");function hce(r){if(r==null&&(r="/"),pce(r))return r.getComponents();if(r instanceof Uint8Array)return sce(r);if(typeof r=="string")return r=r.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),r===""&&(r="/"),ace(r);if(Array.isArray(r))return r;throw new _i("Must be a string, Uint8Array, Component[], or another Multiaddr")}var UR,$i,xu,Su,mo;let dce=(mo=class{constructor(e="/",t={}){f(this,UR,!0);xe(this,$i);xe(this,xu);xe(this,Su);_e(this,$i,hce(e)),t.validate!==!1&&fce(this)}get bytes(){return N(this,Su)==null&&_e(this,Su,oce(N(this,$i))),N(this,Su)}toString(){return N(this,xu)==null&&_e(this,xu,cce(N(this,$i))),N(this,xu)}toJSON(){return this.toString()}getComponents(){return[...N(this,$i).map(e=>({...e}))]}encapsulate(e){const t=new mo(e);return new mo([...N(this,$i),...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),n=this.toString(),i=n.lastIndexOf(t);if(i<0)throw new iae(`Address ${this.toString()} does not contain subaddress: ${t}`);return new mo(n.slice(0,i),{validate:!1})}decapsulateCode(e){let t;for(let n=N(this,$i).length-1;n>-1;n--)if(N(this,$i)[n].code===e){t=n;break}return new mo(N(this,$i).slice(0,t),{validate:!1})}equals(e){return We(this.bytes,e.bytes)}[(UR=Nk,uce)](){return`Multiaddr(${this.toString()})`}},$i=new WeakMap,xu=new WeakMap,Su=new WeakMap,mo);function fce(r){r.getComponents().forEach(e=>{var n;const t=Mh.getProtocol(e.code);e.value!=null&&((n=t.validate)==null||n.call(t,e.value))})}function pce(r){return!!(r!=null&&r[Nk])}function _a(r){return new dce(r)}const mce=1,Ok=5e3,gce=100,Vm=`${Hoe}-circuit-relay`;BigInt(1<<17);const yy="/libp2p/circuit/relay/0.2.0/hop",nI="/libp2p/circuit/relay/0.2.0/stop",rI=300,yce=4096,bce=.001;var th;(function(r){(function(n){n.RESERVE="RESERVE",n.CONNECT="CONNECT",n.STATUS="STATUS"})(r.Type||(r.Type={}));let e;(function(n){n[n.RESERVE=0]="RESERVE",n[n.CONNECT=1]="CONNECT",n[n.STATUS=2]="STATUS"})(e||(e={})),(function(n){n.codec=()=>Jc(e)})(r.Type||(r.Type={}));let t;r.codec=()=>(t==null&&(t=Gt((n,i,s={})=>{s.lengthDelimited!==!1&&i.fork(),n.type!=null&&(i.uint32(8),r.Type.codec().encode(n.type,i)),n.peer!=null&&(i.uint32(18),nh.codec().encode(n.peer,i)),n.reservation!=null&&(i.uint32(26),by.codec().encode(n.reservation,i)),n.limit!=null&&(i.uint32(34),rh.codec().encode(n.limit,i)),n.status!=null&&(i.uint32(40),Cr.codec().encode(n.status,i)),s.lengthDelimited!==!1&&i.ldelim()},(n,i,s={})=>{var c,l,u;const o={},a=i==null?n.len:n.pos+i;for(;n.pos<a;){const h=n.uint32();switch(h>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.peer=nh.codec().decode(n,n.uint32(),{limits:(c=s.limits)==null?void 0:c.peer});break}case 3:{o.reservation=by.codec().decode(n,n.uint32(),{limits:(l=s.limits)==null?void 0:l.reservation});break}case 4:{o.limit=rh.codec().decode(n,n.uint32(),{limits:(u=s.limits)==null?void 0:u.limit});break}case 5:{o.status=Cr.codec().decode(n);break}default:{n.skipType(h&7);break}}}return o})),t),r.encode=n=>Ht(n,r.codec()),r.decode=(n,i)=>Vt(n,r.codec(),i)})(th||(th={}));var Xs;(function(r){(function(n){n.CONNECT="CONNECT",n.STATUS="STATUS"})(r.Type||(r.Type={}));let e;(function(n){n[n.CONNECT=0]="CONNECT",n[n.STATUS=1]="STATUS"})(e||(e={})),(function(n){n.codec=()=>Jc(e)})(r.Type||(r.Type={}));let t;r.codec=()=>(t==null&&(t=Gt((n,i,s={})=>{s.lengthDelimited!==!1&&i.fork(),n.type!=null&&(i.uint32(8),r.Type.codec().encode(n.type,i)),n.peer!=null&&(i.uint32(18),nh.codec().encode(n.peer,i)),n.limit!=null&&(i.uint32(26),rh.codec().encode(n.limit,i)),n.status!=null&&(i.uint32(32),Cr.codec().encode(n.status,i)),s.lengthDelimited!==!1&&i.ldelim()},(n,i,s={})=>{var c,l;const o={},a=i==null?n.len:n.pos+i;for(;n.pos<a;){const u=n.uint32();switch(u>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.peer=nh.codec().decode(n,n.uint32(),{limits:(c=s.limits)==null?void 0:c.peer});break}case 3:{o.limit=rh.codec().decode(n,n.uint32(),{limits:(l=s.limits)==null?void 0:l.limit});break}case 4:{o.status=Cr.codec().decode(n);break}default:{n.skipType(u&7);break}}}return o})),t),r.encode=n=>Ht(n,r.codec()),r.decode=(n,i)=>Vt(n,r.codec(),i)})(Xs||(Xs={}));var nh;(function(r){let e;r.codec=()=>(e==null&&(e=Gt((t,n,i={})=>{if(i.lengthDelimited!==!1&&n.fork(),t.id!=null&&t.id.byteLength>0&&(n.uint32(10),n.bytes(t.id)),t.addrs!=null)for(const s of t.addrs)n.uint32(18),n.bytes(s);i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{var a;const s={id:xt(0),addrs:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const c=t.uint32();switch(c>>>3){case 1:{s.id=t.bytes();break}case 2:{if(((a=i.limits)==null?void 0:a.addrs)!=null&&s.addrs.length===i.limits.addrs)throw new Cs('Decode error - map field "addrs" had too many elements');s.addrs.push(t.bytes());break}default:{t.skipType(c&7);break}}}return s})),e),r.encode=t=>Ht(t,r.codec()),r.decode=(t,n)=>Vt(t,r.codec(),n)})(nh||(nh={}));var by;(function(r){let e;r.codec=()=>(e==null&&(e=Gt((t,n,i={})=>{if(i.lengthDelimited!==!1&&n.fork(),t.expire!=null&&t.expire!==0n&&(n.uint32(8),n.uint64(t.expire)),t.addrs!=null)for(const s of t.addrs)n.uint32(18),n.bytes(s);t.voucher!=null&&(n.uint32(26),vy.codec().encode(t.voucher,n)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{var a,c;const s={expire:0n,addrs:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const l=t.uint32();switch(l>>>3){case 1:{s.expire=t.uint64();break}case 2:{if(((a=i.limits)==null?void 0:a.addrs)!=null&&s.addrs.length===i.limits.addrs)throw new Cs('Decode error - map field "addrs" had too many elements');s.addrs.push(t.bytes());break}case 3:{s.voucher=vy.codec().decode(t,t.uint32(),{limits:(c=i.limits)==null?void 0:c.voucher});break}default:{t.skipType(l&7);break}}}return s})),e),r.encode=t=>Ht(t,r.codec()),r.decode=(t,n)=>Vt(t,r.codec(),n)})(by||(by={}));var rh;(function(r){let e;r.codec=()=>(e==null&&(e=Gt((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.duration!=null&&(n.uint32(8),n.uint32(t.duration)),t.data!=null&&(n.uint32(16),n.uint64(t.data)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.duration=t.uint32();break}case 2:{s.data=t.uint64();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Ht(t,r.codec()),r.decode=(t,n)=>Vt(t,r.codec(),n)})(rh||(rh={}));var Cr;(function(r){r.UNUSED="UNUSED",r.OK="OK",r.RESERVATION_REFUSED="RESERVATION_REFUSED",r.RESOURCE_LIMIT_EXCEEDED="RESOURCE_LIMIT_EXCEEDED",r.PERMISSION_DENIED="PERMISSION_DENIED",r.CONNECTION_FAILED="CONNECTION_FAILED",r.NO_RESERVATION="NO_RESERVATION",r.MALFORMED_MESSAGE="MALFORMED_MESSAGE",r.UNEXPECTED_MESSAGE="UNEXPECTED_MESSAGE"})(Cr||(Cr={}));var NS;(function(r){r[r.UNUSED=0]="UNUSED",r[r.OK=100]="OK",r[r.RESERVATION_REFUSED=200]="RESERVATION_REFUSED",r[r.RESOURCE_LIMIT_EXCEEDED=201]="RESOURCE_LIMIT_EXCEEDED",r[r.PERMISSION_DENIED=202]="PERMISSION_DENIED",r[r.CONNECTION_FAILED=203]="CONNECTION_FAILED",r[r.NO_RESERVATION=204]="NO_RESERVATION",r[r.MALFORMED_MESSAGE=400]="MALFORMED_MESSAGE",r[r.UNEXPECTED_MESSAGE=401]="UNEXPECTED_MESSAGE"})(NS||(NS={}));(function(r){r.codec=()=>Jc(NS)})(Cr||(Cr={}));var wy;(function(r){let e;r.codec=()=>(e==null&&(e=Gt((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.relay!=null&&t.relay.byteLength>0&&(n.uint32(10),n.bytes(t.relay)),t.peer!=null&&t.peer.byteLength>0&&(n.uint32(18),n.bytes(t.peer)),t.expiration!=null&&t.expiration!==0n&&(n.uint32(24),n.uint64(t.expiration)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={relay:xt(0),peer:xt(0),expiration:0n},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.relay=t.bytes();break}case 2:{s.peer=t.bytes();break}case 3:{s.expiration=t.uint64();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Ht(t,r.codec()),r.decode=(t,n)=>Vt(t,r.codec(),n)})(wy||(wy={}));var vy;(function(r){let e;r.codec=()=>(e==null&&(e=Gt((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(n.uint32(10),n.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(n.uint32(18),n.bytes(t.payloadType)),t.payload!=null&&(n.uint32(26),wy.codec().encode(t.payload,n)),t.signature!=null&&t.signature.byteLength>0&&(n.uint32(42),n.bytes(t.signature)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{var a;const s={publicKey:xt(0),payloadType:xt(0),signature:xt(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const c=t.uint32();switch(c>>>3){case 1:{s.publicKey=t.bytes();break}case 2:{s.payloadType=t.bytes();break}case 3:{s.payload=wy.codec().decode(t,t.uint32(),{limits:(a=i.limits)==null?void 0:a.payload});break}case 5:{s.signature=t.bytes();break}default:{t.skipType(c&7);break}}}return s})),e),r.encode=t=>Ht(t,r.codec()),r.decode=(t,n)=>Vt(t,r.codec(),n)})(vy||(vy={}));class OS extends Error{constructor(){super(...arguments);f(this,"name","HadEnoughRelaysError")}}f(OS,"name","HadEnoughRelaysError");class Uk extends Error{constructor(){super(...arguments);f(this,"name","DoubleRelayError")}}f(Uk,"name","DoubleRelayError");class kk extends Error{constructor(){super(...arguments);f(this,"name","RelayQueueFullError")}}f(kk,"name","RelayQueueFullError");function iI(r){const e=r*BigInt(1e3),t=new Date().getTime();return Number(e-BigInt(t))}class sI{constructor(e){f(this,"expires");f(this,"bytes");(e==null?void 0:e.duration)!=null&&(e==null?void 0:e.duration)!==0&&(this.expires=Date.now()+e.duration*1e3),this.bytes=e==null?void 0:e.data,this.bytes===0n&&(this.bytes=void 0),this.onData=this.onData.bind(this)}onData(e){this.bytes!=null&&(this.bytes-=BigInt(e.byteLength),this.bytes<0n&&(this.bytes=0n))}getLimits(){if(this.expires==null&&this.bytes==null)return;const e={};if(this.bytes!=null){const t=this;Object.defineProperty(e,"bytes",{get(){return t.bytes}})}if(this.expires!=null){const t=this;Object.defineProperty(e,"seconds",{get(){return Math.round(((t.expires??0)-Date.now())/1e3)}})}return e}}const Bk=Ot(At(cM.matchers[0],Nt(mM))),Fk=Ot(Nt(mM));class wce extends Pr{constructor(t,n={}){super();f(this,"components");f(this,"started");f(this,"running");f(this,"topologyId");f(this,"log");f(this,"discoveryController");f(this,"filter");f(this,"queue");this.log=t.logger.forComponent("libp2p:circuit-relay:discover-relays"),this.components=t,this.started=!1,this.running=!1,this.filter=n.filter,this.discoveryController=new AbortController,this.discoveryController.signal,this.dialPeer=this.dialPeer.bind(this),this.onPeer=this.onPeer.bind(this)}isStarted(){return this.started}async start(){this.topologyId=await this.components.registrar.register(yy,{filter:this.filter,onConnect:t=>{var n,i;this.log.trace("discovered relay %p queue (length: %d, active %d)",t,(n=this.queue)==null?void 0:n.size,(i=this.queue)==null?void 0:i.running),this.safeDispatchEvent("relay:discover",{detail:t})}}),this.started=!0}stop(){this.topologyId!=null&&this.components.registrar.unregister(this.topologyId),this.running&&this.stopDiscovery(),this.started=!1}startDiscovery(){this.running||(this.log("start discovery"),this.running=!0,this.discoveryController=new AbortController,this.discoveryController.signal,this.components.events.addEventListener("peer:discovery",this.onPeer),Promise.resolve().then(async()=>{var i;this.log("searching peer store for relays");const t=await this.components.peerStore.all({filters:[s=>s.protocols.includes(yy)],orders:[()=>Math.random()<.5?1:-1,(s,o)=>{const a=oI(s),c=oI(o);return a>c?-1:c>a?1:0}]});for(const s of t)this.log.trace("found relay peer %p in peer store",s.id),this.safeDispatchEvent("relay:discover",{detail:s.id});this.log("found %d relay peers in peer store",t.length);const n=this.queue=new Z1({concurrency:5});this.log("start random walk");for await(const s of this.components.randomWalk.walk({signal:this.discoveryController.signal})){if(this.log.trace("found random peer %p",s.id),n.has(s.id)){this.log.trace("random peer %p was already in queue",s.id);continue}if(((i=this.components.connectionManager.getConnections(s.id))==null?void 0:i.length)>0){this.log.trace("random peer %p was already connected",s.id);continue}if(!await this.components.connectionManager.isDialable(s.multiaddrs)){this.log.trace("random peer %p was not dialable",s.id,s.multiaddrs.map(o=>o.toString()));continue}n.queued>10&&(this.log.trace("wait for space in queue for %p",s.id),await n.onSizeLessThan(10,{signal:this.discoveryController.signal})),this.log("adding random peer %p to dial queue (length: %d, active %d)",s.id,n.size,n.running),n.add(this.dialPeer,{peerId:s.id,signal:this.discoveryController.signal}).catch(o=>{this.log.error("error opening connection to random peer %p - %e",s.id,o)})}this.log("stop random walk"),await n.onIdle()}).catch(t=>{this.discoveryController.signal.aborted||this.log.error("failed when finding relays on the network - %e",t)}))}stopDiscovery(){var t,n;this.log("stop discovery"),this.running=!1,(t=this.discoveryController)==null||t.abort(),(n=this.queue)==null||n.clear(),this.components.events.removeEventListener("peer:discovery",this.onPeer)}onPeer(t){this.log.trace("maybe dialing discovered peer %p",t.detail.id),this.maybeDialPeer(t).catch(n=>{this.log.trace("error dialing discovered peer %p - %e",t.detail.id,n)})}async maybeDialPeer(t){var s,o;if(this.queue==null)return;const n=t.detail.id,i=t.detail.multiaddrs;if(this.queue.has(n)){this.log.trace("random peer %p was already in queue",n);return}if(((s=this.components.connectionManager.getConnections(n))==null?void 0:s.length)>0){this.log.trace("random peer %p was already connected",n);return}if(!await this.components.connectionManager.isDialable(i)){this.log.trace("random peer %p was not dialable",n);return}(o=this.queue)==null||o.add(this.dialPeer,{peerId:t.detail.id,signal:this.discoveryController.signal}).catch(a=>{this.log.error("error opening connection to discovered peer %p - %e",t.detail.id,a)})}async dialPeer({peerId:t,signal:n}){const i=Bc([AbortSignal.timeout(5e3),n]);try{await this.components.connectionManager.openConnection(t,{signal:i})}finally{i.clear()}}}function oI(r){const e=r.metadata.get("last-dial-success");return e==null?0:new Date(ae(e)).getTime()}class vce extends Pr{constructor(t,n={}){super();f(this,"connectionManager");f(this,"addressManager");f(this,"reservationStore");f(this,"listeningAddrs");f(this,"log");f(this,"listenTimeout");f(this,"reservationId");f(this,"relay");f(this,"_onRemoveRelayPeer",t=>{var n,i;this.log("relay removed %p our relay %p",t.detail.relay,this.relay,(n=this.relay)==null?void 0:n.equals(t.detail.relay)),((i=this.relay)==null?void 0:i.equals(t.detail.relay))===!0&&(this.log("relay peer removed %p",t.detail.relay),this.listeningAddrs.forEach(s=>{this.addressManager.removeObservedAddr(s)}),this.listeningAddrs=[],this.safeDispatchEvent("listening"))});f(this,"_onAddRelayPeer",t=>{const{details:n}=t.detail;n.type!=="configured"&&n.id===this.reservationId&&this.addedRelay(t.detail)});this.log=t.logger.forComponent("libp2p:circuit-relay:transport:listener"),this.connectionManager=t.connectionManager,this.addressManager=t.addressManager,this.reservationStore=t.reservationStore,this.listeningAddrs=[],this.listenTimeout=n.listenTimeout??Ok,this.reservationStore.addEventListener("relay:removed",this._onRemoveRelayPeer),this.reservationStore.addEventListener("relay:created-reservation",this._onAddRelayPeer)}async listen(t){if(Fk.exactMatch(t))this.log("searching for circuit relay servers"),this.reservationId=this.reservationStore.reserveRelay();else if(Bk.exactMatch(t)){this.log("listen on specific relay server %a",t);const n=AbortSignal.timeout(this.listenTimeout),i=t.decapsulate("/p2p-circuit"),s=await this.connectionManager.openConnection(i,{signal:n});if(!this.reservationStore.hasReservation(s.remotePeer)){this.log("making reservation on peer %p",s.remotePeer);const o=await this.reservationStore.addRelay(s.remotePeer,"configured");this.addedRelay(o)}}else throw new my(`Could not listen on p2p-circuit address "${t}"`)}getAddrs(){return[...this.listeningAddrs.values()].flat()}updateAnnounceAddrs(){}async close(){this.reservationStore.cancelReservations(),this.listeningAddrs=[],this.reservationStore.removeEventListener("relay:removed",this._onRemoveRelayPeer),queueMicrotask(()=>{this.safeDispatchEvent("close")})}addedRelay(t){this.log("relay peer added %p",t.relay),this.relay=t.relay,this.listeningAddrs=t.details.reservation.addrs.map(n=>_a(n).encapsulate("/p2p-circuit")),this.listeningAddrs.forEach(n=>{this.addressManager.confirmObservedAddr(n,{type:"transport"})}),queueMicrotask(()=>{this.safeDispatchEvent("listening")})}}function _ce(r){return new vce(r)}const xce="useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";let Sce=(r=21)=>{let e="",t=crypto.getRandomValues(new Uint8Array(r|=0));for(;r--;)e+=xce[t[r]&63];return e};const Ece=60*1e3*10,Mce=60*1e3*5,Ace=30*1e3;var Vr,$k,pd,md;class Tce extends Pr{constructor(t,n){super();xe(this,Vr);f(this,"peerId");f(this,"connectionManager");f(this,"peerStore");f(this,"events");f(this,"reserveQueue");f(this,"reservations");f(this,"pendingReservations");f(this,"maxReservationQueueLength");f(this,"reservationCompletionTimeout");f(this,"started");f(this,"log");f(this,"relayFilter");this.log=t.logger.forComponent("libp2p:circuit-relay:transport:reservation-store"),this.peerId=t.peerId,this.connectionManager=t.connectionManager,this.peerStore=t.peerStore,this.events=t.events,this.reservations=new wh,this.pendingReservations=[],this.maxReservationQueueLength=(n==null?void 0:n.maxReservationQueueLength)??gce,this.reservationCompletionTimeout=(n==null?void 0:n.reservationCompletionTimeout)??Ok,this.started=!1,this.relayFilter=mf(100),this.reserveQueue=new Z1({concurrency:(n==null?void 0:n.reservationConcurrency)??mce,metricName:"libp2p_relay_reservation_queue",metrics:t.metrics}),this.events.addEventListener("connection:close",i=>{[...this.reservations.values()].find(o=>o.connection===i.detail.id)!=null&&be(this,Vr,pd).call(this,i.detail.remotePeer).catch(o=>{this.log("could not remove relay %p - %e",i.detail,o)})})}isStarted(){return this.started}start(){this.started=!0}afterStart(){Promise.resolve().then(async()=>{const t=await this.peerStore.all({filters:[n=>n.tags.has(Vm)]});this.log("removing tag from %d old relays",t.length),await Promise.all(t.map(async n=>{await this.peerStore.merge(n.id,{tags:{[Vm]:void 0}})})),this.log("redialing %d old relays",t.length),await Promise.all(t.map(async n=>this.addRelay(n.id,"discovered"))),be(this,Vr,md).call(this)}).catch(t=>{this.log.error("failed to clean up and redial old relays during afterStart - %e",t)})}stop(){this.reserveQueue.clear(),this.reservations.forEach(({timeout:t})=>{clearTimeout(t)}),this.reservations.clear(),this.started=!1}reserveRelay(){const t=Sce();return this.pendingReservations.push(t),be(this,Vr,md).call(this),t}async addRelay(t,n){if(this.peerId.equals(t))throw this.log.trace("not trying to use self as relay"),new my("Cannot use self as relay");if(this.reserveQueue.size>this.maxReservationQueueLength)throw new kk("The reservation queue is full");const i=this.reserveQueue.find(t);if(i!=null)return this.log.trace("potential relay peer %p is already in the reservation queue",t),i.join();if(this.relayFilter.has(t.toMultihash().bytes))throw new my("The relay was previously invalid");return this.log.trace("try to reserve relay slot with %p",t),this.reserveQueue.add(async()=>{const s=Date.now();try{const o=this.reservations.get(t);if(o!=null){const b=this.connectionManager.getConnections(t);let g=!1;if(b.length===0&&this.log("already have relay reservation with %p but we are no longer connected",t),b.map(y=>y.id).includes(o.connection)&&(this.log("already have relay reservation with %p and the original connection is still open",t),g=!0),g&&iI(o.reservation.expire)>Ece)return this.log("already have relay reservation with %p but we are still connected and it does not expire soon",t),{relay:t,details:o};await be(this,Vr,pd).call(this,t)}if(n==="discovered"&&this.pendingReservations.length===0)throw new OS("Not making reservation on discovered relay because we do not need any more relays");const a=AbortSignal.timeout(this.reservationCompletionTimeout);const c=await this.connectionManager.openConnection(t,{signal:a});if(Qu.matches(c.remoteAddr))throw new Uk("not creating reservation over relayed connection");const l=await be(this,Vr,$k).call(this,c,{signal:a}),u=iI(l.expire);this.log("created reservation on relay peer %p, expiry date is %s",t,new Date(Date.now()+u).toString());const h=Math.min(Math.max(u-Mce,Ace),Math.pow(2,31)-1),d=setTimeout(()=>{this.log("refresh reservation to relay %p",t),this.addRelay(t,n).catch(async b=>{this.log.error("could not refresh reservation to relay %p - %e",t,b),await be(this,Vr,pd).call(this,t)}).catch(b=>{this.log.error("could not remove expired reservation to relay %p - %e",t,b)})},h);let m;if(n==="discovered"){const b=this.pendingReservations.pop();if(b==null)throw new OS("Made reservation on relay but did not need any more discovered relays");m={timeout:d,reservation:l,type:n,connection:c.id,id:b}}else m={timeout:d,reservation:l,type:n,connection:c.id};this.reservations.set(t,m),await this.peerStore.merge(t,{tags:{[Vm]:{value:1,ttl:u}}}),be(this,Vr,md).call(this);const p={relay:t,details:m};return this.safeDispatchEvent("relay:created-reservation",{detail:p}),p}catch(o){throw n==="discovered"&&o.name==="HadEnoughRelaysError"||this.log.error("could not reserve slot on %p after %dms - %e",t,Date.now()-s,o),(o.name==="DialError"||o.name==="UnsupportedProtocolError")&&this.relayFilter.add(t.toMultihash().bytes),be(this,Vr,pd).call(this,t).catch(a=>{this.log.error("could not remove reservation on %p after reserving slot failed - %e",t,a)}),o}},{peerId:t})}hasReservation(t){return this.reservations.has(t)}getReservation(t){var n;return(n=this.reservations.get(t))==null?void 0:n.reservation}reservationCount(t){return t==null?this.reservations.size:[...this.reservations.values()].reduce((n,i)=>(i.type===t&&n++,n),0)}cancelReservations(){[...this.reservations.values()].forEach(t=>{clearTimeout(t.timeout)}),this.reservations.clear()}}Vr=new WeakSet,$k=async function(t,n){var l;(l=n.signal)==null||l.throwIfAborted(),this.log("requesting reservation from %p",t.remotePeer);const i=await t.newStream(yy,n),o=Ma(i).pb(th);this.log.trace("send RESERVE to %p",t.remotePeer),await o.write({type:th.Type.RESERVE},n);let a;try{this.log.trace("reading response from %p",t.remotePeer),a=await o.read(n)}catch(u){throw i.abort(u),u}finally{i.status!=="closed"&&await i.close(n)}if(this.log.trace("read response %s",a.status),a.status===Cr.OK&&a.reservation!=null){const u=new Set;u.add(t.remoteAddr.toString());for(const h of a.reservation.addrs){let d=_a(h);d.getComponents().find(m=>m.code===gy)==null&&(d=d.encapsulate(`/p2p/${t.remotePeer}`)),d=_a(d.toString().replace(`/p2p/${t.remotePeer}/p2p/${t.remotePeer}`,`/p2p/${t.remotePeer}`)),u.add(d.toString())}return a.reservation.addrs=[...u].map(h=>_a(h).bytes),a.reservation}const c=`reservation failed with status ${a.status??"undefined"}`;throw this.log.error(c),new Error(c)},pd=async function(t){const n=this.reservations.get(t);n!=null&&(this.log("removing relay reservation with %p from local store",t),clearTimeout(n.timeout),this.reservations.delete(t),n.type==="discovered"&&this.pendingReservations.push(n.id),await this.peerStore.merge(t,{tags:{[Vm]:void 0}}),this.safeDispatchEvent("relay:removed",{detail:{relay:t,details:n}}),be(this,Vr,md).call(this))},md=function(){if(this.pendingReservations.length===0){this.log.trace("have discovered enough relays"),this.reserveQueue.clear(),this.safeDispatchEvent("relay:found-enough-relays");return}this.relayFilter=mf(100),this.log("not discovered enough relays %d/%d",this.reservations.size,this.pendingReservations.length),this.safeDispatchEvent("relay:not-enough-relays")};class Cce extends Y1{constructor(t){super({...t,direction:t.stream.direction});f(this,"stream");f(this,"init");this.init=t,this.stream=t.stream,this.stream.addEventListener("close",n=>{this.onTransportClosed(n.error)}),this.stream.addEventListener("remoteCloseWrite",n=>{this.onRemoteCloseWrite(),this.close().catch(i=>{this.abort(i)})}),this.stream.addEventListener("message",n=>{var i;(i=t.onDataRead)==null||i.call(t,n.data),this.onData(n.data)}),this.stream.addEventListener("drain",()=>{this.safeDispatchEvent("drain")})}sendData(t){var n,i;return(i=(n=this.init).onDataWrite)==null||i.call(n,t),{sentBytes:t.byteLength,canSendMore:this.stream.send(t)}}async sendClose(t){await this.stream.close(t)}sendReset(){this.stream.abort(new Error("An error occurred"))}sendPause(){this.stream.pause()}sendResume(){this.stream.resume()}}function aI(r){return new Cce(r)}const Ice=r=>{if(r.peer==null)return!1;try{r.peer.addrs.forEach(_a)}catch{return!1}return!0},cI={maxInboundStopStreams:rI,maxOutboundStopStreams:rI};var kR,BR,FR,$R;class Pce{constructor(e,t={}){f(this,"components");f(this,"discovery");f(this,"reservationStore");f(this,"maxInboundStopStreams");f(this,"maxOutboundStopStreams");f(this,"started");f(this,"log");f(this,"shutdownController");f(this,$R,"@libp2p/circuit-relay-v2-transport");f(this,FR,["@libp2p/transport","@libp2p/circuit-relay-v2-transport"]);f(this,kR,!0);this.components=e,this.log=e.logger.forComponent("libp2p:circuit-relay:transport"),this.maxInboundStopStreams=t.maxInboundStopStreams??cI.maxInboundStopStreams,this.maxOutboundStopStreams=t.maxOutboundStopStreams??cI.maxOutboundStopStreams,this.shutdownController=new AbortController,this.discovery=new wce(e,{filter:t.discoveryFilter??dY(yce,bce)}),this.discovery.addEventListener("relay:discover",n=>{this.reservationStore.addRelay(n.detail,"discovered").catch(i=>{i.name!=="HadEnoughRelaysError"&&i.name!=="RelayQueueFullError"&&this.log.error("could not add discovered relay %p - %e",n.detail,i)})}),this.reservationStore=new Tce(e,t),this.reservationStore.addEventListener("relay:not-enough-relays",()=>{var n;(n=this.discovery)==null||n.startDiscovery()}),this.reservationStore.addEventListener("relay:found-enough-relays",()=>{var n;(n=this.discovery)==null||n.stopDiscovery()}),this.started=!1,this.onStop=this.onStop.bind(this)}get[($R=Symbol.toStringTag,FR=Koe,BR=Xoe,kR=qoe,BR)](){return this.discovery!=null?["@libp2p/identify"]:[]}isStarted(){return this.started}async start(){this.shutdownController=new AbortController,this.shutdownController.signal,await this.components.registrar.handle(nI,this.onStop,{maxInboundStreams:this.maxInboundStopStreams,maxOutboundStreams:this.maxOutboundStopStreams,runOnLimitedConnection:!0}),await Goe(this.discovery,this.reservationStore),this.started=!0}async stop(){this.shutdownController.abort(),await Woe(this.discovery,this.reservationStore),await this.components.registrar.unhandle(nI),this.started=!1}async dial(e,t){var m,p,b,g,y,v,w,_;const n=e.toString().split("/p2p-circuit"),i=_a(n[0]),s=_a(n[n.length-1]),o=(m=i.getComponents().find(M=>M.code===gy))==null?void 0:m.value,a=(p=s.getComponents().find(M=>M.code===gy))==null?void 0:p.value;if(o==null||a==null){const M=`ircuit relay dial to ${e.toString()} failed as address did not have both relay and destination PeerIDs`;throw this.log.error(`c${M}`),new Ck(`C${M}`)}const c=jC(o),l=jC(a);let h=this.components.connectionManager.getConnections(c)[0];h==null?(await this.components.peerStore.merge(c,{multiaddrs:[i]}),(b=t.onProgress)==null||b.call(t,new Rt("circuit-relay:open-connection")),h=await this.components.connectionManager.openConnection(c,t)):(g=t.onProgress)==null||g.call(t,new Rt("circuit-relay:reuse-connection"));let d;try{(y=t.onProgress)==null||y.call(t,new Rt("circuit-relay:open-hop-stream")),d=await h.newStream(yy,t);const M=Ma(d).pb(th);(v=t.onProgress)==null||v.call(t,new Rt("circuit-relay:write-connect-message")),await M.write({type:th.Type.CONNECT,peer:{id:l.toMultihash().bytes,addrs:[_a(s).bytes]}},t),(w=t.onProgress)==null||w.call(t,new Rt("circuit-relay:read-connect-response"));const E=await M.read(t);if(E.status!==Cr.OK)throw new Voe(`failed to connect via relay with status ${((_=E==null?void 0:E.status)==null?void 0:_.toString())??"undefined"}`);const C=new sI(E.limit),I=aI({stream:M.unwrap().unwrap(),remoteAddr:e,localAddr:i.encapsulate(`/p2p-circuit/p2p/${this.components.peerId.toString()}`),onDataRead:C.onData,onDataWrite:C.onData,log:d.log.newScope("circuit-relay:connection")}),x=await this.components.upgrader.upgradeOutbound(I,{...t,limits:C.getLimits()});return x.log("outbound relayed connection established to %p with limits %o, over connection %s",x.remotePeer,E.limit??"none",h.id),x}catch(M){throw this.log.error("circuit relay dial to destination %p via relay %p failed - %e",l,c,M),d==null||d.abort(M),M}}createListener(e){return _ce({peerId:this.components.peerId,connectionManager:this.components.connectionManager,addressManager:this.components.addressManager,reservationStore:this.reservationStore,logger:this.components.logger})}listenFilter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>Bk.exactMatch(t)||Fk.exactMatch(t))}dialFilter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>Qu.exactMatch(t))}async onStop(e,t){var i,s;const n=this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);try{if(!this.reservationStore.hasReservation(t.remotePeer))try{this.log("dialed via relay we did not have a reservation on, start listening on that relay address"),await this.components.transportManager.listen([t.remoteAddr.encapsulate("/p2p-circuit")])}catch(m){this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on - %e",m)}const o=Ma(e).pb(Xs),a=await o.read({signal:n});if(this.log("new circuit relay v2 stop stream from %p with type %s",t.remotePeer,a.type),(a==null?void 0:a.type)===void 0){this.log.error("type was missing from circuit v2 stop protocol request from %s",t.remotePeer),await o.write({type:Xs.Type.STATUS,status:Cr.MALFORMED_MESSAGE},{signal:n}),await e.close({signal:n});return}if(a.type!==Xs.Type.CONNECT){this.log.error("invalid stop connect request via peer %p",t.remotePeer),await o.write({type:Xs.Type.STATUS,status:Cr.UNEXPECTED_MESSAGE},{signal:n}),await e.close({signal:n});return}if(!Ice(a)){this.log.error("invalid stop connect request via peer %p",t.remotePeer),await o.write({type:Xs.Type.STATUS,status:Cr.MALFORMED_MESSAGE},{signal:n}),await e.close({signal:n});return}const c=pM(Lo(a.peer.id));if(await((s=(i=this.components.connectionGater).denyInboundRelayedConnection)==null?void 0:s.call(i,t.remotePeer,c))===!0){this.log.error("connection gater denied inbound relayed connection from %p",t.remotePeer),await o.write({type:Xs.Type.STATUS,status:Cr.PERMISSION_DENIED},{signal:n}),await e.close({signal:n});return}this.log.trace("sending success response to %p",t.remotePeer),await o.write({type:Xs.Type.STATUS,status:Cr.OK},{signal:n});const l=new sI(a.limit),u=t.remoteAddr.encapsulate(`/p2p-circuit/p2p/${c.toString()}`),h=this.components.addressManager.getAddresses()[0],d=aI({stream:o.unwrap().unwrap(),remoteAddr:u,localAddr:h,onDataRead:l.onData,onDataWrite:l.onData,log:e.log.newScope("circuit-relay:connection")});await this.components.upgrader.upgradeInbound(d,{limits:l.getLimits(),signal:n}),d.log("inbound relayed connection established to %p with limits %o, over connection %s",c,a.limit??"none",t.id)}finally{n==null||n.clear()}}}function Rce(r={}){return e=>new Pce(e,r)}var I_;let Dce=(I_=class extends Error{constructor(e="Unexpected Peer"){super(e),this.name="UnexpectedPeerError"}},f(I_,"name","UnexpectedPeerError"),I_);var P_;let Lce=(P_=class extends Error{constructor(e="Invalid crypto exchange"){super(e),this.name="InvalidCryptoExchangeError"}},f(P_,"name","InvalidCryptoExchangeError"),P_);var R_;let Nce=(R_=class extends Error{constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}},f(R_,"name","UnsupportedKeyTypeError"),R_);const Oce=Symbol.for("@libp2p/peer-id"),Uce=Symbol.for("@libp2p/service-capabilities"),kce=Symbol.for("nodejs.util.inspect.custom"),Bce=114;var zR;let gM=class{constructor(e){f(this,"type");f(this,"multihash");f(this,"publicKey");f(this,"string");f(this,zR,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=gt.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return Ze.createV1(Bce,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return We(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return We(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(zR=Oce,kce)](){return`PeerId(${this.toString()})`}},Fce=class extends gM{constructor(t){super({...t,type:"RSA"});f(this,"type","RSA");f(this,"publicKey");this.publicKey=t.publicKey}},$ce=class extends gM{constructor(t){super({...t,type:"Ed25519"});f(this,"type","Ed25519");f(this,"publicKey");this.publicKey=t.publicKey}},zce=class extends gM{constructor(t){super({...t,type:"secp256k1"});f(this,"type","secp256k1");f(this,"publicKey");this.publicKey=t.publicKey}};function lI(r){if(r.type==="Ed25519")return new $ce({multihash:r.toCID().multihash,publicKey:r});if(r.type==="secp256k1")return new zce({multihash:r.toCID().multihash,publicKey:r});if(r.type==="RSA")return new Fce({multihash:r.toCID().multihash,publicKey:r});throw new Nce}const Cf=65535,uI=Cf-16;var VR,HR;const hp=!!((HR=(VR=globalThis.process)==null?void 0:VR.env)!=null&&HR.DUMP_SESSION_KEYS),hI=16,Vce={hashSHA256(r){return Rd(r.subarray())},getHKDF(r,e){const t=Uoe(Rd,e,r),i=koe(Rd,t,void 0,96),s=i.subarray(0,32),o=i.subarray(32,64),a=i.subarray(64,96);return[s,o,a]},generateX25519KeyPair(){const r=Sm.utils.randomSecretKey();return{publicKey:Sm.getPublicKey(r),privateKey:r}},generateX25519KeyPairFromSeed(r){return{publicKey:Sm.getPublicKey(r),privateKey:r}},generateX25519SharedKey(r,e){return Sm.getSharedSecret(r.subarray(),e.subarray())},chaCha20Poly1305Encrypt(r,e,t,n){return XC(n,e,t).encrypt(r.subarray())},chaCha20Poly1305Decrypt(r,e,t,n,i){return XC(n,e,t).decrypt(r.subarray(),i)}},Hce=Vce;function Gce(r){return{generateKeypair:r.generateX25519KeyPair,dh:(e,t)=>r.generateX25519SharedKey(e.privateKey,t).subarray(0,32),encrypt:r.chaCha20Poly1305Encrypt,decrypt:r.chaCha20Poly1305Decrypt,hash:r.hashSHA256,hkdf:r.getHKDF}}const _y=r=>{const e=ns(2);return e[0]=r>>8,e[1]=r,e};_y.bytes=2;const xy=r=>{if(r.length<2)throw RangeError("Could not decode int16BE");if(r instanceof Uint8Array){let e=0;return e+=r[0]<<8,e+=r[1],e}return r.getUint16(0)};xy.bytes=2;function Wce(r){return{xxHandshakeSuccesses:r.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:r.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:r.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:r.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:r.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}function zk(r,e){!e.enabled||!hp||(r?(e(`LOCAL_STATIC_PUBLIC_KEY ${ae(r.publicKey,"hex")}`),e(`LOCAL_STATIC_PRIVATE_KEY ${ae(r.privateKey,"hex")}`)):e("Missing local static keys."))}function Vk(r,e){!e.enabled||!hp||(r?(e(`LOCAL_PUBLIC_EPHEMERAL_KEY ${ae(r.publicKey,"hex")}`),e(`LOCAL_PRIVATE_EPHEMERAL_KEY ${ae(r.privateKey,"hex")}`)):e("Missing local ephemeral keys."))}function qce(r,e){!e.enabled||!hp||e(r?`REMOTE_STATIC_PUBLIC_KEY ${ae(r.subarray(),"hex")}`:"Missing remote static public key.")}function Hk(r,e){!e.enabled||!hp||e(r?`REMOTE_EPHEMERAL_PUBLIC_KEY ${ae(r.subarray(),"hex")}`:"Missing remote ephemeral keys.")}function Gk(r,e,t){!t.enabled||!hp||(t(`CIPHER_STATE_1 ${r.n.getUint64()} ${r.k&&ae(r.k,"hex")}`),t(`CIPHER_STATE_2 ${e.n.getUint64()} ${e.k&&ae(e.k,"hex")}`))}var wc;let Lw=(wc=class extends Error{constructor(t="Invalid crypto exchange"){super(t);f(this,"code");this.code=wc.code}},f(wc,"code","ERR_INVALID_CRYPTO_EXCHANGE"),wc);const Kce=0,Xce=4294967295,Yce="Cipher state has reached maximum n, a new handshake must be performed";class Zce{constructor(e=Kce){f(this,"n");f(this,"bytes");f(this,"view");this.n=e,this.bytes=xt(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,e,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>Xce)throw new Error(Yce)}}const eu=xt(0);class Hm{constructor(e,t=void 0,n=0){f(this,"k");f(this,"n");f(this,"crypto");this.crypto=e,this.k=t,this.n=new Zce(n)}hasKey(){return!!this.k}encryptWithAd(e,t){if(!this.hasKey())return t;this.n.assertValue();const n=this.crypto.encrypt(t,this.n.getBytes(),e,this.k);return this.n.increment(),n}decryptWithAd(e,t,n){if(!this.hasKey())return t;this.n.assertValue();const i=this.crypto.decrypt(t,this.n.getBytes(),e,this.k,n);return this.n.increment(),i}}class Jce{constructor(e,t){f(this,"cs");f(this,"ck");f(this,"h");f(this,"crypto");this.crypto=e;const n=Se(t,"utf-8");this.h=Qce(e,n),this.ck=this.h,this.cs=new Hm(e)}mixKey(e){const[t,n]=this.crypto.hkdf(this.ck,e);this.ck=t,this.cs=new Hm(this.crypto,n)}mixHash(e){this.h=this.crypto.hash(new vt(this.h,e))}encryptAndHash(e){const t=this.cs.encryptWithAd(this.h,e);return this.mixHash(t),t}decryptAndHash(e){const t=this.cs.decryptWithAd(this.h,e);return this.mixHash(e),t}split(){const[e,t]=this.crypto.hkdf(this.ck,eu);return[new Hm(this.crypto,e),new Hm(this.crypto,t)]}}class jce{constructor(e){f(this,"ss");f(this,"s");f(this,"e");f(this,"rs");f(this,"re");f(this,"initiator");f(this,"crypto");const{crypto:t,protocolName:n,prologue:i,initiator:s,s:o,e:a,rs:c,re:l}=e;this.crypto=t,this.ss=new Jce(t,n),this.ss.mixHash(i),this.initiator=s,this.s=o,this.e=a,this.rs=c,this.re=l}writeE(){if(this.e)throw new Error("ephemeral keypair is already set");const e=this.crypto.generateKeypair();return this.ss.mixHash(e.publicKey),this.e=e,e.publicKey}writeS(){if(!this.s)throw new Error("static keypair is not set");return this.ss.encryptAndHash(this.s.publicKey)}writeEE(){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.re))}writeES(){if(this.initiator){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}else{if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}}writeSE(){if(this.initiator){if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}else{if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}}readE(e,t=0){if(this.re)throw new Error("remote ephemeral public key is already set");if(e.byteLength<t+32)throw new Error("message is not long enough");this.re=e.sublist(t,t+32),this.ss.mixHash(this.re)}readS(e,t=0){if(this.rs)throw new Error("remote static public key is already set");const n=32+(this.ss.cs.hasKey()?16:0);if(e.byteLength<t+n)throw new Error("message is not long enough");const i=e.sublist(t,t+n);return this.rs=this.ss.decryptAndHash(i),n}readEE(){this.writeEE()}readES(){this.writeES()}readSE(){this.writeSE()}}class Wk extends jce{writeMessageA(e){return new vt(this.writeE(),this.ss.encryptAndHash(e))}writeMessageB(e){const t=this.writeE();this.writeEE();const n=this.writeS();return this.writeES(),new vt(t,n,this.ss.encryptAndHash(e))}writeMessageC(e){const t=this.writeS();return this.writeSE(),new vt(t,this.ss.encryptAndHash(e))}readMessageA(e){try{return this.readE(e),this.ss.decryptAndHash(e.sublist(32))}catch(t){throw new Lw(`handshake stage 0 validation fail: ${t.message}`)}}readMessageB(e){try{this.readE(e),this.readEE();const t=this.readS(e,32);return this.readES(),this.ss.decryptAndHash(e.sublist(32+t))}catch(t){throw new Lw(`handshake stage 1 validation fail: ${t.message}`)}}readMessageC(e){try{const t=this.readS(e);return this.readSE(),this.ss.decryptAndHash(e.sublist(t))}catch(t){throw new Lw(`handshake stage 2 validation fail: ${t.message}`)}}}function Qce(r,e){if(e.length<=32){const t=xt(32);return t.set(e),t}else return r.hash(e)}var Sy;(function(r){let e;r.codec=()=>(e==null&&(e=Gt((t,n,i={})=>{if(i.lengthDelimited!==!1&&n.fork(),t.webtransportCerthashes!=null)for(const s of t.webtransportCerthashes)n.uint32(10),n.bytes(s);if(t.streamMuxers!=null)for(const s of t.streamMuxers)n.uint32(18),n.string(s);i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{var a,c;const s={webtransportCerthashes:[],streamMuxers:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const l=t.uint32();switch(l>>>3){case 1:{if(((a=i.limits)==null?void 0:a.webtransportCerthashes)!=null&&s.webtransportCerthashes.length===i.limits.webtransportCerthashes)throw new Cs('Decode error - map field "webtransportCerthashes" had too many elements');s.webtransportCerthashes.push(t.bytes());break}case 2:{if(((c=i.limits)==null?void 0:c.streamMuxers)!=null&&s.streamMuxers.length===i.limits.streamMuxers)throw new Cs('Decode error - map field "streamMuxers" had too many elements');s.streamMuxers.push(t.string());break}default:{t.skipType(l&7);break}}}return s})),e),r.encode=t=>Ht(t,r.codec()),r.decode=(t,n)=>Vt(t,r.codec(),n)})(Sy||(Sy={}));var Ey;(function(r){let e;r.codec=()=>(e==null&&(e=Gt((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.identityKey!=null&&t.identityKey.byteLength>0&&(n.uint32(10),n.bytes(t.identityKey)),t.identitySig!=null&&t.identitySig.byteLength>0&&(n.uint32(18),n.bytes(t.identitySig)),t.extensions!=null&&(n.uint32(34),Sy.codec().encode(t.extensions,n)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{var a;const s={identityKey:xt(0),identitySig:xt(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const c=t.uint32();switch(c>>>3){case 1:{s.identityKey=t.bytes();break}case 2:{s.identitySig=t.bytes();break}case 4:{s.extensions=Sy.codec().decode(t,t.uint32(),{limits:(a=i.limits)==null?void 0:a.extensions});break}default:{t.skipType(c&7);break}}}return s})),e),r.encode=t=>Ht(t,r.codec()),r.decode=(t,n)=>Vt(t,r.codec(),n)})(Ey||(Ey={}));async function qk(r,e,t){const n=await r.sign(Xk(e));return Ey.encode({identityKey:Ms(r.publicKey),identitySig:n,extensions:t})}async function Kk(r,e,t){try{const n=Ey.decode(r),i=Io(n.identityKey);if((t==null?void 0:t.equals(i))===!1)throw new Error(`Payload identity key ${i} does not match expected remote identity key ${t}`);if(!e)throw new Error("Remote static does not exist");const s=Xk(e);if(!await i.verify(s,n.identitySig))throw new Error("Invalid payload signature");return n}catch(n){throw new Dce(n.message)}}function Xk(r){const e=Se("noise-libp2p-static-key:");return r instanceof Uint8Array?ut([e,r],e.length+r.length):(r.prepend(e),r)}class ele extends X1{constructor(t,n,i){super({log:t.log,inactivityTimeout:t.inactivityTimeout,maxReadBufferLength:t.maxReadBufferLength,direction:t.direction});f(this,"stream");f(this,"handshake");f(this,"metrics");f(this,"decoder");this.stream=t,this.handshake=n,this.metrics=i,this.decoder=new oY({lengthDecoder:xy,maxBufferSize:16*1024*1024,encodingLength:()=>2});const s=l=>{try{for(const u of this.decoder.decode(l.data))this.onData(this.decrypt(u))}catch(u){this.abort(u)}};this.stream.addEventListener("message",s);const o=l=>{l.error!=null?l.local===!0?this.abort(l.error):this.onRemoteReset():this.onTransportClosed()};this.stream.addEventListener("close",o);const a=()=>{this.safeDispatchEvent("drain")};this.stream.addEventListener("drain",a);const c=()=>{this.onRemoteCloseWrite()};this.stream.addEventListener("remoteCloseWrite",c)}encrypt(t){var i;const n=new vt;for(let s=0;s<t.byteLength;s+=uI){let o=s+uI;o>t.byteLength&&(o=t.byteLength);let a;t instanceof Uint8Array?a=this.handshake.encrypt(t.subarray(s,o)):a=this.handshake.encrypt(t.sublist(s,o)),(i=this.metrics)==null||i.encryptedPackets.increment(),n.append(_y(a.byteLength)),n.append(a)}return n}decrypt(t){var i,s;const n=new vt;for(let o=0;o<t.byteLength;o+=Cf){let a=o+Cf;if(a>t.byteLength&&(a=t.byteLength),a-hI<o)throw new Error("Invalid chunk");let c;t instanceof Uint8Array?c=t.subarray(o,a):c=t.sublist(o,a);const l=t.subarray(o,a-hI);try{const u=this.handshake.decrypt(c,l);(i=this.metrics)==null||i.decryptedPackets.increment(),n.append(u)}catch(u){throw(s=this.metrics)==null||s.decryptErrors.increment(),u}}return n}close(t){return this.stream.close(t)}sendPause(){this.stream.pause()}sendResume(){this.stream.resume()}sendReset(t){this.stream.abort(t)}sendData(t){return{sentBytes:t.byteLength,canSendMore:this.stream.send(this.encrypt(t))}}}function dI(r,e,t){return new ele(r,e,t)}async function tle(r,e){const{log:t,connection:n,crypto:i,privateKey:s,prologue:o,s:a,remoteIdentityKey:c,extensions:l}=r,u=await qk(s,a.publicKey,l),h=new Wk({crypto:i,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!0,prologue:o,s:a});zk(h.s,t),t.trace("Stage 0 - Initiator starting to send first message."),await n.write(h.writeMessageA(eu),e),t.trace("Stage 0 - Initiator finished sending first message."),Vk(h.e,t),t.trace("Stage 1 - Initiator waiting to receive first message from responder...");const d=h.readMessageB(await n.read(e));t.trace("Stage 1 - Initiator received the message."),Hk(h.re,t),qce(h.rs,t),t.trace("Initiator going to check remote's signature...");const m=await Kk(d,h.rs,c);t.trace("All good with the signature!"),t.trace("Stage 2 - Initiator sending third handshake message."),await n.write(h.writeMessageC(u),e),t.trace("Stage 2 - Initiator sent message with signed payload.");const[p,b]=h.ss.split();return Gk(p,b,t),{payload:m,encrypt:g=>p.encryptWithAd(eu,g),decrypt:(g,y)=>b.decryptWithAd(eu,g,y)}}async function nle(r,e){const{log:t,connection:n,crypto:i,privateKey:s,prologue:o,s:a,remoteIdentityKey:c,extensions:l}=r,u=await qk(s,a.publicKey,l),h=new Wk({crypto:i,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!1,prologue:o,s:a});zk(h.s,t),t.trace("Stage 0 - Responder waiting to receive first message."),h.readMessageA(await n.read(e)),t.trace("Stage 0 - Responder received first message."),Hk(h.re,t),t.trace("Stage 1 - Responder sending out first message with signed payload and static key."),await n.write(h.writeMessageB(u),e),t.trace("Stage 1 - Responder sent the second handshake message with signed payload."),Vk(h.e,t),t.trace("Stage 2 - Responder waiting for third handshake message...");const d=h.readMessageC(await n.read(e));t.trace("Stage 2 - Responder received the message, finished handshake.");const m=await Kk(d,h.rs,c),[p,b]=h.ss.split();return Gk(p,b,t),{payload:m,encrypt:g=>b.encryptWithAd(eu,g),decrypt:(g,y)=>p.decryptWithAd(eu,g,y)}}var GR,WR;WR=Symbol.toStringTag,GR=Uce;class rle{constructor(e,t={}){f(this,"protocol","/noise");f(this,"crypto");f(this,"prologue");f(this,"staticKey");f(this,"extensions");f(this,"metrics");f(this,"components");f(this,"log");f(this,WR,"@libp2p/noise");f(this,GR,["@libp2p/connection-encryption","@libp2p/noise"]);const{staticNoiseKey:n,extensions:i,crypto:s,prologueBytes:o}=t,{metrics:a}=e;this.components=e,this.log=e.logger.forComponent("libp2p:noise");const c=s??Hce;this.crypto=Gce(c),this.extensions={webtransportCerthashes:[],...i},this.metrics=a?Wce(a):void 0,n?this.staticKey=c.generateX25519KeyPairFromSeed(n):this.staticKey=c.generateX25519KeyPair(),this.prologue=o??xt(0)}async secureOutbound(e,t){var a,c,l;const n=((a=e.log)==null?void 0:a.newScope("noise"))??this.log,i=bf(e,{lengthEncoder:_y,lengthDecoder:xy,maxDataLength:Cf}),s=await this.performHandshakeInitiator(i,this.components.privateKey,n,(c=t==null?void 0:t.remotePeer)==null?void 0:c.publicKey,t),o=Io(s.payload.identityKey);return{connection:dI(i.unwrap(),s,this.metrics),remoteExtensions:s.payload.extensions,remotePeer:lI(o),streamMuxer:(t==null?void 0:t.skipStreamMuxerNegotiation)===!0?void 0:this.getStreamMuxer((l=s.payload.extensions)==null?void 0:l.streamMuxers)}}getStreamMuxer(e){if(e==null||e.length===0)return;const t=this.components.upgrader.getStreamMuxers();if(t!=null)for(const n of e){const i=t.get(n);if(i!=null)return i}if(e.length)throw new Lce("Early muxer negotiation was requested but the initiator and responder had no common muxers")}async secureInbound(e,t){var a,c,l;const n=((a=e.log)==null?void 0:a.newScope("noise"))??this.log,i=bf(e,{lengthEncoder:_y,lengthDecoder:xy,maxDataLength:Cf}),s=await this.performHandshakeResponder(i,this.components.privateKey,n,(c=t==null?void 0:t.remotePeer)==null?void 0:c.publicKey,t),o=Io(s.payload.identityKey);return{connection:dI(i.unwrap(),s,this.metrics),remoteExtensions:s.payload.extensions,remotePeer:lI(o),streamMuxer:(t==null?void 0:t.skipStreamMuxerNegotiation)===!0?void 0:this.getStreamMuxer((l=s.payload.extensions)==null?void 0:l.streamMuxers)}}async performHandshakeInitiator(e,t,n,i,s){var c,l;let o;const a=(s==null?void 0:s.skipStreamMuxerNegotiation)===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{o=await tle({connection:e,privateKey:t,remoteIdentityKey:i,log:n.newScope("xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:a,webtransportCerthashes:[],...this.extensions}},s),(c=this.metrics)==null||c.xxHandshakeSuccesses.increment()}catch(u){throw(l=this.metrics)==null||l.xxHandshakeErrors.increment(),u}return o}async performHandshakeResponder(e,t,n,i,s){var c,l;let o;const a=(s==null?void 0:s.skipStreamMuxerNegotiation)===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{o=await nle({connection:e,privateKey:t,remoteIdentityKey:i,log:n.newScope("xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:a,webtransportCerthashes:[],...this.extensions}},s),(c=this.metrics)==null||c.xxHandshakeSuccesses.increment()}catch(u){throw(l=this.metrics)==null||l.xxHandshakeErrors.increment(),u}return o}}function ile(r={}){return e=>new rle(e,r)}class Yk extends Error{constructor(e="Unexpected Peer"){super(e),this.name="UnexpectedPeerError"}}f(Yk,"name","UnexpectedPeerError");class US extends Error{constructor(e="Invalid crypto exchange"){super(e),this.name="InvalidCryptoExchangeError"}}f(US,"name","InvalidCryptoExchangeError");var D_;let Nw=(D_=class extends Error{constructor(e="Protocol error"){super(e),this.name="ProtocolError"}},f(D_,"name","ProtocolError"),D_);var L_;let sle=(L_=class extends Error{constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}},f(L_,"name","UnsupportedKeyTypeError"),L_);const ole=Symbol.for("@libp2p/peer-id"),ale=Symbol.for("@libp2p/service-capabilities"),cle=Symbol.for("nodejs.util.inspect.custom"),lle=114;var qR;let yM=class{constructor(e){f(this,"type");f(this,"multihash");f(this,"publicKey");f(this,"string");f(this,qR,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=gt.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return Ze.createV1(lle,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return We(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return We(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(qR=ole,cle)](){return`PeerId(${this.toString()})`}},ule=class extends yM{constructor(t){super({...t,type:"RSA"});f(this,"type","RSA");f(this,"publicKey");this.publicKey=t.publicKey}},hle=class extends yM{constructor(t){super({...t,type:"Ed25519"});f(this,"type","Ed25519");f(this,"publicKey");this.publicKey=t.publicKey}},dle=class extends yM{constructor(t){super({...t,type:"secp256k1"});f(this,"type","secp256k1");f(this,"publicKey");this.publicKey=t.publicKey}};function fle(r){if(r.type==="Ed25519")return new hle({multihash:r.toCID().multihash,publicKey:r});if(r.type==="secp256k1")return new dle({multihash:r.toCID().multihash,publicKey:r});if(r.type==="RSA")return new ule({multihash:r.toCID().multihash,publicKey:r});throw new sle}var kS;(function(r){let e;r.codec=()=>(e==null&&(e=Gt((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.id!=null&&(n.uint32(10),n.bytes(t.id)),t.pubkey!=null&&(n.uint32(18),My.codec().encode(t.pubkey,n)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{var a;const s={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const c=t.uint32();switch(c>>>3){case 1:{s.id=t.bytes();break}case 2:{s.pubkey=My.codec().decode(t,t.uint32(),{limits:(a=i.limits)==null?void 0:a.pubkey});break}default:{t.skipType(c&7);break}}}return s})),e),r.encode=t=>Ht(t,r.codec()),r.decode=(t,n)=>Vt(t,r.codec(),n)})(kS||(kS={}));var zc;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1",r.ECDSA="ECDSA"})(zc||(zc={}));var BS;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1",r[r.ECDSA=3]="ECDSA"})(BS||(BS={}));(function(r){r.codec=()=>Jc(BS)})(zc||(zc={}));var My;(function(r){let e;r.codec=()=>(e==null&&(e=Gt((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.Type!=null&&(n.uint32(8),zc.codec().encode(t.Type,n)),t.Data!=null&&t.Data.byteLength>0&&(n.uint32(18),n.bytes(t.Data)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={Data:xt(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.Type=zc.codec().decode(t);break}case 2:{s.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Ht(t,r.codec()),r.decode=(t,n)=>Vt(t,r.codec(),n)})(My||(My={}));const ple="/plaintext/2.0.0";var KR,XR;XR=Symbol.toStringTag,KR=ale;class mle{constructor(e){f(this,"protocol",ple);f(this,"privateKey");f(this,"log");f(this,XR,"@libp2p/plaintext");f(this,KR,["@libp2p/connection-encryption"]);this.privateKey=e.privateKey,this.log=e.logger.forComponent("libp2p:plaintext")}async secureInbound(e,t){return this._encrypt(e,t)}async secureOutbound(e,t){return this._encrypt(e,t)}async _encrypt(e,t){var c;const n=((c=e.log)==null?void 0:c.newScope("plaintext"))??this.log,i=Ma(e).pb(kS);n("write pubkey exchange to peer %p",t==null?void 0:t.remotePeer);const s=this.privateKey.publicKey;await i.write({id:s.toMultihash().bytes,pubkey:{Type:zc[s.type],Data:s.raw}},t);const o=await i.read(t);let a;try{if(o.pubkey==null)throw new Nw("Public key missing");if(o.pubkey.Data.byteLength===0)throw new Nw("Public key data too short");if(o.id==null)throw new Nw("Remote id missing");const l=qq(o.pubkey.Data);if(a=fle(l),!We(a.toMultihash().bytes,o.id))throw new US("Public key did not match id")}catch(l){throw n.error("invalid public key - %e",l),new US(`Invalid public key - ${l.message}`)}if((t==null?void 0:t.remotePeer)!=null&&!a.equals(t==null?void 0:t.remotePeer))throw new Yk;return n("plaintext key exchange completed successfully with peer %p",a),{connection:i.unwrap().unwrap(),remotePeer:a}}}function gle(){return r=>new mle(r)}var N_;let Ys=(N_=class extends Error{constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}},f(N_,"name","InvalidParametersError"),N_);class gd extends Error{constructor(e="The muxer is closed"){super(e),this.name="MuxerClosedError"}}f(gd,"name","MuxerClosedError");class Zk extends Error{constructor(e="Too many outbound protocol streams"){super(e),this.name="TooManyOutboundProtocolStreamsError"}}f(Zk,"name","TooManyOutboundProtocolStreamsError");const yle=Symbol.for("@libp2p/service-capabilities");var gn;(function(r){r[r.Data=0]="Data",r[r.WindowUpdate=1]="WindowUpdate",r[r.Ping=2]="Ping",r[r.GoAway=3]="GoAway"})(gn||(gn={}));var St;(function(r){r[r.SYN=1]="SYN",r[r.ACK=2]="ACK",r[r.FIN=4]="FIN",r[r.RST=8]="RST"})(St||(St={}));Object.values(St).filter(r=>typeof r!="string");const ble=0;var Qr;(function(r){r[r.NormalTermination=0]="NormalTermination",r[r.ProtocolError=1]="ProtocolError",r[r.InternalError=2]="InternalError"})(Qr||(Qr={}));const fc=12;var O_;let G0=(O_=class extends Error{constructor(t,n){super(t);f(this,"reason");this.name="ProtocolError",this.reason=n}},f(O_,"name","ProtocolError"),O_);function wle(r){return(r==null?void 0:r.reason)!==null}class pc extends G0{constructor(e="The frame was invalid"){super(e,Qr.ProtocolError),this.name="InvalidFrameError"}}f(pc,"name","InvalidFrameError");class Jk extends G0{constructor(e="Un-requested ping error"){super(e,Qr.ProtocolError),this.name="UnRequestedPingError"}}f(Jk,"name","UnRequestedPingError");class jk extends G0{constructor(e="Not matching ping error"){super(e,Qr.ProtocolError),this.name="NotMatchingPingError"}}f(jk,"name","NotMatchingPingError");class Qk extends G0{constructor(e="Receive window exceeded"){super(e,Qr.ProtocolError),this.name="ReceiveWindowExceededError"}}f(Qk,"name","ReceiveWindowExceededError");const eB=256*1024,vle=16*1024*1024,Gm={enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3};function _le(r){var e,t,n,i,s,o,a,c;if(r.keepAliveInterval!=null&&r.keepAliveInterval<=0)throw new Ys("keep-alive interval must be positive");if(r.maxInboundStreams!=null&&r.maxInboundStreams<0)throw new Ys("max inbound streams must be larger or equal 0");if(r.maxOutboundStreams!=null&&r.maxOutboundStreams<0)throw new Ys("max outbound streams must be larger or equal 0");if(r.maxMessageSize!=null&&r.maxMessageSize<1024)throw new Ys("MaxMessageSize must be greater than a kilobyte");if(((e=r.streamOptions)==null?void 0:e.initialStreamWindowSize)!=null&&((t=r.streamOptions)==null?void 0:t.initialStreamWindowSize)<eB)throw new Ys("InitialStreamWindowSize must be larger or equal 256 kB");if(((n=r.streamOptions)==null?void 0:n.maxStreamWindowSize)!=null&&((i=r.streamOptions)==null?void 0:i.initialStreamWindowSize)!=null&&((s=r.streamOptions)==null?void 0:s.maxStreamWindowSize)<((o=r.streamOptions)==null?void 0:o.initialStreamWindowSize))throw new Ys("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");if(((a=r.streamOptions)==null?void 0:a.maxStreamWindowSize)!=null&&((c=r.streamOptions)==null?void 0:c.maxStreamWindowSize)>2**32-1)throw new Ys("MaxStreamWindowSize must be less than equal MAX_UINT32")}function xle(r){return r.header.type===gn.Data&&r.data!==null}const fI=2**24;function Sle(r){if(r[0]!==ble)throw new pc("Invalid frame version");return{type:r[1],flag:(r[2]<<8)+r[3],streamID:r[4]*fI+(r[5]<<16)+(r[6]<<8)+r[7],length:r[8]*fI+(r[9]<<16)+(r[10]<<8)+r[11]}}let Ele=class{constructor(){f(this,"buffer");this.buffer=new vt}*emitFrames(e){for(this.buffer.append(e);;){const t=this.readFrame();if(t===void 0)break;yield t}}readFrame(){let e=fc;if(this.buffer.byteLength<fc)return;const t=Sle(this.buffer.subarray(0,fc));if(t.type===gn.Data){if(e+=t.length,this.buffer.byteLength<e)return;const n=this.buffer.sublist(fc,e);return this.buffer.consume(e),{header:t,data:n}}return this.buffer.consume(e),{header:t}}};function pI(r){const e=new Uint8Array(fc);return e[1]=r.type,e[2]=r.flag>>>8,e[3]=r.flag,e[4]=r.streamID>>>24,e[5]=r.streamID>>>16,e[6]=r.streamID>>>8,e[7]=r.streamID,e[8]=r.length>>>24,e[9]=r.length>>>16,e[10]=r.length>>>8,e[11]=r.length,e}var Nr;(function(r){r[r.Init=0]="Init",r[r.SYNSent=1]="SYNSent",r[r.SYNReceived=2]="SYNReceived",r[r.Established=3]="Established",r[r.Finished=4]="Finished",r[r.Paused=5]="Paused"})(Nr||(Nr={}));class Mle extends iO{constructor(t){const n=t.initialStreamWindowSize??eB;super({...t,maxMessageSize:n-fc});f(this,"streamId");f(this,"state");f(this,"sendWindowCapacity");f(this,"recvWindow");f(this,"recvWindowCapacity");f(this,"maxStreamWindowSize");f(this,"epochStart");f(this,"getRTT");f(this,"sendFrame");this.streamId=t.streamId,this.state=t.state,this.sendWindowCapacity=n,this.recvWindow=n,this.recvWindowCapacity=this.recvWindow,this.maxStreamWindowSize=t.maxStreamWindowSize??vle,this.epochStart=Date.now(),this.getRTT=t.getRTT,this.sendFrame=t.sendFrame;const i=()=>{this.state=Nr.Finished};this.addEventListener("close",i)}sendData(t){var o,a;const n=t.byteLength;let i=0,s=!0;for((o=this.log)==null||o.trace("send window capacity is %d bytes",this.sendWindowCapacity);t.byteLength>0;){if(this.sendWindowCapacity===0){s=!1,(a=this.log)==null||a.trace("sent %d/%d bytes, exhausted send window, waiting for window update",i,n);break}const c=Math.min(this.sendWindowCapacity,t.byteLength),l=this.getSendFlags(),u=t.sublist(0,c);t.consume(c);const h=this.sendFrame({type:gn.Data,flag:l,streamID:this.streamId,length:c},u);if(this.sendWindowCapacity-=c,i+=c,!h){s=h,this.log.trace("sent %d/%d bytes, wait for muxer to have more send capacity",i,n);break}}return{sentBytes:i,canSendMore:s}}async sendReset(){this.sendFrame({type:gn.WindowUpdate,flag:St.RST,streamID:this.streamId,length:0})}async sendCloseWrite(){const t=this.getSendFlags()|St.FIN;this.sendFrame({type:gn.WindowUpdate,flag:t,streamID:this.streamId,length:0})}async sendCloseRead(t){var n;(n=t==null?void 0:t.signal)==null||n.throwIfAborted()}sendPause(){this.state=Nr.Paused}sendResume(){this.state=Nr.Established,this.sendWindowUpdate()}handleWindowUpdate(t){var n;this.processFlags(t.header.flag),this.sendWindowCapacity+=t.header.length,this.maxMessageSize=this.sendWindowCapacity-fc,this.maxMessageSize<0&&(this.maxMessageSize=0),this.maxMessageSize!==0&&this.writeBuffer.byteLength>0&&((n=this.log)==null||n.trace("window update of %d bytes allows more data to be sent, have %d bytes queued, sending data %s",t.header.length,this.writeBuffer.byteLength,this.sendingData),this.safeDispatchEvent("drain"))}handleData(t){if(!xle(t))throw new pc("Frame was not data frame");if(this.processFlags(t.header.flag),this.recvWindowCapacity<t.header.length)throw new Qk("Receive window exceeded");this.recvWindowCapacity-=t.header.length,this.onData(t.data),this.sendWindowUpdate()}processFlags(t){(t&St.ACK)===St.ACK&&this.state===Nr.SYNSent&&(this.state=Nr.Established),(t&St.FIN)===St.FIN&&this.onRemoteCloseWrite(),(t&St.RST)===St.RST&&this.onRemoteReset()}getSendFlags(){switch(this.state){case Nr.Init:return this.state=Nr.SYNSent,St.SYN;case Nr.SYNReceived:return this.state=Nr.Established,St.ACK;default:return 0}}sendWindowUpdate(){if(this.state===Nr.Paused){this.epochStart=Date.now();return}const t=this.getSendFlags(),n=Date.now(),i=this.getRTT();if(t===0&&i>-1&&n-this.epochStart<=i*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&t===0)return;const s=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=n,this.sendFrame({type:gn.WindowUpdate,flag:t,streamID:this.streamId,length:s})}}function mI(r){return{type:gn[r.type],flags:[(r.flag&St.SYN)===St.SYN?"SYN":void 0,(r.flag&St.ACK)===St.ACK?"ACK":void 0,(r.flag&St.FIN)===St.FIN?"FIN":void 0,(r.flag&St.RST)===St.RST?"RST":void 0].filter(Boolean),streamID:r.streamID,length:r.length}}const tB="/yamux/1.0.0";var YR,ZR;ZR=Symbol.toStringTag,YR=yle;class Ale{constructor(e={}){f(this,"protocol",tB);f(this,"_init");f(this,ZR,"@libp2p/yamux");f(this,YR,["@libp2p/stream-multiplexing"]);this._init=e}createStreamMuxer(e){return new Tle(e,{...this._init})}}class Tle extends rO{constructor(t,n={}){super(t,{...n,protocol:tB,name:"yamux"});f(this,"nextStreamID");f(this,"nextPingID");f(this,"activePing");f(this,"rtt");f(this,"client");f(this,"localGoAway");f(this,"remoteGoAway");f(this,"numInboundStreams");f(this,"numOutboundStreams");f(this,"decoder");f(this,"keepAlive");f(this,"enableKeepAlive");f(this,"keepAliveInterval");f(this,"maxInboundStreams");f(this,"maxOutboundStreams");this.client=t.direction==="outbound",_le(n),this.enableKeepAlive=n.enableKeepAlive??Gm.enableKeepAlive,this.keepAliveInterval=n.keepAliveInterval??Gm.keepAliveInterval,this.maxInboundStreams=n.maxInboundStreams??Gm.maxInboundStreams,this.maxOutboundStreams=n.maxOutboundStreams??Gm.maxOutboundStreams,this.decoder=new Ele,this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=-1,this.log.trace("muxer created"),this.enableKeepAlive&&(this.log.trace("muxer keepalive enabled interval=%s",this.keepAliveInterval),this.keepAlive=aO(async i=>{try{await this.ping(i)}catch(s){this.log.error("ping error: %s",s)}},this.keepAliveInterval,{runImmediately:!0}),this.keepAlive.start())}onData(t){for(const n of this.decoder.emitFrames(t))this.handleFrame(n)}onCreateStream(){if(this.remoteGoAway!==void 0)throw new gd("Muxer closed remotely");if(this.localGoAway!==void 0)throw new gd("Muxer closed locally");const t=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.maxOutboundStreams)throw new Zk("max outbound streams exceeded");this.log.trace("new outgoing stream id=%s",t);const n=this._newStream(t,Nr.Init,"outbound");return this.numOutboundStreams++,queueMicrotask(()=>{n.sendWindowUpdate()}),n}async ping(t){if(this.remoteGoAway!==void 0)throw new gd("Muxer closed remotely");if(this.localGoAway!==void 0)throw new gd("Muxer closed locally");if(this.activePing!=null)return rs(this.activePing.promise,t==null?void 0:t.signal);this.activePing=Object.assign(Promise.withResolvers(),{id:this.nextPingID++,start:Date.now()}),this.sendPing(this.activePing.id);try{this.rtt=await rs(this.activePing.promise,t==null?void 0:t.signal)}finally{this.activePing=void 0}return this.rtt}getRTT(){return this.rtt}async close(t={}){var n;if(this.status==="open")try{const i=(t==null?void 0:t.reason)??Qr.NormalTermination;this.log.trace("muxer close reason=%s",Qr[i]),await super.close(t),this.sendGoAway(i)}finally{(n=this.keepAlive)==null||n.stop()}}abort(t){var n;if(this.status==="open")try{super.abort(t);let i=Qr.InternalError;wle(t)&&(i=t.reason),this.log.error("muxer abort reason=%s error=%s",i,t),this.sendGoAway(i)}finally{(n=this.keepAlive)==null||n.stop()}}onTransportClosed(){var t;try{super.onTransportClosed()}finally{(t=this.keepAlive)==null||t.stop()}}_newStream(t,n,i){if(this.streams.find(o=>o.streamId===t)!=null)throw new Ys("Stream already exists with that id");const s=new Mle({...this.streamOptions,id:`${t}`,streamId:t,state:n,direction:i,sendFrame:this.sendFrame.bind(this),log:this.log.newScope(`${i}:${t}`),getRTT:this.getRTT.bind(this)});return s.addEventListener("close",()=>{this.closeStream(t)},{once:!0}),s}closeStream(t){this.client===(t%2===0)?this.numInboundStreams--:this.numOutboundStreams--}handleFrame(t){const{streamID:n,type:i,length:s}=t.header;if(this.log.trace("received frame %o",mI(t.header)),n===0)switch(i){case gn.Ping:{this.handlePing(t.header);return}case gn.GoAway:{this.handleGoAway(s);return}default:throw new pc("Invalid frame type")}else switch(t.header.type){case gn.Data:case gn.WindowUpdate:{this.handleStreamMessage(t);return}default:throw new pc("Invalid frame type")}}handlePing(t){if(t.flag===St.SYN)this.log.trace("received ping request pingId=%s",t.length),this.sendPing(t.length,St.ACK);else if(t.flag===St.ACK)this.log.trace("received ping response pingId=%s",t.length),this.handlePingResponse(t.length);else throw new pc("Invalid frame flag")}handlePingResponse(t){if(this.activePing===void 0)throw new Jk("ping not requested");if(this.activePing.id!==t)throw new jk("ping doesn't match our id");this.activePing.resolve(Date.now()-this.activePing.start)}handleGoAway(t){this.log.trace("received GoAway reason=%s",Qr[t]??"unknown"),this.remoteGoAway=t,t===Qr.NormalTermination?this.onTransportClosed():this.abort(new Error("Remote sent GoAway"))}handleStreamMessage(t){const{streamID:n,flag:i,type:s}=t.header;(i&St.SYN)===St.SYN&&this.incomingStream(n);const o=this.streams.find(a=>a.streamId===n);if(o===void 0){this.log.trace("frame for missing stream id=%s",n);return}switch(s){case gn.WindowUpdate:{o.handleWindowUpdate(t);return}case gn.Data:{o.handleData(t);return}default:throw new Error("unreachable")}}incomingStream(t){if(this.client!==(t%2===0))throw new Ys("Both endpoints are clients");if(this.streams.find(i=>i.streamId===t))return;if(this.log.trace("new incoming stream id=%s",t),this.localGoAway!==void 0){this.sendFrame({type:gn.WindowUpdate,flag:St.RST,streamID:t,length:0});return}if(this.numInboundStreams>=this.maxInboundStreams){this.log("maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:gn.WindowUpdate,flag:St.RST,streamID:t,length:0});return}const n=this._newStream(t,Nr.SYNReceived,"inbound");this.numInboundStreams++,this.onRemoteStream(n)}sendFrame(t,n){let i;if(t.type===gn.Data){if(n==null)throw new pc("Invalid frame");i=new vt(pI(t),n)}else i=pI(t);return this.log.trace("sending frame %o",mI(t)),this.send(i)}sendPing(t,n=St.SYN){n===St.SYN?this.log.trace("sending ping request pingId=%s",t):this.log.trace("sending ping response pingId=%s",t),this.sendFrame({type:gn.Ping,flag:n,streamID:0,length:t})}sendGoAway(t=Qr.NormalTermination){this.log("sending GoAway reason=%s",Qr[t]),this.localGoAway=t,this.sendFrame({type:gn.GoAway,flag:0,streamID:0,length:t})}}function Cle(r={}){return()=>new Ale(r)}const Ile=Symbol.for("@libp2p/pubsub");var U_;let jc=(U_=class extends Error{constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}},f(U_,"name","InvalidParametersError"),U_);class bM extends Error{constructor(e="Invalid public key"){super(e),this.name="InvalidPublicKeyError"}}f(bM,"name","InvalidPublicKeyError");var k_;let Ple=(k_=class extends Error{constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}},f(k_,"name","InvalidMultihashError"),k_);var B_;let Nn=(B_=class extends Error{constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}},f(B_,"name","InvalidMessageError"),B_);class nB extends Error{constructor(e="Not started"){super(e),this.name="NotStartedError"}}f(nB,"name","NotStartedError");var F_;let wM=(F_=class extends Error{constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}},f(F_,"name","UnsupportedKeyTypeError"),F_);const rB=Symbol.for("@libp2p/peer-id");var gs;class iB extends EventTarget{constructor(){super();xe(this,gs,new Map)}listenerCount(t){const n=N(this,gs).get(t);return n==null?0:n.length}addEventListener(t,n,i){super.addEventListener(t,n,i);let s=N(this,gs).get(t);s==null&&(s=[],N(this,gs).set(t,s)),s.push({callback:n,once:(i!==!0&&i!==!1&&(i==null?void 0:i.once))??!1})}removeEventListener(t,n,i){super.removeEventListener(t.toString(),n??null,i);let s=N(this,gs).get(t);s!=null&&(s=s.filter(({callback:o})=>o!==n),N(this,gs).set(t,s))}dispatchEvent(t){const n=super.dispatchEvent(t);let i=N(this,gs).get(t.type);return i==null||(i=i.filter(({once:s})=>!s),N(this,gs).set(t.type,i)),n}safeDispatchEvent(t,n={}){return this.dispatchEvent(new CustomEvent(t,n))}}gs=new WeakMap;const Rle=Symbol.for("@libp2p/service-capabilities"),Dle=Symbol.for("@libp2p/service-dependencies");function Lle(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}function W0(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function Nle(r){return new TextEncoder().encode(r)}function Ole(r){return new TextDecoder().decode(r)}function Ule(r,e){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),n=0;n<t.length;n++)t[n]=255;for(var i=0;i<r.length;i++){var s=r.charAt(i),o=s.charCodeAt(0);if(t[o]!==255)throw new TypeError(s+" is ambiguous");t[o]=i}var a=r.length,c=r.charAt(0),l=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function h(p){if(p instanceof Uint8Array||(ArrayBuffer.isView(p)?p=new Uint8Array(p.buffer,p.byteOffset,p.byteLength):Array.isArray(p)&&(p=Uint8Array.from(p))),!(p instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(p.length===0)return"";for(var b=0,g=0,y=0,v=p.length;y!==v&&p[y]===0;)y++,b++;for(var w=(v-y)*u+1>>>0,_=new Uint8Array(w);y!==v;){for(var M=p[y],E=0,C=w-1;(M!==0||E<g)&&C!==-1;C--,E++)M+=256*_[C]>>>0,_[C]=M%a>>>0,M=M/a>>>0;if(M!==0)throw new Error("Non-zero carry");g=E,y++}for(var I=w-g;I!==w&&_[I]===0;)I++;for(var x=c.repeat(b);I<w;++I)x+=r.charAt(_[I]);return x}function d(p){if(typeof p!="string")throw new TypeError("Expected String");if(p.length===0)return new Uint8Array;var b=0;if(p[b]!==" "){for(var g=0,y=0;p[b]===c;)g++,b++;for(var v=(p.length-b)*l+1>>>0,w=new Uint8Array(v);p[b];){var _=t[p.charCodeAt(b)];if(_===255)return;for(var M=0,E=v-1;(_!==0||M<y)&&E!==-1;E--,M++)_+=a*w[E]>>>0,w[E]=_%256>>>0,_=_/256>>>0;if(_!==0)throw new Error("Non-zero carry");y=M,b++}if(p[b]!==" "){for(var C=v-y;C!==v&&w[C]===0;)C++;for(var I=new Uint8Array(g+(v-C)),x=g;C!==v;)I[x++]=w[C++];return I}}}function m(p){var b=d(p);if(b)return b;throw new Error(`Non-${e} character`)}return{encode:h,decodeUnsafe:d,decode:m}}var kle=Ule,Ble=kle;let Fle=class{constructor(e,t,n){f(this,"name");f(this,"prefix");f(this,"baseEncode");this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},$le=class{constructor(e,t,n){f(this,"name");f(this,"prefix");f(this,"baseDecode");f(this,"prefixCodePoint");this.name=e,this.prefix=t;const i=t.codePointAt(0);if(i===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=i,this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return sB(this,e)}};class zle{constructor(e){f(this,"decoders");this.decoders=e}or(e){return sB(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(n!=null)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function sB(r,e){return new zle({...r.decoders??{[r.prefix]:r},...e.decoders??{[e.prefix]:e}})}class Vle{constructor(e,t,n,i){f(this,"name");f(this,"prefix");f(this,"baseEncode");f(this,"baseDecode");f(this,"encoder");f(this,"decoder");this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=i,this.encoder=new Fle(e,t,n),this.decoder=new $le(e,t,i)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}function q0({name:r,prefix:e,encode:t,decode:n}){return new Vle(r,e,t,n)}function dp({name:r,prefix:e,alphabet:t}){const{encode:n,decode:i}=Ble(t,r);return q0({prefix:e,name:r,encode:n,decode:s=>W0(i(s))})}function Hle(r,e,t,n){let i=r.length;for(;r[i-1]==="=";)--i;const s=new Uint8Array(i*t/8|0);let o=0,a=0,c=0;for(let l=0;l<i;++l){const u=e[r[l]];if(u===void 0)throw new SyntaxError(`Non-${n} character`);a=a<<t|u,o+=t,o>=8&&(o-=8,s[c++]=255&a>>o)}if(o>=t||(255&a<<8-o)!==0)throw new SyntaxError("Unexpected end of data");return s}function Gle(r,e,t){const n=e[e.length-1]==="=",i=(1<<t)-1;let s="",o=0,a=0;for(let c=0;c<r.length;++c)for(a=a<<8|r[c],o+=8;o>t;)o-=t,s+=e[i&a>>o];if(o!==0&&(s+=e[i&a<<t-o]),n)for(;(s.length*t&7)!==0;)s+="=";return s}function Wle(r){const e={};for(let t=0;t<r.length;++t)e[r[t]]=t;return e}function Gn({name:r,prefix:e,bitsPerChar:t,alphabet:n}){const i=Wle(n);return q0({prefix:e,name:r,encode(s){return Gle(s,n,t)},decode(s){return Hle(s,i,t,r)}})}const Ir=dp({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),qle=dp({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),Kle=Object.freeze(Object.defineProperty({__proto__:null,base58btc:Ir,base58flickr:qle},Symbol.toStringTag,{value:"Module"})),Ud=Gn({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Xle=Gn({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Yle=Gn({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Zle=Gn({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Jle=Gn({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),jle=Gn({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Qle=Gn({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),eue=Gn({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),tue=Gn({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),nue=Object.freeze(Object.defineProperty({__proto__:null,base32:Ud,base32hex:Jle,base32hexpad:Qle,base32hexpadupper:eue,base32hexupper:jle,base32pad:Yle,base32padupper:Zle,base32upper:Xle,base32z:tue},Symbol.toStringTag,{value:"Module"})),Ag=dp({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),rue=dp({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),iue=Object.freeze(Object.defineProperty({__proto__:null,base36:Ag,base36upper:rue},Symbol.toStringTag,{value:"Module"}));var sue=oB,gI=128,oue=-128,aue=Math.pow(2,31);function oB(r,e,t){e=e||[],t=t||0;for(var n=t;r>=aue;)e[t++]=r&255|gI,r/=128;for(;r&oue;)e[t++]=r&255|gI,r>>>=7;return e[t]=r|0,oB.bytes=t-n+1,e}var cue=FS,lue=128,yI=127;function FS(r,n){var t=0,n=n||0,i=0,s=n,o,a=r.length;do{if(s>=a)throw FS.bytes=0,new RangeError("Could not decode varint");o=r[s++],t+=i<28?(o&yI)<<i:(o&yI)*Math.pow(2,i),i+=7}while(o>=lue);return FS.bytes=s-n,t}var uue=Math.pow(2,7),hue=Math.pow(2,14),due=Math.pow(2,21),fue=Math.pow(2,28),pue=Math.pow(2,35),mue=Math.pow(2,42),gue=Math.pow(2,49),yue=Math.pow(2,56),bue=Math.pow(2,63),wue=function(r){return r<uue?1:r<hue?2:r<due?3:r<fue?4:r<pue?5:r<mue?6:r<gue?7:r<yue?8:r<bue?9:10},vue={encode:sue,decode:cue,encodingLength:wue},Ay=vue;function $S(r,e=0){return[Ay.decode(r,e),Ay.decode.bytes]}function Ty(r,e,t=0){return Ay.encode(r,e,t),e}function Cy(r){return Ay.encodingLength(r)}function K0(r,e){const t=e.byteLength,n=Cy(r),i=n+Cy(t),s=new Uint8Array(i+t);return Ty(r,s,0),Ty(t,s,n),s.set(e,i),new vM(r,t,e,s)}function X0(r){const e=W0(r),[t,n]=$S(e),[i,s]=$S(e.subarray(n)),o=e.subarray(n+s);if(o.byteLength!==i)throw new Error("Incorrect length");return new vM(t,i,o,e)}function _ue(r,e){if(r===e)return!0;{const t=e;return r.code===t.code&&r.size===t.size&&t.bytes instanceof Uint8Array&&Lle(r.bytes,t.bytes)}}class vM{constructor(e,t,n,i){f(this,"code");f(this,"size");f(this,"digest");f(this,"bytes");this.code=e,this.size=t,this.digest=n,this.bytes=i}}function bI(r,e){const{bytes:t,version:n}=r;switch(n){case 0:return Sue(t,zS(r),e??Ir.encoder);default:return Eue(t,zS(r),e??Ud.encoder)}}const wI=new WeakMap;function zS(r){const e=wI.get(r);if(e==null){const t=new Map;return wI.set(r,t),t}return e}var JR;class en{constructor(e,t,n,i){f(this,"code");f(this,"version");f(this,"multihash");f(this,"bytes");f(this,"/");f(this,JR,"CID");this.code=t,this.version=e,this.multihash=n,this.bytes=i,this["/"]=i}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==Qh)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==Mue)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return en.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,n=K0(e,t);return en.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return en.equals(this,e)}static equals(e,t){const n=t;return n!=null&&e.code===n.code&&e.version===n.version&&_ue(e.multihash,n.multihash)}toString(e){return bI(this,e)}toJSON(){return{"/":bI(this)}}link(){return this}[(JR=Symbol.toStringTag,Symbol.for("nodejs.util.inspect.custom"))](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const t=e;if(t instanceof en)return t;if(t["/"]!=null&&t["/"]===t.bytes||t.asCID===t){const{version:n,code:i,multihash:s,bytes:o}=t;return new en(n,i,s,o??vI(n,i,s.bytes))}else if(t[Aue]===!0){const{version:n,multihash:i,code:s}=t,o=X0(i);return en.create(n,s,o)}else return null}static create(e,t,n){if(typeof t!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(t!==Qh)throw new Error(`Version 0 CID must use dag-pb (code: ${Qh}) block encoding`);return new en(e,t,n,n.bytes)}case 1:{const i=vI(e,t,n.bytes);return new en(e,t,n,i)}default:throw new Error("Invalid version")}}static createV0(e){return en.create(0,Qh,e)}static createV1(e,t){return en.create(1,e,t)}static decode(e){const[t,n]=en.decodeFirst(e);if(n.length!==0)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=en.inspectBytes(e),n=t.size-t.multihashSize,i=W0(e.subarray(n,n+t.multihashSize));if(i.byteLength!==t.multihashSize)throw new Error("Incorrect length");const s=i.subarray(t.multihashSize-t.digestSize),o=new vM(t.multihashCode,t.digestSize,s,i);return[t.version===0?en.createV0(o):en.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0;const n=()=>{const[h,d]=$S(e.subarray(t));return t+=d,h};let i=n(),s=Qh;if(i===18?(i=0,t=0):s=n(),i!==0&&i!==1)throw new RangeError(`Invalid CID version ${i}`);const o=t,a=n(),c=n(),l=t+c,u=l-o;return{version:i,codec:s,multihashCode:a,digestSize:c,multihashSize:u,size:l}}static parse(e,t){const[n,i]=xue(e,t),s=en.decode(i);if(s.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return zS(s).set(n,e),s}}function xue(r,e){switch(r[0]){case"Q":{const t=e??Ir;return[Ir.prefix,t.decode(`${Ir.prefix}${r}`)]}case Ir.prefix:{const t=e??Ir;return[Ir.prefix,t.decode(r)]}case Ud.prefix:{const t=e??Ud;return[Ud.prefix,t.decode(r)]}case Ag.prefix:{const t=e??Ag;return[Ag.prefix,t.decode(r)]}default:{if(e==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],e.decode(r)]}}}function Sue(r,e,t){const{prefix:n}=t;if(n!==Ir.prefix)throw Error(`Cannot string encode V0 in ${t.name} encoding`);const i=e.get(n);if(i==null){const s=t.encode(r).slice(1);return e.set(n,s),s}else return i}function Eue(r,e,t){const{prefix:n}=t,i=e.get(n);if(i==null){const s=t.encode(r);return e.set(n,s),s}else return i}const Qh=112,Mue=18;function vI(r,e,t){const n=Cy(r),i=n+Cy(e),s=new Uint8Array(i+t.byteLength);return Ty(r,s,0),Ty(e,s,n),s.set(t,i),s}const Aue=Symbol.for("@ipld/js-cid/CID"),aB=0,Tue="identity",cB=W0;function Cue(r,e){if((e==null?void 0:e.truncate)!=null&&e.truncate!==r.byteLength){if(e.truncate<0||e.truncate>r.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${r.byteLength}`);r=r.subarray(0,e.truncate)}return K0(aB,cB(r))}const fp={code:aB,name:Tue,encode:cB,digest:Cue};function Vc(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}function Yo(r=0){return new Uint8Array(r)}function Ta(r=0){return new Uint8Array(r)}function Iy(r,e){e==null&&(e=r.reduce((i,s)=>i+s.length,0));const t=Ta(e);let n=0;for(const i of r)t.set(i,n),n+=i.length;return t}const lB=Symbol.for("@achingbrain/uint8arraylist");function _I(r,e){if(e==null||e<0)throw new RangeError("index is out of bounds");let t=0;for(const n of r){const i=t+n.byteLength;if(e<i)return{buf:n,index:e-t};t=i}throw new RangeError("index is out of bounds")}function Wm(r){return!!(r!=null&&r[lB])}var jR;class $n{constructor(...e){f(this,"bufs");f(this,"length");f(this,jR,!0);this.bufs=[],this.length=0,e.length>0&&this.appendAll(e)}*[(jR=lB,Symbol.iterator)](){yield*this.bufs}get byteLength(){return this.length}append(...e){this.appendAll(e)}appendAll(e){let t=0;for(const n of e)if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.push(n);else if(Wm(n))t+=n.byteLength,this.bufs.push(...n.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}prepend(...e){this.prependAll(e)}prependAll(e){let t=0;for(const n of e.reverse())if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.unshift(n);else if(Wm(n))t+=n.byteLength,this.bufs.unshift(...n.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}get(e){const t=_I(this.bufs,e);return t.buf[t.index]}set(e,t){const n=_I(this.bufs,e);n.buf[n.index]=t}write(e,t=0){if(e instanceof Uint8Array)for(let n=0;n<e.length;n++)this.set(t+n,e[n]);else if(Wm(e))for(let n=0;n<e.length;n++)this.set(t+n,e.get(n));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(e){if(e=Math.trunc(e),!(Number.isNaN(e)||e<=0)){if(e===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(e>=this.bufs[0].byteLength)e-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(e),this.length-=e;break}}}slice(e,t){const{bufs:n,length:i}=this._subList(e,t);return Iy(n,i)}subarray(e,t){const{bufs:n,length:i}=this._subList(e,t);return n.length===1?n[0]:Iy(n,i)}sublist(e,t){const{bufs:n,length:i}=this._subList(e,t),s=new $n;return s.length=i,s.bufs=[...n],s}_subList(e,t){if(e=e??0,t=t??this.length,e<0&&(e=this.length+e),t<0&&(t=this.length+t),e<0||t>this.length)throw new RangeError("index is out of bounds");if(e===t)return{bufs:[],length:0};if(e===0&&t===this.length)return{bufs:this.bufs,length:this.length};const n=[];let i=0;for(let s=0;s<this.bufs.length;s++){const o=this.bufs[s],a=i,c=a+o.byteLength;if(i=c,e>=c)continue;const l=e>=a&&e<c,u=t>a&&t<=c;if(l&&u){if(e===a&&t===c){n.push(o);break}const h=e-a;n.push(o.subarray(h,h+(t-e)));break}if(l){if(e===0){n.push(o);continue}n.push(o.subarray(e-a));continue}if(u){if(t===c){n.push(o);break}n.push(o.subarray(0,t-a));break}n.push(o)}return{bufs:n,length:t-e}}indexOf(e,t=0){if(!Wm(e)&&!(e instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const n=e instanceof Uint8Array?e:e.subarray();if(t=Number(t??0),isNaN(t)&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),e.length===0)return t>this.length?this.length:t;const i=n.byteLength;if(i===0)throw new TypeError("search must be at least 1 byte long");const s=256,o=new Int32Array(s);for(let h=0;h<s;h++)o[h]=-1;for(let h=0;h<i;h++)o[n[h]]=h;const a=o,c=this.byteLength-n.byteLength,l=n.byteLength-1;let u;for(let h=t;h<=c;h+=u){u=0;for(let d=l;d>=0;d--){const m=this.get(h+d);if(n[d]!==m){u=Math.max(1,d-a[m]);break}}if(u===0)return h}return-1}getInt8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getInt8(0)}setInt8(e,t){const n=Ta(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt8(0,t),this.write(n,e)}getInt16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt16(0,t)}setInt16(e,t,n){const i=Yo(2);new DataView(i.buffer,i.byteOffset,i.byteLength).setInt16(0,t,n),this.write(i,e)}getInt32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt32(0,t)}setInt32(e,t,n){const i=Yo(4);new DataView(i.buffer,i.byteOffset,i.byteLength).setInt32(0,t,n),this.write(i,e)}getBigInt64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigInt64(0,t)}setBigInt64(e,t,n){const i=Yo(8);new DataView(i.buffer,i.byteOffset,i.byteLength).setBigInt64(0,t,n),this.write(i,e)}getUint8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getUint8(0)}setUint8(e,t){const n=Ta(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint8(0,t),this.write(n,e)}getUint16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint16(0,t)}setUint16(e,t,n){const i=Yo(2);new DataView(i.buffer,i.byteOffset,i.byteLength).setUint16(0,t,n),this.write(i,e)}getUint32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint32(0,t)}setUint32(e,t,n){const i=Yo(4);new DataView(i.buffer,i.byteOffset,i.byteLength).setUint32(0,t,n),this.write(i,e)}getBigUint64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigUint64(0,t)}setBigUint64(e,t,n){const i=Yo(8);new DataView(i.buffer,i.byteOffset,i.byteLength).setBigUint64(0,t,n),this.write(i,e)}getFloat32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat32(0,t)}setFloat32(e,t,n){const i=Yo(4);new DataView(i.buffer,i.byteOffset,i.byteLength).setFloat32(0,t,n),this.write(i,e)}getFloat64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat64(0,t)}setFloat64(e,t,n){const i=Yo(8);new DataView(i.buffer,i.byteOffset,i.byteLength).setFloat64(0,t,n),this.write(i,e)}equals(e){if(e==null||!(e instanceof $n)||e.bufs.length!==this.bufs.length)return!1;for(let t=0;t<this.bufs.length;t++)if(!Vc(this.bufs[t],e.bufs[t]))return!1;return!0}static fromUint8Arrays(e,t){const n=new $n;return n.bufs=e,t==null&&(t=e.reduce((i,s)=>i+s.byteLength,0)),n.length=t,n}}const Iue=dp({prefix:"9",name:"base10",alphabet:"0123456789"}),Pue=Object.freeze(Object.defineProperty({__proto__:null,base10:Iue},Symbol.toStringTag,{value:"Module"})),Rue=Gn({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Due=Gn({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),Lue=Object.freeze(Object.defineProperty({__proto__:null,base16:Rue,base16upper:Due},Symbol.toStringTag,{value:"Module"})),Nue=Gn({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),Oue=Object.freeze(Object.defineProperty({__proto__:null,base2:Nue},Symbol.toStringTag,{value:"Module"})),uB=Array.from(""),Uue=uB.reduce((r,e,t)=>(r[t]=e,r),[]),kue=uB.reduce((r,e,t)=>{const n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);return r[n]=t,r},[]);function Bue(r){return r.reduce((e,t)=>(e+=Uue[t],e),"")}function Fue(r){const e=[];for(const t of r){const n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);const i=kue[n];if(i==null)throw new Error(`Non-base256emoji character: ${t}`);e.push(i)}return new Uint8Array(e)}const $ue=q0({prefix:"",name:"base256emoji",encode:Bue,decode:Fue}),zue=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:$ue},Symbol.toStringTag,{value:"Module"})),Vue=Gn({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Hue=Gn({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Gue=Gn({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Wue=Gn({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),que=Object.freeze(Object.defineProperty({__proto__:null,base64:Vue,base64pad:Hue,base64url:Gue,base64urlpad:Wue},Symbol.toStringTag,{value:"Module"})),Kue=Gn({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),Xue=Object.freeze(Object.defineProperty({__proto__:null,base8:Kue},Symbol.toStringTag,{value:"Module"})),Yue=q0({prefix:"\0",name:"identity",encode:r=>Ole(r),decode:r=>Nle(r)}),Zue=Object.freeze(Object.defineProperty({__proto__:null,identity:Yue},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const Jue=20;function jue({name:r,code:e,encode:t,minDigestLength:n,maxDigestLength:i}){return new Que(r,e,t,n,i)}class Que{constructor(e,t,n,i,s){f(this,"name");f(this,"code");f(this,"encode");f(this,"minDigestLength");f(this,"maxDigestLength");this.name=e,this.code=t,this.encode=n,this.minDigestLength=i??Jue,this.maxDigestLength=s}digest(e,t){if((t==null?void 0:t.truncate)!=null){if(t.truncate<this.minDigestLength)throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);if(this.maxDigestLength!=null&&t.truncate>this.maxDigestLength)throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`)}if(e instanceof Uint8Array){const n=this.encode(e);return n instanceof Uint8Array?xI(n,this.code,t==null?void 0:t.truncate):n.then(i=>xI(i,this.code,t==null?void 0:t.truncate))}else throw Error("Unknown type, must be binary type")}}function xI(r,e,t){if(t!=null&&t!==r.byteLength){if(t>r.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${r.byteLength}`);r=r.subarray(0,t)}return K0(e,r)}function ehe(r){return async e=>new Uint8Array(await crypto.subtle.digest(r,e))}const _M=jue({name:"sha2-256",code:18,encode:ehe("SHA-256")}),SI={...Zue,...Oue,...Xue,...Pue,...Lue,...nue,...iue,...Kle,...que,...zue};function hB(r,e,t,n){return{name:r,prefix:e,encoder:{name:r,prefix:e,encode:t},decoder:{decode:n}}}const EI=hB("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),Ow=hB("ascii","a",r=>{let e="a";for(let t=0;t<r.length;t++)e+=String.fromCharCode(r[t]);return e},r=>{r=r.substring(1);const e=Ta(r.length);for(let t=0;t<r.length;t++)e[t]=r.charCodeAt(t);return e}),dB={utf8:EI,"utf-8":EI,hex:SI.base16,latin1:Ow,ascii:Ow,binary:Ow,...SI};function Ro(r,e="utf8"){const t=dB[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.decoder.decode(`${t.prefix}${r}`)}function ei(r,e="utf8"){const t=dB[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.encoder.encode(r).substring(1)}const the=parseInt("11111",2),VS=parseInt("10000000",2),nhe=parseInt("01111111",2),MI={0:ed,1:ed,2:rhe,3:ohe,4:ahe,5:she,6:ihe,16:ed,22:ed,48:ed};function Y0(r,e={offset:0}){const t=r[e.offset]&the;if(e.offset++,MI[t]!=null)return MI[t](r,e);throw new Error("No decoder for tag "+t)}function pp(r,e){let t=0;if((r[e.offset]&VS)===VS){const n=r[e.offset]&nhe;let i="0x";e.offset++;for(let s=0;s<n;s++,e.offset++)i+=r[e.offset].toString(16).padStart(2,"0");t=parseInt(i,16)}else t=r[e.offset],e.offset++;return t}function ed(r,e){pp(r,e);const t=[];for(;!(e.offset>=r.byteLength);){const n=Y0(r,e);if(n===null)break;t.push(n)}return t}function rhe(r,e){const t=pp(r,e),n=e.offset,i=e.offset+t,s=[];for(let o=n;o<i;o++)o===n&&r[o]===0||s.push(r[o]);return e.offset+=t,Uint8Array.from(s)}function ihe(r,e){const t=pp(r,e),n=e.offset+t,i=r[e.offset];e.offset++;let s=0,o=0;i<40?(s=0,o=i):i<80?(s=1,o=i-40):(s=2,o=i-80);let a=`${s}.${o}`,c=[];for(;e.offset<n;){const l=r[e.offset];if(e.offset++,c.push(l&127),l<128){c.reverse();let u=0;for(let h=0;h<c.length;h++)u+=c[h]<<h*7;a+=`.${u}`,c=[]}}return a}function she(r,e){return e.offset++,null}function ohe(r,e){const t=pp(r,e),n=r[e.offset];e.offset++;const i=r.subarray(e.offset,e.offset+t-1);if(e.offset+=t,n!==0)throw new Error("Unused bits in bit string is unimplemented");return i}function ahe(r,e){const t=pp(r,e),n=r.subarray(e.offset,e.offset+t);return e.offset+=t,n}function che(r){let e=r.toString(16);e.length%2===1&&(e="0"+e);const t=new $n;for(let n=0;n<e.length;n+=2)t.append(Uint8Array.from([parseInt(`${e[n]}${e[n+1]}`,16)]));return t}function xM(r){if(r.byteLength<128)return Uint8Array.from([r.byteLength]);const e=che(r.byteLength);return new $n(Uint8Array.from([e.byteLength|VS]),e)}function HS(r){const e=new $n,t=128;return(r.subarray()[0]&t)===t&&e.append(Uint8Array.from([0])),e.append(r),new $n(Uint8Array.from([2]),xM(e),e)}function fB(r){const e=Uint8Array.from([0]),t=new $n(e,r);return new $n(Uint8Array.from([3]),xM(t),t)}function kd(r,e=48){const t=new $n;for(const n of r)t.append(n);return new $n(Uint8Array.from([e]),xM(t),t)}async function lhe(r,e,t,n){var o,a;const i=await crypto.subtle.importKey("jwk",r,{name:"ECDSA",namedCurve:r.crv??"P-256"},!1,["verify"]);(o=n==null?void 0:n.signal)==null||o.throwIfAborted();const s=await crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},i,e,t.subarray());return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),s}const uhe=Uint8Array.from([6,8,42,134,72,206,61,3,1,7]),hhe=Uint8Array.from([6,5,43,129,4,0,34]),dhe=Uint8Array.from([6,5,43,129,4,0,35]),fhe={ext:!0,kty:"EC",crv:"P-256"},phe={ext:!0,kty:"EC",crv:"P-384"},mhe={ext:!0,kty:"EC",crv:"P-521"},Uw=32,kw=48,Bw=66;function pB(r){const e=Y0(r);return ghe(e)}function ghe(r){const e=r[1][1][0],t=1;let n,i;if(e.byteLength===Uw*2+1)return n=ei(e.subarray(t,t+Uw),"base64url"),i=ei(e.subarray(t+Uw),"base64url"),new Fw({...fhe,key_ops:["verify"],x:n,y:i});if(e.byteLength===kw*2+1)return n=ei(e.subarray(t,t+kw),"base64url"),i=ei(e.subarray(t+kw),"base64url"),new Fw({...phe,key_ops:["verify"],x:n,y:i});if(e.byteLength===Bw*2+1)return n=ei(e.subarray(t,t+Bw),"base64url"),i=ei(e.subarray(t+Bw),"base64url"),new Fw({...mhe,key_ops:["verify"],x:n,y:i});throw new jc(`coordinates were wrong length, got ${e.byteLength}, expected 65, 97 or 133`)}function yhe(r){return kd([HS(Uint8Array.from([1])),kd([bhe(r.crv)],160),kd([fB(new $n(Uint8Array.from([4]),Ro(r.x??"","base64url"),Ro(r.y??"","base64url")))],161)]).subarray()}function bhe(r){if(r==="P-256")return uhe;if(r==="P-384")return hhe;if(r==="P-521")return dhe;throw new jc(`Invalid curve ${r}`)}class Fw{constructor(e){f(this,"type","ECDSA");f(this,"jwk");f(this,"_raw");this.jwk=e}get raw(){return this._raw==null&&(this._raw=yhe(this.jwk)),this._raw}toMultihash(){return fp.digest(yp(this))}toCID(){return en.createV1(114,this.toMultihash())}toString(){return Ir.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Vc(this.raw,e.raw)}async verify(e,t,n){return lhe(this.jwk,t,e,n)}}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Z0(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Hc(r,e=""){if(!Number.isSafeInteger(r)||r<0){const t=e&&`"${e}" `;throw new Error(`${t}expected integer >= 0, got ${r}`)}}function bt(r,e,t=""){const n=Z0(r),i=r==null?void 0:r.length,s=e!==void 0;if(!n||s&&i!==e){const o=t&&`"${t}" `,a=s?` of length ${e}`:"",c=n?`length=${i}`:`type=${typeof r}`;throw new Error(o+"expected Uint8Array"+a+", got "+c)}return r}function mB(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash must wrapped by utils.createHasher");Hc(r.outputLen),Hc(r.blockLen)}function Py(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function whe(r,e){bt(r,void 0,"digestInto() output");const t=e.outputLen;if(r.length<t)throw new Error('"digestInto() output" expected to be of length >='+t)}function ih(...r){for(let e=0;e<r.length;e++)r[e].fill(0)}function $w(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}function cs(r,e){return r<<32-e|r>>>e}const gB=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",vhe=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function mp(r){if(bt(r),gB)return r.toHex();let e="";for(let t=0;t<r.length;t++)e+=vhe[r[t]];return e}const Gs={_0:48,_9:57,A:65,F:70,a:97,f:102};function AI(r){if(r>=Gs._0&&r<=Gs._9)return r-Gs._0;if(r>=Gs.A&&r<=Gs.F)return r-(Gs.A-10);if(r>=Gs.a&&r<=Gs.f)return r-(Gs.a-10)}function If(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);if(gB)return Uint8Array.fromHex(r);const e=r.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(t);for(let i=0,s=0;i<t;i++,s+=2){const o=AI(r.charCodeAt(s)),a=AI(r.charCodeAt(s+1));if(o===void 0||a===void 0){const c=r[s]+r[s+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+s)}n[i]=o*16+a}return n}function xs(...r){let e=0;for(let n=0;n<r.length;n++){const i=r[n];bt(i),e+=i.length}const t=new Uint8Array(e);for(let n=0,i=0;n<r.length;n++){const s=r[n];t.set(s,i),i+=s.length}return t}function yB(r,e={}){const t=(i,s)=>r(s).update(i).digest(),n=r(void 0);return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=i=>r(i),Object.assign(t,e),Object.freeze(t)}function J0(r=32){const e=typeof globalThis=="object"?globalThis.crypto:null;if(typeof(e==null?void 0:e.getRandomValues)!="function")throw new Error("crypto.getRandomValues must be defined");return e.getRandomValues(new Uint8Array(r))}const bB=r=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,r])});function _he(r,e,t){return r&e^~r&t}function xhe(r,e,t){return r&e^r&t^e&t}class wB{constructor(e,t,n,i){f(this,"blockLen");f(this,"outputLen");f(this,"padOffset");f(this,"isLE");f(this,"buffer");f(this,"view");f(this,"finished",!1);f(this,"length",0);f(this,"pos",0);f(this,"destroyed",!1);this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=i,this.buffer=new Uint8Array(e),this.view=$w(this.buffer)}update(e){Py(this),bt(e);const{view:t,buffer:n,blockLen:i}=this,s=e.length;for(let o=0;o<s;){const a=Math.min(i-this.pos,s-o);if(a===i){const c=$w(e);for(;i<=s-o;o+=i)this.process(c,o);continue}n.set(e.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===i&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Py(this),whe(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:i,isLE:s}=this;let{pos:o}=this;t[o++]=128,ih(this.buffer.subarray(o)),this.padOffset>i-o&&(this.process(n,0),o=0);for(let h=o;h<i;h++)t[h]=0;n.setBigUint64(i-8,BigInt(this.length*8),s),this.process(n,0);const a=$w(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen must be aligned to 32bit");const l=c/4,u=this.get();if(l>u.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<l;h++)a.setUint32(4*h,u[h],s)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:i,finished:s,destroyed:o,pos:a}=this;return e.destroyed=o,e.finished=s,e.length=i,e.pos=a,i%t&&e.buffer.set(n),e}clone(){return this._cloneInto()}}const Zo=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Zn=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),qm=BigInt(2**32-1),TI=BigInt(32);function She(r,e=!1){return e?{h:Number(r&qm),l:Number(r>>TI&qm)}:{h:Number(r>>TI&qm)|0,l:Number(r&qm)|0}}function Ehe(r,e=!1){const t=r.length;let n=new Uint32Array(t),i=new Uint32Array(t);for(let s=0;s<t;s++){const{h:o,l:a}=She(r[s],e);[n[s],i[s]]=[o,a]}return[n,i]}const CI=(r,e,t)=>r>>>t,II=(r,e,t)=>r<<32-t|e>>>t,Il=(r,e,t)=>r>>>t|e<<32-t,Pl=(r,e,t)=>r<<32-t|e>>>t,Km=(r,e,t)=>r<<64-t|e>>>t-32,Xm=(r,e,t)=>r>>>t-32|e<<64-t;function Ws(r,e,t,n){const i=(e>>>0)+(n>>>0);return{h:r+t+(i/2**32|0)|0,l:i|0}}const Mhe=(r,e,t)=>(r>>>0)+(e>>>0)+(t>>>0),Ahe=(r,e,t,n)=>e+t+n+(r/2**32|0)|0,The=(r,e,t,n)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0),Che=(r,e,t,n,i)=>e+t+n+i+(r/2**32|0)|0,Ihe=(r,e,t,n,i)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0)+(i>>>0),Phe=(r,e,t,n,i,s)=>e+t+n+i+s+(r/2**32|0)|0,Rhe=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Jo=new Uint32Array(64);class Dhe extends wB{constructor(e){super(64,e,8,!1)}get(){const{A:e,B:t,C:n,D:i,E:s,F:o,G:a,H:c}=this;return[e,t,n,i,s,o,a,c]}set(e,t,n,i,s,o,a,c){this.A=e|0,this.B=t|0,this.C=n|0,this.D=i|0,this.E=s|0,this.F=o|0,this.G=a|0,this.H=c|0}process(e,t){for(let h=0;h<16;h++,t+=4)Jo[h]=e.getUint32(t,!1);for(let h=16;h<64;h++){const d=Jo[h-15],m=Jo[h-2],p=cs(d,7)^cs(d,18)^d>>>3,b=cs(m,17)^cs(m,19)^m>>>10;Jo[h]=b+Jo[h-7]+p+Jo[h-16]|0}let{A:n,B:i,C:s,D:o,E:a,F:c,G:l,H:u}=this;for(let h=0;h<64;h++){const d=cs(a,6)^cs(a,11)^cs(a,25),m=u+d+_he(a,c,l)+Rhe[h]+Jo[h]|0,b=(cs(n,2)^cs(n,13)^cs(n,22))+xhe(n,i,s)|0;u=l,l=c,c=a,a=o+m|0,o=s,s=i,i=n,n=m+b|0}n=n+this.A|0,i=i+this.B|0,s=s+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,l=l+this.G|0,u=u+this.H|0,this.set(n,i,s,o,a,c,l,u)}roundClean(){ih(Jo)}destroy(){this.set(0,0,0,0,0,0,0,0),ih(this.buffer)}}class Lhe extends Dhe{constructor(){super(32);f(this,"A",Zo[0]|0);f(this,"B",Zo[1]|0);f(this,"C",Zo[2]|0);f(this,"D",Zo[3]|0);f(this,"E",Zo[4]|0);f(this,"F",Zo[5]|0);f(this,"G",Zo[6]|0);f(this,"H",Zo[7]|0)}}const vB=Ehe(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),Nhe=vB[0],Ohe=vB[1],jo=new Uint32Array(80),Qo=new Uint32Array(80);class Uhe extends wB{constructor(e){super(128,e,16,!1)}get(){const{Ah:e,Al:t,Bh:n,Bl:i,Ch:s,Cl:o,Dh:a,Dl:c,Eh:l,El:u,Fh:h,Fl:d,Gh:m,Gl:p,Hh:b,Hl:g}=this;return[e,t,n,i,s,o,a,c,l,u,h,d,m,p,b,g]}set(e,t,n,i,s,o,a,c,l,u,h,d,m,p,b,g){this.Ah=e|0,this.Al=t|0,this.Bh=n|0,this.Bl=i|0,this.Ch=s|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=l|0,this.El=u|0,this.Fh=h|0,this.Fl=d|0,this.Gh=m|0,this.Gl=p|0,this.Hh=b|0,this.Hl=g|0}process(e,t){for(let w=0;w<16;w++,t+=4)jo[w]=e.getUint32(t),Qo[w]=e.getUint32(t+=4);for(let w=16;w<80;w++){const _=jo[w-15]|0,M=Qo[w-15]|0,E=Il(_,M,1)^Il(_,M,8)^CI(_,M,7),C=Pl(_,M,1)^Pl(_,M,8)^II(_,M,7),I=jo[w-2]|0,x=Qo[w-2]|0,T=Il(I,x,19)^Km(I,x,61)^CI(I,x,6),F=Pl(I,x,19)^Xm(I,x,61)^II(I,x,6),$=The(C,F,Qo[w-7],Qo[w-16]),H=Che($,E,T,jo[w-7],jo[w-16]);jo[w]=H|0,Qo[w]=$|0}let{Ah:n,Al:i,Bh:s,Bl:o,Ch:a,Cl:c,Dh:l,Dl:u,Eh:h,El:d,Fh:m,Fl:p,Gh:b,Gl:g,Hh:y,Hl:v}=this;for(let w=0;w<80;w++){const _=Il(h,d,14)^Il(h,d,18)^Km(h,d,41),M=Pl(h,d,14)^Pl(h,d,18)^Xm(h,d,41),E=h&m^~h&b,C=d&p^~d&g,I=Ihe(v,M,C,Ohe[w],Qo[w]),x=Phe(I,y,_,E,Nhe[w],jo[w]),T=I|0,F=Il(n,i,28)^Km(n,i,34)^Km(n,i,39),$=Pl(n,i,28)^Xm(n,i,34)^Xm(n,i,39),H=n&s^n&a^s&a,S=i&o^i&c^o&c;y=b|0,v=g|0,b=m|0,g=p|0,m=h|0,p=d|0,{h,l:d}=Ws(l|0,u|0,x|0,T|0),l=a|0,u=c|0,a=s|0,c=o|0,s=n|0,o=i|0;const A=Mhe(T,$,S);n=Ahe(A,x,F,H),i=A|0}({h:n,l:i}=Ws(this.Ah|0,this.Al|0,n|0,i|0)),{h:s,l:o}=Ws(this.Bh|0,this.Bl|0,s|0,o|0),{h:a,l:c}=Ws(this.Ch|0,this.Cl|0,a|0,c|0),{h:l,l:u}=Ws(this.Dh|0,this.Dl|0,l|0,u|0),{h,l:d}=Ws(this.Eh|0,this.El|0,h|0,d|0),{h:m,l:p}=Ws(this.Fh|0,this.Fl|0,m|0,p|0),{h:b,l:g}=Ws(this.Gh|0,this.Gl|0,b|0,g|0),{h:y,l:v}=Ws(this.Hh|0,this.Hl|0,y|0,v|0),this.set(n,i,s,o,a,c,l,u,h,d,m,p,b,g,y,v)}roundClean(){ih(jo,Qo)}destroy(){ih(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class khe extends Uhe{constructor(){super(64);f(this,"Ah",Zn[0]|0);f(this,"Al",Zn[1]|0);f(this,"Bh",Zn[2]|0);f(this,"Bl",Zn[3]|0);f(this,"Ch",Zn[4]|0);f(this,"Cl",Zn[5]|0);f(this,"Dh",Zn[6]|0);f(this,"Dl",Zn[7]|0);f(this,"Eh",Zn[8]|0);f(this,"El",Zn[9]|0);f(this,"Fh",Zn[10]|0);f(this,"Fl",Zn[11]|0);f(this,"Gh",Zn[12]|0);f(this,"Gl",Zn[13]|0);f(this,"Hh",Zn[14]|0);f(this,"Hl",Zn[15]|0)}}const _B=yB(()=>new Lhe,bB(1)),Bhe=yB(()=>new khe,bB(3));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const SM=BigInt(0),GS=BigInt(1);function Gc(r,e=""){if(typeof r!="boolean"){const t=e&&`"${e}" `;throw new Error(t+"expected boolean, got type="+typeof r)}return r}function xB(r){if(typeof r=="bigint"){if(!Tg(r))throw new Error("positive bigint expected, got "+r)}else Hc(r);return r}function Ym(r){const e=xB(r).toString(16);return e.length&1?"0"+e:e}function SB(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?SM:BigInt("0x"+r)}function j0(r){return SB(mp(r))}function Pf(r){return SB(mp(WS(bt(r)).reverse()))}function EM(r,e){Hc(e),r=xB(r);const t=If(r.toString(16).padStart(e*2,"0"));if(t.length!==e)throw new Error("number too large");return t}function EB(r,e){return EM(r,e).reverse()}function WS(r){return Uint8Array.from(r)}const Tg=r=>typeof r=="bigint"&&SM<=r;function Fhe(r,e,t){return Tg(r)&&Tg(e)&&Tg(t)&&e<=r&&r<t}function qS(r,e,t,n){if(!Fhe(e,t,n))throw new Error("expected valid "+r+": "+t+" <= n < "+n+", got "+e)}function $he(r){let e;for(e=0;r>SM;r>>=GS,e+=1);return e}const MM=r=>(GS<<BigInt(r))-GS;function zhe(r,e,t){if(Hc(r,"hashLen"),Hc(e,"qByteLen"),typeof t!="function")throw new Error("hmacFn must be a function");const n=g=>new Uint8Array(g),i=Uint8Array.of(),s=Uint8Array.of(0),o=Uint8Array.of(1),a=1e3;let c=n(r),l=n(r),u=0;const h=()=>{c.fill(1),l.fill(0),u=0},d=(...g)=>t(l,xs(c,...g)),m=(g=i)=>{l=d(s,g),c=d(),g.length!==0&&(l=d(o,g),c=d())},p=()=>{if(u++>=a)throw new Error("drbg: tried max amount of iterations");let g=0;const y=[];for(;g<e;){c=d();const v=c.slice();y.push(v),g+=c.length}return xs(...y)};return(g,y)=>{h(),m(g);let v;for(;!(v=y(p()));)m();return h(),v}}function gp(r,e={},t={}){if(!r||typeof r!="object")throw new Error("expected valid options object");function n(s,o,a){const c=r[s];if(a&&c===void 0)return;const l=typeof c;if(l!==o||c===null)throw new Error(`param "${s}" is invalid: expected ${o}, got ${l}`)}const i=(s,o)=>Object.entries(s).forEach(([a,c])=>n(a,c,o));i(e,!1),i(t,!0)}function Ry(r){const e=new WeakMap;return(t,...n)=>{const i=e.get(t);if(i!==void 0)return i;const s=r(t,...n);return e.set(t,s),s}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const zr=BigInt(0),zn=BigInt(1),mc=BigInt(2),MB=BigInt(3),AB=BigInt(4),TB=BigInt(5),Vhe=BigInt(7),CB=BigInt(8),Hhe=BigInt(9),IB=BigInt(16);function yn(r,e){const t=r%e;return t>=zr?t:e+t}function tn(r,e,t){let n=r;for(;e-- >zr;)n*=n,n%=t;return n}function PI(r,e){if(r===zr)throw new Error("invert: expected non-zero number");if(e<=zr)throw new Error("invert: expected positive modulus, got "+e);let t=yn(r,e),n=e,i=zr,s=zn;for(;t!==zr;){const a=n/t,c=n%t,l=i-s*a;n=t,t=c,i=s,s=l}if(n!==zn)throw new Error("invert: does not exist");return yn(i,e)}function AM(r,e,t){if(!r.eql(r.sqr(e),t))throw new Error("Cannot find square root")}function PB(r,e){const t=(r.ORDER+zn)/AB,n=r.pow(e,t);return AM(r,n,e),n}function Ghe(r,e){const t=(r.ORDER-TB)/CB,n=r.mul(e,mc),i=r.pow(n,t),s=r.mul(e,i),o=r.mul(r.mul(s,mc),i),a=r.mul(s,r.sub(o,r.ONE));return AM(r,a,e),a}function Whe(r){const e=Q0(r),t=RB(r),n=t(e,e.neg(e.ONE)),i=t(e,n),s=t(e,e.neg(n)),o=(r+Vhe)/IB;return(a,c)=>{let l=a.pow(c,o),u=a.mul(l,n);const h=a.mul(l,i),d=a.mul(l,s),m=a.eql(a.sqr(u),c),p=a.eql(a.sqr(h),c);l=a.cmov(l,u,m),u=a.cmov(d,h,p);const b=a.eql(a.sqr(u),c),g=a.cmov(l,u,b);return AM(a,g,c),g}}function RB(r){if(r<MB)throw new Error("sqrt is not defined for small field");let e=r-zn,t=0;for(;e%mc===zr;)e/=mc,t++;let n=mc;const i=Q0(r);for(;RI(i,n)===1;)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return PB;let s=i.pow(n,e);const o=(e+zn)/mc;return function(c,l){if(c.is0(l))return l;if(RI(c,l)!==1)throw new Error("Cannot find square root");let u=t,h=c.mul(c.ONE,s),d=c.pow(l,e),m=c.pow(l,o);for(;!c.eql(d,c.ONE);){if(c.is0(d))return c.ZERO;let p=1,b=c.sqr(d);for(;!c.eql(b,c.ONE);)if(p++,b=c.sqr(b),p===u)throw new Error("Cannot find square root");const g=zn<<BigInt(u-p-1),y=c.pow(h,g);u=p,h=c.sqr(y),d=c.mul(d,h),m=c.mul(m,y)}return m}}function qhe(r){return r%AB===MB?PB:r%CB===TB?Ghe:r%IB===Hhe?Whe(r):RB(r)}const Khe=(r,e)=>(yn(r,e)&zn)===zn,Xhe=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Yhe(r){const e={ORDER:"bigint",BYTES:"number",BITS:"number"},t=Xhe.reduce((n,i)=>(n[i]="function",n),e);return gp(r,t),r}function Zhe(r,e,t){if(t<zr)throw new Error("invalid exponent, negatives unsupported");if(t===zr)return r.ONE;if(t===zn)return e;let n=r.ONE,i=e;for(;t>zr;)t&zn&&(n=r.mul(n,i)),i=r.sqr(i),t>>=zn;return n}function DB(r,e,t=!1){const n=new Array(e.length).fill(t?r.ZERO:void 0),i=e.reduce((o,a,c)=>r.is0(a)?o:(n[c]=o,r.mul(o,a)),r.ONE),s=r.inv(i);return e.reduceRight((o,a,c)=>r.is0(a)?o:(n[c]=r.mul(o,n[c]),r.mul(o,a)),s),n}function RI(r,e){const t=(r.ORDER-zn)/mc,n=r.pow(e,t),i=r.eql(n,r.ONE),s=r.eql(n,r.ZERO),o=r.eql(n,r.neg(r.ONE));if(!i&&!s&&!o)throw new Error("invalid Legendre symbol result");return i?1:s?0:-1}function Jhe(r,e){e!==void 0&&Hc(e);const t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}class jhe{constructor(e,t={}){f(this,"ORDER");f(this,"BITS");f(this,"BYTES");f(this,"isLE");f(this,"ZERO",zr);f(this,"ONE",zn);f(this,"_lengths");f(this,"_sqrt");f(this,"_mod");var o;if(e<=zr)throw new Error("invalid field: expected ORDER > 0, got "+e);let n;this.isLE=!1,t!=null&&typeof t=="object"&&(typeof t.BITS=="number"&&(n=t.BITS),typeof t.sqrt=="function"&&(this.sqrt=t.sqrt),typeof t.isLE=="boolean"&&(this.isLE=t.isLE),t.allowedLengths&&(this._lengths=(o=t.allowedLengths)==null?void 0:o.slice()),typeof t.modFromBytes=="boolean"&&(this._mod=t.modFromBytes));const{nBitLength:i,nByteLength:s}=Jhe(e,n);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=e,this.BITS=i,this.BYTES=s,this._sqrt=void 0,Object.preventExtensions(this)}create(e){return yn(e,this.ORDER)}isValid(e){if(typeof e!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof e);return zr<=e&&e<this.ORDER}is0(e){return e===zr}isValidNot0(e){return!this.is0(e)&&this.isValid(e)}isOdd(e){return(e&zn)===zn}neg(e){return yn(-e,this.ORDER)}eql(e,t){return e===t}sqr(e){return yn(e*e,this.ORDER)}add(e,t){return yn(e+t,this.ORDER)}sub(e,t){return yn(e-t,this.ORDER)}mul(e,t){return yn(e*t,this.ORDER)}pow(e,t){return Zhe(this,e,t)}div(e,t){return yn(e*PI(t,this.ORDER),this.ORDER)}sqrN(e){return e*e}addN(e,t){return e+t}subN(e,t){return e-t}mulN(e,t){return e*t}inv(e){return PI(e,this.ORDER)}sqrt(e){return this._sqrt||(this._sqrt=qhe(this.ORDER)),this._sqrt(this,e)}toBytes(e){return this.isLE?EB(e,this.BYTES):EM(e,this.BYTES)}fromBytes(e,t=!1){bt(e);const{_lengths:n,BYTES:i,isLE:s,ORDER:o,_mod:a}=this;if(n){if(!n.includes(e.length)||e.length>i)throw new Error("Field.fromBytes: expected "+n+" bytes, got "+e.length);const l=new Uint8Array(i);l.set(e,s?0:l.length-e.length),e=l}if(e.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+e.length);let c=s?Pf(e):j0(e);if(a&&(c=yn(c,o)),!t&&!this.isValid(c))throw new Error("invalid field element: outside of range 0..ORDER");return c}invertBatch(e){return DB(this,e)}cmov(e,t,n){return n?t:e}}function Q0(r,e={}){return new jhe(r,e)}function LB(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const e=r.toString(2).length;return Math.ceil(e/8)}function NB(r){const e=LB(r);return e+Math.ceil(e/2)}function Qhe(r,e,t=!1){bt(r);const n=r.length,i=LB(e),s=NB(e);if(n<16||n<s||n>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+n);const o=t?Pf(r):j0(r),a=yn(o,e-zn)+zn;return t?EB(a,i):EM(a,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const sh=BigInt(0),gc=BigInt(1);function Dy(r,e){const t=e.negate();return r?t:e}function Bd(r,e){const t=DB(r.Fp,e.map(n=>n.Z));return e.map((n,i)=>r.fromAffine(n.toAffine(t[i])))}function OB(r,e){if(!Number.isSafeInteger(r)||r<=0||r>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+r)}function zw(r,e){OB(r,e);const t=Math.ceil(e/r)+1,n=2**(r-1),i=2**r,s=MM(r),o=BigInt(r);return{windows:t,windowSize:n,mask:s,maxNumber:i,shiftBy:o}}function DI(r,e,t){const{windowSize:n,mask:i,maxNumber:s,shiftBy:o}=t;let a=Number(r&i),c=r>>o;a>n&&(a-=s,c+=gc);const l=e*n,u=l+Math.abs(a)-1,h=a===0,d=a<0,m=e%2!==0;return{nextN:c,offset:u,isZero:h,isNeg:d,isNegF:m,offsetF:l}}const Vw=new WeakMap,UB=new WeakMap;function Hw(r){return UB.get(r)||1}function LI(r){if(r!==sh)throw new Error("invalid wNAF")}class kB{constructor(e,t){f(this,"BASE");f(this,"ZERO");f(this,"Fn");f(this,"bits");this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=t}_unsafeLadder(e,t,n=this.ZERO){let i=e;for(;t>sh;)t&gc&&(n=n.add(i)),i=i.double(),t>>=gc;return n}precomputeWindow(e,t){const{windows:n,windowSize:i}=zw(t,this.bits),s=[];let o=e,a=o;for(let c=0;c<n;c++){a=o,s.push(a);for(let l=1;l<i;l++)a=a.add(o),s.push(a);o=a.double()}return s}wNAF(e,t,n){if(!this.Fn.isValid(n))throw new Error("invalid scalar");let i=this.ZERO,s=this.BASE;const o=zw(e,this.bits);for(let a=0;a<o.windows;a++){const{nextN:c,offset:l,isZero:u,isNeg:h,isNegF:d,offsetF:m}=DI(n,a,o);n=c,u?s=s.add(Dy(d,t[m])):i=i.add(Dy(h,t[l]))}return LI(n),{p:i,f:s}}wNAFUnsafe(e,t,n,i=this.ZERO){const s=zw(e,this.bits);for(let o=0;o<s.windows&&n!==sh;o++){const{nextN:a,offset:c,isZero:l,isNeg:u}=DI(n,o,s);if(n=a,!l){const h=t[c];i=i.add(u?h.negate():h)}}return LI(n),i}getPrecomputes(e,t,n){let i=Vw.get(t);return i||(i=this.precomputeWindow(t,e),e!==1&&(typeof n=="function"&&(i=n(i)),Vw.set(t,i))),i}cached(e,t,n){const i=Hw(e);return this.wNAF(i,this.getPrecomputes(i,e,n),t)}unsafe(e,t,n,i){const s=Hw(e);return s===1?this._unsafeLadder(e,t,i):this.wNAFUnsafe(s,this.getPrecomputes(s,e,n),t,i)}createCache(e,t){OB(t,this.bits),UB.set(e,t),Vw.delete(e)}hasCache(e){return Hw(e)!==1}}function ede(r,e,t,n){let i=e,s=r.ZERO,o=r.ZERO;for(;t>sh||n>sh;)t&gc&&(s=s.add(i)),n&gc&&(o=o.add(i)),i=i.double(),t>>=gc,n>>=gc;return{p1:s,p2:o}}function NI(r,e,t){if(e){if(e.ORDER!==r)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return Yhe(e),e}else return Q0(r,{isLE:t})}function BB(r,e,t={},n){if(n===void 0&&(n=r==="edwards"),!e||typeof e!="object")throw new Error(`expected valid ${r} CURVE object`);for(const c of["p","n","h"]){const l=e[c];if(!(typeof l=="bigint"&&l>sh))throw new Error(`CURVE.${c} must be positive bigint`)}const i=NI(e.p,t.Fp,n),s=NI(e.n,t.Fn,n),a=["Gx","Gy","a",r==="weierstrass"?"b":"d"];for(const c of a)if(!i.isValid(e[c]))throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);return e=Object.freeze(Object.assign({},e)),{CURVE:e,Fp:i,Fn:s}}function FB(r,e){return function(n){const i=r(n);return{secretKey:i,publicKey:e(i)}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ea=BigInt(0),Tn=BigInt(1),Gw=BigInt(2),tde=BigInt(8);function nde(r,e,t,n){const i=r.sqr(t),s=r.sqr(n),o=r.add(r.mul(e.a,i),s),a=r.add(r.ONE,r.mul(e.d,r.mul(i,s)));return r.eql(o,a)}function rde(r,e={}){const t=BB("edwards",r,e,e.FpFnLE),{Fp:n,Fn:i}=t;let s=t.CURVE;const{h:o}=s;gp(e,{},{uvRatio:"function"});const a=Gw<<BigInt(i.BYTES*8)-Tn,c=y=>n.create(y),l=e.uvRatio||((y,v)=>{try{return{isValid:!0,value:n.sqrt(n.div(y,v))}}catch{return{isValid:!1,value:ea}}});if(!nde(n,s,s.Gx,s.Gy))throw new Error("bad curve params: generator point");function u(y,v,w=!1){const _=w?Tn:ea;return qS("coordinate "+y,v,_,a),v}function h(y){if(!(y instanceof p))throw new Error("EdwardsPoint expected")}const d=Ry((y,v)=>{const{X:w,Y:_,Z:M}=y,E=y.is0();v==null&&(v=E?tde:n.inv(M));const C=c(w*v),I=c(_*v),x=n.mul(M,v);if(E)return{x:ea,y:Tn};if(x!==Tn)throw new Error("invZ was invalid");return{x:C,y:I}}),m=Ry(y=>{const{a:v,d:w}=s;if(y.is0())throw new Error("bad point: ZERO");const{X:_,Y:M,Z:E,T:C}=y,I=c(_*_),x=c(M*M),T=c(E*E),F=c(T*T),$=c(I*v),H=c(T*c($+x)),S=c(F+c(w*c(I*x)));if(H!==S)throw new Error("bad point: equation left != right (1)");const A=c(_*M),P=c(E*C);if(A!==P)throw new Error("bad point: equation left != right (2)");return!0}),g=class g{constructor(v,w,_,M){f(this,"X");f(this,"Y");f(this,"Z");f(this,"T");this.X=u("x",v),this.Y=u("y",w),this.Z=u("z",_,!0),this.T=u("t",M),Object.freeze(this)}static CURVE(){return s}static fromAffine(v){if(v instanceof g)throw new Error("extended point not allowed");const{x:w,y:_}=v||{};return u("x",w),u("y",_),new g(w,_,Tn,c(w*_))}static fromBytes(v,w=!1){const _=n.BYTES,{a:M,d:E}=s;v=WS(bt(v,_,"point")),Gc(w,"zip215");const C=WS(v),I=v[_-1];C[_-1]=I&-129;const x=Pf(C),T=w?a:n.ORDER;qS("point.y",x,ea,T);const F=c(x*x),$=c(F-Tn),H=c(E*F-M);let{isValid:S,value:A}=l($,H);if(!S)throw new Error("bad point: invalid y coordinate");const P=(A&Tn)===Tn,L=(I&128)!==0;if(!w&&A===ea&&L)throw new Error("bad point: x=0 and x_0=1");return L!==P&&(A=c(-A)),g.fromAffine({x:A,y:x})}static fromHex(v,w=!1){return g.fromBytes(If(v),w)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(v=8,w=!0){return b.createCache(this,v),w||this.multiply(Gw),this}assertValidity(){m(this)}equals(v){h(v);const{X:w,Y:_,Z:M}=this,{X:E,Y:C,Z:I}=v,x=c(w*I),T=c(E*M),F=c(_*I),$=c(C*M);return x===T&&F===$}is0(){return this.equals(g.ZERO)}negate(){return new g(c(-this.X),this.Y,this.Z,c(-this.T))}double(){const{a:v}=s,{X:w,Y:_,Z:M}=this,E=c(w*w),C=c(_*_),I=c(Gw*c(M*M)),x=c(v*E),T=w+_,F=c(c(T*T)-E-C),$=x+C,H=$-I,S=x-C,A=c(F*H),P=c($*S),L=c(F*S),B=c(H*$);return new g(A,P,B,L)}add(v){h(v);const{a:w,d:_}=s,{X:M,Y:E,Z:C,T:I}=this,{X:x,Y:T,Z:F,T:$}=v,H=c(M*x),S=c(E*T),A=c(I*_*$),P=c(C*F),L=c((M+E)*(x+T)-H-S),B=P-A,D=P+A,V=c(S-w*H),z=c(L*B),q=c(D*V),G=c(L*V),Y=c(B*D);return new g(z,q,Y,G)}subtract(v){return this.add(v.negate())}multiply(v){if(!i.isValidNot0(v))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:w,f:_}=b.cached(this,v,M=>Bd(g,M));return Bd(g,[w,_])[0]}multiplyUnsafe(v,w=g.ZERO){if(!i.isValid(v))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return v===ea?g.ZERO:this.is0()||v===Tn?this:b.unsafe(this,v,_=>Bd(g,_),w)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}isTorsionFree(){return b.unsafe(this,s.n).is0()}toAffine(v){return d(this,v)}clearCofactor(){return o===Tn?this:this.multiplyUnsafe(o)}toBytes(){const{x:v,y:w}=this.toAffine(),_=n.toBytes(w);return _[_.length-1]|=v&Tn?128:0,_}toHex(){return mp(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}};f(g,"BASE",new g(s.Gx,s.Gy,Tn,c(s.Gx*s.Gy))),f(g,"ZERO",new g(ea,Tn,Tn,ea)),f(g,"Fp",n),f(g,"Fn",i);let p=g;const b=new kB(p,i.BITS);return p.BASE.precompute(8),p}function ide(r,e,t={}){if(typeof e!="function")throw new Error('"hash" function param is required');gp(t,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:n}=t,{BASE:i,Fp:s,Fn:o}=r,a=t.randomBytes||J0,c=t.adjustScalarBytes||(I=>I),l=t.domain||((I,x,T)=>{if(Gc(T,"phflag"),x.length||T)throw new Error("Contexts/pre-hash are not supported");return I});function u(I){return o.create(Pf(I))}function h(I){const x=w.secretKey;bt(I,w.secretKey,"secretKey");const T=bt(e(I),2*x,"hashedSecretKey"),F=c(T.slice(0,x)),$=T.slice(x,2*x),H=u(F);return{head:F,prefix:$,scalar:H}}function d(I){const{head:x,prefix:T,scalar:F}=h(I),$=i.multiply(F),H=$.toBytes();return{head:x,prefix:T,scalar:F,point:$,pointBytes:H}}function m(I){return d(I).pointBytes}function p(I=Uint8Array.of(),...x){const T=xs(...x);return u(e(l(T,bt(I,void 0,"context"),!!n)))}function b(I,x,T={}){I=bt(I,void 0,"message"),n&&(I=n(I));const{prefix:F,scalar:$,pointBytes:H}=d(x),S=p(T.context,F,I),A=i.multiply(S).toBytes(),P=p(T.context,A,H,I),L=o.create(S+P*$);if(!o.isValid(L))throw new Error("sign failed: invalid s");const B=xs(A,o.toBytes(L));return bt(B,w.signature,"result")}const g={zip215:!0};function y(I,x,T,F=g){const{context:$,zip215:H}=F,S=w.signature;I=bt(I,S,"signature"),x=bt(x,void 0,"message"),T=bt(T,w.publicKey,"publicKey"),H!==void 0&&Gc(H,"zip215"),n&&(x=n(x));const A=S/2,P=I.subarray(0,A),L=Pf(I.subarray(A,S));let B,D,V;try{B=r.fromBytes(T,H),D=r.fromBytes(P,H),V=i.multiplyUnsafe(L)}catch{return!1}if(!H&&B.isSmallOrder())return!1;const z=p($,D.toBytes(),B.toBytes(),x);return D.add(B.multiplyUnsafe(z)).subtract(V).clearCofactor().is0()}const v=s.BYTES,w={secretKey:v,publicKey:v,signature:2*v,seed:v};function _(I=a(w.seed)){return bt(I,w.seed,"seed")}function M(I){return Z0(I)&&I.length===o.BYTES}function E(I,x){try{return!!r.fromBytes(I,x)}catch{return!1}}const C={getExtendedPublicKey:d,randomSecretKey:_,isValidSecretKey:M,isValidPublicKey:E,toMontgomery(I){const{y:x}=r.fromBytes(I),T=w.publicKey,F=T===32;if(!F&&T!==57)throw new Error("only defined for 25519 and 448");const $=F?s.div(Tn+x,Tn-x):s.div(x-Tn,x+Tn);return s.toBytes($)},toMontgomerySecret(I){const x=w.secretKey;bt(I,x);const T=e(I.subarray(0,x));return c(T).subarray(0,x)}};return Object.freeze({keygen:FB(_,m),getPublicKey:m,sign:b,verify:y,utils:C,Point:r,lengths:w})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const sde=BigInt(1),OI=BigInt(2),ode=BigInt(5),ade=BigInt(8),TM=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),cde={p:TM,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:ade,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function lde(r){const e=BigInt(10),t=BigInt(20),n=BigInt(40),i=BigInt(80),s=TM,a=r*r%s*r%s,c=tn(a,OI,s)*a%s,l=tn(c,sde,s)*r%s,u=tn(l,ode,s)*l%s,h=tn(u,e,s)*u%s,d=tn(h,t,s)*h%s,m=tn(d,n,s)*d%s,p=tn(m,i,s)*m%s,b=tn(p,i,s)*m%s,g=tn(b,e,s)*u%s;return{pow_p_5_8:tn(g,OI,s)*r%s,b2:a}}function ude(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}const UI=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function hde(r,e){const t=TM,n=yn(e*e*e,t),i=yn(n*n*e,t),s=lde(r*i).pow_p_5_8;let o=yn(r*n*s,t);const a=yn(e*o*o,t),c=o,l=yn(o*UI,t),u=a===r,h=a===yn(-r,t),d=a===yn(-r*UI,t);return u&&(o=c),(h||d)&&(o=l),Khe(o,t)&&(o=yn(-o,t)),{isValid:u||h,value:o}}const dde=rde(cde,{uvRatio:hde});function fde(r){return ide(dde,Bhe,Object.assign({adjustScalarBytes:ude},r))}const pde=fde({});class kI extends Error{constructor(e="An error occurred while verifying a message"){super(e),this.name="VerificationError"}}class mde extends Error{constructor(e="Missing Web Crypto API"){super(e),this.name="WebCryptoMissingError"}}const Rf={get(r=globalThis){const e=r.crypto;if((e==null?void 0:e.subtle)==null)throw new mde("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return e}},$B=32;let Ww;const gde=(async()=>{try{return await Rf.get().subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),!0}catch{return!1}})();async function yde(r,e,t){if(r.buffer instanceof ArrayBuffer){const n=await Rf.get().subtle.importKey("raw",r.buffer,{name:"Ed25519"},!1,["verify"]);return await Rf.get().subtle.verify({name:"Ed25519"},n,e,t instanceof Uint8Array?t:t.subarray())}throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys")}function bde(r,e,t){return pde.verify(e,t instanceof Uint8Array?t:t.subarray(),r)}async function wde(r,e,t){return Ww==null&&(Ww=await gde),Ww?yde(r,e,t):bde(r,e,t)}function zB(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}class vde{constructor(e){f(this,"type","Ed25519");f(this,"raw");this.raw=HB(e,$B)}toMultihash(){return fp.digest(yp(this))}toCID(){return en.createV1(114,this.toMultihash())}toString(){return Ir.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Vc(this.raw,e.raw)}verify(e,t,n){var s;(s=n==null?void 0:n.signal)==null||s.throwIfAborted();const i=wde(this.raw,t,e);return zB(i)?i.then(o=>{var a;return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),o}):i}}function VB(r){return r=HB(r,$B),new vde(r)}function HB(r,e){if(r=Uint8Array.from(r??[]),r.length!==e)throw new jc(`Key must be a Uint8Array of length ${e}, got ${r.length}`);return r}const _de=Math.pow(2,7),xde=Math.pow(2,14),Sde=Math.pow(2,21),CM=Math.pow(2,28),IM=Math.pow(2,35),PM=Math.pow(2,42),RM=Math.pow(2,49),Mt=128,dr=127;function Ah(r){if(r<_de)return 1;if(r<xde)return 2;if(r<Sde)return 3;if(r<CM)return 4;if(r<IM)return 5;if(r<PM)return 6;if(r<RM)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function GB(r,e,t=0){switch(Ah(r)){case 8:e[t++]=r&255|Mt,r/=128;case 7:e[t++]=r&255|Mt,r/=128;case 6:e[t++]=r&255|Mt,r/=128;case 5:e[t++]=r&255|Mt,r/=128;case 4:e[t++]=r&255|Mt,r>>>=7;case 3:e[t++]=r&255|Mt,r>>>=7;case 2:e[t++]=r&255|Mt,r>>>=7;case 1:{e[t++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return e}function Ede(r,e,t=0){switch(Ah(r)){case 8:e.set(t++,r&255|Mt),r/=128;case 7:e.set(t++,r&255|Mt),r/=128;case 6:e.set(t++,r&255|Mt),r/=128;case 5:e.set(t++,r&255|Mt),r/=128;case 4:e.set(t++,r&255|Mt),r>>>=7;case 3:e.set(t++,r&255|Mt),r>>>=7;case 2:e.set(t++,r&255|Mt),r>>>=7;case 1:{e.set(t++,r&255),r>>>=7;break}default:throw new Error("unreachable")}return e}function WB(r,e){let t=r[e],n=0;if(n+=t&dr,t<Mt||(t=r[e+1],n+=(t&dr)<<7,t<Mt)||(t=r[e+2],n+=(t&dr)<<14,t<Mt)||(t=r[e+3],n+=(t&dr)<<21,t<Mt)||(t=r[e+4],n+=(t&dr)*CM,t<Mt)||(t=r[e+5],n+=(t&dr)*IM,t<Mt)||(t=r[e+6],n+=(t&dr)*PM,t<Mt)||(t=r[e+7],n+=(t&dr)*RM,t<Mt))return n;throw new RangeError("Could not decode varint")}function Mde(r,e){let t=r.get(e),n=0;if(n+=t&dr,t<Mt||(t=r.get(e+1),n+=(t&dr)<<7,t<Mt)||(t=r.get(e+2),n+=(t&dr)<<14,t<Mt)||(t=r.get(e+3),n+=(t&dr)<<21,t<Mt)||(t=r.get(e+4),n+=(t&dr)*CM,t<Mt)||(t=r.get(e+5),n+=(t&dr)*IM,t<Mt)||(t=r.get(e+6),n+=(t&dr)*PM,t<Mt)||(t=r.get(e+7),n+=(t&dr)*RM,t<Mt))return n;throw new RangeError("Could not decode varint")}function Ade(r,e,t=0){return e==null&&(e=Ta(Ah(r))),e instanceof Uint8Array?GB(r,e,t):Ede(r,e,t)}function Tde(r,e=0){return r instanceof Uint8Array?WB(r,e):Mde(r,e)}const DM=new Float32Array([-0]),pa=new Uint8Array(DM.buffer);function Cde(r,e,t){DM[0]=r,e[t]=pa[0],e[t+1]=pa[1],e[t+2]=pa[2],e[t+3]=pa[3]}function Ide(r,e){return pa[0]=r[e],pa[1]=r[e+1],pa[2]=r[e+2],pa[3]=r[e+3],DM[0]}const LM=new Float64Array([-0]),fr=new Uint8Array(LM.buffer);function Pde(r,e,t){LM[0]=r,e[t]=fr[0],e[t+1]=fr[1],e[t+2]=fr[2],e[t+3]=fr[3],e[t+4]=fr[4],e[t+5]=fr[5],e[t+6]=fr[6],e[t+7]=fr[7]}function Rde(r,e){return fr[0]=r[e],fr[1]=r[e+1],fr[2]=r[e+2],fr[3]=r[e+3],fr[4]=r[e+4],fr[5]=r[e+5],fr[6]=r[e+6],fr[7]=r[e+7],LM[0]}const Dde=BigInt(Number.MAX_SAFE_INTEGER),Lde=BigInt(Number.MIN_SAFE_INTEGER);class mr{constructor(e,t){f(this,"lo");f(this,"hi");this.lo=e|0,this.hi=t|0}toNumber(e=!1){if(!e&&this.hi>>>31>0){const t=~this.lo+1>>>0;let n=~this.hi>>>0;return t===0&&(n=n+1>>>0),-(t+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(e=!1){if(e)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const t=~this.lo+1>>>0;let n=~this.hi>>>0;return t===0&&(n=n+1>>>0),-(BigInt(t)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(e=!1){return this.toBigInt(e).toString()}zzEncode(){const e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this}zzDecode(){const e=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this}length(){const e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?t===0?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:n<128?9:10}static fromBigInt(e){if(e===0n)return Tc;if(e<Dde&&e>Lde)return this.fromNumber(Number(e));const t=e<0n;t&&(e=-e);let n=e>>32n,i=e-(n<<32n);return t&&(n=~n|0n,i=~i|0n,++i>BI&&(i=0n,++n>BI&&(n=0n))),new mr(Number(i),Number(n))}static fromNumber(e){if(e===0)return Tc;const t=e<0;t&&(e=-e);let n=e>>>0,i=(e-n)/4294967296>>>0;return t&&(i=~i>>>0,n=~n>>>0,++n>4294967295&&(n=0,++i>4294967295&&(i=0))),new mr(n,i)}static from(e){return typeof e=="number"?mr.fromNumber(e):typeof e=="bigint"?mr.fromBigInt(e):typeof e=="string"?mr.fromBigInt(BigInt(e)):e.low!=null||e.high!=null?new mr(e.low>>>0,e.high>>>0):Tc}}const Tc=new mr(0,0);Tc.toBigInt=function(){return 0n};Tc.zzEncode=Tc.zzDecode=function(){return this};Tc.length=function(){return 1};const BI=4294967296n;function Nde(r){let e=0,t=0;for(let n=0;n<r.length;++n)t=r.charCodeAt(n),t<128?e+=1:t<2048?e+=2:(t&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,e+=4):e+=3;return e}function Ode(r,e,t){if(t-e<1)return"";let i;const s=[];let o=0,a;for(;e<t;)a=r[e++],a<128?s[o++]=a:a>191&&a<224?s[o++]=(a&31)<<6|r[e++]&63:a>239&&a<365?(a=((a&7)<<18|(r[e++]&63)<<12|(r[e++]&63)<<6|r[e++]&63)-65536,s[o++]=55296+(a>>10),s[o++]=56320+(a&1023)):s[o++]=(a&15)<<12|(r[e++]&63)<<6|r[e++]&63,o>8191&&((i??(i=[])).push(String.fromCharCode.apply(String,s)),o=0);return i!=null?(o>0&&i.push(String.fromCharCode.apply(String,s.slice(0,o))),i.join("")):String.fromCharCode.apply(String,s.slice(0,o))}function qB(r,e,t){const n=t;let i,s;for(let o=0;o<r.length;++o)i=r.charCodeAt(o),i<128?e[t++]=i:i<2048?(e[t++]=i>>6|192,e[t++]=i&63|128):(i&64512)===55296&&((s=r.charCodeAt(o+1))&64512)===56320?(i=65536+((i&1023)<<10)+(s&1023),++o,e[t++]=i>>18|240,e[t++]=i>>12&63|128,e[t++]=i>>6&63|128,e[t++]=i&63|128):(e[t++]=i>>12|224,e[t++]=i>>6&63|128,e[t++]=i&63|128);return t-n}function Li(r,e){return RangeError(`index out of range: ${r.pos} + ${e??1} > ${r.len}`)}function Zm(r,e){return(r[e-4]|r[e-3]<<8|r[e-2]<<16|r[e-1]<<24)>>>0}class Ude{constructor(e){f(this,"buf");f(this,"pos");f(this,"len");f(this,"_slice",Uint8Array.prototype.subarray);this.buf=e,this.pos=0,this.len=e.length}uint32(){let e=4294967295;if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,Li(this,10);return e}int32(){return this.uint32()|0}sint32(){const e=this.uint32();return e>>>1^-(e&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw Li(this,4);return Zm(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw Li(this,4);return Zm(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw Li(this,4);const e=Ide(this.buf,this.pos);return this.pos+=4,e}double(){if(this.pos+8>this.len)throw Li(this,4);const e=Rde(this.buf,this.pos);return this.pos+=8,e}bytes(){const e=this.uint32(),t=this.pos,n=this.pos+e;if(n>this.len)throw Li(this,e);return this.pos+=e,t===n?new Uint8Array(0):this.buf.subarray(t,n)}string(){const e=this.bytes();return Ode(e,0,e.length)}skip(e){if(typeof e=="number"){if(this.pos+e>this.len)throw Li(this,e);this.pos+=e}else do if(this.pos>=this.len)throw Li(this);while((this.buf[this.pos++]&128)!==0);return this}skipType(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(e=this.uint32()&7)!==4;)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${e} at offset ${this.pos}`)}return this}readLongVarint(){const e=new mr(0,0);let t=0;if(this.len-this.pos>4){for(;t<4;++t)if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(this.buf[this.pos]&127)<<28)>>>0,e.hi=(e.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return e;t=0}else{for(;t<3;++t){if(this.pos>=this.len)throw Li(this);if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(this.buf[this.pos++]&127)<<t*7)>>>0,e}if(this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw Li(this);if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw Li(this,8);const e=Zm(this.buf,this.pos+=4),t=Zm(this.buf,this.pos+=4);return new mr(e,t)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const e=WB(this.buf,this.pos);return this.pos+=Ah(e),e}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function kde(r){return new Ude(r instanceof Uint8Array?r:r.subarray())}function Ji(r,e,t){const n=kde(r);return e.decode(n,void 0,t)}function Bde(r){let n,i=8192;return function(o){if(o<1||o>4096)return Ta(o);i+o>8192&&(n=Ta(8192),i=0);const a=n.subarray(i,i+=o);return(i&7)!==0&&(i=(i|7)+1),a}}class yd{constructor(e,t,n){f(this,"fn");f(this,"len");f(this,"next");f(this,"val");this.fn=e,this.len=t,this.next=void 0,this.val=n}}function qw(){}class Fde{constructor(e){f(this,"head");f(this,"tail");f(this,"len");f(this,"next");this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}}const $de=Bde();function zde(r){return globalThis.Buffer!=null?Ta(r):$de(r)}class KS{constructor(){f(this,"len");f(this,"head");f(this,"tail");f(this,"states");this.len=0,this.head=new yd(qw,0,0),this.tail=this.head,this.states=null}_push(e,t,n){return this.tail=this.tail.next=new yd(e,t,n),this.len+=t,this}uint32(e){return this.len+=(this.tail=this.tail.next=new Hde((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this}int32(e){return e<0?this._push(Jm,10,mr.fromNumber(e)):this.uint32(e)}sint32(e){return this.uint32((e<<1^e>>31)>>>0)}uint64(e){const t=mr.fromBigInt(e);return this._push(Jm,t.length(),t)}uint64Number(e){return this._push(GB,Ah(e),e)}uint64String(e){return this.uint64(BigInt(e))}int64(e){return this.uint64(e)}int64Number(e){return this.uint64Number(e)}int64String(e){return this.uint64String(e)}sint64(e){const t=mr.fromBigInt(e).zzEncode();return this._push(Jm,t.length(),t)}sint64Number(e){const t=mr.fromNumber(e).zzEncode();return this._push(Jm,t.length(),t)}sint64String(e){return this.sint64(BigInt(e))}bool(e){return this._push(Kw,1,e?1:0)}fixed32(e){return this._push(td,4,e>>>0)}sfixed32(e){return this.fixed32(e)}fixed64(e){const t=mr.fromBigInt(e);return this._push(td,4,t.lo)._push(td,4,t.hi)}fixed64Number(e){const t=mr.fromNumber(e);return this._push(td,4,t.lo)._push(td,4,t.hi)}fixed64String(e){return this.fixed64(BigInt(e))}sfixed64(e){return this.fixed64(e)}sfixed64Number(e){return this.fixed64Number(e)}sfixed64String(e){return this.fixed64String(e)}float(e){return this._push(Cde,4,e)}double(e){return this._push(Pde,8,e)}bytes(e){const t=e.length>>>0;return t===0?this._push(Kw,1,0):this.uint32(t)._push(Gde,t,e)}string(e){const t=Nde(e);return t!==0?this.uint32(t)._push(qB,t,e):this._push(Kw,1,0)}fork(){return this.states=new Fde(this),this.head=this.tail=new yd(qw,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new yd(qw,0,0),this.len=0),this}ldelim(){const e=this.head,t=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=e.next,this.tail=t,this.len+=n),this}finish(){let e=this.head.next;const t=zde(this.len);let n=0;for(;e!=null;)e.fn(e.val,t,n),n+=e.len,e=e.next;return t}}function Kw(r,e,t){e[t]=r&255}function Vde(r,e,t){for(;r>127;)e[t++]=r&127|128,r>>>=7;e[t]=r}class Hde extends yd{constructor(t,n){super(Vde,t,n);f(this,"next");this.next=void 0}}function Jm(r,e,t){for(;r.hi!==0;)e[t++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)e[t++]=r.lo&127|128,r.lo=r.lo>>>7;e[t++]=r.lo}function td(r,e,t){e[t]=r&255,e[t+1]=r>>>8&255,e[t+2]=r>>>16&255,e[t+3]=r>>>24}function Gde(r,e,t){e.set(r,t)}globalThis.Buffer!=null&&(KS.prototype.bytes=function(r){const e=r.length>>>0;return this.uint32(e),e>0&&this._push(Wde,e,r),this},KS.prototype.string=function(r){const e=globalThis.Buffer.byteLength(r);return this.uint32(e),e>0&&this._push(qde,e,r),this});function Wde(r,e,t){e.set(r,t)}function qde(r,e,t){r.length<40?qB(r,e,t):e.utf8Write!=null?e.utf8Write(r,t):e.set(Ro(r),t)}function Kde(){return new KS}function ji(r,e){const t=Kde();return e.encode(r,t,{lengthDelimited:!1}),t.finish()}var Ly;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})(Ly||(Ly={}));function KB(r,e,t,n){return{name:r,type:e,encode:t,decode:n}}function Xde(r){function e(i){if(r[i.toString()]==null)throw new Error("Invalid enum value");return r[i]}const t=function(s,o){const a=e(s);o.int32(a)},n=function(s){const o=s.int32();return e(o)};return KB("enum",Ly.VARINT,t,n)}function Qi(r,e){return KB("message",Ly.LENGTH_DELIMITED,r,e)}class ao extends Error{constructor(){super(...arguments);f(this,"code","ERR_MAX_LENGTH");f(this,"name","MaxLengthError")}}var kn;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1",r.ECDSA="ECDSA"})(kn||(kn={}));var XS;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1",r[r.ECDSA=3]="ECDSA"})(XS||(XS={}));(function(r){r.codec=()=>Xde(XS)})(kn||(kn={}));var oh;(function(r){let e;r.codec=()=>(e==null&&(e=Qi((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.Type!=null&&(n.uint32(8),kn.codec().encode(t.Type,n)),t.Data!=null&&(n.uint32(18),n.bytes(t.Data)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.Type=kn.codec().decode(t);break}case 2:{s.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>ji(t,r.codec()),r.decode=(t,n)=>Ji(t,r.codec(),n)})(oh||(oh={}));var FI;(function(r){let e;r.codec=()=>(e==null&&(e=Qi((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.Type!=null&&(n.uint32(8),kn.codec().encode(t.Type,n)),t.Data!=null&&(n.uint32(18),n.bytes(t.Data)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.Type=kn.codec().decode(t);break}case 2:{s.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>ji(t,r.codec()),r.decode=(t,n)=>Ji(t,r.codec(),n)})(FI||(FI={}));function Yde(r){if(isNaN(r)||r<=0)throw new jc("random bytes length must be a Number bigger than 0");return J0(r)}class Zde{constructor(e,t){f(this,"type","RSA");f(this,"jwk");f(this,"_raw");f(this,"_multihash");this.jwk=e,this._multihash=t}get raw(){return this._raw==null&&(this._raw=tfe(this.jwk)),this._raw}toMultihash(){return this._multihash}toCID(){return en.createV1(114,this._multihash)}toString(){return Ir.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Vc(this.raw,e.raw)}verify(e,t,n){return ife(this.jwk,t,e,n)}}const Jde=18,jde=1062,Qde=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function efe(r){const e=Y0(r[1],{offset:0});return{kty:"RSA",n:ei(e[0],"base64url"),e:ei(e[1],"base64url")}}function tfe(r){if(r.n==null||r.e==null)throw new jc("JWK was missing components");return kd([Qde,fB(kd([HS(Ro(r.n,"base64url")),HS(Ro(r.e,"base64url"))]))]).subarray()}function nfe(r,e){if(r.byteLength>=jde)throw new bM("Key size is too large");const t=Y0(r,{offset:0});return rfe(t,r,e)}function rfe(r,e,t){const n=efe(r);if(t==null){const i=_B(oh.encode({Type:kn.RSA,Data:e}));t=K0(Jde,i)}return new Zde(n,t)}async function ife(r,e,t,n){var o,a;const i=await Rf.get().subtle.importKey("jwk",r,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);(o=n==null?void 0:n.signal)==null||o.throwIfAborted();const s=await Rf.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},i,e,t instanceof Uint8Array?t:t.subarray());return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),s}class XB{constructor(e,t){f(this,"oHash");f(this,"iHash");f(this,"blockLen");f(this,"outputLen");f(this,"finished",!1);f(this,"destroyed",!1);if(mB(e),bt(t,void 0,"key"),this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,i=new Uint8Array(n);i.set(t.length>n?e.create().update(t).digest():t);for(let s=0;s<i.length;s++)i[s]^=54;this.iHash.update(i),this.oHash=e.create();for(let s=0;s<i.length;s++)i[s]^=106;this.oHash.update(i),ih(i)}update(e){return Py(this),this.iHash.update(e),this}digestInto(e){Py(this),bt(e,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:i,destroyed:s,blockLen:o,outputLen:a}=this;return e=e,e.finished=i,e.destroyed=s,e.blockLen=o,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const YB=(r,e,t)=>new XB(r,e).update(t).digest();YB.create=(r,e)=>new XB(r,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const $I=(r,e)=>(r+(r>=0?e:-e)/ZB)/e;function sfe(r,e,t){const[[n,i],[s,o]]=e,a=$I(o*r,t),c=$I(-i*r,t);let l=r-a*n-c*s,u=-a*i-c*o;const h=l<co,d=u<co;h&&(l=-l),d&&(u=-u);const m=MM(Math.ceil($he(t)/2))+tu;if(l<co||l>=m||u<co||u>=m)throw new Error("splitScalar (endomorphism): failed, k="+r);return{k1neg:h,k1:l,k2neg:d,k2:u}}function YS(r){if(!["compact","recovered","der"].includes(r))throw new Error('Signature format must be "compact", "recovered", or "der"');return r}function Xw(r,e){const t={};for(let n of Object.keys(e))t[n]=r[n]===void 0?e[n]:r[n];return Gc(t.lowS,"lowS"),Gc(t.prehash,"prehash"),t.format!==void 0&&YS(t.format),t}class ofe extends Error{constructor(e=""){super(e)}}const ia={Err:ofe,_tlv:{encode:(r,e)=>{const{Err:t}=ia;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const n=e.length/2,i=Ym(n);if(i.length/2&128)throw new t("tlv.encode: long form length too big");const s=n>127?Ym(i.length/2|128):"";return Ym(r)+s+i+e},decode(r,e){const{Err:t}=ia;let n=0;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[n++]!==r)throw new t("tlv.decode: wrong tlv");const i=e[n++],s=!!(i&128);let o=0;if(!s)o=i;else{const c=i&127;if(!c)throw new t("tlv.decode(long): indefinite length not supported");if(c>4)throw new t("tlv.decode(long): byte length is too big");const l=e.subarray(n,n+c);if(l.length!==c)throw new t("tlv.decode: length bytes not complete");if(l[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const u of l)o=o<<8|u;if(n+=c,o<128)throw new t("tlv.decode(long): not minimal encoding")}const a=e.subarray(n,n+o);if(a.length!==o)throw new t("tlv.decode: wrong value length");return{v:a,l:e.subarray(n+o)}}},_int:{encode(r){const{Err:e}=ia;if(r<co)throw new e("integer: negative integers are not allowed");let t=Ym(r);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(r){const{Err:e}=ia;if(r[0]&128)throw new e("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return j0(r)}},toSig(r){const{Err:e,_int:t,_tlv:n}=ia,i=bt(r,void 0,"signature"),{v:s,l:o}=n.decode(48,i);if(o.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,s),{v:l,l:u}=n.decode(2,c);if(u.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(l)}},hexFromSig(r){const{_tlv:e,_int:t}=ia,n=e.encode(2,t.encode(r.r)),i=e.encode(2,t.encode(r.s)),s=n+i;return e.encode(48,s)}},co=BigInt(0),tu=BigInt(1),ZB=BigInt(2),jm=BigInt(3),afe=BigInt(4);function cfe(r,e={}){const t=BB("weierstrass",r,e),{Fp:n,Fn:i}=t;let s=t.CURVE;const{h:o,n:a}=s;gp(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});const{endo:c}=e;if(c&&(!n.is0(s.a)||typeof c.beta!="bigint"||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const l=jB(n,i);function u(){if(!n.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function h(H,S,A){const{x:P,y:L}=S.toAffine(),B=n.toBytes(P);if(Gc(A,"isCompressed"),A){u();const D=!n.isOdd(L);return xs(JB(D),B)}else return xs(Uint8Array.of(4),B,n.toBytes(L))}function d(H){bt(H,void 0,"Point");const{publicKey:S,publicKeyUncompressed:A}=l,P=H.length,L=H[0],B=H.subarray(1);if(P===S&&(L===2||L===3)){const D=n.fromBytes(B);if(!n.isValid(D))throw new Error("bad point: is not on curve, wrong x");const V=b(D);let z;try{z=n.sqrt(V)}catch(Y){const j=Y instanceof Error?": "+Y.message:"";throw new Error("bad point: is not on curve, sqrt error"+j)}u();const q=n.isOdd(z);return(L&1)===1!==q&&(z=n.neg(z)),{x:D,y:z}}else if(P===A&&L===4){const D=n.BYTES,V=n.fromBytes(B.subarray(0,D)),z=n.fromBytes(B.subarray(D,D*2));if(!g(V,z))throw new Error("bad point: is not on curve");return{x:V,y:z}}else throw new Error(`bad point: got length ${P}, expected compressed=${S} or uncompressed=${A}`)}const m=e.toBytes||h,p=e.fromBytes||d;function b(H){const S=n.sqr(H),A=n.mul(S,H);return n.add(n.add(A,n.mul(H,s.a)),s.b)}function g(H,S){const A=n.sqr(S),P=b(H);return n.eql(A,P)}if(!g(s.Gx,s.Gy))throw new Error("bad curve params: generator point");const y=n.mul(n.pow(s.a,jm),afe),v=n.mul(n.sqr(s.b),BigInt(27));if(n.is0(n.add(y,v)))throw new Error("bad curve params: a or b");function w(H,S,A=!1){if(!n.isValid(S)||A&&n.is0(S))throw new Error(`bad point coordinate ${H}`);return S}function _(H){if(!(H instanceof x))throw new Error("Weierstrass Point expected")}function M(H){if(!c||!c.basises)throw new Error("no endo");return sfe(H,c.basises,i.ORDER)}const E=Ry((H,S)=>{const{X:A,Y:P,Z:L}=H;if(n.eql(L,n.ONE))return{x:A,y:P};const B=H.is0();S==null&&(S=B?n.ONE:n.inv(L));const D=n.mul(A,S),V=n.mul(P,S),z=n.mul(L,S);if(B)return{x:n.ZERO,y:n.ZERO};if(!n.eql(z,n.ONE))throw new Error("invZ was invalid");return{x:D,y:V}}),C=Ry(H=>{if(H.is0()){if(e.allowInfinityPoint&&!n.is0(H.Y))return;throw new Error("bad point: ZERO")}const{x:S,y:A}=H.toAffine();if(!n.isValid(S)||!n.isValid(A))throw new Error("bad point: x or y not field elements");if(!g(S,A))throw new Error("bad point: equation left != right");if(!H.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function I(H,S,A,P,L){return A=new x(n.mul(A.X,H),A.Y,A.Z),S=Dy(P,S),A=Dy(L,A),S.add(A)}const $=class ${constructor(S,A,P){f(this,"X");f(this,"Y");f(this,"Z");this.X=w("x",S),this.Y=w("y",A,!0),this.Z=w("z",P),Object.freeze(this)}static CURVE(){return s}static fromAffine(S){const{x:A,y:P}=S||{};if(!S||!n.isValid(A)||!n.isValid(P))throw new Error("invalid affine point");if(S instanceof $)throw new Error("projective point not allowed");return n.is0(A)&&n.is0(P)?$.ZERO:new $(A,P,n.ONE)}static fromBytes(S){const A=$.fromAffine(p(bt(S,void 0,"point")));return A.assertValidity(),A}static fromHex(S){return $.fromBytes(If(S))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(S=8,A=!0){return F.createCache(this,S),A||this.multiply(jm),this}assertValidity(){C(this)}hasEvenY(){const{y:S}=this.toAffine();if(!n.isOdd)throw new Error("Field doesn't support isOdd");return!n.isOdd(S)}equals(S){_(S);const{X:A,Y:P,Z:L}=this,{X:B,Y:D,Z:V}=S,z=n.eql(n.mul(A,V),n.mul(B,L)),q=n.eql(n.mul(P,V),n.mul(D,L));return z&&q}negate(){return new $(this.X,n.neg(this.Y),this.Z)}double(){const{a:S,b:A}=s,P=n.mul(A,jm),{X:L,Y:B,Z:D}=this;let V=n.ZERO,z=n.ZERO,q=n.ZERO,G=n.mul(L,L),Y=n.mul(B,B),j=n.mul(D,D),X=n.mul(L,B);return X=n.add(X,X),q=n.mul(L,D),q=n.add(q,q),V=n.mul(S,q),z=n.mul(P,j),z=n.add(V,z),V=n.sub(Y,z),z=n.add(Y,z),z=n.mul(V,z),V=n.mul(X,V),q=n.mul(P,q),j=n.mul(S,j),X=n.sub(G,j),X=n.mul(S,X),X=n.add(X,q),q=n.add(G,G),G=n.add(q,G),G=n.add(G,j),G=n.mul(G,X),z=n.add(z,G),j=n.mul(B,D),j=n.add(j,j),G=n.mul(j,X),V=n.sub(V,G),q=n.mul(j,Y),q=n.add(q,q),q=n.add(q,q),new $(V,z,q)}add(S){_(S);const{X:A,Y:P,Z:L}=this,{X:B,Y:D,Z:V}=S;let z=n.ZERO,q=n.ZERO,G=n.ZERO;const Y=s.a,j=n.mul(s.b,jm);let X=n.mul(A,B),ne=n.mul(P,D),oe=n.mul(L,V),he=n.add(A,P),ce=n.add(B,D);he=n.mul(he,ce),ce=n.add(X,ne),he=n.sub(he,ce),ce=n.add(A,L);let fe=n.add(B,V);return ce=n.mul(ce,fe),fe=n.add(X,oe),ce=n.sub(ce,fe),fe=n.add(P,L),z=n.add(D,V),fe=n.mul(fe,z),z=n.add(ne,oe),fe=n.sub(fe,z),G=n.mul(Y,ce),z=n.mul(j,oe),G=n.add(z,G),z=n.sub(ne,G),G=n.add(ne,G),q=n.mul(z,G),ne=n.add(X,X),ne=n.add(ne,X),oe=n.mul(Y,oe),ce=n.mul(j,ce),ne=n.add(ne,oe),oe=n.sub(X,oe),oe=n.mul(Y,oe),ce=n.add(ce,oe),X=n.mul(ne,ce),q=n.add(q,X),X=n.mul(fe,ce),z=n.mul(he,z),z=n.sub(z,X),X=n.mul(he,ne),G=n.mul(fe,G),G=n.add(G,X),new $(z,q,G)}subtract(S){return this.add(S.negate())}is0(){return this.equals($.ZERO)}multiply(S){const{endo:A}=e;if(!i.isValidNot0(S))throw new Error("invalid scalar: out of range");let P,L;const B=D=>F.cached(this,D,V=>Bd($,V));if(A){const{k1neg:D,k1:V,k2neg:z,k2:q}=M(S),{p:G,f:Y}=B(V),{p:j,f:X}=B(q);L=Y.add(X),P=I(A.beta,G,j,D,z)}else{const{p:D,f:V}=B(S);P=D,L=V}return Bd($,[P,L])[0]}multiplyUnsafe(S){const{endo:A}=e,P=this;if(!i.isValid(S))throw new Error("invalid scalar: out of range");if(S===co||P.is0())return $.ZERO;if(S===tu)return P;if(F.hasCache(this))return this.multiply(S);if(A){const{k1neg:L,k1:B,k2neg:D,k2:V}=M(S),{p1:z,p2:q}=ede($,P,B,V);return I(A.beta,z,q,L,D)}else return F.unsafe(P,S)}toAffine(S){return E(this,S)}isTorsionFree(){const{isTorsionFree:S}=e;return o===tu?!0:S?S($,this):F.unsafe(this,a).is0()}clearCofactor(){const{clearCofactor:S}=e;return o===tu?this:S?S($,this):this.multiplyUnsafe(o)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}toBytes(S=!0){return Gc(S,"isCompressed"),this.assertValidity(),m($,this,S)}toHex(S=!0){return mp(this.toBytes(S))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}};f($,"BASE",new $(s.Gx,s.Gy,n.ONE)),f($,"ZERO",new $(n.ZERO,n.ONE,n.ZERO)),f($,"Fp",n),f($,"Fn",i);let x=$;const T=i.BITS,F=new kB(x,e.endo?Math.ceil(T/2):T);return x.BASE.precompute(8),x}function JB(r){return Uint8Array.of(r?2:3)}function jB(r,e){return{secretKey:e.BYTES,publicKey:1+r.BYTES,publicKeyUncompressed:1+2*r.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}function lfe(r,e={}){const{Fn:t}=r,n=e.randomBytes||J0,i=Object.assign(jB(r.Fp,t),{seed:NB(t.ORDER)});function s(m){try{const p=t.fromBytes(m);return t.isValidNot0(p)}catch{return!1}}function o(m,p){const{publicKey:b,publicKeyUncompressed:g}=i;try{const y=m.length;return p===!0&&y!==b||p===!1&&y!==g?!1:!!r.fromBytes(m)}catch{return!1}}function a(m=n(i.seed)){return Qhe(bt(m,i.seed,"seed"),t.ORDER)}function c(m,p=!0){return r.BASE.multiply(t.fromBytes(m)).toBytes(p)}function l(m){const{secretKey:p,publicKey:b,publicKeyUncompressed:g}=i;if(!Z0(m)||"_lengths"in t&&t._lengths||p===b)return;const y=bt(m,void 0,"key").length;return y===b||y===g}function u(m,p,b=!0){if(l(m)===!0)throw new Error("first arg must be private key");if(l(p)===!1)throw new Error("second arg must be public key");const g=t.fromBytes(m);return r.fromBytes(p).multiply(g).toBytes(b)}const h={isValidSecretKey:s,isValidPublicKey:o,randomSecretKey:a},d=FB(a,c);return Object.freeze({getPublicKey:c,getSharedSecret:u,keygen:d,Point:r,utils:h,lengths:i})}function ufe(r,e,t={}){mB(e),gp(t,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"}),t=Object.assign({},t);const n=t.randomBytes||J0,i=t.hmac||((S,A)=>YB(e,S,A)),{Fp:s,Fn:o}=r,{ORDER:a,BITS:c}=o,{keygen:l,getPublicKey:u,getSharedSecret:h,utils:d,lengths:m}=lfe(r,t),p={prehash:!0,lowS:typeof t.lowS=="boolean"?t.lowS:!0,format:"compact",extraEntropy:!1},b=a*ZB<s.ORDER;function g(S){const A=a>>tu;return S>A}function y(S,A){if(!o.isValidNot0(A))throw new Error(`invalid signature ${S}: out of range 1..Point.Fn.ORDER`);return A}function v(){if(b)throw new Error('"recovered" sig type is not supported for cofactor >2 curves')}function w(S,A){YS(A);const P=m.signature,L=A==="compact"?P:A==="recovered"?P+1:void 0;return bt(S,L)}class _{constructor(A,P,L){f(this,"r");f(this,"s");f(this,"recovery");if(this.r=y("r",A),this.s=y("s",P),L!=null){if(v(),![0,1,2,3].includes(L))throw new Error("invalid recovery id");this.recovery=L}Object.freeze(this)}static fromBytes(A,P=p.format){w(A,P);let L;if(P==="der"){const{r:z,s:q}=ia.toSig(bt(A));return new _(z,q)}P==="recovered"&&(L=A[0],P="compact",A=A.subarray(1));const B=m.signature/2,D=A.subarray(0,B),V=A.subarray(B,B*2);return new _(o.fromBytes(D),o.fromBytes(V),L)}static fromHex(A,P){return this.fromBytes(If(A),P)}assertRecovery(){const{recovery:A}=this;if(A==null)throw new Error("invalid recovery id: must be present");return A}addRecoveryBit(A){return new _(this.r,this.s,A)}recoverPublicKey(A){const{r:P,s:L}=this,B=this.assertRecovery(),D=B===2||B===3?P+a:P;if(!s.isValid(D))throw new Error("invalid recovery id: sig.r+curve.n != R.x");const V=s.toBytes(D),z=r.fromBytes(xs(JB((B&1)===0),V)),q=o.inv(D),G=E(bt(A,void 0,"msgHash")),Y=o.create(-G*q),j=o.create(L*q),X=r.BASE.multiplyUnsafe(Y).add(z.multiplyUnsafe(j));if(X.is0())throw new Error("invalid recovery: point at infinify");return X.assertValidity(),X}hasHighS(){return g(this.s)}toBytes(A=p.format){if(YS(A),A==="der")return If(ia.hexFromSig(this));const{r:P,s:L}=this,B=o.toBytes(P),D=o.toBytes(L);return A==="recovered"?(v(),xs(Uint8Array.of(this.assertRecovery()),B,D)):xs(B,D)}toHex(A){return mp(this.toBytes(A))}}const M=t.bits2int||function(A){if(A.length>8192)throw new Error("input is too large");const P=j0(A),L=A.length*8-c;return L>0?P>>BigInt(L):P},E=t.bits2int_modN||function(A){return o.create(M(A))},C=MM(c);function I(S){return qS("num < 2^"+c,S,co,C),o.toBytes(S)}function x(S,A){return bt(S,void 0,"message"),A?bt(e(S),void 0,"prehashed message"):S}function T(S,A,P){const{lowS:L,prehash:B,extraEntropy:D}=Xw(P,p);S=x(S,B);const V=E(S),z=o.fromBytes(A);if(!o.isValidNot0(z))throw new Error("invalid private key");const q=[I(z),I(V)];if(D!=null&&D!==!1){const X=D===!0?n(m.secretKey):D;q.push(bt(X,void 0,"extraEntropy"))}const G=xs(...q),Y=V;function j(X){const ne=M(X);if(!o.isValidNot0(ne))return;const oe=o.inv(ne),he=r.BASE.multiply(ne).toAffine(),ce=o.create(he.x);if(ce===co)return;const fe=o.create(oe*o.create(Y+ce*z));if(fe===co)return;let W=(he.x===ce?0:2)|Number(he.y&tu),ue=fe;return L&&g(fe)&&(ue=o.neg(fe),W^=1),new _(ce,ue,b?void 0:W)}return{seed:G,k2sig:j}}function F(S,A,P={}){const{seed:L,k2sig:B}=T(S,A,P);return zhe(e.outputLen,o.BYTES,i)(L,B).toBytes(P.format)}function $(S,A,P,L={}){const{lowS:B,prehash:D,format:V}=Xw(L,p);if(P=bt(P,void 0,"publicKey"),A=x(A,D),!Z0(S)){const z=S instanceof _?", use sig.toBytes()":"";throw new Error("verify expects Uint8Array signature"+z)}w(S,V);try{const z=_.fromBytes(S,V),q=r.fromBytes(P);if(B&&z.hasHighS())return!1;const{r:G,s:Y}=z,j=E(A),X=o.inv(Y),ne=o.create(j*X),oe=o.create(G*X),he=r.BASE.multiplyUnsafe(ne).add(q.multiplyUnsafe(oe));return he.is0()?!1:o.create(he.x)===G}catch{return!1}}function H(S,A,P={}){const{prehash:L}=Xw(P,p);return A=x(A,L),_.fromBytes(S,"recovered").recoverPublicKey(A).toBytes()}return Object.freeze({keygen:l,getPublicKey:u,getSharedSecret:h,utils:d,lengths:m,Point:r,sign:F,verify:$,recoverPublicKey:H,Signature:_,hash:e})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const NM={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},hfe={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},zI=BigInt(2);function dfe(r){const e=NM.p,t=BigInt(3),n=BigInt(6),i=BigInt(11),s=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),l=r*r*r%e,u=l*l*r%e,h=tn(u,t,e)*u%e,d=tn(h,t,e)*u%e,m=tn(d,zI,e)*l%e,p=tn(m,i,e)*m%e,b=tn(p,s,e)*p%e,g=tn(b,a,e)*b%e,y=tn(g,c,e)*g%e,v=tn(y,a,e)*b%e,w=tn(v,t,e)*u%e,_=tn(w,o,e)*p%e,M=tn(_,n,e)*l%e,E=tn(M,zI,e);if(!ZS.eql(ZS.sqr(E),r))throw new Error("Cannot find square root");return E}const ZS=Q0(NM.p,{sqrt:dfe}),ffe=cfe(NM,{Fp:ZS,endo:hfe}),Ny=ufe(ffe,_B);function pfe(r,e,t,n){var s;const i=_M.digest(t instanceof Uint8Array?t:t.subarray());if(zB(i))return i.then(({digest:o})=>{var a;return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),Ny.verify(e,o,r,{prehash:!1,format:"der"})}).catch(o=>{throw o.name==="AbortError"?o:new kI(String(o))});try{return(s=n==null?void 0:n.signal)==null||s.throwIfAborted(),Ny.verify(e,i.digest,r,{prehash:!1,format:"der"})}catch(o){throw new kI(String(o))}}class mfe{constructor(e){f(this,"type","secp256k1");f(this,"raw");f(this,"_key");this._key=yfe(e),this.raw=gfe(this._key)}toMultihash(){return fp.digest(yp(this))}toCID(){return en.createV1(114,this.toMultihash())}toString(){return Ir.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Vc(this.raw,e.raw)}verify(e,t,n){return pfe(this._key,t,e,n)}}function QB(r){return new mfe(r)}function gfe(r){return Ny.Point.fromBytes(r).toBytes()}function yfe(r){try{return Ny.Point.fromBytes(r),r}catch(e){throw new bM(String(e))}}function e4(r,e){const{Type:t,Data:n}=oh.decode(r),i=n??new Uint8Array;switch(t){case kn.RSA:return nfe(i,e);case kn.Ed25519:return VB(i);case kn.secp256k1:return QB(i);case kn.ECDSA:return pB(i);default:throw new wM}}function bfe(r){const{Type:e,Data:t}=oh.decode(r.digest),n=t??new Uint8Array;switch(e){case kn.Ed25519:return VB(n);case kn.secp256k1:return QB(n);case kn.ECDSA:return pB(n);default:throw new wM}}function yp(r){return oh.encode({Type:kn[r.type],Data:r.raw})}const t4=Symbol.for("nodejs.util.inspect.custom"),wfe=114;var QR;let OM=class{constructor(e){f(this,"type");f(this,"multihash");f(this,"publicKey");f(this,"string");f(this,QR,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=Ir.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return en.createV1(wfe,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return Vc(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return Vc(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(QR=rB,t4)](){return`PeerId(${this.toString()})`}},n4=class extends OM{constructor(t){super({...t,type:"RSA"});f(this,"type","RSA");f(this,"publicKey");this.publicKey=t.publicKey}},r4=class extends OM{constructor(t){super({...t,type:"Ed25519"});f(this,"type","Ed25519");f(this,"publicKey");this.publicKey=t.publicKey}},i4=class extends OM{constructor(t){super({...t,type:"secp256k1"});f(this,"type","secp256k1");f(this,"publicKey");this.publicKey=t.publicKey}};const vfe=2336;var eD,tD;let _fe=class{constructor(e){f(this,"type","url");f(this,"multihash");f(this,"publicKey");f(this,"url");f(this,eD,!0);this.url=e.toString(),this.multihash=fp.digest(Ro(this.url))}[(tD=t4,eD=rB,tD)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return en.createV1(vfe,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=ei(e)),e.toString()===this.toString())}};function s4(r){if(r.type==="Ed25519")return new r4({multihash:r.toCID().multihash,publicKey:r});if(r.type==="secp256k1")return new i4({multihash:r.toCID().multihash,publicKey:r});if(r.type==="RSA")return new n4({multihash:r.toCID().multihash,publicKey:r});throw new wM}function xfe(r){return s4(r.publicKey)}function UM(r){if(Efe(r))return new n4({multihash:r});if(Sfe(r))try{const e=bfe(r);if(e.type==="Ed25519")return new r4({multihash:r,publicKey:e});if(e.type==="secp256k1")return new i4({multihash:r,publicKey:e})}catch{const t=ei(r.digest);return new _fe(new URL(t))}throw new Ple("Supplied PeerID Multihash is invalid")}function Sfe(r){return r.code===fp.code}function Efe(r){return r.code===_M.code}function Fd(r,e){const t={[Symbol.iterator]:()=>t,next:()=>{const n=r.next(),i=n.value;return n.done===!0||i==null?{done:!0,value:void 0}:{done:!1,value:e(i)}}};return t}function Yw(r){const e=X0(Ir.decode(`z${r}`));return UM(e)}class Mfe{constructor(e){f(this,"map");if(this.map=new Map,e!=null)for(const[t,n]of e.entries())this.map.set(t.toString(),{key:t,value:n})}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(e){return this.map.delete(e.toString())}entries(){return Fd(this.map.entries(),e=>[e[1].key,e[1].value])}forEach(e){this.map.forEach((t,n)=>{e(t.value,t.key,this)})}get(e){var t;return(t=this.map.get(e.toString()))==null?void 0:t.value}has(e){return this.map.has(e.toString())}set(e,t){this.map.set(e.toString(),{key:e,value:t})}keys(){return Fd(this.map.values(),e=>e.key)}values(){return Fd(this.map.values(),e=>e.value)}get size(){return this.map.size}}class $d{constructor(e){f(this,"set");if(this.set=new Set,e!=null)for(const t of e)this.set.add(t.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(e){this.set.add(e.toString())}clear(){this.set.clear()}delete(e){this.set.delete(e.toString())}entries(){return Fd(this.set.entries(),e=>{const t=Yw(e[0]);return[t,t]})}forEach(e){this.set.forEach(t=>{const n=Yw(t);e(n,n,this)})}has(e){return this.set.has(e.toString())}values(){return Fd(this.set.values(),e=>Yw(e))}intersection(e){const t=new $d;for(const n of e)this.has(n)&&t.add(n);return t}difference(e){const t=new $d;for(const n of this)e.has(n)||t.add(n);return t}union(e){const t=new $d;for(const n of e)t.add(n);for(const n of this)t.add(n);return t}}let Afe=class extends Error{constructor(e){super(e),this.name="TimeoutError"}};class Tfe extends Error{constructor(e){super(),this.name="AbortError",this.message=e}}const VI=r=>globalThis.DOMException===void 0?new Tfe(r):new DOMException(r),HI=r=>{const e=r.reason===void 0?VI("This operation was aborted."):r.reason;return e instanceof Error?e:VI(e)};function Cfe(r,e){const{milliseconds:t,fallback:n,message:i,customTimers:s={setTimeout,clearTimeout}}=e;let o,a;const l=new Promise((u,h)=>{if(typeof t!="number"||Math.sign(t)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${t}\``);if(e.signal){const{signal:m}=e;m.aborted&&h(HI(m)),a=()=>{h(HI(m))},m.addEventListener("abort",a,{once:!0})}if(t===Number.POSITIVE_INFINITY){r.then(u,h);return}const d=new Afe;o=s.setTimeout.call(void 0,()=>{if(n){try{u(n())}catch(m){h(m)}return}typeof r.cancel=="function"&&r.cancel(),i===!1?u():i instanceof Error?h(i):(d.message=i??`Promise timed out after ${t} milliseconds`,h(d))},t),(async()=>{try{u(await r)}catch(m){h(m)}})()}).finally(()=>{l.clear(),a&&e.signal&&e.signal.removeEventListener("abort",a)});return l.clear=()=>{s.clearTimeout.call(void 0,o),o=void 0},l}const Ife=r=>{const e=r.addEventListener||r.on||r.addListener,t=r.removeEventListener||r.off||r.removeListener;if(!e||!t)throw new TypeError("Emitter is not compatible");return{addListener:e.bind(r),removeListener:t.bind(r)}};function Pfe(r,e,t){let n;const i=new Promise((s,o)=>{var m;if(t={rejectionEvents:["error"],multiArgs:!1,rejectionMultiArgs:!1,resolveImmediately:!1,...t},!(t.count>=0&&(t.count===Number.POSITIVE_INFINITY||Number.isInteger(t.count))))throw new TypeError("The `count` option should be at least 0 or more");(m=t.signal)==null||m.throwIfAborted();const a=[e].flat(),c=[],{addListener:l,removeListener:u}=Ife(r),h=async(...p)=>{const b=t.multiArgs?p:p[0];if(t.filter)try{if(!await t.filter(b))return}catch(g){n(),o(g);return}c.push(b),t.count===c.length&&(n(),s(c))},d=(...p)=>{n(),o(t.rejectionMultiArgs?p:p[0])};n=()=>{for(const p of a)u(p,h);for(const p of t.rejectionEvents)a.includes(p)||u(p,d)};for(const p of a)l(p,h);for(const p of t.rejectionEvents)a.includes(p)||l(p,d);t.signal&&t.signal.addEventListener("abort",()=>{d(t.signal.reason)},{once:!0}),t.resolveImmediately&&s(c)});if(i.cancel=n,typeof t.timeout=="number"){const s=Cfe(i,{milliseconds:t.timeout});return s.cancel=()=>{n(),s.clear()},s}return i}function Rfe(r,e,t){typeof t=="function"&&(t={filter:t}),t={...t,count:1,resolveImmediately:!1};const n=Pfe(r,e,t),i=n.then(s=>s[0]);return i.cancel=n.cancel,i}class Df extends Error{constructor(){super(...arguments);f(this,"name","UnexpectedEOFError")}}f(Df,"name","UnexpectedEOFError");function Dfe(r){return r.reason}async function Lfe(r,e,t){if(e==null)return r;const n=Dfe;if(e.aborted)return r.catch(()=>{}),Promise.reject(n(e));let i;try{return await Promise.race([r,new Promise((s,o)=>{i=()=>{o(n(e))},e.addEventListener("abort",i)})])}finally{i!=null&&e.removeEventListener("abort",i)}}const Nfe=4194304;class JS extends Error{constructor(){super(...arguments);f(this,"name","UnwrappedError")}}f(JS,"name","UnwrappedError");class Ofe extends Error{constructor(){super(...arguments);f(this,"name","InvalidMessageLengthError");f(this,"code","ERR_INVALID_MSG_LENGTH")}}class Ufe extends Error{constructor(){super(...arguments);f(this,"name","InvalidDataLengthError");f(this,"code","ERR_MSG_DATA_TOO_LONG")}}class kfe extends Error{constructor(){super(...arguments);f(this,"name","InvalidDataLengthLengthError");f(this,"code","ERR_MSG_LENGTH_TOO_LONG")}}function Bfe(r){return typeof(r==null?void 0:r.closeRead)=="function"}function Ffe(r){return typeof(r==null?void 0:r.close)=="function"}function Zw(r){return Bfe(r)?r.remoteWriteStatus!=="writable"&&r.readBufferLength===0:Ffe(r)?r.status!=="open":!1}function $fe(r){return(r==null?void 0:r.addEventListener)!=null&&(r==null?void 0:r.removeEventListener)!=null&&(r==null?void 0:r.send)!=null&&(r==null?void 0:r.push)!=null&&(r==null?void 0:r.log)!=null}function zfe(r,e){const t=(e==null?void 0:e.maxBufferSize)??Nfe,n=new $n;let i,s=!1;if(!$fe(r))throw new jc("Argument should be a Stream or a Multiaddr");const o=u=>{if(n.append(u.data),n.byteLength>t){const h=n.byteLength;n.consume(n.byteLength),i==null||i.reject(new Error(`Read buffer overflow - ${h} > ${t}`))}i==null||i.resolve()};r.addEventListener("message",o);const a=u=>{u.error!=null?i==null||i.reject(u.error):i==null||i.resolve()};r.addEventListener("close",a);const c=()=>{i==null||i.resolve()};r.addEventListener("remoteCloseWrite",c);const l={readBuffer:n,async read(u){if(s===!0)throw new JS("Stream was unwrapped");if(Zw(r)){if((u==null?void 0:u.bytes)==null)return null;if(n.byteLength<u.bytes)throw r.log.error("closed after reading %d/%d bytes",n.byteLength,u.bytes),new Df(`Unexpected EOF - stream closed after reading ${n.byteLength}/${u.bytes} bytes`)}const h=(u==null?void 0:u.bytes)??1;for(i=Promise.withResolvers();;){if(n.byteLength>=h){i.resolve();break}if(await Lfe(i.promise,u==null?void 0:u.signal),Zw(r)){if(n.byteLength===0&&(u==null?void 0:u.bytes)==null)return null;break}i=Promise.withResolvers()}const d=(u==null?void 0:u.bytes)??n.byteLength;if(n.byteLength<d){if(Zw(r))throw r.log.error("closed while reading %d/%d bytes",n.byteLength,d),new Df(`Unexpected EOF - stream closed while reading ${n.byteLength}/${d} bytes`);return l.read(u)}const m=n.sublist(0,d);return n.consume(d),m},async write(u,h){if(s===!0)throw new JS("Stream was unwrapped");r.send(u)||await Rfe(r,"drain",{signal:h==null?void 0:h.signal,rejectionEvents:["close"]})},unwrap(){return s||(s=!0,r.removeEventListener("message",o),r.removeEventListener("close",a),r.removeEventListener("remoteCloseWrite",c),n.byteLength>0&&(r.log("stream unwrapped with %d unread bytes",n.byteLength),r.push(n))),r}};return l}function Vfe(r,e={}){const t=zfe(r,e);e.maxDataLength!=null&&e.maxLengthLength==null&&(e.maxLengthLength=Ah(e.maxDataLength));const n=(e==null?void 0:e.lengthDecoder)??Tde,i=(e==null?void 0:e.lengthEncoder)??Ade;return{async read(o){let a=-1;const c=new $n;for(;;){const u=await t.read({...o,bytes:1});if(u==null)break;c.append(u);try{a=n(c)}catch(h){if(h instanceof RangeError)continue;throw h}if(a<0)throw new Ofe("Invalid message length");if((e==null?void 0:e.maxLengthLength)!=null&&c.byteLength>e.maxLengthLength)throw new kfe(`Message length length too long - ${c.byteLength} > ${e.maxLengthLength}`);if(a>-1)break}if((e==null?void 0:e.maxDataLength)!=null&&a>e.maxDataLength)throw new Ufe(`Message length too long - ${a} > ${e.maxDataLength}`);const l=await t.read({...o,bytes:a});if(l==null)throw r.log.error("tried to read %d bytes but the stream closed",a),new Df(`Unexpected EOF - tried to read ${a} bytes but the stream closed`);if(l.byteLength!==a)throw r.log.error("read %d/%d bytes before the stream closed",l.byteLength,a),new Df(`Unexpected EOF - read ${l.byteLength}/${a} bytes before the stream closed`);return l},async write(o,a){await t.write(new $n(i(o.byteLength),o),a)},async writeV(o,a){const c=new $n(...o.flatMap(l=>[i(l.byteLength),l]));await t.write(c,a)},unwrap(){return t.unwrap()}}}function GI(r,e){const t=Vfe(r,e),n={read:async(i,s)=>{const o=await t.read(s);return i.decode(o)},write:async(i,s,o)=>{await t.write(s.encode(i),o)},writeV:async(i,s,o)=>{await t.writeV(i.map(a=>s.encode(a)),o)},pb:i=>({read:async s=>n.read(i,s),write:async(s,o)=>n.write(s,i,o),writeV:async(s,o)=>n.writeV(s,i,o),unwrap:()=>n}),unwrap:()=>t.unwrap()};return n}var Jw={exports:{}},WI;function Hfe(){return WI||(WI=1,(function(r){var e=Object.prototype.hasOwnProperty,t="~";function n(){}Object.create&&(n.prototype=Object.create(null),new n().__proto__||(t=!1));function i(c,l,u){this.fn=c,this.context=l,this.once=u||!1}function s(c,l,u,h,d){if(typeof u!="function")throw new TypeError("The listener must be a function");var m=new i(u,h||c,d),p=t?t+l:l;return c._events[p]?c._events[p].fn?c._events[p]=[c._events[p],m]:c._events[p].push(m):(c._events[p]=m,c._eventsCount++),c}function o(c,l){--c._eventsCount===0?c._events=new n:delete c._events[l]}function a(){this._events=new n,this._eventsCount=0}a.prototype.eventNames=function(){var l=[],u,h;if(this._eventsCount===0)return l;for(h in u=this._events)e.call(u,h)&&l.push(t?h.slice(1):h);return Object.getOwnPropertySymbols?l.concat(Object.getOwnPropertySymbols(u)):l},a.prototype.listeners=function(l){var u=t?t+l:l,h=this._events[u];if(!h)return[];if(h.fn)return[h.fn];for(var d=0,m=h.length,p=new Array(m);d<m;d++)p[d]=h[d].fn;return p},a.prototype.listenerCount=function(l){var u=t?t+l:l,h=this._events[u];return h?h.fn?1:h.length:0},a.prototype.emit=function(l,u,h,d,m,p){var b=t?t+l:l;if(!this._events[b])return!1;var g=this._events[b],y=arguments.length,v,w;if(g.fn){switch(g.once&&this.removeListener(l,g.fn,void 0,!0),y){case 1:return g.fn.call(g.context),!0;case 2:return g.fn.call(g.context,u),!0;case 3:return g.fn.call(g.context,u,h),!0;case 4:return g.fn.call(g.context,u,h,d),!0;case 5:return g.fn.call(g.context,u,h,d,m),!0;case 6:return g.fn.call(g.context,u,h,d,m,p),!0}for(w=1,v=new Array(y-1);w<y;w++)v[w-1]=arguments[w];g.fn.apply(g.context,v)}else{var _=g.length,M;for(w=0;w<_;w++)switch(g[w].once&&this.removeListener(l,g[w].fn,void 0,!0),y){case 1:g[w].fn.call(g[w].context);break;case 2:g[w].fn.call(g[w].context,u);break;case 3:g[w].fn.call(g[w].context,u,h);break;case 4:g[w].fn.call(g[w].context,u,h,d);break;default:if(!v)for(M=1,v=new Array(y-1);M<y;M++)v[M-1]=arguments[M];g[w].fn.apply(g[w].context,v)}}return!0},a.prototype.on=function(l,u,h){return s(this,l,u,h,!1)},a.prototype.once=function(l,u,h){return s(this,l,u,h,!0)},a.prototype.removeListener=function(l,u,h,d){var m=t?t+l:l;if(!this._events[m])return this;if(!u)return o(this,m),this;var p=this._events[m];if(p.fn)p.fn===u&&(!d||p.once)&&(!h||p.context===h)&&o(this,m);else{for(var b=0,g=[],y=p.length;b<y;b++)(p[b].fn!==u||d&&!p[b].once||h&&p[b].context!==h)&&g.push(p[b]);g.length?this._events[m]=g.length===1?g[0]:g:o(this,m)}return this},a.prototype.removeAllListeners=function(l){var u;return l?(u=t?t+l:l,this._events[u]&&o(this,u)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=t,a.EventEmitter=a,r.exports=a})(Jw)),Jw.exports}var Gfe=Hfe();const Wfe=W1(Gfe);let qfe=class o4 extends Error{constructor(t,n){var i;super(t,n);f(this,"name","TimeoutError");(i=Error.captureStackTrace)==null||i.call(Error,this,o4)}};const qI=r=>r.reason??new DOMException("This operation was aborted.","AbortError");function Kfe(r,e){const{milliseconds:t,fallback:n,message:i,customTimers:s={setTimeout,clearTimeout},signal:o}=e;let a,c;const u=new Promise((h,d)=>{if(typeof t!="number"||Math.sign(t)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${t}\``);if(o!=null&&o.aborted){d(qI(o));return}if(o&&(c=()=>{d(qI(o))},o.addEventListener("abort",c,{once:!0})),r.then(h,d),t===Number.POSITIVE_INFINITY)return;const m=new qfe;a=s.setTimeout.call(void 0,()=>{if(n){try{h(n())}catch(p){d(p)}return}typeof r.cancel=="function"&&r.cancel(),i===!1?h():i instanceof Error?d(i):(m.message=i??`Promise timed out after ${t} milliseconds`,d(m))},t)}).finally(()=>{u.clear(),c&&o&&o.removeEventListener("abort",c)});return u.clear=()=>{s.clearTimeout.call(void 0,a),a=void 0},u}function Xfe(r,e,t){let n=0,i=r.length;for(;i>0;){const s=Math.trunc(i/2);let o=n+s;t(r[o],e)<=0?(n=++o,i-=s+1):i=s}return n}var hi;class Yfe{constructor(){xe(this,hi,[])}enqueue(e,t){const{priority:n=0,id:i}=t??{},s={priority:n,id:i,run:e};if(this.size===0||N(this,hi)[this.size-1].priority>=n){N(this,hi).push(s);return}const o=Xfe(N(this,hi),s,(a,c)=>c.priority-a.priority);N(this,hi).splice(o,0,s)}setPriority(e,t){const n=N(this,hi).findIndex(s=>s.id===e);if(n===-1)throw new ReferenceError(`No promise function with the id "${e}" exists in the queue.`);const[i]=N(this,hi).splice(n,1);this.enqueue(i.run,{priority:t,id:e})}dequeue(){const e=N(this,hi).shift();return e==null?void 0:e.run}filter(e){return N(this,hi).filter(t=>t.priority===e.priority).map(t=>t.run)}get size(){return N(this,hi).length}}hi=new WeakMap;var Eu,zi,ys,Mu,Au,Tu,ua,Yf,Cu,bs,to,mn,Zf,lr,vc,no,Qy,_c,Fe,a4,c4,l4,u4,h4,jS,QS,d4,Cg,eE,tE,Ig,Qa,f4,bd,nE;class Zfe extends Wfe{constructor(t){var n,i;super();xe(this,Fe);xe(this,Eu);xe(this,zi);xe(this,ys,0);xe(this,Mu);xe(this,Au,!1);xe(this,Tu,!1);xe(this,ua);xe(this,Yf,0);xe(this,Cu,0);xe(this,bs);xe(this,to);xe(this,mn);xe(this,Zf);xe(this,lr,0);xe(this,vc);xe(this,no);xe(this,Qy,1n);xe(this,_c,new Map);f(this,"timeout");if(t={carryoverIntervalCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:Yfe,...t},!(typeof t.intervalCap=="number"&&t.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${((n=t.intervalCap)==null?void 0:n.toString())??""}\` (${typeof t.intervalCap})`);if(t.interval===void 0||!(Number.isFinite(t.interval)&&t.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${((i=t.interval)==null?void 0:i.toString())??""}\` (${typeof t.interval})`);if(_e(this,Eu,t.carryoverIntervalCount??t.carryoverConcurrencyCount??!1),_e(this,zi,t.intervalCap===Number.POSITIVE_INFINITY||t.interval===0),_e(this,Mu,t.intervalCap),_e(this,ua,t.interval),_e(this,mn,new t.queueClass),_e(this,Zf,t.queueClass),this.concurrency=t.concurrency,t.timeout!==void 0&&!(Number.isFinite(t.timeout)&&t.timeout>0))throw new TypeError(`Expected \`timeout\` to be a positive finite number, got \`${t.timeout}\` (${typeof t.timeout})`);this.timeout=t.timeout,_e(this,no,t.autoStart===!1),be(this,Fe,f4).call(this)}get concurrency(){return N(this,vc)}set concurrency(t){if(!(typeof t=="number"&&t>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${t}\` (${typeof t})`);_e(this,vc,t),be(this,Fe,Ig).call(this)}setPriority(t,n){if(typeof n!="number"||!Number.isFinite(n))throw new TypeError(`Expected \`priority\` to be a finite number, got \`${n}\` (${typeof n})`);N(this,mn).setPriority(t,n)}async add(t,n={}){return n.id??(n.id=(Ti(this,Qy)._++).toString()),n={timeout:this.timeout,...n},new Promise((i,s)=>{const o=Symbol(`task-${n.id}`);N(this,mn).enqueue(async()=>{var c,l;Ti(this,lr)._++,N(this,_c).set(o,{id:n.id,priority:n.priority??0,startTime:Date.now(),timeout:n.timeout});let a;try{try{(c=n.signal)==null||c.throwIfAborted()}catch(d){throw N(this,zi)||Ti(this,ys)._--,N(this,_c).delete(o),d}let u=t({signal:n.signal});if(n.timeout&&(u=Kfe(Promise.resolve(u),{milliseconds:n.timeout,message:`Task timed out after ${n.timeout}ms (queue has ${N(this,lr)} running, ${N(this,mn).size} waiting)`})),n.signal){const{signal:d}=n;u=Promise.race([u,new Promise((m,p)=>{a=()=>{p(d.reason)},d.addEventListener("abort",a,{once:!0})})])}const h=await u;i(h),this.emit("completed",h)}catch(u){s(u),this.emit("error",u)}finally{a&&((l=n.signal)==null||l.removeEventListener("abort",a)),N(this,_c).delete(o),queueMicrotask(()=>{be(this,Fe,l4).call(this)})}},n),this.emit("add"),be(this,Fe,Cg).call(this)})}async addAll(t,n){return Promise.all(t.map(async i=>this.add(i,n)))}start(){return N(this,no)?(_e(this,no,!1),be(this,Fe,Ig).call(this),this):this}pause(){_e(this,no,!0)}clear(){_e(this,mn,new(N(this,Zf))),be(this,Fe,nE).call(this)}async onEmpty(){N(this,mn).size!==0&&await be(this,Fe,Qa).call(this,"empty")}async onSizeLessThan(t){N(this,mn).size<t||await be(this,Fe,Qa).call(this,"next",()=>N(this,mn).size<t)}async onIdle(){N(this,lr)===0&&N(this,mn).size===0||await be(this,Fe,Qa).call(this,"idle")}async onPendingZero(){N(this,lr)!==0&&await be(this,Fe,Qa).call(this,"pendingZero")}async onRateLimit(){this.isRateLimited||await be(this,Fe,Qa).call(this,"rateLimit")}async onRateLimitCleared(){this.isRateLimited&&await be(this,Fe,Qa).call(this,"rateLimitCleared")}async onError(){return new Promise((t,n)=>{const i=s=>{this.off("error",i),n(s)};this.on("error",i)})}get size(){return N(this,mn).size}sizeBy(t){return N(this,mn).filter(t).length}get pending(){return N(this,lr)}get isPaused(){return N(this,no)}get isRateLimited(){return N(this,Au)}get isSaturated(){return N(this,lr)===N(this,vc)&&N(this,mn).size>0||this.isRateLimited&&N(this,mn).size>0}get runningTasks(){return[...N(this,_c).values()].map(t=>({...t}))}}Eu=new WeakMap,zi=new WeakMap,ys=new WeakMap,Mu=new WeakMap,Au=new WeakMap,Tu=new WeakMap,ua=new WeakMap,Yf=new WeakMap,Cu=new WeakMap,bs=new WeakMap,to=new WeakMap,mn=new WeakMap,Zf=new WeakMap,lr=new WeakMap,vc=new WeakMap,no=new WeakMap,Qy=new WeakMap,_c=new WeakMap,Fe=new WeakSet,a4=function(){return N(this,zi)||N(this,ys)<N(this,Mu)},c4=function(){return N(this,lr)<N(this,vc)},l4=function(){Ti(this,lr)._--,N(this,lr)===0&&this.emit("pendingZero"),be(this,Fe,Cg).call(this),this.emit("next")},u4=function(){be(this,Fe,tE).call(this),be(this,Fe,eE).call(this),_e(this,to,void 0)},h4=function(){const t=Date.now();if(N(this,bs)===void 0){const n=N(this,Yf)-t;if(n<0){if(N(this,Cu)>0){const i=t-N(this,Cu);if(i<N(this,ua))return be(this,Fe,jS).call(this,N(this,ua)-i),!0}_e(this,ys,N(this,Eu)?N(this,lr):0)}else return be(this,Fe,jS).call(this,n),!0}return!1},jS=function(t){N(this,to)===void 0&&_e(this,to,setTimeout(()=>{be(this,Fe,u4).call(this)},t))},QS=function(){N(this,bs)&&(clearInterval(N(this,bs)),_e(this,bs,void 0))},d4=function(){N(this,to)&&(clearTimeout(N(this,to)),_e(this,to,void 0))},Cg=function(){if(N(this,mn).size===0)return be(this,Fe,QS).call(this),this.emit("empty"),N(this,lr)===0&&(be(this,Fe,d4).call(this),this.emit("idle")),!1;let t=!1;if(!N(this,no)){const n=!N(this,Fe,h4);if(N(this,Fe,a4)&&N(this,Fe,c4)){const i=N(this,mn).dequeue();N(this,zi)||(Ti(this,ys)._++,be(this,Fe,bd).call(this)),this.emit("active"),_e(this,Cu,Date.now()),i(),n&&be(this,Fe,eE).call(this),t=!0}}return t},eE=function(){N(this,zi)||N(this,bs)!==void 0||(_e(this,bs,setInterval(()=>{be(this,Fe,tE).call(this)},N(this,ua))),_e(this,Yf,Date.now()+N(this,ua)))},tE=function(){N(this,ys)===0&&N(this,lr)===0&&N(this,bs)&&be(this,Fe,QS).call(this),_e(this,ys,N(this,Eu)?N(this,lr):0),be(this,Fe,Ig).call(this),be(this,Fe,bd).call(this)},Ig=function(){for(;be(this,Fe,Cg).call(this););},Qa=async function(t,n){return new Promise(i=>{const s=()=>{n&&!n()||(this.off(t,s),i())};this.on(t,s)})},f4=function(){N(this,zi)||(this.on("add",()=>{N(this,mn).size>0&&be(this,Fe,bd).call(this)}),this.on("next",()=>{be(this,Fe,bd).call(this)}))},bd=function(){N(this,zi)||N(this,Tu)||(_e(this,Tu,!0),queueMicrotask(()=>{_e(this,Tu,!1),be(this,Fe,nE).call(this)}))},nE=function(){const t=N(this,Au),n=!N(this,zi)&&N(this,ys)>=N(this,Mu)&&N(this,mn).size>0;n!==t&&(_e(this,Au,n),this.emit(n?"rateLimit":"rateLimitCleared"))};class Jfe{constructor(e){f(this,"entries");f(this,"validityMs");f(this,"lastPruneTime",0);this.entries=new Map,this.validityMs=e.validityMs}put(e,t){this.entries.set(e,{value:t,validUntilMs:Date.now()+this.validityMs}),this.prune()}prune(){const e=Date.now();if(!(e-this.lastPruneTime<200)){this.lastPruneTime=e;for(const[t,n]of this.entries.entries())if(n.validUntilMs<e)this.entries.delete(t);else break}}has(e){return this.entries.has(e)}get(e){const t=this.entries.get(e);return t!=null&&t.validUntilMs>=Date.now()?t.value:void 0}clear(){this.entries=new Map,this.lastPruneTime=0}}var Lf;(function(r){(function(t){let n;t.codec=()=>(n==null&&(n=Qi((i,s,o={})=>{o.lengthDelimited!==!1&&s.fork(),i.subscribe!=null&&(s.uint32(8),s.bool(i.subscribe)),i.topic!=null&&(s.uint32(18),s.string(i.topic)),o.lengthDelimited!==!1&&s.ldelim()},(i,s,o={})=>{const a={},c=s==null?i.len:i.pos+s;for(;i.pos<c;){const l=i.uint32();switch(l>>>3){case 1:{a.subscribe=i.bool();break}case 2:{a.topic=i.string();break}default:{i.skipType(l&7);break}}}return a})),n),t.encode=i=>ji(i,t.codec()),t.decode=(i,s)=>Ji(i,t.codec(),s)})(r.SubOpts||(r.SubOpts={})),(function(t){let n;t.codec=()=>(n==null&&(n=Qi((i,s,o={})=>{o.lengthDelimited!==!1&&s.fork(),i.from!=null&&(s.uint32(10),s.bytes(i.from)),i.data!=null&&(s.uint32(18),s.bytes(i.data)),i.sequenceNumber!=null&&(s.uint32(26),s.bytes(i.sequenceNumber)),i.topic!=null&&(s.uint32(34),s.string(i.topic)),i.signature!=null&&(s.uint32(42),s.bytes(i.signature)),i.key!=null&&(s.uint32(50),s.bytes(i.key)),o.lengthDelimited!==!1&&s.ldelim()},(i,s,o={})=>{const a={},c=s==null?i.len:i.pos+s;for(;i.pos<c;){const l=i.uint32();switch(l>>>3){case 1:{a.from=i.bytes();break}case 2:{a.data=i.bytes();break}case 3:{a.sequenceNumber=i.bytes();break}case 4:{a.topic=i.string();break}case 5:{a.signature=i.bytes();break}case 6:{a.key=i.bytes();break}default:{i.skipType(l&7);break}}}return a})),n),t.encode=i=>ji(i,t.codec()),t.decode=(i,s)=>Ji(i,t.codec(),s)})(r.Message||(r.Message={}));let e;r.codec=()=>(e==null&&(e=Qi((t,n,i={})=>{if(i.lengthDelimited!==!1&&n.fork(),t.subscriptions!=null)for(const s of t.subscriptions)n.uint32(10),r.SubOpts.codec().encode(s,n);if(t.messages!=null)for(const s of t.messages)n.uint32(18),r.Message.codec().encode(s,n);t.control!=null&&(n.uint32(26),Oy.codec().encode(t.control,n)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{var a,c,l,u,h;const s={subscriptions:[],messages:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const d=t.uint32();switch(d>>>3){case 1:{if(((a=i.limits)==null?void 0:a.subscriptions)!=null&&s.subscriptions.length===i.limits.subscriptions)throw new ao('Decode error - map field "subscriptions" had too many elements');s.subscriptions.push(r.SubOpts.codec().decode(t,t.uint32(),{limits:(c=i.limits)==null?void 0:c.subscriptions$}));break}case 2:{if(((l=i.limits)==null?void 0:l.messages)!=null&&s.messages.length===i.limits.messages)throw new ao('Decode error - map field "messages" had too many elements');s.messages.push(r.Message.codec().decode(t,t.uint32(),{limits:(u=i.limits)==null?void 0:u.messages$}));break}case 3:{s.control=Oy.codec().decode(t,t.uint32(),{limits:(h=i.limits)==null?void 0:h.control});break}default:{t.skipType(d&7);break}}}return s})),e),r.encode=t=>ji(t,r.codec()),r.decode=(t,n)=>Ji(t,r.codec(),n)})(Lf||(Lf={}));var Oy;(function(r){let e;r.codec=()=>(e==null&&(e=Qi((t,n,i={})=>{if(i.lengthDelimited!==!1&&n.fork(),t.ihave!=null)for(const s of t.ihave)n.uint32(10),Uy.codec().encode(s,n);if(t.iwant!=null)for(const s of t.iwant)n.uint32(18),ky.codec().encode(s,n);if(t.graft!=null)for(const s of t.graft)n.uint32(26),By.codec().encode(s,n);if(t.prune!=null)for(const s of t.prune)n.uint32(34),Fy.codec().encode(s,n);i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{var a,c,l,u,h,d,m,p;const s={ihave:[],iwant:[],graft:[],prune:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const b=t.uint32();switch(b>>>3){case 1:{if(((a=i.limits)==null?void 0:a.ihave)!=null&&s.ihave.length===i.limits.ihave)throw new ao('Decode error - map field "ihave" had too many elements');s.ihave.push(Uy.codec().decode(t,t.uint32(),{limits:(c=i.limits)==null?void 0:c.ihave$}));break}case 2:{if(((l=i.limits)==null?void 0:l.iwant)!=null&&s.iwant.length===i.limits.iwant)throw new ao('Decode error - map field "iwant" had too many elements');s.iwant.push(ky.codec().decode(t,t.uint32(),{limits:(u=i.limits)==null?void 0:u.iwant$}));break}case 3:{if(((h=i.limits)==null?void 0:h.graft)!=null&&s.graft.length===i.limits.graft)throw new ao('Decode error - map field "graft" had too many elements');s.graft.push(By.codec().decode(t,t.uint32(),{limits:(d=i.limits)==null?void 0:d.graft$}));break}case 4:{if(((m=i.limits)==null?void 0:m.prune)!=null&&s.prune.length===i.limits.prune)throw new ao('Decode error - map field "prune" had too many elements');s.prune.push(Fy.codec().decode(t,t.uint32(),{limits:(p=i.limits)==null?void 0:p.prune$}));break}default:{t.skipType(b&7);break}}}return s})),e),r.encode=t=>ji(t,r.codec()),r.decode=(t,n)=>Ji(t,r.codec(),n)})(Oy||(Oy={}));var Uy;(function(r){let e;r.codec=()=>(e==null&&(e=Qi((t,n,i={})=>{if(i.lengthDelimited!==!1&&n.fork(),t.topic!=null&&(n.uint32(10),n.string(t.topic)),t.messageIDs!=null)for(const s of t.messageIDs)n.uint32(18),n.bytes(s);i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{var a;const s={messageIDs:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const c=t.uint32();switch(c>>>3){case 1:{s.topic=t.string();break}case 2:{if(((a=i.limits)==null?void 0:a.messageIDs)!=null&&s.messageIDs.length===i.limits.messageIDs)throw new ao('Decode error - map field "messageIDs" had too many elements');s.messageIDs.push(t.bytes());break}default:{t.skipType(c&7);break}}}return s})),e),r.encode=t=>ji(t,r.codec()),r.decode=(t,n)=>Ji(t,r.codec(),n)})(Uy||(Uy={}));var ky;(function(r){let e;r.codec=()=>(e==null&&(e=Qi((t,n,i={})=>{if(i.lengthDelimited!==!1&&n.fork(),t.messageIDs!=null)for(const s of t.messageIDs)n.uint32(10),n.bytes(s);i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{var a;const s={messageIDs:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const c=t.uint32();switch(c>>>3){case 1:{if(((a=i.limits)==null?void 0:a.messageIDs)!=null&&s.messageIDs.length===i.limits.messageIDs)throw new ao('Decode error - map field "messageIDs" had too many elements');s.messageIDs.push(t.bytes());break}default:{t.skipType(c&7);break}}}return s})),e),r.encode=t=>ji(t,r.codec()),r.decode=(t,n)=>Ji(t,r.codec(),n)})(ky||(ky={}));var By;(function(r){let e;r.codec=()=>(e==null&&(e=Qi((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.topic!=null&&(n.uint32(10),n.string(t.topic)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.topic=t.string();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>ji(t,r.codec()),r.decode=(t,n)=>Ji(t,r.codec(),n)})(By||(By={}));var Fy;(function(r){let e;r.codec=()=>(e==null&&(e=Qi((t,n,i={})=>{if(i.lengthDelimited!==!1&&n.fork(),t.topic!=null&&(n.uint32(10),n.string(t.topic)),t.peers!=null)for(const s of t.peers)n.uint32(18),$y.codec().encode(s,n);t.backoff!=null&&(n.uint32(24),n.uint64(t.backoff)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{var a,c;const s={peers:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const l=t.uint32();switch(l>>>3){case 1:{s.topic=t.string();break}case 2:{if(((a=i.limits)==null?void 0:a.peers)!=null&&s.peers.length===i.limits.peers)throw new ao('Decode error - map field "peers" had too many elements');s.peers.push($y.codec().decode(t,t.uint32(),{limits:(c=i.limits)==null?void 0:c.peers$}));break}case 3:{s.backoff=t.uint64();break}default:{t.skipType(l&7);break}}}return s})),e),r.encode=t=>ji(t,r.codec()),r.decode=(t,n)=>Ji(t,r.codec(),n)})(Fy||(Fy={}));var $y;(function(r){let e;r.codec=()=>(e==null&&(e=Qi((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.peerID!=null&&(n.uint32(10),n.bytes(t.peerID)),t.signedPeerRecord!=null&&(n.uint32(18),n.bytes(t.signedPeerRecord)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.peerID=t.bytes();break}case 2:{s.signedPeerRecord=t.bytes();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>ji(t,r.codec()),r.decode=(t,n)=>Ji(t,r.codec(),n)})($y||($y={}));class jfe extends iB{constructor(t){super();f(this,"peerId");f(this,"shutDownController");f(this,"inboundPb");f(this,"outboundPb");this.peerId=t,this.shutDownController=new AbortController}attachInboundStream(t,n){this.inboundPb=GI(t,n).pb(Lf),Promise.resolve().then(async()=>{for(;;){if(this.inboundPb==null)return;const i=await this.inboundPb.read({signal:this.shutDownController.signal});this.safeDispatchEvent("message",{detail:i})}}).catch(i=>{var s;(s=this.inboundPb)==null||s.unwrap().unwrap().abort(i)})}attachOutboundStream(t,n){this.outboundPb=GI(t,n).pb(Lf)}write(t){this.outboundPb!=null&&this.outboundPb.write(t,{signal:this.shutDownController.signal}).catch(n=>{var i;(i=this.outboundPb)==null||i.unwrap().unwrap().abort(n)})}close(){var t,n;this.shutDownController.abort(),Promise.all([(t=this.inboundPb)==null?void 0:t.unwrap().unwrap().close().catch(i=>{var s;(s=this.inboundPb)==null||s.unwrap().unwrap().abort(i)}),(n=this.outboundPb)==null?void 0:n.unwrap().unwrap().close().catch(i=>{var s;(s=this.inboundPb)==null||s.unwrap().unwrap().abort(i)})]).finally(()=>{this.safeDispatchEvent("close")})}}function Qfe(){return BigInt(`0x${ei(Yde(8),"base16")}`)}const epe=(r,e)=>{const t=Ro(e.toString(16).padStart(16,"0"),"base16"),n=yp(r),i=new Uint8Array(n.byteLength+t.length);return i.set(n,0),i.set(t,n.byteLength),i},tpe=r=>_M.encode(r),npe=async r=>{if(r.sequenceNumber==null||r.from==null||r.signature==null)return!1;const e=UM(X0(r.from));if(e.publicKey!=null)return!0;if(r.key!=null){const t=r.key;return s4(e4(t)).equals(e)}return!1},rpe=async r=>{if(r.from==null)throw new Nn("RPC message was missing from");if(!await npe(r))return{type:"unsigned",topic:r.topic??"",data:r.data??new Uint8Array(0)};const e=UM(X0(r.from)),t=r.key??e.publicKey;if(t==null)throw new Nn("RPC message was missing public key");return{type:"signed",from:e,topic:r.topic??"",sequenceNumber:spe(r.sequenceNumber??new Uint8Array(0)),data:r.data??new Uint8Array(0),signature:r.signature??new Uint8Array(0),key:t instanceof Uint8Array?e4(t):t}},kM=r=>r.type==="signed"?{from:r.from.toMultihash().bytes,data:r.data,sequenceNumber:ipe(r.sequenceNumber),topic:r.topic,signature:r.signature,key:r.key?yp(r.key):void 0}:{data:r.data,topic:r.topic},ipe=r=>{let e=r.toString(16);return e.length%2!==0&&(e=`0${e}`),Ro(e,"base16")},spe=r=>BigInt(`0x${ei(r,"base16")}`),p4=Ro("libp2p-pubsub:");async function ope(r,e,t){const n={type:"signed",topic:e.topic,data:e.data,sequenceNumber:e.sequenceNumber,from:xfe(r)},i=Iy([p4,t(kM(n)).subarray()]);return n.signature=await r.sign(i),n.key=r.publicKey,n}async function ape(r,e){if(r.type!=="signed")throw new Error('Message type must be "signed" to be verified');if(r.signature==null)throw new Error("Message must contain a signature to be verified");if(r.from==null)throw new Error("Message must contain a from property to be verified");const t=Iy([p4,e({...kM(r),signature:void 0,key:void 0}).subarray()]);return cpe(r).verify(t,r.signature)}function cpe(r){if(r.type!=="signed")throw new Error('Message type must be "signed" to have a public key');if(r.from==null)throw new Error("Could not get the public key from the originator id");if(r.key!=null)return r.key;if(r.from.publicKey!=null)return r.from.publicKey;throw new Error("Could not get the public key from the originator id")}var nD,rD,iD,sD,oD;class lpe extends(oD=iB,sD=Ile,iD=Symbol.toStringTag,rD=Rle,nD=Dle,oD){constructor(t,n){super();f(this,"log");f(this,"started");f(this,"topics");f(this,"subscriptions");f(this,"peers");f(this,"globalSignaturePolicy");f(this,"canRelayMessage");f(this,"emitSelf");f(this,"topicValidators");f(this,"queue");f(this,"protocol");f(this,"components");f(this,"_registrarTopologyId");f(this,"maxInboundStreams");f(this,"maxOutboundStreams");f(this,"seenCache");f(this,sD,!0);f(this,iD,"@libp2p/floodsub");f(this,rD,["@libp2p/pubsub"]);f(this,nD,["@libp2p/identify"]);this.log=t.logger.forComponent("libp2p:floodsub"),this.components=t,this.protocol=n.protocol??upe,this.started=!1,this.topics=new Map,this.subscriptions=new Set,this.peers=new Mfe,this.globalSignaturePolicy=n.globalSignaturePolicy==="StrictNoSign"?"StrictNoSign":"StrictSign",this.canRelayMessage=n.canRelayMessage??!0,this.emitSelf=n.emitSelf??!1,this.topicValidators=new Map,this.queue=new Zfe({concurrency:n.messageProcessingConcurrency??10}),this.maxInboundStreams=n.maxInboundStreams??1,this.maxOutboundStreams=n.maxOutboundStreams??1,this.seenCache=new Jfe({validityMs:(n==null?void 0:n.seenTTL)??3e4}),this._onIncomingStream=this._onIncomingStream.bind(this),this._onPeerConnected=this._onPeerConnected.bind(this),this._onPeerDisconnected=this._onPeerDisconnected.bind(this)}async start(){this.started||(this.log("starting"),await this.components.registrar.handle(this.protocol,this._onIncomingStream,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams}),this._registrarTopologyId=await this.components.registrar.register(this.protocol,{onConnect:this._onPeerConnected,onDisconnect:this._onPeerDisconnected}),this.log("started"),this.started=!0)}async stop(){if(!this.started)return;const t=this.components.registrar;this._registrarTopologyId!=null&&t.unregister(this._registrarTopologyId),await t.unhandle(this.protocol),this.log("stopping");for(const n of this.peers.values())n.close();this.peers.clear(),this.subscriptions=new Set,this.started=!1,this.log("stopped")}isStarted(){return this.started}_onIncomingStream(t,n){this.addPeer(n.remotePeer,t).attachInboundStream(t)}async _onPeerConnected(t,n){if(this.log("connected %p",t),n.streams.find(o=>o.direction==="outbound"&&o.protocol===this.protocol)){this.log("outbound pubsub stream already present on connection from %p",t);return}const i=await n.newStream(this.protocol);this.addPeer(t,i).attachOutboundStream(i),this.send(t,{subscriptions:Array.from(this.subscriptions).map(o=>o.toString()),subscribe:!0})}_onPeerDisconnected(t,n){this.log("connection ended %p",t),this._removePeer(t)}addPeer(t,n){const i=this.peers.get(t);if(i!=null)return i;this.log("new peer %p",t);const s=new jfe(t);return this.peers.set(t,s),s.addEventListener("message",o=>{const a=o.detail,c=[];for(const l of a.messages??[]){if(l.from==null||l.data==null||l.topic==null){this.log("message from %p was missing from, data or topic fields, dropping",t);continue}c.push({from:l.from,data:l.data,topic:l.topic,sequenceNumber:l.sequenceNumber??void 0,signature:l.signature??void 0,key:l.key??void 0})}this.processRpc(s,{subscriptions:(a.subscriptions??[]).map(l=>({subscribe:!!l.subscribe,topic:l.topic??""})),messages:c}).catch(l=>{this.log(l)})}),s.addEventListener("close",()=>this._removePeer(t),{once:!0}),s}_removePeer(t){const n=this.peers.get(t);if(n!=null){n.close(),this.log("delete peer %p",t),this.peers.delete(t);for(const i of this.topics.values())i.delete(t)}}async processRpc(t,n){this.log("rpc from %p",t.peerId);const{subscriptions:i,messages:s}=n;return i!=null&&i.length>0&&(this.log("subscription update from %p",t.peerId),i.forEach(o=>{this.processRpcSubOpt(t.peerId,o)}),super.dispatchEvent(new CustomEvent("subscription-change",{detail:{peerId:t.peerId,subscriptions:i.map(({topic:o,subscribe:a})=>({topic:`${o??""}`,subscribe:!!a}))}}))),s!=null&&s.length>0&&(this.log("messages from %p",t.peerId),this.queue.addAll(s.map(o=>async()=>{if(o.topic==null||!this.subscriptions.has(o.topic)&&!this.canRelayMessage)return this.log("received message we didn't subscribe to. Dropping."),!1;try{const a=await rpe(o);await this.processMessage(t.peerId,a)}catch(a){this.log.error("failed to queue messages from %p - %e",t.peerId,a)}})).catch(o=>{this.log(o)})),!0}processRpcSubOpt(t,n){const i=n.topic;if(i==null)return;let s=this.topics.get(i);s==null&&(s=new $d,this.topics.set(i,s)),n.subscribe===!0?s.add(t):s.delete(t)}async processMessage(t,n){if(this.components.peerId.equals(t)&&!this.emitSelf)return;const i=await this.getMsgId(n),s=ei(i,"base64");if(!this.seenCache.has(s)){this.seenCache.put(s,!0);try{await this.validate(t,n)}catch(o){this.log("Message is invalid, dropping it. %O",o);return}this.subscriptions.has(n.topic)&&(!this.components.peerId.equals(t)||this.emitSelf)&&super.dispatchEvent(new CustomEvent("message",{detail:n})),await this.publishMessage(t,n)}}getMsgId(t){switch(this.globalSignaturePolicy){case"StrictSign":if(t.type!=="signed")throw new Nn('Message type should be "signed" when signature policy is StrictSign but it was not');if(t.sequenceNumber==null)throw new Nn("Need sequence number when signature policy is StrictSign but it was missing");if(t.key==null)throw new Nn("Need key when signature policy is StrictSign but it was missing");return epe(t.key,t.sequenceNumber);case"StrictNoSign":return tpe(t.data);default:throw new Nn("Cannot get message id: unhandled signature policy")}}encodeMessage(t){return Lf.Message.encode(t)}send(t,n){const{messages:i,subscriptions:s,subscribe:o}=n;this.sendRpc(t,{subscriptions:(s??[]).map(a=>({topic:a,subscribe:!!o})),messages:(i??[]).map(kM)})}sendRpc(t,n){const i=this.peers.get(t);if(i==null){this.log.error("cannot send RPC to %p as there are no streams to it available",t);return}i.write(n)}async validate(t,n){switch(this.globalSignaturePolicy){case"StrictNoSign":if(n.type!=="unsigned")throw new Nn('Message type should be "unsigned" when signature policy is StrictNoSign but it was not');if(n.signature!=null)throw new Nn("StrictNoSigning: signature should not be present");if(n.key!=null)throw new Nn("StrictNoSigning: key should not be present");if(n.sequenceNumber!=null)throw new Nn("StrictNoSigning: seqno should not be present");break;case"StrictSign":if(n.type!=="signed")throw new Nn('Message type should be "signed" when signature policy is StrictSign but it was not');if(n.signature==null)throw new Nn("StrictSigning: Signing required and no signature was present");if(n.sequenceNumber==null)throw new Nn("StrictSigning: Signing required and no sequenceNumber was present");if(!await ape(n,this.encodeMessage.bind(this)))throw new Nn("StrictSigning: Invalid message signature");break;default:throw new Nn("Cannot validate message: unhandled signature policy")}const s=this.topicValidators.get(n.topic);if(s!=null){const o=await s(t,n);if(o===zy.Reject||o===zy.Ignore)throw new Nn("Message validation failed")}}async buildMessage(t){switch(this.globalSignaturePolicy){case"StrictSign":return ope(this.components.privateKey,t,this.encodeMessage.bind(this));case"StrictNoSign":return Promise.resolve({type:"unsigned",...t});default:throw new Nn("Cannot build message: unhandled signature policy")}}getSubscribers(t){if(!this.started)throw new nB("not started yet");if(t==null)throw new jc("Topic is required");const n=this.topics.get(t.toString());return n==null?[]:Array.from(n.values())}async publish(t,n){if(!this.started)throw new Error("Pubsub has not started");const i={from:this.components.peerId,topic:t,data:n??new Uint8Array(0),sequenceNumber:Qfe()};this.log("publish topic: %s from: %p data: %m",t,i.from,i.data);const s=await this.buildMessage(i);let o=!1;this.emitSelf&&this.subscriptions.has(t)&&(o=!0,super.dispatchEvent(new CustomEvent("message",{detail:s})));const a=await this.publishMessage(this.components.peerId,s);return o&&(a.recipients=[...a.recipients,this.components.peerId]),a}async publishMessage(t,n){const i=this.getSubscribers(n.topic),s=[];return i==null||i.length===0?(this.log("no peers are subscribed to topic %s",n.topic),{recipients:s}):(i.forEach(o=>{if(this.components.peerId.equals(o)){this.log("not sending message on topic %s to myself",n.topic);return}if(o.equals(t)){this.log("not sending message on topic %s to sender %p",n.topic,o);return}this.log("publish msgs on topics %s %p",n.topic,o),s.push(o),this.send(o,{messages:[n]})}),{recipients:s})}subscribe(t){if(!this.started)throw new Error("Pubsub has not started");if(!this.subscriptions.has(t)){this.log("subscribe to topic: %s",t),this.subscriptions.add(t);for(const n of this.peers.keys())this.send(n,{subscriptions:[t],subscribe:!0})}}unsubscribe(t){if(!this.started)throw new Error("Pubsub is not started");if(this.subscriptions.has(t)){this.log("unsubscribe from %s",t),this.subscriptions.delete(t);for(const n of this.peers.keys())this.send(n,{subscriptions:[t],subscribe:!1})}}getTopics(){if(!this.started)throw new Error("Pubsub is not started");return Array.from(this.subscriptions)}getPeers(){if(!this.started)throw new Error("Pubsub is not started");return Array.from(this.peers.keys())}}const upe="/floodsub/1.0.0";var zy;(function(r){r.Accept="accept",r.Ignore="ignore",r.Reject="reject"})(zy||(zy={}));function hpe(r={}){return e=>new lpe(e,r)}var $_;let dpe=($_=class extends Error{constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}},f($_,"name","InvalidCIDError"),$_);var z_;let fpe=(z_=class extends Error{constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}},f(z_,"name","InvalidMultihashError"),z_);class ma extends Error{constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}}f(ma,"name","InvalidMessageError");var V_;let ppe=(V_=class extends Error{constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}},f(V_,"name","UnsupportedKeyTypeError"),V_);const m4=Symbol.for("@libp2p/peer-id"),mpe=Symbol.for("@libp2p/service-capabilities");var H_;let xi=(H_=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidMultiaddrError")}},f(H_,"name","InvalidMultiaddrError"),H_);var G_;let Nf=(G_=class extends Error{constructor(){super(...arguments);f(this,"name","ValidationError")}},f(G_,"name","ValidationError"),G_);var W_;let gpe=(W_=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidParametersError")}},f(W_,"name","InvalidParametersError"),W_);var q_;let ype=(q_=class extends Error{constructor(){super(...arguments);f(this,"name","UnknownProtocolError")}},f(q_,"name","UnknownProtocolError"),q_);const bpe=4,wpe=6,vpe=273,_pe=33,rE=41,g4=42,xpe=43,Spe=53,Epe=54,Mpe=55,Ape=56,Tpe=132,Cpe=301,Ipe=302,Ppe=400,y4=421,Rpe=444,Dpe=445,Lpe=446,Npe=447,Ope=448,Upe=449,kpe=454,Bpe=460,Fpe=461,$pe=465,zpe=466,Vpe=480,Hpe=481,Gpe=443,Wpe=477,qpe=478,Kpe=479,Xpe=277,Ype=275,Zpe=276,Jpe=280,jpe=281,Qpe=290,eme=777;function KI(r){return e=>ae(e,r)}function XI(r){return e=>Se(e,r)}function wd(r){return new DataView(r.buffer).getUint16(r.byteOffset).toString()}function Vl(r){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof r=="string"?parseInt(r):r),new Uint8Array(e)}function tme(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=Se(e[0],"base32"),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=Vl(n);return ut([t,i],t.length+i.length)}function nme(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=Rn.decode(`b${e[0]}`),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=Vl(n);return ut([t,i],t.length+i.length)}function YI(r){const e=r.subarray(0,r.length-2),t=r.subarray(r.length-2),n=ae(e,"base32"),i=wd(t);return`${n}:${i}`}const b4=function(r){r=r.toString().trim();const e=new Uint8Array(4);return r.split(/\./g).forEach((t,n)=>{const i=parseInt(t,10);if(isNaN(i)||i<0||i>255)throw new xi("Invalid byte value in IP address");e[n]=i}),e},rme=function(r){let e=0;r=r.toString().trim();const t=r.split(":",8);let n;for(n=0;n<t.length;n++){const s=$t(t[n]);let o;s&&(o=b4(t[n]),t[n]=ae(o.subarray(0,2),"base16")),o!=null&&++n<8&&t.splice(n,0,ae(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(n=0;n<t.length&&t[n]!=="";n++);const s=[n,1];for(n=9-t.length;n>0;n--)s.push("0");t.splice.apply(t,s)}const i=new Uint8Array(e+16);for(n=0;n<t.length;n++){t[n]===""&&(t[n]="0");const s=parseInt(t[n],16);if(isNaN(s)||s<0||s>65535)throw new xi("Invalid byte value in IP address");i[e++]=s>>8&255,i[e++]=s&255}return i},ime=function(r){if(r.byteLength!==4)throw new xi("IPv4 address was incorrect length");const e=[];for(let t=0;t<r.byteLength;t++)e.push(r[t]);return e.join(".")},sme=function(r){if(r.byteLength!==16)throw new xi("IPv6 address was incorrect length");const e=[];for(let n=0;n<r.byteLength;n+=2){const i=r[n],s=r[n+1],o=`${i.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const n=new URL(`http://[${t}]`);return n.hostname.substring(1,n.hostname.length-1)}catch{throw new xi(`Invalid IPv6 address "${t}"`)}};function ome(r){try{const e=new URL(`http://[${r}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new xi(`Invalid IPv6 address "${r}"`)}}const jw=Object.values(oi).map(r=>r.decoder),ame=(function(){let r=jw[0].or(jw[1]);return jw.slice(2).forEach(e=>r=r.or(e)),r})();function cme(r){return ame.decode(r)}function lme(r){return e=>r.encoder.encode(e)}function ume(r){if(parseInt(r).toString()!==r)throw new Nf("Value must be an integer")}function hme(r){if(r<0)throw new Nf("Value must be a positive integer, or zero")}function dme(r){return e=>{if(e>r)throw new Nf(`Value must be smaller than or equal to ${r}`)}}function fme(...r){return e=>{for(const t of r)t(e)}}const Qm=fme(ume,hme,dme(65535)),ir=-1;let pme=class{constructor(){f(this,"protocolsByCode",new Map);f(this,"protocolsByName",new Map)}getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new ype(`Protocol ${e} was unknown`);return t}addProtocol(e){var t;this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),(t=e.aliases)==null||t.forEach(n=>{this.protocolsByName.set(n,e)})}removeProtocol(e){var n;const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),(n=t.aliases)==null||n.forEach(i=>{this.protocolsByName.delete(i)}))}};const Th=new pme,mme=[{code:bpe,name:"ip4",size:32,valueToBytes:b4,bytesToValue:ime,validate:r=>{if(!$t(r))throw new Nf(`Invalid IPv4 address "${r}"`)}},{code:wpe,name:"tcp",size:16,valueToBytes:Vl,bytesToValue:wd,validate:Qm},{code:vpe,name:"udp",size:16,valueToBytes:Vl,bytesToValue:wd,validate:Qm},{code:_pe,name:"dccp",size:16,valueToBytes:Vl,bytesToValue:wd,validate:Qm},{code:rE,name:"ip6",size:128,valueToBytes:rme,bytesToValue:sme,stringToValue:ome,validate:r=>{if(!Ai(r))throw new Nf(`Invalid IPv6 address "${r}"`)}},{code:g4,name:"ip6zone",size:ir},{code:xpe,name:"ipcidr",size:8,bytesToValue:KI("base10"),valueToBytes:XI("base10")},{code:Spe,name:"dns",size:ir},{code:Epe,name:"dns4",size:ir},{code:Mpe,name:"dns6",size:ir},{code:Ape,name:"dnsaddr",size:ir},{code:Tpe,name:"sctp",size:16,valueToBytes:Vl,bytesToValue:wd,validate:Qm},{code:Cpe,name:"udt"},{code:Ipe,name:"utp"},{code:Ppe,name:"unix",size:ir,stringToValue:r=>decodeURIComponent(r),valueToString:r=>encodeURIComponent(r)},{code:y4,name:"p2p",aliases:["ipfs"],size:ir,bytesToValue:KI("base58btc"),valueToBytes:r=>r.startsWith("Q")||r.startsWith("1")?XI("base58btc")(r):Ze.parse(r).multihash.bytes},{code:Rpe,name:"onion",size:96,bytesToValue:YI,valueToBytes:tme},{code:Dpe,name:"onion3",size:296,bytesToValue:YI,valueToBytes:nme},{code:Lpe,name:"garlic64",size:ir},{code:Npe,name:"garlic32",size:ir},{code:Ope,name:"tls"},{code:Upe,name:"sni",size:ir},{code:kpe,name:"noise"},{code:Bpe,name:"quic"},{code:Fpe,name:"quic-v1"},{code:$pe,name:"webtransport"},{code:zpe,name:"certhash",size:ir,bytesToValue:lme(Mi),valueToBytes:cme},{code:Vpe,name:"http"},{code:Hpe,name:"http-path",size:ir,stringToValue:r=>`/${decodeURIComponent(r)}`,valueToString:r=>encodeURIComponent(r.substring(1))},{code:Gpe,name:"https"},{code:Wpe,name:"ws"},{code:qpe,name:"wss"},{code:Kpe,name:"p2p-websocket-star"},{code:Xpe,name:"p2p-stardust"},{code:Ype,name:"p2p-webrtc-star"},{code:Zpe,name:"p2p-webrtc-direct"},{code:Jpe,name:"webrtc-direct"},{code:jpe,name:"webrtc"},{code:Qpe,name:"p2p-circuit"},{code:eme,name:"memory",size:ir}];mme.forEach(r=>{Th.addProtocol(r)});function gme(r){var n;const e=[];let t=0;for(;t<r.length;){const i=Yt(r,t),s=Th.getProtocol(i),o=Ue(i),a=vme(s,r,t+o);let c=0;a>0&&s.size===ir&&(c=Ue(a));const l=o+c+a,u={code:i,name:s.name,bytes:r.subarray(t,t+l)};if(a>0){const h=t+o+c,d=r.subarray(h,h+a);u.value=((n=s.bytesToValue)==null?void 0:n.call(s,d))??ae(d)}e.push(u),t+=l}return e}function yme(r){var n;let e=0;const t=[];for(const i of r){if(i.bytes==null){const s=Th.getProtocol(i.code),o=Ue(i.code);let a,c=0,l=0;i.value!=null&&(a=((n=s.valueToBytes)==null?void 0:n.call(s,i.value))??Se(i.value),c=a.byteLength,s.size===ir&&(l=Ue(c)));const u=new Uint8Array(o+l+c);let h=0;sn(i.code,u,h),h+=o,a!=null&&(s.size===ir&&(sn(c,u,h),h+=l),u.set(a,h)),i.bytes=u}t.push(i.bytes),e+=i.bytes.byteLength}return ut(t,e)}function bme(r){var s;if(r.charAt(0)!=="/")throw new xi('String multiaddr must start with "/"');const e=[];let t="protocol",n="",i="";for(let o=1;o<r.length;o++){const a=r.charAt(o);a!=="/"&&(t==="protocol"?i+=r.charAt(o):n+=r.charAt(o));const c=o===r.length-1;if(a==="/"||c){const l=Th.getProtocol(i);if(t==="protocol"){if(l.size==null||l.size===0){e.push({code:l.code,name:l.name}),n="",i="",t="protocol";continue}else if(c)throw new xi(`Component ${i} was missing value`);t="value"}else if(t==="value"){const u={code:l.code,name:l.name};if(l.size!=null&&l.size!==0){if(n==="")throw new xi(`Component ${i} was missing value`);u.value=((s=l.stringToValue)==null?void 0:s.call(l,n))??n}e.push(u),n="",i="",t="protocol"}}}if(i!==""&&n!=="")throw new xi("Incomplete multiaddr");return e}function wme(r){return`/${r.flatMap(e=>{var n;if(e.value==null)return e.name;const t=Th.getProtocol(e.code);if(t==null)throw new xi(`Unknown protocol code ${e.code}`);return[e.name,((n=t.valueToString)==null?void 0:n.call(t,e.value))??e.value]}).join("/")}`}function vme(r,e,t){return r.size==null||r.size===0?0:r.size>0?r.size/8:Yt(e,t)}const _me=Symbol.for("nodejs.util.inspect.custom"),w4=Symbol.for("@multiformats/multiaddr");function xme(r){if(r==null&&(r="/"),Mme(r))return r.getComponents();if(r instanceof Uint8Array)return gme(r);if(typeof r=="string")return r=r.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),r===""&&(r="/"),bme(r);if(Array.isArray(r))return r;throw new xi("Must be a string, Uint8Array, Component[], or another Multiaddr")}var aD,Vi,Iu,Pu,go;let Sme=(go=class{constructor(e="/",t={}){f(this,aD,!0);xe(this,Vi);xe(this,Iu);xe(this,Pu);_e(this,Vi,xme(e)),t.validate!==!1&&Eme(this)}get bytes(){return N(this,Pu)==null&&_e(this,Pu,yme(N(this,Vi))),N(this,Pu)}toString(){return N(this,Iu)==null&&_e(this,Iu,wme(N(this,Vi))),N(this,Iu)}toJSON(){return this.toString()}getComponents(){return[...N(this,Vi).map(e=>({...e}))]}encapsulate(e){const t=new go(e);return new go([...N(this,Vi),...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),n=this.toString(),i=n.lastIndexOf(t);if(i<0)throw new gpe(`Address ${this.toString()} does not contain subaddress: ${t}`);return new go(n.slice(0,i),{validate:!1})}decapsulateCode(e){let t;for(let n=N(this,Vi).length-1;n>-1;n--)if(N(this,Vi)[n].code===e){t=n;break}return new go(N(this,Vi).slice(0,t),{validate:!1})}equals(e){return We(this.bytes,e.bytes)}[(aD=w4,_me)](){return`Multiaddr(${this.toString()})`}},Vi=new WeakMap,Iu=new WeakMap,Pu=new WeakMap,go);function Eme(r){r.getComponents().forEach(e=>{var n;const t=Th.getProtocol(e.code);e.value!=null&&((n=t.validate)==null||n.call(t,e.value))})}function Mme(r){return!!(r!=null&&r[w4])}function Pg(r){return new Sme(r)}const Ame="0.1.0",Tme="id",Cme="1.0.0",Ime=1024*8;var Vy;(function(r){let e;r.codec=()=>(e==null&&(e=Gt((t,n,i={})=>{if(i.lengthDelimited!==!1&&n.fork(),t.protocolVersion!=null&&(n.uint32(42),n.string(t.protocolVersion)),t.agentVersion!=null&&(n.uint32(50),n.string(t.agentVersion)),t.publicKey!=null&&(n.uint32(10),n.bytes(t.publicKey)),t.listenAddrs!=null)for(const s of t.listenAddrs)n.uint32(18),n.bytes(s);if(t.observedAddr!=null&&(n.uint32(34),n.bytes(t.observedAddr)),t.protocols!=null)for(const s of t.protocols)n.uint32(26),n.string(s);t.signedPeerRecord!=null&&(n.uint32(66),n.bytes(t.signedPeerRecord)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{var a,c;const s={listenAddrs:[],protocols:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const l=t.uint32();switch(l>>>3){case 5:{s.protocolVersion=t.string();break}case 6:{s.agentVersion=t.string();break}case 1:{s.publicKey=t.bytes();break}case 2:{if(((a=i.limits)==null?void 0:a.listenAddrs)!=null&&s.listenAddrs.length===i.limits.listenAddrs)throw new Cs('Decode error - map field "listenAddrs" had too many elements');s.listenAddrs.push(t.bytes());break}case 4:{s.observedAddr=t.bytes();break}case 3:{if(((c=i.limits)==null?void 0:c.protocols)!=null&&s.protocols.length===i.limits.protocols)throw new Cs('Decode error - map field "protocols" had too many elements');s.protocols.push(t.string());break}case 8:{s.signedPeerRecord=t.bytes();break}default:{t.skipType(l&7);break}}}return s})),e),r.encode=t=>Ht(t,r.codec()),r.decode=(t,n)=>Vt(t,r.codec(),n)})(Vy||(Vy={}));const v4=Symbol.for("nodejs.util.inspect.custom"),Pme=114;var cD;let BM=class{constructor(e){f(this,"type");f(this,"multihash");f(this,"publicKey");f(this,"string");f(this,cD,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=gt.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return Ze.createV1(Pme,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return We(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return We(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(cD=m4,v4)](){return`PeerId(${this.toString()})`}},_4=class extends BM{constructor(t){super({...t,type:"RSA"});f(this,"type","RSA");f(this,"publicKey");this.publicKey=t.publicKey}},x4=class extends BM{constructor(t){super({...t,type:"Ed25519"});f(this,"type","Ed25519");f(this,"publicKey");this.publicKey=t.publicKey}},S4=class extends BM{constructor(t){super({...t,type:"secp256k1"});f(this,"type","secp256k1");f(this,"publicKey");this.publicKey=t.publicKey}};const Rme=2336;var lD,uD;let E4=class{constructor(e){f(this,"type","url");f(this,"multihash");f(this,"publicKey");f(this,"url");f(this,lD,!0);this.url=e.toString(),this.multihash=dn.digest(Se(this.url))}[(uD=v4,lD=m4,uD)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return Ze.createV1(Rme,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=ae(e)),e.toString()===this.toString())}};const Dme=114,ZI=2336;function Lme(r){if(r.type==="Ed25519")return new x4({multihash:r.toCID().multihash,publicKey:r});if(r.type==="secp256k1")return new S4({multihash:r.toCID().multihash,publicKey:r});if(r.type==="RSA")return new _4({multihash:r.toCID().multihash,publicKey:r});throw new ppe}function Nme(r){if(Ume(r))return new _4({multihash:r});if(Ome(r))try{const e=No(r);if(e.type==="Ed25519")return new x4({multihash:r,publicKey:e});if(e.type==="secp256k1")return new S4({multihash:r,publicKey:e})}catch{const t=ae(r.digest);return new E4(new URL(t))}throw new fpe("Supplied PeerID Multihash is invalid")}function M4(r){if((r==null?void 0:r.multihash)==null||r.version==null||r.version===1&&r.code!==Dme&&r.code!==ZI)throw new dpe("Supplied PeerID CID is invalid");if(r.code===ZI){const e=ae(r.multihash.digest);return new E4(new URL(e))}return Nme(r.multihash)}function Ome(r){return r.code===dn.code}function Ume(r){return r.code===Ns.code}const Zs={protocolPrefix:"ipfs",timeout:5e3,maxInboundStreams:1,maxOutboundStreams:1,maxObservedAddresses:10,maxMessageSize:Ime,runOnConnectionOpen:!0,runOnLimitedConnection:!0};function kme(r){if(r!=null&&r.length>0)try{return Pg(r)}catch{}}async function Bme(r,e,t,n,i){if(t("received identify from %p",n.remotePeer),i==null)throw new ma("message was null or undefined");const s={};if(i.listenAddrs.length>0&&(s.addresses=i.listenAddrs.map(c=>({isCertified:!1,multiaddr:Pg(c)}))),i.protocols.length>0&&(s.protocols=i.protocols),i.publicKey!=null){const c=Io(i.publicKey);if(!Lme(c).equals(n.remotePeer))throw new ma("public key did not match remote PeerId");s.publicKey=c}let o;if(i.signedPeerRecord!=null){t.trace("received signedPeerRecord from %p",n.remotePeer);let c=i.signedPeerRecord;const l=await Fc.openAndCertify(c,xo.DOMAIN);let u=xo.createFromProtobuf(l.payload);const h=M4(l.publicKey.toCID());if(!u.peerId.equals(h))throw new ma("signing key does not match PeerId in the PeerRecord");if(!n.remotePeer.equals(u.peerId))throw new ma("signing key does not match remote PeerId");let d;try{d=await r.get(u.peerId)}catch(m){if(m.name!=="NotFoundError")throw m}if(d!=null&&(s.metadata=d.metadata,d.peerRecordEnvelope!=null)){const m=Fc.createFromProtobuf(d.peerRecordEnvelope),p=xo.createFromProtobuf(m.payload);p.seqNumber>=u.seqNumber&&(t("sequence number was lower or equal to existing sequence number - stored: %d received: %d",p.seqNumber,u.seqNumber),u=p,c=d.peerRecordEnvelope)}s.peerRecordEnvelope=c,s.addresses=u.multiaddrs.map(m=>({isCertified:!0,multiaddr:m})),o={seq:u.seqNumber,addresses:u.multiaddrs}}else t("%p did not send a signed peer record",n.remotePeer);if(t.trace("patching %p with",n.remotePeer,s),await r.patch(n.remotePeer,s),i.agentVersion!=null||i.protocolVersion!=null){const c={};i.agentVersion!=null&&(c.AgentVersion=Se(i.agentVersion)),i.protocolVersion!=null&&(c.ProtocolVersion=Se(i.protocolVersion)),t.trace("merging %p metadata",n.remotePeer,c),await r.merge(n.remotePeer,{metadata:c})}const a={peerId:n.remotePeer,protocolVersion:i.protocolVersion,agentVersion:i.agentVersion,publicKey:i.publicKey,listenAddrs:i.listenAddrs.map(c=>Pg(c)),observedAddr:i.observedAddr==null?void 0:Pg(i.observedAddr),protocols:i.protocols,signedPeerRecord:o,connection:n};return e.safeDispatchEvent("peer:identify",{detail:a}),a}class Fme{constructor(e,t){f(this,"host");f(this,"components");f(this,"protocol");f(this,"started");f(this,"timeout");f(this,"maxInboundStreams");f(this,"maxOutboundStreams");f(this,"maxMessageSize");f(this,"maxObservedAddresses");f(this,"runOnLimitedConnection");f(this,"log");this.protocol=t.protocol,this.started=!1,this.components=e,this.log=t.log,this.timeout=t.timeout??Zs.timeout,this.maxInboundStreams=t.maxInboundStreams??Zs.maxInboundStreams,this.maxOutboundStreams=t.maxOutboundStreams??Zs.maxOutboundStreams,this.maxMessageSize=t.maxMessageSize??Zs.maxMessageSize,this.maxObservedAddresses=t.maxObservedAddresses??Zs.maxObservedAddresses,this.runOnLimitedConnection=t.runOnLimitedConnection??Zs.runOnLimitedConnection,this.host={protocolVersion:`${t.protocolPrefix??Zs.protocolPrefix}/${Ame}`,agentVersion:e.nodeInfo.userAgent},this.handleProtocol=this.handleProtocol.bind(this)}isStarted(){return this.started}async start(){this.started||(await this.components.peerStore.merge(this.components.peerId,{metadata:{AgentVersion:Se(this.host.agentVersion),ProtocolVersion:Se(this.host.protocolVersion)}}),await this.components.registrar.handle(this.protocol,this.handleProtocol,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0)}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}}var hD,dD;class $me extends(dD=Fme,hD=mpe,dD){constructor(t,n={}){super(t,{...n,protocol:`/${n.protocolPrefix??Zs.protocolPrefix}/${Tme}/${Cme}`,log:t.logger.forComponent("libp2p:identify")});f(this,hD,["@libp2p/identify"]);(n.runOnConnectionOpen??Zs.runOnConnectionOpen)&&t.events.addEventListener("connection:open",i=>{const s=i.detail;this.identify(s).catch(()=>{})})}async _identify(t,n={}){let i,s;if(n.signal==null){const o=AbortSignal.timeout(this.timeout);n={...n,signal:o}}this.log("run identify on new connection %a",t.remoteAddr);try{i=await t.newStream(this.protocol,{...n,runOnLimitedConnection:this.runOnLimitedConnection}),s=i.log.newScope("identify");const o=Ma(i,{maxDataLength:this.maxMessageSize}).pb(Vy),a=await o.read(n);return await o.unwrap().unwrap().close(n),a}catch(o){throw s==null||s.error("identify failed - %e",o),i==null||i.abort(o),o}}async identify(t,n={}){const i=await this._identify(t,n),{publicKey:s,protocols:o,observedAddr:a}=i;if(s==null)throw new ma("Public key was missing from identify message");const c=Io(s),l=M4(c.toCID());if(!t.remotePeer.equals(l))throw new ma("Identified peer does not match the expected peer");if(this.components.peerId.equals(l))throw new ma("Identified peer is our own peer id?");return this.maybeAddObservedAddress(a),this.log("completed for peer %p and protocols %o",l,o),Bme(this.components.peerStore,this.components.events,this.log,t,i)}maybeAddObservedAddress(t){const n=kme(t);if(n==null||(this.log.trace("our observed address was %a",n),Zu(n)))return;const i=n.getComponents();if((i[0].code===rE||i[0].code===g4&&i[1].code===rE)&&!dX(n)){this.log.trace("our observed address was IPv6 but not a global unicast address");return}uy.exactMatch(n)||(this.log.trace("storing the observed address"),this.components.addressManager.addObservedAddr(n))}async handleProtocol(t,n){const i=t.log.newScope("identify");i("responding to identify");const s=AbortSignal.timeout(this.timeout),o=await this.components.peerStore.get(this.components.peerId,{signal:s}),a=this.components.addressManager.getAddresses().map(h=>h.decapsulateCode(y4));let c=o.peerRecordEnvelope;if(a.length>0&&c==null){const h=new xo({peerId:this.components.peerId,multiaddrs:a});c=(await Fc.seal(h,this.components.privateKey,{signal:s})).marshal().subarray()}let l=n.remoteAddr.bytes;Uee.matches(n.remoteAddr)||(l=void 0);const u=Ma(t).pb(Vy);i("send response"),await u.write({protocolVersion:this.host.protocolVersion,agentVersion:this.host.agentVersion,publicKey:Ms(this.components.privateKey.publicKey),listenAddrs:a.map(h=>h.bytes),signedPeerRecord:c,observedAddr:l,protocols:o.protocols},{signal:s}),i("close write"),await u.unwrap().unwrap().close({signal:s})}}function zme(r={}){return e=>new $me(e,r)}class A4 extends Error{constructor(e="Protocol error"){super(e),this.name="ProtocolError"}}f(A4,"name","ProtocolError");class T4 extends Error{constructor(e="Timed out"){super(e),this.name="TimeoutError"}}f(T4,"name","TimeoutError");const Vme=Symbol.for("@libp2p/service-capabilities"),JI=32,Hme="1.0.0",Gme="ping",Wme="ipfs",qme=1e4,Kme=2,Xme=1;var fD,pD;pD=Symbol.toStringTag,fD=Vme;class Yme{constructor(e,t={}){f(this,"protocol");f(this,"components");f(this,"started");f(this,"timeout");f(this,"maxInboundStreams");f(this,"maxOutboundStreams");f(this,"runOnLimitedConnection");f(this,pD,"@libp2p/ping");f(this,fD,["@libp2p/ping"]);this.components=e,this.started=!1,this.protocol=`/${t.protocolPrefix??Wme}/${Gme}/${Hme}`,this.timeout=t.timeout??qme,this.maxInboundStreams=t.maxInboundStreams??Kme,this.maxOutboundStreams=t.maxOutboundStreams??Xme,this.runOnLimitedConnection=t.runOnLimitedConnection??!0,this.handlePing=this.handlePing.bind(this)}async start(){await this.components.registrar.handle(this.protocol,this.handlePing,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}isStarted(){return this.started}async handlePing(e,t){const n=e.log.newScope("ping");n.trace("ping from %p",t.remotePeer);const i=AbortSignal.timeout(this.timeout);i.addEventListener("abort",()=>{e.abort(new T4("Ping timed out"))});const s=Date.now();for await(const o of e){if(e.status!=="open"){n("stream status changed to %s",e.status);break}e.send(o)||(n("waiting for stream to drain"),await Dn(e,"drain",{rejectionEvents:["close"],signal:i}),n("stream drained"))}n("ping from %p complete in %dms",t.remotePeer,Date.now()-s),await e.close({signal:i})}async ping(e,t={}){const n=D1(JI),i=await this.components.connectionManager.openStream(e,this.protocol,{runOnLimitedConnection:this.runOnLimitedConnection,...t}),s=i.log.newScope("ping");try{const o=Date.now(),a=Promise.withResolvers(),c=new vt,l=u=>{if(c.append(u.data),c.byteLength===JI){i.removeEventListener("message",l);const h=Date.now()-o;Promise.all([i.closeRead(t)]).then(()=>{if(We(n,c.subarray()))a.resolve(h);else throw new A4(`Received wrong ping ack after ${h}ms`)}).catch(d=>{i.abort(d),a.reject(d)})}};return i.addEventListener("message",l),i.send(n),await i.close(t),await rs(a.promise,t.signal)}catch(o){throw s.error("error while pinging %o - %e",e,o),i==null||i.abort(o),o}finally{i==null||i.close()}}}function Zme(r={}){return e=>new Yme(e,r)}var K_;let Jme=(K_=class extends Error{constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}},f(K_,"name","InvalidParametersError"),K_);var X_;let jme=(X_=class extends Error{constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}},f(X_,"name","InvalidCIDError"),X_);var Y_;let Qme=(Y_=class extends Error{constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}},f(Y_,"name","InvalidMultihashError"),Y_);const ege=Symbol.for("@libp2p/peer-discovery"),C4=Symbol.for("@libp2p/peer-id"),tge=Symbol.for("@libp2p/service-capabilities"),I4=Symbol.for("nodejs.util.inspect.custom"),nge=114;var mD;let FM=class{constructor(e){f(this,"type");f(this,"multihash");f(this,"publicKey");f(this,"string");f(this,mD,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=gt.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return Ze.createV1(nge,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return We(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return We(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(mD=C4,I4)](){return`PeerId(${this.toString()})`}},rge=class extends FM{constructor(t){super({...t,type:"RSA"});f(this,"type","RSA");f(this,"publicKey");this.publicKey=t.publicKey}},ige=class extends FM{constructor(t){super({...t,type:"Ed25519"});f(this,"type","Ed25519");f(this,"publicKey");this.publicKey=t.publicKey}},sge=class extends FM{constructor(t){super({...t,type:"secp256k1"});f(this,"type","secp256k1");f(this,"publicKey");this.publicKey=t.publicKey}};const oge=2336;var gD,yD;let P4=class{constructor(e){f(this,"type","url");f(this,"multihash");f(this,"publicKey");f(this,"url");f(this,gD,!0);this.url=e.toString(),this.multihash=dn.digest(Se(this.url))}[(yD=I4,gD=C4,yD)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return Ze.createV1(oge,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=ae(e)),e.toString()===this.toString())}};const age=114,jI=2336;function cge(r,e){let t;if(r.charAt(0)==="1"||r.charAt(0)==="Q")t=Lo(gt.decode(`z${r}`));else{if(r.startsWith("k51qzi5uqu5")||r.startsWith("kzwfwjn5ji4")||r.startsWith("k2k4r8")||r.startsWith("bafz"))return lge(Ze.parse(r));throw new Jme('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return R4(t)}function R4(r){if(hge(r))return new rge({multihash:r});if(uge(r))try{const e=No(r);if(e.type==="Ed25519")return new ige({multihash:r,publicKey:e});if(e.type==="secp256k1")return new sge({multihash:r,publicKey:e})}catch{const t=ae(r.digest);return new P4(new URL(t))}throw new Qme("Supplied PeerID Multihash is invalid")}function lge(r){if((r==null?void 0:r.multihash)==null||r.version==null||r.version===1&&r.code!==age&&r.code!==jI)throw new jme("Supplied PeerID CID is invalid");if(r.code===jI){const e=ae(r.multihash.digest);return new P4(new URL(e))}return R4(r.multihash)}function uge(r){return r.code===dn.code}function hge(r){return r.code===Ns.code}var Z_;let Si=(Z_=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidMultiaddrError")}},f(Z_,"name","InvalidMultiaddrError"),Z_);var J_;let Of=(J_=class extends Error{constructor(){super(...arguments);f(this,"name","ValidationError")}},f(J_,"name","ValidationError"),J_);var j_;let dge=(j_=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidParametersError")}},f(j_,"name","InvalidParametersError"),j_);var Q_;let fge=(Q_=class extends Error{constructor(){super(...arguments);f(this,"name","UnknownProtocolError")}},f(Q_,"name","UnknownProtocolError"),Q_);const pge=4,mge=6,gge=273,yge=33,bge=41,wge=42,vge=43,_ge=53,xge=54,Sge=55,Ege=56,Mge=132,Age=301,Tge=302,Cge=400,iE=421,Ige=444,Pge=445,Rge=446,Dge=447,Lge=448,Nge=449,Oge=454,Uge=460,kge=461,Bge=465,Fge=466,$ge=480,zge=481,Vge=443,Hge=477,Gge=478,Wge=479,qge=277,Kge=275,Xge=276,Yge=280,Zge=281,Jge=290,jge=777;function QI(r){return e=>ae(e,r)}function eP(r){return e=>Se(e,r)}function vd(r){return new DataView(r.buffer).getUint16(r.byteOffset).toString()}function Hl(r){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof r=="string"?parseInt(r):r),new Uint8Array(e)}function Qge(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=Se(e[0],"base32"),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=Hl(n);return ut([t,i],t.length+i.length)}function eye(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=Rn.decode(`b${e[0]}`),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=Hl(n);return ut([t,i],t.length+i.length)}function tP(r){const e=r.subarray(0,r.length-2),t=r.subarray(r.length-2),n=ae(e,"base32"),i=vd(t);return`${n}:${i}`}const D4=function(r){r=r.toString().trim();const e=new Uint8Array(4);return r.split(/\./g).forEach((t,n)=>{const i=parseInt(t,10);if(isNaN(i)||i<0||i>255)throw new Si("Invalid byte value in IP address");e[n]=i}),e},tye=function(r){let e=0;r=r.toString().trim();const t=r.split(":",8);let n;for(n=0;n<t.length;n++){const s=$t(t[n]);let o;s&&(o=D4(t[n]),t[n]=ae(o.subarray(0,2),"base16")),o!=null&&++n<8&&t.splice(n,0,ae(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(n=0;n<t.length&&t[n]!=="";n++);const s=[n,1];for(n=9-t.length;n>0;n--)s.push("0");t.splice.apply(t,s)}const i=new Uint8Array(e+16);for(n=0;n<t.length;n++){t[n]===""&&(t[n]="0");const s=parseInt(t[n],16);if(isNaN(s)||s<0||s>65535)throw new Si("Invalid byte value in IP address");i[e++]=s>>8&255,i[e++]=s&255}return i},nye=function(r){if(r.byteLength!==4)throw new Si("IPv4 address was incorrect length");const e=[];for(let t=0;t<r.byteLength;t++)e.push(r[t]);return e.join(".")},rye=function(r){if(r.byteLength!==16)throw new Si("IPv6 address was incorrect length");const e=[];for(let n=0;n<r.byteLength;n+=2){const i=r[n],s=r[n+1],o=`${i.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const n=new URL(`http://[${t}]`);return n.hostname.substring(1,n.hostname.length-1)}catch{throw new Si(`Invalid IPv6 address "${t}"`)}};function iye(r){try{const e=new URL(`http://[${r}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new Si(`Invalid IPv6 address "${r}"`)}}const Qw=Object.values(oi).map(r=>r.decoder),sye=(function(){let r=Qw[0].or(Qw[1]);return Qw.slice(2).forEach(e=>r=r.or(e)),r})();function oye(r){return sye.decode(r)}function aye(r){return e=>r.encoder.encode(e)}function cye(r){if(parseInt(r).toString()!==r)throw new Of("Value must be an integer")}function lye(r){if(r<0)throw new Of("Value must be a positive integer, or zero")}function uye(r){return e=>{if(e>r)throw new Of(`Value must be smaller than or equal to ${r}`)}}function hye(...r){return e=>{for(const t of r)t(e)}}const eg=hye(cye,lye,uye(65535)),sr=-1;let dye=class{constructor(){f(this,"protocolsByCode",new Map);f(this,"protocolsByName",new Map)}getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new fge(`Protocol ${e} was unknown`);return t}addProtocol(e){var t;this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),(t=e.aliases)==null||t.forEach(n=>{this.protocolsByName.set(n,e)})}removeProtocol(e){var n;const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),(n=t.aliases)==null||n.forEach(i=>{this.protocolsByName.delete(i)}))}};const Ch=new dye,fye=[{code:pge,name:"ip4",size:32,valueToBytes:D4,bytesToValue:nye,validate:r=>{if(!$t(r))throw new Of(`Invalid IPv4 address "${r}"`)}},{code:mge,name:"tcp",size:16,valueToBytes:Hl,bytesToValue:vd,validate:eg},{code:gge,name:"udp",size:16,valueToBytes:Hl,bytesToValue:vd,validate:eg},{code:yge,name:"dccp",size:16,valueToBytes:Hl,bytesToValue:vd,validate:eg},{code:bge,name:"ip6",size:128,valueToBytes:tye,bytesToValue:rye,stringToValue:iye,validate:r=>{if(!Ai(r))throw new Of(`Invalid IPv6 address "${r}"`)}},{code:wge,name:"ip6zone",size:sr},{code:vge,name:"ipcidr",size:8,bytesToValue:QI("base10"),valueToBytes:eP("base10")},{code:_ge,name:"dns",size:sr},{code:xge,name:"dns4",size:sr},{code:Sge,name:"dns6",size:sr},{code:Ege,name:"dnsaddr",size:sr},{code:Mge,name:"sctp",size:16,valueToBytes:Hl,bytesToValue:vd,validate:eg},{code:Age,name:"udt"},{code:Tge,name:"utp"},{code:Cge,name:"unix",size:sr,stringToValue:r=>decodeURIComponent(r),valueToString:r=>encodeURIComponent(r)},{code:iE,name:"p2p",aliases:["ipfs"],size:sr,bytesToValue:QI("base58btc"),valueToBytes:r=>r.startsWith("Q")||r.startsWith("1")?eP("base58btc")(r):Ze.parse(r).multihash.bytes},{code:Ige,name:"onion",size:96,bytesToValue:tP,valueToBytes:Qge},{code:Pge,name:"onion3",size:296,bytesToValue:tP,valueToBytes:eye},{code:Rge,name:"garlic64",size:sr},{code:Dge,name:"garlic32",size:sr},{code:Lge,name:"tls"},{code:Nge,name:"sni",size:sr},{code:Oge,name:"noise"},{code:Uge,name:"quic"},{code:kge,name:"quic-v1"},{code:Bge,name:"webtransport"},{code:Fge,name:"certhash",size:sr,bytesToValue:aye(Mi),valueToBytes:oye},{code:$ge,name:"http"},{code:zge,name:"http-path",size:sr,stringToValue:r=>`/${decodeURIComponent(r)}`,valueToString:r=>encodeURIComponent(r.substring(1))},{code:Vge,name:"https"},{code:Hge,name:"ws"},{code:Gge,name:"wss"},{code:Wge,name:"p2p-websocket-star"},{code:qge,name:"p2p-stardust"},{code:Kge,name:"p2p-webrtc-star"},{code:Xge,name:"p2p-webrtc-direct"},{code:Yge,name:"webrtc-direct"},{code:Zge,name:"webrtc"},{code:Jge,name:"p2p-circuit"},{code:jge,name:"memory",size:sr}];fye.forEach(r=>{Ch.addProtocol(r)});function pye(r){var n;const e=[];let t=0;for(;t<r.length;){const i=Yt(r,t),s=Ch.getProtocol(i),o=Ue(i),a=bye(s,r,t+o);let c=0;a>0&&s.size===sr&&(c=Ue(a));const l=o+c+a,u={code:i,name:s.name,bytes:r.subarray(t,t+l)};if(a>0){const h=t+o+c,d=r.subarray(h,h+a);u.value=((n=s.bytesToValue)==null?void 0:n.call(s,d))??ae(d)}e.push(u),t+=l}return e}function mye(r){var n;let e=0;const t=[];for(const i of r){if(i.bytes==null){const s=Ch.getProtocol(i.code),o=Ue(i.code);let a,c=0,l=0;i.value!=null&&(a=((n=s.valueToBytes)==null?void 0:n.call(s,i.value))??Se(i.value),c=a.byteLength,s.size===sr&&(l=Ue(c)));const u=new Uint8Array(o+l+c);let h=0;sn(i.code,u,h),h+=o,a!=null&&(s.size===sr&&(sn(c,u,h),h+=l),u.set(a,h)),i.bytes=u}t.push(i.bytes),e+=i.bytes.byteLength}return ut(t,e)}function gye(r){var s;if(r.charAt(0)!=="/")throw new Si('String multiaddr must start with "/"');const e=[];let t="protocol",n="",i="";for(let o=1;o<r.length;o++){const a=r.charAt(o);a!=="/"&&(t==="protocol"?i+=r.charAt(o):n+=r.charAt(o));const c=o===r.length-1;if(a==="/"||c){const l=Ch.getProtocol(i);if(t==="protocol"){if(l.size==null||l.size===0){e.push({code:l.code,name:l.name}),n="",i="",t="protocol";continue}else if(c)throw new Si(`Component ${i} was missing value`);t="value"}else if(t==="value"){const u={code:l.code,name:l.name};if(l.size!=null&&l.size!==0){if(n==="")throw new Si(`Component ${i} was missing value`);u.value=((s=l.stringToValue)==null?void 0:s.call(l,n))??n}e.push(u),n="",i="",t="protocol"}}}if(i!==""&&n!=="")throw new Si("Incomplete multiaddr");return e}function yye(r){return`/${r.flatMap(e=>{var n;if(e.value==null)return e.name;const t=Ch.getProtocol(e.code);if(t==null)throw new Si(`Unknown protocol code ${e.code}`);return[e.name,((n=t.valueToString)==null?void 0:n.call(t,e.value))??e.value]}).join("/")}`}function bye(r,e,t){return r.size==null||r.size===0?0:r.size>0?r.size/8:Yt(e,t)}const wye=Symbol.for("nodejs.util.inspect.custom"),L4=Symbol.for("@multiformats/multiaddr");function vye(r){if(r==null&&(r="/"),Sye(r))return r.getComponents();if(r instanceof Uint8Array)return pye(r);if(typeof r=="string")return r=r.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),r===""&&(r="/"),gye(r);if(Array.isArray(r))return r;throw new Si("Must be a string, Uint8Array, Component[], or another Multiaddr")}var bD,Hi,Ru,Du,yo;let _ye=(yo=class{constructor(e="/",t={}){f(this,bD,!0);xe(this,Hi);xe(this,Ru);xe(this,Du);_e(this,Hi,vye(e)),t.validate!==!1&&xye(this)}get bytes(){return N(this,Du)==null&&_e(this,Du,mye(N(this,Hi))),N(this,Du)}toString(){return N(this,Ru)==null&&_e(this,Ru,yye(N(this,Hi))),N(this,Ru)}toJSON(){return this.toString()}getComponents(){return[...N(this,Hi).map(e=>({...e}))]}encapsulate(e){const t=new yo(e);return new yo([...N(this,Hi),...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),n=this.toString(),i=n.lastIndexOf(t);if(i<0)throw new dge(`Address ${this.toString()} does not contain subaddress: ${t}`);return new yo(n.slice(0,i),{validate:!1})}decapsulateCode(e){let t;for(let n=N(this,Hi).length-1;n>-1;n--)if(N(this,Hi)[n].code===e){t=n;break}return new yo(N(this,Hi).slice(0,t),{validate:!1})}equals(e){return We(this.bytes,e.bytes)}[(bD=L4,wye)](){return`Multiaddr(${this.toString()})`}},Hi=new WeakMap,Ru=new WeakMap,Du=new WeakMap,yo);function xye(r){r.getComponents().forEach(e=>{var n;const t=Ch.getProtocol(e.code);e.value!=null&&((n=t.validate)==null||n.call(t,e.value))})}function Sye(r){return!!(r!=null&&r[L4])}function Eye(r){return new _ye(r)}const Mye="bootstrap",Aye=50,Tye=1e3;var wD,vD,_D,xD;class N4 extends(xD=Pr,_D=ege,vD=Symbol.toStringTag,wD=tge,xD){constructor(t,n={list:[]}){if(n.list==null||n.list.length===0)throw new Error("Bootstrap requires a list of peer addresses");super();f(this,"log");f(this,"timer");f(this,"list");f(this,"timeout");f(this,"components");f(this,"_init");f(this,_D,this);f(this,vD,"@libp2p/bootstrap");f(this,wD,["@libp2p/peer-discovery"]);this.components=t,this.log=t.logger.forComponent("libp2p:bootstrap"),this.timeout=n.timeout??Tye,this.list=n.list.map(i=>Eye(i)).filter(i=>{var o;return cM.matches(i)?((o=i.getComponents().findLast(a=>a.code===iE))==null?void 0:o.value)==null?(this.log.error("invalid bootstrap multiaddr without peer id"),!1):!0:(this.log.error("invalid multiaddr %a",i),!1)}).map(i=>{var s;return{id:cge(((s=i.getComponents().findLast(o=>o.code===iE))==null?void 0:s.value)??""),multiaddrs:[i]}}),this._init=n}isStarted(){return!!this.timer}start(){this.isStarted()||(this.log("Starting bootstrap node discovery, discovering peers after %s ms",this.timeout),this.timer=setTimeout(()=>{this._discoverBootstrapPeers().catch(t=>{this.log.error("failed to discover bootstrap peers - %e",t)})},this.timeout))}async _discoverBootstrapPeers(){if(this.timer!=null)for(const t of this.list){if(await this.components.peerStore.merge(t.id,{tags:{[this._init.tagName??Mye]:{value:this._init.tagValue??Aye,ttl:this._init.tagTTL}},multiaddrs:t.multiaddrs}),this.timer==null)return;this.safeDispatchEvent("peer",{detail:t}),this.components.connectionManager.openConnection(t.id).catch(n=>{this.log.error("could not dial bootstrap peer %p - %e",t.id,n)})}}stop(){this.timer!=null&&clearTimeout(this.timer),this.timer=void 0}}f(N4,"tag","bootstrap");function Cye(r){return e=>new N4(e,r)}class O4 extends Error{constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}}f(O4,"name","UnsupportedKeyTypeError");const Iye=Symbol.for("@libp2p/peer-discovery"),Pye=Symbol.for("@libp2p/peer-id"),Rye=Symbol.for("nodejs.util.inspect.custom"),Dye=114;var SD;let $M=class{constructor(e){f(this,"type");f(this,"multihash");f(this,"publicKey");f(this,"string");f(this,SD,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=gt.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return Ze.createV1(Dye,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return We(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return We(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(SD=Pye,Rye)](){return`PeerId(${this.toString()})`}},Lye=class extends $M{constructor(t){super({...t,type:"RSA"});f(this,"type","RSA");f(this,"publicKey");this.publicKey=t.publicKey}},Nye=class extends $M{constructor(t){super({...t,type:"Ed25519"});f(this,"type","Ed25519");f(this,"publicKey");this.publicKey=t.publicKey}},Oye=class extends $M{constructor(t){super({...t,type:"secp256k1"});f(this,"type","secp256k1");f(this,"publicKey");this.publicKey=t.publicKey}};function Uye(r){if(r.type==="Ed25519")return new Nye({multihash:r.toCID().multihash,publicKey:r});if(r.type==="secp256k1")return new Oye({multihash:r.toCID().multihash,publicKey:r});if(r.type==="RSA")return new Lye({multihash:r.toCID().multihash,publicKey:r});throw new O4}var ex;let Ei=(ex=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidMultiaddrError")}},f(ex,"name","InvalidMultiaddrError"),ex);var tx;let Uf=(tx=class extends Error{constructor(){super(...arguments);f(this,"name","ValidationError")}},f(tx,"name","ValidationError"),tx);var nx;let kye=(nx=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidParametersError")}},f(nx,"name","InvalidParametersError"),nx);var rx;let Bye=(rx=class extends Error{constructor(){super(...arguments);f(this,"name","UnknownProtocolError")}},f(rx,"name","UnknownProtocolError"),rx);const Fye=4,$ye=6,zye=273,Vye=33,Hye=41,Gye=42,Wye=43,qye=53,Kye=54,Xye=55,Yye=56,Zye=132,Jye=301,jye=302,Qye=400,e0e=421,t0e=444,n0e=445,r0e=446,i0e=447,s0e=448,o0e=449,a0e=454,c0e=460,l0e=461,u0e=465,h0e=466,d0e=480,f0e=481,p0e=443,m0e=477,g0e=478,y0e=479,b0e=277,w0e=275,v0e=276,_0e=280,x0e=281,S0e=290,E0e=777;function nP(r){return e=>ae(e,r)}function rP(r){return e=>Se(e,r)}function _d(r){return new DataView(r.buffer).getUint16(r.byteOffset).toString()}function Gl(r){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof r=="string"?parseInt(r):r),new Uint8Array(e)}function M0e(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=Se(e[0],"base32"),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=Gl(n);return ut([t,i],t.length+i.length)}function A0e(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=Rn.decode(`b${e[0]}`),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=Gl(n);return ut([t,i],t.length+i.length)}function iP(r){const e=r.subarray(0,r.length-2),t=r.subarray(r.length-2),n=ae(e,"base32"),i=_d(t);return`${n}:${i}`}const U4=function(r){r=r.toString().trim();const e=new Uint8Array(4);return r.split(/\./g).forEach((t,n)=>{const i=parseInt(t,10);if(isNaN(i)||i<0||i>255)throw new Ei("Invalid byte value in IP address");e[n]=i}),e},T0e=function(r){let e=0;r=r.toString().trim();const t=r.split(":",8);let n;for(n=0;n<t.length;n++){const s=$t(t[n]);let o;s&&(o=U4(t[n]),t[n]=ae(o.subarray(0,2),"base16")),o!=null&&++n<8&&t.splice(n,0,ae(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(n=0;n<t.length&&t[n]!=="";n++);const s=[n,1];for(n=9-t.length;n>0;n--)s.push("0");t.splice.apply(t,s)}const i=new Uint8Array(e+16);for(n=0;n<t.length;n++){t[n]===""&&(t[n]="0");const s=parseInt(t[n],16);if(isNaN(s)||s<0||s>65535)throw new Ei("Invalid byte value in IP address");i[e++]=s>>8&255,i[e++]=s&255}return i},C0e=function(r){if(r.byteLength!==4)throw new Ei("IPv4 address was incorrect length");const e=[];for(let t=0;t<r.byteLength;t++)e.push(r[t]);return e.join(".")},I0e=function(r){if(r.byteLength!==16)throw new Ei("IPv6 address was incorrect length");const e=[];for(let n=0;n<r.byteLength;n+=2){const i=r[n],s=r[n+1],o=`${i.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const n=new URL(`http://[${t}]`);return n.hostname.substring(1,n.hostname.length-1)}catch{throw new Ei(`Invalid IPv6 address "${t}"`)}};function P0e(r){try{const e=new URL(`http://[${r}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new Ei(`Invalid IPv6 address "${r}"`)}}const ev=Object.values(oi).map(r=>r.decoder),R0e=(function(){let r=ev[0].or(ev[1]);return ev.slice(2).forEach(e=>r=r.or(e)),r})();function D0e(r){return R0e.decode(r)}function L0e(r){return e=>r.encoder.encode(e)}function N0e(r){if(parseInt(r).toString()!==r)throw new Uf("Value must be an integer")}function O0e(r){if(r<0)throw new Uf("Value must be a positive integer, or zero")}function U0e(r){return e=>{if(e>r)throw new Uf(`Value must be smaller than or equal to ${r}`)}}function k0e(...r){return e=>{for(const t of r)t(e)}}const tg=k0e(N0e,O0e,U0e(65535)),or=-1;let B0e=class{constructor(){f(this,"protocolsByCode",new Map);f(this,"protocolsByName",new Map)}getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new Bye(`Protocol ${e} was unknown`);return t}addProtocol(e){var t;this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),(t=e.aliases)==null||t.forEach(n=>{this.protocolsByName.set(n,e)})}removeProtocol(e){var n;const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),(n=t.aliases)==null||n.forEach(i=>{this.protocolsByName.delete(i)}))}};const Ih=new B0e,F0e=[{code:Fye,name:"ip4",size:32,valueToBytes:U4,bytesToValue:C0e,validate:r=>{if(!$t(r))throw new Uf(`Invalid IPv4 address "${r}"`)}},{code:$ye,name:"tcp",size:16,valueToBytes:Gl,bytesToValue:_d,validate:tg},{code:zye,name:"udp",size:16,valueToBytes:Gl,bytesToValue:_d,validate:tg},{code:Vye,name:"dccp",size:16,valueToBytes:Gl,bytesToValue:_d,validate:tg},{code:Hye,name:"ip6",size:128,valueToBytes:T0e,bytesToValue:I0e,stringToValue:P0e,validate:r=>{if(!Ai(r))throw new Uf(`Invalid IPv6 address "${r}"`)}},{code:Gye,name:"ip6zone",size:or},{code:Wye,name:"ipcidr",size:8,bytesToValue:nP("base10"),valueToBytes:rP("base10")},{code:qye,name:"dns",size:or},{code:Kye,name:"dns4",size:or},{code:Xye,name:"dns6",size:or},{code:Yye,name:"dnsaddr",size:or},{code:Zye,name:"sctp",size:16,valueToBytes:Gl,bytesToValue:_d,validate:tg},{code:Jye,name:"udt"},{code:jye,name:"utp"},{code:Qye,name:"unix",size:or,stringToValue:r=>decodeURIComponent(r),valueToString:r=>encodeURIComponent(r)},{code:e0e,name:"p2p",aliases:["ipfs"],size:or,bytesToValue:nP("base58btc"),valueToBytes:r=>r.startsWith("Q")||r.startsWith("1")?rP("base58btc")(r):Ze.parse(r).multihash.bytes},{code:t0e,name:"onion",size:96,bytesToValue:iP,valueToBytes:M0e},{code:n0e,name:"onion3",size:296,bytesToValue:iP,valueToBytes:A0e},{code:r0e,name:"garlic64",size:or},{code:i0e,name:"garlic32",size:or},{code:s0e,name:"tls"},{code:o0e,name:"sni",size:or},{code:a0e,name:"noise"},{code:c0e,name:"quic"},{code:l0e,name:"quic-v1"},{code:u0e,name:"webtransport"},{code:h0e,name:"certhash",size:or,bytesToValue:L0e(Mi),valueToBytes:D0e},{code:d0e,name:"http"},{code:f0e,name:"http-path",size:or,stringToValue:r=>`/${decodeURIComponent(r)}`,valueToString:r=>encodeURIComponent(r.substring(1))},{code:p0e,name:"https"},{code:m0e,name:"ws"},{code:g0e,name:"wss"},{code:y0e,name:"p2p-websocket-star"},{code:b0e,name:"p2p-stardust"},{code:w0e,name:"p2p-webrtc-star"},{code:v0e,name:"p2p-webrtc-direct"},{code:_0e,name:"webrtc-direct"},{code:x0e,name:"webrtc"},{code:S0e,name:"p2p-circuit"},{code:E0e,name:"memory",size:or}];F0e.forEach(r=>{Ih.addProtocol(r)});function $0e(r){var n;const e=[];let t=0;for(;t<r.length;){const i=Yt(r,t),s=Ih.getProtocol(i),o=Ue(i),a=G0e(s,r,t+o);let c=0;a>0&&s.size===or&&(c=Ue(a));const l=o+c+a,u={code:i,name:s.name,bytes:r.subarray(t,t+l)};if(a>0){const h=t+o+c,d=r.subarray(h,h+a);u.value=((n=s.bytesToValue)==null?void 0:n.call(s,d))??ae(d)}e.push(u),t+=l}return e}function z0e(r){var n;let e=0;const t=[];for(const i of r){if(i.bytes==null){const s=Ih.getProtocol(i.code),o=Ue(i.code);let a,c=0,l=0;i.value!=null&&(a=((n=s.valueToBytes)==null?void 0:n.call(s,i.value))??Se(i.value),c=a.byteLength,s.size===or&&(l=Ue(c)));const u=new Uint8Array(o+l+c);let h=0;sn(i.code,u,h),h+=o,a!=null&&(s.size===or&&(sn(c,u,h),h+=l),u.set(a,h)),i.bytes=u}t.push(i.bytes),e+=i.bytes.byteLength}return ut(t,e)}function V0e(r){var s;if(r.charAt(0)!=="/")throw new Ei('String multiaddr must start with "/"');const e=[];let t="protocol",n="",i="";for(let o=1;o<r.length;o++){const a=r.charAt(o);a!=="/"&&(t==="protocol"?i+=r.charAt(o):n+=r.charAt(o));const c=o===r.length-1;if(a==="/"||c){const l=Ih.getProtocol(i);if(t==="protocol"){if(l.size==null||l.size===0){e.push({code:l.code,name:l.name}),n="",i="",t="protocol";continue}else if(c)throw new Ei(`Component ${i} was missing value`);t="value"}else if(t==="value"){const u={code:l.code,name:l.name};if(l.size!=null&&l.size!==0){if(n==="")throw new Ei(`Component ${i} was missing value`);u.value=((s=l.stringToValue)==null?void 0:s.call(l,n))??n}e.push(u),n="",i="",t="protocol"}}}if(i!==""&&n!=="")throw new Ei("Incomplete multiaddr");return e}function H0e(r){return`/${r.flatMap(e=>{var n;if(e.value==null)return e.name;const t=Ih.getProtocol(e.code);if(t==null)throw new Ei(`Unknown protocol code ${e.code}`);return[e.name,((n=t.valueToString)==null?void 0:n.call(t,e.value))??e.value]}).join("/")}`}function G0e(r,e,t){return r.size==null||r.size===0?0:r.size>0?r.size/8:Yt(e,t)}const W0e=Symbol.for("nodejs.util.inspect.custom"),k4=Symbol.for("@multiformats/multiaddr");function q0e(r){if(r==null&&(r="/"),Y0e(r))return r.getComponents();if(r instanceof Uint8Array)return $0e(r);if(typeof r=="string")return r=r.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),r===""&&(r="/"),V0e(r);if(Array.isArray(r))return r;throw new Ei("Must be a string, Uint8Array, Component[], or another Multiaddr")}var ED,Gi,Lu,Nu,bo;let K0e=(bo=class{constructor(e="/",t={}){f(this,ED,!0);xe(this,Gi);xe(this,Lu);xe(this,Nu);_e(this,Gi,q0e(e)),t.validate!==!1&&X0e(this)}get bytes(){return N(this,Nu)==null&&_e(this,Nu,z0e(N(this,Gi))),N(this,Nu)}toString(){return N(this,Lu)==null&&_e(this,Lu,H0e(N(this,Gi))),N(this,Lu)}toJSON(){return this.toString()}getComponents(){return[...N(this,Gi).map(e=>({...e}))]}encapsulate(e){const t=new bo(e);return new bo([...N(this,Gi),...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),n=this.toString(),i=n.lastIndexOf(t);if(i<0)throw new kye(`Address ${this.toString()} does not contain subaddress: ${t}`);return new bo(n.slice(0,i),{validate:!1})}decapsulateCode(e){let t;for(let n=N(this,Gi).length-1;n>-1;n--)if(N(this,Gi)[n].code===e){t=n;break}return new bo(N(this,Gi).slice(0,t),{validate:!1})}equals(e){return We(this.bytes,e.bytes)}[(ED=k4,W0e)](){return`Multiaddr(${this.toString()})`}},Gi=new WeakMap,Lu=new WeakMap,Nu=new WeakMap,bo);function X0e(r){r.getComponents().forEach(e=>{var n;const t=Ih.getProtocol(e.code);e.value!=null&&((n=t.validate)==null||n.call(t,e.value))})}function Y0e(r){return!!(r!=null&&r[k4])}function Z0e(r){return new K0e(r)}var Hy;(function(r){let e;r.codec=()=>(e==null&&(e=Gt((t,n,i={})=>{if(i.lengthDelimited!==!1&&n.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(n.uint32(10),n.bytes(t.publicKey)),t.addrs!=null)for(const s of t.addrs)n.uint32(18),n.bytes(s);i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{var a;const s={publicKey:xt(0),addrs:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const c=t.uint32();switch(c>>>3){case 1:{s.publicKey=t.bytes();break}case 2:{if(((a=i.limits)==null?void 0:a.addrs)!=null&&s.addrs.length===i.limits.addrs)throw new Cs('Decode error - map field "addrs" had too many elements');s.addrs.push(t.bytes());break}default:{t.skipType(c&7);break}}}return s})),e),r.encode=t=>Ht(t,r.codec()),r.decode=(t,n)=>Vt(t,r.codec(),n)})(Hy||(Hy={}));const J0e="_peer-discovery._p2p._pubsub";var MD,AD,TD;class j0e extends(TD=Pr,AD=Iye,MD=Symbol.toStringTag,TD){constructor(t,n={}){super();f(this,AD,!0);f(this,MD,"@libp2p/pubsub-peer-discovery");f(this,"interval");f(this,"listenOnly");f(this,"topics");f(this,"intervalId");f(this,"components");f(this,"log");const{interval:i,topics:s,listenOnly:o}=n;this.components=t,this.interval=i??1e4,this.listenOnly=o??!1,this.log=t.logger.forComponent("libp2p:discovery:pubsub"),Array.isArray(s)&&s.length>0?this.topics=s:this.topics=[J0e],this._onMessage=this._onMessage.bind(this)}isStarted(){return this.intervalId!=null}start(){}afterStart(){if(this.intervalId!=null)return;const t=this.components.pubsub;if(t==null)throw new Error("PubSub not configured");for(const n of this.topics)t.subscribe(n),t.addEventListener("message",this._onMessage);this.listenOnly||(this._broadcast(),this.intervalId=setInterval(()=>{this._broadcast()},this.interval))}beforeStop(){const t=this.components.pubsub;if(t==null)throw new Error("PubSub not configured");for(const n of this.topics)t.unsubscribe(n),t.removeEventListener("message",this._onMessage)}stop(){this.intervalId!=null&&(clearInterval(this.intervalId),this.intervalId=void 0)}_broadcast(){const t=this.components.peerId;if(t.publicKey==null)throw new Error("PeerId was missing public key");const n={publicKey:Ms(t.publicKey),addrs:this.components.addressManager.getAddresses().map(o=>o.bytes)},i=Hy.encode(n),s=this.components.pubsub;if(s==null)throw new Error("PubSub not configured");for(const o of this.topics){if(s.getSubscribers(o).length===0){this.log("skipping broadcasting our peer data on topic %s because there are no peers present",o);continue}this.log("broadcasting our peer data on topic %s",o),s.publish(o,i)}}_onMessage(t){if(!this.isStarted())return;const n=t.detail;if(this.topics.includes(n.topic))try{const i=Hy.decode(n.data),s=Io(i.publicKey),o=Uye(s);if(o.equals(this.components.peerId))return;this.log("discovered peer %p on %s",o,n.topic),this.safeDispatchEvent("peer",{detail:{id:o,multiaddrs:i.addrs.map(a=>Z0e(a))}})}catch(i){this.log.error("error handling incoming message",i)}}}function Q0e(r={}){return e=>new j0e(e,r)}const B4=Symbol.for("@libp2p/peer-id");var ix;let ebe=(ix=class extends Error{constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}},f(ix,"name","InvalidParametersError"),ix);class F4 extends Error{constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}}f(F4,"name","InvalidCIDError");class $4 extends Error{constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}}f($4,"name","InvalidMultihashError");const z4=Symbol.for("nodejs.util.inspect.custom"),tbe=114;var CD;class zM{constructor(e){f(this,"type");f(this,"multihash");f(this,"publicKey");f(this,"string");f(this,CD,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=gt.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return Ze.createV1(tbe,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return We(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return We(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(CD=B4,z4)](){return`PeerId(${this.toString()})`}}class nbe extends zM{constructor(t){super({...t,type:"RSA"});f(this,"type","RSA");f(this,"publicKey");this.publicKey=t.publicKey}}class rbe extends zM{constructor(t){super({...t,type:"Ed25519"});f(this,"type","Ed25519");f(this,"publicKey");this.publicKey=t.publicKey}}class ibe extends zM{constructor(t){super({...t,type:"secp256k1"});f(this,"type","secp256k1");f(this,"publicKey");this.publicKey=t.publicKey}}const sbe=2336;var ID,PD;class V4{constructor(e){f(this,"type","url");f(this,"multihash");f(this,"publicKey");f(this,"url");f(this,ID,!0);this.url=e.toString(),this.multihash=dn.digest(Se(this.url))}[(PD=z4,ID=B4,PD)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return Ze.createV1(sbe,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=ae(e)),e.toString()===this.toString())}}const obe=114,sP=2336;function tv(r,e){let t;if(r.charAt(0)==="1"||r.charAt(0)==="Q")t=Lo(gt.decode(`z${r}`));else{if(r.startsWith("k51qzi5uqu5")||r.startsWith("kzwfwjn5ji4")||r.startsWith("k2k4r8")||r.startsWith("bafz"))return abe(Ze.parse(r));throw new ebe('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return H4(t)}function H4(r){if(lbe(r))return new nbe({multihash:r});if(cbe(r))try{const e=No(r);if(e.type==="Ed25519")return new rbe({multihash:r,publicKey:e});if(e.type==="secp256k1")return new ibe({multihash:r,publicKey:e})}catch{const t=ae(r.digest);return new V4(new URL(t))}throw new $4("Supplied PeerID Multihash is invalid")}function abe(r){if((r==null?void 0:r.multihash)==null||r.version==null||r.version===1&&r.code!==obe&&r.code!==sP)throw new F4("Supplied PeerID CID is invalid");if(r.code===sP){const e=ae(r.multihash.digest);return new V4(new URL(e))}return H4(r.multihash)}function cbe(r){return r.code===dn.code}function lbe(r){return r.code===Ns.code}class ri extends Error{constructor(){super(...arguments);f(this,"name","InvalidMultiaddrError")}}f(ri,"name","InvalidMultiaddrError");class ah extends Error{constructor(){super(...arguments);f(this,"name","ValidationError")}}f(ah,"name","ValidationError");class G4 extends Error{constructor(){super(...arguments);f(this,"name","InvalidParametersError")}}f(G4,"name","InvalidParametersError");class W4 extends Error{constructor(){super(...arguments);f(this,"name","UnknownProtocolError")}}f(W4,"name","UnknownProtocolError");const sE=4,oE=6,aE=273,ube=33,Rg=41,q4=42,hbe=43,K4=53,X4=54,VM=55,Y4=56,dbe=132,fbe=301,pbe=302,mbe=400,Z4=421,gbe=444,ybe=445,bbe=446,wbe=447,vbe=448,_be=449,xbe=454,Sbe=460,Ebe=461,Mbe=465,Abe=466,Tbe=480,Cbe=481,Ibe=443,Pbe=477,Rbe=478,Dbe=479,Lbe=277,Nbe=275,Obe=276,Ube=280,kbe=281,J4=290,Bbe=777;function oP(r){return e=>ae(e,r)}function aP(r){return e=>Se(e,r)}function xd(r){return new DataView(r.buffer).getUint16(r.byteOffset).toString()}function Wl(r){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof r=="string"?parseInt(r):r),new Uint8Array(e)}function Fbe(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=Se(e[0],"base32"),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=Wl(n);return ut([t,i],t.length+i.length)}function $be(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=Rn.decode(`b${e[0]}`),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=Wl(n);return ut([t,i],t.length+i.length)}function cP(r){const e=r.subarray(0,r.length-2),t=r.subarray(r.length-2),n=ae(e,"base32"),i=xd(t);return`${n}:${i}`}const j4=function(r){r=r.toString().trim();const e=new Uint8Array(4);return r.split(/\./g).forEach((t,n)=>{const i=parseInt(t,10);if(isNaN(i)||i<0||i>255)throw new ri("Invalid byte value in IP address");e[n]=i}),e},zbe=function(r){let e=0;r=r.toString().trim();const t=r.split(":",8);let n;for(n=0;n<t.length;n++){const s=$t(t[n]);let o;s&&(o=j4(t[n]),t[n]=ae(o.subarray(0,2),"base16")),o!=null&&++n<8&&t.splice(n,0,ae(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(n=0;n<t.length&&t[n]!=="";n++);const s=[n,1];for(n=9-t.length;n>0;n--)s.push("0");t.splice.apply(t,s)}const i=new Uint8Array(e+16);for(n=0;n<t.length;n++){t[n]===""&&(t[n]="0");const s=parseInt(t[n],16);if(isNaN(s)||s<0||s>65535)throw new ri("Invalid byte value in IP address");i[e++]=s>>8&255,i[e++]=s&255}return i},Vbe=function(r){if(r.byteLength!==4)throw new ri("IPv4 address was incorrect length");const e=[];for(let t=0;t<r.byteLength;t++)e.push(r[t]);return e.join(".")},Hbe=function(r){if(r.byteLength!==16)throw new ri("IPv6 address was incorrect length");const e=[];for(let n=0;n<r.byteLength;n+=2){const i=r[n],s=r[n+1],o=`${i.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const n=new URL(`http://[${t}]`);return n.hostname.substring(1,n.hostname.length-1)}catch{throw new ri(`Invalid IPv6 address "${t}"`)}};function Gbe(r){try{const e=new URL(`http://[${r}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new ri(`Invalid IPv6 address "${r}"`)}}const nv=Object.values(oi).map(r=>r.decoder),Wbe=(function(){let r=nv[0].or(nv[1]);return nv.slice(2).forEach(e=>r=r.or(e)),r})();function qbe(r){return Wbe.decode(r)}function Kbe(r){return e=>r.encoder.encode(e)}function Xbe(r){if(parseInt(r).toString()!==r)throw new ah("Value must be an integer")}function Ybe(r){if(r<0)throw new ah("Value must be a positive integer, or zero")}function Zbe(r){return e=>{if(e>r)throw new ah(`Value must be smaller than or equal to ${r}`)}}function Jbe(...r){return e=>{for(const t of r)t(e)}}const ng=Jbe(Xbe,Ybe,Zbe(65535)),ar=-1;class jbe{constructor(){f(this,"protocolsByCode",new Map);f(this,"protocolsByName",new Map)}getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new W4(`Protocol ${e} was unknown`);return t}addProtocol(e){var t;this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),(t=e.aliases)==null||t.forEach(n=>{this.protocolsByName.set(n,e)})}removeProtocol(e){var n;const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),(n=t.aliases)==null||n.forEach(i=>{this.protocolsByName.delete(i)}))}}const So=new jbe,Qbe=[{code:sE,name:"ip4",size:32,valueToBytes:j4,bytesToValue:Vbe,validate:r=>{if(!$t(r))throw new ah(`Invalid IPv4 address "${r}"`)}},{code:oE,name:"tcp",size:16,valueToBytes:Wl,bytesToValue:xd,validate:ng},{code:aE,name:"udp",size:16,valueToBytes:Wl,bytesToValue:xd,validate:ng},{code:ube,name:"dccp",size:16,valueToBytes:Wl,bytesToValue:xd,validate:ng},{code:Rg,name:"ip6",size:128,valueToBytes:zbe,bytesToValue:Hbe,stringToValue:Gbe,validate:r=>{if(!Ai(r))throw new ah(`Invalid IPv6 address "${r}"`)}},{code:q4,name:"ip6zone",size:ar},{code:hbe,name:"ipcidr",size:8,bytesToValue:oP("base10"),valueToBytes:aP("base10")},{code:K4,name:"dns",size:ar,resolvable:!0},{code:X4,name:"dns4",size:ar,resolvable:!0},{code:VM,name:"dns6",size:ar,resolvable:!0},{code:Y4,name:"dnsaddr",size:ar,resolvable:!0},{code:dbe,name:"sctp",size:16,valueToBytes:Wl,bytesToValue:xd,validate:ng},{code:fbe,name:"udt"},{code:pbe,name:"utp"},{code:mbe,name:"unix",size:ar,path:!0,stringToValue:r=>decodeURIComponent(r),valueToString:r=>encodeURIComponent(r)},{code:Z4,name:"p2p",aliases:["ipfs"],size:ar,bytesToValue:oP("base58btc"),valueToBytes:r=>r.startsWith("Q")||r.startsWith("1")?aP("base58btc")(r):Ze.parse(r).multihash.bytes},{code:gbe,name:"onion",size:96,bytesToValue:cP,valueToBytes:Fbe},{code:ybe,name:"onion3",size:296,bytesToValue:cP,valueToBytes:$be},{code:bbe,name:"garlic64",size:ar},{code:wbe,name:"garlic32",size:ar},{code:vbe,name:"tls"},{code:_be,name:"sni",size:ar},{code:xbe,name:"noise"},{code:Sbe,name:"quic"},{code:Ebe,name:"quic-v1"},{code:Mbe,name:"webtransport"},{code:Abe,name:"certhash",size:ar,bytesToValue:Kbe(Mi),valueToBytes:qbe},{code:Tbe,name:"http"},{code:Cbe,name:"http-path",size:ar,stringToValue:r=>`/${decodeURIComponent(r)}`,valueToString:r=>encodeURIComponent(r.substring(1))},{code:Ibe,name:"https"},{code:Pbe,name:"ws"},{code:Rbe,name:"wss"},{code:Dbe,name:"p2p-websocket-star"},{code:Lbe,name:"p2p-stardust"},{code:Nbe,name:"p2p-webrtc-star"},{code:Obe,name:"p2p-webrtc-direct"},{code:Ube,name:"webrtc-direct"},{code:kbe,name:"webrtc"},{code:J4,name:"p2p-circuit"},{code:Bbe,name:"memory",size:ar}];Qbe.forEach(r=>{So.addProtocol(r)});function ewe(r){var n;const e=[];let t=0;for(;t<r.length;){const i=Yt(r,t),s=So.getProtocol(i),o=Ue(i),a=iwe(s,r,t+o);let c=0;a>0&&s.size===ar&&(c=Ue(a));const l=o+c+a,u={code:i,name:s.name,bytes:r.subarray(t,t+l)};if(a>0){const h=t+o+c,d=r.subarray(h,h+a);u.value=((n=s.bytesToValue)==null?void 0:n.call(s,d))??ae(d)}e.push(u),t+=l}return e}function twe(r){var n;let e=0;const t=[];for(const i of r){if(i.bytes==null){const s=So.getProtocol(i.code),o=Ue(i.code);let a,c=0,l=0;i.value!=null&&(a=((n=s.valueToBytes)==null?void 0:n.call(s,i.value))??Se(i.value),c=a.byteLength,s.size===ar&&(l=Ue(c)));const u=new Uint8Array(o+l+c);let h=0;sn(i.code,u,h),h+=o,a!=null&&(s.size===ar&&(sn(c,u,h),h+=l),u.set(a,h)),i.bytes=u}t.push(i.bytes),e+=i.bytes.byteLength}return ut(t,e)}function nwe(r){var s;if(r.charAt(0)!=="/")throw new ri('String multiaddr must start with "/"');const e=[];let t="protocol",n="",i="";for(let o=1;o<r.length;o++){const a=r.charAt(o);a!=="/"&&(t==="protocol"?i+=r.charAt(o):n+=r.charAt(o));const c=o===r.length-1;if(a==="/"||c){const l=So.getProtocol(i);if(t==="protocol"){if(l.size==null||l.size===0){e.push({code:l.code,name:l.name}),n="",i="",t="protocol";continue}else if(c)throw new ri(`Component ${i} was missing value`);t="value"}else if(t==="value"){const u={code:l.code,name:l.name};if(l.size!=null&&l.size!==0){if(n==="")throw new ri(`Component ${i} was missing value`);u.value=((s=l.stringToValue)==null?void 0:s.call(l,n))??n}e.push(u),n="",i="",t="protocol"}}}if(i!==""&&n!=="")throw new ri("Incomplete multiaddr");return e}function rwe(r){return`/${r.flatMap(e=>{var n;if(e.value==null)return e.name;const t=So.getProtocol(e.code);if(t==null)throw new ri(`Unknown protocol code ${e.code}`);return[e.name,((n=t.valueToString)==null?void 0:n.call(t,e.value))??e.value]}).join("/")}`}function iwe(r,e,t){return r.size==null||r.size===0?0:r.size>0?r.size/8:Yt(e,t)}const swe=Symbol.for("nodejs.util.inspect.custom"),Q4=Symbol.for("@multiformats/multiaddr"),owe=[K4,X4,VM,Y4];class awe extends Error{constructor(e="No available resolver"){super(e),this.name="NoAvailableResolverError"}}function cwe(r){if(r==null&&(r="/"),hwe(r))return r.getComponents();if(r instanceof Uint8Array)return ewe(r);if(typeof r=="string")return r=r.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),r===""&&(r="/"),nwe(r);if(Array.isArray(r))return r;throw new ri("Must be a string, Uint8Array, Component[], or another Multiaddr")}var RD,Wt,Ou,Uu;const Kl=class Kl{constructor(e="/",t={}){f(this,RD,!0);xe(this,Wt);xe(this,Ou);xe(this,Uu);_e(this,Wt,cwe(e)),t.validate!==!1&&lwe(this)}get bytes(){return N(this,Uu)==null&&_e(this,Uu,twe(N(this,Wt))),N(this,Uu)}toString(){return N(this,Ou)==null&&_e(this,Ou,rwe(N(this,Wt))),N(this,Ou)}toJSON(){return this.toString()}toOptions(){let e,t,n,i,s="";for(const{code:a,name:c,value:l}of N(this,Wt))a===q4&&(s=`%${l??""}`),owe.includes(a)&&(t="tcp",i=443,n=`${l??""}${s}`,e=a===VM?6:4),(a===oE||a===aE)&&(t=c==="tcp"?"tcp":"udp",i=parseInt(l??"")),(a===sE||a===Rg)&&(t="tcp",n=`${l??""}${s}`,e=a===Rg?6:4);if(e==null||t==null||n==null||i==null)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:e,host:n,transport:t,port:i}}getComponents(){return[...N(this,Wt)]}protos(){return N(this,Wt).map(({code:e,value:t})=>{const n=So.getProtocol(e);return{code:e,size:n.size??0,name:n.name,resolvable:!!n.resolvable,path:!!n.path}})}protoCodes(){return N(this,Wt).map(({code:e})=>e)}protoNames(){return N(this,Wt).map(({name:e})=>e)}tuples(){return N(this,Wt).map(({code:e,value:t})=>{var s;if(t==null)return[e];const n=So.getProtocol(e),i=[e];return t!=null&&i.push(((s=n.valueToBytes)==null?void 0:s.call(n,t))??Se(t)),i})}stringTuples(){return N(this,Wt).map(({code:e,value:t})=>t==null?[e]:[e,t])}encapsulate(e){const t=new Kl(e);return new Kl([...N(this,Wt),...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),n=this.toString(),i=n.lastIndexOf(t);if(i<0)throw new G4(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`);return new Kl(n.slice(0,i),{validate:!1})}decapsulateCode(e){let t;for(let n=N(this,Wt).length-1;n>-1;n--)if(N(this,Wt)[n].code===e){t=n;break}return new Kl(N(this,Wt).slice(0,t),{validate:!1})}getPeerId(){try{let e=[];N(this,Wt).forEach(({code:n,value:i})=>{n===Z4&&e.push([n,i]),n===J4&&(e=[])});const t=e.pop();if((t==null?void 0:t[1])!=null){const n=t[1];return n[0]==="Q"||n[0]==="1"?ae(gt.decode(`z${n}`),"base58btc"):ae(Ze.parse(n).multihash.bytes,"base58btc")}return null}catch{return null}}getPath(){for(const e of N(this,Wt))if(So.getProtocol(e.code).path)return e.value??null;return null}equals(e){return We(this.bytes,e.bytes)}async resolve(e){const t=this.protos().find(s=>s.resolvable);if(t==null)return[this];const n=uwe.get(t.name);if(n==null)throw new awe(`no available resolver for ${t.name}`);return(await n(this,e)).map(s=>HM(s))}nodeAddress(){const e=this.toOptions();if(e.transport!=="tcp"&&e.transport!=="udp")throw new Error(`multiaddr must have a valid format - no protocol with name: "${e.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:e.family,address:e.host,port:e.port}}isThinWaistAddress(){return!(N(this,Wt).length!==2||N(this,Wt)[0].code!==sE&&N(this,Wt)[0].code!==Rg||N(this,Wt)[1].code!==oE&&N(this,Wt)[1].code!==aE)}[(RD=Q4,swe)](){return`Multiaddr(${this.toString()})`}};Wt=new WeakMap,Ou=new WeakMap,Uu=new WeakMap;let cE=Kl;function lwe(r){r.getComponents().forEach(e=>{var n;const t=So.getProtocol(e.code);e.value!=null&&((n=t.validate)==null||n.call(t,e.value))})}const uwe=new Map;function hwe(r){return!!(r!=null&&r[Q4])}function HM(r){return new cE(r)}const lP=(r,e)=>typeof r!="number"||!Number.isFinite(r)?e:Math.max(1,Math.min(60,r)),ec={snapshotHz:20,commandHz:30,keepaliveMs:1e3,maxEventsPerTick:20,eventRetryMs:500,eventRetryMax:5,reliableEventTypes:[],reconnectStallMs:8e3,reconnectBackoffMs:5e3,snapshotsRequireAuthority:!1,snapshotTopic:null,commandTopic:null,eventTopic:null};class dwe{constructor(e,t={}){this.adapter=e,this.stateProviders=new Map,this.commandProviders=new Map,this.eventQueue=[],this.pendingReliableEvents=new Map,this.reliabilityStats={sent:0,acked:0,dropped:0},this.snapshotHandlers=[],this.commandHandlers=[],this.eventHandlers=[],this.seq={snapshot:0,command:0,event:0},this.lastSnapshotAt=-1/0,this.lastCommandAt=-1/0,this.lastEventAt=-1/0,this.lastRxAt=0,this.lastTxAt=0,this.lastReconnectAt=-1/0,this.stateDirty=!0,this.authorityId=null,this.configure(t)}configure(e={}){const t=Number.isFinite(e.eventRetryMs)?e.eventRetryMs:ec.eventRetryMs,n=Number.isFinite(e.eventRetryMax)?e.eventRetryMax:ec.eventRetryMax;this.profile={...ec,...e,snapshotHz:lP(e.snapshotHz,ec.snapshotHz),commandHz:lP(e.commandHz,ec.commandHz),eventRetryMs:Math.max(0,t),eventRetryMax:Math.max(1,n),reliableEventTypes:Array.isArray(e.reliableEventTypes)?e.reliableEventTypes:ec.reliableEventTypes},this.snapshotIntervalMs=Math.round(1e3/this.profile.snapshotHz),this.commandIntervalMs=Math.round(1e3/this.profile.commandHz);const i=Math.max(this.profile.snapshotHz,this.profile.commandHz);this.tickIntervalMs=Math.max(10,Math.round(1e3/i))}getProfile(){return{...this.profile}}getTickIntervalMs(){return this.tickIntervalMs}setAuthority(e){this.authorityId=e||null}getAuthority(){return this.authorityId}registerStateProvider(e,t={}){const n=t.id||`state-${Math.random().toString(36).slice(2)}`;return this.stateProviders.set(n,{fn:e,options:t}),n}registerCommandProvider(e,t={}){const n=t.id||`cmd-${Math.random().toString(36).slice(2)}`;return this.commandProviders.set(n,{fn:e,options:t}),n}unregisterStateProvider(e){this.stateProviders.delete(e)}unregisterCommandProvider(e){this.commandProviders.delete(e)}addSnapshotHandler(e){this.snapshotHandlers.push(e)}addCommandHandler(e){this.commandHandlers.push(e)}addEventHandler(e){this.eventHandlers.push(e)}markStateDirty(){this.stateDirty=!0}queueEvent(e,t={}){const n=Date.now(),i=t.reliable||t.critical,s=t.id||`evt-${n}-${Math.random().toString(36).slice(2,8)}`;return i?(this.pendingReliableEvents.has(s)||this.pendingReliableEvents.set(s,{id:s,payload:e,options:t,createdAt:n,lastSentAt:0,attempts:0,nextSendAt:0}),s):(this.eventQueue.push({id:s,payload:e,options:t,reliable:!1}),s)}recordRx(e=Date.now()){this.lastRxAt=e}recordTx(e=Date.now()){this.lastTxAt=e}handleMessage(e,t){var n,i,s,o;if(!e||typeof e.type!="string"||!e.type.startsWith("pc-"))return!1;if((n=this.adapter)!=null&&n.isInScope&&!this.adapter.isInScope(e)||e.target&&((i=this.adapter)!=null&&i.getPeerId)&&e.target!==this.adapter.getPeerId())return!0;if(this.recordRx(((s=e.header)==null?void 0:s.ts)||Date.now()),e.type==="pc-snapshot")return this.snapshotHandlers.forEach(a=>a(t,e)),!0;if(e.type==="pc-command")return this.commandHandlers.forEach(a=>a(t,e)),!0;if(e.type==="pc-ack"){const a=(o=e==null?void 0:e.payload)==null?void 0:o.eventIds;if(Array.isArray(a)){let c=0;a.forEach(l=>{this.pendingReliableEvents.delete(l)&&(c+=1)}),this.reliabilityStats.acked+=c}return!0}return e.type==="pc-event"&&(this.eventHandlers.forEach(a=>a(t,e)),this._ackReliableEvents(e,t)),!0}tick(e=Date.now()){this._flushCommands(e),this._flushSnapshots(e),this._flushEvents(e),this._checkReconnect(e)}_buildHeader(e,t){var n,i,s,o;return{type:e,seq:this.seq[e]++,ts:t,peerId:((i=(n=this.adapter)==null?void 0:n.getPeerId)==null?void 0:i.call(n))||null,authorityId:this.authorityId||((o=(s=this.adapter)==null?void 0:s.getAuthority)==null?void 0:o.call(s))||null}}_collectStatePayload(){const e=[];for(const[t,n]of this.stateProviders.entries())try{const i=n.fn();if(i==null)continue;e.push({id:t,data:i})}catch{}return e}_collectCommandPayload(){const e=[];for(const[t,n]of this.commandProviders.entries())try{const i=n.fn();if(i==null)continue;Array.isArray(i)?i.forEach(s=>e.push({id:t,data:s})):e.push({id:t,data:i})}catch{}return e}_flushSnapshots(e){var s,o,a,c,l,u;if(this.stateProviders.size===0||e-this.lastSnapshotAt<this.snapshotIntervalMs)return;const t=e-this.lastSnapshotAt>=this.profile.keepaliveMs;if(!this.stateDirty&&!t)return;const n=this._collectStatePayload();if(n.length===0&&!t)return;const i={type:"pc-snapshot",header:this._buildHeader("snapshot",e),gameId:((o=(s=this.adapter)==null?void 0:s.getGameId)==null?void 0:o.call(s))||null,roomId:((c=(a=this.adapter)==null?void 0:a.getRoomId)==null?void 0:c.call(a))||null,payload:n,keepalive:t};this.lastSnapshotAt=e,this.stateDirty=!1,(u=(l=this.adapter)==null?void 0:l.sendSnapshot)==null||u.call(l,i),this.recordTx(e)}_flushCommands(e){var i,s,o,a,c,l;if(this.commandProviders.size===0||e-this.lastCommandAt<this.commandIntervalMs)return;const t=this._collectCommandPayload();if(t.length===0)return;const n={type:"pc-command",header:this._buildHeader("command",e),gameId:((s=(i=this.adapter)==null?void 0:i.getGameId)==null?void 0:s.call(i))||null,roomId:((a=(o=this.adapter)==null?void 0:o.getRoomId)==null?void 0:a.call(o))||null,payload:t};this.lastCommandAt=e,(l=(c=this.adapter)==null?void 0:c.sendCommand)==null||l.call(c,n),this.recordTx(e)}_flushEvents(e){var a,c,l,u,h,d,m;if(this.eventQueue.length===0&&this.pendingReliableEvents.size===0)return;const t=this.profile.maxEventsPerTick,n=[],i=[];for(const p of this.pendingReliableEvents.values()){if(p.attempts>=this.profile.eventRetryMax){this.reliabilityStats.dropped+=1,this.pendingReliableEvents.delete(p.id);continue}e>=p.nextSendAt&&i.push(p)}const s=p=>n.length>=t?!1:(n.push(p),!0);for(const p of i){if(!s({id:p.id,payload:p.payload,reliable:!0,ts:e}))break;p.attempts+=1,p.lastSentAt=e,this.reliabilityStats.sent+=1;const g=(((a=p.options)==null?void 0:a.retryMs)??this.profile.eventRetryMs)*Math.pow(2,Math.max(0,p.attempts-1));p.nextSendAt=e+g}for(;n.length<t&&this.eventQueue.length>0;){const p=this.eventQueue.shift();if(!p)break;n.push({id:p.id,payload:p.payload,reliable:!1,ts:e})}if(n.length===0)return;const o={type:"pc-event",header:this._buildHeader("event",e),gameId:((l=(c=this.adapter)==null?void 0:c.getGameId)==null?void 0:l.call(c))||null,roomId:((h=(u=this.adapter)==null?void 0:u.getRoomId)==null?void 0:h.call(u))||null,payload:n};this.lastEventAt=e,(m=(d=this.adapter)==null?void 0:d.sendEvent)==null||m.call(d,o),this.recordTx(e)}getReliabilityStats(){return{sent:this.reliabilityStats.sent,acked:this.reliabilityStats.acked,dropped:this.reliabilityStats.dropped,pending:this.pendingReliableEvents.size,retryMs:this.profile.eventRetryMs,retryMax:this.profile.eventRetryMax}}_checkReconnect(e){var n;if(!((n=this.adapter)!=null&&n.reconnect)||this.profile.reconnectStallMs<=0)return;const t=this.lastRxAt||0;e-t<this.profile.reconnectStallMs||e-this.lastReconnectAt<this.profile.reconnectBackoffMs||(this.lastReconnectAt=e,this.adapter.reconnect())}_ackReliableEvents(e,t){var a,c,l,u,h,d;const i=(Array.isArray(e==null?void 0:e.payload)?e.payload:[]).filter(m=>(m==null?void 0:m.reliable)&&(m==null?void 0:m.id)).map(m=>m.id);if(i.length===0)return;const s=Date.now(),o={type:"pc-ack",header:this._buildHeader("event",s),gameId:((c=(a=this.adapter)==null?void 0:a.getGameId)==null?void 0:c.call(a))||null,roomId:((u=(l=this.adapter)==null?void 0:l.getRoomId)==null?void 0:u.call(l))||null,target:t||null,payload:{eventIds:i}};(d=(h=this.adapter)==null?void 0:h.sendEvent)==null||d.call(h,o)}}const fwe="peercompute-state-sync",pwe="peercompute-direct",mwe="peercompute-presence",gwe=5e3,ywe=new TextEncoder,bwe=new TextDecoder,GM=typeof __PC_DEBUG__<"u"&&__PC_DEBUG__===!0,rv=(...r)=>{GM&&console.log(...r)},ds=(...r)=>{GM&&console.warn(...r)},wwe=r=>typeof r!="string"?!1:r.includes("/dns4/localhost")||r.includes("/dns/localhost")||r.includes("/ip6/::1")||r.includes("/ip4/127.")||r.includes("/ip4/10.")||r.includes("/ip4/192.168.")?!0:/\/ip4\/172\.(1[6-9]|2\d|3[01])\./.test(r),e6=r=>{if(typeof r!="string")return r;const e=r.split("/p2p/");if(e.length<=2)return r;const t=e[e.length-1];return`${e[0]}/p2p/${t}`},uP=r=>{if(typeof r!="string")return null;const e=r.split("/p2p/");return e.length<2?null:e[e.length-1]||null},hP=r=>{if(!r)return null;if(typeof r.getComponents=="function")return r;if(typeof r!="string")return null;try{return HM(r)}catch(e){return ds("[NetworkManager] Invalid peer multiaddr",r,(e==null?void 0:e.message)||e),null}},vwe=r=>{if(!r)return null;if(typeof r.getComponents=="function")return r;if(typeof r!="string")return null;const e=e6(r);try{return HM(e)}catch(t){return ds("[NetworkManager] Invalid bootstrap multiaddr",e,(t==null?void 0:t.message)||t),null}},_we=(r,e)=>{if(!e||typeof r!="string")return r;const t=`/p2p/${e}`;return r.includes(t)?r:`${r}${t}`};class xwe{constructor(e={}){const t={topology:e.topology||"distributed",pubsubTopic:e.pubsubTopic||fwe,directTopic:e.directTopic||pwe,presenceTopic:e.presenceTopic||mwe,discoveryTopic:e.discoveryTopic||"peercompute._peer-discovery._p2p._pubsub",bootstrapPeers:Array.isArray(e.bootstrapPeers)?e.bootstrapPeers:[],gameId:e.gameId||"default-game",roomId:e.roomId||"default-room",enforceRoomIsolation:e.enforceRoomIsolation!==!1},n=t.bootstrapPeers.map(s=>typeof s=="string"?e6(s):s),i=e.allowLocalDial??n.some(wwe);this.config={...t,...e,bootstrapPeers:n,allowLocalDial:i},this.bootstrapPeerIds=new Set(n.map(uP).filter(Boolean)),this.libp2p=null,this.peerId=null,this.isConnected=!1,this.presenceInterval=null,this.publishErrorAt=new Map,this.peers=new Map,this.recentDialAttempts=new Map,this.onMessage=e.onMessage||(()=>{}),this.onPeerConnect=e.onPeerConnect||(()=>{}),this.onPeerDisconnect=e.onPeerDisconnect||(()=>{}),this.messageHandlers=[],this.scheduler=null,this.schedulerTimer=null,this.schedulerEnabled=e.enableScheduler||!1,this.schedulerClock=e.schedulerClock||"internal",this.schedulerProfile={...ec,...e.schedulerProfile||{}},this.authorityId=e.authorityId||null,this.lastRxAt=0,this.lastTxAt=0,this.allowedTopics=new Set([this.config.pubsubTopic,this.config.directTopic,this.config.presenceTopic]),[this.schedulerProfile.snapshotTopic,this.schedulerProfile.commandTopic,this.schedulerProfile.eventTopic].filter(Boolean).forEach(s=>this.allowedTopics.add(s))}addMessageHandler(e){this.messageHandlers.push(e)}configureScheduler(e={}){this.schedulerProfile={...this.schedulerProfile,...e},[this.schedulerProfile.snapshotTopic,this.schedulerProfile.commandTopic,this.schedulerProfile.eventTopic].filter(Boolean).forEach(t=>this.allowedTopics.add(t)),this.schedulerEnabled=!0,this._ensureScheduler(),this.scheduler.configure(this.schedulerProfile),this._startScheduler()}setSchedulerClock(e="internal"){const t=e==="external"?"external":"internal";if(this.schedulerClock!==t){if(this.schedulerClock=t,t==="external"){this._stopScheduler();return}this.schedulerEnabled&&this.isConnected&&this._startScheduler()}}getSchedulerClock(){return this.schedulerClock}tickScheduler(e=Date.now()){!this.scheduler||!this.schedulerEnabled||this.scheduler.tick(e)}getSchedulerProfile(){return this.scheduler?this.scheduler.getProfile():{...this.schedulerProfile}}registerStateProvider(e,t={}){return this._ensureScheduler(),this.schedulerEnabled=!0,this._startScheduler(),this.scheduler.registerStateProvider(e,t)}registerWarmDeltaProvider(e,t={}){const n=t.id||"warm-deltas";return this.registerStateProvider(()=>e(),{...t,id:n})}registerCommandProvider(e,t={}){return this._ensureScheduler(),this.schedulerEnabled=!0,this._startScheduler(),this.scheduler.registerCommandProvider(e,t)}unregisterStateProvider(e){var t;(t=this.scheduler)==null||t.unregisterStateProvider(e)}unregisterCommandProvider(e){var t;(t=this.scheduler)==null||t.unregisterCommandProvider(e)}markStateDirty(){var e;(e=this.scheduler)==null||e.markStateDirty()}queueEvent(e,t={}){var s,o;this._ensureScheduler(),this.schedulerEnabled=!0,this._startScheduler();const n=Object.prototype.hasOwnProperty.call(t,"reliable")||Object.prototype.hasOwnProperty.call(t,"critical");let i=t;if(!n&&(e!=null&&e.type)){const a=((o=(s=this.scheduler)==null?void 0:s.getProfile)==null?void 0:o.call(s))||this.schedulerProfile;Array.isArray(a.reliableEventTypes)&&a.reliableEventTypes.includes(e.type)&&(i={...t,reliable:!0})}this.scheduler.queueEvent(e,i)}addSnapshotHandler(e){this._ensureScheduler(),this.scheduler.addSnapshotHandler(e)}addCommandHandler(e){this._ensureScheduler(),this.scheduler.addCommandHandler(e)}addEventHandler(e){this._ensureScheduler(),this.scheduler.addEventHandler(e)}setAuthority(e){this.authorityId=e||null,this.scheduler&&this.scheduler.setAuthority(this.authorityId)}getAuthority(){return this.authorityId}getHealth(){var t,n,i,s,o,a;const e=(n=(t=this.scheduler)==null?void 0:t.getReliabilityStats)==null?void 0:n.call(t);return{lastRxAt:this.lastRxAt,lastTxAt:this.lastTxAt,peerCount:this.getConnectedPeers().length,pubsubPeers:((a=(o=(s=(i=this.libp2p)==null?void 0:i.services)==null?void 0:s.pubsub)==null?void 0:o.getPeers)==null?void 0:a.call(o))||[],reliability:e}}async initialize(){var i;const t=typeof window<"u"?["/p2p-circuit","/webrtc"]:["/ip4/0.0.0.0/tcp/0"],n=[Q0e({interval:1e3,topics:[this.config.discoveryTopic]})];return(i=this.config.bootstrapPeers)!=null&&i.length&&n.unshift(Cye({list:this.config.bootstrapPeers})),this.libp2p=await Fne({transports:[iie(),Boe(),Rce()],connectionEncrypters:[ile(),gle()],streamMuxers:[Cle()],peerDiscovery:n,services:{identify:zme(),ping:Zme({interval:1e4}),pubsub:hpe()},connectionManager:{minConnections:0,maxConnections:200,inboundConnectionThreshold:1/0,maxIncomingPendingConnections:100},connectionMonitor:{abortConnectionOnPingFailure:!1},addresses:{listen:t},...this.config.allowLocalDial?{connectionGater:{denyDialMultiaddr:()=>!1}}:{}}),this._wireLibp2pEvents(),this.libp2p}async connect(){if(!this.isConnected){if(!this.libp2p)throw new Error("NetworkManager not initialized");await this.libp2p.start(),this.peerId=this.libp2p.peerId.toString(),this.libp2p.services.pubsub.subscribe(this.config.pubsubTopic),this.libp2p.services.pubsub.subscribe(this.config.directTopic),this.libp2p.services.pubsub.subscribe(this.config.presenceTopic),await this._dialBootstrapPeers(),this._startPresence(),this._logPubsubStatus("connected"),this.isConnected=!0,this.schedulerEnabled&&(this._ensureScheduler(),this._startScheduler())}}async redialBootstrapPeers(){this.libp2p&&await this._dialBootstrapPeers()}async disconnect(){this.isConnected=!1,this._stopScheduler(),this._clearPresenceTimer(),this.libp2p&&await this.libp2p.stop(),this.peers.clear(),this.peerId=null}async sendToPeer(e,t){const n=this._wrapPayload(t,{target:e});await this._publish(this.config.directTopic,n)}async broadcast(e,t={}){const n=t.topic||this.config.pubsubTopic,i=this._wrapPayload(e);await this._publish(n,i)}getConnectedPeers(){const e=this._getConnectionPeers(),t=this._getScopedPeers(),n=new Map;return e.forEach(i=>n.set(i.peerId,i)),t.forEach(i=>{const s=n.get(i.peerId)||{};n.set(i.peerId,{...s,...i})}),Array.from(n.values())}getNetworkStats(){var i,s;const e=this._getConnectionPeers(),t=((s=(i=this.libp2p)==null?void 0:i.getConnections)==null?void 0:s.call(i))||[],n=Array.isArray(t)?t.length:typeof t.size=="number"?t.size:0;return{peerId:this.peerId,peerCount:e.length,isConnected:this.isConnected,topology:this.config.topology,connections:n}}getLibp2pNode(){return this.libp2p}_wireLibp2pEvents(){this.libp2p&&(this.libp2p.addEventListener("peer:discovery",e=>{var n,i,s,o,a,c;const t=((s=(i=(n=e.detail)==null?void 0:n.id)==null?void 0:i.toString)==null?void 0:s.call(i))||((c=(a=(o=e.detail)==null?void 0:o.id)==null?void 0:a.toString)==null?void 0:c.call(a));!t||t===this.peerId||this._shouldDialDiscoveredPeer(t)&&this._maybeDialPeer(t,"discovery").catch(()=>{})}),this.libp2p.addEventListener("peer:connect",e=>{var i,s,o,a,c;const t=((o=(s=(i=e.detail)==null?void 0:i.remotePeer)==null?void 0:s.toString)==null?void 0:o.call(s))||((c=(a=e.detail)==null?void 0:a.toString)==null?void 0:c.call(a));if(!t)return;const n=!this.peers.has(t);this._touchPeer(t,{connectedAt:Date.now(),via:"connection"}),n&&this.onPeerConnect(t)}),this.libp2p.addEventListener("peer:disconnect",e=>{var n,i,s,o,a;const t=((s=(i=(n=e.detail)==null?void 0:n.remotePeer)==null?void 0:i.toString)==null?void 0:s.call(i))||((a=(o=e.detail)==null?void 0:o.toString)==null?void 0:a.call(o));t&&(this.peers.delete(t),this.onPeerDisconnect(t))}),this.libp2p.services.pubsub.addEventListener("message",e=>{var l,u,h;const{topic:t,data:n}=e.detail||{};if(!t||!n||!this.allowedTopics.has(t))return;let i=null;try{i=JSON.parse(bwe.decode(n))}catch(d){ds("[NetworkManager] Failed to parse pubsub payload",d);return}const s=Date.now();this.lastRxAt=s,(l=this.scheduler)==null||l.recordRx(s);const o=((u=i==null?void 0:i.header)==null?void 0:u.peerId)||(i==null?void 0:i.from)||"unknown";if((h=this.scheduler)!=null&&h.handleMessage(i,o))return;if(t===this.config.presenceTopic){this._handlePresence(i);return}if(t===this.config.directTopic&&i!=null&&i.target&&i.target!==this.peerId||!this._matchesScope(i))return;const a=(i==null?void 0:i.payload)??i,c=i==null?void 0:i.from;c&&c!==this.peerId&&this._touchPeer(c,{lastMessageTime:Date.now()}),this._dispatchMessage(c||"unknown",a)}))}_dispatchMessage(e,t){this.messageHandlers.forEach(n=>{try{n(e,t)}catch(i){console.error("[NetworkManager] Message handler failed",i)}}),this.onMessage(e,t)}_wrapPayload(e,t={}){return{type:"peercompute-message",from:this.peerId,gameId:this.config.gameId,roomId:this.config.roomId,payload:e,...t}}_matchesScope(e){return e?!(e.gameId&&e.gameId!==this.config.gameId||e.roomId&&e.roomId!==this.config.roomId):!0}_handlePresence(e){if(!e||!this._matchesScope(e)||!e.from||e.from===this.peerId)return;const t=!this.peers.has(e.from);this._touchPeer(e.from,{gameId:e.gameId,roomId:e.roomId,lastSeen:Date.now(),via:"presence"}),t&&this.onPeerConnect(e.from),Array.isArray(e.multiaddrs)&&e.multiaddrs.length>0&&this._rememberPeerAddresses(e.from,e.multiaddrs),this._maybeDialPeer(e.from,"presence",e.multiaddrs).catch(()=>{})}_getScopedPeers(){return Array.from(this.peers.entries()).filter(([,e])=>(e==null?void 0:e.gameId)===this.config.gameId&&(e==null?void 0:e.roomId)===this.config.roomId).map(([e,t])=>({peerId:e,...t}))}_getConnectionPeers(){var i,s,o,a,c;if(!((i=this.libp2p)!=null&&i.getConnections))return[];const e=new Map,t=this.libp2p.getConnections(),n=Array.isArray(t)?t:typeof(t==null?void 0:t.values)=="function"?Array.from(t.values()).reduce((l,u)=>l.concat(u),[]):[];for(const l of n){const u=((o=(s=l==null?void 0:l.remotePeer)==null?void 0:s.toString)==null?void 0:o.call(s))||((c=(a=l==null?void 0:l.remotePeer)==null?void 0:a.toString)==null?void 0:c.call(a));if(!u)continue;const h=this.peers.get(u)||{};e.set(u,{peerId:u,...h,via:h.via||"connection"})}return Array.from(e.values())}_shouldDialDiscoveredPeer(e){return e?!this.config.enforceRoomIsolation||this.bootstrapPeerIds.has(e)?!0:this.peers.has(e):!1}_touchPeer(e,t){const n=this.peers.get(e)||{};this.peers.set(e,{...n,...t})}_startPresence(){this._clearPresenceTimer();const e=async()=>{if(!this.peerId)return;const t={type:"presence",from:this.peerId,gameId:this.config.gameId,roomId:this.config.roomId,multiaddrs:this._getAnnounceAddrs()};await this._publish(this.config.presenceTopic,t)};e().catch(()=>{}),this.presenceInterval=setInterval(()=>{e().catch(()=>{})},3e3)}_clearPresenceTimer(){this.presenceInterval&&(clearInterval(this.presenceInterval),this.presenceInterval=null)}_ensureScheduler(){this.scheduler||(this.scheduler=new dwe(this._buildSchedulerAdapter(),this.schedulerProfile),this.authorityId&&this.scheduler.setAuthority(this.authorityId))}_startScheduler(){if(!this.schedulerEnabled||!this.isConnected||this.schedulerClock==="external"||!this.scheduler||this.schedulerTimer)return;const e=()=>{this.scheduler&&(this.scheduler.tick(Date.now()),this.schedulerTimer=setTimeout(e,this.scheduler.getTickIntervalMs()))};this.schedulerTimer=setTimeout(e,this.scheduler.getTickIntervalMs())}_stopScheduler(){this.schedulerTimer&&(clearTimeout(this.schedulerTimer),this.schedulerTimer=null)}_buildSchedulerAdapter(){return{sendSnapshot:e=>this._sendScheduledSnapshot(e),sendCommand:e=>this._sendScheduledCommand(e),sendEvent:e=>this._sendScheduledEvent(e),reconnect:()=>this._schedulerReconnect(),getPeerId:()=>this.peerId,getAuthority:()=>this.authorityId,getGameId:()=>this.config.gameId,getRoomId:()=>this.config.roomId,isInScope:e=>this._matchesScope(e)}}async _sendScheduledSnapshot(e){var n,i;if(!this.isConnected||this.schedulerProfile.snapshotsRequireAuthority&&this.authorityId&&this.authorityId!==this.peerId)return;const t=((i=(n=this.scheduler)==null?void 0:n.getProfile())==null?void 0:i.snapshotTopic)||this.config.pubsubTopic;await this._publish(t,e)}async _sendScheduledCommand(e){var s,o;if(!this.isConnected)return;const t=((o=(s=this.scheduler)==null?void 0:s.getProfile())==null?void 0:o.commandTopic)||this.config.directTopic,n=this.authorityId&&this.authorityId!==this.peerId?this.authorityId:null,i=n?{...e,target:n}:e;await this._publish(t,i)}async _sendScheduledEvent(e){var n,i;if(!this.isConnected)return;const t=((i=(n=this.scheduler)==null?void 0:n.getProfile())==null?void 0:i.eventTopic)||this.config.pubsubTopic;await this._publish(t,e)}async _schedulerReconnect(){await this.redialBootstrapPeers(),this._resubscribeTopics(),this._startPresence()}_resubscribeTopics(){var e,t;(t=(e=this.libp2p)==null?void 0:e.services)!=null&&t.pubsub&&(this.libp2p.services.pubsub.subscribe(this.config.pubsubTopic),this.libp2p.services.pubsub.subscribe(this.config.directTopic),this.libp2p.services.pubsub.subscribe(this.config.presenceTopic))}async _publish(e,t){var i,s,o;if(!((s=(i=this.libp2p)==null?void 0:i.services)!=null&&s.pubsub))return;const n=ywe.encode(JSON.stringify(t));try{await this.libp2p.services.pubsub.publish(e,n);const a=Date.now();this.lastTxAt=a,(o=this.scheduler)==null||o.recordTx(a)}catch(a){const c=Date.now(),l=this.publishErrorAt.get(e)||0;c-l>5e3&&(this.publishErrorAt.set(e,c),ds("[NetworkManager] Publish failed",e,(a==null?void 0:a.message)||a))}}async _dialBootstrapPeers(){const e=(this.config.bootstrapPeers||[]).map(vwe).filter(Boolean);await Promise.all(e.map(async t=>{var n,i;try{const s=t.toString(),o=uP(s);if(o)try{const a=tv(o);if((((i=(n=this.libp2p)==null?void 0:n.getConnections)==null?void 0:i.call(n,a))||[]).length>0)return}catch{}await this.libp2p.dial(t),rv("[NetworkManager] Dialed bootstrap peer",t.toString())}catch(s){ds("[NetworkManager] Failed to dial bootstrap peer",t.toString(),(s==null?void 0:s.message)||s)}}))}async _maybeDialPeer(e,t,n=null){var l,u;if(!this.libp2p||!e||e===this.peerId||this.bootstrapPeerIds.has(e)||(((u=(l=this.libp2p).getConnections)==null?void 0:u.call(l,e))||[]).length>0)return;const s=Date.now(),o=this.recentDialAttempts.get(e)||0;if(s-o<gwe)return;this.recentDialAttempts.set(e,s);const a=Array.isArray(n)&&n.length>0?n.map(hP).filter(Boolean):[];if(a.length>0)for(const h of a)try{await this.libp2p.dial(h),rv("[NetworkManager] Dialed discovered peer",e,t?`(${t})`:"",h.toString());return}catch(d){ds("[NetworkManager] Failed to dial discovered peer",e,h.toString(),(d==null?void 0:d.message)||d)}let c=e;try{c=tv(e)}catch{return}try{await this.libp2p.dial(c),rv("[NetworkManager] Dialed discovered peer",e,t?`(${t})`:"")}catch(h){ds("[NetworkManager] Failed to dial discovered peer",e,(h==null?void 0:h.message)||h)}}_getAnnounceAddrs(){var o;if(!((o=this.libp2p)!=null&&o.getMultiaddrs))return[];const e=this.libp2p.getMultiaddrs().map(a=>a.toString()),t=e.filter(a=>a.includes("/p2p-circuit")||a.includes("/webrtc")),n=t.length>0?t:e,i=this.peerId,s=n.map(a=>_we(a,i));return Array.from(new Set(s))}_logPubsubStatus(e){var o,a;if(!((a=(o=this.libp2p)==null?void 0:o.services)!=null&&a.pubsub)||!GM)return;const t=this.libp2p.services.pubsub,n=typeof t.getPeers=="function"?t.getPeers():[],i=typeof t.getSubscribers=="function"?t.getSubscribers(this.config.presenceTopic):[];Array.isArray(n)&&n.length===0&&ds(`[NetworkManager] Pubsub has no peers (${e})`),Array.isArray(i)&&i.length===0&&ds(`[NetworkManager] No subscribers on presence topic (${e})`),this._getAnnounceAddrs().length===0&&ds(`[NetworkManager] No announce addrs available (${e})`)}_rememberPeerAddresses(e,t){var s,o;if(!((o=(s=this.libp2p)==null?void 0:s.peerStore)!=null&&o.merge)||!Array.isArray(t)||t.length===0)return;let n;try{n=tv(e)}catch{return}const i=t.map(hP).filter(Boolean);i.length!==0&&this.libp2p.peerStore.merge(n,{multiaddrs:i}).catch(()=>{})}}const es=()=>new Map,lE=r=>{const e=es();return r.forEach((t,n)=>{e.set(n,t)}),e},Na=(r,e,t)=>{let n=r.get(e);return n===void 0&&r.set(e,n=t()),n},Swe=(r,e)=>{const t=[];for(const[n,i]of r)t.push(e(i,n));return t},Ewe=(r,e)=>{for(const[t,n]of r)if(e(n,t))return!0;return!1},ch=()=>new Set,iv=r=>r[r.length-1],Mwe=(r,e)=>{for(let t=0;t<e.length;t++)r.push(e[t])},Wc=Array.from,Awe=Array.isArray;class WM{constructor(){this._observers=es()}on(e,t){Na(this._observers,e,ch).add(t)}once(e,t){const n=(...i)=>{this.off(e,n),t(...i)};this.on(e,n)}off(e,t){const n=this._observers.get(e);n!==void 0&&(n.delete(t),n.size===0&&this._observers.delete(e))}emit(e,t){return Wc((this._observers.get(e)||es()).values()).forEach(n=>n(...t))}destroy(){this._observers=es()}}const Ca=Math.floor,Dg=Math.abs,t6=(r,e)=>r<e?r:e,Qc=(r,e)=>r>e?r:e,n6=r=>r!==0?r<0:1/r<0,dP=1,fP=2,sv=4,ov=8,kf=32,Eo=64,si=128,eb=31,uE=63,Cc=127,Twe=2147483647,r6=Number.MAX_SAFE_INTEGER,Cwe=Number.isInteger||(r=>typeof r=="number"&&isFinite(r)&&Ca(r)===r),Iwe=r=>r.toLowerCase(),Pwe=/^\s*/g,Rwe=r=>r.replace(Pwe,""),Dwe=/([A-Z])/g,pP=(r,e)=>Rwe(r.replace(Dwe,t=>`${e}${Iwe(t)}`)),Lwe=r=>{const e=unescape(encodeURIComponent(r)),t=e.length,n=new Uint8Array(t);for(let i=0;i<t;i++)n[i]=e.codePointAt(i);return n},Bf=typeof TextEncoder<"u"?new TextEncoder:null,Nwe=r=>Bf.encode(r),Owe=Bf?Nwe:Lwe;let zd=typeof TextDecoder>"u"?null:new TextDecoder("utf-8",{fatal:!0,ignoreBOM:!0});zd&&zd.decode(new Uint8Array).length===1&&(zd=null);class bp{constructor(){this.cpos=0,this.cbuf=new Uint8Array(100),this.bufs=[]}}const tb=()=>new bp,Uwe=r=>{let e=r.cpos;for(let t=0;t<r.bufs.length;t++)e+=r.bufs[t].length;return e},Ss=r=>{const e=new Uint8Array(Uwe(r));let t=0;for(let n=0;n<r.bufs.length;n++){const i=r.bufs[n];e.set(i,t),t+=i.length}return e.set(new Uint8Array(r.cbuf.buffer,0,r.cpos),t),e},kwe=(r,e)=>{const t=r.cbuf.length;t-r.cpos<e&&(r.bufs.push(new Uint8Array(r.cbuf.buffer,0,r.cpos)),r.cbuf=new Uint8Array(Qc(t,e)*2),r.cpos=0)},Cn=(r,e)=>{const t=r.cbuf.length;r.cpos===t&&(r.bufs.push(r.cbuf),r.cbuf=new Uint8Array(t*2),r.cpos=0),r.cbuf[r.cpos++]=e},hE=Cn,pt=(r,e)=>{for(;e>Cc;)Cn(r,si|Cc&e),e=Ca(e/128);Cn(r,Cc&e)},qM=(r,e)=>{const t=n6(e);for(t&&(e=-e),Cn(r,(e>uE?si:0)|(t?Eo:0)|uE&e),e=Ca(e/64);e>0;)Cn(r,(e>Cc?si:0)|Cc&e),e=Ca(e/128)},dE=new Uint8Array(3e4),Bwe=dE.length/3,Fwe=(r,e)=>{if(e.length<Bwe){const t=Bf.encodeInto(e,dE).written||0;pt(r,t);for(let n=0;n<t;n++)Cn(r,dE[n])}else Zr(r,Owe(e))},$we=(r,e)=>{const t=unescape(encodeURIComponent(e)),n=t.length;pt(r,n);for(let i=0;i<n;i++)Cn(r,t.codePointAt(i))},nu=Bf&&Bf.encodeInto?Fwe:$we,nb=(r,e)=>{const t=r.cbuf.length,n=r.cpos,i=t6(t-n,e.length),s=e.length-i;r.cbuf.set(e.subarray(0,i),n),r.cpos+=i,s>0&&(r.bufs.push(r.cbuf),r.cbuf=new Uint8Array(Qc(t*2,s)),r.cbuf.set(e.subarray(i)),r.cpos=s)},Zr=(r,e)=>{pt(r,e.byteLength),nb(r,e)},KM=(r,e)=>{kwe(r,e);const t=new DataView(r.cbuf.buffer,r.cpos,e);return r.cpos+=e,t},zwe=(r,e)=>KM(r,4).setFloat32(0,e,!1),Vwe=(r,e)=>KM(r,8).setFloat64(0,e,!1),Hwe=(r,e)=>KM(r,8).setBigInt64(0,e,!1),mP=new DataView(new ArrayBuffer(4)),Gwe=r=>(mP.setFloat32(0,r),mP.getFloat32(0)===r),Ff=(r,e)=>{switch(typeof e){case"string":Cn(r,119),nu(r,e);break;case"number":Cwe(e)&&Dg(e)<=Twe?(Cn(r,125),qM(r,e)):Gwe(e)?(Cn(r,124),zwe(r,e)):(Cn(r,123),Vwe(r,e));break;case"bigint":Cn(r,122),Hwe(r,e);break;case"object":if(e===null)Cn(r,126);else if(Awe(e)){Cn(r,117),pt(r,e.length);for(let t=0;t<e.length;t++)Ff(r,e[t])}else if(e instanceof Uint8Array)Cn(r,116),Zr(r,e);else{Cn(r,118);const t=Object.keys(e);pt(r,t.length);for(let n=0;n<t.length;n++){const i=t[n];nu(r,i),Ff(r,e[i])}}break;case"boolean":Cn(r,e?120:121);break;default:Cn(r,127)}};class gP extends bp{constructor(e){super(),this.w=e,this.s=null,this.count=0}write(e){this.s===e?this.count++:(this.count>0&&pt(this,this.count-1),this.count=1,this.w(this,e),this.s=e)}}const yP=r=>{r.count>0&&(qM(r.encoder,r.count===1?r.s:-r.s),r.count>1&&pt(r.encoder,r.count-2))};class Lg{constructor(){this.encoder=new bp,this.s=0,this.count=0}write(e){this.s===e?this.count++:(yP(this),this.count=1,this.s=e)}toUint8Array(){return yP(this),Ss(this.encoder)}}const bP=r=>{if(r.count>0){const e=r.diff*2+(r.count===1?0:1);qM(r.encoder,e),r.count>1&&pt(r.encoder,r.count-2)}};class av{constructor(){this.encoder=new bp,this.s=0,this.count=0,this.diff=0}write(e){this.diff===e-this.s?(this.s=e,this.count++):(bP(this),this.count=1,this.diff=e-this.s,this.s=e)}toUint8Array(){return bP(this),Ss(this.encoder)}}class Wwe{constructor(){this.sarr=[],this.s="",this.lensE=new Lg}write(e){this.s+=e,this.s.length>19&&(this.sarr.push(this.s),this.s=""),this.lensE.write(e.length)}toUint8Array(){const e=new bp;return this.sarr.push(this.s),this.s="",nu(e,this.sarr.join("")),nb(e,this.lensE.toUint8Array()),Ss(e)}}const el=r=>new Error(r),As=()=>{throw el("Method unimplemented")},Ps=()=>{throw el("Unexpected case")},i6=el("Unexpected end of array"),s6=el("Integer out of Range");class rb{constructor(e){this.arr=e,this.pos=0}}const Ph=r=>new rb(r),qwe=r=>r.pos!==r.arr.length,Kwe=(r,e)=>{const t=new Uint8Array(r.arr.buffer,r.pos+r.arr.byteOffset,e);return r.pos+=e,t},Jr=r=>Kwe(r,at(r)),lh=r=>r.arr[r.pos++],at=r=>{let e=0,t=1;const n=r.arr.length;for(;r.pos<n;){const i=r.arr[r.pos++];if(e=e+(i&Cc)*t,t*=128,i<si)return e;if(e>r6)throw s6}throw i6},XM=r=>{let e=r.arr[r.pos++],t=e&uE,n=64;const i=(e&Eo)>0?-1:1;if((e&si)===0)return i*t;const s=r.arr.length;for(;r.pos<s;){if(e=r.arr[r.pos++],t=t+(e&Cc)*n,n*=128,e<si)return i*t;if(t>r6)throw s6}throw i6},Xwe=r=>{let e=at(r);if(e===0)return"";{let t=String.fromCodePoint(lh(r));if(--e<100)for(;e--;)t+=String.fromCodePoint(lh(r));else for(;e>0;){const n=e<1e4?e:1e4,i=r.arr.subarray(r.pos,r.pos+n);r.pos+=n,t+=String.fromCodePoint.apply(null,i),e-=n}return decodeURIComponent(escape(t))}},Ywe=r=>zd.decode(Jr(r)),ru=zd?Ywe:Xwe,YM=(r,e)=>{const t=new DataView(r.arr.buffer,r.arr.byteOffset+r.pos,e);return r.pos+=e,t},Zwe=r=>YM(r,4).getFloat32(0,!1),Jwe=r=>YM(r,8).getFloat64(0,!1),jwe=r=>YM(r,8).getBigInt64(0,!1),Qwe=[r=>{},r=>null,XM,Zwe,Jwe,jwe,r=>!1,r=>!0,ru,r=>{const e=at(r),t={};for(let n=0;n<e;n++){const i=ru(r);t[i]=$f(r)}return t},r=>{const e=at(r),t=[];for(let n=0;n<e;n++)t.push($f(r));return t},Jr],$f=r=>Qwe[127-lh(r)](r);class wP extends rb{constructor(e,t){super(e),this.reader=t,this.s=null,this.count=0}read(){return this.count===0&&(this.s=this.reader(this),qwe(this)?this.count=at(this)+1:this.count=-1),this.count--,this.s}}class Ng extends rb{constructor(e){super(e),this.s=0,this.count=0}read(){if(this.count===0){this.s=XM(this);const e=n6(this.s);this.count=1,e&&(this.s=-this.s,this.count=at(this)+2)}return this.count--,this.s}}class cv extends rb{constructor(e){super(e),this.s=0,this.count=0,this.diff=0}read(){if(this.count===0){const e=XM(this),t=e&1;this.diff=Ca(e/2),this.count=1,t&&(this.count=at(this)+2)}return this.s+=this.diff,this.count--,this.s}}class eve{constructor(e){this.decoder=new Ng(e),this.str=ru(this.decoder),this.spos=0}read(){const e=this.spos+this.decoder.read(),t=this.str.slice(this.spos,e);return this.spos=e,t}}const tve=crypto.getRandomValues.bind(crypto),o6=()=>tve(new Uint32Array(1))[0],nve="10000000-1000-4000-8000"+-1e11,rve=()=>nve.replace(/[018]/g,r=>(r^o6()&15>>r/4).toString(16)),uh=r=>new Promise(r);Promise.all.bind(Promise);const vP=r=>r===void 0?null:r;class ive{constructor(){this.map=new Map}setItem(e,t){this.map.set(e,t)}getItem(e){return this.map.get(e)}}let a6=new ive,sve=!0;try{typeof localStorage<"u"&&localStorage&&(a6=localStorage,sve=!1)}catch{}const ove=a6,ave=Object.assign,cve=Object.keys,_P=r=>cve(r).length,lve=r=>{for(const e in r)return!1;return!0},uve=(r,e)=>{for(const t in r)if(!e(r[t],t))return!1;return!0},hve=(r,e)=>Object.prototype.hasOwnProperty.call(r,e),dve=(r,e)=>r===e||_P(r)===_P(e)&&uve(r,(t,n)=>(t!==void 0||hve(e,n))&&e[n]===t),ZM=(r,e,t=0)=>{try{for(;t<r.length;t++)r[t](...e)}finally{t<r.length&&ZM(r,e,t+1)}},fve=(r,e)=>e.includes(r);var c6={};const zf=typeof process<"u"&&process.release&&/node|io\.js/.test(process.release.name)&&Object.prototype.toString.call(typeof process<"u"?process:0)==="[object process]";let ls;const pve=()=>{if(ls===void 0)if(zf){ls=es();const r=process.argv;let e=null;for(let t=0;t<r.length;t++){const n=r[t];n[0]==="-"?(e!==null&&ls.set(e,""),e=n):e!==null&&(ls.set(e,n),e=null)}e!==null&&ls.set(e,"")}else typeof location=="object"?(ls=es(),(location.search||"?").slice(1).split("&").forEach(r=>{if(r.length!==0){const[e,t]=r.split("=");ls.set(`--${pP(e,"-")}`,t),ls.set(`-${pP(e,"-")}`,t)}})):ls=es();return ls},fE=r=>pve().has(r),pE=r=>vP(zf?c6[r.toUpperCase().replaceAll("-","_")]:ove.getItem(r)),l6=r=>fE("--"+r)||pE(r)!==null;l6("production");const mve=zf&&fve(c6.FORCE_COLOR,["true","1","2"]),gve=mve||!fE("--no-colors")&&!l6("no-color")&&(!zf||process.stdout.isTTY)&&(!zf||fE("--color")||pE("COLORTERM")!==null||(pE("TERM")||"").includes("color")),yve=r=>new Uint8Array(r),bve=r=>{const e=yve(r.byteLength);return e.set(r),e};class wve{constructor(e,t){this.left=e,this.right=t}}const qs=(r,e)=>new wve(r,e);typeof DOMParser<"u"&&new DOMParser;const vve=r=>Swe(r,(e,t)=>`${t}:${e};`).join(""),Oo=Symbol,u6=Oo(),h6=Oo(),_ve=Oo(),xve=Oo(),Sve=Oo(),d6=Oo(),Eve=Oo(),f6=Oo(),Mve=Oo(),Ave=r=>{var i;r.length===1&&((i=r[0])==null?void 0:i.constructor)===Function&&(r=r[0]());const e=[],t=[];let n=0;for(;n<r.length;n++){const s=r[n];if(s===void 0)break;if(s.constructor===String||s.constructor===Number)e.push(s);else if(s.constructor===Object)break}for(n>0&&t.push(e.join(""));n<r.length;n++){const s=r[n];s instanceof Symbol||t.push(s)}return t},Tve={[u6]:qs("font-weight","bold"),[h6]:qs("font-weight","normal"),[_ve]:qs("color","blue"),[Sve]:qs("color","green"),[xve]:qs("color","grey"),[d6]:qs("color","red"),[Eve]:qs("color","purple"),[f6]:qs("color","orange"),[Mve]:qs("color","black")},Cve=r=>{var o;r.length===1&&((o=r[0])==null?void 0:o.constructor)===Function&&(r=r[0]());const e=[],t=[],n=es();let i=[],s=0;for(;s<r.length;s++){const a=r[s],c=Tve[a];if(c!==void 0)n.set(c.left,c.right);else{if(a===void 0)break;if(a.constructor===String||a.constructor===Number){const l=vve(n);s>0||l.length>0?(e.push("%c"+a),t.push(l)):e.push(a)}else break}}for(s>0&&(i=t,i.unshift(e.join("")));s<r.length;s++){const a=r[s];a instanceof Symbol||i.push(a)}return i},Ive=gve?Cve:Ave,Pve=(...r)=>{console.log(...Ive(r)),Rve.forEach(e=>e.print(r))},Rve=ch(),p6=r=>({[Symbol.iterator](){return this},next:r}),Dve=(r,e)=>p6(()=>{let t;do t=r.next();while(!t.done&&!e(t.value));return t}),lv=(r,e)=>p6(()=>{const{done:t,value:n}=r.next();return{done:t,value:t?void 0:e(n)}});class JM{constructor(e,t){this.clock=e,this.len=t}}class wp{constructor(){this.clients=new Map}}const mE=(r,e,t)=>e.clients.forEach((n,i)=>{const s=r.doc.store.clients.get(i);for(let o=0;o<n.length;o++){const a=n[o];M6(r,s,a.clock,a.len,t)}}),Lve=(r,e)=>{let t=0,n=r.length-1;for(;t<=n;){const i=Ca((t+n)/2),s=r[i],o=s.clock;if(o<=e){if(e<o+s.len)return i;t=i+1}else n=i-1}return null},m6=(r,e)=>{const t=r.clients.get(e.client);return t!==void 0&&Lve(t,e.clock)!==null},jM=r=>{r.clients.forEach(e=>{e.sort((i,s)=>i.clock-s.clock);let t,n;for(t=1,n=1;t<e.length;t++){const i=e[n-1],s=e[t];i.clock+i.len>=s.clock?i.len=Qc(i.len,s.clock+s.len-i.clock):(n<t&&(e[n]=s),n++)}e.length=n})},Nve=r=>{const e=new wp;for(let t=0;t<r.length;t++)r[t].clients.forEach((n,i)=>{if(!e.clients.has(i)){const s=n.slice();for(let o=t+1;o<r.length;o++)Mwe(s,r[o].clients.get(i)||[]);e.clients.set(i,s)}});return jM(e),e},Gy=(r,e,t,n)=>{Na(r.clients,e,()=>[]).push(new JM(t,n))},Ove=()=>new wp,Uve=r=>{const e=Ove();return r.clients.forEach((t,n)=>{const i=[];for(let s=0;s<t.length;s++){const o=t[s];if(o.deleted){const a=o.id.clock;let c=o.length;if(s+1<t.length)for(let l=t[s+1];s+1<t.length&&l.deleted;l=t[++s+1])c+=l.length;i.push(new JM(a,c))}}i.length>0&&e.clients.set(n,i)}),e},Rh=(r,e)=>{pt(r.restEncoder,e.clients.size),Wc(e.clients.entries()).sort((t,n)=>n[0]-t[0]).forEach(([t,n])=>{r.resetDsCurVal(),pt(r.restEncoder,t);const i=n.length;pt(r.restEncoder,i);for(let s=0;s<i;s++){const o=n[s];r.writeDsClock(o.clock),r.writeDsLen(o.len)}})},QM=r=>{const e=new wp,t=at(r.restDecoder);for(let n=0;n<t;n++){r.resetDsCurVal();const i=at(r.restDecoder),s=at(r.restDecoder);if(s>0){const o=Na(e.clients,i,()=>[]);for(let a=0;a<s;a++)o.push(new JM(r.readDsClock(),r.readDsLen()))}}return e},xP=(r,e,t)=>{const n=new wp,i=at(r.restDecoder);for(let s=0;s<i;s++){r.resetDsCurVal();const o=at(r.restDecoder),a=at(r.restDecoder),c=t.clients.get(o)||[],l=Pn(t,o);for(let u=0;u<a;u++){const h=r.readDsClock(),d=h+r.readDsLen();if(h<l){l<d&&Gy(n,o,l,d-l);let m=Rs(c,h),p=c[m];for(!p.deleted&&p.id.clock<h&&(c.splice(m+1,0,Jy(e,p,h-p.id.clock)),m++);m<c.length&&(p=c[m++],p.id.clock<d);)p.deleted||(d<p.id.clock+p.length&&c.splice(m,0,Jy(e,p,d-p.id.clock)),p.delete(e))}else Gy(n,o,h,d-h)}}if(n.clients.size>0){const s=new qc;return pt(s.restEncoder,0),Rh(s,n),s.toUint8Array()}return null},g6=o6;class Dh extends WM{constructor({guid:e=rve(),collectionid:t=null,gc:n=!0,gcFilter:i=()=>!0,meta:s=null,autoLoad:o=!1,shouldLoad:a=!0}={}){super(),this.gc=n,this.gcFilter=i,this.clientID=g6(),this.guid=e,this.collectionid=t,this.share=new Map,this.store=new S6,this._transaction=null,this._transactionCleanups=[],this.subdocs=new Set,this._item=null,this.shouldLoad=a,this.autoLoad=o,this.meta=s,this.isLoaded=!1,this.isSynced=!1,this.whenLoaded=uh(l=>{this.on("load",()=>{this.isLoaded=!0,l(this)})});const c=()=>uh(l=>{const u=h=>{(h===void 0||h===!0)&&(this.off("sync",u),l())};this.on("sync",u)});this.on("sync",l=>{l===!1&&this.isSynced&&(this.whenSynced=c()),this.isSynced=l===void 0||l===!0,this.isLoaded||this.emit("load",[])}),this.whenSynced=c()}load(){const e=this._item;e!==null&&!this.shouldLoad&&Lt(e.parent.doc,t=>{t.subdocsLoaded.add(this)},null,!0),this.shouldLoad=!0}getSubdocs(){return this.subdocs}getSubdocGuids(){return new Set(Wc(this.subdocs).map(e=>e.guid))}transact(e,t=null){return Lt(this,e,t)}get(e,t=Vn){const n=Na(this.share,e,()=>{const s=new t;return s._integrate(this,null),s}),i=n.constructor;if(t!==Vn&&i!==t)if(i===Vn){const s=new t;s._map=n._map,n._map.forEach(o=>{for(;o!==null;o=o.left)o.parent=s}),s._start=n._start;for(let o=s._start;o!==null;o=o.right)o.parent=s;return s._length=n._length,this.share.set(e,s),s._integrate(this,null),s}else throw new Error(`Type with the name ${e} has already been defined with a different constructor`);return n}getArray(e=""){return this.get(e,su)}getText(e=""){return this.get(e,dh)}getMap(e=""){return this.get(e,Pa)}getXmlFragment(e=""){return this.get(e,Kc)}toJSON(){const e={};return this.share.forEach((t,n)=>{e[n]=t.toJSON()}),e}destroy(){Wc(this.subdocs).forEach(t=>t.destroy());const e=this._item;if(e!==null){this._item=null;const t=e.content;t.doc=new Dh({guid:this.guid,...t.opts,shouldLoad:!1}),t.doc._item=e,Lt(e.parent.doc,n=>{const i=t.doc;e.deleted||n.subdocsAdded.add(i),n.subdocsRemoved.add(this)},null,!0)}this.emit("destroyed",[!0]),this.emit("destroy",[this]),super.destroy()}on(e,t){super.on(e,t)}off(e,t){super.off(e,t)}}class y6{constructor(e){this.restDecoder=e}resetDsCurVal(){}readDsClock(){return at(this.restDecoder)}readDsLen(){return at(this.restDecoder)}}class b6 extends y6{readLeftID(){return ht(at(this.restDecoder),at(this.restDecoder))}readRightID(){return ht(at(this.restDecoder),at(this.restDecoder))}readClient(){return at(this.restDecoder)}readInfo(){return lh(this.restDecoder)}readString(){return ru(this.restDecoder)}readParentInfo(){return at(this.restDecoder)===1}readTypeRef(){return at(this.restDecoder)}readLen(){return at(this.restDecoder)}readAny(){return $f(this.restDecoder)}readBuf(){return bve(Jr(this.restDecoder))}readJSON(){return JSON.parse(ru(this.restDecoder))}readKey(){return ru(this.restDecoder)}}class kve{constructor(e){this.dsCurrVal=0,this.restDecoder=e}resetDsCurVal(){this.dsCurrVal=0}readDsClock(){return this.dsCurrVal+=at(this.restDecoder),this.dsCurrVal}readDsLen(){const e=at(this.restDecoder)+1;return this.dsCurrVal+=e,e}}class hh extends kve{constructor(e){super(e),this.keys=[],at(e),this.keyClockDecoder=new cv(Jr(e)),this.clientDecoder=new Ng(Jr(e)),this.leftClockDecoder=new cv(Jr(e)),this.rightClockDecoder=new cv(Jr(e)),this.infoDecoder=new wP(Jr(e),lh),this.stringDecoder=new eve(Jr(e)),this.parentInfoDecoder=new wP(Jr(e),lh),this.typeRefDecoder=new Ng(Jr(e)),this.lenDecoder=new Ng(Jr(e))}readLeftID(){return new iu(this.clientDecoder.read(),this.leftClockDecoder.read())}readRightID(){return new iu(this.clientDecoder.read(),this.rightClockDecoder.read())}readClient(){return this.clientDecoder.read()}readInfo(){return this.infoDecoder.read()}readString(){return this.stringDecoder.read()}readParentInfo(){return this.parentInfoDecoder.read()===1}readTypeRef(){return this.typeRefDecoder.read()}readLen(){return this.lenDecoder.read()}readAny(){return $f(this.restDecoder)}readBuf(){return Jr(this.restDecoder)}readJSON(){return $f(this.restDecoder)}readKey(){const e=this.keyClockDecoder.read();if(e<this.keys.length)return this.keys[e];{const t=this.stringDecoder.read();return this.keys.push(t),t}}}class Bve{constructor(){this.restEncoder=tb()}toUint8Array(){return Ss(this.restEncoder)}resetDsCurVal(){}writeDsClock(e){pt(this.restEncoder,e)}writeDsLen(e){pt(this.restEncoder,e)}}class vp extends Bve{writeLeftID(e){pt(this.restEncoder,e.client),pt(this.restEncoder,e.clock)}writeRightID(e){pt(this.restEncoder,e.client),pt(this.restEncoder,e.clock)}writeClient(e){pt(this.restEncoder,e)}writeInfo(e){hE(this.restEncoder,e)}writeString(e){nu(this.restEncoder,e)}writeParentInfo(e){pt(this.restEncoder,e?1:0)}writeTypeRef(e){pt(this.restEncoder,e)}writeLen(e){pt(this.restEncoder,e)}writeAny(e){Ff(this.restEncoder,e)}writeBuf(e){Zr(this.restEncoder,e)}writeJSON(e){nu(this.restEncoder,JSON.stringify(e))}writeKey(e){nu(this.restEncoder,e)}}class Fve{constructor(){this.restEncoder=tb(),this.dsCurrVal=0}toUint8Array(){return Ss(this.restEncoder)}resetDsCurVal(){this.dsCurrVal=0}writeDsClock(e){const t=e-this.dsCurrVal;this.dsCurrVal=e,pt(this.restEncoder,t)}writeDsLen(e){e===0&&Ps(),pt(this.restEncoder,e-1),this.dsCurrVal+=e}}class qc extends Fve{constructor(){super(),this.keyMap=new Map,this.keyClock=0,this.keyClockEncoder=new av,this.clientEncoder=new Lg,this.leftClockEncoder=new av,this.rightClockEncoder=new av,this.infoEncoder=new gP(hE),this.stringEncoder=new Wwe,this.parentInfoEncoder=new gP(hE),this.typeRefEncoder=new Lg,this.lenEncoder=new Lg}toUint8Array(){const e=tb();return pt(e,0),Zr(e,this.keyClockEncoder.toUint8Array()),Zr(e,this.clientEncoder.toUint8Array()),Zr(e,this.leftClockEncoder.toUint8Array()),Zr(e,this.rightClockEncoder.toUint8Array()),Zr(e,Ss(this.infoEncoder)),Zr(e,this.stringEncoder.toUint8Array()),Zr(e,Ss(this.parentInfoEncoder)),Zr(e,this.typeRefEncoder.toUint8Array()),Zr(e,this.lenEncoder.toUint8Array()),nb(e,Ss(this.restEncoder)),Ss(e)}writeLeftID(e){this.clientEncoder.write(e.client),this.leftClockEncoder.write(e.clock)}writeRightID(e){this.clientEncoder.write(e.client),this.rightClockEncoder.write(e.clock)}writeClient(e){this.clientEncoder.write(e)}writeInfo(e){this.infoEncoder.write(e)}writeString(e){this.stringEncoder.write(e)}writeParentInfo(e){this.parentInfoEncoder.write(e?1:0)}writeTypeRef(e){this.typeRefEncoder.write(e)}writeLen(e){this.lenEncoder.write(e)}writeAny(e){Ff(this.restEncoder,e)}writeBuf(e){Zr(this.restEncoder,e)}writeJSON(e){Ff(this.restEncoder,e)}writeKey(e){const t=this.keyMap.get(e);t===void 0?(this.keyClockEncoder.write(this.keyClock++),this.stringEncoder.write(e)):this.keyClockEncoder.write(t)}}const $ve=(r,e,t,n)=>{n=Qc(n,e[0].id.clock);const i=Rs(e,n);pt(r.restEncoder,e.length-i),r.writeClient(t),pt(r.restEncoder,n);const s=e[i];s.write(r,n-s.id.clock);for(let o=i+1;o<e.length;o++)e[o].write(r,0)},eA=(r,e,t)=>{const n=new Map;t.forEach((i,s)=>{Pn(e,s)>i&&n.set(s,i)}),nA(e).forEach((i,s)=>{t.has(s)||n.set(s,0)}),pt(r.restEncoder,n.size),Wc(n.entries()).sort((i,s)=>s[0]-i[0]).forEach(([i,s])=>{$ve(r,e.clients.get(i),i,s)})},zve=(r,e)=>{const t=es(),n=at(r.restDecoder);for(let i=0;i<n;i++){const s=at(r.restDecoder),o=new Array(s),a=r.readClient();let c=at(r.restDecoder);t.set(a,{i:0,refs:o});for(let l=0;l<s;l++){const u=r.readInfo();switch(eb&u){case 0:{const h=r.readLen();o[l]=new fi(ht(a,c),h),c+=h;break}case 10:{const h=at(r.restDecoder);o[l]=new pi(ht(a,c),h),c+=h;break}default:{const h=(u&(Eo|si))===0,d=new wn(ht(a,c),null,(u&si)===si?r.readLeftID():null,null,(u&Eo)===Eo?r.readRightID():null,h?r.readParentInfo()?e.get(r.readString()):r.readLeftID():null,h&&(u&kf)===kf?r.readString():null,G6(r,u));o[l]=d,c+=d.length}}}}return t},Vve=(r,e,t)=>{const n=[];let i=Wc(t.keys()).sort((m,p)=>m-p);if(i.length===0)return null;const s=()=>{if(i.length===0)return null;let m=t.get(i[i.length-1]);for(;m.refs.length===m.i;)if(i.pop(),i.length>0)m=t.get(i[i.length-1]);else return null;return m};let o=s();if(o===null&&n.length===0)return null;const a=new S6,c=new Map,l=(m,p)=>{const b=c.get(m);(b==null||b>p)&&c.set(m,p)};let u=o.refs[o.i++];const h=new Map,d=()=>{for(const m of n){const p=m.id.client,b=t.get(p);b?(b.i--,a.clients.set(p,b.refs.slice(b.i)),t.delete(p),b.i=0,b.refs=[]):a.clients.set(p,[m]),i=i.filter(g=>g!==p)}n.length=0};for(;;){if(u.constructor!==pi){const p=Na(h,u.id.client,()=>Pn(e,u.id.client))-u.id.clock;if(p<0)n.push(u),l(u.id.client,u.id.clock-1),d();else{const b=u.getMissing(r,e);if(b!==null){n.push(u);const g=t.get(b)||{refs:[],i:0};if(g.refs.length===g.i)l(b,Pn(e,b)),d();else{u=g.refs[g.i++];continue}}else(p===0||p<u.length)&&(u.integrate(r,p),h.set(u.id.client,u.id.clock+u.length))}}if(n.length>0)u=n.pop();else if(o!==null&&o.i<o.refs.length)u=o.refs[o.i++];else{if(o=s(),o===null)break;u=o.refs[o.i++]}}if(a.clients.size>0){const m=new qc;return eA(m,a,new Map),pt(m.restEncoder,0),{missing:c,update:m.toUint8Array()}}return null},Hve=(r,e)=>eA(r,e.doc.store,e.beforeState),Gve=(r,e,t,n=new hh(r))=>Lt(e,i=>{i.local=!1;let s=!1;const o=i.doc,a=o.store,c=zve(n,o),l=Vve(i,a,c),u=a.pendingStructs;if(u){for(const[d,m]of u.missing)if(m<Pn(a,d)){s=!0;break}if(l){for(const[d,m]of l.missing){const p=u.missing.get(d);(p==null||p>m)&&u.missing.set(d,m)}u.update=Wy([u.update,l.update])}}else a.pendingStructs=l;const h=xP(n,i,a);if(a.pendingDs){const d=new hh(Ph(a.pendingDs));at(d.restDecoder);const m=xP(d,i,a);h&&m?a.pendingDs=Wy([h,m]):a.pendingDs=h||m}else a.pendingDs=h;if(s){const d=a.pendingStructs.update;a.pendingStructs=null,w6(i.doc,d)}},t,!1),w6=(r,e,t,n=hh)=>{const i=Ph(e);Gve(i,r,t,new n(i))},tA=(r,e,t)=>w6(r,e,t,b6),Wve=(r,e,t=new Map)=>{eA(r,e.store,t),Rh(r,Uve(e.store))},qve=(r,e=new Uint8Array([0]),t=new qc)=>{const n=_6(e);Wve(t,r,n);const i=[t.toUint8Array()];if(r.store.pendingDs&&i.push(r.store.pendingDs),r.store.pendingStructs&&i.push(i_e(r.store.pendingStructs.update,e)),i.length>1){if(t.constructor===vp)return n_e(i.map((s,o)=>o===0?s:o_e(s)));if(t.constructor===qc)return Wy(i)}return i[0]},v6=(r,e)=>qve(r,e,new vp),Kve=r=>{const e=new Map,t=at(r.restDecoder);for(let n=0;n<t;n++){const i=at(r.restDecoder),s=at(r.restDecoder);e.set(i,s)}return e},_6=r=>Kve(new y6(Ph(r)));class Xve{constructor(){this.l=[]}}const SP=()=>new Xve,EP=(r,e)=>r.l.push(e),MP=(r,e)=>{const t=r.l,n=t.length;r.l=t.filter(i=>e!==i),n===r.l.length&&console.error("[yjs] Tried to remove event handler that doesn't exist.")},x6=(r,e,t)=>ZM(r.l,[e,t]);class iu{constructor(e,t){this.client=e,this.clock=t}}const rg=(r,e)=>r===e||r!==null&&e!==null&&r.client===e.client&&r.clock===e.clock,ht=(r,e)=>new iu(r,e),Yve=r=>{for(const[e,t]of r.doc.share.entries())if(t===r)return e;throw Ps()},nd=(r,e)=>e===void 0?!r.deleted:e.sv.has(r.id.client)&&(e.sv.get(r.id.client)||0)>r.id.clock&&!m6(e.ds,r.id),gE=(r,e)=>{const t=Na(r.meta,gE,ch),n=r.doc.store;t.has(e)||(e.sv.forEach((i,s)=>{i<Pn(n,s)&&Ia(r,ht(s,i))}),mE(r,e.ds,i=>{}),t.add(e))};class S6{constructor(){this.clients=new Map,this.pendingStructs=null,this.pendingDs=null}}const nA=r=>{const e=new Map;return r.clients.forEach((t,n)=>{const i=t[t.length-1];e.set(n,i.id.clock+i.length)}),e},Pn=(r,e)=>{const t=r.clients.get(e);if(t===void 0)return 0;const n=t[t.length-1];return n.id.clock+n.length},E6=(r,e)=>{let t=r.clients.get(e.id.client);if(t===void 0)t=[],r.clients.set(e.id.client,t);else{const n=t[t.length-1];if(n.id.clock+n.length!==e.id.clock)throw Ps()}t.push(e)},Rs=(r,e)=>{let t=0,n=r.length-1,i=r[n],s=i.id.clock;if(s===e)return n;let o=Ca(e/(s+i.length-1)*n);for(;t<=n;){if(i=r[o],s=i.id.clock,s<=e){if(e<s+i.length)return o;t=o+1}else n=o-1;o=Ca((t+n)/2)}throw Ps()},Zve=(r,e)=>{const t=r.clients.get(e.client);return t[Rs(t,e.clock)]},uv=Zve,yE=(r,e,t)=>{const n=Rs(e,t),i=e[n];return i.id.clock<t&&i instanceof wn?(e.splice(n+1,0,Jy(r,i,t-i.id.clock)),n+1):n},Ia=(r,e)=>{const t=r.doc.store.clients.get(e.client);return t[yE(r,t,e.clock)]},AP=(r,e,t)=>{const n=e.clients.get(t.client),i=Rs(n,t.clock),s=n[i];return t.clock!==s.id.clock+s.length-1&&s.constructor!==fi&&n.splice(i+1,0,Jy(r,s,t.clock-s.id.clock+1)),s},Jve=(r,e,t)=>{const n=r.clients.get(e.id.client);n[Rs(n,e.id.clock)]=t},M6=(r,e,t,n,i)=>{if(n===0)return;const s=t+n;let o=yE(r,e,t),a;do a=e[o++],s<a.id.clock+a.length&&yE(r,e,s),i(a);while(o<e.length&&e[o].id.clock<s)};class jve{constructor(e,t,n){this.doc=e,this.deleteSet=new wp,this.beforeState=nA(e.store),this.afterState=new Map,this.changed=new Map,this.changedParentTypes=new Map,this._mergeStructs=[],this.origin=t,this.meta=new Map,this.local=n,this.subdocsAdded=new Set,this.subdocsRemoved=new Set,this.subdocsLoaded=new Set}}const TP=(r,e)=>e.deleteSet.clients.size===0&&!Ewe(e.afterState,(t,n)=>e.beforeState.get(n)!==t)?!1:(jM(e.deleteSet),Hve(r,e),Rh(r,e.deleteSet),!0),CP=(r,e,t)=>{const n=e._item;(n===null||n.id.clock<(r.beforeState.get(n.id.client)||0)&&!n.deleted)&&Na(r.changed,e,ch).add(t)},Og=(r,e)=>{const t=r[e-1],n=r[e];t.deleted===n.deleted&&t.constructor===n.constructor&&t.mergeWith(n)&&(r.splice(e,1),n instanceof wn&&n.parentSub!==null&&n.parent._map.get(n.parentSub)===n&&n.parent._map.set(n.parentSub,t))},Qve=(r,e,t)=>{for(const[n,i]of r.clients.entries()){const s=e.clients.get(n);for(let o=i.length-1;o>=0;o--){const a=i[o],c=a.clock+a.len;for(let l=Rs(s,a.clock),u=s[l];l<s.length&&u.id.clock<c;u=s[++l]){const h=s[l];if(a.clock+a.len<=h.id.clock)break;h instanceof wn&&h.deleted&&!h.keep&&t(h)&&h.gc(e,!1)}}}},e_e=(r,e)=>{r.clients.forEach((t,n)=>{const i=e.clients.get(n);for(let s=t.length-1;s>=0;s--){const o=t[s],a=t6(i.length-1,1+Rs(i,o.clock+o.len-1));for(let c=a,l=i[c];c>0&&l.id.clock>=o.clock;l=i[--c])Og(i,c)}})},A6=(r,e)=>{if(e<r.length){const t=r[e],n=t.doc,i=n.store,s=t.deleteSet,o=t._mergeStructs;try{jM(s),t.afterState=nA(t.doc.store),n.emit("beforeObserverCalls",[t,n]);const a=[];t.changed.forEach((c,l)=>a.push(()=>{(l._item===null||!l._item.deleted)&&l._callObserver(t,c)})),a.push(()=>{t.changedParentTypes.forEach((c,l)=>a.push(()=>{(l._item===null||!l._item.deleted)&&(c=c.filter(u=>u.target._item===null||!u.target._item.deleted),c.forEach(u=>{u.currentTarget=l}),c.sort((u,h)=>u.path.length-h.path.length),x6(l._dEH,c,t))})),a.push(()=>n.emit("afterTransaction",[t,n]))}),ZM(a,[])}finally{n.gc&&Qve(s,i,n.gcFilter),e_e(s,i),t.afterState.forEach((u,h)=>{const d=t.beforeState.get(h)||0;if(d!==u){const m=i.clients.get(h),p=Qc(Rs(m,d),1);for(let b=m.length-1;b>=p;b--)Og(m,b)}});for(let u=0;u<o.length;u++){const{client:h,clock:d}=o[u].id,m=i.clients.get(h),p=Rs(m,d);p+1<m.length&&Og(m,p+1),p>0&&Og(m,p)}if(!t.local&&t.afterState.get(n.clientID)!==t.beforeState.get(n.clientID)&&(Pve(f6,u6,"[yjs] ",h6,d6,"Changed the client-id because another client seems to be using it."),n.clientID=g6()),n.emit("afterTransactionCleanup",[t,n]),n._observers.has("update")){const u=new vp;TP(u,t)&&n.emit("update",[u.toUint8Array(),t.origin,n,t])}if(n._observers.has("updateV2")){const u=new qc;TP(u,t)&&n.emit("updateV2",[u.toUint8Array(),t.origin,n,t])}const{subdocsAdded:a,subdocsLoaded:c,subdocsRemoved:l}=t;(a.size>0||l.size>0||c.size>0)&&(a.forEach(u=>{u.clientID=n.clientID,u.collectionid==null&&(u.collectionid=n.collectionid),n.subdocs.add(u)}),l.forEach(u=>n.subdocs.delete(u)),n.emit("subdocs",[{loaded:c,added:a,removed:l},n,t]),l.forEach(u=>u.destroy())),r.length<=e+1?(n._transactionCleanups=[],n.emit("afterAllTransactions",[n,r])):A6(r,e+1)}}},Lt=(r,e,t=null,n=!0)=>{const i=r._transactionCleanups;let s=!1,o=null;r._transaction===null&&(s=!0,r._transaction=new jve(r,t,n),i.push(r._transaction),i.length===1&&r.emit("beforeAllTransactions",[r]),r.emit("beforeTransaction",[r._transaction,r]));try{o=e(r._transaction)}finally{if(s){const a=r._transaction===i[0];r._transaction=null,a&&A6(i,0)}}return o};function*t_e(r){const e=at(r.restDecoder);for(let t=0;t<e;t++){const n=at(r.restDecoder),i=r.readClient();let s=at(r.restDecoder);for(let o=0;o<n;o++){const a=r.readInfo();if(a===10){const c=at(r.restDecoder);yield new pi(ht(i,s),c),s+=c}else if((eb&a)!==0){const c=(a&(Eo|si))===0,l=new wn(ht(i,s),null,(a&si)===si?r.readLeftID():null,null,(a&Eo)===Eo?r.readRightID():null,c?r.readParentInfo()?r.readString():r.readLeftID():null,c&&(a&kf)===kf?r.readString():null,G6(r,a));yield l,s+=l.length}else{const c=r.readLen();yield new fi(ht(i,s),c),s+=c}}}}class rA{constructor(e,t){this.gen=t_e(e),this.curr=null,this.done=!1,this.filterSkips=t,this.next()}next(){do this.curr=this.gen.next().value||null;while(this.filterSkips&&this.curr!==null&&this.curr.constructor===pi);return this.curr}}class iA{constructor(e){this.currClient=0,this.startClock=0,this.written=0,this.encoder=e,this.clientStructs=[]}}const n_e=r=>Wy(r,b6,vp),r_e=(r,e)=>{if(r.constructor===fi){const{client:t,clock:n}=r.id;return new fi(ht(t,n+e),r.length-e)}else if(r.constructor===pi){const{client:t,clock:n}=r.id;return new pi(ht(t,n+e),r.length-e)}else{const t=r,{client:n,clock:i}=t.id;return new wn(ht(n,i+e),null,ht(n,i+e-1),null,t.rightOrigin,t.parent,t.parentSub,t.content.splice(e))}},Wy=(r,e=hh,t=qc)=>{if(r.length===1)return r[0];const n=r.map(u=>new e(Ph(u)));let i=n.map(u=>new rA(u,!0)),s=null;const o=new t,a=new iA(o);for(;i=i.filter(d=>d.curr!==null),i.sort((d,m)=>{if(d.curr.id.client===m.curr.id.client){const p=d.curr.id.clock-m.curr.id.clock;return p===0?d.curr.constructor===m.curr.constructor?0:d.curr.constructor===pi?1:-1:p}else return m.curr.id.client-d.curr.id.client}),i.length!==0;){const u=i[0],h=u.curr.id.client;if(s!==null){let d=u.curr,m=!1;for(;d!==null&&d.id.clock+d.length<=s.struct.id.clock+s.struct.length&&d.id.client>=s.struct.id.client;)d=u.next(),m=!0;if(d===null||d.id.client!==h||m&&d.id.clock>s.struct.id.clock+s.struct.length)continue;if(h!==s.struct.id.client)ca(a,s.struct,s.offset),s={struct:d,offset:0},u.next();else if(s.struct.id.clock+s.struct.length<d.id.clock)if(s.struct.constructor===pi)s.struct.length=d.id.clock+d.length-s.struct.id.clock;else{ca(a,s.struct,s.offset);const p=d.id.clock-s.struct.id.clock-s.struct.length;s={struct:new pi(ht(h,s.struct.id.clock+s.struct.length),p),offset:0}}else{const p=s.struct.id.clock+s.struct.length-d.id.clock;p>0&&(s.struct.constructor===pi?s.struct.length-=p:d=r_e(d,p)),s.struct.mergeWith(d)||(ca(a,s.struct,s.offset),s={struct:d,offset:0},u.next())}}else s={struct:u.curr,offset:0},u.next();for(let d=u.curr;d!==null&&d.id.client===h&&d.id.clock===s.struct.id.clock+s.struct.length&&d.constructor!==pi;d=u.next())ca(a,s.struct,s.offset),s={struct:d,offset:0}}s!==null&&(ca(a,s.struct,s.offset),s=null),sA(a);const c=n.map(u=>QM(u)),l=Nve(c);return Rh(o,l),o.toUint8Array()},i_e=(r,e,t=hh,n=qc)=>{const i=_6(e),s=new n,o=new iA(s),a=new t(Ph(r)),c=new rA(a,!1);for(;c.curr;){const u=c.curr,h=u.id.client,d=i.get(h)||0;if(c.curr.constructor===pi){c.next();continue}if(u.id.clock+u.length>d)for(ca(o,u,Qc(d-u.id.clock,0)),c.next();c.curr&&c.curr.id.client===h;)ca(o,c.curr,0),c.next();else for(;c.curr&&c.curr.id.client===h&&c.curr.id.clock+c.curr.length<=d;)c.next()}sA(o);const l=QM(a);return Rh(s,l),s.toUint8Array()},T6=r=>{r.written>0&&(r.clientStructs.push({written:r.written,restEncoder:Ss(r.encoder.restEncoder)}),r.encoder.restEncoder=tb(),r.written=0)},ca=(r,e,t)=>{r.written>0&&r.currClient!==e.id.client&&T6(r),r.written===0&&(r.currClient=e.id.client,r.encoder.writeClient(e.id.client),pt(r.encoder.restEncoder,e.id.clock+t)),e.write(r.encoder,t),r.written++},sA=r=>{T6(r);const e=r.encoder.restEncoder;pt(e,r.clientStructs.length);for(let t=0;t<r.clientStructs.length;t++){const n=r.clientStructs[t];pt(e,n.written),nb(e,n.restEncoder)}},s_e=(r,e,t)=>{const n=new e(Ph(r)),i=new rA(n,!1),s=new t,o=new iA(s);for(let c=i.curr;c!==null;c=i.next())ca(o,c,0);sA(o);const a=QM(n);return Rh(s,a),s.toUint8Array()},o_e=r=>s_e(r,hh,vp);class ib{constructor(e,t){this.target=e,this.currentTarget=e,this.transaction=t,this._changes=null,this._keys=null,this._delta=null}get path(){return a_e(this.currentTarget,this.target)}deletes(e){return m6(this.transaction.deleteSet,e.id)}get keys(){if(this._keys===null){const e=new Map,t=this.target;this.transaction.changed.get(t).forEach(i=>{if(i!==null){const s=t._map.get(i);let o,a;if(this.adds(s)){let c=s.left;for(;c!==null&&this.adds(c);)c=c.left;if(this.deletes(s))if(c!==null&&this.deletes(c))o="delete",a=iv(c.content.getContent());else return;else c!==null&&this.deletes(c)?(o="update",a=iv(c.content.getContent())):(o="add",a=void 0)}else if(this.deletes(s))o="delete",a=iv(s.content.getContent());else return;e.set(i,{action:o,oldValue:a})}}),this._keys=e}return this._keys}get delta(){return this.changes.delta}adds(e){return e.id.clock>=(this.transaction.beforeState.get(e.id.client)||0)}get changes(){let e=this._changes;if(e===null){const t=this.target,n=ch(),i=ch(),s=[];if(e={added:n,deleted:i,delta:s,keys:this.keys},this.transaction.changed.get(t).has(null)){let a=null;const c=()=>{a&&s.push(a)};for(let l=t._start;l!==null;l=l.right)l.deleted?this.deletes(l)&&!this.adds(l)&&((a===null||a.delete===void 0)&&(c(),a={delete:0}),a.delete+=l.length,i.add(l)):this.adds(l)?((a===null||a.insert===void 0)&&(c(),a={insert:[]}),a.insert=a.insert.concat(l.content.getContent()),n.add(l)):((a===null||a.retain===void 0)&&(c(),a={retain:0}),a.retain+=l.length);a!==null&&a.retain===void 0&&c()}this._changes=e}return e}}const a_e=(r,e)=>{const t=[];for(;e._item!==null&&e!==r;){if(e._item.parentSub!==null)t.unshift(e._item.parentSub);else{let n=0,i=e._item.parent._start;for(;i!==e._item&&i!==null;)i.deleted||n++,i=i.right;t.unshift(n)}e=e._item.parent}return t},C6=80;let oA=0;class c_e{constructor(e,t){e.marker=!0,this.p=e,this.index=t,this.timestamp=oA++}}const l_e=r=>{r.timestamp=oA++},I6=(r,e,t)=>{r.p.marker=!1,r.p=e,e.marker=!0,r.index=t,r.timestamp=oA++},u_e=(r,e,t)=>{if(r.length>=C6){const n=r.reduce((i,s)=>i.timestamp<s.timestamp?i:s);return I6(n,e,t),n}else{const n=new c_e(e,t);return r.push(n),n}},sb=(r,e)=>{if(r._start===null||e===0||r._searchMarker===null)return null;const t=r._searchMarker.length===0?null:r._searchMarker.reduce((s,o)=>Dg(e-s.index)<Dg(e-o.index)?s:o);let n=r._start,i=0;for(t!==null&&(n=t.p,i=t.index,l_e(t));n.right!==null&&i<e;){if(!n.deleted&&n.countable){if(e<i+n.length)break;i+=n.length}n=n.right}for(;n.left!==null&&i>e;)n=n.left,!n.deleted&&n.countable&&(i-=n.length);for(;n.left!==null&&n.left.id.client===n.id.client&&n.left.id.clock+n.left.length===n.id.clock;)n=n.left,!n.deleted&&n.countable&&(i-=n.length);return t!==null&&Dg(t.index-i)<n.parent.length/C6?(I6(t,n,i),t):u_e(r._searchMarker,n,i)},Vf=(r,e,t)=>{for(let n=r.length-1;n>=0;n--){const i=r[n];if(t>0){let s=i.p;for(s.marker=!1;s&&(s.deleted||!s.countable);)s=s.left,s&&!s.deleted&&s.countable&&(i.index-=s.length);if(s===null||s.marker===!0){r.splice(n,1);continue}i.p=s,s.marker=!0}(e<i.index||t>0&&e===i.index)&&(i.index=Qc(e,i.index+t))}},ob=(r,e,t)=>{const n=r,i=e.changedParentTypes;for(;Na(i,r,()=>[]).push(t),r._item!==null;)r=r._item.parent;x6(n._eH,t,e)};class Vn{constructor(){this._item=null,this._map=new Map,this._start=null,this.doc=null,this._length=0,this._eH=SP(),this._dEH=SP(),this._searchMarker=null}get parent(){return this._item?this._item.parent:null}_integrate(e,t){this.doc=e,this._item=t}_copy(){throw As()}clone(){throw As()}_write(e){}get _first(){let e=this._start;for(;e!==null&&e.deleted;)e=e.right;return e}_callObserver(e,t){!e.local&&this._searchMarker&&(this._searchMarker.length=0)}observe(e){EP(this._eH,e)}observeDeep(e){EP(this._dEH,e)}unobserve(e){MP(this._eH,e)}unobserveDeep(e){MP(this._dEH,e)}toJSON(){}}const P6=(r,e,t)=>{e<0&&(e=r._length+e),t<0&&(t=r._length+t);let n=t-e;const i=[];let s=r._start;for(;s!==null&&n>0;){if(s.countable&&!s.deleted){const o=s.content.getContent();if(o.length<=e)e-=o.length;else{for(let a=e;a<o.length&&n>0;a++)i.push(o[a]),n--;e=0}}s=s.right}return i},R6=r=>{const e=[];let t=r._start;for(;t!==null;){if(t.countable&&!t.deleted){const n=t.content.getContent();for(let i=0;i<n.length;i++)e.push(n[i])}t=t.right}return e},Hf=(r,e)=>{let t=0,n=r._start;for(;n!==null;){if(n.countable&&!n.deleted){const i=n.content.getContent();for(let s=0;s<i.length;s++)e(i[s],t++,r)}n=n.right}},D6=(r,e)=>{const t=[];return Hf(r,(n,i)=>{t.push(e(n,i,r))}),t},h_e=r=>{let e=r._start,t=null,n=0;return{[Symbol.iterator](){return this},next:()=>{if(t===null){for(;e!==null&&e.deleted;)e=e.right;if(e===null)return{done:!0,value:void 0};t=e.content.getContent(),n=0,e=e.right}const i=t[n++];return t.length<=n&&(t=null),{done:!1,value:i}}}},L6=(r,e)=>{const t=sb(r,e);let n=r._start;for(t!==null&&(n=t.p,e-=t.index);n!==null;n=n.right)if(!n.deleted&&n.countable){if(e<n.length)return n.content.getContent()[e];e-=n.length}},qy=(r,e,t,n)=>{let i=t;const s=r.doc,o=s.clientID,a=s.store,c=t===null?e._start:t.right;let l=[];const u=()=>{l.length>0&&(i=new wn(ht(o,Pn(a,o)),i,i&&i.lastId,c,c&&c.id,e,null,new Xc(l)),i.integrate(r,0),l=[])};n.forEach(h=>{if(h===null)l.push(h);else switch(h.constructor){case Number:case Object:case Boolean:case Array:case String:l.push(h);break;default:switch(u(),h.constructor){case Uint8Array:case ArrayBuffer:i=new wn(ht(o,Pn(a,o)),i,i&&i.lastId,c,c&&c.id,e,null,new _p(new Uint8Array(h))),i.integrate(r,0);break;case Dh:i=new wn(ht(o,Pn(a,o)),i,i&&i.lastId,c,c&&c.id,e,null,new xp(h)),i.integrate(r,0);break;default:if(h instanceof Vn)i=new wn(ht(o,Pn(a,o)),i,i&&i.lastId,c,c&&c.id,e,null,new Uo(h)),i.integrate(r,0);else throw new Error("Unexpected content type in insert operation")}}}),u()},N6=el("Length exceeded!"),O6=(r,e,t,n)=>{if(t>e._length)throw N6;if(t===0)return e._searchMarker&&Vf(e._searchMarker,t,n.length),qy(r,e,null,n);const i=t,s=sb(e,t);let o=e._start;for(s!==null&&(o=s.p,t-=s.index,t===0&&(o=o.prev,t+=o&&o.countable&&!o.deleted?o.length:0));o!==null;o=o.right)if(!o.deleted&&o.countable){if(t<=o.length){t<o.length&&Ia(r,ht(o.id.client,o.id.clock+t));break}t-=o.length}return e._searchMarker&&Vf(e._searchMarker,i,n.length),qy(r,e,o,n)},d_e=(r,e,t)=>{let i=(e._searchMarker||[]).reduce((s,o)=>o.index>s.index?o:s,{index:0,p:e._start}).p;if(i)for(;i.right;)i=i.right;return qy(r,e,i,t)},U6=(r,e,t,n)=>{if(n===0)return;const i=t,s=n,o=sb(e,t);let a=e._start;for(o!==null&&(a=o.p,t-=o.index);a!==null&&t>0;a=a.right)!a.deleted&&a.countable&&(t<a.length&&Ia(r,ht(a.id.client,a.id.clock+t)),t-=a.length);for(;n>0&&a!==null;)a.deleted||(n<a.length&&Ia(r,ht(a.id.client,a.id.clock+n)),a.delete(r),n-=a.length),a=a.right;if(n>0)throw N6;e._searchMarker&&Vf(e._searchMarker,i,-s+n)},Ky=(r,e,t)=>{const n=e._map.get(t);n!==void 0&&n.delete(r)},aA=(r,e,t,n)=>{const i=e._map.get(t)||null,s=r.doc,o=s.clientID;let a;if(n==null)a=new Xc([n]);else switch(n.constructor){case Number:case Object:case Boolean:case Array:case String:a=new Xc([n]);break;case Uint8Array:a=new _p(n);break;case Dh:a=new xp(n);break;default:if(n instanceof Vn)a=new Uo(n);else throw new Error("Unexpected content type")}new wn(ht(o,Pn(s.store,o)),i,i&&i.lastId,null,null,e,t,a).integrate(r,0)},cA=(r,e)=>{const t=r._map.get(e);return t!==void 0&&!t.deleted?t.content.getContent()[t.length-1]:void 0},k6=r=>{const e={};return r._map.forEach((t,n)=>{t.deleted||(e[n]=t.content.getContent()[t.length-1])}),e},B6=(r,e)=>{const t=r._map.get(e);return t!==void 0&&!t.deleted},ig=r=>Dve(r.entries(),e=>!e[1].deleted);class f_e extends ib{constructor(e,t){super(e,t),this._transaction=t}}class su extends Vn{constructor(){super(),this._prelimContent=[],this._searchMarker=[]}static from(e){const t=new su;return t.push(e),t}_integrate(e,t){super._integrate(e,t),this.insert(0,this._prelimContent),this._prelimContent=null}_copy(){return new su}clone(){const e=new su;return e.insert(0,this.toArray().map(t=>t instanceof Vn?t.clone():t)),e}get length(){return this._prelimContent===null?this._length:this._prelimContent.length}_callObserver(e,t){super._callObserver(e,t),ob(this,e,new f_e(this,e))}insert(e,t){this.doc!==null?Lt(this.doc,n=>{O6(n,this,e,t)}):this._prelimContent.splice(e,0,...t)}push(e){this.doc!==null?Lt(this.doc,t=>{d_e(t,this,e)}):this._prelimContent.push(...e)}unshift(e){this.insert(0,e)}delete(e,t=1){this.doc!==null?Lt(this.doc,n=>{U6(n,this,e,t)}):this._prelimContent.splice(e,t)}get(e){return L6(this,e)}toArray(){return R6(this)}slice(e=0,t=this.length){return P6(this,e,t)}toJSON(){return this.map(e=>e instanceof Vn?e.toJSON():e)}map(e){return D6(this,e)}forEach(e){Hf(this,e)}[Symbol.iterator](){return h_e(this)}_write(e){e.writeTypeRef(U_e)}}const p_e=r=>new su;class m_e extends ib{constructor(e,t,n){super(e,t),this.keysChanged=n}}class Pa extends Vn{constructor(e){super(),this._prelimContent=null,e===void 0?this._prelimContent=new Map:this._prelimContent=new Map(e)}_integrate(e,t){super._integrate(e,t),this._prelimContent.forEach((n,i)=>{this.set(i,n)}),this._prelimContent=null}_copy(){return new Pa}clone(){const e=new Pa;return this.forEach((t,n)=>{e.set(n,t instanceof Vn?t.clone():t)}),e}_callObserver(e,t){ob(this,e,new m_e(this,e,t))}toJSON(){const e={};return this._map.forEach((t,n)=>{if(!t.deleted){const i=t.content.getContent()[t.length-1];e[n]=i instanceof Vn?i.toJSON():i}}),e}get size(){return[...ig(this._map)].length}keys(){return lv(ig(this._map),e=>e[0])}values(){return lv(ig(this._map),e=>e[1].content.getContent()[e[1].length-1])}entries(){return lv(ig(this._map),e=>[e[0],e[1].content.getContent()[e[1].length-1]])}forEach(e){this._map.forEach((t,n)=>{t.deleted||e(t.content.getContent()[t.length-1],n,this)})}[Symbol.iterator](){return this.entries()}delete(e){this.doc!==null?Lt(this.doc,t=>{Ky(t,this,e)}):this._prelimContent.delete(e)}set(e,t){return this.doc!==null?Lt(this.doc,n=>{aA(n,this,e,t)}):this._prelimContent.set(e,t),t}get(e){return cA(this,e)}has(e){return B6(this,e)}clear(){this.doc!==null?Lt(this.doc,e=>{this.forEach(function(t,n,i){Ky(e,i,n)})}):this._prelimContent.clear()}_write(e){e.writeTypeRef(k_e)}}const g_e=r=>new Pa,ga=(r,e)=>r===e||typeof r=="object"&&typeof e=="object"&&r&&e&&dve(r,e);class bE{constructor(e,t,n,i){this.left=e,this.right=t,this.index=n,this.currentAttributes=i}forward(){switch(this.right===null&&Ps(),this.right.content.constructor){case vn:this.right.deleted||Lh(this.currentAttributes,this.right.content);break;default:this.right.deleted||(this.index+=this.right.length);break}this.left=this.right,this.right=this.right.right}}const IP=(r,e,t)=>{for(;e.right!==null&&t>0;){switch(e.right.content.constructor){case vn:e.right.deleted||Lh(e.currentAttributes,e.right.content);break;default:e.right.deleted||(t<e.right.length&&Ia(r,ht(e.right.id.client,e.right.id.clock+t)),e.index+=e.right.length,t-=e.right.length);break}e.left=e.right,e.right=e.right.right}return e},sg=(r,e,t)=>{const n=new Map,i=sb(e,t);if(i){const s=new bE(i.p.left,i.p,i.index,n);return IP(r,s,t-i.index)}else{const s=new bE(null,e._start,0,n);return IP(r,s,t)}},F6=(r,e,t,n)=>{for(;t.right!==null&&(t.right.deleted===!0||t.right.content.constructor===vn&&ga(n.get(t.right.content.key),t.right.content.value));)t.right.deleted||n.delete(t.right.content.key),t.forward();const i=r.doc,s=i.clientID;n.forEach((o,a)=>{const c=t.left,l=t.right,u=new wn(ht(s,Pn(i.store,s)),c,c&&c.lastId,l,l&&l.id,e,null,new vn(a,o));u.integrate(r,0),t.right=u,t.forward()})},Lh=(r,e)=>{const{key:t,value:n}=e;n===null?r.delete(t):r.set(t,n)},$6=(r,e)=>{for(;r.right!==null;){if(!(r.right.deleted||r.right.content.constructor===vn&&ga(e[r.right.content.key]||null,r.right.content.value)))break;r.forward()}},z6=(r,e,t,n)=>{const i=r.doc,s=i.clientID,o=new Map;for(const a in n){const c=n[a],l=t.currentAttributes.get(a)||null;if(!ga(l,c)){o.set(a,l);const{left:u,right:h}=t;t.right=new wn(ht(s,Pn(i.store,s)),u,u&&u.lastId,h,h&&h.id,e,null,new vn(a,c)),t.right.integrate(r,0),t.forward()}}return o},hv=(r,e,t,n,i)=>{t.currentAttributes.forEach((d,m)=>{i[m]===void 0&&(i[m]=null)});const s=r.doc,o=s.clientID;$6(t,i);const a=z6(r,e,t,i),c=n.constructor===String?new Ds(n):n instanceof Vn?new Uo(n):new tl(n);let{left:l,right:u,index:h}=t;e._searchMarker&&Vf(e._searchMarker,t.index,c.getLength()),u=new wn(ht(o,Pn(s.store,o)),l,l&&l.lastId,u,u&&u.id,e,null,c),u.integrate(r,0),t.right=u,t.index=h,t.forward(),F6(r,e,t,a)},PP=(r,e,t,n,i)=>{const s=r.doc,o=s.clientID;$6(t,i);const a=z6(r,e,t,i);e:for(;t.right!==null&&(n>0||a.size>0&&(t.right.deleted||t.right.content.constructor===vn));){if(!t.right.deleted)switch(t.right.content.constructor){case vn:{const{key:c,value:l}=t.right.content,u=i[c];if(u!==void 0){if(ga(u,l))a.delete(c);else{if(n===0)break e;a.set(c,l)}t.right.delete(r)}else t.currentAttributes.set(c,l);break}default:n<t.right.length&&Ia(r,ht(t.right.id.client,t.right.id.clock+n)),n-=t.right.length;break}t.forward()}if(n>0){let c="";for(;n>0;n--)c+=`
`;t.right=new wn(ht(o,Pn(s.store,o)),t.left,t.left&&t.left.lastId,t.right,t.right&&t.right.id,e,null,new Ds(c)),t.right.integrate(r,0),t.forward()}F6(r,e,t,a)},V6=(r,e,t,n,i)=>{let s=e;const o=es();for(;s&&(!s.countable||s.deleted);){if(!s.deleted&&s.content.constructor===vn){const l=s.content;o.set(l.key,l)}s=s.right}let a=0,c=!1;for(;e!==s;){if(t===e&&(c=!0),!e.deleted){const l=e.content;switch(l.constructor){case vn:{const{key:u,value:h}=l,d=n.get(u)||null;(o.get(u)!==l||d===h)&&(e.delete(r),a++,!c&&(i.get(u)||null)===h&&d!==h&&(d===null?i.delete(u):i.set(u,d))),!c&&!e.deleted&&Lh(i,l);break}}}e=e.right}return a},y_e=(r,e)=>{for(;e&&e.right&&(e.right.deleted||!e.right.countable);)e=e.right;const t=new Set;for(;e&&(e.deleted||!e.countable);){if(!e.deleted&&e.content.constructor===vn){const n=e.content.key;t.has(n)?e.delete(r):t.add(n)}e=e.left}},b_e=r=>{let e=0;return Lt(r.doc,t=>{let n=r._start,i=r._start,s=es();const o=lE(s);for(;i;){if(i.deleted===!1)switch(i.content.constructor){case vn:Lh(o,i.content);break;default:e+=V6(t,n,i,s,o),s=lE(o),n=i;break}i=i.right}}),e},RP=(r,e,t)=>{const n=t,i=lE(e.currentAttributes),s=e.right;for(;t>0&&e.right!==null;){if(e.right.deleted===!1)switch(e.right.content.constructor){case Uo:case tl:case Ds:t<e.right.length&&Ia(r,ht(e.right.id.client,e.right.id.clock+t)),t-=e.right.length,e.right.delete(r);break}e.forward()}s&&V6(r,s,e.right,i,e.currentAttributes);const o=(e.left||e.right).parent;return o._searchMarker&&Vf(o._searchMarker,e.index,-n+t),e};class w_e extends ib{constructor(e,t,n){super(e,t),this.childListChanged=!1,this.keysChanged=new Set,n.forEach(i=>{i===null?this.childListChanged=!0:this.keysChanged.add(i)})}get changes(){if(this._changes===null){const e={keys:this.keys,delta:this.delta,added:new Set,deleted:new Set};this._changes=e}return this._changes}get delta(){if(this._delta===null){const e=this.target.doc,t=[];Lt(e,n=>{const i=new Map,s=new Map;let o=this.target._start,a=null;const c={};let l="",u=0,h=0;const d=()=>{if(a!==null){let m=null;switch(a){case"delete":h>0&&(m={delete:h}),h=0;break;case"insert":(typeof l=="object"||l.length>0)&&(m={insert:l},i.size>0&&(m.attributes={},i.forEach((p,b)=>{p!==null&&(m.attributes[b]=p)}))),l="";break;case"retain":u>0&&(m={retain:u},lve(c)||(m.attributes=ave({},c))),u=0;break}m&&t.push(m),a=null}};for(;o!==null;){switch(o.content.constructor){case Uo:case tl:this.adds(o)?this.deletes(o)||(d(),a="insert",l=o.content.getContent()[0],d()):this.deletes(o)?(a!=="delete"&&(d(),a="delete"),h+=1):o.deleted||(a!=="retain"&&(d(),a="retain"),u+=1);break;case Ds:this.adds(o)?this.deletes(o)||(a!=="insert"&&(d(),a="insert"),l+=o.content.str):this.deletes(o)?(a!=="delete"&&(d(),a="delete"),h+=o.length):o.deleted||(a!=="retain"&&(d(),a="retain"),u+=o.length);break;case vn:{const{key:m,value:p}=o.content;if(this.adds(o)){if(!this.deletes(o)){const b=i.get(m)||null;ga(b,p)?p!==null&&o.delete(n):(a==="retain"&&d(),ga(p,s.get(m)||null)?delete c[m]:c[m]=p)}}else if(this.deletes(o)){s.set(m,p);const b=i.get(m)||null;ga(b,p)||(a==="retain"&&d(),c[m]=b)}else if(!o.deleted){s.set(m,p);const b=c[m];b!==void 0&&(ga(b,p)?b!==null&&o.delete(n):(a==="retain"&&d(),p===null?delete c[m]:c[m]=p))}o.deleted||(a==="insert"&&d(),Lh(i,o.content));break}}o=o.right}for(d();t.length>0;){const m=t[t.length-1];if(m.retain!==void 0&&m.attributes===void 0)t.pop();else break}}),this._delta=t}return this._delta}}class dh extends Vn{constructor(e){super(),this._pending=e!==void 0?[()=>this.insert(0,e)]:[],this._searchMarker=[]}get length(){return this._length}_integrate(e,t){super._integrate(e,t);try{this._pending.forEach(n=>n())}catch(n){console.error(n)}this._pending=null}_copy(){return new dh}clone(){const e=new dh;return e.applyDelta(this.toDelta()),e}_callObserver(e,t){super._callObserver(e,t);const n=new w_e(this,e,t),i=e.doc;if(ob(this,e,n),!e.local){let s=!1;for(const[o,a]of e.afterState.entries()){const c=e.beforeState.get(o)||0;if(a!==c&&(M6(e,i.store.clients.get(o),c,a,l=>{!l.deleted&&l.content.constructor===vn&&(s=!0)}),s))break}s||mE(e,e.deleteSet,o=>{o instanceof fi||s||o.parent===this&&o.content.constructor===vn&&(s=!0)}),Lt(i,o=>{s?b_e(this):mE(o,o.deleteSet,a=>{a instanceof fi||a.parent===this&&y_e(o,a)})})}}toString(){let e="",t=this._start;for(;t!==null;)!t.deleted&&t.countable&&t.content.constructor===Ds&&(e+=t.content.str),t=t.right;return e}toJSON(){return this.toString()}applyDelta(e,{sanitize:t=!0}={}){this.doc!==null?Lt(this.doc,n=>{const i=new bE(null,this._start,0,new Map);for(let s=0;s<e.length;s++){const o=e[s];if(o.insert!==void 0){const a=!t&&typeof o.insert=="string"&&s===e.length-1&&i.right===null&&o.insert.slice(-1)===`
`?o.insert.slice(0,-1):o.insert;(typeof a!="string"||a.length>0)&&hv(n,this,i,a,o.attributes||{})}else o.retain!==void 0?PP(n,this,i,o.retain,o.attributes||{}):o.delete!==void 0&&RP(n,i,o.delete)}}):this._pending.push(()=>this.applyDelta(e))}toDelta(e,t,n){const i=[],s=new Map,o=this.doc;let a="",c=this._start;function l(){if(a.length>0){const h={};let d=!1;s.forEach((p,b)=>{d=!0,h[b]=p});const m={insert:a};d&&(m.attributes=h),i.push(m),a=""}}const u=()=>{for(;c!==null;){if(nd(c,e)||t!==void 0&&nd(c,t))switch(c.content.constructor){case Ds:{const h=s.get("ychange");e!==void 0&&!nd(c,e)?(h===void 0||h.user!==c.id.client||h.type!=="removed")&&(l(),s.set("ychange",n?n("removed",c.id):{type:"removed"})):t!==void 0&&!nd(c,t)?(h===void 0||h.user!==c.id.client||h.type!=="added")&&(l(),s.set("ychange",n?n("added",c.id):{type:"added"})):h!==void 0&&(l(),s.delete("ychange")),a+=c.content.str;break}case Uo:case tl:{l();const h={insert:c.content.getContent()[0]};if(s.size>0){const d={};h.attributes=d,s.forEach((m,p)=>{d[p]=m})}i.push(h);break}case vn:nd(c,e)&&(l(),Lh(s,c.content));break}c=c.right}l()};return e||t?Lt(o,h=>{e&&gE(h,e),t&&gE(h,t),u()},"cleanup"):u(),i}insert(e,t,n){if(t.length<=0)return;const i=this.doc;i!==null?Lt(i,s=>{const o=sg(s,this,e);n||(n={},o.currentAttributes.forEach((a,c)=>{n[c]=a})),hv(s,this,o,t,n)}):this._pending.push(()=>this.insert(e,t,n))}insertEmbed(e,t,n={}){const i=this.doc;i!==null?Lt(i,s=>{const o=sg(s,this,e);hv(s,this,o,t,n)}):this._pending.push(()=>this.insertEmbed(e,t,n))}delete(e,t){if(t===0)return;const n=this.doc;n!==null?Lt(n,i=>{RP(i,sg(i,this,e),t)}):this._pending.push(()=>this.delete(e,t))}format(e,t,n){if(t===0)return;const i=this.doc;i!==null?Lt(i,s=>{const o=sg(s,this,e);o.right!==null&&PP(s,this,o,t,n)}):this._pending.push(()=>this.format(e,t,n))}removeAttribute(e){this.doc!==null?Lt(this.doc,t=>{Ky(t,this,e)}):this._pending.push(()=>this.removeAttribute(e))}setAttribute(e,t){this.doc!==null?Lt(this.doc,n=>{aA(n,this,e,t)}):this._pending.push(()=>this.setAttribute(e,t))}getAttribute(e){return cA(this,e)}getAttributes(){return k6(this)}_write(e){e.writeTypeRef(B_e)}}const v_e=r=>new dh;class dv{constructor(e,t=()=>!0){this._filter=t,this._root=e,this._currentNode=e._start,this._firstCall=!0}[Symbol.iterator](){return this}next(){let e=this._currentNode,t=e&&e.content&&e.content.type;if(e!==null&&(!this._firstCall||e.deleted||!this._filter(t)))do if(t=e.content.type,!e.deleted&&(t.constructor===Gf||t.constructor===Kc)&&t._start!==null)e=t._start;else for(;e!==null;)if(e.right!==null){e=e.right;break}else e.parent===this._root?e=null:e=e.parent._item;while(e!==null&&(e.deleted||!this._filter(e.content.type)));return this._firstCall=!1,e===null?{value:void 0,done:!0}:(this._currentNode=e,{value:e.content.type,done:!1})}}class Kc extends Vn{constructor(){super(),this._prelimContent=[]}get firstChild(){const e=this._first;return e?e.content.getContent()[0]:null}_integrate(e,t){super._integrate(e,t),this.insert(0,this._prelimContent),this._prelimContent=null}_copy(){return new Kc}clone(){const e=new Kc;return e.insert(0,this.toArray().map(t=>t instanceof Vn?t.clone():t)),e}get length(){return this._prelimContent===null?this._length:this._prelimContent.length}createTreeWalker(e){return new dv(this,e)}querySelector(e){e=e.toUpperCase();const n=new dv(this,i=>i.nodeName&&i.nodeName.toUpperCase()===e).next();return n.done?null:n.value}querySelectorAll(e){return e=e.toUpperCase(),Wc(new dv(this,t=>t.nodeName&&t.nodeName.toUpperCase()===e))}_callObserver(e,t){ob(this,e,new S_e(this,t,e))}toString(){return D6(this,e=>e.toString()).join("")}toJSON(){return this.toString()}toDOM(e=document,t={},n){const i=e.createDocumentFragment();return n!==void 0&&n._createAssociation(i,this),Hf(this,s=>{i.insertBefore(s.toDOM(e,t,n),null)}),i}insert(e,t){this.doc!==null?Lt(this.doc,n=>{O6(n,this,e,t)}):this._prelimContent.splice(e,0,...t)}insertAfter(e,t){if(this.doc!==null)Lt(this.doc,n=>{const i=e&&e instanceof Vn?e._item:e;qy(n,this,i,t)});else{const n=this._prelimContent,i=e===null?0:n.findIndex(s=>s===e)+1;if(i===0&&e!==null)throw el("Reference item not found");n.splice(i,0,...t)}}delete(e,t=1){this.doc!==null?Lt(this.doc,n=>{U6(n,this,e,t)}):this._prelimContent.splice(e,t)}toArray(){return R6(this)}push(e){this.insert(this.length,e)}unshift(e){this.insert(0,e)}get(e){return L6(this,e)}slice(e=0,t=this.length){return P6(this,e,t)}forEach(e){Hf(this,e)}_write(e){e.writeTypeRef($_e)}}const __e=r=>new Kc;class Gf extends Kc{constructor(e="UNDEFINED"){super(),this.nodeName=e,this._prelimAttrs=new Map}get nextSibling(){const e=this._item?this._item.next:null;return e?e.content.type:null}get prevSibling(){const e=this._item?this._item.prev:null;return e?e.content.type:null}_integrate(e,t){super._integrate(e,t),this._prelimAttrs.forEach((n,i)=>{this.setAttribute(i,n)}),this._prelimAttrs=null}_copy(){return new Gf(this.nodeName)}clone(){const e=new Gf(this.nodeName),t=this.getAttributes();for(const n in t)e.setAttribute(n,t[n]);return e.insert(0,this.toArray().map(n=>n instanceof Vn?n.clone():n)),e}toString(){const e=this.getAttributes(),t=[],n=[];for(const a in e)n.push(a);n.sort();const i=n.length;for(let a=0;a<i;a++){const c=n[a];t.push(c+'="'+e[c]+'"')}const s=this.nodeName.toLocaleLowerCase(),o=t.length>0?" "+t.join(" "):"";return`<${s}${o}>${super.toString()}</${s}>`}removeAttribute(e){this.doc!==null?Lt(this.doc,t=>{Ky(t,this,e)}):this._prelimAttrs.delete(e)}setAttribute(e,t){this.doc!==null?Lt(this.doc,n=>{aA(n,this,e,t)}):this._prelimAttrs.set(e,t)}getAttribute(e){return cA(this,e)}hasAttribute(e){return B6(this,e)}getAttributes(){return k6(this)}toDOM(e=document,t={},n){const i=e.createElement(this.nodeName),s=this.getAttributes();for(const o in s)i.setAttribute(o,s[o]);return Hf(this,o=>{i.appendChild(o.toDOM(e,t,n))}),n!==void 0&&n._createAssociation(i,this),i}_write(e){e.writeTypeRef(F_e),e.writeKey(this.nodeName)}}const x_e=r=>new Gf(r.readKey());class S_e extends ib{constructor(e,t,n){super(e,n),this.childListChanged=!1,this.attributesChanged=new Set,t.forEach(i=>{i===null?this.childListChanged=!0:this.attributesChanged.add(i)})}}class Xy extends Pa{constructor(e){super(),this.hookName=e}_copy(){return new Xy(this.hookName)}clone(){const e=new Xy(this.hookName);return this.forEach((t,n)=>{e.set(n,t)}),e}toDOM(e=document,t={},n){const i=t[this.hookName];let s;return i!==void 0?s=i.createDom(this):s=document.createElement(this.hookName),s.setAttribute("data-yjs-hook",this.hookName),n!==void 0&&n._createAssociation(s,this),s}_write(e){e.writeTypeRef(z_e),e.writeKey(this.hookName)}}const E_e=r=>new Xy(r.readKey());class Yy extends dh{get nextSibling(){const e=this._item?this._item.next:null;return e?e.content.type:null}get prevSibling(){const e=this._item?this._item.prev:null;return e?e.content.type:null}_copy(){return new Yy}clone(){const e=new Yy;return e.applyDelta(this.toDelta()),e}toDOM(e=document,t,n){const i=e.createTextNode(this.toString());return n!==void 0&&n._createAssociation(i,this),i}toString(){return this.toDelta().map(e=>{const t=[];for(const i in e.attributes){const s=[];for(const o in e.attributes[i])s.push({key:o,value:e.attributes[i][o]});s.sort((o,a)=>o.key<a.key?-1:1),t.push({nodeName:i,attrs:s})}t.sort((i,s)=>i.nodeName<s.nodeName?-1:1);let n="";for(let i=0;i<t.length;i++){const s=t[i];n+=`<${s.nodeName}`;for(let o=0;o<s.attrs.length;o++){const a=s.attrs[o];n+=` ${a.key}="${a.value}"`}n+=">"}n+=e.insert;for(let i=t.length-1;i>=0;i--)n+=`</${t[i].nodeName}>`;return n}).join("")}toJSON(){return this.toString()}_write(e){e.writeTypeRef(V_e)}}const M_e=r=>new Yy;class lA{constructor(e,t){this.id=e,this.length=t}get deleted(){throw As()}mergeWith(e){return!1}write(e,t,n){throw As()}integrate(e,t){throw As()}}const A_e=0;class fi extends lA{get deleted(){return!0}delete(){}mergeWith(e){return this.constructor!==e.constructor?!1:(this.length+=e.length,!0)}integrate(e,t){t>0&&(this.id.clock+=t,this.length-=t),E6(e.doc.store,this)}write(e,t){e.writeInfo(A_e),e.writeLen(this.length-t)}getMissing(e,t){return null}}class _p{constructor(e){this.content=e}getLength(){return 1}getContent(){return[this.content]}isCountable(){return!0}copy(){return new _p(this.content)}splice(e){throw As()}mergeWith(e){return!1}integrate(e,t){}delete(e){}gc(e){}write(e,t){e.writeBuf(this.content)}getRef(){return 3}}const T_e=r=>new _p(r.readBuf());class Wf{constructor(e){this.len=e}getLength(){return this.len}getContent(){return[]}isCountable(){return!1}copy(){return new Wf(this.len)}splice(e){const t=new Wf(this.len-e);return this.len=e,t}mergeWith(e){return this.len+=e.len,!0}integrate(e,t){Gy(e.deleteSet,t.id.client,t.id.clock,this.len),t.markDeleted()}delete(e){}gc(e){}write(e,t){e.writeLen(this.len-t)}getRef(){return 1}}const C_e=r=>new Wf(r.readLen()),H6=(r,e)=>new Dh({guid:r,...e,shouldLoad:e.shouldLoad||e.autoLoad||!1});class xp{constructor(e){e._item&&console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid."),this.doc=e;const t={};this.opts=t,e.gc||(t.gc=!1),e.autoLoad&&(t.autoLoad=!0),e.meta!==null&&(t.meta=e.meta)}getLength(){return 1}getContent(){return[this.doc]}isCountable(){return!0}copy(){return new xp(H6(this.doc.guid,this.opts))}splice(e){throw As()}mergeWith(e){return!1}integrate(e,t){this.doc._item=t,e.subdocsAdded.add(this.doc),this.doc.shouldLoad&&e.subdocsLoaded.add(this.doc)}delete(e){e.subdocsAdded.has(this.doc)?e.subdocsAdded.delete(this.doc):e.subdocsRemoved.add(this.doc)}gc(e){}write(e,t){e.writeString(this.doc.guid),e.writeAny(this.opts)}getRef(){return 9}}const I_e=r=>new xp(H6(r.readString(),r.readAny()));class tl{constructor(e){this.embed=e}getLength(){return 1}getContent(){return[this.embed]}isCountable(){return!0}copy(){return new tl(this.embed)}splice(e){throw As()}mergeWith(e){return!1}integrate(e,t){}delete(e){}gc(e){}write(e,t){e.writeJSON(this.embed)}getRef(){return 5}}const P_e=r=>new tl(r.readJSON());class vn{constructor(e,t){this.key=e,this.value=t}getLength(){return 1}getContent(){return[]}isCountable(){return!1}copy(){return new vn(this.key,this.value)}splice(e){throw As()}mergeWith(e){return!1}integrate(e,t){t.parent._searchMarker=null}delete(e){}gc(e){}write(e,t){e.writeKey(this.key),e.writeJSON(this.value)}getRef(){return 6}}const R_e=r=>new vn(r.readKey(),r.readJSON());class Zy{constructor(e){this.arr=e}getLength(){return this.arr.length}getContent(){return this.arr}isCountable(){return!0}copy(){return new Zy(this.arr)}splice(e){const t=new Zy(this.arr.slice(e));return this.arr=this.arr.slice(0,e),t}mergeWith(e){return this.arr=this.arr.concat(e.arr),!0}integrate(e,t){}delete(e){}gc(e){}write(e,t){const n=this.arr.length;e.writeLen(n-t);for(let i=t;i<n;i++){const s=this.arr[i];e.writeString(s===void 0?"undefined":JSON.stringify(s))}}getRef(){return 2}}const D_e=r=>{const e=r.readLen(),t=[];for(let n=0;n<e;n++){const i=r.readString();i==="undefined"?t.push(void 0):t.push(JSON.parse(i))}return new Zy(t)};class Xc{constructor(e){this.arr=e}getLength(){return this.arr.length}getContent(){return this.arr}isCountable(){return!0}copy(){return new Xc(this.arr)}splice(e){const t=new Xc(this.arr.slice(e));return this.arr=this.arr.slice(0,e),t}mergeWith(e){return this.arr=this.arr.concat(e.arr),!0}integrate(e,t){}delete(e){}gc(e){}write(e,t){const n=this.arr.length;e.writeLen(n-t);for(let i=t;i<n;i++){const s=this.arr[i];e.writeAny(s)}}getRef(){return 8}}const L_e=r=>{const e=r.readLen(),t=[];for(let n=0;n<e;n++)t.push(r.readAny());return new Xc(t)};class Ds{constructor(e){this.str=e}getLength(){return this.str.length}getContent(){return this.str.split("")}isCountable(){return!0}copy(){return new Ds(this.str)}splice(e){const t=new Ds(this.str.slice(e));this.str=this.str.slice(0,e);const n=this.str.charCodeAt(e-1);return n>=55296&&n<=56319&&(this.str=this.str.slice(0,e-1)+"",t.str=""+t.str.slice(1)),t}mergeWith(e){return this.str+=e.str,!0}integrate(e,t){}delete(e){}gc(e){}write(e,t){e.writeString(t===0?this.str:this.str.slice(t))}getRef(){return 4}}const N_e=r=>new Ds(r.readString()),O_e=[p_e,g_e,v_e,x_e,__e,E_e,M_e],U_e=0,k_e=1,B_e=2,F_e=3,$_e=4,z_e=5,V_e=6;class Uo{constructor(e){this.type=e}getLength(){return 1}getContent(){return[this.type]}isCountable(){return!0}copy(){return new Uo(this.type._copy())}splice(e){throw As()}mergeWith(e){return!1}integrate(e,t){this.type._integrate(e.doc,t)}delete(e){let t=this.type._start;for(;t!==null;)t.deleted?e._mergeStructs.push(t):t.delete(e),t=t.right;this.type._map.forEach(n=>{n.deleted?e._mergeStructs.push(n):n.delete(e)}),e.changed.delete(this.type)}gc(e){let t=this.type._start;for(;t!==null;)t.gc(e,!0),t=t.right;this.type._start=null,this.type._map.forEach(n=>{for(;n!==null;)n.gc(e,!0),n=n.left}),this.type._map=new Map}write(e,t){this.type._write(e)}getRef(){return 7}}const H_e=r=>new Uo(O_e[r.readTypeRef()](r)),Jy=(r,e,t)=>{const{client:n,clock:i}=e.id,s=new wn(ht(n,i+t),e,ht(n,i+t-1),e.right,e.rightOrigin,e.parent,e.parentSub,e.content.splice(t));return e.deleted&&s.markDeleted(),e.keep&&(s.keep=!0),e.redone!==null&&(s.redone=ht(e.redone.client,e.redone.clock+t)),e.right=s,s.right!==null&&(s.right.left=s),r._mergeStructs.push(s),s.parentSub!==null&&s.right===null&&s.parent._map.set(s.parentSub,s),e.length=t,s};class wn extends lA{constructor(e,t,n,i,s,o,a,c){super(e,c.getLength()),this.origin=n,this.left=t,this.right=i,this.rightOrigin=s,this.parent=o,this.parentSub=a,this.redone=null,this.content=c,this.info=this.content.isCountable()?fP:0}set marker(e){(this.info&ov)>0!==e&&(this.info^=ov)}get marker(){return(this.info&ov)>0}get keep(){return(this.info&dP)>0}set keep(e){this.keep!==e&&(this.info^=dP)}get countable(){return(this.info&fP)>0}get deleted(){return(this.info&sv)>0}set deleted(e){this.deleted!==e&&(this.info^=sv)}markDeleted(){this.info|=sv}getMissing(e,t){if(this.origin&&this.origin.client!==this.id.client&&this.origin.clock>=Pn(t,this.origin.client))return this.origin.client;if(this.rightOrigin&&this.rightOrigin.client!==this.id.client&&this.rightOrigin.clock>=Pn(t,this.rightOrigin.client))return this.rightOrigin.client;if(this.parent&&this.parent.constructor===iu&&this.id.client!==this.parent.client&&this.parent.clock>=Pn(t,this.parent.client))return this.parent.client;if(this.origin&&(this.left=AP(e,t,this.origin),this.origin=this.left.lastId),this.rightOrigin&&(this.right=Ia(e,this.rightOrigin),this.rightOrigin=this.right.id),(this.left&&this.left.constructor===fi||this.right&&this.right.constructor===fi)&&(this.parent=null),!this.parent)this.left&&this.left.constructor===wn&&(this.parent=this.left.parent,this.parentSub=this.left.parentSub),this.right&&this.right.constructor===wn&&(this.parent=this.right.parent,this.parentSub=this.right.parentSub);else if(this.parent.constructor===iu){const n=uv(t,this.parent);n.constructor===fi?this.parent=null:this.parent=n.content.type}return null}integrate(e,t){if(t>0&&(this.id.clock+=t,this.left=AP(e,e.doc.store,ht(this.id.client,this.id.clock-1)),this.origin=this.left.lastId,this.content=this.content.splice(t),this.length-=t),this.parent){if(!this.left&&(!this.right||this.right.left!==null)||this.left&&this.left.right!==this.right){let n=this.left,i;if(n!==null)i=n.right;else if(this.parentSub!==null)for(i=this.parent._map.get(this.parentSub)||null;i!==null&&i.left!==null;)i=i.left;else i=this.parent._start;const s=new Set,o=new Set;for(;i!==null&&i!==this.right;){if(o.add(i),s.add(i),rg(this.origin,i.origin)){if(i.id.client<this.id.client)n=i,s.clear();else if(rg(this.rightOrigin,i.rightOrigin))break}else if(i.origin!==null&&o.has(uv(e.doc.store,i.origin)))s.has(uv(e.doc.store,i.origin))||(n=i,s.clear());else break;i=i.right}this.left=n}if(this.left!==null){const n=this.left.right;this.right=n,this.left.right=this}else{let n;if(this.parentSub!==null)for(n=this.parent._map.get(this.parentSub)||null;n!==null&&n.left!==null;)n=n.left;else n=this.parent._start,this.parent._start=this;this.right=n}this.right!==null?this.right.left=this:this.parentSub!==null&&(this.parent._map.set(this.parentSub,this),this.left!==null&&this.left.delete(e)),this.parentSub===null&&this.countable&&!this.deleted&&(this.parent._length+=this.length),E6(e.doc.store,this),this.content.integrate(e,this),CP(e,this.parent,this.parentSub),(this.parent._item!==null&&this.parent._item.deleted||this.parentSub!==null&&this.right!==null)&&this.delete(e)}else new fi(this.id,this.length).integrate(e,0)}get next(){let e=this.right;for(;e!==null&&e.deleted;)e=e.right;return e}get prev(){let e=this.left;for(;e!==null&&e.deleted;)e=e.left;return e}get lastId(){return this.length===1?this.id:ht(this.id.client,this.id.clock+this.length-1)}mergeWith(e){if(this.constructor===e.constructor&&rg(e.origin,this.lastId)&&this.right===e&&rg(this.rightOrigin,e.rightOrigin)&&this.id.client===e.id.client&&this.id.clock+this.length===e.id.clock&&this.deleted===e.deleted&&this.redone===null&&e.redone===null&&this.content.constructor===e.content.constructor&&this.content.mergeWith(e.content)){const t=this.parent._searchMarker;return t&&t.forEach(n=>{n.p===e&&(n.p=this,!this.deleted&&this.countable&&(n.index-=this.length))}),e.keep&&(this.keep=!0),this.right=e.right,this.right!==null&&(this.right.left=this),this.length+=e.length,!0}return!1}delete(e){if(!this.deleted){const t=this.parent;this.countable&&this.parentSub===null&&(t._length-=this.length),this.markDeleted(),Gy(e.deleteSet,this.id.client,this.id.clock,this.length),CP(e,t,this.parentSub),this.content.delete(e)}}gc(e,t){if(!this.deleted)throw Ps();this.content.gc(e),t?Jve(e,this,new fi(this.id,this.length)):this.content=new Wf(this.length)}write(e,t){const n=t>0?ht(this.id.client,this.id.clock+t-1):this.origin,i=this.rightOrigin,s=this.parentSub,o=this.content.getRef()&eb|(n===null?0:si)|(i===null?0:Eo)|(s===null?0:kf);if(e.writeInfo(o),n!==null&&e.writeLeftID(n),i!==null&&e.writeRightID(i),n===null&&i===null){const a=this.parent;if(a._item!==void 0){const c=a._item;if(c===null){const l=Yve(a);e.writeParentInfo(!0),e.writeString(l)}else e.writeParentInfo(!1),e.writeLeftID(c.id)}else a.constructor===String?(e.writeParentInfo(!0),e.writeString(a)):a.constructor===iu?(e.writeParentInfo(!1),e.writeLeftID(a)):Ps();s!==null&&e.writeString(s)}this.content.write(e,t)}}const G6=(r,e)=>G_e[e&eb](r),G_e=[()=>{Ps()},C_e,D_e,T_e,N_e,P_e,R_e,H_e,L_e,I_e,()=>{Ps()}],W_e=10;class pi extends lA{get deleted(){return!0}delete(){}mergeWith(e){return this.constructor!==e.constructor?!1:(this.length+=e.length,!0)}integrate(e,t){Ps()}write(e,t){e.writeInfo(W_e),pt(e.restEncoder,this.length-t)}getMissing(e,t){return null}}const W6=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:{},q6="__ $YJS$ __";W6[q6]===!0&&console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");W6[q6]=!0;const nl=r=>uh((e,t)=>{r.onerror=n=>t(new Error(n.target.error)),r.onsuccess=n=>e(n.target.result)}),q_e=(r,e)=>uh((t,n)=>{const i=indexedDB.open(r);i.onupgradeneeded=s=>e(s.target.result),i.onerror=s=>n(el(s.target.error)),i.onsuccess=s=>{const o=s.target.result;o.onversionchange=()=>{o.close()},t(o)}}),K_e=r=>nl(indexedDB.deleteDatabase(r)),X_e=(r,e)=>e.forEach(t=>r.createObjectStore.apply(r,t)),Sd=(r,e,t="readwrite")=>{const n=r.transaction(e,t);return e.map(i=>nxe(n,i))},K6=(r,e)=>nl(r.count(e)),Y_e=(r,e)=>nl(r.get(e)),X6=(r,e)=>nl(r.delete(e)),Z_e=(r,e,t)=>nl(r.put(e,t)),wE=(r,e)=>nl(r.add(e)),J_e=(r,e,t)=>nl(r.getAll(e,t)),j_e=(r,e,t)=>{let n=null;return txe(r,e,i=>(n=i,!1),t).then(()=>n)},Q_e=(r,e=null)=>j_e(r,e,"prev"),exe=(r,e)=>uh((t,n)=>{r.onerror=n,r.onsuccess=async i=>{const s=i.target.result;if(s===null||await e(s)===!1)return t();s.continue()}}),txe=(r,e,t,n="next")=>exe(r.openKeyCursor(e,n),i=>t(i.key)),nxe=(r,e)=>r.objectStore(e),rxe=(r,e)=>IDBKeyRange.upperBound(r,e),ixe=(r,e)=>IDBKeyRange.lowerBound(r,e),fv="custom",Y6="updates",Z6=500,J6=(r,e=()=>{},t=()=>{})=>{const[n]=Sd(r.db,[Y6]);return J_e(n,ixe(r._dbref,!1)).then(i=>{r._destroyed||(e(n),Lt(r.doc,()=>{i.forEach(s=>tA(r.doc,s))},r,!1),t(n))}).then(()=>Q_e(n).then(i=>{r._dbref=i+1})).then(()=>K6(n).then(i=>{r._dbsize=i})).then(()=>n)},sxe=(r,e=!0)=>J6(r).then(t=>{(e||r._dbsize>=Z6)&&wE(t,v6(r.doc)).then(()=>X6(t,rxe(r._dbref,!0))).then(()=>K6(t).then(n=>{r._dbsize=n}))});class oxe extends WM{constructor(e,t){super(),this.doc=t,this.name=e,this._dbref=0,this._dbsize=0,this._destroyed=!1,this.db=null,this.synced=!1,this._db=q_e(e,n=>X_e(n,[["updates",{autoIncrement:!0}],["custom"]])),this.whenSynced=uh(n=>this.on("synced",()=>n(this))),this._db.then(n=>{this.db=n,J6(this,o=>wE(o,v6(t)),()=>{if(this._destroyed)return this;this.synced=!0,this.emit("synced",[this])})}),this._storeTimeout=1e3,this._storeTimeoutId=null,this._storeUpdate=(n,i)=>{if(this.db&&i!==this){const[s]=Sd(this.db,[Y6]);wE(s,n),++this._dbsize>=Z6&&(this._storeTimeoutId!==null&&clearTimeout(this._storeTimeoutId),this._storeTimeoutId=setTimeout(()=>{sxe(this,!1),this._storeTimeoutId=null},this._storeTimeout))}},t.on("update",this._storeUpdate),this.destroy=this.destroy.bind(this),t.on("destroy",this.destroy)}destroy(){return this._storeTimeoutId&&clearTimeout(this._storeTimeoutId),this.doc.off("update",this._storeUpdate),this.doc.off("destroy",this.destroy),this._destroyed=!0,this._db.then(e=>{e.close()})}clearData(){return this.destroy().then(()=>{K_e(this.name)})}get(e){return this._db.then(t=>{const[n]=Sd(t,[fv],"readonly");return Y_e(n,e)})}set(e,t){return this._db.then(n=>{const[i]=Sd(n,[fv]);return Z_e(i,t,e)})}del(e){return this._db.then(t=>{const[n]=Sd(t,[fv]);return X6(n,e)})}}class axe extends WM{constructor(e,t,n={}){var i;super(),this.networkManager=e,this.doc=t,this.topic=n.topic||"peercompute-state-sync",this.awareness=null,this._onDocumentUpdate=this._onDocumentUpdate.bind(this),this._onNetworkMessage=this._onNetworkMessage.bind(this),this.doc.on("update",this._onDocumentUpdate),(i=this.networkManager)!=null&&i.addMessageHandler&&this.networkManager.addMessageHandler(this._onNetworkMessage),console.log("[PeerComputeProvider] Initialized")}_onDocumentUpdate(e,t){t!==this&&this.networkManager.broadcast({type:"yjs-update",data:Array.from(e)},{topic:this.topic}).catch(n=>{console.error("[PeerComputeProvider] Broadcast failed",n)})}_onNetworkMessage(e,t){if(t.type==="yjs-update"){const n=new Uint8Array(t.data);tA(this.doc,n,this)}}destroy(){this.doc.off("update",this._onDocumentUpdate),this.networkManager=null}}class cxe{constructor({ydoc:e,stateMap:t,hotStore:n,deltaNamespace:i="deltas"}={}){if(!e||!t)throw new Error("[DataState] ydoc and stateMap are required");this.ydoc=e,this.state=t,this.hotStore=n||new Map,this.deltaNamespace=i}_getNamespaceMap(e){let t=this.state.get(e);return t||(t=new Pa,this.state.set(e,t)),t}commitDelta(e={}){const t=e.taskId||e.key;if(!t)throw new Error("[DataState] commitDelta requires taskId");const n=e.scope||this.deltaNamespace,i={version:e.version??null,payload:e.payload??null,ts:e.timestamp??Date.now()};this.ydoc.transact(()=>{(n?this._getNamespaceMap(n):this.state).set(t,i)},"commit-delta")}readWarm(e,t){if(t){const n=this.state.get(t);return n?n.get(e):void 0}return this.state.get(e)}writeWarm(e,t,n){this.ydoc.transact(()=>{n?this._getNamespaceMap(n).set(e,t):this.state.set(e,t)},"write-warm")}getWarmDeltas(e=this.deltaNamespace){const t=this.state.get(e);return t?typeof t.entries=="function"?Object.fromEntries(t.entries()):{}:{}}setHotBuffer(e,t){this.hotStore.set(e,t)}getHotBuffer(e){return this.hotStore.get(e)}deleteHotBuffer(e){this.hotStore.delete(e)}listHotBuffers(){return Array.from(this.hotStore.keys())}}class lxe{constructor(e,t={}){this.networkManager=e,this.libp2pNode=e?e.getLibp2pNode():null,this.config={docName:t.docName||"peercompute-state",topic:t.topic||"peercompute-state-sync",enablePersistence:t.enablePersistence!==!1,disableNetworkProvider:t.disableNetworkProvider||!1,disableBroadcast:t.disableBroadcast||!1,broadcastNamespaces:Array.isArray(t.broadcastNamespaces)?t.broadcastNamespaces:null,...t},this.ydoc=new Dh,this.state=this.ydoc.getMap("state"),this.dataState=new cxe({ydoc:this.ydoc,stateMap:this.state,hotStore:t.hotStore,deltaNamespace:t.deltaNamespace||"deltas"}),this.indexeddbProvider=null,this.libp2pProvider=null,this.subscribers=new Map,this.globalSubscribers=new Set,this.isInitialized=!1,this.persistenceFailed=!1}_getNamespaceMap(e){let t=this.state.get(e);return t||(t=new Pa,this.state.set(e,t)),t}applyRemoteUpdate(e){try{const t=(()=>{if(e instanceof Uint8Array)return e;if(Array.isArray(e))return new Uint8Array(e);if(e&&typeof e=="object"){const i=Object.values(e);return new Uint8Array(i)}return new Uint8Array(0)})();if(t.byteLength===0){console.warn("[StateManager] Remote update was empty, skipping");return}const n=t;tA(this.ydoc,n,this)}catch(t){console.error("[StateManager] Failed to apply remote update:",t)}}applyStateSet(e,t,n){try{this.ydoc.transact(()=>{if(n){const i=this._getNamespaceMap(n);t===void 0?i.delete(e):i.set(e,t)}else t===void 0?this.state.delete(e):this.state.set(e,t)},"remote-state-set")}catch(i){console.error("[StateManager] Failed to apply state-set:",i)}}commitDelta(e){if(!this.isInitialized)throw new Error("StateManager not initialized");this.dataState.commitDelta(e)}getDataState(){return this.dataState}getWarmDeltas(e){return this.dataState.getWarmDeltas(e)}setHotBuffer(e,t){this.dataState.setHotBuffer(e,t)}getHotBuffer(e){return this.dataState.getHotBuffer(e)}async initialize(e={}){if(this.isInitialized){console.warn("[StateManager] Already initialized");return}try{if(this.config.enablePersistence&&(this.indexeddbProvider=new oxe(this.config.docName,this.ydoc),await new Promise(t=>{this.indexeddbProvider.once("synced",t)}),console.log("[StateManager] IndexedDB persistence loaded")),this.networkManager&&!this.config.disableNetworkProvider)try{this.libp2pProvider=new axe(this.networkManager,this.ydoc,{topic:this.config.topic}),console.log("[StateManager] PeerCompute P2P synchronization enabled")}catch(t){console.error("[StateManager] Failed to enable P2P sync:",t)}Object.keys(e).length>0&&this.ydoc.transact(()=>{for(const[t,n]of Object.entries(e))this.state.set(t,n)}),this._setupObservers(),this.isInitialized=!0,console.log("[StateManager] Initialized")}catch(t){throw console.error("[StateManager] Initialization failed:",t),t}}_setupObservers(){this.state.observe(e=>{e.keysChanged.forEach(t=>{const n=this.state.get(t),i=this.subscribers.get(t);i&&i.forEach(s=>{try{s(n,t)}catch(o){console.error("[StateManager] Subscriber error:",o)}}),this.globalSubscribers.forEach(s=>{try{s(n,t)}catch(o){console.error("[StateManager] Global subscriber error:",o)}})})},{captureTransactions:!1})}_setupFallbackSync(){this.libp2pNode&&console.log("[StateManager] Using fallback P2P sync via NetworkManager")}read(e){if(!this.isInitialized)throw new Error("StateManager not initialized");return this.state.get(e)}write(e,t){var n;if(!this.isInitialized)throw new Error("StateManager not initialized");this._safeSetMap(this.state,e,t),(n=this.networkManager)!=null&&n.broadcast&&!this.config.disableBroadcast&&this.networkManager.broadcast({type:"state-set",data:{key:e,value:t}}).catch(()=>{})}writeScoped(e,t,n){var s;const i=this._getNamespaceMap(e);this._safeSetMap(i,t,n),(s=this.networkManager)!=null&&s.broadcast&&!this.config.disableBroadcast&&(!this.config.broadcastNamespaces||this.config.broadcastNamespaces.includes(e))&&this.networkManager.broadcast({type:"state-set",data:{namespace:e,key:t,value:n}}).catch(()=>{})}readScoped(e,t){const n=this.state.get(e);if(n)return n.get(t)}hasScoped(e,t){const n=this.state.get(e);return n?n.has(t):!1}listNamespaceKeys(e){const t=this.state.get(e);return t?Array.from(t.keys()):[]}clearNamespace(e){var i;const t=this.state.get(e);if(!t)return;const n=Array.from(t.keys());this.ydoc.transact(()=>{n.forEach(s=>t.delete(s))}),(i=this.networkManager)!=null&&i.broadcast&&!this.config.disableBroadcast&&n.forEach(s=>{this.networkManager.broadcast({type:"state-set",data:{namespace:e,key:s,value:void 0}}).catch(()=>{})})}deleteScoped(e,t){var i;const n=this.state.get(e);n&&(n.delete(t),(i=this.networkManager)!=null&&i.broadcast&&!this.config.disableBroadcast&&this.networkManager.broadcast({type:"state-set",data:{namespace:e,key:t,value:void 0}}).catch(()=>{}))}delete(e){if(!this.isInitialized)throw new Error("StateManager not initialized");this.state.delete(e)}has(e){if(!this.isInitialized)throw new Error("StateManager not initialized");return this.state.has(e)}_safeSetMap(e,t,n){var i,s;if(this.persistenceFailed){e.set(t,n);return}try{e.set(t,n)}catch(o){if((o==null?void 0:o.name)==="InvalidStateError")console.warn("[StateManager] Persistence unavailable, disabling IndexedDB provider",o),(s=(i=this.indexeddbProvider)==null?void 0:i.destroy)==null||s.call(i),this.indexeddbProvider=null,this.persistenceFailed=!0,e.set(t,n);else throw o}}batchWrite(e){if(!this.isInitialized)throw new Error("StateManager not initialized");this.ydoc.transact(()=>{for(const[t,n]of Object.entries(e))this.state.set(t,n)})}subscribe(e,t){if(!this.isInitialized)throw new Error("StateManager not initialized");return e==="*"?(this.globalSubscribers.add(t),()=>{this.globalSubscribers.delete(t)}):(this.subscribers.has(e)||this.subscribers.set(e,new Set),this.subscribers.get(e).add(t),()=>{const n=this.subscribers.get(e);n&&(n.delete(t),n.size===0&&this.subscribers.delete(e))})}observeNamespace(e,t){const n=this._getNamespaceMap(e),i=s=>{s.keysChanged.forEach(o=>{t(n.get(o),o)})};return n.observe(i),()=>n.unobserve(i)}keys(){if(!this.isInitialized)throw new Error("StateManager not initialized");return Array.from(this.state.keys())}values(){if(!this.isInitialized)throw new Error("StateManager not initialized");return Array.from(this.state.values())}entries(){if(!this.isInitialized)throw new Error("StateManager not initialized");return Array.from(this.state.entries())}async synchronize(e){console.log("[StateManager] Synchronization is automatic with Yjs CRDT")}snapshot(){if(!this.isInitialized)throw new Error("StateManager not initialized");return{data:Object.fromEntries(this.state.entries()),timestamp:Date.now(),version:this.ydoc.clientID,keyCount:this.state.size}}getYDoc(){return this.ydoc}getYMap(){return this.state}getAwareness(){var e;return((e=this.libp2pProvider)==null?void 0:e.awareness)||null}clear(){if(!this.isInitialized)throw new Error("StateManager not initialized");this.ydoc.transact(()=>{this.state.clear()})}async destroy(){try{this.libp2pProvider&&(this.libp2pProvider.destroy(),this.libp2pProvider=null),this.indexeddbProvider&&(this.indexeddbProvider.destroy(),this.indexeddbProvider=null),this.subscribers.clear(),this.globalSubscribers.clear(),this.ydoc.destroy(),this.isInitialized=!1,console.log("[StateManager] Destroyed")}catch(e){throw console.error("[StateManager] Destroy failed:",e),e}}async clearPersistence(){var e;if((e=this.indexeddbProvider)!=null&&e.clearData)try{await this.indexeddbProvider.clearData(),console.log("[StateManager] IndexedDB persistence cleared")}catch(t){console.error("[StateManager] Failed to clear IndexedDB persistence",t)}}async clearAllPersistenceByPrefix(e,t=[]){if(typeof(indexedDB==null?void 0:indexedDB.databases)=="function")try{const n=await indexedDB.databases();for(const i of n||[])i!=null&&i.name&&i.name.startsWith(e)&&!t.includes(i.name)&&await new Promise((s,o)=>{const a=indexedDB.deleteDatabase(i.name);a.onsuccess=()=>s(),a.onerror=()=>o(a.error),a.onblocked=()=>s()});console.log(`[StateManager] Cleared IndexedDB databases with prefix ${e}`)}catch(n){console.warn("[StateManager] Failed to enumerate/delete IndexedDB databases",n)}}getDocName(){return this.config.docName}getStats(){var e,t;return{isInitialized:this.isInitialized,keyCount:this.state.size,subscriberCount:this.subscribers.size,globalSubscriberCount:this.globalSubscribers.size,hasPersistence:!!this.indexeddbProvider,hasP2PSync:!!this.libp2pProvider,docName:this.config.docName,topic:this.config.topic,hotBufferCount:((t=(e=this.dataState)==null?void 0:e.listHotBuffers)==null?void 0:t.call(e).length)||0}}}const uxe="modulepreload",hxe=function(r,e){return new URL(r,e).href},DP={},dxe=function(e,t,n){let i=Promise.resolve();if(t&&t.length>0){let o=function(u){return Promise.all(u.map(h=>Promise.resolve(h).then(d=>({status:"fulfilled",value:d}),d=>({status:"rejected",reason:d}))))};const a=document.getElementsByTagName("link"),c=document.querySelector("meta[property=csp-nonce]"),l=(c==null?void 0:c.nonce)||(c==null?void 0:c.getAttribute("nonce"));i=o(t.map(u=>{if(u=hxe(u,n),u in DP)return;DP[u]=!0;const h=u.endsWith(".css"),d=h?'[rel="stylesheet"]':"";if(!!n)for(let b=a.length-1;b>=0;b--){const g=a[b];if(g.href===u&&(!h||g.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${u}"]${d}`))return;const p=document.createElement("link");if(p.rel=h?"stylesheet":uxe,h||(p.as="script"),p.crossOrigin="",p.href=u,l&&p.setAttribute("nonce",l),document.head.appendChild(p),h)return new Promise((b,g)=>{p.addEventListener("load",b),p.addEventListener("error",()=>g(new Error(`Unable to preload CSS for ${u}`)))})}))}function s(o){const a=new Event("vite:preloadError",{cancelable:!0});if(a.payload=o,window.dispatchEvent(a),!a.defaultPrevented)throw o}return i.then(o=>{for(const a of o||[])a.status==="rejected"&&s(a.reason);return e().catch(s)})};class fxe{constructor(e={}){const t=typeof navigator<"u"&&navigator.hardwareConcurrency?navigator.hardwareConcurrency:4;this.config={enableWebGPU:e.enableWebGPU||!1,enableWorkers:e.enableWorkers!==!1,maxWorkers:e.maxWorkers||t,...e},this.workers=[],this.taskQueue=[],this.activeTasks=new Map,this.commitDeltaHandler=null,this.capabilities={cpu:!0,webgpu:!1},this.initialized=!1}setCommitDeltaHandler(e){this.commitDeltaHandler=e}commitDelta(e){this.commitDeltaHandler&&this.commitDeltaHandler(e)}async initialize(){if(this.initialized)return;if(this.initialized=!0,!(typeof Worker<"u"&&this.config.enableWorkers)){console.warn("[ComputeManager] Web Workers not available; falling back to inline execution");return}const t=new URL("data:text/javascript;base64,LyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovCgpzZWxmLm9ubWVzc2FnZSA9IGFzeW5jIChldmVudCkgPT4gewogIGNvbnN0IG1zZyA9IGV2ZW50LmRhdGE7CiAgaWYgKCFtc2cgfHwgbXNnLnR5cGUgIT09ICdydW4nKSByZXR1cm47CiAgY29uc3QgeyBpZCwgZGF0YSwgZm4sIG1vZHVsZSwgZXhwb3J0TmFtZSB9ID0gbXNnOwogIHRyeSB7CiAgICBsZXQgaGFuZGxlcjsKICAgIGlmIChmbikgewogICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmMKICAgICAgaGFuZGxlciA9IG5ldyBGdW5jdGlvbihgcmV0dXJuICgke2ZufSk7YCkoKTsKICAgIH0gZWxzZSBpZiAobW9kdWxlKSB7CiAgICAgIC8vIFNpbGVuY2Ugd2VicGFjaydzICJkZXBlbmRlbmN5IGlzIGFuIGV4cHJlc3Npb24iIHdhcm5pbmcgYnkgZXhwbGljaXRseSBpZ25vcmluZyBidW5kbGluZyBoZXJlLgogICAgICAvLyBUaGUgd29ya2VyIGV4cGVjdHMgYSByZWFsIFVSTCBzdHJpbmcgcGFzc2VkIGluIGZyb20gdGhlIG1haW4gdGhyZWFkLgogICAgICBjb25zdCBtb2QgPSBhd2FpdCBpbXBvcnQoCiAgICAgICAgLyogd2VicGFja0lnbm9yZTogdHJ1ZSAqLwogICAgICAgIG1vZHVsZQogICAgICApOwogICAgICBoYW5kbGVyID0gbW9kW2V4cG9ydE5hbWUgfHwgJ2RlZmF1bHQnXTsKICAgIH0KICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykgewogICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhbmRsZXIgbm90IGZvdW5kIGZvciB0YXNrJyk7CiAgICB9CiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBoYW5kbGVyKGRhdGEpOwogICAgc2VsZi5wb3N0TWVzc2FnZSh7IHR5cGU6ICdyZXN1bHQnLCBpZCwgcmVzdWx0IH0pOwogIH0gY2F0Y2ggKGVycikgewogICAgc2VsZi5wb3N0TWVzc2FnZSh7IHR5cGU6ICdlcnJvcicsIGlkLCBlcnJvcjogZXJyPy5tZXNzYWdlIHx8IFN0cmluZyhlcnIpIH0pOwogIH0KfTsK",import.meta.url),n=Math.max(1,Math.min(this.config.maxWorkers,128));for(let i=0;i<n;i++){const s=new Worker(t,{type:"module"});s.onmessage=o=>this._handleWorkerMessage(s,o.data),s.onerror=o=>console.error("[ComputeManager] Worker error",o),this.workers.push(s)}}async submitTask(e){if(!e)throw new Error("Task is required");if(!e.fn&&!e.module)throw new Error("Task must provide fn or module");const t=typeof crypto<"u"&&crypto.randomUUID?crypto.randomUUID():`${Date.now()}-${Math.random()}`,n=e.id||t,i={id:n,data:e.data??null,fn:e.fn?e.fn.toString():void 0,module:e.module,exportName:e.exportName||"default"};return this.initialized||await this.initialize(),new Promise((s,o)=>{const a={id:n,payload:i,resolve:s,reject:o};this._dispatchToWorker(a)||(this.taskQueue.push(a),this._scheduleNext())})}async distributeTask(e,t){}async cancelTask(e){}getCapabilities(){return{...this.capabilities,workers:this.workers.length,activeTaskCount:this.activeTasks.size,queuedTaskCount:this.taskQueue.length}}getStats(){return{totalTasksCompleted:0,averageTaskDuration:0,currentLoad:0}}async _executeTask(e){}_scheduleNext(){}_handleTaskComplete(e,t){}_handleTaskError(e,t){}_dispatchToWorker(e){const t=this.workers.find(n=>!Array.from(this.activeTasks.values()).some(i=>i.worker===n));return t?(this.activeTasks.set(e.id,{...e,worker:t}),t.postMessage({type:"run",...e.payload}),!0):!1}async _executeInline(e){try{let t;if(e.payload.fn)t=new Function(`return (${e.payload.fn});`)();else if(e.payload.module){if(typeof e.payload.module!="string")throw new Error("module path must be a string");t=(await dxe(()=>import(`${e.payload.module}`),[],import.meta.url))[e.payload.exportName||"default"]}const n=await t(e.payload.data);if(n&&typeof n=="object"&&Object.prototype.hasOwnProperty.call(n,"commitDelta")){this.commitDelta(n.commitDelta);const i=Object.prototype.hasOwnProperty.call(n,"value")?n.value:n.result;e.resolve(i);return}e.resolve(n)}catch(t){e.reject(t)}}_handleWorkerMessage(e,t){const{id:n,type:i,result:s,error:o}=t||{},a=this.activeTasks.get(n);if(a){if(i==="result"){let c=s;s&&typeof s=="object"&&Object.prototype.hasOwnProperty.call(s,"commitDelta")&&(this.commitDelta(s.commitDelta),c=Object.prototype.hasOwnProperty.call(s,"value")?s.value:s.result),a.resolve(c)}else i==="error"&&a.reject(new Error(o||"Worker task failed"));this.activeTasks.delete(n),this._scheduleNext()}}_scheduleNext(){if(this.taskQueue.length===0)return;const e=this.taskQueue.shift();if(this.workers.length===0){this._executeInline(e);return}this._dispatchToWorker(e)||this.taskQueue.unshift(e)}}class pxe{constructor(e={}){this.frameBudgetMs=e.frameBudgetMs??4,this.hotStore=e.hotStore||new Map,this.device=null,this.tasks=new Map}async initialize(e={}){if(e.device)return this.device=e.device,this.device;if(typeof navigator>"u"||!navigator.gpu)throw new Error("[GPUHubManager] WebGPU not available in this environment");const t=await navigator.gpu.requestAdapter(e.adapterOptions);if(!t)throw new Error("[GPUHubManager] Failed to acquire GPU adapter");return this.device=await t.requestDevice(e.deviceDescriptor),this.device}setDevice(e){this.device=e}getHotStore(){return this.hotStore}registerHotBuffer(e,t){this.hotStore.set(e,t)}registerHotBufferSet(e,t){this.hotStore.set(e,t)}getHotBufferSet(e){return this.hotStore.get(e)}getHotBuffer(e){return this.hotStore.get(e)}createHotBuffer(e,t,n,i){if(!this.device)throw new Error("[GPUHubManager] Device not initialized");const s=this.device.createBuffer({size:t,usage:n,label:i});return this.hotStore.set(e,s),s}removeHotBuffer(e){this.hotStore.delete(e)}registerTask(e,t){this.tasks.set(e,t)}unregisterTask(e){this.tasks.delete(e)}tick(){}}function mxe(){return`${Date.now()}-${Math.random().toString(36).substr(2,9)}`}class vE{constructor(e={}){const t=this._normalizeClockPolicy(e.clockPolicy);this.config={topology:e.topology||"distributed",storageMode:e.storageMode||"local",enableWebGPU:e.enableWebGPU||!1,enableGPUHub:e.enableGPUHub!==!1,enableWarmDeltaProvider:e.enableWarmDeltaProvider||!1,enablePersistence:e.enablePersistence!==!1,disableStateNetworkProvider:e.disableStateNetworkProvider||!1,disableStateBroadcast:e.disableStateBroadcast||!1,bootstrapPeers:Array.isArray(e.bootstrapPeers)?e.bootstrapPeers:[],gameId:e.gameId||"default-game",roomId:e.roomId||"default-room",stateTopic:e.stateTopic||"peercompute-state",docName:e.docName,stateBroadcastNamespaces:e.stateBroadcastNamespaces,deltaNamespace:e.deltaNamespace||"deltas",gpuHubFrameBudgetMs:e.gpuHubFrameBudgetMs,clockPolicy:t,...e},this.stateManager=null,this.networkManager=null,this.computeManager=null,this.gpuHub=null,this.isInitialized=!1,this.isStarted=!1,this.nodeId=null,this.kernelClockTimer=null,this.kernelTickMs=Math.round(1e3/(this.config.clockPolicy.tickHz||30))}async initialize(){var e;if(this.isInitialized){console.warn("[NodeKernel] Already initialized");return}try{console.log("[NodeKernel] Initializing..."),this.nodeId=mxe(),console.log(`[NodeKernel] Node ID: ${this.nodeId}`),this.networkManager=new xwe({topology:this.config.topology,bootstrapPeers:this.config.bootstrapPeers,gameId:this.config.gameId,roomId:this.config.roomId,pubsubTopic:this.config.stateTopic,schedulerClock:this.config.clockPolicy.mode==="kernel"?"external":"internal",schedulerProfile:this.config.clockPolicy.networkProfile,onMessage:this._handleNetworkMessage.bind(this),onPeerConnect:this._handlePeerConnect.bind(this),onPeerDisconnect:this._handlePeerDisconnect.bind(this)}),await this.networkManager.initialize(),console.log("[NodeKernel] NetworkManager initialized");const t=this.config.docName||`peercompute-${this.config.gameId}-${this.config.roomId}`;this.config.enableGPUHub&&(this.gpuHub=new pxe({frameBudgetMs:this.config.gpuHubFrameBudgetMs})),this.stateManager=new lxe(this.networkManager,{docName:t,topic:this.config.stateTopic,enablePersistence:this.config.enablePersistence,disableNetworkProvider:this.config.disableStateNetworkProvider,disableBroadcast:this.config.disableStateBroadcast,broadcastNamespaces:this.config.stateBroadcastNamespaces,deltaNamespace:this.config.deltaNamespace,hotStore:(e=this.gpuHub)==null?void 0:e.getHotStore()}),await this.stateManager.initialize({nodeId:this.nodeId,topology:this.config.topology,createdAt:Date.now()}),console.log("[NodeKernel] StateManager initialized"),this.config.enableWarmDeltaProvider&&this.networkManager.registerWarmDeltaProvider(()=>this.stateManager.getWarmDeltas()),this.computeManager=new fxe({enableWebGPU:this.config.enableWebGPU,maxWorkers:this.config.maxWorkers,enableWorkers:this.config.enableWorkers!==!1}),await this.computeManager.initialize(),this.computeManager.setCommitDeltaHandler(n=>{var i,s;(s=(i=this.stateManager)==null?void 0:i.commitDelta)==null||s.call(i,n)}),console.log("[NodeKernel] ComputeManager initialized"),this.isInitialized=!0,console.log("[NodeKernel] Initialization complete")}catch(t){throw console.error("[NodeKernel] Initialization failed:",t),t}}async start(e){if(!this.isInitialized)throw new Error("NodeKernel not initialized. Call initialize() first.");if(this.isStarted){console.warn("[NodeKernel] Already started");return}try{console.log("[NodeKernel] Starting..."),await this.networkManager.connect(),this.config.clockPolicy.networkProfile&&this.networkManager.configureScheduler(this.config.clockPolicy.networkProfile),this.config.clockPolicy.mode==="kernel"&&this._startKernelClock(),this.stateManager.write("status","active"),this.stateManager.write("startedAt",Date.now()),this.isStarted=!0,console.log("[NodeKernel] Node started and connected to P2P network")}catch(t){throw console.error("[NodeKernel] Start failed:",t),t}}async stop(){if(!this.isStarted){console.warn("[NodeKernel] Node not started");return}try{console.log("[NodeKernel] Stopping..."),this._stopKernelClock(),this.stateManager&&this.stateManager.write("status","stopped"),this.networkManager&&await this.networkManager.disconnect(),this.stateManager&&await this.stateManager.destroy(),this.computeManager,this.isStarted=!1,console.log("[NodeKernel] Node stopped")}catch(e){throw console.error("[NodeKernel] Stop failed:",e),e}}setClockPolicy(e={}){const t=this._normalizeClockPolicy(e,this.config.clockPolicy);this.config.clockPolicy=t,this.kernelTickMs=Math.round(1e3/t.tickHz),this.networkManager&&(this.networkManager.setSchedulerClock(t.mode==="kernel"?"external":"internal"),t.networkProfile&&this.networkManager.configureScheduler(t.networkProfile)),this.isStarted&&(t.mode==="kernel"?this._startKernelClock():this._stopKernelClock())}tick(e=Date.now()){var t,n;(n=(t=this.networkManager)==null?void 0:t.tickScheduler)==null||n.call(t,e)}_startKernelClock(){if(this.kernelClockTimer)return;const e=Math.max(10,this.kernelTickMs||33);this.kernelClockTimer=setInterval(()=>{this.tick(Date.now())},e)}_stopKernelClock(){this.kernelClockTimer&&(clearInterval(this.kernelClockTimer),this.kernelClockTimer=null)}_normalizeClockPolicy(e={},t={}){const n=e&&typeof e=="object"?e:{},i=t&&typeof t=="object"?t:{},s=n.mode||i.mode||"independent",o=n.tickHz??i.tickHz??30,a=Number.isFinite(o)&&o>0?o:30,c=n.networkProfile!==void 0?n.networkProfile:i.networkProfile||null;return{mode:s==="kernel"?"kernel":"independent",tickHz:a,networkProfile:c}}async submitTask(e){if(!this.isStarted)throw new Error("Node not started");if(!this.computeManager)throw new Error("ComputeManager not initialized");return this.computeManager.submitTask(e)}getStatus(){var n,i,s,o;const e=((n=this.networkManager)==null?void 0:n.getNetworkStats())||{},t=((i=this.stateManager)==null?void 0:i.getStats())||{};return{nodeId:this.nodeId,isInitialized:this.isInitialized,isStarted:this.isStarted,topology:this.config.topology,clock:{mode:this.config.clockPolicy.mode,tickHz:this.config.clockPolicy.tickHz,schedulerClock:(o=(s=this.networkManager)==null?void 0:s.getSchedulerClock)==null?void 0:o.call(s)},network:{peerId:e.peerId,peerCount:e.peerCount,isConnected:e.isConnected,connections:e.connections},state:{keyCount:t.keyCount,hasPersistence:t.hasPersistence,hasP2PSync:t.hasP2PSync},compute:{enabled:!0,available:!!this.computeManager}}}getStateManager(){return this.stateManager}getNetworkManager(){return this.networkManager}getComputeManager(){return this.computeManager}getGPUHub(){return this.gpuHub}_handleNetworkMessage(e,t){var n,i,s;switch(console.log(`[NodeKernel] Message from ${e}:`,t.type),t.type){case"state-request":this._handleStateRequest(e,t.data);break;case"yjs-update":this.stateManager&&this.stateManager.applyRemoteUpdate(t.data);break;case"state-set":this.stateManager&&this.stateManager.applyStateSet((n=t.data)==null?void 0:n.key,(i=t.data)==null?void 0:i.value,(s=t.data)==null?void 0:s.namespace);break;case"compute-task":this._handleComputeTask(e,t.data);break;case"ping":this._handlePing(e,t.data);break;default:console.warn(`[NodeKernel] Unknown message type: ${t.type}`)}}_handlePeerConnect(e){console.log(`[NodeKernel] Peer connected: ${e}`);const t=this.stateManager.read("connectedPeers")||[];t.includes(e)||(t.push(e),this.stateManager.write("connectedPeers",t))}_handlePeerDisconnect(e){console.log(`[NodeKernel] Peer disconnected: ${e}`);const n=(this.stateManager.read("connectedPeers")||[]).filter(i=>i!==e);this.stateManager.write("connectedPeers",n)}async _handleStateRequest(e,t){const n=this.stateManager.snapshot();await this.networkManager.sendToPeer(e,{type:"state-response",data:n})}async _handleComputeTask(e,t){console.log(`[NodeKernel] Compute task from ${e}: TODO`)}async _handlePing(e,t){await this.networkManager.sendToPeer(e,{type:"pong",data:{timestamp:Date.now(),originalTimestamp:t.timestamp}})}}class gxe{static createButton(e){const t=document.createElement("button");t.id="VRButton",t.style.cssText="position:absolute;bottom:20px;right:20px;padding:12px 24px;border:1px solid white;border-radius:4px;background:rgba(0,0,0,0.6);color:white;font:normal 13px sans-serif;cursor:pointer;pointer-events:auto;";const n=()=>{t.textContent="VR NOT SUPPORTED",t.onclick=null},i=()=>{t.textContent="ENTER VR",t.onclick=async()=>{try{const s=await navigator.xr.requestSession("immersive-vr",{optionalFeatures:["local-floor","bounded-floor"]});s.addEventListener("end",()=>{t.textContent="ENTER VR"}),e.xr.setSession(s),t.textContent="EXIT VR"}catch(s){if((s==null?void 0:s.name)==="AbortError"){console.warn("XR session aborted by user"),t.textContent="ENTER VR";return}console.warn("Failed to start XR session",s)}}};return"xr"in navigator?navigator.xr.isSessionSupported("immersive-vr").then(s=>{s?i():n()}).catch(n):n(),t}}const yxe=(r,e,t,n,i=0,s=t.length-1)=>{const o={findSpan:(c,l,u,h)=>{const d=h-1;if(u>=l[d+1])return d;if(u<=l[c])return c;let m=c,p=d+1;for(;p-m>1;){const b=Math.floor((m+p)/2);u<l[b]?p=b:m=b}return m},calcBSplinePoint:(c,l,u,h)=>{const d=o.findSpan(c,l,h,u.length),m=[];for(let p=0;p<=c;p++)m[p]=u[d-c+p].clone();for(let p=1;p<=c;p++)for(let b=c;b>=p;b--){const g=d-c+b,y=l[g],v=l[g+c-p+1],w=v!==y?(h-y)/(v-y):0;m[b]=m[b-1].clone().multiplyScalar(1-w).add(m[b].clone().multiplyScalar(w))}return m[c]}};class a extends r.Curve{constructor(l,u,h,d=0,m=u.length-1){super(),this.degree=l,this.knots=u,this.controlPoints=h.map(p=>new r.Vector4(p.x,p.y,p.z,p.w??1)),this.startKnot=d,this.endKnot=m}getPoint(l,u=new r.Vector3){const h=this.knots[this.startKnot]+l*(this.knots[this.endKnot]-this.knots[this.startKnot]),d=o.calcBSplinePoint(this.degree,this.knots,this.controlPoints,h);return d.w!==1&&d.w!==0&&d.divideScalar(d.w),u.set(d.x,d.y,d.z)}}return new a(e,t,n,i,s)},LP="hyperborea-player-persist",bxe=()=>{try{const r=new URLSearchParams(window.location.search),e=parseInt(r.get("RD")||r.get("rd")||"",10);if(!Number.isNaN(e)&&e>0&&e<2e3)return e}catch{}return null},j6=()=>{try{const r=new URLSearchParams(window.location.search),e=r.get("netHz")||r.get("nethz")||r.get("net")||"",t=parseInt(e,10);if(!Number.isNaN(t)&&t>0&&t<=60)return t}catch{}return 20},cn={DAY_DURATION:360*1e3,YEAR_DURATION:3600*1e3,CHUNK_SIZE:2048,RENDER_DISTANCE:bxe()??8,WORLD_SEED:12345,PLAYER_SPEED:150,JUMP_FORCE:10,GRAVITY:-25},wxe=1e3,vxe=5e3,_xe=15e3,xxe=1500;Math.round(1e3/j6());const og="time-anchor",Sxe=4e3,Exe=2e3,us=(...r)=>console.log("[hyperborea-net]",...r),Mxe=r=>/^\d{1,3}(\.\d{1,3}){3}$/.test(r),Axe=r=>r.includes(":"),Txe=r=>r==="localhost"||r==="127.0.0.1"||r==="::1",Cxe=r=>Axe(r)?`/ip6/${r}`:Mxe(r)?`/ip4/${r}`:`/dns4/${r}`,Ixe=(r,e)=>typeof r!="string"?r:r.replace("/ip4/127.0.0.1",e).replace("/ip6/::1",e).replace("/dns4/localhost",e).replace("/dns/localhost",e),NP=r=>{if(typeof r!="string")return null;const e=r.split("/p2p/");return e.length<2?null:e[e.length-1]||null};class Pxe{constructor(){this.startTime=Date.now(),this.timeMultiplier=1,this.timeOffset=cn.DAY_DURATION*.5+cn.YEAR_DURATION*.125}getTime(){return(Date.now()-this.startTime)*this.timeMultiplier+this.timeOffset}setTimeMultiplier(e){const t=this.getTime();this.startTime=Date.now(),this.timeOffset=t,this.timeMultiplier=e}applyRemoteSync({multiplier:e,time:t,sentAt:n}){const i=Date.now(),s=typeof t=="number"?t:this.getTime(),o=typeof e=="number"?e:this.timeMultiplier,a=n?i-n:0;this.startTime=i,this.timeOffset=s+a*o,this.timeMultiplier=o}getDayProgress(){return this.getTime()%cn.DAY_DURATION/cn.DAY_DURATION}getYearProgress(){return this.getTime()%cn.YEAR_DURATION/cn.YEAR_DURATION}getSeason(){const e=this.getYearProgress();return e<.25?"Winter":e<.5?"Spring":e<.75?"Summer":"Fall"}getDayNumber(){return Math.floor(this.getTime()/cn.DAY_DURATION)+1}getSunPosition(){const e=this.getDayProgress(),t=this.getYearProgress(),n=.5+Math.cos(t*Math.PI*2)*.33;let i;return e<n?i=e/n*.5:i=.5+(e-n)/(1-n)*.5,i}getMoonPhase(){return this.getYearProgress()}getTemperature(){return-5+Math.cos(this.getYearProgress()*Math.PI*2)*25}}class Rxe{constructor(e){this.seed=e}next(){return this.seed=(this.seed*9301+49297)%233280,this.seed/233280}}class Xa{constructor(e){const t=new Rxe(e);this.perm=[];for(let n=0;n<256;n++)this.perm[n]=n;for(let n=255;n>0;n--){const i=Math.floor(t.next()*(n+1));[this.perm[n],this.perm[i]]=[this.perm[i],this.perm[n]]}this.perm=[...this.perm,...this.perm]}fade(e){return e*e*e*(e*(e*6-15)+10)}lerp(e,t,n){return t+e*(n-t)}grad(e,t,n){const i=e&3,s=i<2?t:n,o=i<2?n:t;return(i&1?-s:s)+(i&2?-o:o)}noise(e,t){const n=Math.floor(e)&255,i=Math.floor(t)&255,s=e-Math.floor(e),o=t-Math.floor(t),a=this.fade(s),c=this.fade(o),l=this.perm[n]+i,u=this.perm[n+1]+i;return this.lerp(c,this.lerp(a,this.grad(this.perm[l],s,o),this.grad(this.perm[u],s-1,o)),this.lerp(a,this.grad(this.perm[l+1],s,o-1),this.grad(this.perm[u+1],s-1,o-1)))}octave(e,t,n,i,s){let o=0,a=1,c=1,l=0;for(let u=0;u<n;u++)o+=this.noise(e*a/s,t*a/s)*c,l+=c,c*=i,a*=2;return o/l}}class OP{constructor(e){this.heightNoise=new Xa(e),this.moistureNoise=new Xa(e+1),this.treeNoise=new Xa(e+2),this.structureNoise=new Xa(e+3),this.macroNoise=new Xa(e+4),this.warpNoise1=new Xa(e+5),this.warpNoise2=new Xa(e+6)}warpCoords(e,t,n=8e3,i=220){const o=Math.cos(.37),a=Math.sin(.37),c=e*o-t*a,l=e*a+t*o,u=this.warpNoise1.octave(c,l,2,.5,n)*i,h=this.warpNoise2.octave(c+1337,l+1337,2,.5,n)*i;return{x:e+u,z:t+h}}getHeight(e,t){const n=this.warpCoords(e,t,9e3,260),i=n.x,s=n.z,o=this.macroNoise.octave(i,s,5,.5,16e3),a=this.heightNoise.octave(i,s,5,.5,4096),c=this.heightNoise.octave(i,s,5,.5,1024);this.heightNoise.octave(i,s,5,.5,256);let l=o*6e3;return l+=a*600,l+=c*60,l}getMoisture(e,t){const n=this.warpCoords(e,t,6500,220),i=this.moistureNoise.octave(n.x,n.z,4,.45,3200),s=this.getHeight(e,t),o=1-Math.min(Math.max(s/6e3,0),1);return i*.9+o*.1}shouldPlaceTree(e,t,n,i){if(n<450||n>1800)return!1;const c=3,l=this.getHeight(e+c,t),u=this.getHeight(e-c,t);if(Math.abs(l-u)/(c*2)>.5)return!1;const d=i>.05?.55:.35,m=this.warpCoords(e,t,6e3,150);return this.treeNoise.noise(m.x*.18,m.z*.18)>1-d}shouldPlaceStructure(e,t,n){if(n<20||n>150)return!1;const i=15,s=this.getHeight(e+i,t),o=this.getHeight(e-i,t),a=this.getHeight(e,t+i),c=this.getHeight(e,t-i);if(Math.max(Math.abs(s-n),Math.abs(o-n),Math.abs(a-n),Math.abs(c-n))>20)return!1;const u=this.warpCoords(e,t,8e3,220);return this.structureNoise.noise(u.x*.01,u.z*.01)>.95}}const Dxe="__rooms__",UP="rooms",kP="room-",BP=1e4,FP=45e3,Q6=r=>String(r||"").trim().toLowerCase().replace(/[^a-z0-9]+/g,"-").replace(/^-+|-+$/g,"")||"global",Lxe=r=>{const e=String(r||"");let t=2166136261;for(let n=0;n<e.length;n+=1)t^=e.charCodeAt(n),t=Math.imul(t,16777619);return(t>>>0).toString(16)},pv=({name:r,visibility:e,password:t})=>{const n=Q6(r);return e==="private"?`priv-${n}-${Lxe(t)}`:n},Ug=r=>Q6(r);class Nxe{constructor({gameId:e,bootstrapPeers:t}){this.gameId=e,this.bootstrapPeers=t||[],this.node=null,this.stateManager=null,this.rooms=new Map,this.announceTimer=null,this.pruneTimer=null,this.currentRoom=null}async init(){this.node||(this.node=new vE({bootstrapPeers:this.bootstrapPeers,enablePersistence:!1,gameId:this.gameId,roomId:Dxe}),await this.node.initialize(),await this.node.start(),this.stateManager=this.node.getStateManager(),this.stateManager.observeNamespace(UP,(e,t)=>{if(!(!t||!t.startsWith(kP))){if(!e){this.rooms.delete(t);return}this.rooms.set(t,e)}}),this.pruneTimer=setInterval(()=>this.pruneStaleRooms(),BP))}announceRoom(e){this.currentRoom=e,this.writeRoomEntry(),this.announceTimer||(this.announceTimer=setInterval(()=>this.writeRoomEntry(),BP))}stopAnnouncing(){this.announceTimer&&(clearInterval(this.announceTimer),this.announceTimer=null)}writeRoomEntry(){if(!this.stateManager||!this.currentRoom)return;const e=Ug(this.currentRoom.name),t=`${kP}${e}`,n={name:this.currentRoom.name,slug:e,visibility:this.currentRoom.visibility,updatedAt:Date.now(),roomId:this.currentRoom.visibility==="public"?this.currentRoom.roomId:null};this.stateManager.writeScoped(UP,t,n)}pruneStaleRooms(){const e=Date.now();for(const[t,n]of this.rooms.entries())(!n||!n.updatedAt||e-n.updatedAt>FP)&&this.rooms.delete(t)}getRooms(){const e=Date.now();return Array.from(this.rooms.values()).filter(t=>t&&(!t.updatedAt||e-t.updatedAt<=FP)).sort((t,n)=>(n.updatedAt||0)-(t.updatedAt||0))}async stop(){this.stopAnnouncing(),this.pruneTimer&&(clearInterval(this.pruneTimer),this.pruneTimer=null),this.node&&(await this.node.stop(),this.node=null),this.stateManager=null,this.rooms.clear()}}class Oxe{constructor(){var e;this.canvas=document.getElementById("gameCanvas"),this.gameNamespace="hyperborea",this.peerMeshes=new Map,this.peers=new Map,this.bootstrapPeers=[],this.roomDirectory=null,this.currentRoom={name:"global",visibility:"public",roomId:"global"},this.networkManager=null,this.libp2p=null,this.visibilityHandler=null,this.backgroundHeartbeat=null,this.peerCleanupInterval=null,this.reconnectTimer=null,this.lastReconnectAttempt=0,this.beforeUnloadHandler=null,this.connectionListenersBound=!1,this.connectionLogBound=!1,this.relayPeerIds=[],this.relayConnected=!1,this.lastStateBroadcast=0,this.attackEventsSeen=new Map,this.attackActiveUntil=0,this.myColor=Math.random()*16777215,this.playerName="";try{const t=localStorage.getItem("hyperboreaPlayerName");t&&(this.playerName=t);const n=localStorage.getItem("hyperboreaPlayerColor");n&&(this.myColor=parseInt(n.replace("#","0x"),16))}catch{}this.spearThrustProgress=0,this.persistedState=this.loadPersistedState(),this.lastPersistSave=0,this.joinedAt=Date.now(),this.timeAnchor=null,this.initThree(),this.initTime(),this.initTerrain(),this.initPlayer(),this.initSkyDome(),this.initControls(),this.initSettingsUI(),this.chunks=new Map,this.structures=new Map,this.collisionBoxes=[],this.prevChunkX=null,this.prevChunkZ=null,this.mainTempleBeam=null,this.mainTempleApex=null,this.foundationInfo=null,this.globeMaterial=null,this.chunkQueue=[],this.chunkBuildBudgetMs=6,this.structureShadowCount=0,this.lastSnowUpdate=0,this.lastSnowSeason=null,this.fps=0,this.lastFpsSample=performance.now(),this.frameSamples=0,this.baseFOV=105,this.godMode=!1,this.wideFOV=!1,this.lastUpdate=Date.now(),this.lastColorUpdate=0,this.lastShadowUpdate=0,this.lastTimeSyncBroadcast=0,this.lastStateSend=0,this.stateDirty=!0,this.lastSentState={position:new k,rotationY:0,color:this.myColor,torch:!1,spearThrust:0},this.stateScratch=new k,this.schedulerConfigured=!1,this.snapshotProviderId=null,this.keys={},this.currentSeed=cn.WORLD_SEED,this.pointerLocked=!1,this.isInVR=!1,this.vrTurning=!1,this.vrJumpPressed=!1,this.vrTorchPressed=!1,this.hasTorch=!1,this.hasSpear=!0,this.templePosition=null,this.persistedState=this.loadPersistedState(),this.lastPersistSave=0,((e=this.persistedState)==null?void 0:e.godMode)!==void 0&&(this.godMode=!!this.persistedState.godMode),this.isMobile=/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),this.touchControls={moveX:0,moveY:0,lookX:0,lookY:0,activeTouches:{}},this.initPlayerEquipment(),this.isMobile&&this.initMobileControls(),this.initMultiplayer(),this.treeGeometryClose=new jr(10,10,6),this.treeGeometryMedium=new jr(10,10,3),this.treeMaterial=new na({color:1724432,shininess:8,specular:1118481}),this.treeInstancedMeshClose=new Vg(this.treeGeometryClose,this.treeMaterial,1e5),this.treeInstancedMeshClose.castShadow=!1,this.treeInstancedMeshClose.receiveShadow=!0,this.treeInstancedMeshClose.frustumCulled=!1,this.scene.add(this.treeInstancedMeshClose),this.treeInstancedMeshMedium=new Vg(this.treeGeometryMedium,this.treeMaterial,1e5),this.treeInstancedMeshMedium.castShadow=!1,this.treeInstancedMeshMedium.receiveShadow=!0,this.treeInstancedMeshMedium.frustumCulled=!1,this.scene.add(this.treeInstancedMeshMedium),this.treeCountClose=0,this.treeCountMedium=0,this.generateInitialTerrain(),this.renderer.setAnimationLoop(()=>this.animate())}loadPersistedState(){try{const e=localStorage.getItem(LP);return e?JSON.parse(e):null}catch{return null}}savePersistedState(){var e,t;try{const n={pos:{x:this.position.x,y:this.position.y,z:this.position.z},yaw:this.yaw,pitch:this.pitch,godMode:this.godMode,time:{multiplier:(e=this.timeSystem)==null?void 0:e.timeMultiplier,time:(t=this.timeSystem)==null?void 0:t.getTime(),sentAt:Date.now()}};localStorage.setItem(LP,JSON.stringify(n))}catch{}}initThree(){this.scene=new GE;const e=window.innerWidth/window.innerHeight,t=this.baseFOV;this.camera=new In(t,e,.5,4e6),this.rig=new On,this.playerBody=new De(new Qt(2,2,2),new Ar({color:0,transparent:!0,opacity:0})),this.playerBody.position.set(0,1,0),this.playerBody.add(this.camera),this.rig.add(this.playerBody),this.scene.add(this.rig),this.renderer=new HE({canvas:this.canvas,antialias:!1}),this.renderer.setSize(window.innerWidth,window.innerHeight),this.renderer.shadowMap.enabled=!0,this.renderer.shadowMap.type=xE,this.renderer.xr.enabled=!0,this.renderer.xr.setReferenceSpaceType("local-floor"),document.body.appendChild(gxe.createButton(this.renderer)),window.addEventListener("resize",()=>{this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.fov=this.wideFOV?120:this.baseFOV,this.camera.updateProjectionMatrix(),this.renderer.setSize(window.innerWidth,window.innerHeight)})}initTime(){var e;this.timeSystem=new Pxe,(e=this.persistedState)!=null&&e.time&&this.timeSystem.applyRemoteSync(this.persistedState.time)}initTerrain(){this.terrainGen=new OP(this.currentSeed)}findSummitLocation(){let n={x:0,z:0,h:-1/0};const i=256,s=8e3;for(let o=-s;o<=s;o+=i)for(let a=-s;a<=s;a+=i){const c=this.terrainGen.getHeight(o,a);c>=2400&&c>n.h&&(n={x:o,z:a,h:c})}return n}ensureAboveGround(e,t=4){const n=this.terrainGen.getHeight(e.x,e.z);e.y<n+t&&(e.y=n+t)}async loadRelayConfig(){try{const e=async n=>{try{const i=await fetch(n,{cache:"no-store"});if(i.ok)return await i.json()}catch{}return null},t=await e("relay-config.json")||await e(".relay-config.json")||await e("/relay-config.json")||await e("/.relay-config.json");if(t)return t}catch{}return{bootstrapPeers:[]}}normalizeBootstrapPeers(e){if(!Array.isArray(e))return[];const t=window.location.hostname;if(!t||Txe(t))return e;const n=Cxe(t),i=e.flatMap(s=>{const o=Ixe(s,n);return o===s?[s]:[s,o]});return Array.from(new Set(i))}async ensureRelayConnection(e=!1){var a,c;if(!this.libp2p||this.bootstrapPeers.length===0||!this.networkManager)return;const t=((c=(a=this.libp2p).getConnections)==null?void 0:c.call(a))||[],n=Array.isArray(t)?t:typeof(t==null?void 0:t.values)=="function"?Array.from(t.values()).reduce((l,u)=>l.concat(u),[]):[],i=this.bootstrapPeers.map(NP).filter(Boolean),s=i.length>0?n.some(l=>{var u,h;return i.includes((h=(u=l==null?void 0:l.remotePeer)==null?void 0:u.toString)==null?void 0:h.call(u))}):n.length>0;if(s&&!this.relayConnected&&us("Relay connected",i.join(", ")||"unknown"),!s&&this.relayConnected&&us("Relay disconnected"),this.relayConnected=s,!e&&s)return;const o=Date.now();if(!(!e&&o-this.lastReconnectAttempt<Exe)){this.lastReconnectAttempt=o;try{await this.networkManager.redialBootstrapPeers()}catch(l){us("Relay redial failed",(l==null?void 0:l.message)||l)}}}startNetworkWatchdog(){this.reconnectTimer||!this.libp2p||(this.reconnectTimer=setInterval(()=>{this.ensureRelayConnection().catch(()=>{})},Sxe),this.connectionListenersBound||(this.connectionListenersBound=!0,this.libp2p.addEventListener("connection:close",()=>{this.ensureRelayConnection(!0).catch(()=>{})})))}stopNetworkWatchdog(){this.reconnectTimer&&(clearInterval(this.reconnectTimer),this.reconnectTimer=null)}async initMultiplayer(){var e,t,n;if(vE)try{const i=await this.loadRelayConfig();this.bootstrapPeers=this.normalizeBootstrapPeers(i.bootstrapPeers||[]),this.relayPeerIds=this.bootstrapPeers.map(NP).filter(Boolean),this.bootstrapPeers.length===0?us("No bootstrap peers; relay config missing"):us("Bootstrap peers",this.bootstrapPeers),this.node=new vE({bootstrapPeers:this.bootstrapPeers,enablePersistence:!1,gameId:"hyperborea",roomId:((e=this.currentRoom)==null?void 0:e.roomId)||"global"}),await this.node.initialize(),await this.node.start(),this.stateManager=this.node.getStateManager(),this.networkManager=this.node.getNetworkManager(),this.libp2p=((n=(t=this.networkManager)==null?void 0:t.getLibp2pNode)==null?void 0:n.call(t))||null,this.myPeerId=this.node.getStatus().network.peerId,us("Node started",this.myPeerId),this.libp2p&&!this.connectionLogBound&&(this.connectionLogBound=!0,this.libp2p.addEventListener("connection:open",s=>{var c,l,u,h,d,m;const o=((u=(l=(c=s.detail)==null?void 0:c.remotePeer)==null?void 0:l.toString)==null?void 0:u.call(l))||((m=(d=(h=s.detail)==null?void 0:h.remotePeer)==null?void 0:d.toString)==null?void 0:m.call(d));if(!o)return;this.relayPeerIds.includes(o)?(this.relayConnected=!0,us("Relay connected",o)):(us("Peer connected",o),this.broadcastTimeAnchor(!0))}),this.libp2p.addEventListener("connection:close",s=>{var c,l,u,h,d,m;const o=((u=(l=(c=s.detail)==null?void 0:c.remotePeer)==null?void 0:l.toString)==null?void 0:u.call(l))||((m=(d=(h=s.detail)==null?void 0:h.remotePeer)==null?void 0:d.toString)==null?void 0:m.call(d));if(!o)return;this.relayPeerIds.includes(o)?(this.relayConnected=!1,us("Relay disconnected",o)):us("Peer disconnected",o)})),this.stateManager.observeNamespace(this.gameNamespace,(s,o)=>{(o==="time"||o===og)&&this.applyRemoteTimeSync(s,o)}),this.configureNetworkScheduler(),this.startPeerCleanup(),this.setupVisibilityHeartbeat(),this.startNetworkWatchdog(),this.ensureRelayConnection(!0).catch(()=>{}),this.beforeUnloadHandler||(this.beforeUnloadHandler=()=>{var s,o;this.stopBackgroundHeartbeat(),this.stopPeerCleanup(),this.stopNetworkWatchdog(),this.savePersistedState(),this.visibilityHandler&&(document.removeEventListener("visibilitychange",this.visibilityHandler),this.visibilityHandler=null),(s=this.stateManager)==null||s.deleteScoped(this.gameNamespace,`player-${this.myPeerId}`),(o=this.stateManager)==null||o.deleteScoped(this.gameNamespace,`evt-${this.myPeerId}`)},window.addEventListener("beforeunload",this.beforeUnloadHandler)),this.publishPlayerState(),this.broadcastTimeAnchor(),document.hidden&&this.startBackgroundHeartbeat(),await this.initRoomDirectory()}catch(i){console.error("Multiplayer init failed",i)}}async initRoomDirectory(){if(this.bootstrapPeers.length){if(!this.roomDirectory){this.roomDirectory=new Nxe({gameId:"hyperborea",bootstrapPeers:this.bootstrapPeers});try{await this.roomDirectory.init()}catch(e){console.warn("Room directory init failed",e);return}}this.roomDirectory.announceRoom(this.currentRoom)}}setRoomStatus(e){const t=document.getElementById("room-status");t&&(t.textContent=e)}renderRoomList(){var n;const e=document.getElementById("room-list-items");if(!e)return;const t=((n=this.roomDirectory)==null?void 0:n.getRooms())||[];if(e.innerHTML="",!t.length){const i=document.createElement("p");i.textContent="No rooms announced yet.",e.appendChild(i);return}t.forEach(i=>{const s=document.createElement("div");s.className="room-entry";const o=document.createElement("h4");o.textContent=i.name||i.slug||"Unnamed room";const a=document.createElement("p");a.textContent=i.visibility==="private"?"Private room":"Public room";const c=document.createElement("button");c.textContent=i.visibility==="private"?"Join (password)":"Join",c.addEventListener("click",async()=>{const l=i.name||i.slug||"global",u=i.visibility==="private"?"private":"public";let h="";if(u==="private"){const g=document.getElementById("room-password");if(h=(g==null?void 0:g.value)||"",h||(h=window.prompt("Password for this room?")||""),!h){this.setRoomStatus("Password required for private rooms.");return}}const d=u==="private"?pv({name:Ug(l),visibility:u,password:h}):i.roomId||pv({name:Ug(l),visibility:u});await this.switchRoom({name:l,visibility:u,roomId:d});const m=document.getElementById("room-list");m&&(m.style.display="none");const p=document.getElementById("room-name"),b=document.getElementById("room-privacy");p&&(p.value=l),b&&(b.value=u);try{localStorage.setItem("hyperboreaRoomName",l),localStorage.setItem("hyperboreaRoomPrivacy",u)}catch{}}),s.appendChild(o),s.appendChild(a),s.appendChild(c),e.appendChild(s)})}async switchRoom({name:e,visibility:t,roomId:n}){var i;!n||n===this.currentRoom.roomId||(this.setRoomStatus("Switching rooms..."),await this.shutdownMultiplayer(),this.currentRoom={name:e,visibility:t,roomId:n},this.joinedAt=Date.now(),await this.initMultiplayer(),(i=this.roomDirectory)==null||i.announceRoom(this.currentRoom),this.setRoomStatus(`Current room: ${e} (${t})`))}async shutdownMultiplayer(){if(this.stopBackgroundHeartbeat(),this.stopPeerCleanup(),this.stopNetworkWatchdog(),this.schedulerConfigured=!1,this.snapshotProviderId=null,this.connectionLogBound=!1,this.connectionListenersBound=!1,this.relayConnected=!1,this.timeAnchor=null,this.attackEventsSeen.clear(),this.stateManager&&this.myPeerId&&(this.stateManager.deleteScoped(this.gameNamespace,`player-${this.myPeerId}`),this.stateManager.deleteScoped(this.gameNamespace,`evt-${this.myPeerId}`)),this.node)try{await this.node.stop()}catch(e){console.warn("Multiplayer shutdown error",e)}this.node=null,this.networkManager=null,this.stateManager=null,this.libp2p=null,this.myPeerId=null,this.clearPeers()}clearPeers(){for(const e of Array.from(this.peerMeshes.keys()))this.removePeer(e);this.peerMeshes.clear(),this.peers.clear()}configureNetworkScheduler(){if(!this.networkManager||this.schedulerConfigured)return;const e=j6();this.networkManager.configureScheduler({snapshotHz:e,keepaliveMs:xxe,snapshotsRequireAuthority:!1}),this.snapshotProviderId=this.networkManager.registerStateProvider(()=>this.buildLocalSnapshot(),{id:"player"}),this.networkManager.addSnapshotHandler((t,n)=>{this.handleNetworkSnapshot(t,n)}),this.networkManager.addEventHandler((t,n)=>{this.handleNetworkEvent(t,n)}),this.schedulerConfigured=!0}buildLocalSnapshot(){if(!this.myPeerId)return null;const e=this.stateScratch;return this.camera.getWorldPosition(e),{position:{x:e.x,y:e.y,z:e.z},rotation:{y:this.camera.rotation.y},color:this.myColor,name:this.playerName||null,torch:this.hasTorch,spear:{thrust:this.spearThrustProgress,visible:!0},ts:Date.now()}}handleNetworkSnapshot(e,t){var s;const n=((s=t==null?void 0:t.header)==null?void 0:s.peerId)||e;if(!n||n===this.myPeerId)return;(Array.isArray(t==null?void 0:t.payload)?t.payload:[]).forEach(o=>{!o||o.id!=="player"||!o.data||this.applyRemotePlayer(n,o.data)})}handleNetworkEvent(e,t){var s;const n=((s=t==null?void 0:t.header)==null?void 0:s.peerId)||e;if(!n||n===this.myPeerId)return;(Array.isArray(t==null?void 0:t.payload)?t.payload:[]).forEach(o=>{const a=o==null?void 0:o.payload;!a||a.type!=="attack"||this.handleRemoteAttack(n,a)})}regenerateTerrain(){this.currentSeed=Math.floor(Math.random()*1e6);for(const[t,n]of this.chunks)this.scene.remove(n.mesh),n.mesh.geometry&&n.mesh.geometry.dispose(),n.mesh.material&&n.mesh.material.dispose(),n.snowMesh&&(this.scene.remove(n.snowMesh),n.snowMesh.geometry&&n.snowMesh.geometry.dispose(),n.snowMesh.material&&n.snowMesh.material.dispose()),n.water&&(this.scene.remove(n.water),n.water.geometry&&n.water.geometry.dispose(),n.water.material&&n.water.material.dispose());this.chunks.clear();for(const[t,n]of this.structures)n.traverse(i=>{i.isMesh&&(i.geometry&&i.geometry.dispose(),i.material&&(Array.isArray(i.material)?i.material.forEach(s=>s.dispose()):i.material.dispose()))}),this.scene.remove(n);this.structures.clear(),this.collisionBoxes=[];const e=new $e;e.makeScale(0,0,0);for(let t=0;t<this.treeCountClose;t++)this.treeInstancedMeshClose.setMatrixAt(t,e);for(let t=0;t<this.treeCountMedium;t++)this.treeInstancedMeshMedium.setMatrixAt(t,e);this.treeInstancedMeshClose.instanceMatrix.needsUpdate=!0,this.treeInstancedMeshMedium.instanceMatrix.needsUpdate=!0,this.treeCountClose=0,this.treeCountMedium=0,this.treeInstancedMeshClose.count=0,this.treeInstancedMeshMedium.count=0,this.prevChunkX=null,this.prevChunkZ=null,this.terrainGen=new OP(this.currentSeed),this.generateInitialTerrain()}getChunkZone(e){return e<=1?{name:"close",terrainStep:16,treeLevel:"close"}:e<=3?{name:"medium",terrainStep:32,treeLevel:"medium"}:{name:"far",terrainStep:64,treeLevel:null}}initPlayer(){var a,c,l;const e=this.templePosition||{x:0,z:0},t=new se(0,1).normalize(),n=400;let i=e.x+t.x*n,s=e.z+t.y*n,o=this.terrainGen.getHeight(i,s);(a=this.persistedState)!=null&&a.pos&&(i=this.persistedState.pos.x,s=this.persistedState.pos.z,o=this.persistedState.pos.y),this.position=new k(i,o,s),this.velocity=new k(0,0,0),this.pitch=((c=this.persistedState)==null?void 0:c.pitch)??0,this.yaw=((l=this.persistedState)==null?void 0:l.yaw)??0,this.onGround=!1,this.rig&&this.rig.position.copy(this.position)}initPlayerEquipment(){const e=new On,t=new De(new Or(.04/3,.04/3,.5/3),new Pt({color:9127187}));t.position.y=-.5/3,e.add(t);const n=new De(new jr(.15/3,.4/3,6),new Ar({color:16737792}));n.position.y=.25/3,e.add(n),e.position.set(-.3,-.5,-.8),e.rotation.set(0,0,Math.PI/6),e.scale.setScalar(1/3),e.visible=!1,this.torch=e,this.torchLight=new Id(16737792,100,120,1.4),this.torchLight.position.set(0,0,0),this.torchLight.castShadow=!0,this.torchLight.shadow.mapSize.width=1024,this.torchLight.shadow.mapSize.height=1024,this.torchLight.shadow.bias=-5e-4,this.torchLight.shadow.radius=2,this.torchLight.shadow.camera.near=.1,this.torchLight.shadow.camera.far=120,this.torchLight.visible=!1,this.torch.add(this.torchLight);const i=new On,s=new De(new Or(.03,.03,1.2),new Pt({color:9136404}));s.position.y=-.6,i.add(s);const o=new De(new jr(.08,.25,4),new Pt({color:8947848}));o.position.y=.1,i.add(o),i.position.set(.6,-.7,-.5),i.rotation.set(-Math.PI/4,0,Math.PI/12),this.spear=i,this.attachWeaponsDesktop()}initSkyDome(){const e=new vs(64e3,32,32),t=new Ar({color:8900331,side:yr});this.skyDome=new De(e,t),this.scene.add(this.skyDome);const n=new Ye,i=[],s=[],o=[];for(let d=0;d<3e3;d++){const m=Math.random(),p=Math.random(),b=2*Math.PI*m,g=Math.acos(2*p-1),y=7950*8,v=y*Math.sin(g)*Math.cos(b),w=y*Math.sin(g)*Math.sin(b),_=y*Math.cos(g);i.push(v,w,_);const M=.3+Math.pow(Math.random(),2)*.7,E=1+Math.pow(Math.random(),1.5)*3;s.push(E),o.push(M)}n.setAttribute("position",new Ce(i,3)),n.setAttribute("size",new Ce(s,1)),n.setAttribute("brightness",new Ce(o,1)),this.stars=new XE(n,new Fr({uniforms:{color:{value:new ye(16777215)},opacity:{value:1}},vertexShader:`
                attribute float size;
                attribute float brightness;
                varying float vBrightness;
                void main() {
                    vBrightness = brightness;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = size;
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,fragmentShader:`
                uniform vec3 color;
                uniform float opacity;
                varying float vBrightness;
                void main() {
                    gl_FragColor = vec4(color * vBrightness, vBrightness * opacity);
                }
            `,transparent:!0,blending:oa})),this.stars.frustumCulled=!1,this.scene.add(this.stars);const a=new Pc(1600,1600),c=new Fr({transparent:!0,depthWrite:!1,depthTest:!1,blending:oa,uniforms:{time:{value:0},color:{value:new ye(12115967)}},vertexShader:`
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,fragmentShader:`
                uniform float time;
                uniform vec3 color;
                varying vec2 vUv;
                void main() {
                    // Centered UV
                    vec2 uv = vUv * 2.0 - 1.0;
                    float r = length(uv);
                    
                    // Pulsing halo
                    float pulse = 0.5 + 0.5 * sin(time * 2.0);
                    float halo = exp(-r * 6.0) * (0.6 + 0.4 * pulse);
                    
                    // Diffraction spikes
                    float angle = atan(uv.y, uv.x);
                    float spikes = pow(abs(cos(angle * 4.0)), 24.0) * (0.4 + 0.6 * pulse);
                    
                    // Core
                    float core = exp(-r * 20.0);
                    
                    float brightness = core + halo + spikes;
                    vec3 col = color * brightness;
                    
                    // Subtle ring/bubble
                    float ring = smoothstep(0.4, 0.32, r) * 0.35;
                    float bubble = smoothstep(0.9, 0.4, r) * 0.25;
                    
                    col += color * ring * (0.6 + 0.4 * pulse);
                    col += vec3(0.8) * bubble;
                    
                    float alpha = clamp(brightness + ring * 0.6 + bubble, 0.0, 1.0);
                    gl_FragColor = vec4(col, alpha);
                }
            `});this.northStar=new De(a,c),this.northStarRadius=7950*8-50,this.northStar.position.set(0,this.northStarRadius,0),this.northStar.renderOrder=999,this.skyDome.add(this.northStar),this.sun=new De(new vs(960,16,16),new Ar({color:16776960})),this.skyDome.add(this.sun),this.moon=new De(new vs(800,16,16),new Ar({color:16777215})),this.skyDome.add(this.moon);const l=new Or(5e3*8,5e3*8,4e3*8,256,64,!0),u=l.attributes.position.array;for(let d=0;d<u.length;d+=3){const m=u[d],p=u[d+1],b=u[d+2],g=Math.atan2(b,m),y=Math.sqrt(m*m+b*b),v=Math.sin(g*8+p*35e-5)*4e3,w=Math.sin(g*5.3+p*22e-5+1.1)*2500,_=Math.sin(g*-11.7+p*48e-5-.6)*1800,M=v+w+_,E=y+M;u[d]=Math.cos(g)*E,u[d+2]=Math.sin(g)*E}l.computeVertexNormals(),this.aurora=new De(l,new Fr({uniforms:{time:{value:0},opacity:{value:0}},vertexShader:`
                uniform float time;
                varying vec2 vUv;
                varying vec3 vPosition;
                void main() {
                    vUv = uv;
                    vec3 pos = position;
                    float angle = atan(pos.z, pos.x);
                    float radius = length(pos.xz);
                    float w1 = sin(angle * 8.0 + pos.y * 0.00035 + time * 0.6) * 3208.0;
                    float w2 = sin(angle * 5.3 + pos.y * 0.00022 + time * 0.5 + 1.1) * 2048.0;
                    float w3 = sin(angle * 11.7 + pos.y * 0.00048 + time * -0.3) * 666.0;
                    float yWave = sin(pos.y * 0.0008 + time * 0.7) * 200.0; // vertical traveling wave
                    pos.y += yWave;
                    float wave = w1 + w2 + w3;
                    float newR = radius + wave;
                    pos.x = cos(angle) * newR;
                    pos.z = sin(angle) * newR;
                    vPosition = pos;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,fragmentShader:`
                uniform float time;
                uniform float opacity;
                varying vec2 vUv;
                varying vec3 vPosition;
                
                // 3D noise function for seamless wrapping
                float noise3D(vec3 p) {
                    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);
                }
                
                float smoothNoise3D(vec3 p) {
                    vec3 i = floor(p);
                    vec3 f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);
                    
                    float a = noise3D(i);
                    float b = noise3D(i + vec3(1.0, 0.0, 0.0));
                    float c = noise3D(i + vec3(0.0, 1.0, 0.0));
                    float d = noise3D(i + vec3(1.0, 1.0, 0.0));
                    float e = noise3D(i + vec3(0.0, 0.0, 1.0));
                    float f1 = noise3D(i + vec3(1.0, 0.0, 1.0));
                    float g = noise3D(i + vec3(0.0, 1.0, 1.0));
                    float h = noise3D(i + vec3(1.0, 1.0, 1.0));
                    
                    float x1 = mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
                    float x2 = mix(mix(e, f1, f.x), mix(g, h, f.x), f.y);
                    
                    return mix(x1, x2, f.z);
                }
                
                void main() {
                    // Map cylinder to 3D space for seamless wrapping
                    // Use normalized position on cylinder surface
                    float angle = atan(vPosition.z, vPosition.x);
                    float radius = sqrt(vPosition.x * vPosition.x + vPosition.z * vPosition.z);
                    
                    // Create 3D coordinates that wrap seamlessly around cylinder
                    vec3 p = vec3(
                        cos(angle) * 2.0,  // X wraps seamlessly
                        vPosition.y * 0.00005,  // Y is height (smoothed after 8x scale)
                        sin(angle) * 2.0   // Z wraps seamlessly
                    );
                    
                    // Add time-based flow
                    vec3 flow = vec3(time * 0.08, time * 0.04, time * 0.06);
                    
                    // Sample 3D noise at different scales
                    float n1 = smoothNoise3D(p + flow);
                    float n2 = smoothNoise3D(p * 1.5 + flow * 0.8);
                    float n3 = smoothNoise3D(p * 3.0 + flow * 0.5);
                    
                    float waves = n1 * 0.55 + n2 * 0.3 + n3 * 0.15;
                    
                    // Vertical gradient - fade at top and bottom
                    float verticalFade = smoothstep(0.0, 0.1, vUv.y) * smoothstep(1.0, 0.9, vUv.y);
                    
                    // Fade out near horizon (bottom of cylinder)
                    float horizonFade = smoothstep(0.0, 0.25, vUv.y);
                    
                    // Aurora colors - green, blue, purple, pink
                    vec3 green = vec3(0.3, 1.0, 0.4);
                    vec3 blue = vec3(0.2, 0.6, 1.0);
                    vec3 purple = vec3(0.8, 0.3, 1.0);
                    vec3 pink = vec3(1.0, 0.4, 0.7);
                    
                    // Mix colors based on noise and position (wider transitions)
                    vec3 color = mix(green, blue, smoothstep(0.25, 0.55, waves));
                    color = mix(color, purple, smoothstep(0.45, 0.75, n2));
                    color = mix(color, pink, smoothstep(0.55, 0.85, n3));
                    
                    // Brightness variation
                    float brightness = waves * verticalFade * horizonFade * (0.5 + n3 * 0.5);
                    
                    gl_FragColor = vec4(color * brightness, brightness * opacity * 1.5);
                }
            `,transparent:!0,blending:oa,side:qi,depthWrite:!1}));const h=65*Math.PI/180;this.aurora.rotation.x=Math.PI/2-h,this.aurora.position.set(0,1500*8,0),this.scene.add(this.aurora),this.sunLight=new a1(16777215,1),this.sunLight.castShadow=!0,this.sunLight.shadow.camera.left=-4e3,this.sunLight.shadow.camera.right=4e3,this.sunLight.shadow.camera.top=4e3,this.sunLight.shadow.camera.bottom=-4e3,this.sunLight.shadow.camera.near=.5,this.sunLight.shadow.camera.far=12e3,this.sunLight.shadow.mapSize.width=4096,this.sunLight.shadow.mapSize.height=4096,this.sunLight.shadow.bias=-2e-4,this.scene.add(this.sunLight),this.scene.add(this.sunLight.target),this.ambient=new c1(4210752,.5),this.scene.add(this.ambient)}initControls(){window.addEventListener("keydown",e=>{this.keys[e.code]=!0,this.markStateDirty(),e.code==="KeyG"&&(this.godMode=!this.godMode),e.code==="KeyV"&&(this.wideFOV=!this.wideFOV,this.camera.fov=this.wideFOV?120:75,this.camera.updateProjectionMatrix()),e.code==="KeyF"&&(this.hasTorch=!this.hasTorch,this.torch.visible=this.hasTorch,this.torchLight.visible=this.hasTorch),e.code==="Equal"&&this.adjustTimeMultiplier(Math.min(this.timeSystem.timeMultiplier*2,128)),e.code==="Minus"&&this.adjustTimeMultiplier(Math.max(this.timeSystem.timeMultiplier/2,.25)),e.code==="KeyR"&&this.regenerateTerrain()}),window.addEventListener("keyup",e=>{this.keys[e.code]=!1,this.markStateDirty()}),this.canvas.addEventListener("click",()=>{!this.isInVR&&!this.isMobile&&this.canvas.requestPointerLock()}),document.addEventListener("pointerlockchange",()=>{this.pointerLocked=document.pointerLockElement===this.canvas}),document.addEventListener("mousemove",e=>{this.pointerLocked&&!this.isInVR&&(this.yaw-=e.movementX*.002,this.pitch=Math.max(-Math.PI/2,Math.min(Math.PI/2,this.pitch-e.movementY*.002)),this.markStateDirty())}),this.initVRControllers(),this.initAttackControls()}initSettingsUI(){const e=document.getElementById("settings-button"),t=document.getElementById("settings-menu"),n=document.getElementById("settings-close"),i=document.getElementById("player-name"),s=document.getElementById("player-color"),o=document.getElementById("player-save"),a=document.getElementById("room-name"),c=document.getElementById("room-privacy"),l=document.getElementById("room-password"),u=document.getElementById("room-create"),h=document.getElementById("room-join"),d=document.getElementById("room-list-open"),m=document.getElementById("room-list"),p=document.getElementById("room-list-close"),b=document.getElementById("room-list-refresh");if(e&&t&&e.addEventListener("click",()=>{const w=t.style.display!=="none";t.style.display=w?"none":"block",!w&&document.pointerLockElement&&document.exitPointerLock()}),n&&t&&n.addEventListener("click",()=>{t.style.display="none"}),i&&(i.value=this.playerName||""),s){const w=`#${Math.floor(this.myColor).toString(16).padStart(6,"0")}`;s.value=w}const g=localStorage.getItem("hyperboreaRoomName")||this.currentRoom.name,y=localStorage.getItem("hyperboreaRoomPrivacy")||this.currentRoom.visibility;a&&(a.value=g),c&&(c.value=y),this.setRoomStatus(`Current room: ${this.currentRoom.name} (${this.currentRoom.visibility})`),o&&o.addEventListener("click",()=>{var M;const w=((M=i==null?void 0:i.value)==null?void 0:M.trim())||"",_=(s==null?void 0:s.value)||"#00ffff";this.playerName=w,this.myColor=parseInt(_.replace("#","0x"),16);try{localStorage.setItem("hyperboreaPlayerName",this.playerName),localStorage.setItem("hyperboreaPlayerColor",_)}catch{}this.publishPlayerState(!0),t&&(t.style.display="none")});const v=async()=>{var I;const w=((I=a==null?void 0:a.value)==null?void 0:I.trim())||"global",_=(c==null?void 0:c.value)||"public",M=(l==null?void 0:l.value)||"";if(_==="private"&&!M){this.setRoomStatus("Password required for private rooms.");return}const E=Ug(w),C=pv({name:E,visibility:_,password:M});this.setRoomStatus("Switching rooms..."),await this.switchRoom({name:w,visibility:_,roomId:C});try{localStorage.setItem("hyperboreaRoomName",w),localStorage.setItem("hyperboreaRoomPrivacy",_)}catch{}};u&&u.addEventListener("click",()=>{v()}),h&&h.addEventListener("click",()=>{v()}),d&&m&&d.addEventListener("click",()=>{m.style.display="block",this.renderRoomList()}),p&&m&&p.addEventListener("click",()=>{m.style.display="none"}),b&&b.addEventListener("click",()=>{this.renderRoomList()})}initVRControllers(){this.controller0=this.renderer.xr.getController(0),this.controller0.addEventListener("connected",t=>{this.controller0.gamepad=t.data.gamepad}),this.playerBody.add(this.controller0),this.controller1=this.renderer.xr.getController(1),this.controller1.addEventListener("connected",t=>{this.controller1.gamepad=t.data.gamepad}),this.playerBody.add(this.controller1);const e=this.createControllerModel();this.controllerGrip0=this.renderer.xr.getControllerGrip(0),this.controllerGrip0.add(e.clone()),this.playerBody.add(this.controllerGrip0),this.controllerGrip1=this.renderer.xr.getControllerGrip(1),this.controllerGrip1.add(e.clone()),this.playerBody.add(this.controllerGrip1),this.isInVR=!1,this.renderer.xr.addEventListener("sessionstart",()=>{this.isInVR=!0,document.getElementById("ui").style.display="none",this.attachWeaponsVR(),this.ensureAboveGround(this.position,6),this.rig&&this.rig.position.copy(this.position),this.publishPlayerState()}),this.renderer.xr.addEventListener("sessionend",()=>{this.isInVR=!1,document.getElementById("ui").style.display="block",this.attachWeaponsDesktop()})}initAttackControls(){window.addEventListener("mousedown",t=>{t.button===0&&!this.isInVR&&this.triggerAttack()}),window.addEventListener("keydown",t=>{(t.code==="ControlLeft"||t.code==="ControlRight")&&this.triggerAttack()});const e=document.getElementById("attackButton");if(e){e.style.display=this.isMobile?"block":"none";const t=n=>{n.preventDefault(),this.triggerAttack()};e.addEventListener("touchstart",t),e.addEventListener("click",t)}}createControllerModel(){const e=new Ye;e.setAttribute("position",new Ce([0,0,0,0,0,-1],3));const t=new vr({color:16777215,linewidth:2});return new To(e,t)}getVRControllerInput(){var u,h,d,m;const e={moveX:0,moveY:0,turnX:0,turnY:0,jump:!1,torch:!1},t=p=>Math.abs(p)>.1?p:0,n=p=>!p||!p.axes?{x:0,y:0}:p.axes.length>=4?{x:t(p.axes[2]||0),y:t(p.axes[3]||0)}:{x:t(p.axes[0]||0),y:t(p.axes[1]||0)},i=p=>{if(!(p!=null&&p.buttons))return{trigger:!1};const b=p.buttons[0];return{trigger:!!(b&&b.pressed)}},s=(u=this.controller0)==null?void 0:u.gamepad,o=(h=this.controller1)==null?void 0:h.gamepad,a=n(s);e.moveX=a.x,e.moveY=a.y,i(s).trigger&&(e.jump=!0);const c=n(o);e.turnX=c.x,e.turnY=c.y,i(s).trigger&&(e.torch=!0);const l=(m=(d=this.renderer.xr).getSession)==null?void 0:m.call(d);if(l!=null&&l.inputSources)for(const p of l.inputSources){if(!p.gamepad)continue;const b=n(p.gamepad);p.handedness==="left"&&!s&&(e.moveX=b.x,e.moveY=b.y,i(p.gamepad).trigger&&(e.jump=!0)),p.handedness==="right"&&!o&&(e.turnX=b.x,e.turnY=b.y,i(p.gamepad).trigger&&(e.torch=!0))}return e}attachWeaponsDesktop(){var e;this.spear&&this.camera&&(this.camera.add(this.spear),this.spear.position.set(.6,-.5,-.6),this.spear.rotation.set(-Math.PI/4,0,Math.PI/16)),this.torch&&this.camera&&(this.camera.add(this.torch),this.torch.position.set(-.28,-.65,-.4),this.torch.rotation.set(-Math.PI/12,0,Math.PI/10),(e=this.torchLight)!=null&&e.shadow&&(this.torchLight.shadow.needsUpdate=!0))}attachWeaponsVR(){var e;this.spear&&this.controllerGrip1&&(this.controllerGrip1.add(this.spear),this.spear.position.set(0,-.15,-.05),this.spear.rotation.set(-Math.PI/2,0,0)),this.torch&&this.controllerGrip0&&(this.controllerGrip0.add(this.torch),this.torch.position.set(0,-.05,0),this.torch.rotation.set(-Math.PI/2,0,0),(e=this.torchLight)!=null&&e.shadow&&(this.torchLight.shadow.needsUpdate=!0))}initMobileControls(){const e=document.createElement("div");e.id="leftStick",e.style.cssText="position:absolute; bottom:80px; left:60px; width:120px; height:120px; background:rgba(255,255,255,0.2); border-radius:50%; border:2px solid rgba(255,255,255,0.5); pointer-events:auto; touch-action:none;";const t=document.createElement("div");t.id="leftKnob",t.style.cssText="position:absolute; top:45px; left:45px; width:30px; height:30px; background:rgba(255,255,255,0.6); border-radius:50%; pointer-events:none;",e.appendChild(t);const n=document.createElement("div");n.id="rightStick",n.style.cssText="position:absolute; bottom:80px; right:60px; width:120px; height:120px; background:rgba(255,255,255,0.2); border-radius:50%; border:2px solid rgba(255,255,255,0.5); pointer-events:auto; touch-action:none;";const i=document.createElement("div");i.id="rightKnob",i.style.cssText="position:absolute; top:45px; left:45px; width:30px; height:30px; background:rgba(255,255,255,0.6); border-radius:50%; pointer-events:none;",n.appendChild(i),document.body.appendChild(e),document.body.appendChild(n);const s=(a,c)=>l=>{l.preventDefault();const u=l.touches,h=a.getBoundingClientRect(),d=h.left+h.width/2,m=h.top+h.height/2;let p=null;for(let b=0;b<u.length;b++){const g=u[b],y=g.clientX-d,v=g.clientY-m;if(Math.sqrt(y*y+v*v)<80){p=g;break}}if(p){const b=p.clientX-d,g=p.clientY-m,y=Math.min(Math.sqrt(b*b+g*g),45),v=Math.atan2(g,b),w=a.children[0];w.style.left=45+Math.cos(v)*y+"px",w.style.top=45+Math.sin(v)*y+"px",c?(this.touchControls.moveX=y/45*Math.cos(v),this.touchControls.moveY=y/45*Math.sin(v)):(this.touchControls.lookX=y/45*Math.cos(v),this.touchControls.lookY=y/45*Math.sin(v))}else{const b=a.children[0];b.style.left="45px",b.style.top="45px",c?(this.touchControls.moveX=0,this.touchControls.moveY=0):(this.touchControls.lookX=0,this.touchControls.lookY=0)}this.markStateDirty()};e.addEventListener("touchstart",s(e,!0)),e.addEventListener("touchmove",s(e,!0)),e.addEventListener("touchend",s(e,!0)),n.addEventListener("touchstart",s(n,!1)),n.addEventListener("touchmove",s(n,!1)),n.addEventListener("touchend",s(n,!1));const o=document.createElement("button");o.textContent="",o.style.cssText="position:absolute; bottom:220px; left:80px; width:60px; height:60px; font-size:24px; background:rgba(255,255,255,0.3); border:2px solid rgba(255,255,255,0.5); border-radius:50%; color:white; pointer-events:auto; touch-action:none;",o.addEventListener("touchstart",a=>{a.preventDefault(),this.keys.Space=!0,this.markStateDirty()}),o.addEventListener("touchend",a=>{a.preventDefault(),this.keys.Space=!1,this.markStateDirty()}),document.body.appendChild(o),document.getElementById("controls").style.display="none"}generateInitialTerrain(){for(let e=-2;e<=2;e++)for(let t=-2;t<=2;t++)this.generateChunk(e,t);this.templePosition=this.findSummitLocation(),this.createTempleComplex(this.templePosition.x,this.templePosition.z),this.updateTerrainColors()}createTempleComplex(e,t){const n=this.terrainGen.getHeight(e,t),i="0,0",s=300,o=s*1.1,a=520,c=24;let l=n,u=n;for(let g=0;g<c;g++){const y=g/c*Math.PI*2,v=a*.98,w=e+Math.cos(y)*v,_=t+Math.sin(y)*v,M=this.terrainGen.getHeight(w,_);M>l&&(l=M),M<u&&(u=M)}const h=l+12,d=Math.max(140,h-u+120),m=new Pt({color:3092271}),p=new De(new Or(o,a,d,48,1,!1),m);p.position.set(e,h-d/2,t),p.castShadow=!0,p.receiveShadow=!0,this.scene.add(p),this.foundationInfo={centerX:e,centerZ:t,topRadius:o,bottomRadius:a,topY:h,height:d,lowestTerrain:u};const b=this.createGrandTempleWithPyramidRoof(e,h,t);this.scene.add(b.group),this.structures.set(`${i}-main`,b.group),this.createMainTempleBeam(b.apex.clone()),b.colliders.forEach(g=>{this.collisionBoxes.push({...g,chunkKey:i})});for(let g=0;g<16;g++){const y=g/16*Math.PI*2,v=s,w=e+Math.cos(y)*v,_=t+Math.sin(y)*v,M=h,E=this.createObelisk(w,M,_);this.scene.add(E),this.structures.set(`${i}-obelisk-${g}`,E),this.collisionBoxes.push({minX:w-4,maxX:w+4,minY:M-8,maxY:M+50,minZ:_-4,maxZ:_+4,chunkKey:i})}}getFoundationHeightAt(e,t){if(!this.foundationInfo)return null;const{centerX:n,centerZ:i,topRadius:s,bottomRadius:o,topY:a,height:c}=this.foundationInfo,l=e-n,u=t-i,h=Math.sqrt(l*l+u*u);if(h>o)return null;if(o===s)return a;const d=(h-s)/(o-s),m=a-d*c,p=a-c;return Math.max(Math.min(m,a),p)}createGrandTempleWithPyramidRoof(e,t,n){const i=new On,s=1.618,o=240,a=o*s,c=6,l=95,u=5,h=10,d=9,m=6,p=[],b=7,g=4,y=o*1.25,v=a*1.25,w=-g*2;let _=w;const M=.5*(c+l+d*m+h),E=new De(new Qt(y,M,v),new Pt({color:3092271}));E.position.y=w-M/2,E.receiveShadow=!0,i.add(E);for(let fe=0;fe<b;fe++){const W=fe/b,ue=y*(1-W*.35),re=v*(1-W*.35),le=new De(new Qt(ue,g,re),new Pt({color:4013373}));le.position.y=w+fe*g+g/2,le.castShadow=!0,le.receiveShadow=!0,i.add(le),_=le.position.y+g/2,p.push({minX:e-ue/2,maxX:e+ue/2,minY:t+le.position.y-g/2,maxY:t+le.position.y+g/2,minZ:n-re/2,maxZ:n+re/2})}const C=_+.2,I=new Pt({color:9079434}),x=[],T=o*.35,F=a*.35,$=18,H=18;for(let fe=-T;fe<=T;fe+=$)x.push([fe,-F]),x.push([fe,F]);for(let fe=-F+H;fe<=F-H;fe+=H)x.push([-T,fe]),x.push([T,fe]);for(const[fe,W]of x){const ue=new De(new Or(u,u,l,14),I);ue.position.set(fe,C+l/2,W),ue.castShadow=!0,ue.receiveShadow=!0,i.add(ue)}const S=o*.78,A=a*.78,P=new De(new Qt(S,h,A),new Pt({color:6974058}));P.position.y=C+l+h/2,P.castShadow=!0,P.receiveShadow=!0,i.add(P);const L=y*(1-(b-1)/b*.35),B=v*(1-(b-1)/b*.35);let D=L*.9,V=B*.9,z=P.position.y;for(let fe=0;fe<d;fe++){const W=.14+.02*fe,ue=D*(1-W),re=V*(1-W),le=new De(new Qt(ue,m,re),new Pt({color:7368816}));le.position.y=z+m/2,le.castShadow=!0,le.receiveShadow=!0,i.add(le),z=le.position.y+m/2,D=ue,V=re}const q=Math.max(D,V)*.3,G=new De(new Qt(q,m*.8,q),new Pt({color:7368816}));G.position.y=z+m*.4,G.castShadow=!0,G.receiveShadow=!0,i.add(G),z=G.position.y+m*.4;const Y=12,j=new De(new vs(Y,24,24),new Fr({uniforms:{time:{value:0},baseColor:{value:new ye(16766720)}},vertexShader:`
                    varying vec3 vNormal;
                    varying vec3 vWorldPos;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vec4 worldPos = modelMatrix * vec4(position, 1.0);
                        vWorldPos = worldPos.xyz;
                        gl_Position = projectionMatrix * viewMatrix * worldPos;
                    }
                `,fragmentShader:`
                    uniform float time;
                    uniform vec3 baseColor;
                    varying vec3 vNormal;
                    varying vec3 vWorldPos;
                    float hash(vec3 p) {
                        return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453);
                    }
                    void main() {
                        vec3 n = normalize(vNormal);
                        float ndotl = max(dot(n, normalize(vec3(0.2, 0.9, 0.4))), 0.0);
                        float spec = pow(ndotl, 24.0);
                        float sparkle = 0.0;
                        vec3 cell = floor(vWorldPos * 6.0 + time * 2.0);
                        float h = hash(cell);
                        sparkle += smoothstep(0.92, 1.0, h) * 1.2;
                        float flicker = 0.5 + 0.5 * sin(time * 5.0 + h * 20.0);
                        sparkle *= flicker;
                        vec3 color = baseColor * (0.6 + 0.8 * ndotl) + vec3(spec * 1.4) + vec3(sparkle);
                        gl_FragColor = vec4(color, 1.0);
                    }
                `,transparent:!1}));j.position.y=z+Y,j.castShadow=!0,j.receiveShadow=!0,i.add(j),this.globeMaterial=j.material;const X=new De(new Or(10,12,10,12),new Pt({color:4927259}));X.position.set(0,C+6,0),X.castShadow=!0,X.receiveShadow=!0,i.add(X);const ne=new De(new jr(8,18,10),new na({color:16747068,emissive:16734720,emissiveIntensity:1.6,transparent:!0,opacity:.9}));ne.position.set(0,C+15,0),ne.castShadow=!1,i.add(ne);const oe=new Id(16757082,2.4,220,2);oe.position.set(0,C+24,0),oe.castShadow=!0,oe.shadow.mapSize.width=1024,oe.shadow.mapSize.height=1024,i.add(oe);const he=j.position.y+Y,ce=new k(e,t+he,n);return i.position.set(e,t,n),{group:i,apex:ce,colliders:p,bounds:{minX:e-y*.55,maxX:e+y*.55,minY:t+w,maxY:t+he,minZ:n-v*.55,maxZ:n+v*.55}}}createLargePyramid(e,t,n,i){const s=new On,o=i*1.3,a=30,c=new De(new Qt(i*2.2,a,i*2.2),new Pt({color:3947580}));c.position.y=-a*.4,c.receiveShadow=!0,s.add(c);const l=new De(new jr(i,o,4),new Pt({color:7368816}));l.position.y=o/2,l.rotation.y=Math.PI/4,l.castShadow=!0,l.receiveShadow=!0,s.add(l);const u=8;for(let m=0;m<u;m++){const p=i*(1-m*.1),b=new De(new Qt(p*2,6,p*2),new Pt({color:6316128}));b.position.y=m*6+3,b.castShadow=!0,b.receiveShadow=!0,s.add(b)}const h=new De(new Qt(i*.4,8,i*.4),new Pt({color:5263440}));h.position.set(0,4,i),h.castShadow=!0,h.receiveShadow=!0,s.add(h);const d=new De(new vs(8,8,8),new Pt({color:16766720}));return d.position.y=o,d.castShadow=!0,s.add(d),s.position.set(e,t,n),s}createObelisk(e,t,n){const i=new On,s=40,o=18,a=new De(new Qt(12,o,12),new Pt({color:3947580}));a.position.y=-o*.4,a.receiveShadow=!0,i.add(a);const c=new De(new Qt(4,s,4),new Pt({color:7368816}));c.position.y=s/2,c.castShadow=!0,c.receiveShadow=!0,i.add(c);const l=new De(new jr(3,8,4),new Pt({color:8421504}));l.position.y=s+4,l.rotation.y=Math.PI/4,l.castShadow=!0,i.add(l);const u=new De(new Qt(8,4,8),new Pt({color:5263440}));return u.position.y=2,u.castShadow=!0,u.receiveShadow=!0,i.add(u),i.position.set(e,t,n),i}createPyramid(e,t,n){const i=new On,s=30+Math.random()*20,o=s*1.2,a=24,c=new De(new Qt(s*2.4,a,s*2.4),new Pt({color:3947580}));c.position.y=-a*.35,c.receiveShadow=!0,i.add(c);const l=new De(new jr(s,o,4),new Pt({color:7368816}));l.position.y=o/2,l.rotation.y=Math.PI/4,l.castShadow=!0,l.receiveShadow=!0,i.add(l);for(let u=0;u<5;u++){const h=s*(1-u*.15),d=new De(new Qt(h*2,5,h*2),new Pt({color:6316128}));d.position.y=u*5+2.5,d.castShadow=!0,d.receiveShadow=!0,i.add(d)}return i.position.set(e,t,n),i}generateChunk(e,t,n=0){const i=`${e},${t}`;if(this.chunks.has(i)){const P=this.chunks.get(i),L=this.getChunkZone(n).name;if(P.zoneName!==L)this.removeChunk(i,P);else{this.updateChunkLOD(i,n);return}}const s=this.getChunkZone(n),o=s.terrainStep,a=cn.CHUNK_SIZE,c=e*a,l=t*a,u=new Ye,h=[],d=[],m=[],p=[],b=Math.floor(a/o),g=[],y=3e3,v=y*.9,w=y*.8,_=y*.6,M=y*.15,E=y*.025;let C=-1/0;for(let P=0;P<=b;P++)for(let L=0;L<=b;L++){const B=c+L*o,D=l+P*o;let V=this.terrainGen.getHeight(B,D);const z=this.terrainGen.getMoisture(B,D);C=Math.max(C,V),h.push(B,V,D);const G=(Math.max(0,Math.min(1,(z+1)*.5))-.5)*.03*y,Y=v+G,j=w+G,X=_+G,ne=M+G,oe=E+G;let he="boreal";V<oe?he="water":V>=Y?he="peak":V>=j?he="summit":V>=X?he="alpine":V>=ne?he="boreal":he="beach",g.push({type:he,height:V,moisture:z}),d.push(1,1,1)}const I=(P,L)=>this.terrainGen.getHeight(P,L);for(let P=0;P<=b;P++)for(let L=0;L<=b;L++){const B=c+L*o,D=l+P*o,V=I(B-o,D),z=I(B+o,D),q=I(B,D-o),G=I(B,D+o),Y=V-z,j=2*o,X=q-G,ne=new k(Y,j,X).normalize();m.push(ne.x,ne.y,ne.z)}for(let P=0;P<b;P++)for(let L=0;L<b;L++){const B=L+P*(b+1),D=L+(P+1)*(b+1),V=L+1+P*(b+1),z=L+1+(P+1)*(b+1);p.push(B,D,V,D,z,V)}u.setAttribute("position",new Ce(h,3)),u.setAttribute("color",new Ce(d,3)),u.setAttribute("normal",new Ce(m,3)),u.setIndex(p);const x=new De(u,new na({vertexColors:!0,shininess:10,specular:2236962}));x.receiveShadow=!0,x.castShadow=!0,this.scene.add(x);let T=null;if(s.name==="close"){const P=u.clone();T=new De(P,new na({color:16777215,shininess:5,specular:2236962})),T.position.y=.2,T.receiveShadow=!0,T.castShadow=!0,T.visible=!1,this.scene.add(T)}const F=new na({color:2176845,transparent:!0,opacity:.01,depthWrite:!1,shininess:40,specular:2966341}),$=new De(new Pc(a,a),F);$.rotation.x=-Math.PI/2,$.position.set(c+a/2,300,l+a/2),this.scene.add($);const H={close:[],medium:[]},S=new $e;if(s.treeLevel){const P=Math.max(16,o*2);for(let L=0;L<a;L+=P)for(let B=0;B<a;B+=P){const D=c+B,V=l+L,z=this.terrainGen.getHeight(D,V),q=this.terrainGen.getMoisture(D,V);if(this.terrainGen.shouldPlaceTree(D,V,z,q)){const G=s.treeLevel,Y=G==="close"?this.treeInstancedMeshClose:this.treeInstancedMeshMedium,j=G==="close"?"treeCountClose":"treeCountMedium";if(this[j]<Y.instanceMatrix.count){const X=Math.sin(D*12.9898+V*78.233)*43758.5453,ne=8+Math.abs(X)%1*6,oe=1.5+Math.abs(X*7)%1*1;S.makeTranslation(D,z+ne*.65,V),S.scale(new k(oe,ne,oe)),Y.setMatrixAt(this[j],S),H[G].push(this[j]),this[j]++}}}this.treeInstancedMeshClose.instanceMatrix.needsUpdate=!0,this.treeInstancedMeshMedium.instanceMatrix.needsUpdate=!0,this.treeInstancedMeshClose.count=this.treeCountClose,this.treeInstancedMeshMedium.count=this.treeCountMedium}if(s.name==="close"){const P=c+a/2,L=l+a/2,B=this.terrainGen.getHeight(P,L);if(this.terrainGen.shouldPlaceStructure(P,L,B)){const D=this.createObelisk(P,B,L);this.collisionBoxes.push({minX:P-8,maxX:P+8,minY:B-8,maxY:B+55,minZ:L-8,maxZ:L+8,chunkKey:i}),this.scene.add(D),this.structures.set(i,D)}}const A={mesh:x,snowMesh:T,water:$,treeIndices:H,terrainTypes:g,gridSize:b,zoneName:s.name,maxHeight:C};this.chunks.set(i,A),this.applySeasonToChunk(A,this.getSeasonFactors())}hideTreeMatrices(e,t){if(!(e!=null&&e.length)||!t)return;const n=new $e;n.makeScale(0,0,0),e.forEach(i=>{t.setMatrixAt(i,n)}),t.instanceMatrix.needsUpdate=!0}recalcTreeCounts(){let e=-1,t=-1;for(const n of this.chunks.values())if(n.treeIndices){for(const i of n.treeIndices.close||[])i>e&&(e=i);for(const i of n.treeIndices.medium||[])i>t&&(t=i)}this.treeCountClose=Math.max(0,e+1),this.treeCountMedium=Math.max(0,t+1),this.treeInstancedMeshClose.count=this.treeCountClose,this.treeInstancedMeshMedium.count=this.treeCountMedium,this.treeInstancedMeshClose.instanceMatrix.needsUpdate=!0,this.treeInstancedMeshMedium.instanceMatrix.needsUpdate=!0}updateChunkLOD(e,t){const n=this.chunks.get(e);if(!n)return;const i=!0;n.mesh.receiveShadow!==i&&(n.mesh.receiveShadow=i,n.mesh.castShadow=i),n.snowMesh&&n.snowMesh.receiveShadow!==i&&(n.snowMesh.receiveShadow=i,n.snowMesh.castShadow=i)}updateStructureShadows(){let t=0;for(const[n,i]of this.structures){const o=i.position.distanceTo(this.position)<400;let a=!1;i.traverse(c=>{c.isMesh&&(c.castShadow!==o&&(c.castShadow=o,c.receiveShadow=o),c.castShadow&&(a=!0))}),a&&t++}this.structureShadowCount=t}getSeasonFactors(){const e=this.timeSystem.getYearProgress(),t=(a,c,l)=>{const u=Math.max(0,Math.min(1,(l-a)/(c-a)));return u*u*(3-2*u)};let n=0,i=0,s=0,o=0;if(e<.2)n=1;else if(e<.35){const a=t(.2,.35,e);n=1-a,i=a}else if(e<.45)i=1;else if(e<.55){const a=t(.45,.55,e);i=1-a,s=a}else if(e<.65)s=1;else if(e<.75){const a=t(.65,.75,e);s=1-a,o=a}else if(e<.85)o=1;else{const a=t(.85,.95,e);o=1-a,n=a}return{winterFactor:n,springFactor:i,summerFactor:s,fallFactor:o}}applySeasonToChunk(e,t){if(!(e!=null&&e.mesh))return;const{winterFactor:n,springFactor:i,summerFactor:s,fallFactor:o}=t,a={boreal:{winter:new ye(16119295),spring:new ye(5205820),summer:new ye(3363882),fall:new ye(14266687)},alpine:{winter:new ye(14937815),spring:new ye(8425311),summer:new ye(7306576),fall:new ye(9116186)},mountain:{winter:new ye(15330802),spring:new ye(13159634),summer:new ye(11843775),fall:new ye(12633290)}},c=e.mesh.geometry.getAttribute("color"),l=c.array,u=e.terrainTypes;for(let h=0;h<u.length;h++){const d=u[h],m=new ye;if(d.type==="water")m.setHex(2831681);else if(d.type==="peak")m.setHex(16120063);else if(d.type==="summit")m.setHex(4936283);else if(d.type==="alpine"){const p=a.alpine;m.r=p.winter.r*n+p.spring.r*i+p.summer.r*s+p.fall.r*o,m.g=p.winter.g*n+p.spring.g*i+p.summer.g*s+p.fall.g*o,m.b=p.winter.b*n+p.spring.b*i+p.summer.b*s+p.fall.b*o}else if(d.type==="mountain"){const p=a.mountain;m.r=p.winter.r*n+p.spring.r*i+p.summer.r*s+p.fall.r*o,m.g=p.winter.g*n+p.spring.g*i+p.summer.g*s+p.fall.g*o,m.b=p.winter.b*n+p.spring.b*i+p.summer.b*s+p.fall.b*o}else if(d.type==="boreal"){let p=a.boreal;m.r=p.winter.r*n+p.spring.r*i+p.summer.r*s+p.fall.r*o,m.g=p.winter.g*n+p.spring.g*i+p.summer.g*s+p.fall.g*o,m.b=p.winter.b*n+p.spring.b*i+p.summer.b*s+p.fall.b*o}else d.type==="beach"?m.setHex(4869975):m.setHex(4936283);e.zoneName!=="close"&&n>0&&m.lerp(new ye(16777215),n),l[h*3]=m.r,l[h*3+1]=m.g,l[h*3+2]=m.b}c.needsUpdate=!0}updateTerrainColors(){const e=this.getSeasonFactors();for(const t of this.chunks.values())this.applySeasonToChunk(t,e)}rebuildChunkQueue(e,t){const n=[];for(let i=-cn.RENDER_DISTANCE;i<=cn.RENDER_DISTANCE;i++)for(let s=-cn.RENDER_DISTANCE;s<=cn.RENDER_DISTANCE;s++){const o=Math.max(Math.abs(i),Math.abs(s)),a=e+i,c=t+s,l=`${a},${c}`;if(this.chunks.has(l)){this.updateChunkLOD(l,o);continue}n.push({key:l,cx:a,cz:c,dist:o})}n.sort((i,s)=>i.dist-s.dist),this.chunkQueue=n}processChunkQueue(){if(!this.chunkQueue.length)return;const e=performance.now();for(;this.chunkQueue.length&&!(performance.now()-e>this.chunkBuildBudgetMs);){const t=this.chunkQueue.shift();this.generateChunk(t.cx,t.cz,t.dist)}}updateChunks(){const e=Math.floor(this.position.x/cn.CHUNK_SIZE),t=Math.floor(this.position.z/cn.CHUNK_SIZE);if(!(e===this.prevChunkX&&t===this.prevChunkZ)){this.prevChunkX=e,this.prevChunkZ=t,this.rebuildChunkQueue(e,t);for(const[n,i]of this.chunks.entries()){const[s,o]=n.split(",").map(Number);Math.max(Math.abs(s-e),Math.abs(o-t))>cn.RENDER_DISTANCE+2&&this.removeChunk(n,i)}}}updateSnow(){const e=Date.now(),t=this.timeSystem.getSeason();if(t===this.lastSnowSeason&&e-this.lastSnowUpdate<1e3)return;this.lastSnowSeason=t,this.lastSnowUpdate=e;const n=t==="Winter",i=3e3*.8;for(const s of this.chunks.values())s.snowMesh&&(s.snowMesh.visible=n&&(s.maxHeight||0)>=i),s.water&&(s.water.material.color.setHex(n?13689087:1458270),s.water.material.opacity=n?.9:.99)}createMainTempleBeam(e){this.mainTempleApex=e.clone();const t=e.clone().add(new k(0,4e3,0)),n=this.buildMainBeamCurve(e,t),i=new Ar({color:16777215,transparent:!0,opacity:.95,blending:oa,depthWrite:!1,toneMapped:!1}),s=new Ar({color:16777215,transparent:!0,opacity:.3,blending:oa,depthWrite:!1,toneMapped:!1}),o=12,a=18,c=new De(new ha(n,64,o,28,!1),i),l=new De(new ha(n,64,a,20,!1),s),u=new On;u.add(l),u.add(c),u.visible=!1,u.renderOrder=999,this.scene.add(u),this.mainTempleBeam={group:u,core:c,glow:l,origin:e.clone(),lastTarget:null,lastUpdate:0,coreRadius:o,glowRadius:a}}buildMainBeamCurve(e,t){const n=t.clone().sub(e),i=n.length()||1,s=Math.min(Math.max(i*.18,3e3),16e3);n.normalize();const o=new k(0,1,0).cross(n);o.lengthSq()<1e-6&&o.set(1,0,0),o.normalize();const a=e.clone().add(new k(0,s*.35,0)).add(o.clone().multiplyScalar(400)),c=e.clone().add(n.clone().multiplyScalar(i*.55)).add(new k(0,s,0)).add(o.clone().multiplyScalar(-250)),l=[0,0,0,0,1,1,1,1],u=[new mt(e.x,e.y,e.z,1),new mt(a.x,a.y,a.z,.6),new mt(c.x,c.y,c.z,.8),new mt(t.x,t.y,t.z,1)];return yxe(r9,3,l,u)}refreshMainTempleBeam(e){if(!this.mainTempleBeam)return;const t=performance.now();if(this.mainTempleBeam.lastTarget||(this.mainTempleBeam.lastTarget=e.clone().addScalar(1e6)),this.mainTempleBeam.lastTarget.distanceToSquared(e)<4&&t-this.mainTempleBeam.lastUpdate<120)return;this.mainTempleBeam.lastTarget.copy(e),this.mainTempleBeam.lastUpdate=t;const n=this.buildMainBeamCurve(this.mainTempleBeam.origin,e),i=180,s=new ha(n,i,this.mainTempleBeam.coreRadius,32,!1),o=new ha(n,i,this.mainTempleBeam.glowRadius,24,!1);this.mainTempleBeam.core.geometry.dispose(),this.mainTempleBeam.glow.geometry.dispose(),this.mainTempleBeam.core.geometry=s,this.mainTempleBeam.glow.geometry=o}updateTempleBeams(e){if(!this.mainTempleBeam)return;const t=e>.2;if(this.mainTempleBeam.group.visible=t,t&&this.northStar){const n=new k;this.northStar.getWorldPosition(n),this.refreshMainTempleBeam(n)}}updateSky(){var B,D,V,z,q,G,Y,j;this.skyDome.position.copy(this.position),this.stars.position.copy(this.position),this.northStar&&this.northStar.position.copy(this.position),(D=(B=this.globeMaterial)==null?void 0:B.uniforms)!=null&&D.time&&(this.globeMaterial.uniforms.time.value=this.timeSystem.getTime()*.001);const t=this.timeSystem.getSunPosition()*Math.PI*2-Math.PI/2,n=4e3*8,i=65*Math.PI/180,s=Math.cos(t)*n,o=Math.sin(t)*n,a=Math.PI/2-i,c=o*Math.cos(a),l=-o*Math.sin(a);this.sun.position.set(s,c,l),this.moon.position.set(-s,-c,-l);const u=new k(s*.3,c*.3,l*.3);this.sunLight.position.copy(this.position).add(u),this.sunLight.target.position.copy(this.position),this.sunLight.target.updateMatrixWorld(),this.sunLight.shadow.camera.position.copy(this.sunLight.position),this.sunLight.shadow.camera.lookAt(this.position),this.sunLight.shadow.camera.updateProjectionMatrix(),this.sunLight.shadow.camera.updateMatrixWorld();const h=this.timeSystem.getMoonPhase();this.moon.scale.setScalar(.5+(.5-Math.abs(.5-h)));const d=Math.asin(c/n),m=-.2618,p=(X,ne,oe)=>{const he=Math.max(0,Math.min(1,(oe-X)/(ne-X)));return he*he*(3-2*he)},b=p(-.1,.3,d),g=p(m,.05,d),y=1-p(m,-.05,d),v=Math.max(0,Math.sin(Math.max(0,d)))*b,w=new ye;if(d<0){const X=p(m,0,d),ne=1,oe=.2+X*.8,he=X*X*.5;w.setRGB(ne,oe,he)}else if(d<.5){const X=p(0,.5,d),ne=1,oe=1,he=.5+X*.5;w.setRGB(ne,oe,he)}else w.setRGB(1,1,1);const _=new ye,M=new ye(.3,.45,.7),E=new ye(.28,.18,.35),C=new ye(.02,.02,.08);b>.01?_.lerpColors(E,M,b):_.lerpColors(C,E,g);const I=.15+y*.05+g*.2+b*.5,T=(.5-Math.abs(.5-h))*y*.6,F=Math.max(v,T),$=new ye(.7,.7,1),H=new ye;y>.5?H.copy($):H.lerpColors(w,$,y);const S=p(.2,.8,y);if(this.stars.material.uniforms.opacity.value=S,this.sun.visible=g>.01,this.moon.visible=y>.01||g>.01&&g<.99,this.stars.visible=!0,this.sun.material.color.copy(w),this.sunLight){this.sunLight.color.copy(H),this.sunLight.intensity=F;const X=b>.2;this.sunLight.castShadow!==X&&(this.sunLight.castShadow=X,this.sunLight.shadow&&(this.sunLight.shadow.needsUpdate=!0))}if(this.ambient&&(this.ambient.intensity=I),(z=(V=this.skyDome)==null?void 0:V.material)!=null&&z.color&&this.skyDome.material.color.copy(_),(q=this.scene.fog)!=null&&q.color&&this.scene.fog.color.copy(_),this.stars.rotation.set(0,0,0),this.stars.rotateX(a),this.stars.rotateY(t),this.northStar){const X=new k(0,this.northStarRadius,0);X.applyAxisAngle(new k(1,0,0),a),this.northStar.position.copy(X),this.northStar.lookAt(this.camera.position)}this.updateTempleBeams(y),this.aurora.position.x=this.position.x,this.aurora.position.z=this.position.z,this.aurora.material.uniforms.time.value=this.timeSystem.getTime()*.001,(j=(Y=(G=this.northStar)==null?void 0:G.material)==null?void 0:Y.uniforms)!=null&&j.time&&(this.northStar.material.uniforms.time.value=this.timeSystem.getTime()*.001);const L=this.timeSystem.getSeason()==="Winter"?y*.7:0;this.aurora.material.uniforms.opacity.value=L,this.aurora.visible=L>.01}updatePlayer(e){let t=null;if(this.isInVR&&(t=this.getVRControllerInput(),t.torch&&!this.vrTorchPressed?(this.hasTorch=!this.hasTorch,this.torch.visible=this.hasTorch,this.torchLight.visible=this.hasTorch,this.vrTorchPressed=!0,this.markStateDirty()):t.torch||(this.vrTorchPressed=!1)),this.isInVR&&t){const n=1.5*e;this.yaw-=t.turnX*n,Math.abs(t.turnX)>.01&&this.markStateDirty()}else if(this.isMobile&&(this.touchControls.lookX!==0||this.touchControls.lookY!==0)){const n=3*e;this.yaw-=this.touchControls.lookX*n,this.pitch=Math.max(-Math.PI/2,Math.min(Math.PI/2,this.pitch-this.touchControls.lookY*n)),this.markStateDirty()}if(this.godMode){const n=cn.PLAYER_SPEED*20,i=new k(-Math.sin(this.yaw),0,-Math.cos(this.yaw)),s=new k(Math.cos(this.yaw),0,-Math.sin(this.yaw)),o=new k;if(this.isInVR&&t){const a=i.clone(),c=s.clone();o.add(a.multiplyScalar(-t.moveY)),o.add(c.multiplyScalar(t.moveX)),t.jump&&(o.y+=1)}else if(this.isMobile&&(this.touchControls.moveX!==0||this.touchControls.moveY!==0)){const a=i.clone(),c=s.clone();o.add(a.multiplyScalar(-this.touchControls.moveY)),o.add(c.multiplyScalar(this.touchControls.moveX))}else this.keys.KeyW&&o.add(i),this.keys.KeyS&&o.sub(i),this.keys.KeyD&&o.add(s),this.keys.KeyA&&o.sub(s);this.keys.Space&&(o.y+=1),this.keys.ShiftLeft&&(o.y-=1),o.length()>0&&(o.normalize().multiplyScalar(n*e),this.position.add(o),this.markStateDirty())}else{const n=cn.PLAYER_SPEED*4;this.velocity.y+=cn.GRAVITY*e;const i=new k(-Math.sin(this.yaw),0,-Math.cos(this.yaw)),s=new k(Math.cos(this.yaw),0,-Math.sin(this.yaw));this.isInVR&&t?(this.velocity.x+=(-i.x*t.moveY+s.x*t.moveX)*n*e,this.velocity.z+=(-i.z*t.moveY+s.z*t.moveX)*n*e,t.jump&&this.onGround&&!this.vrJumpPressed?(this.velocity.y=cn.JUMP_FORCE,this.onGround=!1,this.vrJumpPressed=!0):t.jump||(this.vrJumpPressed=!1),(Math.abs(t.moveX)>.01||Math.abs(t.moveY)>.01||t.jump)&&this.markStateDirty()):this.isMobile&&(this.touchControls.moveX!==0||this.touchControls.moveY!==0)?(this.velocity.x+=(-i.x*this.touchControls.moveY+s.x*this.touchControls.moveX)*n*e,this.velocity.z+=(-i.z*this.touchControls.moveY+s.z*this.touchControls.moveX)*n*e,this.markStateDirty()):(this.keys.KeyW&&(this.velocity.x+=i.x*n*e,this.velocity.z+=i.z*n*e),this.keys.KeyS&&(this.velocity.x-=i.x*n*e,this.velocity.z-=i.z*n*e),this.keys.KeyD&&(this.velocity.x+=s.x*n*e,this.velocity.z+=s.z*n*e),this.keys.KeyA&&(this.velocity.x-=s.x*n*e,this.velocity.z-=s.z*n*e),(this.keys.KeyW||this.keys.KeyS||this.keys.KeyA||this.keys.KeyD||this.keys.Space||this.keys.ShiftLeft)&&this.markStateDirty()),this.velocity.x*=.85,this.velocity.z*=.85;const o=this.position.clone().add(this.velocity.clone().multiplyScalar(e));let a=-1/0;const c=1,l=3,u=5;for(const g of this.collisionBoxes)if(o.x+c>g.minX&&o.x-c<g.maxX&&o.z+c>g.minZ&&o.z-c<g.maxZ){const v=g.maxY-this.position.y;if(v>-u&&v<=u&&o.y+l>g.minY){a=Math.max(a,g.maxY);continue}if(this.position.y>=g.maxY-2&&o.y>=g.maxY-2)a=Math.max(a,g.maxY);else if(o.y+l>g.minY&&o.y<g.maxY){const w=(g.minX+g.maxX)/2,_=(g.minZ+g.maxZ)/2,M=o.x-w,E=o.z-_,C=Math.sqrt(M*M+E*E);if(C>0){const I=Math.max(Math.abs(g.maxX-g.minX),Math.abs(g.maxZ-g.minZ))/2+c;o.x=w+M/C*I,o.z=_+E/C*I}this.velocity.x=0,this.velocity.z=0;break}}this.position.copy(o),this.rig&&this.rig.position.copy(this.position);const h=this.terrainGen.getHeight(this.position.x,this.position.z),d=this.getFoundationHeightAt(this.position.x,this.position.z);let m=h;d!==null&&(m=Math.max(m,d)),a>h&&this.position.y<=a+l&&(m=a);const p=this.timeSystem.getSeason(),b=300;p==="Winter"&&h<b&&b>m&&(m=b),this.position.y<=m+l?(this.position.y=m+l,this.velocity.y=0,this.onGround=!0):this.onGround=!1,this.keys.Space&&this.onGround&&(this.velocity.y=cn.JUMP_FORCE,this.onGround=!1)}if(!this.isInVR&&this.rig&&this.rig.position.copy(this.position),this.isInVR?this.rig&&(this.rig.rotation.y=this.yaw):this.camera.rotation.set(this.pitch,this.yaw,0,"YXZ"),this.camera.updateMatrixWorld(),this.hasTorch){const n=2.5+Math.random()*.5;this.torchLight.intensity=n,this.torch.children[1].scale.y=.9+Math.random()*.2,this.torch.updateMatrixWorld(!0),this.torchLight.shadow&&(this.torchLight.shadow.needsUpdate=!0)}if(!this.isInVR&&this.spear){this.spearThrustProgress>0&&(this.spearThrustProgress=Math.max(0,this.spearThrustProgress-e*2.5));const n=Math.sin(this.spearThrustProgress*Math.PI);this.spear.position.z=-.8-n*.35,this.spear.rotation.x=-Math.PI/4+n*.2}}updateUI(){const e=this.hasTorch?" | TORCH ON":"",t=this.wideFOV?" | WIDE FOV":"";document.getElementById("timeInfo").textContent=`Day: ${this.timeSystem.getDayNumber()} | Season: ${this.timeSystem.getSeason()} (${this.timeSystem.timeMultiplier}x)${this.godMode?" | GOD":""}${e}${t}`,document.getElementById("posInfo").textContent=`X: ${Math.floor(this.position.x)} Y: ${Math.floor(this.position.y)} Z: ${Math.floor(this.position.z)}`,document.getElementById("fpsInfo").textContent=`FPS: ${Math.round(this.fps)}`;const n=this.treeCountClose+this.treeCountMedium;document.getElementById("tempInfo").textContent=`Temp: ${Math.floor(this.timeSystem.getTemperature())}C | Trees: ${n} | Seed: ${this.currentSeed} | Chunks: ${this.chunks.size} | Structures: ${this.structures.size} (${this.structureShadowCount} with shadows)`}animate(){var s;const e=Date.now(),t=Math.min((e-this.lastUpdate)/1e3,.1);this.lastUpdate=e,this.frameSamples++;const n=performance.now();n-this.lastFpsSample>=500&&(this.fps=this.frameSamples*1e3/(n-this.lastFpsSample),this.frameSamples=0,this.lastFpsSample=n);const i=document.hidden;!i&&e-this.lastColorUpdate>2e3&&(this.updateTerrainColors(),this.lastColorUpdate=e),!i&&e-this.lastShadowUpdate>500&&(this.updateStructureShadows(),this.lastShadowUpdate=e),i||(this.updatePlayer(t),this.updateChunks(),this.processChunkQueue(),this.updateSky(),this.updateSnow(),this.updateUI(),e-this.lastPersistSave>3e3&&(this.savePersistedState(),this.lastPersistSave=e));for(const[,o]of this.peerMeshes.entries()){const a=o.group||o,c=(s=a==null?void 0:a.userData)==null?void 0:s.targetPos;a&&c&&a.position.lerp(c,.15)}this.performSpearHitTest(this.isInVR),this.renderer.render(this.scene,this.camera)}startBackgroundHeartbeat(){this.backgroundHeartbeat||(this.backgroundHeartbeat=setInterval(()=>this.publishPlayerState(),wxe))}stopBackgroundHeartbeat(){this.backgroundHeartbeat&&(clearInterval(this.backgroundHeartbeat),this.backgroundHeartbeat=null)}setupVisibilityHeartbeat(){this.visibilityHandler||(this.visibilityHandler=()=>{document.hidden?this.startBackgroundHeartbeat():(this.stopBackgroundHeartbeat(),this.publishPlayerState(),this.ensureRelayConnection(!0).catch(()=>{}))},document.addEventListener("visibilitychange",this.visibilityHandler),document.hidden&&this.startBackgroundHeartbeat())}startPeerCleanup(){this.peerCleanupInterval||(this.peerCleanupInterval=setInterval(()=>this.pruneStalePeers(),vxe))}stopPeerCleanup(){this.peerCleanupInterval&&(clearInterval(this.peerCleanupInterval),this.peerCleanupInterval=null)}pruneStalePeers(){const e=Date.now()-_xe;for(const[t,n]of this.peers.entries())((n==null?void 0:n.lastSeen)||0)<e&&this.removePeer(t)}adjustTimeMultiplier(e){this.timeSystem.setTimeMultiplier(e),this.broadcastTimeAnchor(!0)}getAnchorRank(e){return e?typeof e.joinedAt=="number"?e.joinedAt:typeof e.sentAt=="number"?e.sentAt:null:null}shouldAdoptAnchor(e){var i;if(!e||!e.peerId)return!1;const t=this.getAnchorRank(e),n=this.getAnchorRank(this.timeAnchor);if(n===null)return!0;if(t===null)return!1;if(t<n)return!0;if(t===n){const s=((i=this.timeAnchor)==null?void 0:i.peerId)||"";return String(e.peerId)<String(s)}return!1}normalizeAnchor(e){return e?{...e,joinedAt:typeof e.joinedAt=="number"?e.joinedAt:typeof e.sentAt=="number"?e.sentAt:Date.now()}:null}broadcastTimeAnchor(e=!1){if(!this.stateManager||!this.myPeerId)return;const t=Date.now(),n=this.stateManager.readScoped?this.stateManager.readScoped(this.gameNamespace,og):null;if(n&&this.shouldAdoptAnchor(n)&&(this.timeAnchor=this.normalizeAnchor(n)),this.timeAnchor&&this.timeAnchor.peerId!==this.myPeerId||!e&&t-this.lastTimeSyncBroadcast<500)return;this.lastTimeSyncBroadcast=t;const i={multiplier:this.timeSystem.timeMultiplier,time:this.timeSystem.getTime(),sentAt:t,peerId:this.myPeerId,joinedAt:this.joinedAt};this.timeAnchor=this.normalizeAnchor(i),this.stateManager.writeScoped(this.gameNamespace,"time",i),this.stateManager.writeScoped(this.gameNamespace,og,i)}applyRemoteTimeSync(e,t){var i,s;if(!e||e.peerId===this.myPeerId)return;const n=this.normalizeAnchor(e);if(t===og){this.shouldAdoptAnchor(n)?(this.timeAnchor=n,this.timeSystem.applyRemoteSync(n)):((i=this.timeAnchor)==null?void 0:i.peerId)===this.myPeerId&&this.getAnchorRank(n)!==null&&this.getAnchorRank(this.timeAnchor)!==null&&this.getAnchorRank(n)>this.getAnchorRank(this.timeAnchor)&&this.broadcastTimeAnchor(!0);return}this.timeAnchor||(this.timeAnchor=n),!((s=this.timeAnchor)!=null&&s.peerId&&n.peerId!==this.timeAnchor.peerId)&&this.timeSystem.applyRemoteSync(n)}markStateDirty(){var e,t;this.stateDirty=!0,(t=(e=this.networkManager)==null?void 0:e.markStateDirty)==null||t.call(e)}maybeBroadcastState(e=!1){var t,n;this.myPeerId&&(e?this.markStateDirty():(this.stateDirty=!0,(n=(t=this.networkManager)==null?void 0:t.markStateDirty)==null||n.call(t)))}publishPlayerState(e=!1){this.maybeBroadcastState(e)}triggerAttack(){const e=performance.now();this.attackActiveUntil=e+350,this.spearThrustProgress=1,this.markStateDirty(),this.performSpearHitTest(!0)}performSpearHitTest(e=!1){const t=performance.now();if(!e&&t>this.attackActiveUntil&&!this.isInVR)return;const n=this.getSpearTip();if(!n)return;const i=new br,s=new Bn(n,1);for(const[o,a]of this.peerMeshes.entries()){const c=a.group||a;if(i.setFromObject(c),i.intersectsSphere(s)){this.registerHit(o);break}}}getSpearTip(){return this.spear?(this.spear.updateMatrixWorld(),new k(0,.8,0).applyMatrix4(this.spear.matrixWorld)):null}registerHit(e){var i,s;if(!this.myPeerId)return;const t=Date.now(),n={type:"attack",victimId:e,ts:t};(s=(i=this.networkManager)==null?void 0:i.queueEvent)==null||s.call(i,n,{reliable:!0}),this.handleRemoteAttack(this.myPeerId,n)}applyRemotePlayer(e,t){var s;if(!t){this.removePeer(e);return}if(!t.position||!t.rotation)return;let n=this.peerMeshes.get(e);(!n||!n.group)&&(n&&this.removePeer(e),n=this.createPeerRig(t.color||65535),this.scene.add(n.group),this.peerMeshes.set(e,n)),n.group.userData.targetPos.set(t.position.x,t.position.y,t.position.z),t.color&&n.body.material.color.setHex(t.color),n.group.rotation.y=((s=t.rotation)==null?void 0:s.y)||0,Object.prototype.hasOwnProperty.call(t,"torch")&&this.applyRemoteTorch(e,t.torch),t.spear&&this.applyRemoteSpear(e,t.spear);const i=typeof t.ts=="number"?t.ts:Date.now();this.peers.set(e,{lastSeen:i})}handleRemoteEvent(e,t){t&&t.type==="attack"&&this.handleRemoteAttack(e,t)}createPeerRig(e){const t=new On,n=new De(new Qt(4,6,4),new na({color:e}));n.castShadow=!0,n.receiveShadow=!0,t.add(n);const i=new On;i.position.set(-1.5,0,-1.5);const s=new De(new Or(.05,.05,1.2),new Pt({color:9127187}));s.position.y=-.6,i.add(s);const o=new Id(16737792,4,60,1.2);o.position.set(0,0,0),o.castShadow=!0,o.shadow.mapSize.width=1024,o.shadow.mapSize.height=1024,o.shadow.bias=-5e-4,o.shadow.radius=2,i.add(o),i.visible=!1,t.add(i);const a=new On,c=new De(new Or(.03,.03,1.2),new Pt({color:9136404}));c.position.y=-.6,a.add(c);const l=new De(new jr(.08,.25,4),new Pt({color:8947848}));return l.position.y=.1,a.add(l),a.position.set(1.6,-.2,-1),a.rotation.set(-Math.PI/4,0,Math.PI/16),t.add(a),t.userData.targetPos=new k,{group:t,body:n,torch:i,torchLight:o,spear:a}}applyRemoteTorch(e,t){const n=this.peerMeshes.get(e);!n||!n.torch||(n.torch.visible=!!t,n.torchLight&&(n.torchLight.visible=!!t))}applyRemoteSpear(e,t){const n=this.peerMeshes.get(e);if(!n)return;n.spear.visible=!!(t!=null&&t.visible);const i=(t==null?void 0:t.thrust)||0;n.spear.position.z=-1-Math.sin(i*Math.PI)*.3,n.spear.rotation.x=-Math.PI/4+Math.sin(i*Math.PI)*.15}removePeer(e){const t=this.peerMeshes.get(e);t&&this.scene.remove(t.group||t),this.peerMeshes.delete(e),this.peers.delete(e)}removeChunk(e,t){if(t.mesh&&(this.scene.remove(t.mesh),t.mesh.geometry&&t.mesh.geometry.dispose(),t.mesh.material&&t.mesh.material.dispose()),t.snowMesh&&(this.scene.remove(t.snowMesh),t.snowMesh.geometry&&t.snowMesh.geometry.dispose(),t.snowMesh.material&&t.snowMesh.material.dispose()),t.water&&(this.scene.remove(t.water),t.water.geometry&&t.water.geometry.dispose(),t.water.material&&t.water.material.dispose()),t.treeIndices&&(this.hideTreeMatrices(t.treeIndices.close,this.treeInstancedMeshClose),this.hideTreeMatrices(t.treeIndices.medium,this.treeInstancedMeshMedium)),this.structures.has(e)){const n=this.structures.get(e);n.traverse(i=>{var s;i.isMesh&&((s=i.geometry)==null||s.dispose(),i.material&&(Array.isArray(i.material)?i.material.forEach(o=>o.dispose()):i.material.dispose()))}),this.scene.remove(n),this.structures.delete(e),this.collisionBoxes=this.collisionBoxes.filter(i=>i.chunkKey!==e)}this.chunks.delete(e),this.recalcTreeCounts()}handleRemoteAttack(e,t){!t||this.attackEventsSeen.get(e)===t.ts||(this.attackEventsSeen.set(e,t.ts),t.victimId===this.myPeerId&&this.respawnPlayer())}respawnPlayer(){const e=Array.from(this.peerMeshes.values()).map(a=>{var l;const c=a.group||a;return((l=c.userData)==null?void 0:l.targetPos)||c.position}),t=e.length?e[Math.floor(Math.random()*e.length)]:new k(0,0,320),n=Math.random()*Math.PI*2,i=80,s=new k(t.x+Math.cos(n)*i,0,t.z+Math.sin(n)*i),o=this.terrainGen.getHeight(s.x,s.z);s.y=o+6,this.position.copy(s),this.rig&&this.rig.position.copy(this.position),this.velocity.set(0,0,0),this.onGround=!1,this.publishPlayerState()}}window.addEventListener("error",r=>{console.error("Global error:",r.message,r.filename,r.lineno,r.colno,r.error)});window.addEventListener("load",()=>{new Oxe});
