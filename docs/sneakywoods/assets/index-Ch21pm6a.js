var QU=Object.defineProperty;var fx=n=>{throw TypeError(n)};var eB=(n,e,t)=>e in n?QU(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var h=(n,e,t)=>eB(n,typeof e!="symbol"?e+"":e,t),dy=(n,e,t)=>e.has(n)||fx("Cannot "+t);var D=(n,e,t)=>(dy(n,e,"read from private field"),t?t.call(n):e.get(n)),me=(n,e,t)=>e.has(n)?fx("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),pe=(n,e,t,r)=>(dy(n,e,"write to private field"),r?r.call(n,t):e.set(n,t),t),ue=(n,e,t)=>(dy(n,e,"access private method"),t);var di=(n,e,t,r)=>({set _(i){pe(n,e,i,t)},get _(){return D(n,e,r)}});(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))r(i);new MutationObserver(i=>{for(const s of i)if(s.type==="childList")for(const o of s.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&r(o)}).observe(document,{childList:!0,subtree:!0});function t(i){const s={};return i.integrity&&(s.integrity=i.integrity),i.referrerPolicy&&(s.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?s.credentials="include":i.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function r(i){if(i.ep)return;i.ep=!0;const s=t(i);fetch(i.href,s)}})();/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Y_="160",tB=0,px=1,nB=2,RI=1,LI=2,As=3,Zo=0,Er=1,ns=2,Go=0,al=1,mx=2,gx=3,yx=4,rB=5,va=100,iB=101,sB=102,bx=103,wx=104,oB=200,aB=201,cB=202,lB=203,ov=204,av=205,uB=206,hB=207,dB=208,fB=209,pB=210,mB=211,gB=212,yB=213,bB=214,wB=0,vB=1,_B=2,tm=3,EB=4,SB=5,xB=6,TB=7,Z_=0,AB=1,MB=2,Wo=0,CB=1,IB=2,PB=3,DB=4,RB=5,LB=6,OI=300,Ql=301,eu=302,cv=303,lv=304,Eg=306,uv=1e3,Pi=1001,hv=1002,cr=1003,vx=1004,fy=1005,Kr=1006,OB=1007,td=1008,qo=1009,NB=1010,UB=1011,j_=1012,NI=1013,Uo=1014,Bo=1015,nd=1016,UI=1017,BI=1018,ka=1020,BB=1021,Di=1023,kB=1024,$B=1025,$a=1026,tu=1027,FB=1028,kI=1029,zB=1030,$I=1031,FI=1033,py=33776,my=33777,gy=33778,yy=33779,_x=35840,Ex=35841,Sx=35842,xx=35843,zI=36196,Tx=37492,Ax=37496,Mx=37808,Cx=37809,Ix=37810,Px=37811,Dx=37812,Rx=37813,Lx=37814,Ox=37815,Nx=37816,Ux=37817,Bx=37818,kx=37819,$x=37820,Fx=37821,by=36492,zx=36494,Vx=36495,VB=36283,Hx=36284,Gx=36285,Wx=36286,VI=3e3,Fa=3001,HB=3200,GB=3201,HI=0,WB=1,Yr="",_n="srgb",to="srgb-linear",J_="display-p3",Sg="display-p3-linear",nm="linear",Dt="srgb",rm="rec709",im="p3",bc=7680,qx=519,qB=512,KB=513,XB=514,GI=515,YB=516,ZB=517,jB=518,JB=519,dv=35044,Kx="300 es",fv=1035,ks=2e3,sm=2001;class Pu{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const r=this._listeners;r[e]===void 0&&(r[e]=[]),r[e].indexOf(t)===-1&&r[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const r=this._listeners;return r[e]!==void 0&&r[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const i=this._listeners[e];if(i!==void 0){const s=i.indexOf(t);s!==-1&&i.splice(s,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const r=this._listeners[e.type];if(r!==void 0){e.target=this;const i=r.slice(0);for(let s=0,o=i.length;s<o;s++)i[s].call(this,e);e.target=null}}}const Rn=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"],wy=Math.PI/180,om=180/Math.PI;function Ko(){const n=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,r=Math.random()*4294967295|0;return(Rn[n&255]+Rn[n>>8&255]+Rn[n>>16&255]+Rn[n>>24&255]+"-"+Rn[e&255]+Rn[e>>8&255]+"-"+Rn[e>>16&15|64]+Rn[e>>24&255]+"-"+Rn[t&63|128]+Rn[t>>8&255]+"-"+Rn[t>>16&255]+Rn[t>>24&255]+Rn[r&255]+Rn[r>>8&255]+Rn[r>>16&255]+Rn[r>>24&255]).toLowerCase()}function yr(n,e,t){return Math.max(e,Math.min(t,n))}function QB(n,e){return(n%e+e)%e}function vy(n,e,t){return(1-t)*n+t*e}function Xx(n){return(n&n-1)===0&&n!==0}function pv(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))}function Bs(n,e){switch(e.constructor){case Float32Array:return n;case Uint32Array:return n/4294967295;case Uint16Array:return n/65535;case Uint8Array:return n/255;case Int32Array:return Math.max(n/2147483647,-1);case Int16Array:return Math.max(n/32767,-1);case Int8Array:return Math.max(n/127,-1);default:throw new Error("Invalid component type.")}}function Et(n,e){switch(e.constructor){case Float32Array:return n;case Uint32Array:return Math.round(n*4294967295);case Uint16Array:return Math.round(n*65535);case Uint8Array:return Math.round(n*255);case Int32Array:return Math.round(n*2147483647);case Int16Array:return Math.round(n*32767);case Int8Array:return Math.round(n*127);default:throw new Error("Invalid component type.")}}class Ye{constructor(e=0,t=0){Ye.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,r=this.y,i=e.elements;return this.x=i[0]*t+i[3]*r+i[6],this.y=i[1]*t+i[4]*r+i[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const r=this.dot(e)/t;return Math.acos(yr(r,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,r=this.y-e.y;return t*t+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,r){return this.x=e.x+(t.x-e.x)*r,this.y=e.y+(t.y-e.y)*r,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const r=Math.cos(t),i=Math.sin(t),s=this.x-e.x,o=this.y-e.y;return this.x=s*r-o*i+e.x,this.y=s*i+o*r+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Je{constructor(e,t,r,i,s,o,a,c,l){Je.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],e!==void 0&&this.set(e,t,r,i,s,o,a,c,l)}set(e,t,r,i,s,o,a,c,l){const u=this.elements;return u[0]=e,u[1]=i,u[2]=a,u[3]=t,u[4]=s,u[5]=c,u[6]=r,u[7]=o,u[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,r=e.elements;return t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t[4]=r[4],t[5]=r[5],t[6]=r[6],t[7]=r[7],t[8]=r[8],this}extractBasis(e,t,r){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),r.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const r=e.elements,i=t.elements,s=this.elements,o=r[0],a=r[3],c=r[6],l=r[1],u=r[4],d=r[7],f=r[2],p=r[5],g=r[8],b=i[0],m=i[3],y=i[6],E=i[1],w=i[4],x=i[7],M=i[2],A=i[5],C=i[8];return s[0]=o*b+a*E+c*M,s[3]=o*m+a*w+c*A,s[6]=o*y+a*x+c*C,s[1]=l*b+u*E+d*M,s[4]=l*m+u*w+d*A,s[7]=l*y+u*x+d*C,s[2]=f*b+p*E+g*M,s[5]=f*m+p*w+g*A,s[8]=f*y+p*x+g*C,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],r=e[1],i=e[2],s=e[3],o=e[4],a=e[5],c=e[6],l=e[7],u=e[8];return t*o*u-t*a*l-r*s*u+r*a*c+i*s*l-i*o*c}invert(){const e=this.elements,t=e[0],r=e[1],i=e[2],s=e[3],o=e[4],a=e[5],c=e[6],l=e[7],u=e[8],d=u*o-a*l,f=a*c-u*s,p=l*s-o*c,g=t*d+r*f+i*p;if(g===0)return this.set(0,0,0,0,0,0,0,0,0);const b=1/g;return e[0]=d*b,e[1]=(i*l-u*r)*b,e[2]=(a*r-i*o)*b,e[3]=f*b,e[4]=(u*t-i*c)*b,e[5]=(i*s-a*t)*b,e[6]=p*b,e[7]=(r*c-l*t)*b,e[8]=(o*t-r*s)*b,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,r,i,s,o,a){const c=Math.cos(s),l=Math.sin(s);return this.set(r*c,r*l,-r*(c*o+l*a)+o+e,-i*l,i*c,-i*(-l*o+c*a)+a+t,0,0,1),this}scale(e,t){return this.premultiply(_y.makeScale(e,t)),this}rotate(e){return this.premultiply(_y.makeRotation(-e)),this}translate(e,t){return this.premultiply(_y.makeTranslation(e,t)),this}makeTranslation(e,t){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,t,0,0,1),this}makeRotation(e){const t=Math.cos(e),r=Math.sin(e);return this.set(t,-r,0,r,t,0,0,0,1),this}makeScale(e,t){return this.set(e,0,0,0,t,0,0,0,1),this}equals(e){const t=this.elements,r=e.elements;for(let i=0;i<9;i++)if(t[i]!==r[i])return!1;return!0}fromArray(e,t=0){for(let r=0;r<9;r++)this.elements[r]=e[r+t];return this}toArray(e=[],t=0){const r=this.elements;return e[t]=r[0],e[t+1]=r[1],e[t+2]=r[2],e[t+3]=r[3],e[t+4]=r[4],e[t+5]=r[5],e[t+6]=r[6],e[t+7]=r[7],e[t+8]=r[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const _y=new Je;function WI(n){for(let e=n.length-1;e>=0;--e)if(n[e]>=65535)return!0;return!1}function am(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}function e4(){const n=am("canvas");return n.style.display="block",n}const Yx={};function Uh(n){n in Yx||(Yx[n]=!0,console.warn(n))}const Zx=new Je().set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),jx=new Je().set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),gf={[to]:{transfer:nm,primaries:rm,toReference:n=>n,fromReference:n=>n},[_n]:{transfer:Dt,primaries:rm,toReference:n=>n.convertSRGBToLinear(),fromReference:n=>n.convertLinearToSRGB()},[Sg]:{transfer:nm,primaries:im,toReference:n=>n.applyMatrix3(jx),fromReference:n=>n.applyMatrix3(Zx)},[J_]:{transfer:Dt,primaries:im,toReference:n=>n.convertSRGBToLinear().applyMatrix3(jx),fromReference:n=>n.applyMatrix3(Zx).convertLinearToSRGB()}},t4=new Set([to,Sg]),bt={enabled:!0,_workingColorSpace:to,get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(n){if(!t4.has(n))throw new Error(`Unsupported working color space, "${n}".`);this._workingColorSpace=n},convert:function(n,e,t){if(this.enabled===!1||e===t||!e||!t)return n;const r=gf[e].toReference,i=gf[t].fromReference;return i(r(n))},fromWorkingColorSpace:function(n,e){return this.convert(n,this._workingColorSpace,e)},toWorkingColorSpace:function(n,e){return this.convert(n,e,this._workingColorSpace)},getPrimaries:function(n){return gf[n].primaries},getTransfer:function(n){return n===Yr?nm:gf[n].transfer}};function cl(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}function Ey(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}let wc;class qI{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{wc===void 0&&(wc=am("canvas")),wc.width=e.width,wc.height=e.height;const r=wc.getContext("2d");e instanceof ImageData?r.putImageData(e,0,0):r.drawImage(e,0,0,e.width,e.height),t=wc}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const t=am("canvas");t.width=e.width,t.height=e.height;const r=t.getContext("2d");r.drawImage(e,0,0,e.width,e.height);const i=r.getImageData(0,0,e.width,e.height),s=i.data;for(let o=0;o<s.length;o++)s[o]=cl(s[o]/255)*255;return r.putImageData(i,0,0),t}else if(e.data){const t=e.data.slice(0);for(let r=0;r<t.length;r++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[r]=Math.floor(cl(t[r]/255)*255):t[r]=cl(t[r]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}let n4=0;class KI{constructor(e=null){this.isSource=!0,Object.defineProperty(this,"id",{value:n4++}),this.uuid=Ko(),this.data=e,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const r={uuid:this.uuid,url:""},i=this.data;if(i!==null){let s;if(Array.isArray(i)){s=[];for(let o=0,a=i.length;o<a;o++)i[o].isDataTexture?s.push(Sy(i[o].image)):s.push(Sy(i[o]))}else s=Sy(i);r.url=s}return t||(e.images[this.uuid]=r),r}}function Sy(n){return typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&n instanceof ImageBitmap?qI.getDataURL(n):n.data?{data:Array.from(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let r4=0;class Sr extends Pu{constructor(e=Sr.DEFAULT_IMAGE,t=Sr.DEFAULT_MAPPING,r=Pi,i=Pi,s=Kr,o=td,a=Di,c=qo,l=Sr.DEFAULT_ANISOTROPY,u=Yr){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:r4++}),this.uuid=Ko(),this.name="",this.source=new KI(e),this.mipmaps=[],this.mapping=t,this.channel=0,this.wrapS=r,this.wrapT=i,this.magFilter=s,this.minFilter=o,this.anisotropy=l,this.format=a,this.internalFormat=null,this.type=c,this.offset=new Ye(0,0),this.repeat=new Ye(1,1),this.center=new Ye(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Je,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,typeof u=="string"?this.colorSpace=u:(Uh("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=u===Fa?_n:Yr),this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.channel=e.channel,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.colorSpace=e.colorSpace,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const r={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(r.userData=this.userData),t||(e.textures[this.uuid]=r),r}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==OI)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case uv:e.x=e.x-Math.floor(e.x);break;case Pi:e.x=e.x<0?0:1;break;case hv:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case uv:e.y=e.y-Math.floor(e.y);break;case Pi:e.y=e.y<0?0:1;break;case hv:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}get encoding(){return Uh("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace===_n?Fa:VI}set encoding(e){Uh("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=e===Fa?_n:Yr}}Sr.DEFAULT_IMAGE=null;Sr.DEFAULT_MAPPING=OI;Sr.DEFAULT_ANISOTROPY=1;class mn{constructor(e=0,t=0,r=0,i=1){mn.prototype.isVector4=!0,this.x=e,this.y=t,this.z=r,this.w=i}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,r,i){return this.x=e,this.y=t,this.z=r,this.w=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,r=this.y,i=this.z,s=this.w,o=e.elements;return this.x=o[0]*t+o[4]*r+o[8]*i+o[12]*s,this.y=o[1]*t+o[5]*r+o[9]*i+o[13]*s,this.z=o[2]*t+o[6]*r+o[10]*i+o[14]*s,this.w=o[3]*t+o[7]*r+o[11]*i+o[15]*s,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,r,i,s;const c=e.elements,l=c[0],u=c[4],d=c[8],f=c[1],p=c[5],g=c[9],b=c[2],m=c[6],y=c[10];if(Math.abs(u-f)<.01&&Math.abs(d-b)<.01&&Math.abs(g-m)<.01){if(Math.abs(u+f)<.1&&Math.abs(d+b)<.1&&Math.abs(g+m)<.1&&Math.abs(l+p+y-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const w=(l+1)/2,x=(p+1)/2,M=(y+1)/2,A=(u+f)/4,C=(d+b)/4,R=(g+m)/4;return w>x&&w>M?w<.01?(r=0,i=.707106781,s=.707106781):(r=Math.sqrt(w),i=A/r,s=C/r):x>M?x<.01?(r=.707106781,i=0,s=.707106781):(i=Math.sqrt(x),r=A/i,s=R/i):M<.01?(r=.707106781,i=.707106781,s=0):(s=Math.sqrt(M),r=C/s,i=R/s),this.set(r,i,s,t),this}let E=Math.sqrt((m-g)*(m-g)+(d-b)*(d-b)+(f-u)*(f-u));return Math.abs(E)<.001&&(E=1),this.x=(m-g)/E,this.y=(d-b)/E,this.z=(f-u)/E,this.w=Math.acos((l+p+y-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,r){return this.x=e.x+(t.x-e.x)*r,this.y=e.y+(t.y-e.y)*r,this.z=e.z+(t.z-e.z)*r,this.w=e.w+(t.w-e.w)*r,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class i4 extends Pu{constructor(e=1,t=1,r={}){super(),this.isRenderTarget=!0,this.width=e,this.height=t,this.depth=1,this.scissor=new mn(0,0,e,t),this.scissorTest=!1,this.viewport=new mn(0,0,e,t);const i={width:e,height:t,depth:1};r.encoding!==void 0&&(Uh("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."),r.colorSpace=r.encoding===Fa?_n:Yr),r=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:Kr,depthBuffer:!0,stencilBuffer:!1,depthTexture:null,samples:0},r),this.texture=new Sr(i,r.mapping,r.wrapS,r.wrapT,r.magFilter,r.minFilter,r.format,r.type,r.anisotropy,r.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=r.generateMipmaps,this.texture.internalFormat=r.internalFormat,this.depthBuffer=r.depthBuffer,this.stencilBuffer=r.stencilBuffer,this.depthTexture=r.depthTexture,this.samples=r.samples}setSize(e,t,r=1){(this.width!==e||this.height!==t||this.depth!==r)&&(this.width=e,this.height=t,this.depth=r,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=r,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.isRenderTargetTexture=!0;const t=Object.assign({},e.texture.image);return this.texture.source=new KI(t),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class Wa extends i4{constructor(e=1,t=1,r={}){super(e,t,r),this.isWebGLRenderTarget=!0}}class XI extends Sr{constructor(e=null,t=1,r=1,i=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:r,depth:i},this.magFilter=cr,this.minFilter=cr,this.wrapR=Pi,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class s4 extends Sr{constructor(e=null,t=1,r=1,i=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:r,depth:i},this.magFilter=cr,this.minFilter=cr,this.wrapR=Pi,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Xd{constructor(e=0,t=0,r=0,i=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=r,this._w=i}static slerpFlat(e,t,r,i,s,o,a){let c=r[i+0],l=r[i+1],u=r[i+2],d=r[i+3];const f=s[o+0],p=s[o+1],g=s[o+2],b=s[o+3];if(a===0){e[t+0]=c,e[t+1]=l,e[t+2]=u,e[t+3]=d;return}if(a===1){e[t+0]=f,e[t+1]=p,e[t+2]=g,e[t+3]=b;return}if(d!==b||c!==f||l!==p||u!==g){let m=1-a;const y=c*f+l*p+u*g+d*b,E=y>=0?1:-1,w=1-y*y;if(w>Number.EPSILON){const M=Math.sqrt(w),A=Math.atan2(M,y*E);m=Math.sin(m*A)/M,a=Math.sin(a*A)/M}const x=a*E;if(c=c*m+f*x,l=l*m+p*x,u=u*m+g*x,d=d*m+b*x,m===1-a){const M=1/Math.sqrt(c*c+l*l+u*u+d*d);c*=M,l*=M,u*=M,d*=M}}e[t]=c,e[t+1]=l,e[t+2]=u,e[t+3]=d}static multiplyQuaternionsFlat(e,t,r,i,s,o){const a=r[i],c=r[i+1],l=r[i+2],u=r[i+3],d=s[o],f=s[o+1],p=s[o+2],g=s[o+3];return e[t]=a*g+u*d+c*p-l*f,e[t+1]=c*g+u*f+l*d-a*p,e[t+2]=l*g+u*p+a*f-c*d,e[t+3]=u*g-a*d-c*f-l*p,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,r,i){return this._x=e,this._y=t,this._z=r,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t=!0){const r=e._x,i=e._y,s=e._z,o=e._order,a=Math.cos,c=Math.sin,l=a(r/2),u=a(i/2),d=a(s/2),f=c(r/2),p=c(i/2),g=c(s/2);switch(o){case"XYZ":this._x=f*u*d+l*p*g,this._y=l*p*d-f*u*g,this._z=l*u*g+f*p*d,this._w=l*u*d-f*p*g;break;case"YXZ":this._x=f*u*d+l*p*g,this._y=l*p*d-f*u*g,this._z=l*u*g-f*p*d,this._w=l*u*d+f*p*g;break;case"ZXY":this._x=f*u*d-l*p*g,this._y=l*p*d+f*u*g,this._z=l*u*g+f*p*d,this._w=l*u*d-f*p*g;break;case"ZYX":this._x=f*u*d-l*p*g,this._y=l*p*d+f*u*g,this._z=l*u*g-f*p*d,this._w=l*u*d+f*p*g;break;case"YZX":this._x=f*u*d+l*p*g,this._y=l*p*d+f*u*g,this._z=l*u*g-f*p*d,this._w=l*u*d-f*p*g;break;case"XZY":this._x=f*u*d-l*p*g,this._y=l*p*d-f*u*g,this._z=l*u*g+f*p*d,this._w=l*u*d+f*p*g;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t===!0&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const r=t/2,i=Math.sin(r);return this._x=e.x*i,this._y=e.y*i,this._z=e.z*i,this._w=Math.cos(r),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,r=t[0],i=t[4],s=t[8],o=t[1],a=t[5],c=t[9],l=t[2],u=t[6],d=t[10],f=r+a+d;if(f>0){const p=.5/Math.sqrt(f+1);this._w=.25/p,this._x=(u-c)*p,this._y=(s-l)*p,this._z=(o-i)*p}else if(r>a&&r>d){const p=2*Math.sqrt(1+r-a-d);this._w=(u-c)/p,this._x=.25*p,this._y=(i+o)/p,this._z=(s+l)/p}else if(a>d){const p=2*Math.sqrt(1+a-r-d);this._w=(s-l)/p,this._x=(i+o)/p,this._y=.25*p,this._z=(c+u)/p}else{const p=2*Math.sqrt(1+d-r-a);this._w=(o-i)/p,this._x=(s+l)/p,this._y=(c+u)/p,this._z=.25*p}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let r=e.dot(t)+1;return r<Number.EPSILON?(r=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=r):(this._x=0,this._y=-e.z,this._z=e.y,this._w=r)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=r),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(yr(this.dot(e),-1,1)))}rotateTowards(e,t){const r=this.angleTo(e);if(r===0)return this;const i=Math.min(1,t/r);return this.slerp(e,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const r=e._x,i=e._y,s=e._z,o=e._w,a=t._x,c=t._y,l=t._z,u=t._w;return this._x=r*u+o*a+i*l-s*c,this._y=i*u+o*c+s*a-r*l,this._z=s*u+o*l+r*c-i*a,this._w=o*u-r*a-i*c-s*l,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const r=this._x,i=this._y,s=this._z,o=this._w;let a=o*e._w+r*e._x+i*e._y+s*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=o,this._x=r,this._y=i,this._z=s,this;const c=1-a*a;if(c<=Number.EPSILON){const p=1-t;return this._w=p*o+t*this._w,this._x=p*r+t*this._x,this._y=p*i+t*this._y,this._z=p*s+t*this._z,this.normalize(),this}const l=Math.sqrt(c),u=Math.atan2(l,a),d=Math.sin((1-t)*u)/l,f=Math.sin(t*u)/l;return this._w=o*d+this._w*f,this._x=r*d+this._x*f,this._y=i*d+this._y*f,this._z=s*d+this._z*f,this._onChangeCallback(),this}slerpQuaternions(e,t,r){return this.copy(e).slerp(t,r)}random(){const e=Math.random(),t=Math.sqrt(1-e),r=Math.sqrt(e),i=2*Math.PI*Math.random(),s=2*Math.PI*Math.random();return this.set(t*Math.cos(i),r*Math.sin(s),r*Math.cos(s),t*Math.sin(i))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class q{constructor(e=0,t=0,r=0){q.prototype.isVector3=!0,this.x=e,this.y=t,this.z=r}set(e,t,r){return r===void 0&&(r=this.z),this.x=e,this.y=t,this.z=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(Jx.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(Jx.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,r=this.y,i=this.z,s=e.elements;return this.x=s[0]*t+s[3]*r+s[6]*i,this.y=s[1]*t+s[4]*r+s[7]*i,this.z=s[2]*t+s[5]*r+s[8]*i,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,r=this.y,i=this.z,s=e.elements,o=1/(s[3]*t+s[7]*r+s[11]*i+s[15]);return this.x=(s[0]*t+s[4]*r+s[8]*i+s[12])*o,this.y=(s[1]*t+s[5]*r+s[9]*i+s[13])*o,this.z=(s[2]*t+s[6]*r+s[10]*i+s[14])*o,this}applyQuaternion(e){const t=this.x,r=this.y,i=this.z,s=e.x,o=e.y,a=e.z,c=e.w,l=2*(o*i-a*r),u=2*(a*t-s*i),d=2*(s*r-o*t);return this.x=t+c*l+o*d-a*u,this.y=r+c*u+a*l-s*d,this.z=i+c*d+s*u-o*l,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,r=this.y,i=this.z,s=e.elements;return this.x=s[0]*t+s[4]*r+s[8]*i,this.y=s[1]*t+s[5]*r+s[9]*i,this.z=s[2]*t+s[6]*r+s[10]*i,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,r){return this.x=e.x+(t.x-e.x)*r,this.y=e.y+(t.y-e.y)*r,this.z=e.z+(t.z-e.z)*r,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const r=e.x,i=e.y,s=e.z,o=t.x,a=t.y,c=t.z;return this.x=i*c-s*a,this.y=s*o-r*c,this.z=r*a-i*o,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const r=e.dot(this)/t;return this.copy(e).multiplyScalar(r)}projectOnPlane(e){return xy.copy(this).projectOnVector(e),this.sub(xy)}reflect(e){return this.sub(xy.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const r=this.dot(e)/t;return Math.acos(yr(r,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,r=this.y-e.y,i=this.z-e.z;return t*t+r*r+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,r){const i=Math.sin(t)*e;return this.x=i*Math.sin(r),this.y=Math.cos(t)*e,this.z=i*Math.cos(r),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,r){return this.x=e*Math.sin(t),this.y=r,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),r=this.setFromMatrixColumn(e,1).length(),i=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=r,this.z=i,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=(Math.random()-.5)*2,t=Math.random()*Math.PI*2,r=Math.sqrt(1-e**2);return this.x=r*Math.cos(t),this.y=r*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const xy=new q,Jx=new Xd;class Fi{constructor(e=new q(1/0,1/0,1/0),t=new q(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){this.makeEmpty();for(let t=0,r=e.length;t<r;t+=3)this.expandByPoint(fi.fromArray(e,t));return this}setFromBufferAttribute(e){this.makeEmpty();for(let t=0,r=e.count;t<r;t++)this.expandByPoint(fi.fromBufferAttribute(e,t));return this}setFromPoints(e){this.makeEmpty();for(let t=0,r=e.length;t<r;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const r=fi.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(r),this.max.copy(e).add(r),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const r=e.geometry;if(r!==void 0){const s=r.getAttribute("position");if(t===!0&&s!==void 0&&e.isInstancedMesh!==!0)for(let o=0,a=s.count;o<a;o++)e.isMesh===!0?e.getVertexPosition(o,fi):fi.fromBufferAttribute(s,o),fi.applyMatrix4(e.matrixWorld),this.expandByPoint(fi);else e.boundingBox!==void 0?(e.boundingBox===null&&e.computeBoundingBox(),yf.copy(e.boundingBox)):(r.boundingBox===null&&r.computeBoundingBox(),yf.copy(r.boundingBox)),yf.applyMatrix4(e.matrixWorld),this.union(yf)}const i=e.children;for(let s=0,o=i.length;s<o;s++)this.expandByObject(i[s],t);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,fi),fi.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,r;return e.normal.x>0?(t=e.normal.x*this.min.x,r=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,r=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,r+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,r+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,r+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,r+=e.normal.z*this.min.z),t<=-e.constant&&r>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(ju),bf.subVectors(this.max,ju),vc.subVectors(e.a,ju),_c.subVectors(e.b,ju),Ec.subVectors(e.c,ju),fo.subVectors(_c,vc),po.subVectors(Ec,_c),la.subVectors(vc,Ec);let t=[0,-fo.z,fo.y,0,-po.z,po.y,0,-la.z,la.y,fo.z,0,-fo.x,po.z,0,-po.x,la.z,0,-la.x,-fo.y,fo.x,0,-po.y,po.x,0,-la.y,la.x,0];return!Ty(t,vc,_c,Ec,bf)||(t=[1,0,0,0,1,0,0,0,1],!Ty(t,vc,_c,Ec,bf))?!1:(wf.crossVectors(fo,po),t=[wf.x,wf.y,wf.z],Ty(t,vc,_c,Ec,bf))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,fi).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=this.getSize(fi).length()*.5),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(gs[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),gs[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),gs[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),gs[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),gs[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),gs[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),gs[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),gs[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(gs),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const gs=[new q,new q,new q,new q,new q,new q,new q,new q],fi=new q,yf=new Fi,vc=new q,_c=new q,Ec=new q,fo=new q,po=new q,la=new q,ju=new q,bf=new q,wf=new q,ua=new q;function Ty(n,e,t,r,i){for(let s=0,o=n.length-3;s<=o;s+=3){ua.fromArray(n,s);const a=i.x*Math.abs(ua.x)+i.y*Math.abs(ua.y)+i.z*Math.abs(ua.z),c=e.dot(ua),l=t.dot(ua),u=r.dot(ua);if(Math.max(-Math.max(c,l,u),Math.min(c,l,u))>a)return!1}return!0}const o4=new Fi,Ju=new q,Ay=new q;class Q_{constructor(e=new q,t=-1){this.isSphere=!0,this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const r=this.center;t!==void 0?r.copy(t):o4.setFromPoints(e).getCenter(r);let i=0;for(let s=0,o=e.length;s<o;s++)i=Math.max(i,r.distanceToSquared(e[s]));return this.radius=Math.sqrt(i),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const r=this.center.distanceToSquared(e);return t.copy(e),r>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;Ju.subVectors(e,this.center);const t=Ju.lengthSq();if(t>this.radius*this.radius){const r=Math.sqrt(t),i=(r-this.radius)*.5;this.center.addScaledVector(Ju,i/r),this.radius+=i}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(Ay.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(Ju.copy(e.center).add(Ay)),this.expandByPoint(Ju.copy(e.center).sub(Ay))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const ys=new q,My=new q,vf=new q,mo=new q,Cy=new q,_f=new q,Iy=new q;class a4{constructor(e=new q,t=new q(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,ys)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const r=t.dot(this.direction);return r<0?t.copy(this.origin):t.copy(this.origin).addScaledVector(this.direction,r)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=ys.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(ys.copy(this.origin).addScaledVector(this.direction,t),ys.distanceToSquared(e))}distanceSqToSegment(e,t,r,i){My.copy(e).add(t).multiplyScalar(.5),vf.copy(t).sub(e).normalize(),mo.copy(this.origin).sub(My);const s=e.distanceTo(t)*.5,o=-this.direction.dot(vf),a=mo.dot(this.direction),c=-mo.dot(vf),l=mo.lengthSq(),u=Math.abs(1-o*o);let d,f,p,g;if(u>0)if(d=o*c-a,f=o*a-c,g=s*u,d>=0)if(f>=-g)if(f<=g){const b=1/u;d*=b,f*=b,p=d*(d+o*f+2*a)+f*(o*d+f+2*c)+l}else f=s,d=Math.max(0,-(o*f+a)),p=-d*d+f*(f+2*c)+l;else f=-s,d=Math.max(0,-(o*f+a)),p=-d*d+f*(f+2*c)+l;else f<=-g?(d=Math.max(0,-(-o*s+a)),f=d>0?-s:Math.min(Math.max(-s,-c),s),p=-d*d+f*(f+2*c)+l):f<=g?(d=0,f=Math.min(Math.max(-s,-c),s),p=f*(f+2*c)+l):(d=Math.max(0,-(o*s+a)),f=d>0?s:Math.min(Math.max(-s,-c),s),p=-d*d+f*(f+2*c)+l);else f=o>0?-s:s,d=Math.max(0,-(o*f+a)),p=-d*d+f*(f+2*c)+l;return r&&r.copy(this.origin).addScaledVector(this.direction,d),i&&i.copy(My).addScaledVector(vf,f),p}intersectSphere(e,t){ys.subVectors(e.center,this.origin);const r=ys.dot(this.direction),i=ys.dot(ys)-r*r,s=e.radius*e.radius;if(i>s)return null;const o=Math.sqrt(s-i),a=r-o,c=r+o;return c<0?null:a<0?this.at(c,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const r=-(this.origin.dot(e.normal)+e.constant)/t;return r>=0?r:null}intersectPlane(e,t){const r=this.distanceToPlane(e);return r===null?null:this.at(r,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let r,i,s,o,a,c;const l=1/this.direction.x,u=1/this.direction.y,d=1/this.direction.z,f=this.origin;return l>=0?(r=(e.min.x-f.x)*l,i=(e.max.x-f.x)*l):(r=(e.max.x-f.x)*l,i=(e.min.x-f.x)*l),u>=0?(s=(e.min.y-f.y)*u,o=(e.max.y-f.y)*u):(s=(e.max.y-f.y)*u,o=(e.min.y-f.y)*u),r>o||s>i||((s>r||isNaN(r))&&(r=s),(o<i||isNaN(i))&&(i=o),d>=0?(a=(e.min.z-f.z)*d,c=(e.max.z-f.z)*d):(a=(e.max.z-f.z)*d,c=(e.min.z-f.z)*d),r>c||a>i)||((a>r||r!==r)&&(r=a),(c<i||i!==i)&&(i=c),i<0)?null:this.at(r>=0?r:i,t)}intersectsBox(e){return this.intersectBox(e,ys)!==null}intersectTriangle(e,t,r,i,s){Cy.subVectors(t,e),_f.subVectors(r,e),Iy.crossVectors(Cy,_f);let o=this.direction.dot(Iy),a;if(o>0){if(i)return null;a=1}else if(o<0)a=-1,o=-o;else return null;mo.subVectors(this.origin,e);const c=a*this.direction.dot(_f.crossVectors(mo,_f));if(c<0)return null;const l=a*this.direction.dot(Cy.cross(mo));if(l<0||c+l>o)return null;const u=-a*mo.dot(Iy);return u<0?null:this.at(u/o,s)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class nn{constructor(e,t,r,i,s,o,a,c,l,u,d,f,p,g,b,m){nn.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],e!==void 0&&this.set(e,t,r,i,s,o,a,c,l,u,d,f,p,g,b,m)}set(e,t,r,i,s,o,a,c,l,u,d,f,p,g,b,m){const y=this.elements;return y[0]=e,y[4]=t,y[8]=r,y[12]=i,y[1]=s,y[5]=o,y[9]=a,y[13]=c,y[2]=l,y[6]=u,y[10]=d,y[14]=f,y[3]=p,y[7]=g,y[11]=b,y[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new nn().fromArray(this.elements)}copy(e){const t=this.elements,r=e.elements;return t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t[4]=r[4],t[5]=r[5],t[6]=r[6],t[7]=r[7],t[8]=r[8],t[9]=r[9],t[10]=r[10],t[11]=r[11],t[12]=r[12],t[13]=r[13],t[14]=r[14],t[15]=r[15],this}copyPosition(e){const t=this.elements,r=e.elements;return t[12]=r[12],t[13]=r[13],t[14]=r[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,r){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),r.setFromMatrixColumn(this,2),this}makeBasis(e,t,r){return this.set(e.x,t.x,r.x,0,e.y,t.y,r.y,0,e.z,t.z,r.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,r=e.elements,i=1/Sc.setFromMatrixColumn(e,0).length(),s=1/Sc.setFromMatrixColumn(e,1).length(),o=1/Sc.setFromMatrixColumn(e,2).length();return t[0]=r[0]*i,t[1]=r[1]*i,t[2]=r[2]*i,t[3]=0,t[4]=r[4]*s,t[5]=r[5]*s,t[6]=r[6]*s,t[7]=0,t[8]=r[8]*o,t[9]=r[9]*o,t[10]=r[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){const t=this.elements,r=e.x,i=e.y,s=e.z,o=Math.cos(r),a=Math.sin(r),c=Math.cos(i),l=Math.sin(i),u=Math.cos(s),d=Math.sin(s);if(e.order==="XYZ"){const f=o*u,p=o*d,g=a*u,b=a*d;t[0]=c*u,t[4]=-c*d,t[8]=l,t[1]=p+g*l,t[5]=f-b*l,t[9]=-a*c,t[2]=b-f*l,t[6]=g+p*l,t[10]=o*c}else if(e.order==="YXZ"){const f=c*u,p=c*d,g=l*u,b=l*d;t[0]=f+b*a,t[4]=g*a-p,t[8]=o*l,t[1]=o*d,t[5]=o*u,t[9]=-a,t[2]=p*a-g,t[6]=b+f*a,t[10]=o*c}else if(e.order==="ZXY"){const f=c*u,p=c*d,g=l*u,b=l*d;t[0]=f-b*a,t[4]=-o*d,t[8]=g+p*a,t[1]=p+g*a,t[5]=o*u,t[9]=b-f*a,t[2]=-o*l,t[6]=a,t[10]=o*c}else if(e.order==="ZYX"){const f=o*u,p=o*d,g=a*u,b=a*d;t[0]=c*u,t[4]=g*l-p,t[8]=f*l+b,t[1]=c*d,t[5]=b*l+f,t[9]=p*l-g,t[2]=-l,t[6]=a*c,t[10]=o*c}else if(e.order==="YZX"){const f=o*c,p=o*l,g=a*c,b=a*l;t[0]=c*u,t[4]=b-f*d,t[8]=g*d+p,t[1]=d,t[5]=o*u,t[9]=-a*u,t[2]=-l*u,t[6]=p*d+g,t[10]=f-b*d}else if(e.order==="XZY"){const f=o*c,p=o*l,g=a*c,b=a*l;t[0]=c*u,t[4]=-d,t[8]=l*u,t[1]=f*d+b,t[5]=o*u,t[9]=p*d-g,t[2]=g*d-p,t[6]=a*u,t[10]=b*d+f}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(c4,e,l4)}lookAt(e,t,r){const i=this.elements;return Ar.subVectors(e,t),Ar.lengthSq()===0&&(Ar.z=1),Ar.normalize(),go.crossVectors(r,Ar),go.lengthSq()===0&&(Math.abs(r.z)===1?Ar.x+=1e-4:Ar.z+=1e-4,Ar.normalize(),go.crossVectors(r,Ar)),go.normalize(),Ef.crossVectors(Ar,go),i[0]=go.x,i[4]=Ef.x,i[8]=Ar.x,i[1]=go.y,i[5]=Ef.y,i[9]=Ar.y,i[2]=go.z,i[6]=Ef.z,i[10]=Ar.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const r=e.elements,i=t.elements,s=this.elements,o=r[0],a=r[4],c=r[8],l=r[12],u=r[1],d=r[5],f=r[9],p=r[13],g=r[2],b=r[6],m=r[10],y=r[14],E=r[3],w=r[7],x=r[11],M=r[15],A=i[0],C=i[4],R=i[8],_=i[12],T=i[1],F=i[5],k=i[9],z=i[13],v=i[2],S=i[6],P=i[10],U=i[14],B=i[3],O=i[7],V=i[11],$=i[15];return s[0]=o*A+a*T+c*v+l*B,s[4]=o*C+a*F+c*S+l*O,s[8]=o*R+a*k+c*P+l*V,s[12]=o*_+a*z+c*U+l*$,s[1]=u*A+d*T+f*v+p*B,s[5]=u*C+d*F+f*S+p*O,s[9]=u*R+d*k+f*P+p*V,s[13]=u*_+d*z+f*U+p*$,s[2]=g*A+b*T+m*v+y*B,s[6]=g*C+b*F+m*S+y*O,s[10]=g*R+b*k+m*P+y*V,s[14]=g*_+b*z+m*U+y*$,s[3]=E*A+w*T+x*v+M*B,s[7]=E*C+w*F+x*S+M*O,s[11]=E*R+w*k+x*P+M*V,s[15]=E*_+w*z+x*U+M*$,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],r=e[4],i=e[8],s=e[12],o=e[1],a=e[5],c=e[9],l=e[13],u=e[2],d=e[6],f=e[10],p=e[14],g=e[3],b=e[7],m=e[11],y=e[15];return g*(+s*c*d-i*l*d-s*a*f+r*l*f+i*a*p-r*c*p)+b*(+t*c*p-t*l*f+s*o*f-i*o*p+i*l*u-s*c*u)+m*(+t*l*d-t*a*p-s*o*d+r*o*p+s*a*u-r*l*u)+y*(-i*a*u-t*c*d+t*a*f+i*o*d-r*o*f+r*c*u)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,r){const i=this.elements;return e.isVector3?(i[12]=e.x,i[13]=e.y,i[14]=e.z):(i[12]=e,i[13]=t,i[14]=r),this}invert(){const e=this.elements,t=e[0],r=e[1],i=e[2],s=e[3],o=e[4],a=e[5],c=e[6],l=e[7],u=e[8],d=e[9],f=e[10],p=e[11],g=e[12],b=e[13],m=e[14],y=e[15],E=d*m*l-b*f*l+b*c*p-a*m*p-d*c*y+a*f*y,w=g*f*l-u*m*l-g*c*p+o*m*p+u*c*y-o*f*y,x=u*b*l-g*d*l+g*a*p-o*b*p-u*a*y+o*d*y,M=g*d*c-u*b*c-g*a*f+o*b*f+u*a*m-o*d*m,A=t*E+r*w+i*x+s*M;if(A===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const C=1/A;return e[0]=E*C,e[1]=(b*f*s-d*m*s-b*i*p+r*m*p+d*i*y-r*f*y)*C,e[2]=(a*m*s-b*c*s+b*i*l-r*m*l-a*i*y+r*c*y)*C,e[3]=(d*c*s-a*f*s-d*i*l+r*f*l+a*i*p-r*c*p)*C,e[4]=w*C,e[5]=(u*m*s-g*f*s+g*i*p-t*m*p-u*i*y+t*f*y)*C,e[6]=(g*c*s-o*m*s-g*i*l+t*m*l+o*i*y-t*c*y)*C,e[7]=(o*f*s-u*c*s+u*i*l-t*f*l-o*i*p+t*c*p)*C,e[8]=x*C,e[9]=(g*d*s-u*b*s-g*r*p+t*b*p+u*r*y-t*d*y)*C,e[10]=(o*b*s-g*a*s+g*r*l-t*b*l-o*r*y+t*a*y)*C,e[11]=(u*a*s-o*d*s-u*r*l+t*d*l+o*r*p-t*a*p)*C,e[12]=M*C,e[13]=(u*b*i-g*d*i+g*r*f-t*b*f-u*r*m+t*d*m)*C,e[14]=(g*a*i-o*b*i-g*r*c+t*b*c+o*r*m-t*a*m)*C,e[15]=(o*d*i-u*a*i+u*r*c-t*d*c-o*r*f+t*a*f)*C,this}scale(e){const t=this.elements,r=e.x,i=e.y,s=e.z;return t[0]*=r,t[4]*=i,t[8]*=s,t[1]*=r,t[5]*=i,t[9]*=s,t[2]*=r,t[6]*=i,t[10]*=s,t[3]*=r,t[7]*=i,t[11]*=s,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],r=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,r,i))}makeTranslation(e,t,r){return e.isVector3?this.set(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1):this.set(1,0,0,e,0,1,0,t,0,0,1,r,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),r=Math.sin(e);return this.set(1,0,0,0,0,t,-r,0,0,r,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),r=Math.sin(e);return this.set(t,0,r,0,0,1,0,0,-r,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),r=Math.sin(e);return this.set(t,-r,0,0,r,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const r=Math.cos(t),i=Math.sin(t),s=1-r,o=e.x,a=e.y,c=e.z,l=s*o,u=s*a;return this.set(l*o+r,l*a-i*c,l*c+i*a,0,l*a+i*c,u*a+r,u*c-i*o,0,l*c-i*a,u*c+i*o,s*c*c+r,0,0,0,0,1),this}makeScale(e,t,r){return this.set(e,0,0,0,0,t,0,0,0,0,r,0,0,0,0,1),this}makeShear(e,t,r,i,s,o){return this.set(1,r,s,0,e,1,o,0,t,i,1,0,0,0,0,1),this}compose(e,t,r){const i=this.elements,s=t._x,o=t._y,a=t._z,c=t._w,l=s+s,u=o+o,d=a+a,f=s*l,p=s*u,g=s*d,b=o*u,m=o*d,y=a*d,E=c*l,w=c*u,x=c*d,M=r.x,A=r.y,C=r.z;return i[0]=(1-(b+y))*M,i[1]=(p+x)*M,i[2]=(g-w)*M,i[3]=0,i[4]=(p-x)*A,i[5]=(1-(f+y))*A,i[6]=(m+E)*A,i[7]=0,i[8]=(g+w)*C,i[9]=(m-E)*C,i[10]=(1-(f+b))*C,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}decompose(e,t,r){const i=this.elements;let s=Sc.set(i[0],i[1],i[2]).length();const o=Sc.set(i[4],i[5],i[6]).length(),a=Sc.set(i[8],i[9],i[10]).length();this.determinant()<0&&(s=-s),e.x=i[12],e.y=i[13],e.z=i[14],pi.copy(this);const l=1/s,u=1/o,d=1/a;return pi.elements[0]*=l,pi.elements[1]*=l,pi.elements[2]*=l,pi.elements[4]*=u,pi.elements[5]*=u,pi.elements[6]*=u,pi.elements[8]*=d,pi.elements[9]*=d,pi.elements[10]*=d,t.setFromRotationMatrix(pi),r.x=s,r.y=o,r.z=a,this}makePerspective(e,t,r,i,s,o,a=ks){const c=this.elements,l=2*s/(t-e),u=2*s/(r-i),d=(t+e)/(t-e),f=(r+i)/(r-i);let p,g;if(a===ks)p=-(o+s)/(o-s),g=-2*o*s/(o-s);else if(a===sm)p=-o/(o-s),g=-o*s/(o-s);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+a);return c[0]=l,c[4]=0,c[8]=d,c[12]=0,c[1]=0,c[5]=u,c[9]=f,c[13]=0,c[2]=0,c[6]=0,c[10]=p,c[14]=g,c[3]=0,c[7]=0,c[11]=-1,c[15]=0,this}makeOrthographic(e,t,r,i,s,o,a=ks){const c=this.elements,l=1/(t-e),u=1/(r-i),d=1/(o-s),f=(t+e)*l,p=(r+i)*u;let g,b;if(a===ks)g=(o+s)*d,b=-2*d;else if(a===sm)g=s*d,b=-1*d;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+a);return c[0]=2*l,c[4]=0,c[8]=0,c[12]=-f,c[1]=0,c[5]=2*u,c[9]=0,c[13]=-p,c[2]=0,c[6]=0,c[10]=b,c[14]=-g,c[3]=0,c[7]=0,c[11]=0,c[15]=1,this}equals(e){const t=this.elements,r=e.elements;for(let i=0;i<16;i++)if(t[i]!==r[i])return!1;return!0}fromArray(e,t=0){for(let r=0;r<16;r++)this.elements[r]=e[r+t];return this}toArray(e=[],t=0){const r=this.elements;return e[t]=r[0],e[t+1]=r[1],e[t+2]=r[2],e[t+3]=r[3],e[t+4]=r[4],e[t+5]=r[5],e[t+6]=r[6],e[t+7]=r[7],e[t+8]=r[8],e[t+9]=r[9],e[t+10]=r[10],e[t+11]=r[11],e[t+12]=r[12],e[t+13]=r[13],e[t+14]=r[14],e[t+15]=r[15],e}}const Sc=new q,pi=new nn,c4=new q(0,0,0),l4=new q(1,1,1),go=new q,Ef=new q,Ar=new q,Qx=new nn,e1=new Xd;class xg{constructor(e=0,t=0,r=0,i=xg.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=t,this._z=r,this._order=i}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,r,i=this._order){return this._x=e,this._y=t,this._z=r,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,r=!0){const i=e.elements,s=i[0],o=i[4],a=i[8],c=i[1],l=i[5],u=i[9],d=i[2],f=i[6],p=i[10];switch(t){case"XYZ":this._y=Math.asin(yr(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-u,p),this._z=Math.atan2(-o,s)):(this._x=Math.atan2(f,l),this._z=0);break;case"YXZ":this._x=Math.asin(-yr(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(a,p),this._z=Math.atan2(c,l)):(this._y=Math.atan2(-d,s),this._z=0);break;case"ZXY":this._x=Math.asin(yr(f,-1,1)),Math.abs(f)<.9999999?(this._y=Math.atan2(-d,p),this._z=Math.atan2(-o,l)):(this._y=0,this._z=Math.atan2(c,s));break;case"ZYX":this._y=Math.asin(-yr(d,-1,1)),Math.abs(d)<.9999999?(this._x=Math.atan2(f,p),this._z=Math.atan2(c,s)):(this._x=0,this._z=Math.atan2(-o,l));break;case"YZX":this._z=Math.asin(yr(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(-u,l),this._y=Math.atan2(-d,s)):(this._x=0,this._y=Math.atan2(a,p));break;case"XZY":this._z=Math.asin(-yr(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(f,l),this._y=Math.atan2(a,s)):(this._x=Math.atan2(-u,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,r===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,r){return Qx.makeRotationFromQuaternion(e),this.setFromRotationMatrix(Qx,t,r)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return e1.setFromEuler(this),this.setFromQuaternion(e1,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}xg.DEFAULT_ORDER="XYZ";class YI{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let u4=0;const t1=new q,xc=new Xd,bs=new nn,Sf=new q,Qu=new q,h4=new q,d4=new Xd,n1=new q(1,0,0),r1=new q(0,1,0),i1=new q(0,0,1),f4={type:"added"},p4={type:"removed"};class sn extends Pu{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:u4++}),this.uuid=Ko(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=sn.DEFAULT_UP.clone();const e=new q,t=new xg,r=new Xd,i=new q(1,1,1);function s(){r.setFromEuler(t,!1)}function o(){t.setFromQuaternion(r,void 0,!1)}t._onChange(s),r._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:r},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new nn},normalMatrix:{value:new Je}}),this.matrix=new nn,this.matrixWorld=new nn,this.matrixAutoUpdate=sn.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=sn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new YI,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return xc.setFromAxisAngle(e,t),this.quaternion.multiply(xc),this}rotateOnWorldAxis(e,t){return xc.setFromAxisAngle(e,t),this.quaternion.premultiply(xc),this}rotateX(e){return this.rotateOnAxis(n1,e)}rotateY(e){return this.rotateOnAxis(r1,e)}rotateZ(e){return this.rotateOnAxis(i1,e)}translateOnAxis(e,t){return t1.copy(e).applyQuaternion(this.quaternion),this.position.add(t1.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(n1,e)}translateY(e){return this.translateOnAxis(r1,e)}translateZ(e){return this.translateOnAxis(i1,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(bs.copy(this.matrixWorld).invert())}lookAt(e,t,r){e.isVector3?Sf.copy(e):Sf.set(e,t,r);const i=this.parent;this.updateWorldMatrix(!0,!1),Qu.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?bs.lookAt(Qu,Sf,this.up):bs.lookAt(Sf,Qu,this.up),this.quaternion.setFromRotationMatrix(bs),i&&(bs.extractRotation(i.matrixWorld),xc.setFromRotationMatrix(bs),this.quaternion.premultiply(xc.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(f4)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let r=0;r<arguments.length;r++)this.remove(arguments[r]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(p4)),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){return this.remove(...this.children)}attach(e){return this.updateWorldMatrix(!0,!1),bs.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),bs.multiply(e.parent.matrixWorld)),e.applyMatrix4(bs),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let r=0,i=this.children.length;r<i;r++){const o=this.children[r].getObjectByProperty(e,t);if(o!==void 0)return o}}getObjectsByProperty(e,t,r=[]){this[e]===t&&r.push(this);const i=this.children;for(let s=0,o=i.length;s<o;s++)i[s].getObjectsByProperty(e,t,r);return r}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Qu,e,h4),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Qu,d4,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let r=0,i=t.length;r<i;r++)t[r].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let r=0,i=t.length;r<i;r++)t[r].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let r=0,i=t.length;r<i;r++){const s=t[r];(s.matrixWorldAutoUpdate===!0||e===!0)&&s.updateMatrixWorld(e)}}updateWorldMatrix(e,t){const r=this.parent;if(e===!0&&r!==null&&r.matrixWorldAutoUpdate===!0&&r.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const i=this.children;for(let s=0,o=i.length;s<o;s++){const a=i[s];a.matrixWorldAutoUpdate===!0&&a.updateWorldMatrix(!1,!0)}}}toJSON(e){const t=e===void 0||typeof e=="string",r={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},r.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),i.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(i.type="BatchedMesh",i.perObjectFrustumCulled=this.perObjectFrustumCulled,i.sortObjects=this.sortObjects,i.drawRanges=this._drawRanges,i.reservedRanges=this._reservedRanges,i.visibility=this._visibility,i.active=this._active,i.bounds=this._bounds.map(a=>({boxInitialized:a.boxInitialized,boxMin:a.box.min.toArray(),boxMax:a.box.max.toArray(),sphereInitialized:a.sphereInitialized,sphereRadius:a.sphere.radius,sphereCenter:a.sphere.center.toArray()})),i.maxGeometryCount=this._maxGeometryCount,i.maxVertexCount=this._maxVertexCount,i.maxIndexCount=this._maxIndexCount,i.geometryInitialized=this._geometryInitialized,i.geometryCount=this._geometryCount,i.matricesTexture=this._matricesTexture.toJSON(e),this.boundingSphere!==null&&(i.boundingSphere={center:i.boundingSphere.center.toArray(),radius:i.boundingSphere.radius}),this.boundingBox!==null&&(i.boundingBox={min:i.boundingBox.min.toArray(),max:i.boundingBox.max.toArray()}));function s(a,c){return a[c.uuid]===void 0&&(a[c.uuid]=c.toJSON(e)),c.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(i.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=s(e.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const c=a.shapes;if(Array.isArray(c))for(let l=0,u=c.length;l<u;l++){const d=c[l];s(e.shapes,d)}else s(e.shapes,c)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(e.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let c=0,l=this.material.length;c<l;c++)a.push(s(e.materials,this.material[c]));i.material=a}else i.material=s(e.materials,this.material);if(this.children.length>0){i.children=[];for(let a=0;a<this.children.length;a++)i.children.push(this.children[a].toJSON(e).object)}if(this.animations.length>0){i.animations=[];for(let a=0;a<this.animations.length;a++){const c=this.animations[a];i.animations.push(s(e.animations,c))}}if(t){const a=o(e.geometries),c=o(e.materials),l=o(e.textures),u=o(e.images),d=o(e.shapes),f=o(e.skeletons),p=o(e.animations),g=o(e.nodes);a.length>0&&(r.geometries=a),c.length>0&&(r.materials=c),l.length>0&&(r.textures=l),u.length>0&&(r.images=u),d.length>0&&(r.shapes=d),f.length>0&&(r.skeletons=f),p.length>0&&(r.animations=p),g.length>0&&(r.nodes=g)}return r.object=i,r;function o(a){const c=[];for(const l in a){const u=a[l];delete u.metadata,c.push(u)}return c}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.animations=e.animations.slice(),this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let r=0;r<e.children.length;r++){const i=e.children[r];this.add(i.clone())}return this}}sn.DEFAULT_UP=new q(0,1,0);sn.DEFAULT_MATRIX_AUTO_UPDATE=!0;sn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const mi=new q,ws=new q,Py=new q,vs=new q,Tc=new q,Ac=new q,s1=new q,Dy=new q,Ry=new q,Ly=new q;let xf=!1;class Xr{constructor(e=new q,t=new q,r=new q){this.a=e,this.b=t,this.c=r}static getNormal(e,t,r,i){i.subVectors(r,t),mi.subVectors(e,t),i.cross(mi);const s=i.lengthSq();return s>0?i.multiplyScalar(1/Math.sqrt(s)):i.set(0,0,0)}static getBarycoord(e,t,r,i,s){mi.subVectors(i,t),ws.subVectors(r,t),Py.subVectors(e,t);const o=mi.dot(mi),a=mi.dot(ws),c=mi.dot(Py),l=ws.dot(ws),u=ws.dot(Py),d=o*l-a*a;if(d===0)return s.set(0,0,0),null;const f=1/d,p=(l*c-a*u)*f,g=(o*u-a*c)*f;return s.set(1-p-g,g,p)}static containsPoint(e,t,r,i){return this.getBarycoord(e,t,r,i,vs)===null?!1:vs.x>=0&&vs.y>=0&&vs.x+vs.y<=1}static getUV(e,t,r,i,s,o,a,c){return xf===!1&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),xf=!0),this.getInterpolation(e,t,r,i,s,o,a,c)}static getInterpolation(e,t,r,i,s,o,a,c){return this.getBarycoord(e,t,r,i,vs)===null?(c.x=0,c.y=0,"z"in c&&(c.z=0),"w"in c&&(c.w=0),null):(c.setScalar(0),c.addScaledVector(s,vs.x),c.addScaledVector(o,vs.y),c.addScaledVector(a,vs.z),c)}static isFrontFacing(e,t,r,i){return mi.subVectors(r,t),ws.subVectors(e,t),mi.cross(ws).dot(i)<0}set(e,t,r){return this.a.copy(e),this.b.copy(t),this.c.copy(r),this}setFromPointsAndIndices(e,t,r,i){return this.a.copy(e[t]),this.b.copy(e[r]),this.c.copy(e[i]),this}setFromAttributeAndIndices(e,t,r,i){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,r),this.c.fromBufferAttribute(e,i),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return mi.subVectors(this.c,this.b),ws.subVectors(this.a,this.b),mi.cross(ws).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Xr.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Xr.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,r,i,s){return xf===!1&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),xf=!0),Xr.getInterpolation(e,this.a,this.b,this.c,t,r,i,s)}getInterpolation(e,t,r,i,s){return Xr.getInterpolation(e,this.a,this.b,this.c,t,r,i,s)}containsPoint(e){return Xr.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Xr.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const r=this.a,i=this.b,s=this.c;let o,a;Tc.subVectors(i,r),Ac.subVectors(s,r),Dy.subVectors(e,r);const c=Tc.dot(Dy),l=Ac.dot(Dy);if(c<=0&&l<=0)return t.copy(r);Ry.subVectors(e,i);const u=Tc.dot(Ry),d=Ac.dot(Ry);if(u>=0&&d<=u)return t.copy(i);const f=c*d-u*l;if(f<=0&&c>=0&&u<=0)return o=c/(c-u),t.copy(r).addScaledVector(Tc,o);Ly.subVectors(e,s);const p=Tc.dot(Ly),g=Ac.dot(Ly);if(g>=0&&p<=g)return t.copy(s);const b=p*l-c*g;if(b<=0&&l>=0&&g<=0)return a=l/(l-g),t.copy(r).addScaledVector(Ac,a);const m=u*g-p*d;if(m<=0&&d-u>=0&&p-g>=0)return s1.subVectors(s,i),a=(d-u)/(d-u+(p-g)),t.copy(i).addScaledVector(s1,a);const y=1/(m+b+f);return o=b*y,a=f*y,t.copy(r).addScaledVector(Tc,o).addScaledVector(Ac,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const ZI={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},yo={h:0,s:0,l:0},Tf={h:0,s:0,l:0};function Oy(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*6*(2/3-t):n}class rt{constructor(e,t,r){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,t,r)}set(e,t,r){if(t===void 0&&r===void 0){const i=e;i&&i.isColor?this.copy(i):typeof i=="number"?this.setHex(i):typeof i=="string"&&this.setStyle(i)}else this.setRGB(e,t,r);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=_n){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,bt.toWorkingColorSpace(this,t),this}setRGB(e,t,r,i=bt.workingColorSpace){return this.r=e,this.g=t,this.b=r,bt.toWorkingColorSpace(this,i),this}setHSL(e,t,r,i=bt.workingColorSpace){if(e=QB(e,1),t=yr(t,0,1),r=yr(r,0,1),t===0)this.r=this.g=this.b=r;else{const s=r<=.5?r*(1+t):r+t-r*t,o=2*r-s;this.r=Oy(o,s,e+1/3),this.g=Oy(o,s,e),this.b=Oy(o,s,e-1/3)}return bt.toWorkingColorSpace(this,i),this}setStyle(e,t=_n){function r(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let i;if(i=/^(\w+)\(([^\)]*)\)/.exec(e)){let s;const o=i[1],a=i[2];switch(o){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return r(s[4]),this.setRGB(Math.min(255,parseInt(s[1],10))/255,Math.min(255,parseInt(s[2],10))/255,Math.min(255,parseInt(s[3],10))/255,t);if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return r(s[4]),this.setRGB(Math.min(100,parseInt(s[1],10))/100,Math.min(100,parseInt(s[2],10))/100,Math.min(100,parseInt(s[3],10))/100,t);break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return r(s[4]),this.setHSL(parseFloat(s[1])/360,parseFloat(s[2])/100,parseFloat(s[3])/100,t);break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(e)){const s=i[1],o=s.length;if(o===3)return this.setRGB(parseInt(s.charAt(0),16)/15,parseInt(s.charAt(1),16)/15,parseInt(s.charAt(2),16)/15,t);if(o===6)return this.setHex(parseInt(s,16),t);console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,t);return this}setColorName(e,t=_n){const r=ZI[e.toLowerCase()];return r!==void 0?this.setHex(r,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=cl(e.r),this.g=cl(e.g),this.b=cl(e.b),this}copyLinearToSRGB(e){return this.r=Ey(e.r),this.g=Ey(e.g),this.b=Ey(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=_n){return bt.fromWorkingColorSpace(Ln.copy(this),e),Math.round(yr(Ln.r*255,0,255))*65536+Math.round(yr(Ln.g*255,0,255))*256+Math.round(yr(Ln.b*255,0,255))}getHexString(e=_n){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=bt.workingColorSpace){bt.fromWorkingColorSpace(Ln.copy(this),t);const r=Ln.r,i=Ln.g,s=Ln.b,o=Math.max(r,i,s),a=Math.min(r,i,s);let c,l;const u=(a+o)/2;if(a===o)c=0,l=0;else{const d=o-a;switch(l=u<=.5?d/(o+a):d/(2-o-a),o){case r:c=(i-s)/d+(i<s?6:0);break;case i:c=(s-r)/d+2;break;case s:c=(r-i)/d+4;break}c/=6}return e.h=c,e.s=l,e.l=u,e}getRGB(e,t=bt.workingColorSpace){return bt.fromWorkingColorSpace(Ln.copy(this),t),e.r=Ln.r,e.g=Ln.g,e.b=Ln.b,e}getStyle(e=_n){bt.fromWorkingColorSpace(Ln.copy(this),e);const t=Ln.r,r=Ln.g,i=Ln.b;return e!==_n?`color(${e} ${t.toFixed(3)} ${r.toFixed(3)} ${i.toFixed(3)})`:`rgb(${Math.round(t*255)},${Math.round(r*255)},${Math.round(i*255)})`}offsetHSL(e,t,r){return this.getHSL(yo),this.setHSL(yo.h+e,yo.s+t,yo.l+r)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,r){return this.r=e.r+(t.r-e.r)*r,this.g=e.g+(t.g-e.g)*r,this.b=e.b+(t.b-e.b)*r,this}lerpHSL(e,t){this.getHSL(yo),e.getHSL(Tf);const r=vy(yo.h,Tf.h,t),i=vy(yo.s,Tf.s,t),s=vy(yo.l,Tf.l,t);return this.setHSL(r,i,s),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const t=this.r,r=this.g,i=this.b,s=e.elements;return this.r=s[0]*t+s[3]*r+s[6]*i,this.g=s[1]*t+s[4]*r+s[7]*i,this.b=s[2]*t+s[5]*r+s[8]*i,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const Ln=new rt;rt.NAMES=ZI;let m4=0;class Du extends Pu{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:m4++}),this.uuid=Ko(),this.name="",this.type="Material",this.blending=al,this.side=Zo,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=ov,this.blendDst=av,this.blendEquation=va,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new rt(0,0,0),this.blendAlpha=0,this.depthFunc=tm,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=qx,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=bc,this.stencilZFail=bc,this.stencilZPass=bc,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const r=e[t];if(r===void 0){console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);continue}const i=this[t];if(i===void 0){console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);continue}i&&i.isColor?i.set(r):i&&i.isVector3&&r&&r.isVector3?i.copy(r):this[t]=r}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const r={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.color&&this.color.isColor&&(r.color=this.color.getHex()),this.roughness!==void 0&&(r.roughness=this.roughness),this.metalness!==void 0&&(r.metalness=this.metalness),this.sheen!==void 0&&(r.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(r.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(r.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(r.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(r.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(r.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(r.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(r.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(r.shininess=this.shininess),this.clearcoat!==void 0&&(r.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(r.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(r.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(r.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(r.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,r.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(r.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(r.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(r.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(r.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(r.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.anisotropy!==void 0&&(r.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(r.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(r.anisotropyMap=this.anisotropyMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(r.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(r.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(r.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(r.lightMap=this.lightMap.toJSON(e).uuid,r.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(r.aoMap=this.aoMap.toJSON(e).uuid,r.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(r.bumpMap=this.bumpMap.toJSON(e).uuid,r.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(r.normalMap=this.normalMap.toJSON(e).uuid,r.normalMapType=this.normalMapType,r.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(r.displacementMap=this.displacementMap.toJSON(e).uuid,r.displacementScale=this.displacementScale,r.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(r.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(r.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(r.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(r.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(r.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(r.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(r.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(r.combine=this.combine)),this.envMapIntensity!==void 0&&(r.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(r.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(r.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(r.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(r.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(r.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(r.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(r.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(r.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(r.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(r.size=this.size),this.shadowSide!==null&&(r.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(r.sizeAttenuation=this.sizeAttenuation),this.blending!==al&&(r.blending=this.blending),this.side!==Zo&&(r.side=this.side),this.vertexColors===!0&&(r.vertexColors=!0),this.opacity<1&&(r.opacity=this.opacity),this.transparent===!0&&(r.transparent=!0),this.blendSrc!==ov&&(r.blendSrc=this.blendSrc),this.blendDst!==av&&(r.blendDst=this.blendDst),this.blendEquation!==va&&(r.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(r.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(r.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(r.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(r.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(r.blendAlpha=this.blendAlpha),this.depthFunc!==tm&&(r.depthFunc=this.depthFunc),this.depthTest===!1&&(r.depthTest=this.depthTest),this.depthWrite===!1&&(r.depthWrite=this.depthWrite),this.colorWrite===!1&&(r.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(r.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==qx&&(r.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(r.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(r.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==bc&&(r.stencilFail=this.stencilFail),this.stencilZFail!==bc&&(r.stencilZFail=this.stencilZFail),this.stencilZPass!==bc&&(r.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(r.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(r.rotation=this.rotation),this.polygonOffset===!0&&(r.polygonOffset=!0),this.polygonOffsetFactor!==0&&(r.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(r.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(r.linewidth=this.linewidth),this.dashSize!==void 0&&(r.dashSize=this.dashSize),this.gapSize!==void 0&&(r.gapSize=this.gapSize),this.scale!==void 0&&(r.scale=this.scale),this.dithering===!0&&(r.dithering=!0),this.alphaTest>0&&(r.alphaTest=this.alphaTest),this.alphaHash===!0&&(r.alphaHash=!0),this.alphaToCoverage===!0&&(r.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(r.premultipliedAlpha=!0),this.forceSinglePass===!0&&(r.forceSinglePass=!0),this.wireframe===!0&&(r.wireframe=!0),this.wireframeLinewidth>1&&(r.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(r.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(r.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(r.flatShading=!0),this.visible===!1&&(r.visible=!1),this.toneMapped===!1&&(r.toneMapped=!1),this.fog===!1&&(r.fog=!1),Object.keys(this.userData).length>0&&(r.userData=this.userData);function i(s){const o=[];for(const a in s){const c=s[a];delete c.metadata,o.push(c)}return o}if(t){const s=i(e.textures),o=i(e.images);s.length>0&&(r.textures=s),o.length>0&&(r.images=o)}return r}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.blendColor.copy(e.blendColor),this.blendAlpha=e.blendAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let r=null;if(t!==null){const i=t.length;r=new Array(i);for(let s=0;s!==i;++s)r[s]=t[s].clone()}return this.clippingPlanes=r,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaHash=e.alphaHash,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}class eE extends Du{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new rt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Z_,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const jt=new q,Af=new Ye;class Oi{constructor(e,t,r=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=r,this.usage=dv,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.gpuType=Bo,this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}get updateRange(){return console.warn("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this.gpuType=e.gpuType,this}copyAt(e,t,r){e*=this.itemSize,r*=t.itemSize;for(let i=0,s=this.itemSize;i<s;i++)this.array[e+i]=t.array[r+i];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,r=this.count;t<r;t++)Af.fromBufferAttribute(this,t),Af.applyMatrix3(e),this.setXY(t,Af.x,Af.y);else if(this.itemSize===3)for(let t=0,r=this.count;t<r;t++)jt.fromBufferAttribute(this,t),jt.applyMatrix3(e),this.setXYZ(t,jt.x,jt.y,jt.z);return this}applyMatrix4(e){for(let t=0,r=this.count;t<r;t++)jt.fromBufferAttribute(this,t),jt.applyMatrix4(e),this.setXYZ(t,jt.x,jt.y,jt.z);return this}applyNormalMatrix(e){for(let t=0,r=this.count;t<r;t++)jt.fromBufferAttribute(this,t),jt.applyNormalMatrix(e),this.setXYZ(t,jt.x,jt.y,jt.z);return this}transformDirection(e){for(let t=0,r=this.count;t<r;t++)jt.fromBufferAttribute(this,t),jt.transformDirection(e),this.setXYZ(t,jt.x,jt.y,jt.z);return this}set(e,t=0){return this.array.set(e,t),this}getComponent(e,t){let r=this.array[e*this.itemSize+t];return this.normalized&&(r=Bs(r,this.array)),r}setComponent(e,t,r){return this.normalized&&(r=Et(r,this.array)),this.array[e*this.itemSize+t]=r,this}getX(e){let t=this.array[e*this.itemSize];return this.normalized&&(t=Bs(t,this.array)),t}setX(e,t){return this.normalized&&(t=Et(t,this.array)),this.array[e*this.itemSize]=t,this}getY(e){let t=this.array[e*this.itemSize+1];return this.normalized&&(t=Bs(t,this.array)),t}setY(e,t){return this.normalized&&(t=Et(t,this.array)),this.array[e*this.itemSize+1]=t,this}getZ(e){let t=this.array[e*this.itemSize+2];return this.normalized&&(t=Bs(t,this.array)),t}setZ(e,t){return this.normalized&&(t=Et(t,this.array)),this.array[e*this.itemSize+2]=t,this}getW(e){let t=this.array[e*this.itemSize+3];return this.normalized&&(t=Bs(t,this.array)),t}setW(e,t){return this.normalized&&(t=Et(t,this.array)),this.array[e*this.itemSize+3]=t,this}setXY(e,t,r){return e*=this.itemSize,this.normalized&&(t=Et(t,this.array),r=Et(r,this.array)),this.array[e+0]=t,this.array[e+1]=r,this}setXYZ(e,t,r,i){return e*=this.itemSize,this.normalized&&(t=Et(t,this.array),r=Et(r,this.array),i=Et(i,this.array)),this.array[e+0]=t,this.array[e+1]=r,this.array[e+2]=i,this}setXYZW(e,t,r,i,s){return e*=this.itemSize,this.normalized&&(t=Et(t,this.array),r=Et(r,this.array),i=Et(i,this.array),s=Et(s,this.array)),this.array[e+0]=t,this.array[e+1]=r,this.array[e+2]=i,this.array[e+3]=s,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==dv&&(e.usage=this.usage),e}}class jI extends Oi{constructor(e,t,r){super(new Uint16Array(e),t,r)}}class JI extends Oi{constructor(e,t,r){super(new Uint32Array(e),t,r)}}class os extends Oi{constructor(e,t,r){super(new Float32Array(e),t,r)}}let g4=0;const Hr=new nn,Ny=new sn,Mc=new q,Mr=new Fi,eh=new Fi,hn=new q;class oo extends Pu{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:g4++}),this.uuid=Ko(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(WI(e)?JI:jI)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,r=0){this.groups.push({start:e,count:t,materialIndex:r})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const r=this.attributes.normal;if(r!==void 0){const s=new Je().getNormalMatrix(e);r.applyNormalMatrix(s),r.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(e),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return Hr.makeRotationFromQuaternion(e),this.applyMatrix4(Hr),this}rotateX(e){return Hr.makeRotationX(e),this.applyMatrix4(Hr),this}rotateY(e){return Hr.makeRotationY(e),this.applyMatrix4(Hr),this}rotateZ(e){return Hr.makeRotationZ(e),this.applyMatrix4(Hr),this}translate(e,t,r){return Hr.makeTranslation(e,t,r),this.applyMatrix4(Hr),this}scale(e,t,r){return Hr.makeScale(e,t,r),this.applyMatrix4(Hr),this}lookAt(e){return Ny.lookAt(e),Ny.updateMatrix(),this.applyMatrix4(Ny.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Mc).negate(),this.translate(Mc.x,Mc.y,Mc.z),this}setFromPoints(e){const t=[];for(let r=0,i=e.length;r<i;r++){const s=e[r];t.push(s.x,s.y,s.z||0)}return this.setAttribute("position",new os(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Fi);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new q(-1/0,-1/0,-1/0),new q(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let r=0,i=t.length;r<i;r++){const s=t[r];Mr.setFromBufferAttribute(s),this.morphTargetsRelative?(hn.addVectors(this.boundingBox.min,Mr.min),this.boundingBox.expandByPoint(hn),hn.addVectors(this.boundingBox.max,Mr.max),this.boundingBox.expandByPoint(hn)):(this.boundingBox.expandByPoint(Mr.min),this.boundingBox.expandByPoint(Mr.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Q_);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new q,1/0);return}if(e){const r=this.boundingSphere.center;if(Mr.setFromBufferAttribute(e),t)for(let s=0,o=t.length;s<o;s++){const a=t[s];eh.setFromBufferAttribute(a),this.morphTargetsRelative?(hn.addVectors(Mr.min,eh.min),Mr.expandByPoint(hn),hn.addVectors(Mr.max,eh.max),Mr.expandByPoint(hn)):(Mr.expandByPoint(eh.min),Mr.expandByPoint(eh.max))}Mr.getCenter(r);let i=0;for(let s=0,o=e.count;s<o;s++)hn.fromBufferAttribute(e,s),i=Math.max(i,r.distanceToSquared(hn));if(t)for(let s=0,o=t.length;s<o;s++){const a=t[s],c=this.morphTargetsRelative;for(let l=0,u=a.count;l<u;l++)hn.fromBufferAttribute(a,l),c&&(Mc.fromBufferAttribute(e,l),hn.add(Mc)),i=Math.max(i,r.distanceToSquared(hn))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const r=e.array,i=t.position.array,s=t.normal.array,o=t.uv.array,a=i.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Oi(new Float32Array(4*a),4));const c=this.getAttribute("tangent").array,l=[],u=[];for(let T=0;T<a;T++)l[T]=new q,u[T]=new q;const d=new q,f=new q,p=new q,g=new Ye,b=new Ye,m=new Ye,y=new q,E=new q;function w(T,F,k){d.fromArray(i,T*3),f.fromArray(i,F*3),p.fromArray(i,k*3),g.fromArray(o,T*2),b.fromArray(o,F*2),m.fromArray(o,k*2),f.sub(d),p.sub(d),b.sub(g),m.sub(g);const z=1/(b.x*m.y-m.x*b.y);isFinite(z)&&(y.copy(f).multiplyScalar(m.y).addScaledVector(p,-b.y).multiplyScalar(z),E.copy(p).multiplyScalar(b.x).addScaledVector(f,-m.x).multiplyScalar(z),l[T].add(y),l[F].add(y),l[k].add(y),u[T].add(E),u[F].add(E),u[k].add(E))}let x=this.groups;x.length===0&&(x=[{start:0,count:r.length}]);for(let T=0,F=x.length;T<F;++T){const k=x[T],z=k.start,v=k.count;for(let S=z,P=z+v;S<P;S+=3)w(r[S+0],r[S+1],r[S+2])}const M=new q,A=new q,C=new q,R=new q;function _(T){C.fromArray(s,T*3),R.copy(C);const F=l[T];M.copy(F),M.sub(C.multiplyScalar(C.dot(F))).normalize(),A.crossVectors(R,F);const z=A.dot(u[T])<0?-1:1;c[T*4]=M.x,c[T*4+1]=M.y,c[T*4+2]=M.z,c[T*4+3]=z}for(let T=0,F=x.length;T<F;++T){const k=x[T],z=k.start,v=k.count;for(let S=z,P=z+v;S<P;S+=3)_(r[S+0]),_(r[S+1]),_(r[S+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let r=this.getAttribute("normal");if(r===void 0)r=new Oi(new Float32Array(t.count*3),3),this.setAttribute("normal",r);else for(let f=0,p=r.count;f<p;f++)r.setXYZ(f,0,0,0);const i=new q,s=new q,o=new q,a=new q,c=new q,l=new q,u=new q,d=new q;if(e)for(let f=0,p=e.count;f<p;f+=3){const g=e.getX(f+0),b=e.getX(f+1),m=e.getX(f+2);i.fromBufferAttribute(t,g),s.fromBufferAttribute(t,b),o.fromBufferAttribute(t,m),u.subVectors(o,s),d.subVectors(i,s),u.cross(d),a.fromBufferAttribute(r,g),c.fromBufferAttribute(r,b),l.fromBufferAttribute(r,m),a.add(u),c.add(u),l.add(u),r.setXYZ(g,a.x,a.y,a.z),r.setXYZ(b,c.x,c.y,c.z),r.setXYZ(m,l.x,l.y,l.z)}else for(let f=0,p=t.count;f<p;f+=3)i.fromBufferAttribute(t,f+0),s.fromBufferAttribute(t,f+1),o.fromBufferAttribute(t,f+2),u.subVectors(o,s),d.subVectors(i,s),u.cross(d),r.setXYZ(f+0,u.x,u.y,u.z),r.setXYZ(f+1,u.x,u.y,u.z),r.setXYZ(f+2,u.x,u.y,u.z);this.normalizeNormals(),r.needsUpdate=!0}}normalizeNormals(){const e=this.attributes.normal;for(let t=0,r=e.count;t<r;t++)hn.fromBufferAttribute(e,t),hn.normalize(),e.setXYZ(t,hn.x,hn.y,hn.z)}toNonIndexed(){function e(a,c){const l=a.array,u=a.itemSize,d=a.normalized,f=new l.constructor(c.length*u);let p=0,g=0;for(let b=0,m=c.length;b<m;b++){a.isInterleavedBufferAttribute?p=c[b]*a.data.stride+a.offset:p=c[b]*u;for(let y=0;y<u;y++)f[g++]=l[p++]}return new Oi(f,u,d)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new oo,r=this.index.array,i=this.attributes;for(const a in i){const c=i[a],l=e(c,r);t.setAttribute(a,l)}const s=this.morphAttributes;for(const a in s){const c=[],l=s[a];for(let u=0,d=l.length;u<d;u++){const f=l[u],p=e(f,r);c.push(p)}t.morphAttributes[a]=c}t.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let a=0,c=o.length;a<c;a++){const l=o[a];t.addGroup(l.start,l.count,l.materialIndex)}return t}toJSON(){const e={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const c=this.parameters;for(const l in c)c[l]!==void 0&&(e[l]=c[l]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const r=this.attributes;for(const c in r){const l=r[c];e.data.attributes[c]=l.toJSON(e.data)}const i={};let s=!1;for(const c in this.morphAttributes){const l=this.morphAttributes[c],u=[];for(let d=0,f=l.length;d<f;d++){const p=l[d];u.push(p.toJSON(e.data))}u.length>0&&(i[c]=u,s=!0)}s&&(e.data.morphAttributes=i,e.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(e.data.groups=JSON.parse(JSON.stringify(o)));const a=this.boundingSphere;return a!==null&&(e.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const r=e.index;r!==null&&this.setIndex(r.clone(t));const i=e.attributes;for(const l in i){const u=i[l];this.setAttribute(l,u.clone(t))}const s=e.morphAttributes;for(const l in s){const u=[],d=s[l];for(let f=0,p=d.length;f<p;f++)u.push(d[f].clone(t));this.morphAttributes[l]=u}this.morphTargetsRelative=e.morphTargetsRelative;const o=e.groups;for(let l=0,u=o.length;l<u;l++){const d=o[l];this.addGroup(d.start,d.count,d.materialIndex)}const a=e.boundingBox;a!==null&&(this.boundingBox=a.clone());const c=e.boundingSphere;return c!==null&&(this.boundingSphere=c.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const o1=new nn,ha=new a4,Mf=new Q_,a1=new q,Cc=new q,Ic=new q,Pc=new q,Uy=new q,Cf=new q,If=new Ye,Pf=new Ye,Df=new Ye,c1=new q,l1=new q,u1=new q,Rf=new q,Lf=new q;class dr extends sn{constructor(e=new oo,t=new eE){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,r=Object.keys(t);if(r.length>0){const i=t[r[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=i.length;s<o;s++){const a=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}getVertexPosition(e,t){const r=this.geometry,i=r.attributes.position,s=r.morphAttributes.position,o=r.morphTargetsRelative;t.fromBufferAttribute(i,e);const a=this.morphTargetInfluences;if(s&&a){Cf.set(0,0,0);for(let c=0,l=s.length;c<l;c++){const u=a[c],d=s[c];u!==0&&(Uy.fromBufferAttribute(d,e),o?Cf.addScaledVector(Uy,u):Cf.addScaledVector(Uy.sub(t),u))}t.add(Cf)}return t}raycast(e,t){const r=this.geometry,i=this.material,s=this.matrixWorld;i!==void 0&&(r.boundingSphere===null&&r.computeBoundingSphere(),Mf.copy(r.boundingSphere),Mf.applyMatrix4(s),ha.copy(e.ray).recast(e.near),!(Mf.containsPoint(ha.origin)===!1&&(ha.intersectSphere(Mf,a1)===null||ha.origin.distanceToSquared(a1)>(e.far-e.near)**2))&&(o1.copy(s).invert(),ha.copy(e.ray).applyMatrix4(o1),!(r.boundingBox!==null&&ha.intersectsBox(r.boundingBox)===!1)&&this._computeIntersections(e,t,ha)))}_computeIntersections(e,t,r){let i;const s=this.geometry,o=this.material,a=s.index,c=s.attributes.position,l=s.attributes.uv,u=s.attributes.uv1,d=s.attributes.normal,f=s.groups,p=s.drawRange;if(a!==null)if(Array.isArray(o))for(let g=0,b=f.length;g<b;g++){const m=f[g],y=o[m.materialIndex],E=Math.max(m.start,p.start),w=Math.min(a.count,Math.min(m.start+m.count,p.start+p.count));for(let x=E,M=w;x<M;x+=3){const A=a.getX(x),C=a.getX(x+1),R=a.getX(x+2);i=Of(this,y,e,r,l,u,d,A,C,R),i&&(i.faceIndex=Math.floor(x/3),i.face.materialIndex=m.materialIndex,t.push(i))}}else{const g=Math.max(0,p.start),b=Math.min(a.count,p.start+p.count);for(let m=g,y=b;m<y;m+=3){const E=a.getX(m),w=a.getX(m+1),x=a.getX(m+2);i=Of(this,o,e,r,l,u,d,E,w,x),i&&(i.faceIndex=Math.floor(m/3),t.push(i))}}else if(c!==void 0)if(Array.isArray(o))for(let g=0,b=f.length;g<b;g++){const m=f[g],y=o[m.materialIndex],E=Math.max(m.start,p.start),w=Math.min(c.count,Math.min(m.start+m.count,p.start+p.count));for(let x=E,M=w;x<M;x+=3){const A=x,C=x+1,R=x+2;i=Of(this,y,e,r,l,u,d,A,C,R),i&&(i.faceIndex=Math.floor(x/3),i.face.materialIndex=m.materialIndex,t.push(i))}}else{const g=Math.max(0,p.start),b=Math.min(c.count,p.start+p.count);for(let m=g,y=b;m<y;m+=3){const E=m,w=m+1,x=m+2;i=Of(this,o,e,r,l,u,d,E,w,x),i&&(i.faceIndex=Math.floor(m/3),t.push(i))}}}}function y4(n,e,t,r,i,s,o,a){let c;if(e.side===Er?c=r.intersectTriangle(o,s,i,!0,a):c=r.intersectTriangle(i,s,o,e.side===Zo,a),c===null)return null;Lf.copy(a),Lf.applyMatrix4(n.matrixWorld);const l=t.ray.origin.distanceTo(Lf);return l<t.near||l>t.far?null:{distance:l,point:Lf.clone(),object:n}}function Of(n,e,t,r,i,s,o,a,c,l){n.getVertexPosition(a,Cc),n.getVertexPosition(c,Ic),n.getVertexPosition(l,Pc);const u=y4(n,e,t,r,Cc,Ic,Pc,Rf);if(u){i&&(If.fromBufferAttribute(i,a),Pf.fromBufferAttribute(i,c),Df.fromBufferAttribute(i,l),u.uv=Xr.getInterpolation(Rf,Cc,Ic,Pc,If,Pf,Df,new Ye)),s&&(If.fromBufferAttribute(s,a),Pf.fromBufferAttribute(s,c),Df.fromBufferAttribute(s,l),u.uv1=Xr.getInterpolation(Rf,Cc,Ic,Pc,If,Pf,Df,new Ye),u.uv2=u.uv1),o&&(c1.fromBufferAttribute(o,a),l1.fromBufferAttribute(o,c),u1.fromBufferAttribute(o,l),u.normal=Xr.getInterpolation(Rf,Cc,Ic,Pc,c1,l1,u1,new q),u.normal.dot(r.direction)>0&&u.normal.multiplyScalar(-1));const d={a,b:c,c:l,normal:new q,materialIndex:0};Xr.getNormal(Cc,Ic,Pc,d.normal),u.face=d}return u}class ao extends oo{constructor(e=1,t=1,r=1,i=1,s=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:r,widthSegments:i,heightSegments:s,depthSegments:o};const a=this;i=Math.floor(i),s=Math.floor(s),o=Math.floor(o);const c=[],l=[],u=[],d=[];let f=0,p=0;g("z","y","x",-1,-1,r,t,e,o,s,0),g("z","y","x",1,-1,r,t,-e,o,s,1),g("x","z","y",1,1,e,r,t,i,o,2),g("x","z","y",1,-1,e,r,-t,i,o,3),g("x","y","z",1,-1,e,t,r,i,s,4),g("x","y","z",-1,-1,e,t,-r,i,s,5),this.setIndex(c),this.setAttribute("position",new os(l,3)),this.setAttribute("normal",new os(u,3)),this.setAttribute("uv",new os(d,2));function g(b,m,y,E,w,x,M,A,C,R,_){const T=x/C,F=M/R,k=x/2,z=M/2,v=A/2,S=C+1,P=R+1;let U=0,B=0;const O=new q;for(let V=0;V<P;V++){const $=V*F-z;for(let W=0;W<S;W++){const H=W*T-k;O[b]=H*E,O[m]=$*w,O[y]=v,l.push(O.x,O.y,O.z),O[b]=0,O[m]=0,O[y]=A>0?1:-1,u.push(O.x,O.y,O.z),d.push(W/C),d.push(1-V/R),U+=1}}for(let V=0;V<R;V++)for(let $=0;$<C;$++){const W=f+$+S*V,H=f+$+S*(V+1),Y=f+($+1)+S*(V+1),te=f+($+1)+S*V;c.push(W,H,te),c.push(H,Y,te),B+=6}a.addGroup(p,B,_),p+=B,f+=U}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new ao(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function nu(n){const e={};for(const t in n){e[t]={};for(const r in n[t]){const i=n[t][r];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?i.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[t][r]=null):e[t][r]=i.clone():Array.isArray(i)?e[t][r]=i.slice():e[t][r]=i}}return e}function sr(n){const e={};for(let t=0;t<n.length;t++){const r=nu(n[t]);for(const i in r)e[i]=r[i]}return e}function b4(n){const e=[];for(let t=0;t<n.length;t++)e.push(n[t].clone());return e}function QI(n){return n.getRenderTarget()===null?n.outputColorSpace:bt.workingColorSpace}const w4={clone:nu,merge:sr};var v4=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,_4=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class qa extends Du{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=v4,this.fragmentShader=_4,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1,clipCullDistance:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=nu(e.uniforms),this.uniformsGroups=b4(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const i in this.uniforms){const o=this.uniforms[i].value;o&&o.isTexture?t.uniforms[i]={type:"t",value:o.toJSON(e).uuid}:o&&o.isColor?t.uniforms[i]={type:"c",value:o.getHex()}:o&&o.isVector2?t.uniforms[i]={type:"v2",value:o.toArray()}:o&&o.isVector3?t.uniforms[i]={type:"v3",value:o.toArray()}:o&&o.isVector4?t.uniforms[i]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?t.uniforms[i]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?t.uniforms[i]={type:"m4",value:o.toArray()}:t.uniforms[i]={value:o}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader,t.lights=this.lights,t.clipping=this.clipping;const r={};for(const i in this.extensions)this.extensions[i]===!0&&(r[i]=!0);return Object.keys(r).length>0&&(t.extensions=r),t}}class eP extends sn{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new nn,this.projectionMatrix=new nn,this.projectionMatrixInverse=new nn,this.coordinateSystem=ks}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this.coordinateSystem=e.coordinateSystem,this}getWorldDirection(e){return super.getWorldDirection(e).negate()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}class Lr extends eP{constructor(e=50,t=1,r=.1,i=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=r,this.far=i,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=om*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(wy*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return om*2*Math.atan(Math.tan(wy*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,r,i,s,o){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=r,this.view.offsetY=i,this.view.width=s,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(wy*.5*this.fov)/this.zoom,r=2*t,i=this.aspect*r,s=-.5*i;const o=this.view;if(this.view!==null&&this.view.enabled){const c=o.fullWidth,l=o.fullHeight;s+=o.offsetX*i/c,t-=o.offsetY*r/l,i*=o.width/c,r*=o.height/l}const a=this.filmOffset;a!==0&&(s+=e*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+i,t,t-r,e,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}const Dc=-90,Rc=1;class E4 extends sn{constructor(e,t,r){super(),this.type="CubeCamera",this.renderTarget=r,this.coordinateSystem=null,this.activeMipmapLevel=0;const i=new Lr(Dc,Rc,e,t);i.layers=this.layers,this.add(i);const s=new Lr(Dc,Rc,e,t);s.layers=this.layers,this.add(s);const o=new Lr(Dc,Rc,e,t);o.layers=this.layers,this.add(o);const a=new Lr(Dc,Rc,e,t);a.layers=this.layers,this.add(a);const c=new Lr(Dc,Rc,e,t);c.layers=this.layers,this.add(c);const l=new Lr(Dc,Rc,e,t);l.layers=this.layers,this.add(l)}updateCoordinateSystem(){const e=this.coordinateSystem,t=this.children.concat(),[r,i,s,o,a,c]=t;for(const l of t)this.remove(l);if(e===ks)r.up.set(0,1,0),r.lookAt(1,0,0),i.up.set(0,1,0),i.lookAt(-1,0,0),s.up.set(0,0,-1),s.lookAt(0,1,0),o.up.set(0,0,1),o.lookAt(0,-1,0),a.up.set(0,1,0),a.lookAt(0,0,1),c.up.set(0,1,0),c.lookAt(0,0,-1);else if(e===sm)r.up.set(0,-1,0),r.lookAt(-1,0,0),i.up.set(0,-1,0),i.lookAt(1,0,0),s.up.set(0,0,1),s.lookAt(0,1,0),o.up.set(0,0,-1),o.lookAt(0,-1,0),a.up.set(0,-1,0),a.lookAt(0,0,1),c.up.set(0,-1,0),c.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+e);for(const l of t)this.add(l),l.updateMatrixWorld()}update(e,t){this.parent===null&&this.updateMatrixWorld();const{renderTarget:r,activeMipmapLevel:i}=this;this.coordinateSystem!==e.coordinateSystem&&(this.coordinateSystem=e.coordinateSystem,this.updateCoordinateSystem());const[s,o,a,c,l,u]=this.children,d=e.getRenderTarget(),f=e.getActiveCubeFace(),p=e.getActiveMipmapLevel(),g=e.xr.enabled;e.xr.enabled=!1;const b=r.texture.generateMipmaps;r.texture.generateMipmaps=!1,e.setRenderTarget(r,0,i),e.render(t,s),e.setRenderTarget(r,1,i),e.render(t,o),e.setRenderTarget(r,2,i),e.render(t,a),e.setRenderTarget(r,3,i),e.render(t,c),e.setRenderTarget(r,4,i),e.render(t,l),r.texture.generateMipmaps=b,e.setRenderTarget(r,5,i),e.render(t,u),e.setRenderTarget(d,f,p),e.xr.enabled=g,r.texture.needsPMREMUpdate=!0}}class tP extends Sr{constructor(e,t,r,i,s,o,a,c,l,u){e=e!==void 0?e:[],t=t!==void 0?t:Ql,super(e,t,r,i,s,o,a,c,l,u),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class S4 extends Wa{constructor(e=1,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const r={width:e,height:e,depth:1},i=[r,r,r,r,r,r];t.encoding!==void 0&&(Uh("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."),t.colorSpace=t.encoding===Fa?_n:Yr),this.texture=new tP(i,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:Kr}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.colorSpace=t.colorSpace,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const r={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new ao(5,5,5),s=new qa({name:"CubemapFromEquirect",uniforms:nu(r.uniforms),vertexShader:r.vertexShader,fragmentShader:r.fragmentShader,side:Er,blending:Go});s.uniforms.tEquirect.value=t;const o=new dr(i,s),a=t.minFilter;return t.minFilter===td&&(t.minFilter=Kr),new E4(1,10,this).update(e,o),t.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(e,t,r,i){const s=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,r,i);e.setRenderTarget(s)}}const By=new q,x4=new q,T4=new Je;class pa{constructor(e=new q(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,r,i){return this.normal.set(e,t,r),this.constant=i,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,r){const i=By.subVectors(r,t).cross(x4.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(i,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,t){const r=e.delta(By),i=this.normal.dot(r);if(i===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const s=-(e.start.dot(this.normal)+this.constant)/i;return s<0||s>1?null:t.copy(e.start).addScaledVector(r,s)}intersectsLine(e){const t=this.distanceToPoint(e.start),r=this.distanceToPoint(e.end);return t<0&&r>0||r<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const r=t||T4.getNormalMatrix(e),i=this.coplanarPoint(By).applyMatrix4(e),s=this.normal.applyMatrix3(r).normalize();return this.constant=-i.dot(s),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}const da=new Q_,Nf=new q;class tE{constructor(e=new pa,t=new pa,r=new pa,i=new pa,s=new pa,o=new pa){this.planes=[e,t,r,i,s,o]}set(e,t,r,i,s,o){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(r),a[3].copy(i),a[4].copy(s),a[5].copy(o),this}copy(e){const t=this.planes;for(let r=0;r<6;r++)t[r].copy(e.planes[r]);return this}setFromProjectionMatrix(e,t=ks){const r=this.planes,i=e.elements,s=i[0],o=i[1],a=i[2],c=i[3],l=i[4],u=i[5],d=i[6],f=i[7],p=i[8],g=i[9],b=i[10],m=i[11],y=i[12],E=i[13],w=i[14],x=i[15];if(r[0].setComponents(c-s,f-l,m-p,x-y).normalize(),r[1].setComponents(c+s,f+l,m+p,x+y).normalize(),r[2].setComponents(c+o,f+u,m+g,x+E).normalize(),r[3].setComponents(c-o,f-u,m-g,x-E).normalize(),r[4].setComponents(c-a,f-d,m-b,x-w).normalize(),t===ks)r[5].setComponents(c+a,f+d,m+b,x+w).normalize();else if(t===sm)r[5].setComponents(a,d,b,w).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+t);return this}intersectsObject(e){if(e.boundingSphere!==void 0)e.boundingSphere===null&&e.computeBoundingSphere(),da.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);else{const t=e.geometry;t.boundingSphere===null&&t.computeBoundingSphere(),da.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)}return this.intersectsSphere(da)}intersectsSprite(e){return da.center.set(0,0,0),da.radius=.7071067811865476,da.applyMatrix4(e.matrixWorld),this.intersectsSphere(da)}intersectsSphere(e){const t=this.planes,r=e.center,i=-e.radius;for(let s=0;s<6;s++)if(t[s].distanceToPoint(r)<i)return!1;return!0}intersectsBox(e){const t=this.planes;for(let r=0;r<6;r++){const i=t[r];if(Nf.x=i.normal.x>0?e.max.x:e.min.x,Nf.y=i.normal.y>0?e.max.y:e.min.y,Nf.z=i.normal.z>0?e.max.z:e.min.z,i.distanceToPoint(Nf)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let r=0;r<6;r++)if(t[r].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function nP(){let n=null,e=!1,t=null,r=null;function i(s,o){t(s,o),r=n.requestAnimationFrame(i)}return{start:function(){e!==!0&&t!==null&&(r=n.requestAnimationFrame(i),e=!0)},stop:function(){n.cancelAnimationFrame(r),e=!1},setAnimationLoop:function(s){t=s},setContext:function(s){n=s}}}function A4(n,e){const t=e.isWebGL2,r=new WeakMap;function i(l,u){const d=l.array,f=l.usage,p=d.byteLength,g=n.createBuffer();n.bindBuffer(u,g),n.bufferData(u,d,f),l.onUploadCallback();let b;if(d instanceof Float32Array)b=n.FLOAT;else if(d instanceof Uint16Array)if(l.isFloat16BufferAttribute)if(t)b=n.HALF_FLOAT;else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else b=n.UNSIGNED_SHORT;else if(d instanceof Int16Array)b=n.SHORT;else if(d instanceof Uint32Array)b=n.UNSIGNED_INT;else if(d instanceof Int32Array)b=n.INT;else if(d instanceof Int8Array)b=n.BYTE;else if(d instanceof Uint8Array)b=n.UNSIGNED_BYTE;else if(d instanceof Uint8ClampedArray)b=n.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+d);return{buffer:g,type:b,bytesPerElement:d.BYTES_PER_ELEMENT,version:l.version,size:p}}function s(l,u,d){const f=u.array,p=u._updateRange,g=u.updateRanges;if(n.bindBuffer(d,l),p.count===-1&&g.length===0&&n.bufferSubData(d,0,f),g.length!==0){for(let b=0,m=g.length;b<m;b++){const y=g[b];t?n.bufferSubData(d,y.start*f.BYTES_PER_ELEMENT,f,y.start,y.count):n.bufferSubData(d,y.start*f.BYTES_PER_ELEMENT,f.subarray(y.start,y.start+y.count))}u.clearUpdateRanges()}p.count!==-1&&(t?n.bufferSubData(d,p.offset*f.BYTES_PER_ELEMENT,f,p.offset,p.count):n.bufferSubData(d,p.offset*f.BYTES_PER_ELEMENT,f.subarray(p.offset,p.offset+p.count)),p.count=-1),u.onUploadCallback()}function o(l){return l.isInterleavedBufferAttribute&&(l=l.data),r.get(l)}function a(l){l.isInterleavedBufferAttribute&&(l=l.data);const u=r.get(l);u&&(n.deleteBuffer(u.buffer),r.delete(l))}function c(l,u){if(l.isGLBufferAttribute){const f=r.get(l);(!f||f.version<l.version)&&r.set(l,{buffer:l.buffer,type:l.type,bytesPerElement:l.elementSize,version:l.version});return}l.isInterleavedBufferAttribute&&(l=l.data);const d=r.get(l);if(d===void 0)r.set(l,i(l,u));else if(d.version<l.version){if(d.size!==l.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");s(d.buffer,l,u),d.version=l.version}}return{get:o,remove:a,update:c}}class Tg extends oo{constructor(e=1,t=1,r=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:r,heightSegments:i};const s=e/2,o=t/2,a=Math.floor(r),c=Math.floor(i),l=a+1,u=c+1,d=e/a,f=t/c,p=[],g=[],b=[],m=[];for(let y=0;y<u;y++){const E=y*f-o;for(let w=0;w<l;w++){const x=w*d-s;g.push(x,-E,0),b.push(0,0,1),m.push(w/a),m.push(1-y/c)}}for(let y=0;y<c;y++)for(let E=0;E<a;E++){const w=E+l*y,x=E+l*(y+1),M=E+1+l*(y+1),A=E+1+l*y;p.push(w,x,A),p.push(x,M,A)}this.setIndex(p),this.setAttribute("position",new os(g,3)),this.setAttribute("normal",new os(b,3)),this.setAttribute("uv",new os(m,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Tg(e.width,e.height,e.widthSegments,e.heightSegments)}}var M4=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,C4=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,I4=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,P4=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,D4=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,R4=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,L4=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,O4=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,N4=`#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,U4=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`,B4=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,k4=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,$4=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,F4=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,z4=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,V4=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,H4=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,G4=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,W4=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,q4=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,K4=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,X4=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,Y4=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,Z4=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,j4=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,J4=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,Q4=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,ek=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,tk=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,nk=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,rk="gl_FragColor = linearToOutputTexel( gl_FragColor );",ik=`
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,sk=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,ok=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,ak=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,ck=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,lk=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,uk=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,hk=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,dk=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,fk=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,pk=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,mk=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,gk=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,yk=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,bk=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,wk=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,vk=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,_k=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,Ek=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,Sk=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,xk=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,Tk=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,Ak=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,Mk=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,Ck=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,Ik=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,Pk=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,Dk=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,Rk=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,Lk=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,Ok=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,Nk=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,Uk=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,Bk=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,kk=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,$k=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,Fk=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,zk=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,Vk=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,Hk=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,Gk=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,Wk=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,qk=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,Kk=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,Xk=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,Yk=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,Zk=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,jk=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,Jk=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,Qk=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,e6=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,t6=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,n6=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,r6=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,i6=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,s6=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,o6=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,a6=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,c6=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,l6=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,u6=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,h6=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,d6=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,f6=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,p6=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,m6=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,g6=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,y6=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,b6=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,w6=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color *= toneMappingExposure;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	return color;
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,v6=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,_6=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,E6=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,S6=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,x6=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,T6=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const A6=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,M6=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,C6=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,I6=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,P6=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,D6=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,R6=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,L6=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,O6=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,N6=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,U6=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,B6=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,k6=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,$6=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,F6=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,z6=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,V6=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,H6=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,G6=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,W6=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,q6=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,K6=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,X6=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Y6=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Z6=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,j6=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,J6=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Q6=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,e$=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,t$=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,n$=`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,r$=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,i$=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,s$=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,We={alphahash_fragment:M4,alphahash_pars_fragment:C4,alphamap_fragment:I4,alphamap_pars_fragment:P4,alphatest_fragment:D4,alphatest_pars_fragment:R4,aomap_fragment:L4,aomap_pars_fragment:O4,batching_pars_vertex:N4,batching_vertex:U4,begin_vertex:B4,beginnormal_vertex:k4,bsdfs:$4,iridescence_fragment:F4,bumpmap_pars_fragment:z4,clipping_planes_fragment:V4,clipping_planes_pars_fragment:H4,clipping_planes_pars_vertex:G4,clipping_planes_vertex:W4,color_fragment:q4,color_pars_fragment:K4,color_pars_vertex:X4,color_vertex:Y4,common:Z4,cube_uv_reflection_fragment:j4,defaultnormal_vertex:J4,displacementmap_pars_vertex:Q4,displacementmap_vertex:ek,emissivemap_fragment:tk,emissivemap_pars_fragment:nk,colorspace_fragment:rk,colorspace_pars_fragment:ik,envmap_fragment:sk,envmap_common_pars_fragment:ok,envmap_pars_fragment:ak,envmap_pars_vertex:ck,envmap_physical_pars_fragment:vk,envmap_vertex:lk,fog_vertex:uk,fog_pars_vertex:hk,fog_fragment:dk,fog_pars_fragment:fk,gradientmap_pars_fragment:pk,lightmap_fragment:mk,lightmap_pars_fragment:gk,lights_lambert_fragment:yk,lights_lambert_pars_fragment:bk,lights_pars_begin:wk,lights_toon_fragment:_k,lights_toon_pars_fragment:Ek,lights_phong_fragment:Sk,lights_phong_pars_fragment:xk,lights_physical_fragment:Tk,lights_physical_pars_fragment:Ak,lights_fragment_begin:Mk,lights_fragment_maps:Ck,lights_fragment_end:Ik,logdepthbuf_fragment:Pk,logdepthbuf_pars_fragment:Dk,logdepthbuf_pars_vertex:Rk,logdepthbuf_vertex:Lk,map_fragment:Ok,map_pars_fragment:Nk,map_particle_fragment:Uk,map_particle_pars_fragment:Bk,metalnessmap_fragment:kk,metalnessmap_pars_fragment:$k,morphcolor_vertex:Fk,morphnormal_vertex:zk,morphtarget_pars_vertex:Vk,morphtarget_vertex:Hk,normal_fragment_begin:Gk,normal_fragment_maps:Wk,normal_pars_fragment:qk,normal_pars_vertex:Kk,normal_vertex:Xk,normalmap_pars_fragment:Yk,clearcoat_normal_fragment_begin:Zk,clearcoat_normal_fragment_maps:jk,clearcoat_pars_fragment:Jk,iridescence_pars_fragment:Qk,opaque_fragment:e6,packing:t6,premultiplied_alpha_fragment:n6,project_vertex:r6,dithering_fragment:i6,dithering_pars_fragment:s6,roughnessmap_fragment:o6,roughnessmap_pars_fragment:a6,shadowmap_pars_fragment:c6,shadowmap_pars_vertex:l6,shadowmap_vertex:u6,shadowmask_pars_fragment:h6,skinbase_vertex:d6,skinning_pars_vertex:f6,skinning_vertex:p6,skinnormal_vertex:m6,specularmap_fragment:g6,specularmap_pars_fragment:y6,tonemapping_fragment:b6,tonemapping_pars_fragment:w6,transmission_fragment:v6,transmission_pars_fragment:_6,uv_pars_fragment:E6,uv_pars_vertex:S6,uv_vertex:x6,worldpos_vertex:T6,background_vert:A6,background_frag:M6,backgroundCube_vert:C6,backgroundCube_frag:I6,cube_vert:P6,cube_frag:D6,depth_vert:R6,depth_frag:L6,distanceRGBA_vert:O6,distanceRGBA_frag:N6,equirect_vert:U6,equirect_frag:B6,linedashed_vert:k6,linedashed_frag:$6,meshbasic_vert:F6,meshbasic_frag:z6,meshlambert_vert:V6,meshlambert_frag:H6,meshmatcap_vert:G6,meshmatcap_frag:W6,meshnormal_vert:q6,meshnormal_frag:K6,meshphong_vert:X6,meshphong_frag:Y6,meshphysical_vert:Z6,meshphysical_frag:j6,meshtoon_vert:J6,meshtoon_frag:Q6,points_vert:e$,points_frag:t$,shadow_vert:n$,shadow_frag:r$,sprite_vert:i$,sprite_frag:s$},de={common:{diffuse:{value:new rt(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new Je},alphaMap:{value:null},alphaMapTransform:{value:new Je},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new Je}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new Je}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new Je}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new Je},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new Je},normalScale:{value:new Ye(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new Je},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new Je}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new Je}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new Je}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new rt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new rt(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new Je},alphaTest:{value:0},uvTransform:{value:new Je}},sprite:{diffuse:{value:new rt(16777215)},opacity:{value:1},center:{value:new Ye(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new Je},alphaMap:{value:null},alphaMapTransform:{value:new Je},alphaTest:{value:0}}},es={basic:{uniforms:sr([de.common,de.specularmap,de.envmap,de.aomap,de.lightmap,de.fog]),vertexShader:We.meshbasic_vert,fragmentShader:We.meshbasic_frag},lambert:{uniforms:sr([de.common,de.specularmap,de.envmap,de.aomap,de.lightmap,de.emissivemap,de.bumpmap,de.normalmap,de.displacementmap,de.fog,de.lights,{emissive:{value:new rt(0)}}]),vertexShader:We.meshlambert_vert,fragmentShader:We.meshlambert_frag},phong:{uniforms:sr([de.common,de.specularmap,de.envmap,de.aomap,de.lightmap,de.emissivemap,de.bumpmap,de.normalmap,de.displacementmap,de.fog,de.lights,{emissive:{value:new rt(0)},specular:{value:new rt(1118481)},shininess:{value:30}}]),vertexShader:We.meshphong_vert,fragmentShader:We.meshphong_frag},standard:{uniforms:sr([de.common,de.envmap,de.aomap,de.lightmap,de.emissivemap,de.bumpmap,de.normalmap,de.displacementmap,de.roughnessmap,de.metalnessmap,de.fog,de.lights,{emissive:{value:new rt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:We.meshphysical_vert,fragmentShader:We.meshphysical_frag},toon:{uniforms:sr([de.common,de.aomap,de.lightmap,de.emissivemap,de.bumpmap,de.normalmap,de.displacementmap,de.gradientmap,de.fog,de.lights,{emissive:{value:new rt(0)}}]),vertexShader:We.meshtoon_vert,fragmentShader:We.meshtoon_frag},matcap:{uniforms:sr([de.common,de.bumpmap,de.normalmap,de.displacementmap,de.fog,{matcap:{value:null}}]),vertexShader:We.meshmatcap_vert,fragmentShader:We.meshmatcap_frag},points:{uniforms:sr([de.points,de.fog]),vertexShader:We.points_vert,fragmentShader:We.points_frag},dashed:{uniforms:sr([de.common,de.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:We.linedashed_vert,fragmentShader:We.linedashed_frag},depth:{uniforms:sr([de.common,de.displacementmap]),vertexShader:We.depth_vert,fragmentShader:We.depth_frag},normal:{uniforms:sr([de.common,de.bumpmap,de.normalmap,de.displacementmap,{opacity:{value:1}}]),vertexShader:We.meshnormal_vert,fragmentShader:We.meshnormal_frag},sprite:{uniforms:sr([de.sprite,de.fog]),vertexShader:We.sprite_vert,fragmentShader:We.sprite_frag},background:{uniforms:{uvTransform:{value:new Je},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:We.background_vert,fragmentShader:We.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1}},vertexShader:We.backgroundCube_vert,fragmentShader:We.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:We.cube_vert,fragmentShader:We.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:We.equirect_vert,fragmentShader:We.equirect_frag},distanceRGBA:{uniforms:sr([de.common,de.displacementmap,{referencePosition:{value:new q},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:We.distanceRGBA_vert,fragmentShader:We.distanceRGBA_frag},shadow:{uniforms:sr([de.lights,de.fog,{color:{value:new rt(0)},opacity:{value:1}}]),vertexShader:We.shadow_vert,fragmentShader:We.shadow_frag}};es.physical={uniforms:sr([es.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new Je},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new Je},clearcoatNormalScale:{value:new Ye(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new Je},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new Je},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new Je},sheen:{value:0},sheenColor:{value:new rt(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new Je},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new Je},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new Je},transmissionSamplerSize:{value:new Ye},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new Je},attenuationDistance:{value:0},attenuationColor:{value:new rt(0)},specularColor:{value:new rt(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new Je},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new Je},anisotropyVector:{value:new Ye},anisotropyMap:{value:null},anisotropyMapTransform:{value:new Je}}]),vertexShader:We.meshphysical_vert,fragmentShader:We.meshphysical_frag};const Uf={r:0,b:0,g:0};function o$(n,e,t,r,i,s,o){const a=new rt(0);let c=s===!0?0:1,l,u,d=null,f=0,p=null;function g(m,y){let E=!1,w=y.isScene===!0?y.background:null;w&&w.isTexture&&(w=(y.backgroundBlurriness>0?t:e).get(w)),w===null?b(a,c):w&&w.isColor&&(b(w,1),E=!0);const x=n.xr.getEnvironmentBlendMode();x==="additive"?r.buffers.color.setClear(0,0,0,1,o):x==="alpha-blend"&&r.buffers.color.setClear(0,0,0,0,o),(n.autoClear||E)&&n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil),w&&(w.isCubeTexture||w.mapping===Eg)?(u===void 0&&(u=new dr(new ao(1,1,1),new qa({name:"BackgroundCubeMaterial",uniforms:nu(es.backgroundCube.uniforms),vertexShader:es.backgroundCube.vertexShader,fragmentShader:es.backgroundCube.fragmentShader,side:Er,depthTest:!1,depthWrite:!1,fog:!1})),u.geometry.deleteAttribute("normal"),u.geometry.deleteAttribute("uv"),u.onBeforeRender=function(M,A,C){this.matrixWorld.copyPosition(C.matrixWorld)},Object.defineProperty(u.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(u)),u.material.uniforms.envMap.value=w,u.material.uniforms.flipEnvMap.value=w.isCubeTexture&&w.isRenderTargetTexture===!1?-1:1,u.material.uniforms.backgroundBlurriness.value=y.backgroundBlurriness,u.material.uniforms.backgroundIntensity.value=y.backgroundIntensity,u.material.toneMapped=bt.getTransfer(w.colorSpace)!==Dt,(d!==w||f!==w.version||p!==n.toneMapping)&&(u.material.needsUpdate=!0,d=w,f=w.version,p=n.toneMapping),u.layers.enableAll(),m.unshift(u,u.geometry,u.material,0,0,null)):w&&w.isTexture&&(l===void 0&&(l=new dr(new Tg(2,2),new qa({name:"BackgroundMaterial",uniforms:nu(es.background.uniforms),vertexShader:es.background.vertexShader,fragmentShader:es.background.fragmentShader,side:Zo,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),Object.defineProperty(l.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(l)),l.material.uniforms.t2D.value=w,l.material.uniforms.backgroundIntensity.value=y.backgroundIntensity,l.material.toneMapped=bt.getTransfer(w.colorSpace)!==Dt,w.matrixAutoUpdate===!0&&w.updateMatrix(),l.material.uniforms.uvTransform.value.copy(w.matrix),(d!==w||f!==w.version||p!==n.toneMapping)&&(l.material.needsUpdate=!0,d=w,f=w.version,p=n.toneMapping),l.layers.enableAll(),m.unshift(l,l.geometry,l.material,0,0,null))}function b(m,y){m.getRGB(Uf,QI(n)),r.buffers.color.setClear(Uf.r,Uf.g,Uf.b,y,o)}return{getClearColor:function(){return a},setClearColor:function(m,y=1){a.set(m),c=y,b(a,c)},getClearAlpha:function(){return c},setClearAlpha:function(m){c=m,b(a,c)},render:g}}function a$(n,e,t,r){const i=n.getParameter(n.MAX_VERTEX_ATTRIBS),s=r.isWebGL2?null:e.get("OES_vertex_array_object"),o=r.isWebGL2||s!==null,a={},c=m(null);let l=c,u=!1;function d(v,S,P,U,B){let O=!1;if(o){const V=b(U,P,S);l!==V&&(l=V,p(l.object)),O=y(v,U,P,B),O&&E(v,U,P,B)}else{const V=S.wireframe===!0;(l.geometry!==U.id||l.program!==P.id||l.wireframe!==V)&&(l.geometry=U.id,l.program=P.id,l.wireframe=V,O=!0)}B!==null&&t.update(B,n.ELEMENT_ARRAY_BUFFER),(O||u)&&(u=!1,R(v,S,P,U),B!==null&&n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t.get(B).buffer))}function f(){return r.isWebGL2?n.createVertexArray():s.createVertexArrayOES()}function p(v){return r.isWebGL2?n.bindVertexArray(v):s.bindVertexArrayOES(v)}function g(v){return r.isWebGL2?n.deleteVertexArray(v):s.deleteVertexArrayOES(v)}function b(v,S,P){const U=P.wireframe===!0;let B=a[v.id];B===void 0&&(B={},a[v.id]=B);let O=B[S.id];O===void 0&&(O={},B[S.id]=O);let V=O[U];return V===void 0&&(V=m(f()),O[U]=V),V}function m(v){const S=[],P=[],U=[];for(let B=0;B<i;B++)S[B]=0,P[B]=0,U[B]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:S,enabledAttributes:P,attributeDivisors:U,object:v,attributes:{},index:null}}function y(v,S,P,U){const B=l.attributes,O=S.attributes;let V=0;const $=P.getAttributes();for(const W in $)if($[W].location>=0){const Y=B[W];let te=O[W];if(te===void 0&&(W==="instanceMatrix"&&v.instanceMatrix&&(te=v.instanceMatrix),W==="instanceColor"&&v.instanceColor&&(te=v.instanceColor)),Y===void 0||Y.attribute!==te||te&&Y.data!==te.data)return!0;V++}return l.attributesNum!==V||l.index!==U}function E(v,S,P,U){const B={},O=S.attributes;let V=0;const $=P.getAttributes();for(const W in $)if($[W].location>=0){let Y=O[W];Y===void 0&&(W==="instanceMatrix"&&v.instanceMatrix&&(Y=v.instanceMatrix),W==="instanceColor"&&v.instanceColor&&(Y=v.instanceColor));const te={};te.attribute=Y,Y&&Y.data&&(te.data=Y.data),B[W]=te,V++}l.attributes=B,l.attributesNum=V,l.index=U}function w(){const v=l.newAttributes;for(let S=0,P=v.length;S<P;S++)v[S]=0}function x(v){M(v,0)}function M(v,S){const P=l.newAttributes,U=l.enabledAttributes,B=l.attributeDivisors;P[v]=1,U[v]===0&&(n.enableVertexAttribArray(v),U[v]=1),B[v]!==S&&((r.isWebGL2?n:e.get("ANGLE_instanced_arrays"))[r.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](v,S),B[v]=S)}function A(){const v=l.newAttributes,S=l.enabledAttributes;for(let P=0,U=S.length;P<U;P++)S[P]!==v[P]&&(n.disableVertexAttribArray(P),S[P]=0)}function C(v,S,P,U,B,O,V){V===!0?n.vertexAttribIPointer(v,S,P,B,O):n.vertexAttribPointer(v,S,P,U,B,O)}function R(v,S,P,U){if(r.isWebGL2===!1&&(v.isInstancedMesh||U.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;w();const B=U.attributes,O=P.getAttributes(),V=S.defaultAttributeValues;for(const $ in O){const W=O[$];if(W.location>=0){let H=B[$];if(H===void 0&&($==="instanceMatrix"&&v.instanceMatrix&&(H=v.instanceMatrix),$==="instanceColor"&&v.instanceColor&&(H=v.instanceColor)),H!==void 0){const Y=H.normalized,te=H.itemSize,j=t.get(H);if(j===void 0)continue;const re=j.buffer,le=j.type,fe=j.bytesPerElement,se=r.isWebGL2===!0&&(le===n.INT||le===n.UNSIGNED_INT||H.gpuType===NI);if(H.isInterleavedBufferAttribute){const ve=H.data,X=ve.stride,Ut=H.offset;if(ve.isInstancedInterleavedBuffer){for(let Ce=0;Ce<W.locationSize;Ce++)M(W.location+Ce,ve.meshPerAttribute);v.isInstancedMesh!==!0&&U._maxInstanceCount===void 0&&(U._maxInstanceCount=ve.meshPerAttribute*ve.count)}else for(let Ce=0;Ce<W.locationSize;Ce++)x(W.location+Ce);n.bindBuffer(n.ARRAY_BUFFER,re);for(let Ce=0;Ce<W.locationSize;Ce++)C(W.location+Ce,te/W.locationSize,le,Y,X*fe,(Ut+te/W.locationSize*Ce)*fe,se)}else{if(H.isInstancedBufferAttribute){for(let ve=0;ve<W.locationSize;ve++)M(W.location+ve,H.meshPerAttribute);v.isInstancedMesh!==!0&&U._maxInstanceCount===void 0&&(U._maxInstanceCount=H.meshPerAttribute*H.count)}else for(let ve=0;ve<W.locationSize;ve++)x(W.location+ve);n.bindBuffer(n.ARRAY_BUFFER,re);for(let ve=0;ve<W.locationSize;ve++)C(W.location+ve,te/W.locationSize,le,Y,te*fe,te/W.locationSize*ve*fe,se)}}else if(V!==void 0){const Y=V[$];if(Y!==void 0)switch(Y.length){case 2:n.vertexAttrib2fv(W.location,Y);break;case 3:n.vertexAttrib3fv(W.location,Y);break;case 4:n.vertexAttrib4fv(W.location,Y);break;default:n.vertexAttrib1fv(W.location,Y)}}}}A()}function _(){k();for(const v in a){const S=a[v];for(const P in S){const U=S[P];for(const B in U)g(U[B].object),delete U[B];delete S[P]}delete a[v]}}function T(v){if(a[v.id]===void 0)return;const S=a[v.id];for(const P in S){const U=S[P];for(const B in U)g(U[B].object),delete U[B];delete S[P]}delete a[v.id]}function F(v){for(const S in a){const P=a[S];if(P[v.id]===void 0)continue;const U=P[v.id];for(const B in U)g(U[B].object),delete U[B];delete P[v.id]}}function k(){z(),u=!0,l!==c&&(l=c,p(l.object))}function z(){c.geometry=null,c.program=null,c.wireframe=!1}return{setup:d,reset:k,resetDefaultState:z,dispose:_,releaseStatesOfGeometry:T,releaseStatesOfProgram:F,initAttributes:w,enableAttribute:x,disableUnusedAttributes:A}}function c$(n,e,t,r){const i=r.isWebGL2;let s;function o(u){s=u}function a(u,d){n.drawArrays(s,u,d),t.update(d,s,1)}function c(u,d,f){if(f===0)return;let p,g;if(i)p=n,g="drawArraysInstanced";else if(p=e.get("ANGLE_instanced_arrays"),g="drawArraysInstancedANGLE",p===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}p[g](s,u,d,f),t.update(d,s,f)}function l(u,d,f){if(f===0)return;const p=e.get("WEBGL_multi_draw");if(p===null)for(let g=0;g<f;g++)this.render(u[g],d[g]);else{p.multiDrawArraysWEBGL(s,u,0,d,0,f);let g=0;for(let b=0;b<f;b++)g+=d[b];t.update(g,s,1)}}this.setMode=o,this.render=a,this.renderInstances=c,this.renderMultiDraw=l}function l$(n,e,t){let r;function i(){if(r!==void 0)return r;if(e.has("EXT_texture_filter_anisotropic")===!0){const C=e.get("EXT_texture_filter_anisotropic");r=n.getParameter(C.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else r=0;return r}function s(C){if(C==="highp"){if(n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision>0)return"highp";C="mediump"}return C==="mediump"&&n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext<"u"&&n.constructor.name==="WebGL2RenderingContext";let a=t.precision!==void 0?t.precision:"highp";const c=s(a);c!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",c,"instead."),a=c);const l=o||e.has("WEBGL_draw_buffers"),u=t.logarithmicDepthBuffer===!0,d=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),f=n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),p=n.getParameter(n.MAX_TEXTURE_SIZE),g=n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),b=n.getParameter(n.MAX_VERTEX_ATTRIBS),m=n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),y=n.getParameter(n.MAX_VARYING_VECTORS),E=n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),w=f>0,x=o||e.has("OES_texture_float"),M=w&&x,A=o?n.getParameter(n.MAX_SAMPLES):0;return{isWebGL2:o,drawBuffers:l,getMaxAnisotropy:i,getMaxPrecision:s,precision:a,logarithmicDepthBuffer:u,maxTextures:d,maxVertexTextures:f,maxTextureSize:p,maxCubemapSize:g,maxAttributes:b,maxVertexUniforms:m,maxVaryings:y,maxFragmentUniforms:E,vertexTextures:w,floatFragmentTextures:x,floatVertexTextures:M,maxSamples:A}}function u$(n){const e=this;let t=null,r=0,i=!1,s=!1;const o=new pa,a=new Je,c={value:null,needsUpdate:!1};this.uniform=c,this.numPlanes=0,this.numIntersection=0,this.init=function(d,f){const p=d.length!==0||f||r!==0||i;return i=f,r=d.length,p},this.beginShadows=function(){s=!0,u(null)},this.endShadows=function(){s=!1},this.setGlobalState=function(d,f){t=u(d,f,0)},this.setState=function(d,f,p){const g=d.clippingPlanes,b=d.clipIntersection,m=d.clipShadows,y=n.get(d);if(!i||g===null||g.length===0||s&&!m)s?u(null):l();else{const E=s?0:r,w=E*4;let x=y.clippingState||null;c.value=x,x=u(g,f,w,p);for(let M=0;M!==w;++M)x[M]=t[M];y.clippingState=x,this.numIntersection=b?this.numPlanes:0,this.numPlanes+=E}};function l(){c.value!==t&&(c.value=t,c.needsUpdate=r>0),e.numPlanes=r,e.numIntersection=0}function u(d,f,p,g){const b=d!==null?d.length:0;let m=null;if(b!==0){if(m=c.value,g!==!0||m===null){const y=p+b*4,E=f.matrixWorldInverse;a.getNormalMatrix(E),(m===null||m.length<y)&&(m=new Float32Array(y));for(let w=0,x=p;w!==b;++w,x+=4)o.copy(d[w]).applyMatrix4(E,a),o.normal.toArray(m,x),m[x+3]=o.constant}c.value=m,c.needsUpdate=!0}return e.numPlanes=b,e.numIntersection=0,m}}function h$(n){let e=new WeakMap;function t(o,a){return a===cv?o.mapping=Ql:a===lv&&(o.mapping=eu),o}function r(o){if(o&&o.isTexture){const a=o.mapping;if(a===cv||a===lv)if(e.has(o)){const c=e.get(o).texture;return t(c,o.mapping)}else{const c=o.image;if(c&&c.height>0){const l=new S4(c.height/2);return l.fromEquirectangularTexture(n,o),e.set(o,l),o.addEventListener("dispose",i),t(l.texture,o.mapping)}else return null}}return o}function i(o){const a=o.target;a.removeEventListener("dispose",i);const c=e.get(a);c!==void 0&&(e.delete(a),c.dispose())}function s(){e=new WeakMap}return{get:r,dispose:s}}class d$ extends eP{constructor(e=-1,t=1,r=1,i=-1,s=.1,o=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=r,this.bottom=i,this.near=s,this.far=o,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,r,i,s,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=r,this.view.offsetY=i,this.view.width=s,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),r=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let s=r-e,o=r+e,a=i+t,c=i-t;if(this.view!==null&&this.view.enabled){const l=(this.right-this.left)/this.view.fullWidth/this.zoom,u=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=l*this.view.offsetX,o=s+l*this.view.width,a-=u*this.view.offsetY,c=a-u*this.view.height}this.projectionMatrix.makeOrthographic(s,o,a,c,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}const qc=4,h1=[.125,.215,.35,.446,.526,.582],_a=20,ky=new d$,d1=new rt;let $y=null,Fy=0,zy=0;const ma=(1+Math.sqrt(5))/2,Lc=1/ma,f1=[new q(1,1,1),new q(-1,1,1),new q(1,1,-1),new q(-1,1,-1),new q(0,ma,Lc),new q(0,ma,-Lc),new q(Lc,0,ma),new q(-Lc,0,ma),new q(ma,Lc,0),new q(-ma,Lc,0)];class p1{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,r=.1,i=100){$y=this._renderer.getRenderTarget(),Fy=this._renderer.getActiveCubeFace(),zy=this._renderer.getActiveMipmapLevel(),this._setSize(256);const s=this._allocateTargets();return s.depthBuffer=!0,this._sceneToCubeUV(e,r,i,s),t>0&&this._blur(s,0,0,t),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=y1(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=g1(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget($y,Fy,zy),e.scissorTest=!1,Bf(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===Ql||e.mapping===eu?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),$y=this._renderer.getRenderTarget(),Fy=this._renderer.getActiveCubeFace(),zy=this._renderer.getActiveMipmapLevel();const r=t||this._allocateTargets();return this._textureToCubeUV(e,r),this._applyPMREM(r),this._cleanup(r),r}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,r={magFilter:Kr,minFilter:Kr,generateMipmaps:!1,type:nd,format:Di,colorSpace:to,depthBuffer:!1},i=m1(e,t,r);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==t){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=m1(e,t,r);const{_lodMax:s}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=f$(s)),this._blurMaterial=p$(s,e,t)}return i}_compileMaterial(e){const t=new dr(this._lodPlanes[0],e);this._renderer.compile(t,ky)}_sceneToCubeUV(e,t,r,i){const a=new Lr(90,1,t,r),c=[1,-1,1,1,1,1],l=[1,1,1,-1,-1,-1],u=this._renderer,d=u.autoClear,f=u.toneMapping;u.getClearColor(d1),u.toneMapping=Wo,u.autoClear=!1;const p=new eE({name:"PMREM.Background",side:Er,depthWrite:!1,depthTest:!1}),g=new dr(new ao,p);let b=!1;const m=e.background;m?m.isColor&&(p.color.copy(m),e.background=null,b=!0):(p.color.copy(d1),b=!0);for(let y=0;y<6;y++){const E=y%3;E===0?(a.up.set(0,c[y],0),a.lookAt(l[y],0,0)):E===1?(a.up.set(0,0,c[y]),a.lookAt(0,l[y],0)):(a.up.set(0,c[y],0),a.lookAt(0,0,l[y]));const w=this._cubeSize;Bf(i,E*w,y>2?w:0,w,w),u.setRenderTarget(i),b&&u.render(g,a),u.render(e,a)}g.geometry.dispose(),g.material.dispose(),u.toneMapping=f,u.autoClear=d,e.background=m}_textureToCubeUV(e,t){const r=this._renderer,i=e.mapping===Ql||e.mapping===eu;i?(this._cubemapMaterial===null&&(this._cubemapMaterial=y1()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=g1());const s=i?this._cubemapMaterial:this._equirectMaterial,o=new dr(this._lodPlanes[0],s),a=s.uniforms;a.envMap.value=e;const c=this._cubeSize;Bf(t,0,0,3*c,2*c),r.setRenderTarget(t),r.render(o,ky)}_applyPMREM(e){const t=this._renderer,r=t.autoClear;t.autoClear=!1;for(let i=1;i<this._lodPlanes.length;i++){const s=Math.sqrt(this._sigmas[i]*this._sigmas[i]-this._sigmas[i-1]*this._sigmas[i-1]),o=f1[(i-1)%f1.length];this._blur(e,i-1,i,s,o)}t.autoClear=r}_blur(e,t,r,i,s){const o=this._pingPongRenderTarget;this._halfBlur(e,o,t,r,i,"latitudinal",s),this._halfBlur(o,e,r,r,i,"longitudinal",s)}_halfBlur(e,t,r,i,s,o,a){const c=this._renderer,l=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const u=3,d=new dr(this._lodPlanes[i],l),f=l.uniforms,p=this._sizeLods[r]-1,g=isFinite(s)?Math.PI/(2*p):2*Math.PI/(2*_a-1),b=s/g,m=isFinite(s)?1+Math.floor(u*b):_a;m>_a&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${_a}`);const y=[];let E=0;for(let C=0;C<_a;++C){const R=C/b,_=Math.exp(-R*R/2);y.push(_),C===0?E+=_:C<m&&(E+=2*_)}for(let C=0;C<y.length;C++)y[C]=y[C]/E;f.envMap.value=e.texture,f.samples.value=m,f.weights.value=y,f.latitudinal.value=o==="latitudinal",a&&(f.poleAxis.value=a);const{_lodMax:w}=this;f.dTheta.value=g,f.mipInt.value=w-r;const x=this._sizeLods[i],M=3*x*(i>w-qc?i-w+qc:0),A=4*(this._cubeSize-x);Bf(t,M,A,3*x,2*x),c.setRenderTarget(t),c.render(d,ky)}}function f$(n){const e=[],t=[],r=[];let i=n;const s=n-qc+1+h1.length;for(let o=0;o<s;o++){const a=Math.pow(2,i);t.push(a);let c=1/a;o>n-qc?c=h1[o-n+qc-1]:o===0&&(c=0),r.push(c);const l=1/(a-2),u=-l,d=1+l,f=[u,u,d,u,d,d,u,u,d,d,u,d],p=6,g=6,b=3,m=2,y=1,E=new Float32Array(b*g*p),w=new Float32Array(m*g*p),x=new Float32Array(y*g*p);for(let A=0;A<p;A++){const C=A%3*2/3-1,R=A>2?0:-1,_=[C,R,0,C+2/3,R,0,C+2/3,R+1,0,C,R,0,C+2/3,R+1,0,C,R+1,0];E.set(_,b*g*A),w.set(f,m*g*A);const T=[A,A,A,A,A,A];x.set(T,y*g*A)}const M=new oo;M.setAttribute("position",new Oi(E,b)),M.setAttribute("uv",new Oi(w,m)),M.setAttribute("faceIndex",new Oi(x,y)),e.push(M),i>qc&&i--}return{lodPlanes:e,sizeLods:t,sigmas:r}}function m1(n,e,t){const r=new Wa(n,e,t);return r.texture.mapping=Eg,r.texture.name="PMREM.cubeUv",r.scissorTest=!0,r}function Bf(n,e,t,r,i){n.viewport.set(e,t,r,i),n.scissor.set(e,t,r,i)}function p$(n,e,t){const r=new Float32Array(_a),i=new q(0,1,0);return new qa({name:"SphericalGaussianBlur",defines:{n:_a,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${n}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:r},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:nE(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:Go,depthTest:!1,depthWrite:!1})}function g1(){return new qa({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:nE(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:Go,depthTest:!1,depthWrite:!1})}function y1(){return new qa({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:nE(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:Go,depthTest:!1,depthWrite:!1})}function nE(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function m$(n){let e=new WeakMap,t=null;function r(a){if(a&&a.isTexture){const c=a.mapping,l=c===cv||c===lv,u=c===Ql||c===eu;if(l||u)if(a.isRenderTargetTexture&&a.needsPMREMUpdate===!0){a.needsPMREMUpdate=!1;let d=e.get(a);return t===null&&(t=new p1(n)),d=l?t.fromEquirectangular(a,d):t.fromCubemap(a,d),e.set(a,d),d.texture}else{if(e.has(a))return e.get(a).texture;{const d=a.image;if(l&&d&&d.height>0||u&&d&&i(d)){t===null&&(t=new p1(n));const f=l?t.fromEquirectangular(a):t.fromCubemap(a);return e.set(a,f),a.addEventListener("dispose",s),f.texture}else return null}}}return a}function i(a){let c=0;const l=6;for(let u=0;u<l;u++)a[u]!==void 0&&c++;return c===l}function s(a){const c=a.target;c.removeEventListener("dispose",s);const l=e.get(c);l!==void 0&&(e.delete(c),l.dispose())}function o(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:r,dispose:o}}function g$(n){const e={};function t(r){if(e[r]!==void 0)return e[r];let i;switch(r){case"WEBGL_depth_texture":i=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=n.getExtension(r)}return e[r]=i,i}return{has:function(r){return t(r)!==null},init:function(r){r.isWebGL2?(t("EXT_color_buffer_float"),t("WEBGL_clip_cull_distance")):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture")},get:function(r){const i=t(r);return i===null&&console.warn("THREE.WebGLRenderer: "+r+" extension not supported."),i}}}function y$(n,e,t,r){const i={},s=new WeakMap;function o(d){const f=d.target;f.index!==null&&e.remove(f.index);for(const g in f.attributes)e.remove(f.attributes[g]);for(const g in f.morphAttributes){const b=f.morphAttributes[g];for(let m=0,y=b.length;m<y;m++)e.remove(b[m])}f.removeEventListener("dispose",o),delete i[f.id];const p=s.get(f);p&&(e.remove(p),s.delete(f)),r.releaseStatesOfGeometry(f),f.isInstancedBufferGeometry===!0&&delete f._maxInstanceCount,t.memory.geometries--}function a(d,f){return i[f.id]===!0||(f.addEventListener("dispose",o),i[f.id]=!0,t.memory.geometries++),f}function c(d){const f=d.attributes;for(const g in f)e.update(f[g],n.ARRAY_BUFFER);const p=d.morphAttributes;for(const g in p){const b=p[g];for(let m=0,y=b.length;m<y;m++)e.update(b[m],n.ARRAY_BUFFER)}}function l(d){const f=[],p=d.index,g=d.attributes.position;let b=0;if(p!==null){const E=p.array;b=p.version;for(let w=0,x=E.length;w<x;w+=3){const M=E[w+0],A=E[w+1],C=E[w+2];f.push(M,A,A,C,C,M)}}else if(g!==void 0){const E=g.array;b=g.version;for(let w=0,x=E.length/3-1;w<x;w+=3){const M=w+0,A=w+1,C=w+2;f.push(M,A,A,C,C,M)}}else return;const m=new(WI(f)?JI:jI)(f,1);m.version=b;const y=s.get(d);y&&e.remove(y),s.set(d,m)}function u(d){const f=s.get(d);if(f){const p=d.index;p!==null&&f.version<p.version&&l(d)}else l(d);return s.get(d)}return{get:a,update:c,getWireframeAttribute:u}}function b$(n,e,t,r){const i=r.isWebGL2;let s;function o(p){s=p}let a,c;function l(p){a=p.type,c=p.bytesPerElement}function u(p,g){n.drawElements(s,g,a,p*c),t.update(g,s,1)}function d(p,g,b){if(b===0)return;let m,y;if(i)m=n,y="drawElementsInstanced";else if(m=e.get("ANGLE_instanced_arrays"),y="drawElementsInstancedANGLE",m===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}m[y](s,g,a,p*c,b),t.update(g,s,b)}function f(p,g,b){if(b===0)return;const m=e.get("WEBGL_multi_draw");if(m===null)for(let y=0;y<b;y++)this.render(p[y]/c,g[y]);else{m.multiDrawElementsWEBGL(s,g,0,a,p,0,b);let y=0;for(let E=0;E<b;E++)y+=g[E];t.update(y,s,1)}}this.setMode=o,this.setIndex=l,this.render=u,this.renderInstances=d,this.renderMultiDraw=f}function w$(n){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function r(s,o,a){switch(t.calls++,o){case n.TRIANGLES:t.triangles+=a*(s/3);break;case n.LINES:t.lines+=a*(s/2);break;case n.LINE_STRIP:t.lines+=a*(s-1);break;case n.LINE_LOOP:t.lines+=a*s;break;case n.POINTS:t.points+=a*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function i(){t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:i,update:r}}function v$(n,e){return n[0]-e[0]}function _$(n,e){return Math.abs(e[1])-Math.abs(n[1])}function E$(n,e,t){const r={},i=new Float32Array(8),s=new WeakMap,o=new mn,a=[];for(let l=0;l<8;l++)a[l]=[l,0];function c(l,u,d){const f=l.morphTargetInfluences;if(e.isWebGL2===!0){const p=u.morphAttributes.position||u.morphAttributes.normal||u.morphAttributes.color,g=p!==void 0?p.length:0;let b=s.get(u);if(b===void 0||b.count!==g){let v=function(){k.dispose(),s.delete(u),u.removeEventListener("dispose",v)};b!==void 0&&b.texture.dispose();const E=u.morphAttributes.position!==void 0,w=u.morphAttributes.normal!==void 0,x=u.morphAttributes.color!==void 0,M=u.morphAttributes.position||[],A=u.morphAttributes.normal||[],C=u.morphAttributes.color||[];let R=0;E===!0&&(R=1),w===!0&&(R=2),x===!0&&(R=3);let _=u.attributes.position.count*R,T=1;_>e.maxTextureSize&&(T=Math.ceil(_/e.maxTextureSize),_=e.maxTextureSize);const F=new Float32Array(_*T*4*g),k=new XI(F,_,T,g);k.type=Bo,k.needsUpdate=!0;const z=R*4;for(let S=0;S<g;S++){const P=M[S],U=A[S],B=C[S],O=_*T*4*S;for(let V=0;V<P.count;V++){const $=V*z;E===!0&&(o.fromBufferAttribute(P,V),F[O+$+0]=o.x,F[O+$+1]=o.y,F[O+$+2]=o.z,F[O+$+3]=0),w===!0&&(o.fromBufferAttribute(U,V),F[O+$+4]=o.x,F[O+$+5]=o.y,F[O+$+6]=o.z,F[O+$+7]=0),x===!0&&(o.fromBufferAttribute(B,V),F[O+$+8]=o.x,F[O+$+9]=o.y,F[O+$+10]=o.z,F[O+$+11]=B.itemSize===4?o.w:1)}}b={count:g,texture:k,size:new Ye(_,T)},s.set(u,b),u.addEventListener("dispose",v)}let m=0;for(let E=0;E<f.length;E++)m+=f[E];const y=u.morphTargetsRelative?1:1-m;d.getUniforms().setValue(n,"morphTargetBaseInfluence",y),d.getUniforms().setValue(n,"morphTargetInfluences",f),d.getUniforms().setValue(n,"morphTargetsTexture",b.texture,t),d.getUniforms().setValue(n,"morphTargetsTextureSize",b.size)}else{const p=f===void 0?0:f.length;let g=r[u.id];if(g===void 0||g.length!==p){g=[];for(let w=0;w<p;w++)g[w]=[w,0];r[u.id]=g}for(let w=0;w<p;w++){const x=g[w];x[0]=w,x[1]=f[w]}g.sort(_$);for(let w=0;w<8;w++)w<p&&g[w][1]?(a[w][0]=g[w][0],a[w][1]=g[w][1]):(a[w][0]=Number.MAX_SAFE_INTEGER,a[w][1]=0);a.sort(v$);const b=u.morphAttributes.position,m=u.morphAttributes.normal;let y=0;for(let w=0;w<8;w++){const x=a[w],M=x[0],A=x[1];M!==Number.MAX_SAFE_INTEGER&&A?(b&&u.getAttribute("morphTarget"+w)!==b[M]&&u.setAttribute("morphTarget"+w,b[M]),m&&u.getAttribute("morphNormal"+w)!==m[M]&&u.setAttribute("morphNormal"+w,m[M]),i[w]=A,y+=A):(b&&u.hasAttribute("morphTarget"+w)===!0&&u.deleteAttribute("morphTarget"+w),m&&u.hasAttribute("morphNormal"+w)===!0&&u.deleteAttribute("morphNormal"+w),i[w]=0)}const E=u.morphTargetsRelative?1:1-y;d.getUniforms().setValue(n,"morphTargetBaseInfluence",E),d.getUniforms().setValue(n,"morphTargetInfluences",i)}}return{update:c}}function S$(n,e,t,r){let i=new WeakMap;function s(c){const l=r.render.frame,u=c.geometry,d=e.get(c,u);if(i.get(d)!==l&&(e.update(d),i.set(d,l)),c.isInstancedMesh&&(c.hasEventListener("dispose",a)===!1&&c.addEventListener("dispose",a),i.get(c)!==l&&(t.update(c.instanceMatrix,n.ARRAY_BUFFER),c.instanceColor!==null&&t.update(c.instanceColor,n.ARRAY_BUFFER),i.set(c,l))),c.isSkinnedMesh){const f=c.skeleton;i.get(f)!==l&&(f.update(),i.set(f,l))}return d}function o(){i=new WeakMap}function a(c){const l=c.target;l.removeEventListener("dispose",a),t.remove(l.instanceMatrix),l.instanceColor!==null&&t.remove(l.instanceColor)}return{update:s,dispose:o}}class rP extends Sr{constructor(e,t,r,i,s,o,a,c,l,u){if(u=u!==void 0?u:$a,u!==$a&&u!==tu)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");r===void 0&&u===$a&&(r=Uo),r===void 0&&u===tu&&(r=ka),super(null,i,s,o,a,c,u,r,l),this.isDepthTexture=!0,this.image={width:e,height:t},this.magFilter=a!==void 0?a:cr,this.minFilter=c!==void 0?c:cr,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(e){return super.copy(e),this.compareFunction=e.compareFunction,this}toJSON(e){const t=super.toJSON(e);return this.compareFunction!==null&&(t.compareFunction=this.compareFunction),t}}const iP=new Sr,sP=new rP(1,1);sP.compareFunction=GI;const oP=new XI,aP=new s4,cP=new tP,b1=[],w1=[],v1=new Float32Array(16),_1=new Float32Array(9),E1=new Float32Array(4);function Ru(n,e,t){const r=n[0];if(r<=0||r>0)return n;const i=e*t;let s=b1[i];if(s===void 0&&(s=new Float32Array(i),b1[i]=s),e!==0){r.toArray(s,0);for(let o=1,a=0;o!==e;++o)a+=t,n[o].toArray(s,a)}return s}function an(n,e){if(n.length!==e.length)return!1;for(let t=0,r=n.length;t<r;t++)if(n[t]!==e[t])return!1;return!0}function cn(n,e){for(let t=0,r=e.length;t<r;t++)n[t]=e[t]}function Ag(n,e){let t=w1[e];t===void 0&&(t=new Int32Array(e),w1[e]=t);for(let r=0;r!==e;++r)t[r]=n.allocateTextureUnit();return t}function x$(n,e){const t=this.cache;t[0]!==e&&(n.uniform1f(this.addr,e),t[0]=e)}function T$(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(an(t,e))return;n.uniform2fv(this.addr,e),cn(t,e)}}function A$(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(n.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(an(t,e))return;n.uniform3fv(this.addr,e),cn(t,e)}}function M$(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(an(t,e))return;n.uniform4fv(this.addr,e),cn(t,e)}}function C$(n,e){const t=this.cache,r=e.elements;if(r===void 0){if(an(t,e))return;n.uniformMatrix2fv(this.addr,!1,e),cn(t,e)}else{if(an(t,r))return;E1.set(r),n.uniformMatrix2fv(this.addr,!1,E1),cn(t,r)}}function I$(n,e){const t=this.cache,r=e.elements;if(r===void 0){if(an(t,e))return;n.uniformMatrix3fv(this.addr,!1,e),cn(t,e)}else{if(an(t,r))return;_1.set(r),n.uniformMatrix3fv(this.addr,!1,_1),cn(t,r)}}function P$(n,e){const t=this.cache,r=e.elements;if(r===void 0){if(an(t,e))return;n.uniformMatrix4fv(this.addr,!1,e),cn(t,e)}else{if(an(t,r))return;v1.set(r),n.uniformMatrix4fv(this.addr,!1,v1),cn(t,r)}}function D$(n,e){const t=this.cache;t[0]!==e&&(n.uniform1i(this.addr,e),t[0]=e)}function R$(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2i(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(an(t,e))return;n.uniform2iv(this.addr,e),cn(t,e)}}function L$(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3i(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(an(t,e))return;n.uniform3iv(this.addr,e),cn(t,e)}}function O$(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4i(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(an(t,e))return;n.uniform4iv(this.addr,e),cn(t,e)}}function N$(n,e){const t=this.cache;t[0]!==e&&(n.uniform1ui(this.addr,e),t[0]=e)}function U$(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2ui(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(an(t,e))return;n.uniform2uiv(this.addr,e),cn(t,e)}}function B$(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3ui(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(an(t,e))return;n.uniform3uiv(this.addr,e),cn(t,e)}}function k$(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4ui(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(an(t,e))return;n.uniform4uiv(this.addr,e),cn(t,e)}}function $$(n,e,t){const r=this.cache,i=t.allocateTextureUnit();r[0]!==i&&(n.uniform1i(this.addr,i),r[0]=i);const s=this.type===n.SAMPLER_2D_SHADOW?sP:iP;t.setTexture2D(e||s,i)}function F$(n,e,t){const r=this.cache,i=t.allocateTextureUnit();r[0]!==i&&(n.uniform1i(this.addr,i),r[0]=i),t.setTexture3D(e||aP,i)}function z$(n,e,t){const r=this.cache,i=t.allocateTextureUnit();r[0]!==i&&(n.uniform1i(this.addr,i),r[0]=i),t.setTextureCube(e||cP,i)}function V$(n,e,t){const r=this.cache,i=t.allocateTextureUnit();r[0]!==i&&(n.uniform1i(this.addr,i),r[0]=i),t.setTexture2DArray(e||oP,i)}function H$(n){switch(n){case 5126:return x$;case 35664:return T$;case 35665:return A$;case 35666:return M$;case 35674:return C$;case 35675:return I$;case 35676:return P$;case 5124:case 35670:return D$;case 35667:case 35671:return R$;case 35668:case 35672:return L$;case 35669:case 35673:return O$;case 5125:return N$;case 36294:return U$;case 36295:return B$;case 36296:return k$;case 35678:case 36198:case 36298:case 36306:case 35682:return $$;case 35679:case 36299:case 36307:return F$;case 35680:case 36300:case 36308:case 36293:return z$;case 36289:case 36303:case 36311:case 36292:return V$}}function G$(n,e){n.uniform1fv(this.addr,e)}function W$(n,e){const t=Ru(e,this.size,2);n.uniform2fv(this.addr,t)}function q$(n,e){const t=Ru(e,this.size,3);n.uniform3fv(this.addr,t)}function K$(n,e){const t=Ru(e,this.size,4);n.uniform4fv(this.addr,t)}function X$(n,e){const t=Ru(e,this.size,4);n.uniformMatrix2fv(this.addr,!1,t)}function Y$(n,e){const t=Ru(e,this.size,9);n.uniformMatrix3fv(this.addr,!1,t)}function Z$(n,e){const t=Ru(e,this.size,16);n.uniformMatrix4fv(this.addr,!1,t)}function j$(n,e){n.uniform1iv(this.addr,e)}function J$(n,e){n.uniform2iv(this.addr,e)}function Q$(n,e){n.uniform3iv(this.addr,e)}function eF(n,e){n.uniform4iv(this.addr,e)}function tF(n,e){n.uniform1uiv(this.addr,e)}function nF(n,e){n.uniform2uiv(this.addr,e)}function rF(n,e){n.uniform3uiv(this.addr,e)}function iF(n,e){n.uniform4uiv(this.addr,e)}function sF(n,e,t){const r=this.cache,i=e.length,s=Ag(t,i);an(r,s)||(n.uniform1iv(this.addr,s),cn(r,s));for(let o=0;o!==i;++o)t.setTexture2D(e[o]||iP,s[o])}function oF(n,e,t){const r=this.cache,i=e.length,s=Ag(t,i);an(r,s)||(n.uniform1iv(this.addr,s),cn(r,s));for(let o=0;o!==i;++o)t.setTexture3D(e[o]||aP,s[o])}function aF(n,e,t){const r=this.cache,i=e.length,s=Ag(t,i);an(r,s)||(n.uniform1iv(this.addr,s),cn(r,s));for(let o=0;o!==i;++o)t.setTextureCube(e[o]||cP,s[o])}function cF(n,e,t){const r=this.cache,i=e.length,s=Ag(t,i);an(r,s)||(n.uniform1iv(this.addr,s),cn(r,s));for(let o=0;o!==i;++o)t.setTexture2DArray(e[o]||oP,s[o])}function lF(n){switch(n){case 5126:return G$;case 35664:return W$;case 35665:return q$;case 35666:return K$;case 35674:return X$;case 35675:return Y$;case 35676:return Z$;case 5124:case 35670:return j$;case 35667:case 35671:return J$;case 35668:case 35672:return Q$;case 35669:case 35673:return eF;case 5125:return tF;case 36294:return nF;case 36295:return rF;case 36296:return iF;case 35678:case 36198:case 36298:case 36306:case 35682:return sF;case 35679:case 36299:case 36307:return oF;case 35680:case 36300:case 36308:case 36293:return aF;case 36289:case 36303:case 36311:case 36292:return cF}}class uF{constructor(e,t,r){this.id=e,this.addr=r,this.cache=[],this.type=t.type,this.setValue=H$(t.type)}}class hF{constructor(e,t,r){this.id=e,this.addr=r,this.cache=[],this.type=t.type,this.size=t.size,this.setValue=lF(t.type)}}class dF{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,r){const i=this.seq;for(let s=0,o=i.length;s!==o;++s){const a=i[s];a.setValue(e,t[a.id],r)}}}const Vy=/(\w+)(\])?(\[|\.)?/g;function S1(n,e){n.seq.push(e),n.map[e.id]=e}function fF(n,e,t){const r=n.name,i=r.length;for(Vy.lastIndex=0;;){const s=Vy.exec(r),o=Vy.lastIndex;let a=s[1];const c=s[2]==="]",l=s[3];if(c&&(a=a|0),l===void 0||l==="["&&o+2===i){S1(t,l===void 0?new uF(a,n,e):new hF(a,n,e));break}else{let d=t.map[a];d===void 0&&(d=new dF(a),S1(t,d)),t=d}}}class Dp{constructor(e,t){this.seq=[],this.map={};const r=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);for(let i=0;i<r;++i){const s=e.getActiveUniform(t,i),o=e.getUniformLocation(t,s.name);fF(s,o,this)}}setValue(e,t,r,i){const s=this.map[t];s!==void 0&&s.setValue(e,r,i)}setOptional(e,t,r){const i=t[r];i!==void 0&&this.setValue(e,r,i)}static upload(e,t,r,i){for(let s=0,o=t.length;s!==o;++s){const a=t[s],c=r[a.id];c.needsUpdate!==!1&&a.setValue(e,c.value,i)}}static seqWithValue(e,t){const r=[];for(let i=0,s=e.length;i!==s;++i){const o=e[i];o.id in t&&r.push(o)}return r}}function x1(n,e,t){const r=n.createShader(e);return n.shaderSource(r,t),n.compileShader(r),r}const pF=37297;let mF=0;function gF(n,e){const t=n.split(`
`),r=[],i=Math.max(e-6,0),s=Math.min(e+6,t.length);for(let o=i;o<s;o++){const a=o+1;r.push(`${a===e?">":" "} ${a}: ${t[o]}`)}return r.join(`
`)}function yF(n){const e=bt.getPrimaries(bt.workingColorSpace),t=bt.getPrimaries(n);let r;switch(e===t?r="":e===im&&t===rm?r="LinearDisplayP3ToLinearSRGB":e===rm&&t===im&&(r="LinearSRGBToLinearDisplayP3"),n){case to:case Sg:return[r,"LinearTransferOETF"];case _n:case J_:return[r,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space:",n),[r,"LinearTransferOETF"]}}function T1(n,e,t){const r=n.getShaderParameter(e,n.COMPILE_STATUS),i=n.getShaderInfoLog(e).trim();if(r&&i==="")return"";const s=/ERROR: 0:(\d+)/.exec(i);if(s){const o=parseInt(s[1]);return t.toUpperCase()+`

`+i+`

`+gF(n.getShaderSource(e),o)}else return i}function bF(n,e){const t=yF(e);return`vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`}function wF(n,e){let t;switch(e){case CB:t="Linear";break;case IB:t="Reinhard";break;case PB:t="OptimizedCineon";break;case DB:t="ACESFilmic";break;case LB:t="AgX";break;case RB:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+n+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function vF(n){return[n.extensionDerivatives||n.envMapCubeUVHeight||n.bumpMap||n.normalMapTangentSpace||n.clearcoatNormalMap||n.flatShading||n.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(n.extensionFragDepth||n.logarithmicDepthBuffer)&&n.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",n.extensionDrawBuffers&&n.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(n.extensionShaderTextureLOD||n.envMap||n.transmission)&&n.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Kc).join(`
`)}function _F(n){return[n.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":""].filter(Kc).join(`
`)}function EF(n){const e=[];for(const t in n){const r=n[t];r!==!1&&e.push("#define "+t+" "+r)}return e.join(`
`)}function SF(n,e){const t={},r=n.getProgramParameter(e,n.ACTIVE_ATTRIBUTES);for(let i=0;i<r;i++){const s=n.getActiveAttrib(e,i),o=s.name;let a=1;s.type===n.FLOAT_MAT2&&(a=2),s.type===n.FLOAT_MAT3&&(a=3),s.type===n.FLOAT_MAT4&&(a=4),t[o]={type:s.type,location:n.getAttribLocation(e,o),locationSize:a}}return t}function Kc(n){return n!==""}function A1(n,e){const t=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return n.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,t).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function M1(n,e){return n.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const xF=/^[ \t]*#include +<([\w\d./]+)>/gm;function mv(n){return n.replace(xF,AF)}const TF=new Map([["encodings_fragment","colorspace_fragment"],["encodings_pars_fragment","colorspace_pars_fragment"],["output_fragment","opaque_fragment"]]);function AF(n,e){let t=We[e];if(t===void 0){const r=TF.get(e);if(r!==void 0)t=We[r],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',e,r);else throw new Error("Can not resolve #include <"+e+">")}return mv(t)}const MF=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function C1(n){return n.replace(MF,CF)}function CF(n,e,t,r){let i="";for(let s=parseInt(e);s<parseInt(t);s++)i+=r.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return i}function I1(n){let e="precision "+n.precision+` float;
precision `+n.precision+" int;";return n.precision==="highp"?e+=`
#define HIGH_PRECISION`:n.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:n.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function IF(n){let e="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===RI?e="SHADOWMAP_TYPE_PCF":n.shadowMapType===LI?e="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===As&&(e="SHADOWMAP_TYPE_VSM"),e}function PF(n){let e="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case Ql:case eu:e="ENVMAP_TYPE_CUBE";break;case Eg:e="ENVMAP_TYPE_CUBE_UV";break}return e}function DF(n){let e="ENVMAP_MODE_REFLECTION";if(n.envMap)switch(n.envMapMode){case eu:e="ENVMAP_MODE_REFRACTION";break}return e}function RF(n){let e="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case Z_:e="ENVMAP_BLENDING_MULTIPLY";break;case AB:e="ENVMAP_BLENDING_MIX";break;case MB:e="ENVMAP_BLENDING_ADD";break}return e}function LF(n){const e=n.envMapCubeUVHeight;if(e===null)return null;const t=Math.log2(e)-2,r=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),112)),texelHeight:r,maxMip:t}}function OF(n,e,t,r){const i=n.getContext(),s=t.defines;let o=t.vertexShader,a=t.fragmentShader;const c=IF(t),l=PF(t),u=DF(t),d=RF(t),f=LF(t),p=t.isWebGL2?"":vF(t),g=_F(t),b=EF(s),m=i.createProgram();let y,E,w=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(y=["#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,b].filter(Kc).join(`
`),y.length>0&&(y+=`
`),E=[p,"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,b].filter(Kc).join(`
`),E.length>0&&(E+=`
`)):(y=[I1(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,b,t.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",t.batching?"#define USE_BATCHING":"",t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+u:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.displacementMap?"#define USE_DISPLACEMENTMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.mapUv?"#define MAP_UV "+t.mapUv:"",t.alphaMapUv?"#define ALPHAMAP_UV "+t.alphaMapUv:"",t.lightMapUv?"#define LIGHTMAP_UV "+t.lightMapUv:"",t.aoMapUv?"#define AOMAP_UV "+t.aoMapUv:"",t.emissiveMapUv?"#define EMISSIVEMAP_UV "+t.emissiveMapUv:"",t.bumpMapUv?"#define BUMPMAP_UV "+t.bumpMapUv:"",t.normalMapUv?"#define NORMALMAP_UV "+t.normalMapUv:"",t.displacementMapUv?"#define DISPLACEMENTMAP_UV "+t.displacementMapUv:"",t.metalnessMapUv?"#define METALNESSMAP_UV "+t.metalnessMapUv:"",t.roughnessMapUv?"#define ROUGHNESSMAP_UV "+t.roughnessMapUv:"",t.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+t.anisotropyMapUv:"",t.clearcoatMapUv?"#define CLEARCOATMAP_UV "+t.clearcoatMapUv:"",t.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+t.clearcoatNormalMapUv:"",t.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+t.clearcoatRoughnessMapUv:"",t.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+t.iridescenceMapUv:"",t.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+t.iridescenceThicknessMapUv:"",t.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+t.sheenColorMapUv:"",t.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+t.sheenRoughnessMapUv:"",t.specularMapUv?"#define SPECULARMAP_UV "+t.specularMapUv:"",t.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+t.specularColorMapUv:"",t.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+t.specularIntensityMapUv:"",t.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+t.transmissionMapUv:"",t.thicknessMapUv?"#define THICKNESSMAP_UV "+t.thicknessMapUv:"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors&&t.isWebGL2?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+c:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.useLegacyLights?"#define LEGACY_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Kc).join(`
`),E=[p,I1(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,b,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+l:"",t.envMap?"#define "+u:"",t.envMap?"#define "+d:"",f?"#define CUBEUV_TEXEL_WIDTH "+f.texelWidth:"",f?"#define CUBEUV_TEXEL_HEIGHT "+f.texelHeight:"",f?"#define CUBEUV_MAX_MIP "+f.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescence?"#define USE_IRIDESCENCE":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+c:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.useLegacyLights?"#define LEGACY_LIGHTS":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Wo?"#define TONE_MAPPING":"",t.toneMapping!==Wo?We.tonemapping_pars_fragment:"",t.toneMapping!==Wo?wF("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",We.colorspace_pars_fragment,bF("linearToOutputTexel",t.outputColorSpace),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(Kc).join(`
`)),o=mv(o),o=A1(o,t),o=M1(o,t),a=mv(a),a=A1(a,t),a=M1(a,t),o=C1(o),a=C1(a),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(w=`#version 300 es
`,y=[g,"precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+y,E=["precision mediump sampler2DArray;","#define varying in",t.glslVersion===Kx?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===Kx?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+E);const x=w+y+o,M=w+E+a,A=x1(i,i.VERTEX_SHADER,x),C=x1(i,i.FRAGMENT_SHADER,M);i.attachShader(m,A),i.attachShader(m,C),t.index0AttributeName!==void 0?i.bindAttribLocation(m,0,t.index0AttributeName):t.morphTargets===!0&&i.bindAttribLocation(m,0,"position"),i.linkProgram(m);function R(k){if(n.debug.checkShaderErrors){const z=i.getProgramInfoLog(m).trim(),v=i.getShaderInfoLog(A).trim(),S=i.getShaderInfoLog(C).trim();let P=!0,U=!0;if(i.getProgramParameter(m,i.LINK_STATUS)===!1)if(P=!1,typeof n.debug.onShaderError=="function")n.debug.onShaderError(i,m,A,C);else{const B=T1(i,A,"vertex"),O=T1(i,C,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(m,i.VALIDATE_STATUS)+`

Program Info Log: `+z+`
`+B+`
`+O)}else z!==""?console.warn("THREE.WebGLProgram: Program Info Log:",z):(v===""||S==="")&&(U=!1);U&&(k.diagnostics={runnable:P,programLog:z,vertexShader:{log:v,prefix:y},fragmentShader:{log:S,prefix:E}})}i.deleteShader(A),i.deleteShader(C),_=new Dp(i,m),T=SF(i,m)}let _;this.getUniforms=function(){return _===void 0&&R(this),_};let T;this.getAttributes=function(){return T===void 0&&R(this),T};let F=t.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return F===!1&&(F=i.getProgramParameter(m,pF)),F},this.destroy=function(){r.releaseStatesOfProgram(this),i.deleteProgram(m),this.program=void 0},this.type=t.shaderType,this.name=t.shaderName,this.id=mF++,this.cacheKey=e,this.usedTimes=1,this.program=m,this.vertexShader=A,this.fragmentShader=C,this}let NF=0;class UF{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,r=e.fragmentShader,i=this._getShaderStage(t),s=this._getShaderStage(r),o=this._getShaderCacheForMaterial(e);return o.has(i)===!1&&(o.add(i),i.usedTimes++),o.has(s)===!1&&(o.add(s),s.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const r of t)r.usedTimes--,r.usedTimes===0&&this.shaderCache.delete(r.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;let r=t.get(e);return r===void 0&&(r=new Set,t.set(e,r)),r}_getShaderStage(e){const t=this.shaderCache;let r=t.get(e);return r===void 0&&(r=new BF(e),t.set(e,r)),r}}class BF{constructor(e){this.id=NF++,this.code=e,this.usedTimes=0}}function kF(n,e,t,r,i,s,o){const a=new YI,c=new UF,l=[],u=i.isWebGL2,d=i.logarithmicDepthBuffer,f=i.vertexTextures;let p=i.precision;const g={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function b(_){return _===0?"uv":`uv${_}`}function m(_,T,F,k,z){const v=k.fog,S=z.geometry,P=_.isMeshStandardMaterial?k.environment:null,U=(_.isMeshStandardMaterial?t:e).get(_.envMap||P),B=U&&U.mapping===Eg?U.image.height:null,O=g[_.type];_.precision!==null&&(p=i.getMaxPrecision(_.precision),p!==_.precision&&console.warn("THREE.WebGLProgram.getParameters:",_.precision,"not supported, using",p,"instead."));const V=S.morphAttributes.position||S.morphAttributes.normal||S.morphAttributes.color,$=V!==void 0?V.length:0;let W=0;S.morphAttributes.position!==void 0&&(W=1),S.morphAttributes.normal!==void 0&&(W=2),S.morphAttributes.color!==void 0&&(W=3);let H,Y,te,j;if(O){const nr=es[O];H=nr.vertexShader,Y=nr.fragmentShader}else H=_.vertexShader,Y=_.fragmentShader,c.update(_),te=c.getVertexShaderID(_),j=c.getFragmentShaderID(_);const re=n.getRenderTarget(),le=z.isInstancedMesh===!0,fe=z.isBatchedMesh===!0,se=!!_.map,ve=!!_.matcap,X=!!U,Ut=!!_.aoMap,Ce=!!_.lightMap,ke=!!_.bumpMap,xe=!!_.normalMap,kt=!!_.displacementMap,qe=!!_.emissiveMap,N=!!_.metalnessMap,I=!!_.roughnessMap,J=_.anisotropy>0,ae=_.clearcoat>0,oe=_.iridescence>0,ce=_.sheen>0,Te=_.transmission>0,we=J&&!!_.anisotropyMap,Ee=ae&&!!_.clearcoatMap,Ue=ae&&!!_.clearcoatNormalMap,Ke=ae&&!!_.clearcoatRoughnessMap,ie=oe&&!!_.iridescenceMap,yt=oe&&!!_.iridescenceThicknessMap,et=ce&&!!_.sheenColorMap,Fe=ce&&!!_.sheenRoughnessMap,Ie=!!_.specularMap,Se=!!_.specularColorMap,Ge=!!_.specularIntensityMap,gt=Te&&!!_.transmissionMap,Vt=Te&&!!_.thicknessMap,Ze=!!_.gradientMap,he=!!_.alphaMap,G=_.alphaTest>0,ye=!!_.alphaHash,be=!!_.extensions,Be=!!S.attributes.uv1,Re=!!S.attributes.uv2,At=!!S.attributes.uv3;let Mt=Wo;return _.toneMapped&&(re===null||re.isXRRenderTarget===!0)&&(Mt=n.toneMapping),{isWebGL2:u,shaderID:O,shaderType:_.type,shaderName:_.name,vertexShader:H,fragmentShader:Y,defines:_.defines,customVertexShaderID:te,customFragmentShaderID:j,isRawShaderMaterial:_.isRawShaderMaterial===!0,glslVersion:_.glslVersion,precision:p,batching:fe,instancing:le,instancingColor:le&&z.instanceColor!==null,supportsVertexTextures:f,outputColorSpace:re===null?n.outputColorSpace:re.isXRRenderTarget===!0?re.texture.colorSpace:to,map:se,matcap:ve,envMap:X,envMapMode:X&&U.mapping,envMapCubeUVHeight:B,aoMap:Ut,lightMap:Ce,bumpMap:ke,normalMap:xe,displacementMap:f&&kt,emissiveMap:qe,normalMapObjectSpace:xe&&_.normalMapType===WB,normalMapTangentSpace:xe&&_.normalMapType===HI,metalnessMap:N,roughnessMap:I,anisotropy:J,anisotropyMap:we,clearcoat:ae,clearcoatMap:Ee,clearcoatNormalMap:Ue,clearcoatRoughnessMap:Ke,iridescence:oe,iridescenceMap:ie,iridescenceThicknessMap:yt,sheen:ce,sheenColorMap:et,sheenRoughnessMap:Fe,specularMap:Ie,specularColorMap:Se,specularIntensityMap:Ge,transmission:Te,transmissionMap:gt,thicknessMap:Vt,gradientMap:Ze,opaque:_.transparent===!1&&_.blending===al,alphaMap:he,alphaTest:G,alphaHash:ye,combine:_.combine,mapUv:se&&b(_.map.channel),aoMapUv:Ut&&b(_.aoMap.channel),lightMapUv:Ce&&b(_.lightMap.channel),bumpMapUv:ke&&b(_.bumpMap.channel),normalMapUv:xe&&b(_.normalMap.channel),displacementMapUv:kt&&b(_.displacementMap.channel),emissiveMapUv:qe&&b(_.emissiveMap.channel),metalnessMapUv:N&&b(_.metalnessMap.channel),roughnessMapUv:I&&b(_.roughnessMap.channel),anisotropyMapUv:we&&b(_.anisotropyMap.channel),clearcoatMapUv:Ee&&b(_.clearcoatMap.channel),clearcoatNormalMapUv:Ue&&b(_.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:Ke&&b(_.clearcoatRoughnessMap.channel),iridescenceMapUv:ie&&b(_.iridescenceMap.channel),iridescenceThicknessMapUv:yt&&b(_.iridescenceThicknessMap.channel),sheenColorMapUv:et&&b(_.sheenColorMap.channel),sheenRoughnessMapUv:Fe&&b(_.sheenRoughnessMap.channel),specularMapUv:Ie&&b(_.specularMap.channel),specularColorMapUv:Se&&b(_.specularColorMap.channel),specularIntensityMapUv:Ge&&b(_.specularIntensityMap.channel),transmissionMapUv:gt&&b(_.transmissionMap.channel),thicknessMapUv:Vt&&b(_.thicknessMap.channel),alphaMapUv:he&&b(_.alphaMap.channel),vertexTangents:!!S.attributes.tangent&&(xe||J),vertexColors:_.vertexColors,vertexAlphas:_.vertexColors===!0&&!!S.attributes.color&&S.attributes.color.itemSize===4,vertexUv1s:Be,vertexUv2s:Re,vertexUv3s:At,pointsUvs:z.isPoints===!0&&!!S.attributes.uv&&(se||he),fog:!!v,useFog:_.fog===!0,fogExp2:v&&v.isFogExp2,flatShading:_.flatShading===!0,sizeAttenuation:_.sizeAttenuation===!0,logarithmicDepthBuffer:d,skinning:z.isSkinnedMesh===!0,morphTargets:S.morphAttributes.position!==void 0,morphNormals:S.morphAttributes.normal!==void 0,morphColors:S.morphAttributes.color!==void 0,morphTargetsCount:$,morphTextureStride:W,numDirLights:T.directional.length,numPointLights:T.point.length,numSpotLights:T.spot.length,numSpotLightMaps:T.spotLightMap.length,numRectAreaLights:T.rectArea.length,numHemiLights:T.hemi.length,numDirLightShadows:T.directionalShadowMap.length,numPointLightShadows:T.pointShadowMap.length,numSpotLightShadows:T.spotShadowMap.length,numSpotLightShadowsWithMaps:T.numSpotLightShadowsWithMaps,numLightProbes:T.numLightProbes,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:_.dithering,shadowMapEnabled:n.shadowMap.enabled&&F.length>0,shadowMapType:n.shadowMap.type,toneMapping:Mt,useLegacyLights:n._useLegacyLights,decodeVideoTexture:se&&_.map.isVideoTexture===!0&&bt.getTransfer(_.map.colorSpace)===Dt,premultipliedAlpha:_.premultipliedAlpha,doubleSided:_.side===ns,flipSided:_.side===Er,useDepthPacking:_.depthPacking>=0,depthPacking:_.depthPacking||0,index0AttributeName:_.index0AttributeName,extensionDerivatives:be&&_.extensions.derivatives===!0,extensionFragDepth:be&&_.extensions.fragDepth===!0,extensionDrawBuffers:be&&_.extensions.drawBuffers===!0,extensionShaderTextureLOD:be&&_.extensions.shaderTextureLOD===!0,extensionClipCullDistance:be&&_.extensions.clipCullDistance&&r.has("WEBGL_clip_cull_distance"),rendererExtensionFragDepth:u||r.has("EXT_frag_depth"),rendererExtensionDrawBuffers:u||r.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:u||r.has("EXT_shader_texture_lod"),rendererExtensionParallelShaderCompile:r.has("KHR_parallel_shader_compile"),customProgramCacheKey:_.customProgramCacheKey()}}function y(_){const T=[];if(_.shaderID?T.push(_.shaderID):(T.push(_.customVertexShaderID),T.push(_.customFragmentShaderID)),_.defines!==void 0)for(const F in _.defines)T.push(F),T.push(_.defines[F]);return _.isRawShaderMaterial===!1&&(E(T,_),w(T,_),T.push(n.outputColorSpace)),T.push(_.customProgramCacheKey),T.join()}function E(_,T){_.push(T.precision),_.push(T.outputColorSpace),_.push(T.envMapMode),_.push(T.envMapCubeUVHeight),_.push(T.mapUv),_.push(T.alphaMapUv),_.push(T.lightMapUv),_.push(T.aoMapUv),_.push(T.bumpMapUv),_.push(T.normalMapUv),_.push(T.displacementMapUv),_.push(T.emissiveMapUv),_.push(T.metalnessMapUv),_.push(T.roughnessMapUv),_.push(T.anisotropyMapUv),_.push(T.clearcoatMapUv),_.push(T.clearcoatNormalMapUv),_.push(T.clearcoatRoughnessMapUv),_.push(T.iridescenceMapUv),_.push(T.iridescenceThicknessMapUv),_.push(T.sheenColorMapUv),_.push(T.sheenRoughnessMapUv),_.push(T.specularMapUv),_.push(T.specularColorMapUv),_.push(T.specularIntensityMapUv),_.push(T.transmissionMapUv),_.push(T.thicknessMapUv),_.push(T.combine),_.push(T.fogExp2),_.push(T.sizeAttenuation),_.push(T.morphTargetsCount),_.push(T.morphAttributeCount),_.push(T.numDirLights),_.push(T.numPointLights),_.push(T.numSpotLights),_.push(T.numSpotLightMaps),_.push(T.numHemiLights),_.push(T.numRectAreaLights),_.push(T.numDirLightShadows),_.push(T.numPointLightShadows),_.push(T.numSpotLightShadows),_.push(T.numSpotLightShadowsWithMaps),_.push(T.numLightProbes),_.push(T.shadowMapType),_.push(T.toneMapping),_.push(T.numClippingPlanes),_.push(T.numClipIntersection),_.push(T.depthPacking)}function w(_,T){a.disableAll(),T.isWebGL2&&a.enable(0),T.supportsVertexTextures&&a.enable(1),T.instancing&&a.enable(2),T.instancingColor&&a.enable(3),T.matcap&&a.enable(4),T.envMap&&a.enable(5),T.normalMapObjectSpace&&a.enable(6),T.normalMapTangentSpace&&a.enable(7),T.clearcoat&&a.enable(8),T.iridescence&&a.enable(9),T.alphaTest&&a.enable(10),T.vertexColors&&a.enable(11),T.vertexAlphas&&a.enable(12),T.vertexUv1s&&a.enable(13),T.vertexUv2s&&a.enable(14),T.vertexUv3s&&a.enable(15),T.vertexTangents&&a.enable(16),T.anisotropy&&a.enable(17),T.alphaHash&&a.enable(18),T.batching&&a.enable(19),_.push(a.mask),a.disableAll(),T.fog&&a.enable(0),T.useFog&&a.enable(1),T.flatShading&&a.enable(2),T.logarithmicDepthBuffer&&a.enable(3),T.skinning&&a.enable(4),T.morphTargets&&a.enable(5),T.morphNormals&&a.enable(6),T.morphColors&&a.enable(7),T.premultipliedAlpha&&a.enable(8),T.shadowMapEnabled&&a.enable(9),T.useLegacyLights&&a.enable(10),T.doubleSided&&a.enable(11),T.flipSided&&a.enable(12),T.useDepthPacking&&a.enable(13),T.dithering&&a.enable(14),T.transmission&&a.enable(15),T.sheen&&a.enable(16),T.opaque&&a.enable(17),T.pointsUvs&&a.enable(18),T.decodeVideoTexture&&a.enable(19),_.push(a.mask)}function x(_){const T=g[_.type];let F;if(T){const k=es[T];F=w4.clone(k.uniforms)}else F=_.uniforms;return F}function M(_,T){let F;for(let k=0,z=l.length;k<z;k++){const v=l[k];if(v.cacheKey===T){F=v,++F.usedTimes;break}}return F===void 0&&(F=new OF(n,T,_,s),l.push(F)),F}function A(_){if(--_.usedTimes===0){const T=l.indexOf(_);l[T]=l[l.length-1],l.pop(),_.destroy()}}function C(_){c.remove(_)}function R(){c.dispose()}return{getParameters:m,getProgramCacheKey:y,getUniforms:x,acquireProgram:M,releaseProgram:A,releaseShaderCache:C,programs:l,dispose:R}}function $F(){let n=new WeakMap;function e(s){let o=n.get(s);return o===void 0&&(o={},n.set(s,o)),o}function t(s){n.delete(s)}function r(s,o,a){n.get(s)[o]=a}function i(){n=new WeakMap}return{get:e,remove:t,update:r,dispose:i}}function FF(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.material.id!==e.material.id?n.material.id-e.material.id:n.z!==e.z?n.z-e.z:n.id-e.id}function P1(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.z!==e.z?e.z-n.z:n.id-e.id}function D1(){const n=[];let e=0;const t=[],r=[],i=[];function s(){e=0,t.length=0,r.length=0,i.length=0}function o(d,f,p,g,b,m){let y=n[e];return y===void 0?(y={id:d.id,object:d,geometry:f,material:p,groupOrder:g,renderOrder:d.renderOrder,z:b,group:m},n[e]=y):(y.id=d.id,y.object=d,y.geometry=f,y.material=p,y.groupOrder=g,y.renderOrder=d.renderOrder,y.z=b,y.group=m),e++,y}function a(d,f,p,g,b,m){const y=o(d,f,p,g,b,m);p.transmission>0?r.push(y):p.transparent===!0?i.push(y):t.push(y)}function c(d,f,p,g,b,m){const y=o(d,f,p,g,b,m);p.transmission>0?r.unshift(y):p.transparent===!0?i.unshift(y):t.unshift(y)}function l(d,f){t.length>1&&t.sort(d||FF),r.length>1&&r.sort(f||P1),i.length>1&&i.sort(f||P1)}function u(){for(let d=e,f=n.length;d<f;d++){const p=n[d];if(p.id===null)break;p.id=null,p.object=null,p.geometry=null,p.material=null,p.group=null}}return{opaque:t,transmissive:r,transparent:i,init:s,push:a,unshift:c,finish:u,sort:l}}function zF(){let n=new WeakMap;function e(r,i){const s=n.get(r);let o;return s===void 0?(o=new D1,n.set(r,[o])):i>=s.length?(o=new D1,s.push(o)):o=s[i],o}function t(){n=new WeakMap}return{get:e,dispose:t}}function VF(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new q,color:new rt};break;case"SpotLight":t={position:new q,direction:new q,color:new rt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new q,color:new rt,distance:0,decay:0};break;case"HemisphereLight":t={direction:new q,skyColor:new rt,groundColor:new rt};break;case"RectAreaLight":t={color:new rt,position:new q,halfWidth:new q,halfHeight:new q};break}return n[e.id]=t,t}}}function HF(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ye};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ye};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ye,shadowCameraNear:1,shadowCameraFar:1e3};break}return n[e.id]=t,t}}}let GF=0;function WF(n,e){return(e.castShadow?2:0)-(n.castShadow?2:0)+(e.map?1:0)-(n.map?1:0)}function qF(n,e){const t=new VF,r=HF(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let u=0;u<9;u++)i.probe.push(new q);const s=new q,o=new nn,a=new nn;function c(u,d){let f=0,p=0,g=0;for(let k=0;k<9;k++)i.probe[k].set(0,0,0);let b=0,m=0,y=0,E=0,w=0,x=0,M=0,A=0,C=0,R=0,_=0;u.sort(WF);const T=d===!0?Math.PI:1;for(let k=0,z=u.length;k<z;k++){const v=u[k],S=v.color,P=v.intensity,U=v.distance,B=v.shadow&&v.shadow.map?v.shadow.map.texture:null;if(v.isAmbientLight)f+=S.r*P*T,p+=S.g*P*T,g+=S.b*P*T;else if(v.isLightProbe){for(let O=0;O<9;O++)i.probe[O].addScaledVector(v.sh.coefficients[O],P);_++}else if(v.isDirectionalLight){const O=t.get(v);if(O.color.copy(v.color).multiplyScalar(v.intensity*T),v.castShadow){const V=v.shadow,$=r.get(v);$.shadowBias=V.bias,$.shadowNormalBias=V.normalBias,$.shadowRadius=V.radius,$.shadowMapSize=V.mapSize,i.directionalShadow[b]=$,i.directionalShadowMap[b]=B,i.directionalShadowMatrix[b]=v.shadow.matrix,x++}i.directional[b]=O,b++}else if(v.isSpotLight){const O=t.get(v);O.position.setFromMatrixPosition(v.matrixWorld),O.color.copy(S).multiplyScalar(P*T),O.distance=U,O.coneCos=Math.cos(v.angle),O.penumbraCos=Math.cos(v.angle*(1-v.penumbra)),O.decay=v.decay,i.spot[y]=O;const V=v.shadow;if(v.map&&(i.spotLightMap[C]=v.map,C++,V.updateMatrices(v),v.castShadow&&R++),i.spotLightMatrix[y]=V.matrix,v.castShadow){const $=r.get(v);$.shadowBias=V.bias,$.shadowNormalBias=V.normalBias,$.shadowRadius=V.radius,$.shadowMapSize=V.mapSize,i.spotShadow[y]=$,i.spotShadowMap[y]=B,A++}y++}else if(v.isRectAreaLight){const O=t.get(v);O.color.copy(S).multiplyScalar(P),O.halfWidth.set(v.width*.5,0,0),O.halfHeight.set(0,v.height*.5,0),i.rectArea[E]=O,E++}else if(v.isPointLight){const O=t.get(v);if(O.color.copy(v.color).multiplyScalar(v.intensity*T),O.distance=v.distance,O.decay=v.decay,v.castShadow){const V=v.shadow,$=r.get(v);$.shadowBias=V.bias,$.shadowNormalBias=V.normalBias,$.shadowRadius=V.radius,$.shadowMapSize=V.mapSize,$.shadowCameraNear=V.camera.near,$.shadowCameraFar=V.camera.far,i.pointShadow[m]=$,i.pointShadowMap[m]=B,i.pointShadowMatrix[m]=v.shadow.matrix,M++}i.point[m]=O,m++}else if(v.isHemisphereLight){const O=t.get(v);O.skyColor.copy(v.color).multiplyScalar(P*T),O.groundColor.copy(v.groundColor).multiplyScalar(P*T),i.hemi[w]=O,w++}}E>0&&(e.isWebGL2?n.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=de.LTC_FLOAT_1,i.rectAreaLTC2=de.LTC_FLOAT_2):(i.rectAreaLTC1=de.LTC_HALF_1,i.rectAreaLTC2=de.LTC_HALF_2):n.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=de.LTC_FLOAT_1,i.rectAreaLTC2=de.LTC_FLOAT_2):n.has("OES_texture_half_float_linear")===!0?(i.rectAreaLTC1=de.LTC_HALF_1,i.rectAreaLTC2=de.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=f,i.ambient[1]=p,i.ambient[2]=g;const F=i.hash;(F.directionalLength!==b||F.pointLength!==m||F.spotLength!==y||F.rectAreaLength!==E||F.hemiLength!==w||F.numDirectionalShadows!==x||F.numPointShadows!==M||F.numSpotShadows!==A||F.numSpotMaps!==C||F.numLightProbes!==_)&&(i.directional.length=b,i.spot.length=y,i.rectArea.length=E,i.point.length=m,i.hemi.length=w,i.directionalShadow.length=x,i.directionalShadowMap.length=x,i.pointShadow.length=M,i.pointShadowMap.length=M,i.spotShadow.length=A,i.spotShadowMap.length=A,i.directionalShadowMatrix.length=x,i.pointShadowMatrix.length=M,i.spotLightMatrix.length=A+C-R,i.spotLightMap.length=C,i.numSpotLightShadowsWithMaps=R,i.numLightProbes=_,F.directionalLength=b,F.pointLength=m,F.spotLength=y,F.rectAreaLength=E,F.hemiLength=w,F.numDirectionalShadows=x,F.numPointShadows=M,F.numSpotShadows=A,F.numSpotMaps=C,F.numLightProbes=_,i.version=GF++)}function l(u,d){let f=0,p=0,g=0,b=0,m=0;const y=d.matrixWorldInverse;for(let E=0,w=u.length;E<w;E++){const x=u[E];if(x.isDirectionalLight){const M=i.directional[f];M.direction.setFromMatrixPosition(x.matrixWorld),s.setFromMatrixPosition(x.target.matrixWorld),M.direction.sub(s),M.direction.transformDirection(y),f++}else if(x.isSpotLight){const M=i.spot[g];M.position.setFromMatrixPosition(x.matrixWorld),M.position.applyMatrix4(y),M.direction.setFromMatrixPosition(x.matrixWorld),s.setFromMatrixPosition(x.target.matrixWorld),M.direction.sub(s),M.direction.transformDirection(y),g++}else if(x.isRectAreaLight){const M=i.rectArea[b];M.position.setFromMatrixPosition(x.matrixWorld),M.position.applyMatrix4(y),a.identity(),o.copy(x.matrixWorld),o.premultiply(y),a.extractRotation(o),M.halfWidth.set(x.width*.5,0,0),M.halfHeight.set(0,x.height*.5,0),M.halfWidth.applyMatrix4(a),M.halfHeight.applyMatrix4(a),b++}else if(x.isPointLight){const M=i.point[p];M.position.setFromMatrixPosition(x.matrixWorld),M.position.applyMatrix4(y),p++}else if(x.isHemisphereLight){const M=i.hemi[m];M.direction.setFromMatrixPosition(x.matrixWorld),M.direction.transformDirection(y),m++}}}return{setup:c,setupView:l,state:i}}function R1(n,e){const t=new qF(n,e),r=[],i=[];function s(){r.length=0,i.length=0}function o(d){r.push(d)}function a(d){i.push(d)}function c(d){t.setup(r,d)}function l(d){t.setupView(r,d)}return{init:s,state:{lightsArray:r,shadowsArray:i,lights:t},setupLights:c,setupLightsView:l,pushLight:o,pushShadow:a}}function KF(n,e){let t=new WeakMap;function r(s,o=0){const a=t.get(s);let c;return a===void 0?(c=new R1(n,e),t.set(s,[c])):o>=a.length?(c=new R1(n,e),a.push(c)):c=a[o],c}function i(){t=new WeakMap}return{get:r,dispose:i}}class XF extends Du{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=HB,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class YF extends Du{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}const ZF=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,jF=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function JF(n,e,t){let r=new tE;const i=new Ye,s=new Ye,o=new mn,a=new XF({depthPacking:GB}),c=new YF,l={},u=t.maxTextureSize,d={[Zo]:Er,[Er]:Zo,[ns]:ns},f=new qa({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Ye},radius:{value:4}},vertexShader:ZF,fragmentShader:jF}),p=f.clone();p.defines.HORIZONTAL_PASS=1;const g=new oo;g.setAttribute("position",new Oi(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const b=new dr(g,f),m=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=RI;let y=this.type;this.render=function(A,C,R){if(m.enabled===!1||m.autoUpdate===!1&&m.needsUpdate===!1||A.length===0)return;const _=n.getRenderTarget(),T=n.getActiveCubeFace(),F=n.getActiveMipmapLevel(),k=n.state;k.setBlending(Go),k.buffers.color.setClear(1,1,1,1),k.buffers.depth.setTest(!0),k.setScissorTest(!1);const z=y!==As&&this.type===As,v=y===As&&this.type!==As;for(let S=0,P=A.length;S<P;S++){const U=A[S],B=U.shadow;if(B===void 0){console.warn("THREE.WebGLShadowMap:",U,"has no shadow.");continue}if(B.autoUpdate===!1&&B.needsUpdate===!1)continue;i.copy(B.mapSize);const O=B.getFrameExtents();if(i.multiply(O),s.copy(B.mapSize),(i.x>u||i.y>u)&&(i.x>u&&(s.x=Math.floor(u/O.x),i.x=s.x*O.x,B.mapSize.x=s.x),i.y>u&&(s.y=Math.floor(u/O.y),i.y=s.y*O.y,B.mapSize.y=s.y)),B.map===null||z===!0||v===!0){const $=this.type!==As?{minFilter:cr,magFilter:cr}:{};B.map!==null&&B.map.dispose(),B.map=new Wa(i.x,i.y,$),B.map.texture.name=U.name+".shadowMap",B.camera.updateProjectionMatrix()}n.setRenderTarget(B.map),n.clear();const V=B.getViewportCount();for(let $=0;$<V;$++){const W=B.getViewport($);o.set(s.x*W.x,s.y*W.y,s.x*W.z,s.y*W.w),k.viewport(o),B.updateMatrices(U,$),r=B.getFrustum(),x(C,R,B.camera,U,this.type)}B.isPointLightShadow!==!0&&this.type===As&&E(B,R),B.needsUpdate=!1}y=this.type,m.needsUpdate=!1,n.setRenderTarget(_,T,F)};function E(A,C){const R=e.update(b);f.defines.VSM_SAMPLES!==A.blurSamples&&(f.defines.VSM_SAMPLES=A.blurSamples,p.defines.VSM_SAMPLES=A.blurSamples,f.needsUpdate=!0,p.needsUpdate=!0),A.mapPass===null&&(A.mapPass=new Wa(i.x,i.y)),f.uniforms.shadow_pass.value=A.map.texture,f.uniforms.resolution.value=A.mapSize,f.uniforms.radius.value=A.radius,n.setRenderTarget(A.mapPass),n.clear(),n.renderBufferDirect(C,null,R,f,b,null),p.uniforms.shadow_pass.value=A.mapPass.texture,p.uniforms.resolution.value=A.mapSize,p.uniforms.radius.value=A.radius,n.setRenderTarget(A.map),n.clear(),n.renderBufferDirect(C,null,R,p,b,null)}function w(A,C,R,_){let T=null;const F=R.isPointLight===!0?A.customDistanceMaterial:A.customDepthMaterial;if(F!==void 0)T=F;else if(T=R.isPointLight===!0?c:a,n.localClippingEnabled&&C.clipShadows===!0&&Array.isArray(C.clippingPlanes)&&C.clippingPlanes.length!==0||C.displacementMap&&C.displacementScale!==0||C.alphaMap&&C.alphaTest>0||C.map&&C.alphaTest>0){const k=T.uuid,z=C.uuid;let v=l[k];v===void 0&&(v={},l[k]=v);let S=v[z];S===void 0&&(S=T.clone(),v[z]=S,C.addEventListener("dispose",M)),T=S}if(T.visible=C.visible,T.wireframe=C.wireframe,_===As?T.side=C.shadowSide!==null?C.shadowSide:C.side:T.side=C.shadowSide!==null?C.shadowSide:d[C.side],T.alphaMap=C.alphaMap,T.alphaTest=C.alphaTest,T.map=C.map,T.clipShadows=C.clipShadows,T.clippingPlanes=C.clippingPlanes,T.clipIntersection=C.clipIntersection,T.displacementMap=C.displacementMap,T.displacementScale=C.displacementScale,T.displacementBias=C.displacementBias,T.wireframeLinewidth=C.wireframeLinewidth,T.linewidth=C.linewidth,R.isPointLight===!0&&T.isMeshDistanceMaterial===!0){const k=n.properties.get(T);k.light=R}return T}function x(A,C,R,_,T){if(A.visible===!1)return;if(A.layers.test(C.layers)&&(A.isMesh||A.isLine||A.isPoints)&&(A.castShadow||A.receiveShadow&&T===As)&&(!A.frustumCulled||r.intersectsObject(A))){A.modelViewMatrix.multiplyMatrices(R.matrixWorldInverse,A.matrixWorld);const z=e.update(A),v=A.material;if(Array.isArray(v)){const S=z.groups;for(let P=0,U=S.length;P<U;P++){const B=S[P],O=v[B.materialIndex];if(O&&O.visible){const V=w(A,O,_,T);A.onBeforeShadow(n,A,C,R,z,V,B),n.renderBufferDirect(R,null,z,V,A,B),A.onAfterShadow(n,A,C,R,z,V,B)}}}else if(v.visible){const S=w(A,v,_,T);A.onBeforeShadow(n,A,C,R,z,S,null),n.renderBufferDirect(R,null,z,S,A,null),A.onAfterShadow(n,A,C,R,z,S,null)}}const k=A.children;for(let z=0,v=k.length;z<v;z++)x(k[z],C,R,_,T)}function M(A){A.target.removeEventListener("dispose",M);for(const R in l){const _=l[R],T=A.target.uuid;T in _&&(_[T].dispose(),delete _[T])}}}function QF(n,e,t){const r=t.isWebGL2;function i(){let G=!1;const ye=new mn;let be=null;const Be=new mn(0,0,0,0);return{setMask:function(Re){be!==Re&&!G&&(n.colorMask(Re,Re,Re,Re),be=Re)},setLocked:function(Re){G=Re},setClear:function(Re,At,Mt,ln,nr){nr===!0&&(Re*=ln,At*=ln,Mt*=ln),ye.set(Re,At,Mt,ln),Be.equals(ye)===!1&&(n.clearColor(Re,At,Mt,ln),Be.copy(ye))},reset:function(){G=!1,be=null,Be.set(-1,0,0,0)}}}function s(){let G=!1,ye=null,be=null,Be=null;return{setTest:function(Re){Re?fe(n.DEPTH_TEST):se(n.DEPTH_TEST)},setMask:function(Re){ye!==Re&&!G&&(n.depthMask(Re),ye=Re)},setFunc:function(Re){if(be!==Re){switch(Re){case wB:n.depthFunc(n.NEVER);break;case vB:n.depthFunc(n.ALWAYS);break;case _B:n.depthFunc(n.LESS);break;case tm:n.depthFunc(n.LEQUAL);break;case EB:n.depthFunc(n.EQUAL);break;case SB:n.depthFunc(n.GEQUAL);break;case xB:n.depthFunc(n.GREATER);break;case TB:n.depthFunc(n.NOTEQUAL);break;default:n.depthFunc(n.LEQUAL)}be=Re}},setLocked:function(Re){G=Re},setClear:function(Re){Be!==Re&&(n.clearDepth(Re),Be=Re)},reset:function(){G=!1,ye=null,be=null,Be=null}}}function o(){let G=!1,ye=null,be=null,Be=null,Re=null,At=null,Mt=null,ln=null,nr=null;return{setTest:function(Ct){G||(Ct?fe(n.STENCIL_TEST):se(n.STENCIL_TEST))},setMask:function(Ct){ye!==Ct&&!G&&(n.stencilMask(Ct),ye=Ct)},setFunc:function(Ct,rr,Hi){(be!==Ct||Be!==rr||Re!==Hi)&&(n.stencilFunc(Ct,rr,Hi),be=Ct,Be=rr,Re=Hi)},setOp:function(Ct,rr,Hi){(At!==Ct||Mt!==rr||ln!==Hi)&&(n.stencilOp(Ct,rr,Hi),At=Ct,Mt=rr,ln=Hi)},setLocked:function(Ct){G=Ct},setClear:function(Ct){nr!==Ct&&(n.clearStencil(Ct),nr=Ct)},reset:function(){G=!1,ye=null,be=null,Be=null,Re=null,At=null,Mt=null,ln=null,nr=null}}}const a=new i,c=new s,l=new o,u=new WeakMap,d=new WeakMap;let f={},p={},g=new WeakMap,b=[],m=null,y=!1,E=null,w=null,x=null,M=null,A=null,C=null,R=null,_=new rt(0,0,0),T=0,F=!1,k=null,z=null,v=null,S=null,P=null;const U=n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let B=!1,O=0;const V=n.getParameter(n.VERSION);V.indexOf("WebGL")!==-1?(O=parseFloat(/^WebGL (\d)/.exec(V)[1]),B=O>=1):V.indexOf("OpenGL ES")!==-1&&(O=parseFloat(/^OpenGL ES (\d)/.exec(V)[1]),B=O>=2);let $=null,W={};const H=n.getParameter(n.SCISSOR_BOX),Y=n.getParameter(n.VIEWPORT),te=new mn().fromArray(H),j=new mn().fromArray(Y);function re(G,ye,be,Be){const Re=new Uint8Array(4),At=n.createTexture();n.bindTexture(G,At),n.texParameteri(G,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(G,n.TEXTURE_MAG_FILTER,n.NEAREST);for(let Mt=0;Mt<be;Mt++)r&&(G===n.TEXTURE_3D||G===n.TEXTURE_2D_ARRAY)?n.texImage3D(ye,0,n.RGBA,1,1,Be,0,n.RGBA,n.UNSIGNED_BYTE,Re):n.texImage2D(ye+Mt,0,n.RGBA,1,1,0,n.RGBA,n.UNSIGNED_BYTE,Re);return At}const le={};le[n.TEXTURE_2D]=re(n.TEXTURE_2D,n.TEXTURE_2D,1),le[n.TEXTURE_CUBE_MAP]=re(n.TEXTURE_CUBE_MAP,n.TEXTURE_CUBE_MAP_POSITIVE_X,6),r&&(le[n.TEXTURE_2D_ARRAY]=re(n.TEXTURE_2D_ARRAY,n.TEXTURE_2D_ARRAY,1,1),le[n.TEXTURE_3D]=re(n.TEXTURE_3D,n.TEXTURE_3D,1,1)),a.setClear(0,0,0,1),c.setClear(1),l.setClear(0),fe(n.DEPTH_TEST),c.setFunc(tm),qe(!1),N(px),fe(n.CULL_FACE),xe(Go);function fe(G){f[G]!==!0&&(n.enable(G),f[G]=!0)}function se(G){f[G]!==!1&&(n.disable(G),f[G]=!1)}function ve(G,ye){return p[G]!==ye?(n.bindFramebuffer(G,ye),p[G]=ye,r&&(G===n.DRAW_FRAMEBUFFER&&(p[n.FRAMEBUFFER]=ye),G===n.FRAMEBUFFER&&(p[n.DRAW_FRAMEBUFFER]=ye)),!0):!1}function X(G,ye){let be=b,Be=!1;if(G)if(be=g.get(ye),be===void 0&&(be=[],g.set(ye,be)),G.isWebGLMultipleRenderTargets){const Re=G.texture;if(be.length!==Re.length||be[0]!==n.COLOR_ATTACHMENT0){for(let At=0,Mt=Re.length;At<Mt;At++)be[At]=n.COLOR_ATTACHMENT0+At;be.length=Re.length,Be=!0}}else be[0]!==n.COLOR_ATTACHMENT0&&(be[0]=n.COLOR_ATTACHMENT0,Be=!0);else be[0]!==n.BACK&&(be[0]=n.BACK,Be=!0);Be&&(t.isWebGL2?n.drawBuffers(be):e.get("WEBGL_draw_buffers").drawBuffersWEBGL(be))}function Ut(G){return m!==G?(n.useProgram(G),m=G,!0):!1}const Ce={[va]:n.FUNC_ADD,[iB]:n.FUNC_SUBTRACT,[sB]:n.FUNC_REVERSE_SUBTRACT};if(r)Ce[bx]=n.MIN,Ce[wx]=n.MAX;else{const G=e.get("EXT_blend_minmax");G!==null&&(Ce[bx]=G.MIN_EXT,Ce[wx]=G.MAX_EXT)}const ke={[oB]:n.ZERO,[aB]:n.ONE,[cB]:n.SRC_COLOR,[ov]:n.SRC_ALPHA,[pB]:n.SRC_ALPHA_SATURATE,[dB]:n.DST_COLOR,[uB]:n.DST_ALPHA,[lB]:n.ONE_MINUS_SRC_COLOR,[av]:n.ONE_MINUS_SRC_ALPHA,[fB]:n.ONE_MINUS_DST_COLOR,[hB]:n.ONE_MINUS_DST_ALPHA,[mB]:n.CONSTANT_COLOR,[gB]:n.ONE_MINUS_CONSTANT_COLOR,[yB]:n.CONSTANT_ALPHA,[bB]:n.ONE_MINUS_CONSTANT_ALPHA};function xe(G,ye,be,Be,Re,At,Mt,ln,nr,Ct){if(G===Go){y===!0&&(se(n.BLEND),y=!1);return}if(y===!1&&(fe(n.BLEND),y=!0),G!==rB){if(G!==E||Ct!==F){if((w!==va||A!==va)&&(n.blendEquation(n.FUNC_ADD),w=va,A=va),Ct)switch(G){case al:n.blendFuncSeparate(n.ONE,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case mx:n.blendFunc(n.ONE,n.ONE);break;case gx:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case yx:n.blendFuncSeparate(n.ZERO,n.SRC_COLOR,n.ZERO,n.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",G);break}else switch(G){case al:n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case mx:n.blendFunc(n.SRC_ALPHA,n.ONE);break;case gx:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case yx:n.blendFunc(n.ZERO,n.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",G);break}x=null,M=null,C=null,R=null,_.set(0,0,0),T=0,E=G,F=Ct}return}Re=Re||ye,At=At||be,Mt=Mt||Be,(ye!==w||Re!==A)&&(n.blendEquationSeparate(Ce[ye],Ce[Re]),w=ye,A=Re),(be!==x||Be!==M||At!==C||Mt!==R)&&(n.blendFuncSeparate(ke[be],ke[Be],ke[At],ke[Mt]),x=be,M=Be,C=At,R=Mt),(ln.equals(_)===!1||nr!==T)&&(n.blendColor(ln.r,ln.g,ln.b,nr),_.copy(ln),T=nr),E=G,F=!1}function kt(G,ye){G.side===ns?se(n.CULL_FACE):fe(n.CULL_FACE);let be=G.side===Er;ye&&(be=!be),qe(be),G.blending===al&&G.transparent===!1?xe(Go):xe(G.blending,G.blendEquation,G.blendSrc,G.blendDst,G.blendEquationAlpha,G.blendSrcAlpha,G.blendDstAlpha,G.blendColor,G.blendAlpha,G.premultipliedAlpha),c.setFunc(G.depthFunc),c.setTest(G.depthTest),c.setMask(G.depthWrite),a.setMask(G.colorWrite);const Be=G.stencilWrite;l.setTest(Be),Be&&(l.setMask(G.stencilWriteMask),l.setFunc(G.stencilFunc,G.stencilRef,G.stencilFuncMask),l.setOp(G.stencilFail,G.stencilZFail,G.stencilZPass)),J(G.polygonOffset,G.polygonOffsetFactor,G.polygonOffsetUnits),G.alphaToCoverage===!0?fe(n.SAMPLE_ALPHA_TO_COVERAGE):se(n.SAMPLE_ALPHA_TO_COVERAGE)}function qe(G){k!==G&&(G?n.frontFace(n.CW):n.frontFace(n.CCW),k=G)}function N(G){G!==tB?(fe(n.CULL_FACE),G!==z&&(G===px?n.cullFace(n.BACK):G===nB?n.cullFace(n.FRONT):n.cullFace(n.FRONT_AND_BACK))):se(n.CULL_FACE),z=G}function I(G){G!==v&&(B&&n.lineWidth(G),v=G)}function J(G,ye,be){G?(fe(n.POLYGON_OFFSET_FILL),(S!==ye||P!==be)&&(n.polygonOffset(ye,be),S=ye,P=be)):se(n.POLYGON_OFFSET_FILL)}function ae(G){G?fe(n.SCISSOR_TEST):se(n.SCISSOR_TEST)}function oe(G){G===void 0&&(G=n.TEXTURE0+U-1),$!==G&&(n.activeTexture(G),$=G)}function ce(G,ye,be){be===void 0&&($===null?be=n.TEXTURE0+U-1:be=$);let Be=W[be];Be===void 0&&(Be={type:void 0,texture:void 0},W[be]=Be),(Be.type!==G||Be.texture!==ye)&&($!==be&&(n.activeTexture(be),$=be),n.bindTexture(G,ye||le[G]),Be.type=G,Be.texture=ye)}function Te(){const G=W[$];G!==void 0&&G.type!==void 0&&(n.bindTexture(G.type,null),G.type=void 0,G.texture=void 0)}function we(){try{n.compressedTexImage2D.apply(n,arguments)}catch(G){console.error("THREE.WebGLState:",G)}}function Ee(){try{n.compressedTexImage3D.apply(n,arguments)}catch(G){console.error("THREE.WebGLState:",G)}}function Ue(){try{n.texSubImage2D.apply(n,arguments)}catch(G){console.error("THREE.WebGLState:",G)}}function Ke(){try{n.texSubImage3D.apply(n,arguments)}catch(G){console.error("THREE.WebGLState:",G)}}function ie(){try{n.compressedTexSubImage2D.apply(n,arguments)}catch(G){console.error("THREE.WebGLState:",G)}}function yt(){try{n.compressedTexSubImage3D.apply(n,arguments)}catch(G){console.error("THREE.WebGLState:",G)}}function et(){try{n.texStorage2D.apply(n,arguments)}catch(G){console.error("THREE.WebGLState:",G)}}function Fe(){try{n.texStorage3D.apply(n,arguments)}catch(G){console.error("THREE.WebGLState:",G)}}function Ie(){try{n.texImage2D.apply(n,arguments)}catch(G){console.error("THREE.WebGLState:",G)}}function Se(){try{n.texImage3D.apply(n,arguments)}catch(G){console.error("THREE.WebGLState:",G)}}function Ge(G){te.equals(G)===!1&&(n.scissor(G.x,G.y,G.z,G.w),te.copy(G))}function gt(G){j.equals(G)===!1&&(n.viewport(G.x,G.y,G.z,G.w),j.copy(G))}function Vt(G,ye){let be=d.get(ye);be===void 0&&(be=new WeakMap,d.set(ye,be));let Be=be.get(G);Be===void 0&&(Be=n.getUniformBlockIndex(ye,G.name),be.set(G,Be))}function Ze(G,ye){const Be=d.get(ye).get(G);u.get(ye)!==Be&&(n.uniformBlockBinding(ye,Be,G.__bindingPointIndex),u.set(ye,Be))}function he(){n.disable(n.BLEND),n.disable(n.CULL_FACE),n.disable(n.DEPTH_TEST),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SCISSOR_TEST),n.disable(n.STENCIL_TEST),n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),n.blendEquation(n.FUNC_ADD),n.blendFunc(n.ONE,n.ZERO),n.blendFuncSeparate(n.ONE,n.ZERO,n.ONE,n.ZERO),n.blendColor(0,0,0,0),n.colorMask(!0,!0,!0,!0),n.clearColor(0,0,0,0),n.depthMask(!0),n.depthFunc(n.LESS),n.clearDepth(1),n.stencilMask(4294967295),n.stencilFunc(n.ALWAYS,0,4294967295),n.stencilOp(n.KEEP,n.KEEP,n.KEEP),n.clearStencil(0),n.cullFace(n.BACK),n.frontFace(n.CCW),n.polygonOffset(0,0),n.activeTexture(n.TEXTURE0),n.bindFramebuffer(n.FRAMEBUFFER,null),r===!0&&(n.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),n.bindFramebuffer(n.READ_FRAMEBUFFER,null)),n.useProgram(null),n.lineWidth(1),n.scissor(0,0,n.canvas.width,n.canvas.height),n.viewport(0,0,n.canvas.width,n.canvas.height),f={},$=null,W={},p={},g=new WeakMap,b=[],m=null,y=!1,E=null,w=null,x=null,M=null,A=null,C=null,R=null,_=new rt(0,0,0),T=0,F=!1,k=null,z=null,v=null,S=null,P=null,te.set(0,0,n.canvas.width,n.canvas.height),j.set(0,0,n.canvas.width,n.canvas.height),a.reset(),c.reset(),l.reset()}return{buffers:{color:a,depth:c,stencil:l},enable:fe,disable:se,bindFramebuffer:ve,drawBuffers:X,useProgram:Ut,setBlending:xe,setMaterial:kt,setFlipSided:qe,setCullFace:N,setLineWidth:I,setPolygonOffset:J,setScissorTest:ae,activeTexture:oe,bindTexture:ce,unbindTexture:Te,compressedTexImage2D:we,compressedTexImage3D:Ee,texImage2D:Ie,texImage3D:Se,updateUBOMapping:Vt,uniformBlockBinding:Ze,texStorage2D:et,texStorage3D:Fe,texSubImage2D:Ue,texSubImage3D:Ke,compressedTexSubImage2D:ie,compressedTexSubImage3D:yt,scissor:Ge,viewport:gt,reset:he}}function e5(n,e,t,r,i,s,o){const a=i.isWebGL2,c=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,l=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),u=new WeakMap;let d;const f=new WeakMap;let p=!1;try{p=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function g(N,I){return p?new OffscreenCanvas(N,I):am("canvas")}function b(N,I,J,ae){let oe=1;if((N.width>ae||N.height>ae)&&(oe=ae/Math.max(N.width,N.height)),oe<1||I===!0)if(typeof HTMLImageElement<"u"&&N instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&N instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&N instanceof ImageBitmap){const ce=I?pv:Math.floor,Te=ce(oe*N.width),we=ce(oe*N.height);d===void 0&&(d=g(Te,we));const Ee=J?g(Te,we):d;return Ee.width=Te,Ee.height=we,Ee.getContext("2d").drawImage(N,0,0,Te,we),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+N.width+"x"+N.height+") to ("+Te+"x"+we+")."),Ee}else return"data"in N&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+N.width+"x"+N.height+")."),N;return N}function m(N){return Xx(N.width)&&Xx(N.height)}function y(N){return a?!1:N.wrapS!==Pi||N.wrapT!==Pi||N.minFilter!==cr&&N.minFilter!==Kr}function E(N,I){return N.generateMipmaps&&I&&N.minFilter!==cr&&N.minFilter!==Kr}function w(N){n.generateMipmap(N)}function x(N,I,J,ae,oe=!1){if(a===!1)return I;if(N!==null){if(n[N]!==void 0)return n[N];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+N+"'")}let ce=I;if(I===n.RED&&(J===n.FLOAT&&(ce=n.R32F),J===n.HALF_FLOAT&&(ce=n.R16F),J===n.UNSIGNED_BYTE&&(ce=n.R8)),I===n.RED_INTEGER&&(J===n.UNSIGNED_BYTE&&(ce=n.R8UI),J===n.UNSIGNED_SHORT&&(ce=n.R16UI),J===n.UNSIGNED_INT&&(ce=n.R32UI),J===n.BYTE&&(ce=n.R8I),J===n.SHORT&&(ce=n.R16I),J===n.INT&&(ce=n.R32I)),I===n.RG&&(J===n.FLOAT&&(ce=n.RG32F),J===n.HALF_FLOAT&&(ce=n.RG16F),J===n.UNSIGNED_BYTE&&(ce=n.RG8)),I===n.RGBA){const Te=oe?nm:bt.getTransfer(ae);J===n.FLOAT&&(ce=n.RGBA32F),J===n.HALF_FLOAT&&(ce=n.RGBA16F),J===n.UNSIGNED_BYTE&&(ce=Te===Dt?n.SRGB8_ALPHA8:n.RGBA8),J===n.UNSIGNED_SHORT_4_4_4_4&&(ce=n.RGBA4),J===n.UNSIGNED_SHORT_5_5_5_1&&(ce=n.RGB5_A1)}return(ce===n.R16F||ce===n.R32F||ce===n.RG16F||ce===n.RG32F||ce===n.RGBA16F||ce===n.RGBA32F)&&e.get("EXT_color_buffer_float"),ce}function M(N,I,J){return E(N,J)===!0||N.isFramebufferTexture&&N.minFilter!==cr&&N.minFilter!==Kr?Math.log2(Math.max(I.width,I.height))+1:N.mipmaps!==void 0&&N.mipmaps.length>0?N.mipmaps.length:N.isCompressedTexture&&Array.isArray(N.image)?I.mipmaps.length:1}function A(N){return N===cr||N===vx||N===fy?n.NEAREST:n.LINEAR}function C(N){const I=N.target;I.removeEventListener("dispose",C),_(I),I.isVideoTexture&&u.delete(I)}function R(N){const I=N.target;I.removeEventListener("dispose",R),F(I)}function _(N){const I=r.get(N);if(I.__webglInit===void 0)return;const J=N.source,ae=f.get(J);if(ae){const oe=ae[I.__cacheKey];oe.usedTimes--,oe.usedTimes===0&&T(N),Object.keys(ae).length===0&&f.delete(J)}r.remove(N)}function T(N){const I=r.get(N);n.deleteTexture(I.__webglTexture);const J=N.source,ae=f.get(J);delete ae[I.__cacheKey],o.memory.textures--}function F(N){const I=N.texture,J=r.get(N),ae=r.get(I);if(ae.__webglTexture!==void 0&&(n.deleteTexture(ae.__webglTexture),o.memory.textures--),N.depthTexture&&N.depthTexture.dispose(),N.isWebGLCubeRenderTarget)for(let oe=0;oe<6;oe++){if(Array.isArray(J.__webglFramebuffer[oe]))for(let ce=0;ce<J.__webglFramebuffer[oe].length;ce++)n.deleteFramebuffer(J.__webglFramebuffer[oe][ce]);else n.deleteFramebuffer(J.__webglFramebuffer[oe]);J.__webglDepthbuffer&&n.deleteRenderbuffer(J.__webglDepthbuffer[oe])}else{if(Array.isArray(J.__webglFramebuffer))for(let oe=0;oe<J.__webglFramebuffer.length;oe++)n.deleteFramebuffer(J.__webglFramebuffer[oe]);else n.deleteFramebuffer(J.__webglFramebuffer);if(J.__webglDepthbuffer&&n.deleteRenderbuffer(J.__webglDepthbuffer),J.__webglMultisampledFramebuffer&&n.deleteFramebuffer(J.__webglMultisampledFramebuffer),J.__webglColorRenderbuffer)for(let oe=0;oe<J.__webglColorRenderbuffer.length;oe++)J.__webglColorRenderbuffer[oe]&&n.deleteRenderbuffer(J.__webglColorRenderbuffer[oe]);J.__webglDepthRenderbuffer&&n.deleteRenderbuffer(J.__webglDepthRenderbuffer)}if(N.isWebGLMultipleRenderTargets)for(let oe=0,ce=I.length;oe<ce;oe++){const Te=r.get(I[oe]);Te.__webglTexture&&(n.deleteTexture(Te.__webglTexture),o.memory.textures--),r.remove(I[oe])}r.remove(I),r.remove(N)}let k=0;function z(){k=0}function v(){const N=k;return N>=i.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+N+" texture units while this GPU supports only "+i.maxTextures),k+=1,N}function S(N){const I=[];return I.push(N.wrapS),I.push(N.wrapT),I.push(N.wrapR||0),I.push(N.magFilter),I.push(N.minFilter),I.push(N.anisotropy),I.push(N.internalFormat),I.push(N.format),I.push(N.type),I.push(N.generateMipmaps),I.push(N.premultiplyAlpha),I.push(N.flipY),I.push(N.unpackAlignment),I.push(N.colorSpace),I.join()}function P(N,I){const J=r.get(N);if(N.isVideoTexture&&kt(N),N.isRenderTargetTexture===!1&&N.version>0&&J.__version!==N.version){const ae=N.image;if(ae===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(ae.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{te(J,N,I);return}}t.bindTexture(n.TEXTURE_2D,J.__webglTexture,n.TEXTURE0+I)}function U(N,I){const J=r.get(N);if(N.version>0&&J.__version!==N.version){te(J,N,I);return}t.bindTexture(n.TEXTURE_2D_ARRAY,J.__webglTexture,n.TEXTURE0+I)}function B(N,I){const J=r.get(N);if(N.version>0&&J.__version!==N.version){te(J,N,I);return}t.bindTexture(n.TEXTURE_3D,J.__webglTexture,n.TEXTURE0+I)}function O(N,I){const J=r.get(N);if(N.version>0&&J.__version!==N.version){j(J,N,I);return}t.bindTexture(n.TEXTURE_CUBE_MAP,J.__webglTexture,n.TEXTURE0+I)}const V={[uv]:n.REPEAT,[Pi]:n.CLAMP_TO_EDGE,[hv]:n.MIRRORED_REPEAT},$={[cr]:n.NEAREST,[vx]:n.NEAREST_MIPMAP_NEAREST,[fy]:n.NEAREST_MIPMAP_LINEAR,[Kr]:n.LINEAR,[OB]:n.LINEAR_MIPMAP_NEAREST,[td]:n.LINEAR_MIPMAP_LINEAR},W={[qB]:n.NEVER,[JB]:n.ALWAYS,[KB]:n.LESS,[GI]:n.LEQUAL,[XB]:n.EQUAL,[jB]:n.GEQUAL,[YB]:n.GREATER,[ZB]:n.NOTEQUAL};function H(N,I,J){if(J?(n.texParameteri(N,n.TEXTURE_WRAP_S,V[I.wrapS]),n.texParameteri(N,n.TEXTURE_WRAP_T,V[I.wrapT]),(N===n.TEXTURE_3D||N===n.TEXTURE_2D_ARRAY)&&n.texParameteri(N,n.TEXTURE_WRAP_R,V[I.wrapR]),n.texParameteri(N,n.TEXTURE_MAG_FILTER,$[I.magFilter]),n.texParameteri(N,n.TEXTURE_MIN_FILTER,$[I.minFilter])):(n.texParameteri(N,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(N,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),(N===n.TEXTURE_3D||N===n.TEXTURE_2D_ARRAY)&&n.texParameteri(N,n.TEXTURE_WRAP_R,n.CLAMP_TO_EDGE),(I.wrapS!==Pi||I.wrapT!==Pi)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),n.texParameteri(N,n.TEXTURE_MAG_FILTER,A(I.magFilter)),n.texParameteri(N,n.TEXTURE_MIN_FILTER,A(I.minFilter)),I.minFilter!==cr&&I.minFilter!==Kr&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),I.compareFunction&&(n.texParameteri(N,n.TEXTURE_COMPARE_MODE,n.COMPARE_REF_TO_TEXTURE),n.texParameteri(N,n.TEXTURE_COMPARE_FUNC,W[I.compareFunction])),e.has("EXT_texture_filter_anisotropic")===!0){const ae=e.get("EXT_texture_filter_anisotropic");if(I.magFilter===cr||I.minFilter!==fy&&I.minFilter!==td||I.type===Bo&&e.has("OES_texture_float_linear")===!1||a===!1&&I.type===nd&&e.has("OES_texture_half_float_linear")===!1)return;(I.anisotropy>1||r.get(I).__currentAnisotropy)&&(n.texParameterf(N,ae.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(I.anisotropy,i.getMaxAnisotropy())),r.get(I).__currentAnisotropy=I.anisotropy)}}function Y(N,I){let J=!1;N.__webglInit===void 0&&(N.__webglInit=!0,I.addEventListener("dispose",C));const ae=I.source;let oe=f.get(ae);oe===void 0&&(oe={},f.set(ae,oe));const ce=S(I);if(ce!==N.__cacheKey){oe[ce]===void 0&&(oe[ce]={texture:n.createTexture(),usedTimes:0},o.memory.textures++,J=!0),oe[ce].usedTimes++;const Te=oe[N.__cacheKey];Te!==void 0&&(oe[N.__cacheKey].usedTimes--,Te.usedTimes===0&&T(I)),N.__cacheKey=ce,N.__webglTexture=oe[ce].texture}return J}function te(N,I,J){let ae=n.TEXTURE_2D;(I.isDataArrayTexture||I.isCompressedArrayTexture)&&(ae=n.TEXTURE_2D_ARRAY),I.isData3DTexture&&(ae=n.TEXTURE_3D);const oe=Y(N,I),ce=I.source;t.bindTexture(ae,N.__webglTexture,n.TEXTURE0+J);const Te=r.get(ce);if(ce.version!==Te.__version||oe===!0){t.activeTexture(n.TEXTURE0+J);const we=bt.getPrimaries(bt.workingColorSpace),Ee=I.colorSpace===Yr?null:bt.getPrimaries(I.colorSpace),Ue=I.colorSpace===Yr||we===Ee?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,I.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,I.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,I.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,Ue);const Ke=y(I)&&m(I.image)===!1;let ie=b(I.image,Ke,!1,i.maxTextureSize);ie=qe(I,ie);const yt=m(ie)||a,et=s.convert(I.format,I.colorSpace);let Fe=s.convert(I.type),Ie=x(I.internalFormat,et,Fe,I.colorSpace,I.isVideoTexture);H(ae,I,yt);let Se;const Ge=I.mipmaps,gt=a&&I.isVideoTexture!==!0&&Ie!==zI,Vt=Te.__version===void 0||oe===!0,Ze=M(I,ie,yt);if(I.isDepthTexture)Ie=n.DEPTH_COMPONENT,a?I.type===Bo?Ie=n.DEPTH_COMPONENT32F:I.type===Uo?Ie=n.DEPTH_COMPONENT24:I.type===ka?Ie=n.DEPTH24_STENCIL8:Ie=n.DEPTH_COMPONENT16:I.type===Bo&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),I.format===$a&&Ie===n.DEPTH_COMPONENT&&I.type!==j_&&I.type!==Uo&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),I.type=Uo,Fe=s.convert(I.type)),I.format===tu&&Ie===n.DEPTH_COMPONENT&&(Ie=n.DEPTH_STENCIL,I.type!==ka&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),I.type=ka,Fe=s.convert(I.type))),Vt&&(gt?t.texStorage2D(n.TEXTURE_2D,1,Ie,ie.width,ie.height):t.texImage2D(n.TEXTURE_2D,0,Ie,ie.width,ie.height,0,et,Fe,null));else if(I.isDataTexture)if(Ge.length>0&&yt){gt&&Vt&&t.texStorage2D(n.TEXTURE_2D,Ze,Ie,Ge[0].width,Ge[0].height);for(let he=0,G=Ge.length;he<G;he++)Se=Ge[he],gt?t.texSubImage2D(n.TEXTURE_2D,he,0,0,Se.width,Se.height,et,Fe,Se.data):t.texImage2D(n.TEXTURE_2D,he,Ie,Se.width,Se.height,0,et,Fe,Se.data);I.generateMipmaps=!1}else gt?(Vt&&t.texStorage2D(n.TEXTURE_2D,Ze,Ie,ie.width,ie.height),t.texSubImage2D(n.TEXTURE_2D,0,0,0,ie.width,ie.height,et,Fe,ie.data)):t.texImage2D(n.TEXTURE_2D,0,Ie,ie.width,ie.height,0,et,Fe,ie.data);else if(I.isCompressedTexture)if(I.isCompressedArrayTexture){gt&&Vt&&t.texStorage3D(n.TEXTURE_2D_ARRAY,Ze,Ie,Ge[0].width,Ge[0].height,ie.depth);for(let he=0,G=Ge.length;he<G;he++)Se=Ge[he],I.format!==Di?et!==null?gt?t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY,he,0,0,0,Se.width,Se.height,ie.depth,et,Se.data,0,0):t.compressedTexImage3D(n.TEXTURE_2D_ARRAY,he,Ie,Se.width,Se.height,ie.depth,0,Se.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):gt?t.texSubImage3D(n.TEXTURE_2D_ARRAY,he,0,0,0,Se.width,Se.height,ie.depth,et,Fe,Se.data):t.texImage3D(n.TEXTURE_2D_ARRAY,he,Ie,Se.width,Se.height,ie.depth,0,et,Fe,Se.data)}else{gt&&Vt&&t.texStorage2D(n.TEXTURE_2D,Ze,Ie,Ge[0].width,Ge[0].height);for(let he=0,G=Ge.length;he<G;he++)Se=Ge[he],I.format!==Di?et!==null?gt?t.compressedTexSubImage2D(n.TEXTURE_2D,he,0,0,Se.width,Se.height,et,Se.data):t.compressedTexImage2D(n.TEXTURE_2D,he,Ie,Se.width,Se.height,0,Se.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):gt?t.texSubImage2D(n.TEXTURE_2D,he,0,0,Se.width,Se.height,et,Fe,Se.data):t.texImage2D(n.TEXTURE_2D,he,Ie,Se.width,Se.height,0,et,Fe,Se.data)}else if(I.isDataArrayTexture)gt?(Vt&&t.texStorage3D(n.TEXTURE_2D_ARRAY,Ze,Ie,ie.width,ie.height,ie.depth),t.texSubImage3D(n.TEXTURE_2D_ARRAY,0,0,0,0,ie.width,ie.height,ie.depth,et,Fe,ie.data)):t.texImage3D(n.TEXTURE_2D_ARRAY,0,Ie,ie.width,ie.height,ie.depth,0,et,Fe,ie.data);else if(I.isData3DTexture)gt?(Vt&&t.texStorage3D(n.TEXTURE_3D,Ze,Ie,ie.width,ie.height,ie.depth),t.texSubImage3D(n.TEXTURE_3D,0,0,0,0,ie.width,ie.height,ie.depth,et,Fe,ie.data)):t.texImage3D(n.TEXTURE_3D,0,Ie,ie.width,ie.height,ie.depth,0,et,Fe,ie.data);else if(I.isFramebufferTexture){if(Vt)if(gt)t.texStorage2D(n.TEXTURE_2D,Ze,Ie,ie.width,ie.height);else{let he=ie.width,G=ie.height;for(let ye=0;ye<Ze;ye++)t.texImage2D(n.TEXTURE_2D,ye,Ie,he,G,0,et,Fe,null),he>>=1,G>>=1}}else if(Ge.length>0&&yt){gt&&Vt&&t.texStorage2D(n.TEXTURE_2D,Ze,Ie,Ge[0].width,Ge[0].height);for(let he=0,G=Ge.length;he<G;he++)Se=Ge[he],gt?t.texSubImage2D(n.TEXTURE_2D,he,0,0,et,Fe,Se):t.texImage2D(n.TEXTURE_2D,he,Ie,et,Fe,Se);I.generateMipmaps=!1}else gt?(Vt&&t.texStorage2D(n.TEXTURE_2D,Ze,Ie,ie.width,ie.height),t.texSubImage2D(n.TEXTURE_2D,0,0,0,et,Fe,ie)):t.texImage2D(n.TEXTURE_2D,0,Ie,et,Fe,ie);E(I,yt)&&w(ae),Te.__version=ce.version,I.onUpdate&&I.onUpdate(I)}N.__version=I.version}function j(N,I,J){if(I.image.length!==6)return;const ae=Y(N,I),oe=I.source;t.bindTexture(n.TEXTURE_CUBE_MAP,N.__webglTexture,n.TEXTURE0+J);const ce=r.get(oe);if(oe.version!==ce.__version||ae===!0){t.activeTexture(n.TEXTURE0+J);const Te=bt.getPrimaries(bt.workingColorSpace),we=I.colorSpace===Yr?null:bt.getPrimaries(I.colorSpace),Ee=I.colorSpace===Yr||Te===we?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,I.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,I.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,I.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,Ee);const Ue=I.isCompressedTexture||I.image[0].isCompressedTexture,Ke=I.image[0]&&I.image[0].isDataTexture,ie=[];for(let he=0;he<6;he++)!Ue&&!Ke?ie[he]=b(I.image[he],!1,!0,i.maxCubemapSize):ie[he]=Ke?I.image[he].image:I.image[he],ie[he]=qe(I,ie[he]);const yt=ie[0],et=m(yt)||a,Fe=s.convert(I.format,I.colorSpace),Ie=s.convert(I.type),Se=x(I.internalFormat,Fe,Ie,I.colorSpace),Ge=a&&I.isVideoTexture!==!0,gt=ce.__version===void 0||ae===!0;let Vt=M(I,yt,et);H(n.TEXTURE_CUBE_MAP,I,et);let Ze;if(Ue){Ge&&gt&&t.texStorage2D(n.TEXTURE_CUBE_MAP,Vt,Se,yt.width,yt.height);for(let he=0;he<6;he++){Ze=ie[he].mipmaps;for(let G=0;G<Ze.length;G++){const ye=Ze[G];I.format!==Di?Fe!==null?Ge?t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+he,G,0,0,ye.width,ye.height,Fe,ye.data):t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+he,G,Se,ye.width,ye.height,0,ye.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):Ge?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+he,G,0,0,ye.width,ye.height,Fe,Ie,ye.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+he,G,Se,ye.width,ye.height,0,Fe,Ie,ye.data)}}}else{Ze=I.mipmaps,Ge&&gt&&(Ze.length>0&&Vt++,t.texStorage2D(n.TEXTURE_CUBE_MAP,Vt,Se,ie[0].width,ie[0].height));for(let he=0;he<6;he++)if(Ke){Ge?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+he,0,0,0,ie[he].width,ie[he].height,Fe,Ie,ie[he].data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+he,0,Se,ie[he].width,ie[he].height,0,Fe,Ie,ie[he].data);for(let G=0;G<Ze.length;G++){const be=Ze[G].image[he].image;Ge?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+he,G+1,0,0,be.width,be.height,Fe,Ie,be.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+he,G+1,Se,be.width,be.height,0,Fe,Ie,be.data)}}else{Ge?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+he,0,0,0,Fe,Ie,ie[he]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+he,0,Se,Fe,Ie,ie[he]);for(let G=0;G<Ze.length;G++){const ye=Ze[G];Ge?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+he,G+1,0,0,Fe,Ie,ye.image[he]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+he,G+1,Se,Fe,Ie,ye.image[he])}}}E(I,et)&&w(n.TEXTURE_CUBE_MAP),ce.__version=oe.version,I.onUpdate&&I.onUpdate(I)}N.__version=I.version}function re(N,I,J,ae,oe,ce){const Te=s.convert(J.format,J.colorSpace),we=s.convert(J.type),Ee=x(J.internalFormat,Te,we,J.colorSpace);if(!r.get(I).__hasExternalTextures){const Ke=Math.max(1,I.width>>ce),ie=Math.max(1,I.height>>ce);oe===n.TEXTURE_3D||oe===n.TEXTURE_2D_ARRAY?t.texImage3D(oe,ce,Ee,Ke,ie,I.depth,0,Te,we,null):t.texImage2D(oe,ce,Ee,Ke,ie,0,Te,we,null)}t.bindFramebuffer(n.FRAMEBUFFER,N),xe(I)?c.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,ae,oe,r.get(J).__webglTexture,0,ke(I)):(oe===n.TEXTURE_2D||oe>=n.TEXTURE_CUBE_MAP_POSITIVE_X&&oe<=n.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&n.framebufferTexture2D(n.FRAMEBUFFER,ae,oe,r.get(J).__webglTexture,ce),t.bindFramebuffer(n.FRAMEBUFFER,null)}function le(N,I,J){if(n.bindRenderbuffer(n.RENDERBUFFER,N),I.depthBuffer&&!I.stencilBuffer){let ae=a===!0?n.DEPTH_COMPONENT24:n.DEPTH_COMPONENT16;if(J||xe(I)){const oe=I.depthTexture;oe&&oe.isDepthTexture&&(oe.type===Bo?ae=n.DEPTH_COMPONENT32F:oe.type===Uo&&(ae=n.DEPTH_COMPONENT24));const ce=ke(I);xe(I)?c.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,ce,ae,I.width,I.height):n.renderbufferStorageMultisample(n.RENDERBUFFER,ce,ae,I.width,I.height)}else n.renderbufferStorage(n.RENDERBUFFER,ae,I.width,I.height);n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,N)}else if(I.depthBuffer&&I.stencilBuffer){const ae=ke(I);J&&xe(I)===!1?n.renderbufferStorageMultisample(n.RENDERBUFFER,ae,n.DEPTH24_STENCIL8,I.width,I.height):xe(I)?c.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,ae,n.DEPTH24_STENCIL8,I.width,I.height):n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_STENCIL,I.width,I.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.RENDERBUFFER,N)}else{const ae=I.isWebGLMultipleRenderTargets===!0?I.texture:[I.texture];for(let oe=0;oe<ae.length;oe++){const ce=ae[oe],Te=s.convert(ce.format,ce.colorSpace),we=s.convert(ce.type),Ee=x(ce.internalFormat,Te,we,ce.colorSpace),Ue=ke(I);J&&xe(I)===!1?n.renderbufferStorageMultisample(n.RENDERBUFFER,Ue,Ee,I.width,I.height):xe(I)?c.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,Ue,Ee,I.width,I.height):n.renderbufferStorage(n.RENDERBUFFER,Ee,I.width,I.height)}}n.bindRenderbuffer(n.RENDERBUFFER,null)}function fe(N,I){if(I&&I.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(n.FRAMEBUFFER,N),!(I.depthTexture&&I.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!r.get(I.depthTexture).__webglTexture||I.depthTexture.image.width!==I.width||I.depthTexture.image.height!==I.height)&&(I.depthTexture.image.width=I.width,I.depthTexture.image.height=I.height,I.depthTexture.needsUpdate=!0),P(I.depthTexture,0);const ae=r.get(I.depthTexture).__webglTexture,oe=ke(I);if(I.depthTexture.format===$a)xe(I)?c.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,ae,0,oe):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,ae,0);else if(I.depthTexture.format===tu)xe(I)?c.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,ae,0,oe):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,ae,0);else throw new Error("Unknown depthTexture format")}function se(N){const I=r.get(N),J=N.isWebGLCubeRenderTarget===!0;if(N.depthTexture&&!I.__autoAllocateDepthBuffer){if(J)throw new Error("target.depthTexture not supported in Cube render targets");fe(I.__webglFramebuffer,N)}else if(J){I.__webglDepthbuffer=[];for(let ae=0;ae<6;ae++)t.bindFramebuffer(n.FRAMEBUFFER,I.__webglFramebuffer[ae]),I.__webglDepthbuffer[ae]=n.createRenderbuffer(),le(I.__webglDepthbuffer[ae],N,!1)}else t.bindFramebuffer(n.FRAMEBUFFER,I.__webglFramebuffer),I.__webglDepthbuffer=n.createRenderbuffer(),le(I.__webglDepthbuffer,N,!1);t.bindFramebuffer(n.FRAMEBUFFER,null)}function ve(N,I,J){const ae=r.get(N);I!==void 0&&re(ae.__webglFramebuffer,N,N.texture,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,0),J!==void 0&&se(N)}function X(N){const I=N.texture,J=r.get(N),ae=r.get(I);N.addEventListener("dispose",R),N.isWebGLMultipleRenderTargets!==!0&&(ae.__webglTexture===void 0&&(ae.__webglTexture=n.createTexture()),ae.__version=I.version,o.memory.textures++);const oe=N.isWebGLCubeRenderTarget===!0,ce=N.isWebGLMultipleRenderTargets===!0,Te=m(N)||a;if(oe){J.__webglFramebuffer=[];for(let we=0;we<6;we++)if(a&&I.mipmaps&&I.mipmaps.length>0){J.__webglFramebuffer[we]=[];for(let Ee=0;Ee<I.mipmaps.length;Ee++)J.__webglFramebuffer[we][Ee]=n.createFramebuffer()}else J.__webglFramebuffer[we]=n.createFramebuffer()}else{if(a&&I.mipmaps&&I.mipmaps.length>0){J.__webglFramebuffer=[];for(let we=0;we<I.mipmaps.length;we++)J.__webglFramebuffer[we]=n.createFramebuffer()}else J.__webglFramebuffer=n.createFramebuffer();if(ce)if(i.drawBuffers){const we=N.texture;for(let Ee=0,Ue=we.length;Ee<Ue;Ee++){const Ke=r.get(we[Ee]);Ke.__webglTexture===void 0&&(Ke.__webglTexture=n.createTexture(),o.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(a&&N.samples>0&&xe(N)===!1){const we=ce?I:[I];J.__webglMultisampledFramebuffer=n.createFramebuffer(),J.__webglColorRenderbuffer=[],t.bindFramebuffer(n.FRAMEBUFFER,J.__webglMultisampledFramebuffer);for(let Ee=0;Ee<we.length;Ee++){const Ue=we[Ee];J.__webglColorRenderbuffer[Ee]=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,J.__webglColorRenderbuffer[Ee]);const Ke=s.convert(Ue.format,Ue.colorSpace),ie=s.convert(Ue.type),yt=x(Ue.internalFormat,Ke,ie,Ue.colorSpace,N.isXRRenderTarget===!0),et=ke(N);n.renderbufferStorageMultisample(n.RENDERBUFFER,et,yt,N.width,N.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+Ee,n.RENDERBUFFER,J.__webglColorRenderbuffer[Ee])}n.bindRenderbuffer(n.RENDERBUFFER,null),N.depthBuffer&&(J.__webglDepthRenderbuffer=n.createRenderbuffer(),le(J.__webglDepthRenderbuffer,N,!0)),t.bindFramebuffer(n.FRAMEBUFFER,null)}}if(oe){t.bindTexture(n.TEXTURE_CUBE_MAP,ae.__webglTexture),H(n.TEXTURE_CUBE_MAP,I,Te);for(let we=0;we<6;we++)if(a&&I.mipmaps&&I.mipmaps.length>0)for(let Ee=0;Ee<I.mipmaps.length;Ee++)re(J.__webglFramebuffer[we][Ee],N,I,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+we,Ee);else re(J.__webglFramebuffer[we],N,I,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+we,0);E(I,Te)&&w(n.TEXTURE_CUBE_MAP),t.unbindTexture()}else if(ce){const we=N.texture;for(let Ee=0,Ue=we.length;Ee<Ue;Ee++){const Ke=we[Ee],ie=r.get(Ke);t.bindTexture(n.TEXTURE_2D,ie.__webglTexture),H(n.TEXTURE_2D,Ke,Te),re(J.__webglFramebuffer,N,Ke,n.COLOR_ATTACHMENT0+Ee,n.TEXTURE_2D,0),E(Ke,Te)&&w(n.TEXTURE_2D)}t.unbindTexture()}else{let we=n.TEXTURE_2D;if((N.isWebGL3DRenderTarget||N.isWebGLArrayRenderTarget)&&(a?we=N.isWebGL3DRenderTarget?n.TEXTURE_3D:n.TEXTURE_2D_ARRAY:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),t.bindTexture(we,ae.__webglTexture),H(we,I,Te),a&&I.mipmaps&&I.mipmaps.length>0)for(let Ee=0;Ee<I.mipmaps.length;Ee++)re(J.__webglFramebuffer[Ee],N,I,n.COLOR_ATTACHMENT0,we,Ee);else re(J.__webglFramebuffer,N,I,n.COLOR_ATTACHMENT0,we,0);E(I,Te)&&w(we),t.unbindTexture()}N.depthBuffer&&se(N)}function Ut(N){const I=m(N)||a,J=N.isWebGLMultipleRenderTargets===!0?N.texture:[N.texture];for(let ae=0,oe=J.length;ae<oe;ae++){const ce=J[ae];if(E(ce,I)){const Te=N.isWebGLCubeRenderTarget?n.TEXTURE_CUBE_MAP:n.TEXTURE_2D,we=r.get(ce).__webglTexture;t.bindTexture(Te,we),w(Te),t.unbindTexture()}}}function Ce(N){if(a&&N.samples>0&&xe(N)===!1){const I=N.isWebGLMultipleRenderTargets?N.texture:[N.texture],J=N.width,ae=N.height;let oe=n.COLOR_BUFFER_BIT;const ce=[],Te=N.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,we=r.get(N),Ee=N.isWebGLMultipleRenderTargets===!0;if(Ee)for(let Ue=0;Ue<I.length;Ue++)t.bindFramebuffer(n.FRAMEBUFFER,we.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+Ue,n.RENDERBUFFER,null),t.bindFramebuffer(n.FRAMEBUFFER,we.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+Ue,n.TEXTURE_2D,null,0);t.bindFramebuffer(n.READ_FRAMEBUFFER,we.__webglMultisampledFramebuffer),t.bindFramebuffer(n.DRAW_FRAMEBUFFER,we.__webglFramebuffer);for(let Ue=0;Ue<I.length;Ue++){ce.push(n.COLOR_ATTACHMENT0+Ue),N.depthBuffer&&ce.push(Te);const Ke=we.__ignoreDepthValues!==void 0?we.__ignoreDepthValues:!1;if(Ke===!1&&(N.depthBuffer&&(oe|=n.DEPTH_BUFFER_BIT),N.stencilBuffer&&(oe|=n.STENCIL_BUFFER_BIT)),Ee&&n.framebufferRenderbuffer(n.READ_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.RENDERBUFFER,we.__webglColorRenderbuffer[Ue]),Ke===!0&&(n.invalidateFramebuffer(n.READ_FRAMEBUFFER,[Te]),n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER,[Te])),Ee){const ie=r.get(I[Ue]).__webglTexture;n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,ie,0)}n.blitFramebuffer(0,0,J,ae,0,0,J,ae,oe,n.NEAREST),l&&n.invalidateFramebuffer(n.READ_FRAMEBUFFER,ce)}if(t.bindFramebuffer(n.READ_FRAMEBUFFER,null),t.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),Ee)for(let Ue=0;Ue<I.length;Ue++){t.bindFramebuffer(n.FRAMEBUFFER,we.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+Ue,n.RENDERBUFFER,we.__webglColorRenderbuffer[Ue]);const Ke=r.get(I[Ue]).__webglTexture;t.bindFramebuffer(n.FRAMEBUFFER,we.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+Ue,n.TEXTURE_2D,Ke,0)}t.bindFramebuffer(n.DRAW_FRAMEBUFFER,we.__webglMultisampledFramebuffer)}}function ke(N){return Math.min(i.maxSamples,N.samples)}function xe(N){const I=r.get(N);return a&&N.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&I.__useRenderToTexture!==!1}function kt(N){const I=o.render.frame;u.get(N)!==I&&(u.set(N,I),N.update())}function qe(N,I){const J=N.colorSpace,ae=N.format,oe=N.type;return N.isCompressedTexture===!0||N.isVideoTexture===!0||N.format===fv||J!==to&&J!==Yr&&(bt.getTransfer(J)===Dt?a===!1?e.has("EXT_sRGB")===!0&&ae===Di?(N.format=fv,N.minFilter=Kr,N.generateMipmaps=!1):I=qI.sRGBToLinear(I):(ae!==Di||oe!==qo)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",J)),I}this.allocateTextureUnit=v,this.resetTextureUnits=z,this.setTexture2D=P,this.setTexture2DArray=U,this.setTexture3D=B,this.setTextureCube=O,this.rebindTextures=ve,this.setupRenderTarget=X,this.updateRenderTargetMipmap=Ut,this.updateMultisampleRenderTarget=Ce,this.setupDepthRenderbuffer=se,this.setupFrameBufferTexture=re,this.useMultisampledRTT=xe}function t5(n,e,t){const r=t.isWebGL2;function i(s,o=Yr){let a;const c=bt.getTransfer(o);if(s===qo)return n.UNSIGNED_BYTE;if(s===UI)return n.UNSIGNED_SHORT_4_4_4_4;if(s===BI)return n.UNSIGNED_SHORT_5_5_5_1;if(s===NB)return n.BYTE;if(s===UB)return n.SHORT;if(s===j_)return n.UNSIGNED_SHORT;if(s===NI)return n.INT;if(s===Uo)return n.UNSIGNED_INT;if(s===Bo)return n.FLOAT;if(s===nd)return r?n.HALF_FLOAT:(a=e.get("OES_texture_half_float"),a!==null?a.HALF_FLOAT_OES:null);if(s===BB)return n.ALPHA;if(s===Di)return n.RGBA;if(s===kB)return n.LUMINANCE;if(s===$B)return n.LUMINANCE_ALPHA;if(s===$a)return n.DEPTH_COMPONENT;if(s===tu)return n.DEPTH_STENCIL;if(s===fv)return a=e.get("EXT_sRGB"),a!==null?a.SRGB_ALPHA_EXT:null;if(s===FB)return n.RED;if(s===kI)return n.RED_INTEGER;if(s===zB)return n.RG;if(s===$I)return n.RG_INTEGER;if(s===FI)return n.RGBA_INTEGER;if(s===py||s===my||s===gy||s===yy)if(c===Dt)if(a=e.get("WEBGL_compressed_texture_s3tc_srgb"),a!==null){if(s===py)return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(s===my)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(s===gy)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(s===yy)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(a=e.get("WEBGL_compressed_texture_s3tc"),a!==null){if(s===py)return a.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===my)return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===gy)return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===yy)return a.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(s===_x||s===Ex||s===Sx||s===xx)if(a=e.get("WEBGL_compressed_texture_pvrtc"),a!==null){if(s===_x)return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===Ex)return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===Sx)return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===xx)return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(s===zI)return a=e.get("WEBGL_compressed_texture_etc1"),a!==null?a.COMPRESSED_RGB_ETC1_WEBGL:null;if(s===Tx||s===Ax)if(a=e.get("WEBGL_compressed_texture_etc"),a!==null){if(s===Tx)return c===Dt?a.COMPRESSED_SRGB8_ETC2:a.COMPRESSED_RGB8_ETC2;if(s===Ax)return c===Dt?a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:a.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(s===Mx||s===Cx||s===Ix||s===Px||s===Dx||s===Rx||s===Lx||s===Ox||s===Nx||s===Ux||s===Bx||s===kx||s===$x||s===Fx)if(a=e.get("WEBGL_compressed_texture_astc"),a!==null){if(s===Mx)return c===Dt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:a.COMPRESSED_RGBA_ASTC_4x4_KHR;if(s===Cx)return c===Dt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:a.COMPRESSED_RGBA_ASTC_5x4_KHR;if(s===Ix)return c===Dt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:a.COMPRESSED_RGBA_ASTC_5x5_KHR;if(s===Px)return c===Dt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:a.COMPRESSED_RGBA_ASTC_6x5_KHR;if(s===Dx)return c===Dt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:a.COMPRESSED_RGBA_ASTC_6x6_KHR;if(s===Rx)return c===Dt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:a.COMPRESSED_RGBA_ASTC_8x5_KHR;if(s===Lx)return c===Dt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:a.COMPRESSED_RGBA_ASTC_8x6_KHR;if(s===Ox)return c===Dt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:a.COMPRESSED_RGBA_ASTC_8x8_KHR;if(s===Nx)return c===Dt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:a.COMPRESSED_RGBA_ASTC_10x5_KHR;if(s===Ux)return c===Dt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:a.COMPRESSED_RGBA_ASTC_10x6_KHR;if(s===Bx)return c===Dt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:a.COMPRESSED_RGBA_ASTC_10x8_KHR;if(s===kx)return c===Dt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:a.COMPRESSED_RGBA_ASTC_10x10_KHR;if(s===$x)return c===Dt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:a.COMPRESSED_RGBA_ASTC_12x10_KHR;if(s===Fx)return c===Dt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:a.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(s===by||s===zx||s===Vx)if(a=e.get("EXT_texture_compression_bptc"),a!==null){if(s===by)return c===Dt?a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:a.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(s===zx)return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(s===Vx)return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(s===VB||s===Hx||s===Gx||s===Wx)if(a=e.get("EXT_texture_compression_rgtc"),a!==null){if(s===by)return a.COMPRESSED_RED_RGTC1_EXT;if(s===Hx)return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(s===Gx)return a.COMPRESSED_RED_GREEN_RGTC2_EXT;if(s===Wx)return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return s===ka?r?n.UNSIGNED_INT_24_8:(a=e.get("WEBGL_depth_texture"),a!==null?a.UNSIGNED_INT_24_8_WEBGL:null):n[s]!==void 0?n[s]:null}return{convert:i}}class n5 extends Lr{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e}}class kf extends sn{constructor(){super(),this.isGroup=!0,this.type="Group"}}const r5={type:"move"};class Hy{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new kf,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new kf,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new q,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new q),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new kf,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new q,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new q),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const t=this._hand;if(t)for(const r of e.hand.values())this._getHandJoint(t,r)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,r){let i=null,s=null,o=null;const a=this._targetRay,c=this._grip,l=this._hand;if(e&&t.session.visibilityState!=="visible-blurred"){if(l&&e.hand){o=!0;for(const b of e.hand.values()){const m=t.getJointPose(b,r),y=this._getHandJoint(l,b);m!==null&&(y.matrix.fromArray(m.transform.matrix),y.matrix.decompose(y.position,y.rotation,y.scale),y.matrixWorldNeedsUpdate=!0,y.jointRadius=m.radius),y.visible=m!==null}const u=l.joints["index-finger-tip"],d=l.joints["thumb-tip"],f=u.position.distanceTo(d.position),p=.02,g=.005;l.inputState.pinching&&f>p+g?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!l.inputState.pinching&&f<=p-g&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else c!==null&&e.gripSpace&&(s=t.getPose(e.gripSpace,r),s!==null&&(c.matrix.fromArray(s.transform.matrix),c.matrix.decompose(c.position,c.rotation,c.scale),c.matrixWorldNeedsUpdate=!0,s.linearVelocity?(c.hasLinearVelocity=!0,c.linearVelocity.copy(s.linearVelocity)):c.hasLinearVelocity=!1,s.angularVelocity?(c.hasAngularVelocity=!0,c.angularVelocity.copy(s.angularVelocity)):c.hasAngularVelocity=!1));a!==null&&(i=t.getPose(e.targetRaySpace,r),i===null&&s!==null&&(i=s),i!==null&&(a.matrix.fromArray(i.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),a.matrixWorldNeedsUpdate=!0,i.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(i.linearVelocity)):a.hasLinearVelocity=!1,i.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(i.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(r5)))}return a!==null&&(a.visible=i!==null),c!==null&&(c.visible=s!==null),l!==null&&(l.visible=o!==null),this}_getHandJoint(e,t){if(e.joints[t.jointName]===void 0){const r=new kf;r.matrixAutoUpdate=!1,r.visible=!1,e.joints[t.jointName]=r,e.add(r)}return e.joints[t.jointName]}}class i5 extends Pu{constructor(e,t){super();const r=this;let i=null,s=1,o=null,a="local-floor",c=1,l=null,u=null,d=null,f=null,p=null,g=null;const b=t.getContextAttributes();let m=null,y=null;const E=[],w=[],x=new Ye;let M=null;const A=new Lr;A.layers.enable(1),A.viewport=new mn;const C=new Lr;C.layers.enable(2),C.viewport=new mn;const R=[A,C],_=new n5;_.layers.enable(1),_.layers.enable(2);let T=null,F=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(H){let Y=E[H];return Y===void 0&&(Y=new Hy,E[H]=Y),Y.getTargetRaySpace()},this.getControllerGrip=function(H){let Y=E[H];return Y===void 0&&(Y=new Hy,E[H]=Y),Y.getGripSpace()},this.getHand=function(H){let Y=E[H];return Y===void 0&&(Y=new Hy,E[H]=Y),Y.getHandSpace()};function k(H){const Y=w.indexOf(H.inputSource);if(Y===-1)return;const te=E[Y];te!==void 0&&(te.update(H.inputSource,H.frame,l||o),te.dispatchEvent({type:H.type,data:H.inputSource}))}function z(){i.removeEventListener("select",k),i.removeEventListener("selectstart",k),i.removeEventListener("selectend",k),i.removeEventListener("squeeze",k),i.removeEventListener("squeezestart",k),i.removeEventListener("squeezeend",k),i.removeEventListener("end",z),i.removeEventListener("inputsourceschange",v);for(let H=0;H<E.length;H++){const Y=w[H];Y!==null&&(w[H]=null,E[H].disconnect(Y))}T=null,F=null,e.setRenderTarget(m),p=null,f=null,d=null,i=null,y=null,W.stop(),r.isPresenting=!1,e.setPixelRatio(M),e.setSize(x.width,x.height,!1),r.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(H){s=H,r.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(H){a=H,r.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return l||o},this.setReferenceSpace=function(H){l=H},this.getBaseLayer=function(){return f!==null?f:p},this.getBinding=function(){return d},this.getFrame=function(){return g},this.getSession=function(){return i},this.setSession=async function(H){if(i=H,i!==null){if(m=e.getRenderTarget(),i.addEventListener("select",k),i.addEventListener("selectstart",k),i.addEventListener("selectend",k),i.addEventListener("squeeze",k),i.addEventListener("squeezestart",k),i.addEventListener("squeezeend",k),i.addEventListener("end",z),i.addEventListener("inputsourceschange",v),b.xrCompatible!==!0&&await t.makeXRCompatible(),M=e.getPixelRatio(),e.getSize(x),i.renderState.layers===void 0||e.capabilities.isWebGL2===!1){const Y={antialias:i.renderState.layers===void 0?b.antialias:!0,alpha:!0,depth:b.depth,stencil:b.stencil,framebufferScaleFactor:s};p=new XRWebGLLayer(i,t,Y),i.updateRenderState({baseLayer:p}),e.setPixelRatio(1),e.setSize(p.framebufferWidth,p.framebufferHeight,!1),y=new Wa(p.framebufferWidth,p.framebufferHeight,{format:Di,type:qo,colorSpace:e.outputColorSpace,stencilBuffer:b.stencil})}else{let Y=null,te=null,j=null;b.depth&&(j=b.stencil?t.DEPTH24_STENCIL8:t.DEPTH_COMPONENT24,Y=b.stencil?tu:$a,te=b.stencil?ka:Uo);const re={colorFormat:t.RGBA8,depthFormat:j,scaleFactor:s};d=new XRWebGLBinding(i,t),f=d.createProjectionLayer(re),i.updateRenderState({layers:[f]}),e.setPixelRatio(1),e.setSize(f.textureWidth,f.textureHeight,!1),y=new Wa(f.textureWidth,f.textureHeight,{format:Di,type:qo,depthTexture:new rP(f.textureWidth,f.textureHeight,te,void 0,void 0,void 0,void 0,void 0,void 0,Y),stencilBuffer:b.stencil,colorSpace:e.outputColorSpace,samples:b.antialias?4:0});const le=e.properties.get(y);le.__ignoreDepthValues=f.ignoreDepthValues}y.isXRRenderTarget=!0,this.setFoveation(c),l=null,o=await i.requestReferenceSpace(a),W.setContext(i),W.start(),r.isPresenting=!0,r.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(i!==null)return i.environmentBlendMode};function v(H){for(let Y=0;Y<H.removed.length;Y++){const te=H.removed[Y],j=w.indexOf(te);j>=0&&(w[j]=null,E[j].disconnect(te))}for(let Y=0;Y<H.added.length;Y++){const te=H.added[Y];let j=w.indexOf(te);if(j===-1){for(let le=0;le<E.length;le++)if(le>=w.length){w.push(te),j=le;break}else if(w[le]===null){w[le]=te,j=le;break}if(j===-1)break}const re=E[j];re&&re.connect(te)}}const S=new q,P=new q;function U(H,Y,te){S.setFromMatrixPosition(Y.matrixWorld),P.setFromMatrixPosition(te.matrixWorld);const j=S.distanceTo(P),re=Y.projectionMatrix.elements,le=te.projectionMatrix.elements,fe=re[14]/(re[10]-1),se=re[14]/(re[10]+1),ve=(re[9]+1)/re[5],X=(re[9]-1)/re[5],Ut=(re[8]-1)/re[0],Ce=(le[8]+1)/le[0],ke=fe*Ut,xe=fe*Ce,kt=j/(-Ut+Ce),qe=kt*-Ut;Y.matrixWorld.decompose(H.position,H.quaternion,H.scale),H.translateX(qe),H.translateZ(kt),H.matrixWorld.compose(H.position,H.quaternion,H.scale),H.matrixWorldInverse.copy(H.matrixWorld).invert();const N=fe+kt,I=se+kt,J=ke-qe,ae=xe+(j-qe),oe=ve*se/I*N,ce=X*se/I*N;H.projectionMatrix.makePerspective(J,ae,oe,ce,N,I),H.projectionMatrixInverse.copy(H.projectionMatrix).invert()}function B(H,Y){Y===null?H.matrixWorld.copy(H.matrix):H.matrixWorld.multiplyMatrices(Y.matrixWorld,H.matrix),H.matrixWorldInverse.copy(H.matrixWorld).invert()}this.updateCamera=function(H){if(i===null)return;_.near=C.near=A.near=H.near,_.far=C.far=A.far=H.far,(T!==_.near||F!==_.far)&&(i.updateRenderState({depthNear:_.near,depthFar:_.far}),T=_.near,F=_.far);const Y=H.parent,te=_.cameras;B(_,Y);for(let j=0;j<te.length;j++)B(te[j],Y);te.length===2?U(_,A,C):_.projectionMatrix.copy(A.projectionMatrix),O(H,_,Y)};function O(H,Y,te){te===null?H.matrix.copy(Y.matrixWorld):(H.matrix.copy(te.matrixWorld),H.matrix.invert(),H.matrix.multiply(Y.matrixWorld)),H.matrix.decompose(H.position,H.quaternion,H.scale),H.updateMatrixWorld(!0),H.projectionMatrix.copy(Y.projectionMatrix),H.projectionMatrixInverse.copy(Y.projectionMatrixInverse),H.isPerspectiveCamera&&(H.fov=om*2*Math.atan(1/H.projectionMatrix.elements[5]),H.zoom=1)}this.getCamera=function(){return _},this.getFoveation=function(){if(!(f===null&&p===null))return c},this.setFoveation=function(H){c=H,f!==null&&(f.fixedFoveation=H),p!==null&&p.fixedFoveation!==void 0&&(p.fixedFoveation=H)};let V=null;function $(H,Y){if(u=Y.getViewerPose(l||o),g=Y,u!==null){const te=u.views;p!==null&&(e.setRenderTargetFramebuffer(y,p.framebuffer),e.setRenderTarget(y));let j=!1;te.length!==_.cameras.length&&(_.cameras.length=0,j=!0);for(let re=0;re<te.length;re++){const le=te[re];let fe=null;if(p!==null)fe=p.getViewport(le);else{const ve=d.getViewSubImage(f,le);fe=ve.viewport,re===0&&(e.setRenderTargetTextures(y,ve.colorTexture,f.ignoreDepthValues?void 0:ve.depthStencilTexture),e.setRenderTarget(y))}let se=R[re];se===void 0&&(se=new Lr,se.layers.enable(re),se.viewport=new mn,R[re]=se),se.matrix.fromArray(le.transform.matrix),se.matrix.decompose(se.position,se.quaternion,se.scale),se.projectionMatrix.fromArray(le.projectionMatrix),se.projectionMatrixInverse.copy(se.projectionMatrix).invert(),se.viewport.set(fe.x,fe.y,fe.width,fe.height),re===0&&(_.matrix.copy(se.matrix),_.matrix.decompose(_.position,_.quaternion,_.scale)),j===!0&&_.cameras.push(se)}}for(let te=0;te<E.length;te++){const j=w[te],re=E[te];j!==null&&re!==void 0&&re.update(j,Y,l||o)}V&&V(H,Y),Y.detectedPlanes&&r.dispatchEvent({type:"planesdetected",data:Y}),g=null}const W=new nP;W.setAnimationLoop($),this.setAnimationLoop=function(H){V=H},this.dispose=function(){}}}function s5(n,e){function t(m,y){m.matrixAutoUpdate===!0&&m.updateMatrix(),y.value.copy(m.matrix)}function r(m,y){y.color.getRGB(m.fogColor.value,QI(n)),y.isFog?(m.fogNear.value=y.near,m.fogFar.value=y.far):y.isFogExp2&&(m.fogDensity.value=y.density)}function i(m,y,E,w,x){y.isMeshBasicMaterial||y.isMeshLambertMaterial?s(m,y):y.isMeshToonMaterial?(s(m,y),d(m,y)):y.isMeshPhongMaterial?(s(m,y),u(m,y)):y.isMeshStandardMaterial?(s(m,y),f(m,y),y.isMeshPhysicalMaterial&&p(m,y,x)):y.isMeshMatcapMaterial?(s(m,y),g(m,y)):y.isMeshDepthMaterial?s(m,y):y.isMeshDistanceMaterial?(s(m,y),b(m,y)):y.isMeshNormalMaterial?s(m,y):y.isLineBasicMaterial?(o(m,y),y.isLineDashedMaterial&&a(m,y)):y.isPointsMaterial?c(m,y,E,w):y.isSpriteMaterial?l(m,y):y.isShadowMaterial?(m.color.value.copy(y.color),m.opacity.value=y.opacity):y.isShaderMaterial&&(y.uniformsNeedUpdate=!1)}function s(m,y){m.opacity.value=y.opacity,y.color&&m.diffuse.value.copy(y.color),y.emissive&&m.emissive.value.copy(y.emissive).multiplyScalar(y.emissiveIntensity),y.map&&(m.map.value=y.map,t(y.map,m.mapTransform)),y.alphaMap&&(m.alphaMap.value=y.alphaMap,t(y.alphaMap,m.alphaMapTransform)),y.bumpMap&&(m.bumpMap.value=y.bumpMap,t(y.bumpMap,m.bumpMapTransform),m.bumpScale.value=y.bumpScale,y.side===Er&&(m.bumpScale.value*=-1)),y.normalMap&&(m.normalMap.value=y.normalMap,t(y.normalMap,m.normalMapTransform),m.normalScale.value.copy(y.normalScale),y.side===Er&&m.normalScale.value.negate()),y.displacementMap&&(m.displacementMap.value=y.displacementMap,t(y.displacementMap,m.displacementMapTransform),m.displacementScale.value=y.displacementScale,m.displacementBias.value=y.displacementBias),y.emissiveMap&&(m.emissiveMap.value=y.emissiveMap,t(y.emissiveMap,m.emissiveMapTransform)),y.specularMap&&(m.specularMap.value=y.specularMap,t(y.specularMap,m.specularMapTransform)),y.alphaTest>0&&(m.alphaTest.value=y.alphaTest);const E=e.get(y).envMap;if(E&&(m.envMap.value=E,m.flipEnvMap.value=E.isCubeTexture&&E.isRenderTargetTexture===!1?-1:1,m.reflectivity.value=y.reflectivity,m.ior.value=y.ior,m.refractionRatio.value=y.refractionRatio),y.lightMap){m.lightMap.value=y.lightMap;const w=n._useLegacyLights===!0?Math.PI:1;m.lightMapIntensity.value=y.lightMapIntensity*w,t(y.lightMap,m.lightMapTransform)}y.aoMap&&(m.aoMap.value=y.aoMap,m.aoMapIntensity.value=y.aoMapIntensity,t(y.aoMap,m.aoMapTransform))}function o(m,y){m.diffuse.value.copy(y.color),m.opacity.value=y.opacity,y.map&&(m.map.value=y.map,t(y.map,m.mapTransform))}function a(m,y){m.dashSize.value=y.dashSize,m.totalSize.value=y.dashSize+y.gapSize,m.scale.value=y.scale}function c(m,y,E,w){m.diffuse.value.copy(y.color),m.opacity.value=y.opacity,m.size.value=y.size*E,m.scale.value=w*.5,y.map&&(m.map.value=y.map,t(y.map,m.uvTransform)),y.alphaMap&&(m.alphaMap.value=y.alphaMap,t(y.alphaMap,m.alphaMapTransform)),y.alphaTest>0&&(m.alphaTest.value=y.alphaTest)}function l(m,y){m.diffuse.value.copy(y.color),m.opacity.value=y.opacity,m.rotation.value=y.rotation,y.map&&(m.map.value=y.map,t(y.map,m.mapTransform)),y.alphaMap&&(m.alphaMap.value=y.alphaMap,t(y.alphaMap,m.alphaMapTransform)),y.alphaTest>0&&(m.alphaTest.value=y.alphaTest)}function u(m,y){m.specular.value.copy(y.specular),m.shininess.value=Math.max(y.shininess,1e-4)}function d(m,y){y.gradientMap&&(m.gradientMap.value=y.gradientMap)}function f(m,y){m.metalness.value=y.metalness,y.metalnessMap&&(m.metalnessMap.value=y.metalnessMap,t(y.metalnessMap,m.metalnessMapTransform)),m.roughness.value=y.roughness,y.roughnessMap&&(m.roughnessMap.value=y.roughnessMap,t(y.roughnessMap,m.roughnessMapTransform)),e.get(y).envMap&&(m.envMapIntensity.value=y.envMapIntensity)}function p(m,y,E){m.ior.value=y.ior,y.sheen>0&&(m.sheenColor.value.copy(y.sheenColor).multiplyScalar(y.sheen),m.sheenRoughness.value=y.sheenRoughness,y.sheenColorMap&&(m.sheenColorMap.value=y.sheenColorMap,t(y.sheenColorMap,m.sheenColorMapTransform)),y.sheenRoughnessMap&&(m.sheenRoughnessMap.value=y.sheenRoughnessMap,t(y.sheenRoughnessMap,m.sheenRoughnessMapTransform))),y.clearcoat>0&&(m.clearcoat.value=y.clearcoat,m.clearcoatRoughness.value=y.clearcoatRoughness,y.clearcoatMap&&(m.clearcoatMap.value=y.clearcoatMap,t(y.clearcoatMap,m.clearcoatMapTransform)),y.clearcoatRoughnessMap&&(m.clearcoatRoughnessMap.value=y.clearcoatRoughnessMap,t(y.clearcoatRoughnessMap,m.clearcoatRoughnessMapTransform)),y.clearcoatNormalMap&&(m.clearcoatNormalMap.value=y.clearcoatNormalMap,t(y.clearcoatNormalMap,m.clearcoatNormalMapTransform),m.clearcoatNormalScale.value.copy(y.clearcoatNormalScale),y.side===Er&&m.clearcoatNormalScale.value.negate())),y.iridescence>0&&(m.iridescence.value=y.iridescence,m.iridescenceIOR.value=y.iridescenceIOR,m.iridescenceThicknessMinimum.value=y.iridescenceThicknessRange[0],m.iridescenceThicknessMaximum.value=y.iridescenceThicknessRange[1],y.iridescenceMap&&(m.iridescenceMap.value=y.iridescenceMap,t(y.iridescenceMap,m.iridescenceMapTransform)),y.iridescenceThicknessMap&&(m.iridescenceThicknessMap.value=y.iridescenceThicknessMap,t(y.iridescenceThicknessMap,m.iridescenceThicknessMapTransform))),y.transmission>0&&(m.transmission.value=y.transmission,m.transmissionSamplerMap.value=E.texture,m.transmissionSamplerSize.value.set(E.width,E.height),y.transmissionMap&&(m.transmissionMap.value=y.transmissionMap,t(y.transmissionMap,m.transmissionMapTransform)),m.thickness.value=y.thickness,y.thicknessMap&&(m.thicknessMap.value=y.thicknessMap,t(y.thicknessMap,m.thicknessMapTransform)),m.attenuationDistance.value=y.attenuationDistance,m.attenuationColor.value.copy(y.attenuationColor)),y.anisotropy>0&&(m.anisotropyVector.value.set(y.anisotropy*Math.cos(y.anisotropyRotation),y.anisotropy*Math.sin(y.anisotropyRotation)),y.anisotropyMap&&(m.anisotropyMap.value=y.anisotropyMap,t(y.anisotropyMap,m.anisotropyMapTransform))),m.specularIntensity.value=y.specularIntensity,m.specularColor.value.copy(y.specularColor),y.specularColorMap&&(m.specularColorMap.value=y.specularColorMap,t(y.specularColorMap,m.specularColorMapTransform)),y.specularIntensityMap&&(m.specularIntensityMap.value=y.specularIntensityMap,t(y.specularIntensityMap,m.specularIntensityMapTransform))}function g(m,y){y.matcap&&(m.matcap.value=y.matcap)}function b(m,y){const E=e.get(y).light;m.referencePosition.value.setFromMatrixPosition(E.matrixWorld),m.nearDistance.value=E.shadow.camera.near,m.farDistance.value=E.shadow.camera.far}return{refreshFogUniforms:r,refreshMaterialUniforms:i}}function o5(n,e,t,r){let i={},s={},o=[];const a=t.isWebGL2?n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS):0;function c(E,w){const x=w.program;r.uniformBlockBinding(E,x)}function l(E,w){let x=i[E.id];x===void 0&&(g(E),x=u(E),i[E.id]=x,E.addEventListener("dispose",m));const M=w.program;r.updateUBOMapping(E,M);const A=e.render.frame;s[E.id]!==A&&(f(E),s[E.id]=A)}function u(E){const w=d();E.__bindingPointIndex=w;const x=n.createBuffer(),M=E.__size,A=E.usage;return n.bindBuffer(n.UNIFORM_BUFFER,x),n.bufferData(n.UNIFORM_BUFFER,M,A),n.bindBuffer(n.UNIFORM_BUFFER,null),n.bindBufferBase(n.UNIFORM_BUFFER,w,x),x}function d(){for(let E=0;E<a;E++)if(o.indexOf(E)===-1)return o.push(E),E;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function f(E){const w=i[E.id],x=E.uniforms,M=E.__cache;n.bindBuffer(n.UNIFORM_BUFFER,w);for(let A=0,C=x.length;A<C;A++){const R=Array.isArray(x[A])?x[A]:[x[A]];for(let _=0,T=R.length;_<T;_++){const F=R[_];if(p(F,A,_,M)===!0){const k=F.__offset,z=Array.isArray(F.value)?F.value:[F.value];let v=0;for(let S=0;S<z.length;S++){const P=z[S],U=b(P);typeof P=="number"||typeof P=="boolean"?(F.__data[0]=P,n.bufferSubData(n.UNIFORM_BUFFER,k+v,F.__data)):P.isMatrix3?(F.__data[0]=P.elements[0],F.__data[1]=P.elements[1],F.__data[2]=P.elements[2],F.__data[3]=0,F.__data[4]=P.elements[3],F.__data[5]=P.elements[4],F.__data[6]=P.elements[5],F.__data[7]=0,F.__data[8]=P.elements[6],F.__data[9]=P.elements[7],F.__data[10]=P.elements[8],F.__data[11]=0):(P.toArray(F.__data,v),v+=U.storage/Float32Array.BYTES_PER_ELEMENT)}n.bufferSubData(n.UNIFORM_BUFFER,k,F.__data)}}}n.bindBuffer(n.UNIFORM_BUFFER,null)}function p(E,w,x,M){const A=E.value,C=w+"_"+x;if(M[C]===void 0)return typeof A=="number"||typeof A=="boolean"?M[C]=A:M[C]=A.clone(),!0;{const R=M[C];if(typeof A=="number"||typeof A=="boolean"){if(R!==A)return M[C]=A,!0}else if(R.equals(A)===!1)return R.copy(A),!0}return!1}function g(E){const w=E.uniforms;let x=0;const M=16;for(let C=0,R=w.length;C<R;C++){const _=Array.isArray(w[C])?w[C]:[w[C]];for(let T=0,F=_.length;T<F;T++){const k=_[T],z=Array.isArray(k.value)?k.value:[k.value];for(let v=0,S=z.length;v<S;v++){const P=z[v],U=b(P),B=x%M;B!==0&&M-B<U.boundary&&(x+=M-B),k.__data=new Float32Array(U.storage/Float32Array.BYTES_PER_ELEMENT),k.__offset=x,x+=U.storage}}}const A=x%M;return A>0&&(x+=M-A),E.__size=x,E.__cache={},this}function b(E){const w={boundary:0,storage:0};return typeof E=="number"||typeof E=="boolean"?(w.boundary=4,w.storage=4):E.isVector2?(w.boundary=8,w.storage=8):E.isVector3||E.isColor?(w.boundary=16,w.storage=12):E.isVector4?(w.boundary=16,w.storage=16):E.isMatrix3?(w.boundary=48,w.storage=48):E.isMatrix4?(w.boundary=64,w.storage=64):E.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",E),w}function m(E){const w=E.target;w.removeEventListener("dispose",m);const x=o.indexOf(w.__bindingPointIndex);o.splice(x,1),n.deleteBuffer(i[w.id]),delete i[w.id],delete s[w.id]}function y(){for(const E in i)n.deleteBuffer(i[E]);o=[],i={},s={}}return{bind:c,update:l,dispose:y}}class lP{constructor(e={}){const{canvas:t=e4(),context:r=null,depth:i=!0,stencil:s=!0,alpha:o=!1,antialias:a=!1,premultipliedAlpha:c=!0,preserveDrawingBuffer:l=!1,powerPreference:u="default",failIfMajorPerformanceCaveat:d=!1}=e;this.isWebGLRenderer=!0;let f;r!==null?f=r.getContextAttributes().alpha:f=o;const p=new Uint32Array(4),g=new Int32Array(4);let b=null,m=null;const y=[],E=[];this.domElement=t,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=_n,this._useLegacyLights=!1,this.toneMapping=Wo,this.toneMappingExposure=1;const w=this;let x=!1,M=0,A=0,C=null,R=-1,_=null;const T=new mn,F=new mn;let k=null;const z=new rt(0);let v=0,S=t.width,P=t.height,U=1,B=null,O=null;const V=new mn(0,0,S,P),$=new mn(0,0,S,P);let W=!1;const H=new tE;let Y=!1,te=!1,j=null;const re=new nn,le=new Ye,fe=new q,se={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function ve(){return C===null?U:1}let X=r;function Ut(L,K){for(let Q=0;Q<L.length;Q++){const ee=L[Q],Z=t.getContext(ee,K);if(Z!==null)return Z}return null}try{const L={alpha:!0,depth:i,stencil:s,antialias:a,premultipliedAlpha:c,preserveDrawingBuffer:l,powerPreference:u,failIfMajorPerformanceCaveat:d};if("setAttribute"in t&&t.setAttribute("data-engine",`three.js r${Y_}`),t.addEventListener("webglcontextlost",he,!1),t.addEventListener("webglcontextrestored",G,!1),t.addEventListener("webglcontextcreationerror",ye,!1),X===null){const K=["webgl2","webgl","experimental-webgl"];if(w.isWebGL1Renderer===!0&&K.shift(),X=Ut(K,L),X===null)throw Ut(K)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}typeof WebGLRenderingContext<"u"&&X instanceof WebGLRenderingContext&&console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),X.getShaderPrecisionFormat===void 0&&(X.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(L){throw console.error("THREE.WebGLRenderer: "+L.message),L}let Ce,ke,xe,kt,qe,N,I,J,ae,oe,ce,Te,we,Ee,Ue,Ke,ie,yt,et,Fe,Ie,Se,Ge,gt;function Vt(){Ce=new g$(X),ke=new l$(X,Ce,e),Ce.init(ke),Se=new t5(X,Ce,ke),xe=new QF(X,Ce,ke),kt=new w$(X),qe=new $F,N=new e5(X,Ce,xe,qe,ke,Se,kt),I=new h$(w),J=new m$(w),ae=new A4(X,ke),Ge=new a$(X,Ce,ae,ke),oe=new y$(X,ae,kt,Ge),ce=new S$(X,oe,ae,kt),et=new E$(X,ke,N),Ke=new u$(qe),Te=new kF(w,I,J,Ce,ke,Ge,Ke),we=new s5(w,qe),Ee=new zF,Ue=new KF(Ce,ke),yt=new o$(w,I,J,xe,ce,f,c),ie=new JF(w,ce,ke),gt=new o5(X,kt,ke,xe),Fe=new c$(X,Ce,kt,ke),Ie=new b$(X,Ce,kt,ke),kt.programs=Te.programs,w.capabilities=ke,w.extensions=Ce,w.properties=qe,w.renderLists=Ee,w.shadowMap=ie,w.state=xe,w.info=kt}Vt();const Ze=new i5(w,X);this.xr=Ze,this.getContext=function(){return X},this.getContextAttributes=function(){return X.getContextAttributes()},this.forceContextLoss=function(){const L=Ce.get("WEBGL_lose_context");L&&L.loseContext()},this.forceContextRestore=function(){const L=Ce.get("WEBGL_lose_context");L&&L.restoreContext()},this.getPixelRatio=function(){return U},this.setPixelRatio=function(L){L!==void 0&&(U=L,this.setSize(S,P,!1))},this.getSize=function(L){return L.set(S,P)},this.setSize=function(L,K,Q=!0){if(Ze.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}S=L,P=K,t.width=Math.floor(L*U),t.height=Math.floor(K*U),Q===!0&&(t.style.width=L+"px",t.style.height=K+"px"),this.setViewport(0,0,L,K)},this.getDrawingBufferSize=function(L){return L.set(S*U,P*U).floor()},this.setDrawingBufferSize=function(L,K,Q){S=L,P=K,U=Q,t.width=Math.floor(L*Q),t.height=Math.floor(K*Q),this.setViewport(0,0,L,K)},this.getCurrentViewport=function(L){return L.copy(T)},this.getViewport=function(L){return L.copy(V)},this.setViewport=function(L,K,Q,ee){L.isVector4?V.set(L.x,L.y,L.z,L.w):V.set(L,K,Q,ee),xe.viewport(T.copy(V).multiplyScalar(U).floor())},this.getScissor=function(L){return L.copy($)},this.setScissor=function(L,K,Q,ee){L.isVector4?$.set(L.x,L.y,L.z,L.w):$.set(L,K,Q,ee),xe.scissor(F.copy($).multiplyScalar(U).floor())},this.getScissorTest=function(){return W},this.setScissorTest=function(L){xe.setScissorTest(W=L)},this.setOpaqueSort=function(L){B=L},this.setTransparentSort=function(L){O=L},this.getClearColor=function(L){return L.copy(yt.getClearColor())},this.setClearColor=function(){yt.setClearColor.apply(yt,arguments)},this.getClearAlpha=function(){return yt.getClearAlpha()},this.setClearAlpha=function(){yt.setClearAlpha.apply(yt,arguments)},this.clear=function(L=!0,K=!0,Q=!0){let ee=0;if(L){let Z=!1;if(C!==null){const _e=C.texture.format;Z=_e===FI||_e===$I||_e===kI}if(Z){const _e=C.texture.type,Ae=_e===qo||_e===Uo||_e===j_||_e===ka||_e===UI||_e===BI,Oe=yt.getClearColor(),$e=yt.getClearAlpha(),Xe=Oe.r,Ve=Oe.g,He=Oe.b;Ae?(p[0]=Xe,p[1]=Ve,p[2]=He,p[3]=$e,X.clearBufferuiv(X.COLOR,0,p)):(g[0]=Xe,g[1]=Ve,g[2]=He,g[3]=$e,X.clearBufferiv(X.COLOR,0,g))}else ee|=X.COLOR_BUFFER_BIT}K&&(ee|=X.DEPTH_BUFFER_BIT),Q&&(ee|=X.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),X.clear(ee)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",he,!1),t.removeEventListener("webglcontextrestored",G,!1),t.removeEventListener("webglcontextcreationerror",ye,!1),Ee.dispose(),Ue.dispose(),qe.dispose(),I.dispose(),J.dispose(),ce.dispose(),Ge.dispose(),gt.dispose(),Te.dispose(),Ze.dispose(),Ze.removeEventListener("sessionstart",nr),Ze.removeEventListener("sessionend",Ct),j&&(j.dispose(),j=null),rr.stop()};function he(L){L.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),x=!0}function G(){console.log("THREE.WebGLRenderer: Context Restored."),x=!1;const L=kt.autoReset,K=ie.enabled,Q=ie.autoUpdate,ee=ie.needsUpdate,Z=ie.type;Vt(),kt.autoReset=L,ie.enabled=K,ie.autoUpdate=Q,ie.needsUpdate=ee,ie.type=Z}function ye(L){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",L.statusMessage)}function be(L){const K=L.target;K.removeEventListener("dispose",be),Be(K)}function Be(L){Re(L),qe.remove(L)}function Re(L){const K=qe.get(L).programs;K!==void 0&&(K.forEach(function(Q){Te.releaseProgram(Q)}),L.isShaderMaterial&&Te.releaseShaderCache(L))}this.renderBufferDirect=function(L,K,Q,ee,Z,_e){K===null&&(K=se);const Ae=Z.isMesh&&Z.matrixWorld.determinant()<0,Oe=YU(L,K,Q,ee,Z);xe.setMaterial(ee,Ae);let $e=Q.index,Xe=1;if(ee.wireframe===!0){if($e=oe.getWireframeAttribute(Q),$e===void 0)return;Xe=2}const Ve=Q.drawRange,He=Q.attributes.position;let Yt=Ve.start*Xe,Tr=(Ve.start+Ve.count)*Xe;_e!==null&&(Yt=Math.max(Yt,_e.start*Xe),Tr=Math.min(Tr,(_e.start+_e.count)*Xe)),$e!==null?(Yt=Math.max(Yt,0),Tr=Math.min(Tr,$e.count)):He!=null&&(Yt=Math.max(Yt,0),Tr=Math.min(Tr,He.count));const un=Tr-Yt;if(un<0||un===1/0)return;Ge.setup(Z,ee,Oe,Q,$e);let ms,$t=Fe;if($e!==null&&(ms=ae.get($e),$t=Ie,$t.setIndex(ms)),Z.isMesh)ee.wireframe===!0?(xe.setLineWidth(ee.wireframeLinewidth*ve()),$t.setMode(X.LINES)):$t.setMode(X.TRIANGLES);else if(Z.isLine){let je=ee.linewidth;je===void 0&&(je=1),xe.setLineWidth(je*ve()),Z.isLineSegments?$t.setMode(X.LINES):Z.isLineLoop?$t.setMode(X.LINE_LOOP):$t.setMode(X.LINE_STRIP)}else Z.isPoints?$t.setMode(X.POINTS):Z.isSprite&&$t.setMode(X.TRIANGLES);if(Z.isBatchedMesh)$t.renderMultiDraw(Z._multiDrawStarts,Z._multiDrawCounts,Z._multiDrawCount);else if(Z.isInstancedMesh)$t.renderInstances(Yt,un,Z.count);else if(Q.isInstancedBufferGeometry){const je=Q._maxInstanceCount!==void 0?Q._maxInstanceCount:1/0,cy=Math.min(Q.instanceCount,je);$t.renderInstances(Yt,un,cy)}else $t.render(Yt,un)};function At(L,K,Q){L.transparent===!0&&L.side===ns&&L.forceSinglePass===!1?(L.side=Er,L.needsUpdate=!0,mf(L,K,Q),L.side=Zo,L.needsUpdate=!0,mf(L,K,Q),L.side=ns):mf(L,K,Q)}this.compile=function(L,K,Q=null){Q===null&&(Q=L),m=Ue.get(Q),m.init(),E.push(m),Q.traverseVisible(function(Z){Z.isLight&&Z.layers.test(K.layers)&&(m.pushLight(Z),Z.castShadow&&m.pushShadow(Z))}),L!==Q&&L.traverseVisible(function(Z){Z.isLight&&Z.layers.test(K.layers)&&(m.pushLight(Z),Z.castShadow&&m.pushShadow(Z))}),m.setupLights(w._useLegacyLights);const ee=new Set;return L.traverse(function(Z){const _e=Z.material;if(_e)if(Array.isArray(_e))for(let Ae=0;Ae<_e.length;Ae++){const Oe=_e[Ae];At(Oe,Q,Z),ee.add(Oe)}else At(_e,Q,Z),ee.add(_e)}),E.pop(),m=null,ee},this.compileAsync=function(L,K,Q=null){const ee=this.compile(L,K,Q);return new Promise(Z=>{function _e(){if(ee.forEach(function(Ae){qe.get(Ae).currentProgram.isReady()&&ee.delete(Ae)}),ee.size===0){Z(L);return}setTimeout(_e,10)}Ce.get("KHR_parallel_shader_compile")!==null?_e():setTimeout(_e,10)})};let Mt=null;function ln(L){Mt&&Mt(L)}function nr(){rr.stop()}function Ct(){rr.start()}const rr=new nP;rr.setAnimationLoop(ln),typeof self<"u"&&rr.setContext(self),this.setAnimationLoop=function(L){Mt=L,Ze.setAnimationLoop(L),L===null?rr.stop():rr.start()},Ze.addEventListener("sessionstart",nr),Ze.addEventListener("sessionend",Ct),this.render=function(L,K){if(K!==void 0&&K.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(x===!0)return;L.matrixWorldAutoUpdate===!0&&L.updateMatrixWorld(),K.parent===null&&K.matrixWorldAutoUpdate===!0&&K.updateMatrixWorld(),Ze.enabled===!0&&Ze.isPresenting===!0&&(Ze.cameraAutoUpdate===!0&&Ze.updateCamera(K),K=Ze.getCamera()),L.isScene===!0&&L.onBeforeRender(w,L,K,C),m=Ue.get(L,E.length),m.init(),E.push(m),re.multiplyMatrices(K.projectionMatrix,K.matrixWorldInverse),H.setFromProjectionMatrix(re),te=this.localClippingEnabled,Y=Ke.init(this.clippingPlanes,te),b=Ee.get(L,y.length),b.init(),y.push(b),Hi(L,K,0,w.sortObjects),b.finish(),w.sortObjects===!0&&b.sort(B,O),this.info.render.frame++,Y===!0&&Ke.beginShadows();const Q=m.state.shadowsArray;if(ie.render(Q,L,K),Y===!0&&Ke.endShadows(),this.info.autoReset===!0&&this.info.reset(),yt.render(b,L),m.setupLights(w._useLegacyLights),K.isArrayCamera){const ee=K.cameras;for(let Z=0,_e=ee.length;Z<_e;Z++){const Ae=ee[Z];ax(b,L,Ae,Ae.viewport)}}else ax(b,L,K);C!==null&&(N.updateMultisampleRenderTarget(C),N.updateRenderTargetMipmap(C)),L.isScene===!0&&L.onAfterRender(w,L,K),Ge.resetDefaultState(),R=-1,_=null,E.pop(),E.length>0?m=E[E.length-1]:m=null,y.pop(),y.length>0?b=y[y.length-1]:b=null};function Hi(L,K,Q,ee){if(L.visible===!1)return;if(L.layers.test(K.layers)){if(L.isGroup)Q=L.renderOrder;else if(L.isLOD)L.autoUpdate===!0&&L.update(K);else if(L.isLight)m.pushLight(L),L.castShadow&&m.pushShadow(L);else if(L.isSprite){if(!L.frustumCulled||H.intersectsSprite(L)){ee&&fe.setFromMatrixPosition(L.matrixWorld).applyMatrix4(re);const Ae=ce.update(L),Oe=L.material;Oe.visible&&b.push(L,Ae,Oe,Q,fe.z,null)}}else if((L.isMesh||L.isLine||L.isPoints)&&(!L.frustumCulled||H.intersectsObject(L))){const Ae=ce.update(L),Oe=L.material;if(ee&&(L.boundingSphere!==void 0?(L.boundingSphere===null&&L.computeBoundingSphere(),fe.copy(L.boundingSphere.center)):(Ae.boundingSphere===null&&Ae.computeBoundingSphere(),fe.copy(Ae.boundingSphere.center)),fe.applyMatrix4(L.matrixWorld).applyMatrix4(re)),Array.isArray(Oe)){const $e=Ae.groups;for(let Xe=0,Ve=$e.length;Xe<Ve;Xe++){const He=$e[Xe],Yt=Oe[He.materialIndex];Yt&&Yt.visible&&b.push(L,Ae,Yt,Q,fe.z,He)}}else Oe.visible&&b.push(L,Ae,Oe,Q,fe.z,null)}}const _e=L.children;for(let Ae=0,Oe=_e.length;Ae<Oe;Ae++)Hi(_e[Ae],K,Q,ee)}function ax(L,K,Q,ee){const Z=L.opaque,_e=L.transmissive,Ae=L.transparent;m.setupLightsView(Q),Y===!0&&Ke.setGlobalState(w.clippingPlanes,Q),_e.length>0&&XU(Z,_e,K,Q),ee&&xe.viewport(T.copy(ee)),Z.length>0&&pf(Z,K,Q),_e.length>0&&pf(_e,K,Q),Ae.length>0&&pf(Ae,K,Q),xe.buffers.depth.setTest(!0),xe.buffers.depth.setMask(!0),xe.buffers.color.setMask(!0),xe.setPolygonOffset(!1)}function XU(L,K,Q,ee){if((Q.isScene===!0?Q.overrideMaterial:null)!==null)return;const _e=ke.isWebGL2;j===null&&(j=new Wa(1,1,{generateMipmaps:!0,type:Ce.has("EXT_color_buffer_half_float")?nd:qo,minFilter:td,samples:_e?4:0})),w.getDrawingBufferSize(le),_e?j.setSize(le.x,le.y):j.setSize(pv(le.x),pv(le.y));const Ae=w.getRenderTarget();w.setRenderTarget(j),w.getClearColor(z),v=w.getClearAlpha(),v<1&&w.setClearColor(16777215,.5),w.clear();const Oe=w.toneMapping;w.toneMapping=Wo,pf(L,Q,ee),N.updateMultisampleRenderTarget(j),N.updateRenderTargetMipmap(j);let $e=!1;for(let Xe=0,Ve=K.length;Xe<Ve;Xe++){const He=K[Xe],Yt=He.object,Tr=He.geometry,un=He.material,ms=He.group;if(un.side===ns&&Yt.layers.test(ee.layers)){const $t=un.side;un.side=Er,un.needsUpdate=!0,cx(Yt,Q,ee,Tr,un,ms),un.side=$t,un.needsUpdate=!0,$e=!0}}$e===!0&&(N.updateMultisampleRenderTarget(j),N.updateRenderTargetMipmap(j)),w.setRenderTarget(Ae),w.setClearColor(z,v),w.toneMapping=Oe}function pf(L,K,Q){const ee=K.isScene===!0?K.overrideMaterial:null;for(let Z=0,_e=L.length;Z<_e;Z++){const Ae=L[Z],Oe=Ae.object,$e=Ae.geometry,Xe=ee===null?Ae.material:ee,Ve=Ae.group;Oe.layers.test(Q.layers)&&cx(Oe,K,Q,$e,Xe,Ve)}}function cx(L,K,Q,ee,Z,_e){L.onBeforeRender(w,K,Q,ee,Z,_e),L.modelViewMatrix.multiplyMatrices(Q.matrixWorldInverse,L.matrixWorld),L.normalMatrix.getNormalMatrix(L.modelViewMatrix),Z.onBeforeRender(w,K,Q,ee,L,_e),Z.transparent===!0&&Z.side===ns&&Z.forceSinglePass===!1?(Z.side=Er,Z.needsUpdate=!0,w.renderBufferDirect(Q,K,ee,Z,L,_e),Z.side=Zo,Z.needsUpdate=!0,w.renderBufferDirect(Q,K,ee,Z,L,_e),Z.side=ns):w.renderBufferDirect(Q,K,ee,Z,L,_e),L.onAfterRender(w,K,Q,ee,Z,_e)}function mf(L,K,Q){K.isScene!==!0&&(K=se);const ee=qe.get(L),Z=m.state.lights,_e=m.state.shadowsArray,Ae=Z.state.version,Oe=Te.getParameters(L,Z.state,_e,K,Q),$e=Te.getProgramCacheKey(Oe);let Xe=ee.programs;ee.environment=L.isMeshStandardMaterial?K.environment:null,ee.fog=K.fog,ee.envMap=(L.isMeshStandardMaterial?J:I).get(L.envMap||ee.environment),Xe===void 0&&(L.addEventListener("dispose",be),Xe=new Map,ee.programs=Xe);let Ve=Xe.get($e);if(Ve!==void 0){if(ee.currentProgram===Ve&&ee.lightsStateVersion===Ae)return ux(L,Oe),Ve}else Oe.uniforms=Te.getUniforms(L),L.onBuild(Q,Oe,w),L.onBeforeCompile(Oe,w),Ve=Te.acquireProgram(Oe,$e),Xe.set($e,Ve),ee.uniforms=Oe.uniforms;const He=ee.uniforms;return(!L.isShaderMaterial&&!L.isRawShaderMaterial||L.clipping===!0)&&(He.clippingPlanes=Ke.uniform),ux(L,Oe),ee.needsLights=jU(L),ee.lightsStateVersion=Ae,ee.needsLights&&(He.ambientLightColor.value=Z.state.ambient,He.lightProbe.value=Z.state.probe,He.directionalLights.value=Z.state.directional,He.directionalLightShadows.value=Z.state.directionalShadow,He.spotLights.value=Z.state.spot,He.spotLightShadows.value=Z.state.spotShadow,He.rectAreaLights.value=Z.state.rectArea,He.ltc_1.value=Z.state.rectAreaLTC1,He.ltc_2.value=Z.state.rectAreaLTC2,He.pointLights.value=Z.state.point,He.pointLightShadows.value=Z.state.pointShadow,He.hemisphereLights.value=Z.state.hemi,He.directionalShadowMap.value=Z.state.directionalShadowMap,He.directionalShadowMatrix.value=Z.state.directionalShadowMatrix,He.spotShadowMap.value=Z.state.spotShadowMap,He.spotLightMatrix.value=Z.state.spotLightMatrix,He.spotLightMap.value=Z.state.spotLightMap,He.pointShadowMap.value=Z.state.pointShadowMap,He.pointShadowMatrix.value=Z.state.pointShadowMatrix),ee.currentProgram=Ve,ee.uniformsList=null,Ve}function lx(L){if(L.uniformsList===null){const K=L.currentProgram.getUniforms();L.uniformsList=Dp.seqWithValue(K.seq,L.uniforms)}return L.uniformsList}function ux(L,K){const Q=qe.get(L);Q.outputColorSpace=K.outputColorSpace,Q.batching=K.batching,Q.instancing=K.instancing,Q.instancingColor=K.instancingColor,Q.skinning=K.skinning,Q.morphTargets=K.morphTargets,Q.morphNormals=K.morphNormals,Q.morphColors=K.morphColors,Q.morphTargetsCount=K.morphTargetsCount,Q.numClippingPlanes=K.numClippingPlanes,Q.numIntersection=K.numClipIntersection,Q.vertexAlphas=K.vertexAlphas,Q.vertexTangents=K.vertexTangents,Q.toneMapping=K.toneMapping}function YU(L,K,Q,ee,Z){K.isScene!==!0&&(K=se),N.resetTextureUnits();const _e=K.fog,Ae=ee.isMeshStandardMaterial?K.environment:null,Oe=C===null?w.outputColorSpace:C.isXRRenderTarget===!0?C.texture.colorSpace:to,$e=(ee.isMeshStandardMaterial?J:I).get(ee.envMap||Ae),Xe=ee.vertexColors===!0&&!!Q.attributes.color&&Q.attributes.color.itemSize===4,Ve=!!Q.attributes.tangent&&(!!ee.normalMap||ee.anisotropy>0),He=!!Q.morphAttributes.position,Yt=!!Q.morphAttributes.normal,Tr=!!Q.morphAttributes.color;let un=Wo;ee.toneMapped&&(C===null||C.isXRRenderTarget===!0)&&(un=w.toneMapping);const ms=Q.morphAttributes.position||Q.morphAttributes.normal||Q.morphAttributes.color,$t=ms!==void 0?ms.length:0,je=qe.get(ee),cy=m.state.lights;if(Y===!0&&(te===!0||L!==_)){const Vr=L===_&&ee.id===R;Ke.setState(ee,L,Vr)}let Ht=!1;ee.version===je.__version?(je.needsLights&&je.lightsStateVersion!==cy.state.version||je.outputColorSpace!==Oe||Z.isBatchedMesh&&je.batching===!1||!Z.isBatchedMesh&&je.batching===!0||Z.isInstancedMesh&&je.instancing===!1||!Z.isInstancedMesh&&je.instancing===!0||Z.isSkinnedMesh&&je.skinning===!1||!Z.isSkinnedMesh&&je.skinning===!0||Z.isInstancedMesh&&je.instancingColor===!0&&Z.instanceColor===null||Z.isInstancedMesh&&je.instancingColor===!1&&Z.instanceColor!==null||je.envMap!==$e||ee.fog===!0&&je.fog!==_e||je.numClippingPlanes!==void 0&&(je.numClippingPlanes!==Ke.numPlanes||je.numIntersection!==Ke.numIntersection)||je.vertexAlphas!==Xe||je.vertexTangents!==Ve||je.morphTargets!==He||je.morphNormals!==Yt||je.morphColors!==Tr||je.toneMapping!==un||ke.isWebGL2===!0&&je.morphTargetsCount!==$t)&&(Ht=!0):(Ht=!0,je.__version=ee.version);let aa=je.currentProgram;Ht===!0&&(aa=mf(ee,K,Z));let hx=!1,Zu=!1,ly=!1;const Dn=aa.getUniforms(),ca=je.uniforms;if(xe.useProgram(aa.program)&&(hx=!0,Zu=!0,ly=!0),ee.id!==R&&(R=ee.id,Zu=!0),hx||_!==L){Dn.setValue(X,"projectionMatrix",L.projectionMatrix),Dn.setValue(X,"viewMatrix",L.matrixWorldInverse);const Vr=Dn.map.cameraPosition;Vr!==void 0&&Vr.setValue(X,fe.setFromMatrixPosition(L.matrixWorld)),ke.logarithmicDepthBuffer&&Dn.setValue(X,"logDepthBufFC",2/(Math.log(L.far+1)/Math.LN2)),(ee.isMeshPhongMaterial||ee.isMeshToonMaterial||ee.isMeshLambertMaterial||ee.isMeshBasicMaterial||ee.isMeshStandardMaterial||ee.isShaderMaterial)&&Dn.setValue(X,"isOrthographic",L.isOrthographicCamera===!0),_!==L&&(_=L,Zu=!0,ly=!0)}if(Z.isSkinnedMesh){Dn.setOptional(X,Z,"bindMatrix"),Dn.setOptional(X,Z,"bindMatrixInverse");const Vr=Z.skeleton;Vr&&(ke.floatVertexTextures?(Vr.boneTexture===null&&Vr.computeBoneTexture(),Dn.setValue(X,"boneTexture",Vr.boneTexture,N)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}Z.isBatchedMesh&&(Dn.setOptional(X,Z,"batchingTexture"),Dn.setValue(X,"batchingTexture",Z._matricesTexture,N));const uy=Q.morphAttributes;if((uy.position!==void 0||uy.normal!==void 0||uy.color!==void 0&&ke.isWebGL2===!0)&&et.update(Z,Q,aa),(Zu||je.receiveShadow!==Z.receiveShadow)&&(je.receiveShadow=Z.receiveShadow,Dn.setValue(X,"receiveShadow",Z.receiveShadow)),ee.isMeshGouraudMaterial&&ee.envMap!==null&&(ca.envMap.value=$e,ca.flipEnvMap.value=$e.isCubeTexture&&$e.isRenderTargetTexture===!1?-1:1),Zu&&(Dn.setValue(X,"toneMappingExposure",w.toneMappingExposure),je.needsLights&&ZU(ca,ly),_e&&ee.fog===!0&&we.refreshFogUniforms(ca,_e),we.refreshMaterialUniforms(ca,ee,U,P,j),Dp.upload(X,lx(je),ca,N)),ee.isShaderMaterial&&ee.uniformsNeedUpdate===!0&&(Dp.upload(X,lx(je),ca,N),ee.uniformsNeedUpdate=!1),ee.isSpriteMaterial&&Dn.setValue(X,"center",Z.center),Dn.setValue(X,"modelViewMatrix",Z.modelViewMatrix),Dn.setValue(X,"normalMatrix",Z.normalMatrix),Dn.setValue(X,"modelMatrix",Z.matrixWorld),ee.isShaderMaterial||ee.isRawShaderMaterial){const Vr=ee.uniformsGroups;for(let hy=0,JU=Vr.length;hy<JU;hy++)if(ke.isWebGL2){const dx=Vr[hy];gt.update(dx,aa),gt.bind(dx,aa)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return aa}function ZU(L,K){L.ambientLightColor.needsUpdate=K,L.lightProbe.needsUpdate=K,L.directionalLights.needsUpdate=K,L.directionalLightShadows.needsUpdate=K,L.pointLights.needsUpdate=K,L.pointLightShadows.needsUpdate=K,L.spotLights.needsUpdate=K,L.spotLightShadows.needsUpdate=K,L.rectAreaLights.needsUpdate=K,L.hemisphereLights.needsUpdate=K}function jU(L){return L.isMeshLambertMaterial||L.isMeshToonMaterial||L.isMeshPhongMaterial||L.isMeshStandardMaterial||L.isShadowMaterial||L.isShaderMaterial&&L.lights===!0}this.getActiveCubeFace=function(){return M},this.getActiveMipmapLevel=function(){return A},this.getRenderTarget=function(){return C},this.setRenderTargetTextures=function(L,K,Q){qe.get(L.texture).__webglTexture=K,qe.get(L.depthTexture).__webglTexture=Q;const ee=qe.get(L);ee.__hasExternalTextures=!0,ee.__hasExternalTextures&&(ee.__autoAllocateDepthBuffer=Q===void 0,ee.__autoAllocateDepthBuffer||Ce.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),ee.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(L,K){const Q=qe.get(L);Q.__webglFramebuffer=K,Q.__useDefaultFramebuffer=K===void 0},this.setRenderTarget=function(L,K=0,Q=0){C=L,M=K,A=Q;let ee=!0,Z=null,_e=!1,Ae=!1;if(L){const $e=qe.get(L);$e.__useDefaultFramebuffer!==void 0?(xe.bindFramebuffer(X.FRAMEBUFFER,null),ee=!1):$e.__webglFramebuffer===void 0?N.setupRenderTarget(L):$e.__hasExternalTextures&&N.rebindTextures(L,qe.get(L.texture).__webglTexture,qe.get(L.depthTexture).__webglTexture);const Xe=L.texture;(Xe.isData3DTexture||Xe.isDataArrayTexture||Xe.isCompressedArrayTexture)&&(Ae=!0);const Ve=qe.get(L).__webglFramebuffer;L.isWebGLCubeRenderTarget?(Array.isArray(Ve[K])?Z=Ve[K][Q]:Z=Ve[K],_e=!0):ke.isWebGL2&&L.samples>0&&N.useMultisampledRTT(L)===!1?Z=qe.get(L).__webglMultisampledFramebuffer:Array.isArray(Ve)?Z=Ve[Q]:Z=Ve,T.copy(L.viewport),F.copy(L.scissor),k=L.scissorTest}else T.copy(V).multiplyScalar(U).floor(),F.copy($).multiplyScalar(U).floor(),k=W;if(xe.bindFramebuffer(X.FRAMEBUFFER,Z)&&ke.drawBuffers&&ee&&xe.drawBuffers(L,Z),xe.viewport(T),xe.scissor(F),xe.setScissorTest(k),_e){const $e=qe.get(L.texture);X.framebufferTexture2D(X.FRAMEBUFFER,X.COLOR_ATTACHMENT0,X.TEXTURE_CUBE_MAP_POSITIVE_X+K,$e.__webglTexture,Q)}else if(Ae){const $e=qe.get(L.texture),Xe=K||0;X.framebufferTextureLayer(X.FRAMEBUFFER,X.COLOR_ATTACHMENT0,$e.__webglTexture,Q||0,Xe)}R=-1},this.readRenderTargetPixels=function(L,K,Q,ee,Z,_e,Ae){if(!(L&&L.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Oe=qe.get(L).__webglFramebuffer;if(L.isWebGLCubeRenderTarget&&Ae!==void 0&&(Oe=Oe[Ae]),Oe){xe.bindFramebuffer(X.FRAMEBUFFER,Oe);try{const $e=L.texture,Xe=$e.format,Ve=$e.type;if(Xe!==Di&&Se.convert(Xe)!==X.getParameter(X.IMPLEMENTATION_COLOR_READ_FORMAT)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const He=Ve===nd&&(Ce.has("EXT_color_buffer_half_float")||ke.isWebGL2&&Ce.has("EXT_color_buffer_float"));if(Ve!==qo&&Se.convert(Ve)!==X.getParameter(X.IMPLEMENTATION_COLOR_READ_TYPE)&&!(Ve===Bo&&(ke.isWebGL2||Ce.has("OES_texture_float")||Ce.has("WEBGL_color_buffer_float")))&&!He){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}K>=0&&K<=L.width-ee&&Q>=0&&Q<=L.height-Z&&X.readPixels(K,Q,ee,Z,Se.convert(Xe),Se.convert(Ve),_e)}finally{const $e=C!==null?qe.get(C).__webglFramebuffer:null;xe.bindFramebuffer(X.FRAMEBUFFER,$e)}}},this.copyFramebufferToTexture=function(L,K,Q=0){const ee=Math.pow(2,-Q),Z=Math.floor(K.image.width*ee),_e=Math.floor(K.image.height*ee);N.setTexture2D(K,0),X.copyTexSubImage2D(X.TEXTURE_2D,Q,0,0,L.x,L.y,Z,_e),xe.unbindTexture()},this.copyTextureToTexture=function(L,K,Q,ee=0){const Z=K.image.width,_e=K.image.height,Ae=Se.convert(Q.format),Oe=Se.convert(Q.type);N.setTexture2D(Q,0),X.pixelStorei(X.UNPACK_FLIP_Y_WEBGL,Q.flipY),X.pixelStorei(X.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Q.premultiplyAlpha),X.pixelStorei(X.UNPACK_ALIGNMENT,Q.unpackAlignment),K.isDataTexture?X.texSubImage2D(X.TEXTURE_2D,ee,L.x,L.y,Z,_e,Ae,Oe,K.image.data):K.isCompressedTexture?X.compressedTexSubImage2D(X.TEXTURE_2D,ee,L.x,L.y,K.mipmaps[0].width,K.mipmaps[0].height,Ae,K.mipmaps[0].data):X.texSubImage2D(X.TEXTURE_2D,ee,L.x,L.y,Ae,Oe,K.image),ee===0&&Q.generateMipmaps&&X.generateMipmap(X.TEXTURE_2D),xe.unbindTexture()},this.copyTextureToTexture3D=function(L,K,Q,ee,Z=0){if(w.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const _e=L.max.x-L.min.x+1,Ae=L.max.y-L.min.y+1,Oe=L.max.z-L.min.z+1,$e=Se.convert(ee.format),Xe=Se.convert(ee.type);let Ve;if(ee.isData3DTexture)N.setTexture3D(ee,0),Ve=X.TEXTURE_3D;else if(ee.isDataArrayTexture||ee.isCompressedArrayTexture)N.setTexture2DArray(ee,0),Ve=X.TEXTURE_2D_ARRAY;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}X.pixelStorei(X.UNPACK_FLIP_Y_WEBGL,ee.flipY),X.pixelStorei(X.UNPACK_PREMULTIPLY_ALPHA_WEBGL,ee.premultiplyAlpha),X.pixelStorei(X.UNPACK_ALIGNMENT,ee.unpackAlignment);const He=X.getParameter(X.UNPACK_ROW_LENGTH),Yt=X.getParameter(X.UNPACK_IMAGE_HEIGHT),Tr=X.getParameter(X.UNPACK_SKIP_PIXELS),un=X.getParameter(X.UNPACK_SKIP_ROWS),ms=X.getParameter(X.UNPACK_SKIP_IMAGES),$t=Q.isCompressedTexture?Q.mipmaps[Z]:Q.image;X.pixelStorei(X.UNPACK_ROW_LENGTH,$t.width),X.pixelStorei(X.UNPACK_IMAGE_HEIGHT,$t.height),X.pixelStorei(X.UNPACK_SKIP_PIXELS,L.min.x),X.pixelStorei(X.UNPACK_SKIP_ROWS,L.min.y),X.pixelStorei(X.UNPACK_SKIP_IMAGES,L.min.z),Q.isDataTexture||Q.isData3DTexture?X.texSubImage3D(Ve,Z,K.x,K.y,K.z,_e,Ae,Oe,$e,Xe,$t.data):Q.isCompressedArrayTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),X.compressedTexSubImage3D(Ve,Z,K.x,K.y,K.z,_e,Ae,Oe,$e,$t.data)):X.texSubImage3D(Ve,Z,K.x,K.y,K.z,_e,Ae,Oe,$e,Xe,$t),X.pixelStorei(X.UNPACK_ROW_LENGTH,He),X.pixelStorei(X.UNPACK_IMAGE_HEIGHT,Yt),X.pixelStorei(X.UNPACK_SKIP_PIXELS,Tr),X.pixelStorei(X.UNPACK_SKIP_ROWS,un),X.pixelStorei(X.UNPACK_SKIP_IMAGES,ms),Z===0&&ee.generateMipmaps&&X.generateMipmap(Ve),xe.unbindTexture()},this.initTexture=function(L){L.isCubeTexture?N.setTextureCube(L,0):L.isData3DTexture?N.setTexture3D(L,0):L.isDataArrayTexture||L.isCompressedArrayTexture?N.setTexture2DArray(L,0):N.setTexture2D(L,0),xe.unbindTexture()},this.resetState=function(){M=0,A=0,C=null,xe.reset(),Ge.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return ks}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e;const t=this.getContext();t.drawingBufferColorSpace=e===J_?"display-p3":"srgb",t.unpackColorSpace=bt.workingColorSpace===Sg?"display-p3":"srgb"}get outputEncoding(){return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace===_n?Fa:VI}set outputEncoding(e){console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace=e===Fa?_n:to}get useLegacyLights(){return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights}set useLegacyLights(e){console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights=e}}class a5 extends lP{}a5.prototype.isWebGL1Renderer=!0;class rE{constructor(e,t=25e-5){this.isFogExp2=!0,this.name="",this.color=new rt(e),this.density=t}clone(){return new rE(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class c5 extends sn{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(t.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(t.object.backgroundIntensity=this.backgroundIntensity),t}}class l5{constructor(e,t){this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=dv,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.version=0,this.uuid=Ko()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}get updateRange(){return console.warn("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,r){e*=this.stride,r*=t.stride;for(let i=0,s=this.stride;i<s;i++)this.array[e+i]=t.array[r+i];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ko()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),r=new this.constructor(t,this.stride);return r.setUsage(this.usage),r}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ko()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const ir=new q;class cm{constructor(e,t,r,i=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=r,this.normalized=i}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,r=this.data.count;t<r;t++)ir.fromBufferAttribute(this,t),ir.applyMatrix4(e),this.setXYZ(t,ir.x,ir.y,ir.z);return this}applyNormalMatrix(e){for(let t=0,r=this.count;t<r;t++)ir.fromBufferAttribute(this,t),ir.applyNormalMatrix(e),this.setXYZ(t,ir.x,ir.y,ir.z);return this}transformDirection(e){for(let t=0,r=this.count;t<r;t++)ir.fromBufferAttribute(this,t),ir.transformDirection(e),this.setXYZ(t,ir.x,ir.y,ir.z);return this}setX(e,t){return this.normalized&&(t=Et(t,this.array)),this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.normalized&&(t=Et(t,this.array)),this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.normalized&&(t=Et(t,this.array)),this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.normalized&&(t=Et(t,this.array)),this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){let t=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(t=Bs(t,this.array)),t}getY(e){let t=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(t=Bs(t,this.array)),t}getZ(e){let t=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(t=Bs(t,this.array)),t}getW(e){let t=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(t=Bs(t,this.array)),t}setXY(e,t,r){return e=e*this.data.stride+this.offset,this.normalized&&(t=Et(t,this.array),r=Et(r,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=r,this}setXYZ(e,t,r,i){return e=e*this.data.stride+this.offset,this.normalized&&(t=Et(t,this.array),r=Et(r,this.array),i=Et(i,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=r,this.data.array[e+2]=i,this}setXYZW(e,t,r,i,s){return e=e*this.data.stride+this.offset,this.normalized&&(t=Et(t,this.array),r=Et(r,this.array),i=Et(i,this.array),s=Et(s,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=r,this.data.array[e+2]=i,this.data.array[e+3]=s,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let r=0;r<this.count;r++){const i=r*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)t.push(this.data.array[i+s])}return new Oi(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new cm(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let r=0;r<this.count;r++){const i=r*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)t.push(this.data.array[i+s])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class uP extends Du{constructor(e){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new rt(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}let Oc;const th=new q,Nc=new q,Uc=new q,Bc=new Ye,nh=new Ye,hP=new nn,$f=new q,rh=new q,Ff=new q,L1=new Ye,Gy=new Ye,O1=new Ye;class u5 extends sn{constructor(e=new uP){if(super(),this.isSprite=!0,this.type="Sprite",Oc===void 0){Oc=new oo;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),r=new l5(t,5);Oc.setIndex([0,1,2,0,2,3]),Oc.setAttribute("position",new cm(r,3,0,!1)),Oc.setAttribute("uv",new cm(r,2,3,!1))}this.geometry=Oc,this.material=e,this.center=new Ye(.5,.5)}raycast(e,t){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Nc.setFromMatrixScale(this.matrixWorld),hP.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),Uc.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&Nc.multiplyScalar(-Uc.z);const r=this.material.rotation;let i,s;r!==0&&(s=Math.cos(r),i=Math.sin(r));const o=this.center;zf($f.set(-.5,-.5,0),Uc,o,Nc,i,s),zf(rh.set(.5,-.5,0),Uc,o,Nc,i,s),zf(Ff.set(.5,.5,0),Uc,o,Nc,i,s),L1.set(0,0),Gy.set(1,0),O1.set(1,1);let a=e.ray.intersectTriangle($f,rh,Ff,!1,th);if(a===null&&(zf(rh.set(-.5,.5,0),Uc,o,Nc,i,s),Gy.set(0,1),a=e.ray.intersectTriangle($f,Ff,rh,!1,th),a===null))return;const c=e.ray.origin.distanceTo(th);c<e.near||c>e.far||t.push({distance:c,point:th.clone(),uv:Xr.getInterpolation(th,$f,rh,Ff,L1,Gy,O1,new Ye),face:null,object:this})}copy(e,t){return super.copy(e,t),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}function zf(n,e,t,r,i,s){Bc.subVectors(n,t).addScalar(.5).multiply(r),i!==void 0?(nh.x=s*Bc.x-i*Bc.y,nh.y=i*Bc.x+s*Bc.y):nh.copy(Bc),n.copy(e),n.x+=nh.x,n.y+=nh.y,n.applyMatrix4(hP)}class h5 extends Sr{constructor(e,t,r,i,s,o,a,c,l){super(e,t,r,i,s,o,a,c,l),this.isCanvasTexture=!0,this.needsUpdate=!0}}class iE extends oo{constructor(e=1,t=1,r=1,i=32,s=1,o=!1,a=0,c=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:r,radialSegments:i,heightSegments:s,openEnded:o,thetaStart:a,thetaLength:c};const l=this;i=Math.floor(i),s=Math.floor(s);const u=[],d=[],f=[],p=[];let g=0;const b=[],m=r/2;let y=0;E(),o===!1&&(e>0&&w(!0),t>0&&w(!1)),this.setIndex(u),this.setAttribute("position",new os(d,3)),this.setAttribute("normal",new os(f,3)),this.setAttribute("uv",new os(p,2));function E(){const x=new q,M=new q;let A=0;const C=(t-e)/r;for(let R=0;R<=s;R++){const _=[],T=R/s,F=T*(t-e)+e;for(let k=0;k<=i;k++){const z=k/i,v=z*c+a,S=Math.sin(v),P=Math.cos(v);M.x=F*S,M.y=-T*r+m,M.z=F*P,d.push(M.x,M.y,M.z),x.set(S,C,P).normalize(),f.push(x.x,x.y,x.z),p.push(z,1-T),_.push(g++)}b.push(_)}for(let R=0;R<i;R++)for(let _=0;_<s;_++){const T=b[_][R],F=b[_+1][R],k=b[_+1][R+1],z=b[_][R+1];u.push(T,F,z),u.push(F,k,z),A+=6}l.addGroup(y,A,0),y+=A}function w(x){const M=g,A=new Ye,C=new q;let R=0;const _=x===!0?e:t,T=x===!0?1:-1;for(let k=1;k<=i;k++)d.push(0,m*T,0),f.push(0,T,0),p.push(.5,.5),g++;const F=g;for(let k=0;k<=i;k++){const v=k/i*c+a,S=Math.cos(v),P=Math.sin(v);C.x=_*P,C.y=m*T,C.z=_*S,d.push(C.x,C.y,C.z),f.push(0,T,0),A.x=S*.5+.5,A.y=P*.5*T+.5,p.push(A.x,A.y),g++}for(let k=0;k<i;k++){const z=M+k,v=F+k;x===!0?u.push(v,v+1,z):u.push(v+1,v,z),R+=3}l.addGroup(y,R,x===!0?1:2),y+=R}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new iE(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class sE extends iE{constructor(e=1,t=1,r=32,i=1,s=!1,o=0,a=Math.PI*2){super(0,e,t,r,i,s,o,a),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:r,heightSegments:i,openEnded:s,thetaStart:o,thetaLength:a}}static fromJSON(e){return new sE(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class rd extends Du{constructor(e){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new rt(16777215),this.specular=new rt(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new rt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=HI,this.normalScale=new Ye(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Z_,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class dP extends sn{constructor(e,t=1){super(),this.isLight=!0,this.type="Light",this.color=new rt(e),this.intensity=t}dispose(){}copy(e,t){return super.copy(e,t),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}}const Wy=new nn,N1=new q,U1=new q;class d5{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Ye(512,512),this.map=null,this.mapPass=null,this.matrix=new nn,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new tE,this._frameExtents=new Ye(1,1),this._viewportCount=1,this._viewports=[new mn(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,r=this.matrix;N1.setFromMatrixPosition(e.matrixWorld),t.position.copy(N1),U1.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(U1),t.updateMatrixWorld(),Wy.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Wy),r.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),r.multiply(Wy)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class f5 extends d5{constructor(){super(new Lr(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(e){const t=this.camera,r=om*2*e.angle*this.focus,i=this.mapSize.width/this.mapSize.height,s=e.distance||t.far;(r!==t.fov||i!==t.aspect||s!==t.far)&&(t.fov=r,t.aspect=i,t.far=s,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class fP extends dP{constructor(e,t,r=0,i=Math.PI/3,s=0,o=2){super(e,t),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(sn.DEFAULT_UP),this.updateMatrix(),this.target=new sn,this.distance=r,this.angle=i,this.penumbra=s,this.decay=o,this.map=null,this.shadow=new f5}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class p5 extends dP{constructor(e,t){super(e,t),this.isAmbientLight=!0,this.type="AmbientLight"}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Y_}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Y_);var gb;let Lu=(gb=class extends Error{constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}},h(gb,"name","InvalidParametersError"),gb);var yb;let pP=(yb=class extends Error{constructor(e="Invalid public key"){super(e),this.name="InvalidPublicKeyError"}},h(yb,"name","InvalidPublicKeyError"),yb);var bb;let mP=(bb=class extends Error{constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}},h(bb,"name","UnsupportedKeyTypeError"),bb);var Xi,FM;let fr=(FM=class extends EventTarget{constructor(){super();me(this,Xi,new Map)}listenerCount(t){const r=D(this,Xi).get(t);return r==null?0:r.length}addEventListener(t,r,i){super.addEventListener(t,r,i);let s=D(this,Xi).get(t);s==null&&(s=[],D(this,Xi).set(t,s)),s.push({callback:r,once:(i!==!0&&i!==!1&&(i==null?void 0:i.once))??!1})}removeEventListener(t,r,i){super.removeEventListener(t.toString(),r??null,i);let s=D(this,Xi).get(t);s!=null&&(s=s.filter(({callback:o})=>o!==r),D(this,Xi).set(t,s))}dispatchEvent(t){const r=super.dispatchEvent(t);let i=D(this,Xi).get(t.type);return i==null||(i=i.filter(({once:s})=>!s),D(this,Xi).set(t.type,i)),r}safeDispatchEvent(t,r={}){return this.dispatchEvent(new CustomEvent(t,r))}},Xi=new WeakMap,FM);function m5(n,e){if(n===e)return!0;if(n.byteLength!==e.byteLength)return!1;for(let t=0;t<n.byteLength;t++)if(n[t]!==e[t])return!1;return!0}function Mg(n){if(n instanceof Uint8Array&&n.constructor.name==="Uint8Array")return n;if(n instanceof ArrayBuffer)return new Uint8Array(n);if(ArrayBuffer.isView(n))return new Uint8Array(n.buffer,n.byteOffset,n.byteLength);throw new Error("Unknown type, must be binary type")}function g5(n){return new TextEncoder().encode(n)}function y5(n){return new TextDecoder().decode(n)}function b5(n,e){if(n.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),r=0;r<t.length;r++)t[r]=255;for(var i=0;i<n.length;i++){var s=n.charAt(i),o=s.charCodeAt(0);if(t[o]!==255)throw new TypeError(s+" is ambiguous");t[o]=i}var a=n.length,c=n.charAt(0),l=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function d(g){if(g instanceof Uint8Array||(ArrayBuffer.isView(g)?g=new Uint8Array(g.buffer,g.byteOffset,g.byteLength):Array.isArray(g)&&(g=Uint8Array.from(g))),!(g instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(g.length===0)return"";for(var b=0,m=0,y=0,E=g.length;y!==E&&g[y]===0;)y++,b++;for(var w=(E-y)*u+1>>>0,x=new Uint8Array(w);y!==E;){for(var M=g[y],A=0,C=w-1;(M!==0||A<m)&&C!==-1;C--,A++)M+=256*x[C]>>>0,x[C]=M%a>>>0,M=M/a>>>0;if(M!==0)throw new Error("Non-zero carry");m=A,y++}for(var R=w-m;R!==w&&x[R]===0;)R++;for(var _=c.repeat(b);R<w;++R)_+=n.charAt(x[R]);return _}function f(g){if(typeof g!="string")throw new TypeError("Expected String");if(g.length===0)return new Uint8Array;var b=0;if(g[b]!==" "){for(var m=0,y=0;g[b]===c;)m++,b++;for(var E=(g.length-b)*l+1>>>0,w=new Uint8Array(E);g[b];){var x=t[g.charCodeAt(b)];if(x===255)return;for(var M=0,A=E-1;(x!==0||M<y)&&A!==-1;A--,M++)x+=a*w[A]>>>0,w[A]=x%256>>>0,x=x/256>>>0;if(x!==0)throw new Error("Non-zero carry");y=M,b++}if(g[b]!==" "){for(var C=E-y;C!==E&&w[C]===0;)C++;for(var R=new Uint8Array(m+(E-C)),_=m;C!==E;)R[_++]=w[C++];return R}}}function p(g){var b=f(g);if(b)return b;throw new Error(`Non-${e} character`)}return{encode:d,decodeUnsafe:f,decode:p}}var w5=b5,v5=w5;let _5=class{constructor(e,t,r){h(this,"name");h(this,"prefix");h(this,"baseEncode");this.name=e,this.prefix=t,this.baseEncode=r}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},E5=class{constructor(e,t,r){h(this,"name");h(this,"prefix");h(this,"baseDecode");h(this,"prefixCodePoint");this.name=e,this.prefix=t;const i=t.codePointAt(0);if(i===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=i,this.baseDecode=r}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return gP(this,e)}},S5=class{constructor(e){h(this,"decoders");this.decoders=e}or(e){return gP(this,e)}decode(e){const t=e[0],r=this.decoders[t];if(r!=null)return r.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};function gP(n,e){return new S5({...n.decoders??{[n.prefix]:n},...e.decoders??{[e.prefix]:e}})}let x5=class{constructor(e,t,r,i){h(this,"name");h(this,"prefix");h(this,"baseEncode");h(this,"baseDecode");h(this,"encoder");h(this,"decoder");this.name=e,this.prefix=t,this.baseEncode=r,this.baseDecode=i,this.encoder=new _5(e,t,r),this.decoder=new E5(e,t,i)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}};function Cg({name:n,prefix:e,encode:t,decode:r}){return new x5(n,e,t,r)}function Yd({name:n,prefix:e,alphabet:t}){const{encode:r,decode:i}=v5(t,n);return Cg({prefix:e,name:n,encode:r,decode:s=>Mg(i(s))})}function T5(n,e,t,r){let i=n.length;for(;n[i-1]==="=";)--i;const s=new Uint8Array(i*t/8|0);let o=0,a=0,c=0;for(let l=0;l<i;++l){const u=e[n[l]];if(u===void 0)throw new SyntaxError(`Non-${r} character`);a=a<<t|u,o+=t,o>=8&&(o-=8,s[c++]=255&a>>o)}if(o>=t||(255&a<<8-o)!==0)throw new SyntaxError("Unexpected end of data");return s}function A5(n,e,t){const r=e[e.length-1]==="=",i=(1<<t)-1;let s="",o=0,a=0;for(let c=0;c<n.length;++c)for(a=a<<8|n[c],o+=8;o>t;)o-=t,s+=e[i&a>>o];if(o!==0&&(s+=e[i&a<<t-o]),r)for(;(s.length*t&7)!==0;)s+="=";return s}function M5(n){const e={};for(let t=0;t<n.length;++t)e[n[t]]=t;return e}function In({name:n,prefix:e,bitsPerChar:t,alphabet:r}){const i=M5(r);return Cg({prefix:e,name:n,encode(s){return A5(s,r,t)},decode(s){return T5(s,i,t,n)}})}const at=Yd({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),C5=Yd({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),I5=Object.freeze(Object.defineProperty({__proto__:null,base58btc:at,base58flickr:C5},Symbol.toStringTag,{value:"Module"})),yn=In({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),P5=In({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),D5=In({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),R5=In({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),L5=In({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),O5=In({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),N5=In({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),U5=In({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),B5=In({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),k5=Object.freeze(Object.defineProperty({__proto__:null,base32:yn,base32hex:L5,base32hexpad:N5,base32hexpadupper:U5,base32hexupper:O5,base32pad:D5,base32padupper:R5,base32upper:P5,base32z:B5},Symbol.toStringTag,{value:"Module"})),Rp=Yd({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),$5=Yd({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),F5=Object.freeze(Object.defineProperty({__proto__:null,base36:Rp,base36upper:$5},Symbol.toStringTag,{value:"Module"}));var z5=yP,B1=128,V5=-128,H5=Math.pow(2,31);function yP(n,e,t){e=e||[],t=t||0;for(var r=t;n>=H5;)e[t++]=n&255|B1,n/=128;for(;n&V5;)e[t++]=n&255|B1,n>>>=7;return e[t]=n|0,yP.bytes=t-r+1,e}var G5=gv,W5=128,k1=127;function gv(n,r){var t=0,r=r||0,i=0,s=r,o,a=n.length;do{if(s>=a)throw gv.bytes=0,new RangeError("Could not decode varint");o=n[s++],t+=i<28?(o&k1)<<i:(o&k1)*Math.pow(2,i),i+=7}while(o>=W5);return gv.bytes=s-r,t}var q5=Math.pow(2,7),K5=Math.pow(2,14),X5=Math.pow(2,21),Y5=Math.pow(2,28),Z5=Math.pow(2,35),j5=Math.pow(2,42),J5=Math.pow(2,49),Q5=Math.pow(2,56),e8=Math.pow(2,63),t8=function(n){return n<q5?1:n<K5?2:n<X5?3:n<Y5?4:n<Z5?5:n<j5?6:n<J5?7:n<Q5?8:n<e8?9:10},n8={encode:z5,decode:G5,encodingLength:t8},lm=n8;function yv(n,e=0){return[lm.decode(n,e),lm.decode.bytes]}function um(n,e,t=0){return lm.encode(n,e,t),e}function hm(n){return lm.encodingLength(n)}function Ig(n,e){const t=e.byteLength,r=hm(n),i=r+hm(t),s=new Uint8Array(i+t);return um(n,s,0),um(t,s,r),s.set(e,i),new oE(n,t,e,s)}function co(n){const e=Mg(n),[t,r]=yv(e),[i,s]=yv(e.subarray(r)),o=e.subarray(r+s);if(o.byteLength!==i)throw new Error("Incorrect length");return new oE(t,i,o,e)}function r8(n,e){if(n===e)return!0;{const t=e;return n.code===t.code&&n.size===t.size&&t.bytes instanceof Uint8Array&&m5(n.bytes,t.bytes)}}let oE=class{constructor(e,t,r,i){h(this,"code");h(this,"size");h(this,"digest");h(this,"bytes");this.code=e,this.size=t,this.digest=r,this.bytes=i}};function $1(n,e){const{bytes:t,version:r}=n;switch(r){case 0:return s8(t,bv(n),e??at.encoder);default:return o8(t,bv(n),e??yn.encoder)}}const F1=new WeakMap;function bv(n){const e=F1.get(n);if(e==null){const t=new Map;return F1.set(n,t),t}return e}var zM;let ze=class Un{constructor(e,t,r,i){h(this,"code");h(this,"version");h(this,"multihash");h(this,"bytes");h(this,"/");h(this,zM,"CID");this.code=t,this.version=e,this.multihash=r,this.bytes=i,this["/"]=i}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==ih)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==a8)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return Un.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,r=Ig(e,t);return Un.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return Un.equals(this,e)}static equals(e,t){const r=t;return r!=null&&e.code===r.code&&e.version===r.version&&r8(e.multihash,r.multihash)}toString(e){return $1(this,e)}toJSON(){return{"/":$1(this)}}link(){return this}[(zM=Symbol.toStringTag,Symbol.for("nodejs.util.inspect.custom"))](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const t=e;if(t instanceof Un)return t;if(t["/"]!=null&&t["/"]===t.bytes||t.asCID===t){const{version:r,code:i,multihash:s,bytes:o}=t;return new Un(r,i,s,o??z1(r,i,s.bytes))}else if(t[c8]===!0){const{version:r,multihash:i,code:s}=t,o=co(i);return Un.create(r,s,o)}else return null}static create(e,t,r){if(typeof t!="number")throw new Error("String codecs are no longer supported");if(!(r.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(t!==ih)throw new Error(`Version 0 CID must use dag-pb (code: ${ih}) block encoding`);return new Un(e,t,r,r.bytes)}case 1:{const i=z1(e,t,r.bytes);return new Un(e,t,r,i)}default:throw new Error("Invalid version")}}static createV0(e){return Un.create(0,ih,e)}static createV1(e,t){return Un.create(1,e,t)}static decode(e){const[t,r]=Un.decodeFirst(e);if(r.length!==0)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=Un.inspectBytes(e),r=t.size-t.multihashSize,i=Mg(e.subarray(r,r+t.multihashSize));if(i.byteLength!==t.multihashSize)throw new Error("Incorrect length");const s=i.subarray(t.multihashSize-t.digestSize),o=new oE(t.multihashCode,t.digestSize,s,i);return[t.version===0?Un.createV0(o):Un.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0;const r=()=>{const[d,f]=yv(e.subarray(t));return t+=f,d};let i=r(),s=ih;if(i===18?(i=0,t=0):s=r(),i!==0&&i!==1)throw new RangeError(`Invalid CID version ${i}`);const o=t,a=r(),c=r(),l=t+c,u=l-o;return{version:i,codec:s,multihashCode:a,digestSize:c,multihashSize:u,size:l}}static parse(e,t){const[r,i]=i8(e,t),s=Un.decode(i);if(s.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return bv(s).set(r,e),s}};function i8(n,e){switch(n[0]){case"Q":{const t=e??at;return[at.prefix,t.decode(`${at.prefix}${n}`)]}case at.prefix:{const t=e??at;return[at.prefix,t.decode(n)]}case yn.prefix:{const t=e??yn;return[yn.prefix,t.decode(n)]}case Rp.prefix:{const t=e??Rp;return[Rp.prefix,t.decode(n)]}default:{if(e==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[n[0],e.decode(n)]}}}function s8(n,e,t){const{prefix:r}=t;if(r!==at.prefix)throw Error(`Cannot string encode V0 in ${t.name} encoding`);const i=e.get(r);if(i==null){const s=t.encode(n).slice(1);return e.set(r,s),s}else return i}function o8(n,e,t){const{prefix:r}=t,i=e.get(r);if(i==null){const s=t.encode(n);return e.set(r,s),s}else return i}const ih=112,a8=18;function z1(n,e,t){const r=hm(n),i=r+hm(e),s=new Uint8Array(i+t.byteLength);return um(n,s,0),um(e,s,r),s.set(t,i),s}const c8=Symbol.for("@ipld/js-cid/CID"),bP=0,l8="identity",wP=Mg;function u8(n,e){if((e==null?void 0:e.truncate)!=null&&e.truncate!==n.byteLength){if(e.truncate<0||e.truncate>n.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${n.byteLength}`);n=n.subarray(0,e.truncate)}return Ig(bP,wP(n))}const Zt={code:bP,name:l8,encode:wP,digest:u8};function Ne(n,e){if(n===e)return!0;if(n.byteLength!==e.byteLength)return!1;for(let t=0;t<n.byteLength;t++)if(n[t]!==e[t])return!1;return!0}function ht(n=0){return new Uint8Array(n)}function zi(n=0){return new Uint8Array(n)}function nt(n,e){e==null&&(e=n.reduce((i,s)=>i+s.length,0));const t=zi(e);let r=0;for(const i of n)t.set(i,r),r+=i.length;return t}const vP=Symbol.for("@achingbrain/uint8arraylist");function V1(n,e){if(e==null||e<0)throw new RangeError("index is out of bounds");let t=0;for(const r of n){const i=t+r.byteLength;if(e<i)return{buf:r,index:e-t};t=i}throw new RangeError("index is out of bounds")}function Vf(n){return!!(n!=null&&n[vP])}var VM;let ut=class Lp{constructor(...e){h(this,"bufs");h(this,"length");h(this,VM,!0);this.bufs=[],this.length=0,e.length>0&&this.appendAll(e)}*[(VM=vP,Symbol.iterator)](){yield*this.bufs}get byteLength(){return this.length}append(...e){this.appendAll(e)}appendAll(e){let t=0;for(const r of e)if(r instanceof Uint8Array)t+=r.byteLength,this.bufs.push(r);else if(Vf(r))t+=r.byteLength,this.bufs.push(...r.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}prepend(...e){this.prependAll(e)}prependAll(e){let t=0;for(const r of e.reverse())if(r instanceof Uint8Array)t+=r.byteLength,this.bufs.unshift(r);else if(Vf(r))t+=r.byteLength,this.bufs.unshift(...r.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}get(e){const t=V1(this.bufs,e);return t.buf[t.index]}set(e,t){const r=V1(this.bufs,e);r.buf[r.index]=t}write(e,t=0){if(e instanceof Uint8Array)for(let r=0;r<e.length;r++)this.set(t+r,e[r]);else if(Vf(e))for(let r=0;r<e.length;r++)this.set(t+r,e.get(r));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(e){if(e=Math.trunc(e),!(Number.isNaN(e)||e<=0)){if(e===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(e>=this.bufs[0].byteLength)e-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(e),this.length-=e;break}}}slice(e,t){const{bufs:r,length:i}=this._subList(e,t);return nt(r,i)}subarray(e,t){const{bufs:r,length:i}=this._subList(e,t);return r.length===1?r[0]:nt(r,i)}sublist(e,t){const{bufs:r,length:i}=this._subList(e,t),s=new Lp;return s.length=i,s.bufs=[...r],s}_subList(e,t){if(e=e??0,t=t??this.length,e<0&&(e=this.length+e),t<0&&(t=this.length+t),e<0||t>this.length)throw new RangeError("index is out of bounds");if(e===t)return{bufs:[],length:0};if(e===0&&t===this.length)return{bufs:this.bufs,length:this.length};const r=[];let i=0;for(let s=0;s<this.bufs.length;s++){const o=this.bufs[s],a=i,c=a+o.byteLength;if(i=c,e>=c)continue;const l=e>=a&&e<c,u=t>a&&t<=c;if(l&&u){if(e===a&&t===c){r.push(o);break}const d=e-a;r.push(o.subarray(d,d+(t-e)));break}if(l){if(e===0){r.push(o);continue}r.push(o.subarray(e-a));continue}if(u){if(t===c){r.push(o);break}r.push(o.subarray(0,t-a));break}r.push(o)}return{bufs:r,length:t-e}}indexOf(e,t=0){if(!Vf(e)&&!(e instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const r=e instanceof Uint8Array?e:e.subarray();if(t=Number(t??0),isNaN(t)&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),e.length===0)return t>this.length?this.length:t;const i=r.byteLength;if(i===0)throw new TypeError("search must be at least 1 byte long");const s=256,o=new Int32Array(s);for(let d=0;d<s;d++)o[d]=-1;for(let d=0;d<i;d++)o[r[d]]=d;const a=o,c=this.byteLength-r.byteLength,l=r.byteLength-1;let u;for(let d=t;d<=c;d+=u){u=0;for(let f=l;f>=0;f--){const p=this.get(d+f);if(r[f]!==p){u=Math.max(1,f-a[p]);break}}if(u===0)return d}return-1}getInt8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getInt8(0)}setInt8(e,t){const r=zi(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setInt8(0,t),this.write(r,e)}getInt16(e,t){const r=this.subarray(e,e+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt16(0,t)}setInt16(e,t,r){const i=ht(2);new DataView(i.buffer,i.byteOffset,i.byteLength).setInt16(0,t,r),this.write(i,e)}getInt32(e,t){const r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt32(0,t)}setInt32(e,t,r){const i=ht(4);new DataView(i.buffer,i.byteOffset,i.byteLength).setInt32(0,t,r),this.write(i,e)}getBigInt64(e,t){const r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigInt64(0,t)}setBigInt64(e,t,r){const i=ht(8);new DataView(i.buffer,i.byteOffset,i.byteLength).setBigInt64(0,t,r),this.write(i,e)}getUint8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getUint8(0)}setUint8(e,t){const r=zi(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setUint8(0,t),this.write(r,e)}getUint16(e,t){const r=this.subarray(e,e+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint16(0,t)}setUint16(e,t,r){const i=ht(2);new DataView(i.buffer,i.byteOffset,i.byteLength).setUint16(0,t,r),this.write(i,e)}getUint32(e,t){const r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint32(0,t)}setUint32(e,t,r){const i=ht(4);new DataView(i.buffer,i.byteOffset,i.byteLength).setUint32(0,t,r),this.write(i,e)}getBigUint64(e,t){const r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigUint64(0,t)}setBigUint64(e,t,r){const i=ht(8);new DataView(i.buffer,i.byteOffset,i.byteLength).setBigUint64(0,t,r),this.write(i,e)}getFloat32(e,t){const r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat32(0,t)}setFloat32(e,t,r){const i=ht(4);new DataView(i.buffer,i.byteOffset,i.byteLength).setFloat32(0,t,r),this.write(i,e)}getFloat64(e,t){const r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat64(0,t)}setFloat64(e,t,r){const i=ht(8);new DataView(i.buffer,i.byteOffset,i.byteLength).setFloat64(0,t,r),this.write(i,e)}equals(e){if(e==null||!(e instanceof Lp)||e.bufs.length!==this.bufs.length)return!1;for(let t=0;t<this.bufs.length;t++)if(!Ne(this.bufs[t],e.bufs[t]))return!1;return!0}static fromUint8Arrays(e,t){const r=new Lp;return r.bufs=e,t==null&&(t=e.reduce((i,s)=>i+s.byteLength,0)),r.length=t,r}};const h8=Yd({prefix:"9",name:"base10",alphabet:"0123456789"}),d8=Object.freeze(Object.defineProperty({__proto__:null,base10:h8},Symbol.toStringTag,{value:"Module"})),f8=In({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),p8=In({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),m8=Object.freeze(Object.defineProperty({__proto__:null,base16:f8,base16upper:p8},Symbol.toStringTag,{value:"Module"})),g8=In({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),y8=Object.freeze(Object.defineProperty({__proto__:null,base2:g8},Symbol.toStringTag,{value:"Module"})),_P=Array.from(""),b8=_P.reduce((n,e,t)=>(n[t]=e,n),[]),w8=_P.reduce((n,e,t)=>{const r=e.codePointAt(0);if(r==null)throw new Error(`Invalid character: ${e}`);return n[r]=t,n},[]);function v8(n){return n.reduce((e,t)=>(e+=b8[t],e),"")}function _8(n){const e=[];for(const t of n){const r=t.codePointAt(0);if(r==null)throw new Error(`Invalid character: ${t}`);const i=w8[r];if(i==null)throw new Error(`Non-base256emoji character: ${t}`);e.push(i)}return new Uint8Array(e)}const E8=Cg({prefix:"",name:"base256emoji",encode:v8,decode:_8}),S8=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:E8},Symbol.toStringTag,{value:"Module"})),EP=In({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),x8=In({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),ui=In({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),T8=In({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),A8=Object.freeze(Object.defineProperty({__proto__:null,base64:EP,base64pad:x8,base64url:ui,base64urlpad:T8},Symbol.toStringTag,{value:"Module"})),M8=In({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),C8=Object.freeze(Object.defineProperty({__proto__:null,base8:M8},Symbol.toStringTag,{value:"Module"})),I8=Cg({prefix:"\0",name:"identity",encode:n=>y5(n),decode:n=>g5(n)}),P8=Object.freeze(Object.defineProperty({__proto__:null,identity:I8},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const D8=20;function R8({name:n,code:e,encode:t,minDigestLength:r,maxDigestLength:i}){return new L8(n,e,t,r,i)}let L8=class{constructor(e,t,r,i,s){h(this,"name");h(this,"code");h(this,"encode");h(this,"minDigestLength");h(this,"maxDigestLength");this.name=e,this.code=t,this.encode=r,this.minDigestLength=i??D8,this.maxDigestLength=s}digest(e,t){if((t==null?void 0:t.truncate)!=null){if(t.truncate<this.minDigestLength)throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);if(this.maxDigestLength!=null&&t.truncate>this.maxDigestLength)throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`)}if(e instanceof Uint8Array){const r=this.encode(e);return r instanceof Uint8Array?H1(r,this.code,t==null?void 0:t.truncate):r.then(i=>H1(i,this.code,t==null?void 0:t.truncate))}else throw Error("Unknown type, must be binary type")}};function H1(n,e,t){if(t!=null&&t!==n.byteLength){if(t>n.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${n.byteLength}`);n=n.subarray(0,t)}return Ig(e,n)}function O8(n){return async e=>new Uint8Array(await crypto.subtle.digest(n,e))}const ps=R8({name:"sha2-256",code:18,encode:O8("SHA-256")}),Fr={...P8,...y8,...C8,...d8,...m8,...k5,...F5,...I5,...A8,...S8};function SP(n,e,t,r){return{name:n,prefix:e,encoder:{name:n,prefix:e,encode:t},decoder:{decode:r}}}const G1=SP("utf8","u",n=>"u"+new TextDecoder("utf8").decode(n),n=>new TextEncoder().encode(n.substring(1))),qy=SP("ascii","a",n=>{let e="a";for(let t=0;t<n.length;t++)e+=String.fromCharCode(n[t]);return e},n=>{n=n.substring(1);const e=zi(n.length);for(let t=0;t<n.length;t++)e[t]=n.charCodeAt(t);return e}),xP={utf8:G1,"utf-8":G1,hex:Fr.base16,latin1:qy,ascii:qy,binary:qy,...Fr};function ge(n,e="utf8"){const t=xP[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.decoder.decode(`${t.prefix}${n}`)}function ne(n,e="utf8"){const t=xP[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.encoder.encode(n).substring(1)}const N8=parseInt("11111",2),wv=parseInt("10000000",2),U8=parseInt("01111111",2),W1={0:sh,1:sh,2:B8,3:F8,4:z8,5:$8,6:k8,16:sh,22:sh,48:sh};function Zd(n,e={offset:0}){const t=n[e.offset]&N8;if(e.offset++,W1[t]!=null)return W1[t](n,e);throw new Error("No decoder for tag "+t)}function jd(n,e){let t=0;if((n[e.offset]&wv)===wv){const r=n[e.offset]&U8;let i="0x";e.offset++;for(let s=0;s<r;s++,e.offset++)i+=n[e.offset].toString(16).padStart(2,"0");t=parseInt(i,16)}else t=n[e.offset],e.offset++;return t}function sh(n,e){jd(n,e);const t=[];for(;!(e.offset>=n.byteLength);){const r=Zd(n,e);if(r===null)break;t.push(r)}return t}function B8(n,e){const t=jd(n,e),r=e.offset,i=e.offset+t,s=[];for(let o=r;o<i;o++)o===r&&n[o]===0||s.push(n[o]);return e.offset+=t,Uint8Array.from(s)}function k8(n,e){const t=jd(n,e),r=e.offset+t,i=n[e.offset];e.offset++;let s=0,o=0;i<40?(s=0,o=i):i<80?(s=1,o=i-40):(s=2,o=i-80);let a=`${s}.${o}`,c=[];for(;e.offset<r;){const l=n[e.offset];if(e.offset++,c.push(l&127),l<128){c.reverse();let u=0;for(let d=0;d<c.length;d++)u+=c[d]<<d*7;a+=`.${u}`,c=[]}}return a}function $8(n,e){return e.offset++,null}function F8(n,e){const t=jd(n,e),r=n[e.offset];e.offset++;const i=n.subarray(e.offset,e.offset+t-1);if(e.offset+=t,r!==0)throw new Error("Unused bits in bit string is unimplemented");return i}function z8(n,e){const t=jd(n,e),r=n.subarray(e.offset,e.offset+t);return e.offset+=t,r}function V8(n){let e=n.toString(16);e.length%2===1&&(e="0"+e);const t=new ut;for(let r=0;r<e.length;r+=2)t.append(Uint8Array.from([parseInt(`${e[r]}${e[r+1]}`,16)]));return t}function aE(n){if(n.byteLength<128)return Uint8Array.from([n.byteLength]);const e=V8(n.byteLength);return new ut(Uint8Array.from([e.byteLength|wv]),e)}function vv(n){const e=new ut,t=128;return(n.subarray()[0]&t)===t&&e.append(Uint8Array.from([0])),e.append(n),new ut(Uint8Array.from([2]),aE(e),e)}function TP(n){const e=Uint8Array.from([0]),t=new ut(e,n);return new ut(Uint8Array.from([3]),aE(t),t)}function Bh(n,e=48){const t=new ut;for(const r of n)t.append(r);return new ut(Uint8Array.from([e]),aE(t),t)}const H8="1.2.840.10045.3.1.7",G8="1.3.132.0.34",W8="1.3.132.0.35";async function q8(n,e,t,r){var o,a;const i=await crypto.subtle.importKey("jwk",n,{name:"ECDSA",namedCurve:n.crv??"P-256"},!1,["verify"]);(o=r==null?void 0:r.signal)==null||o.throwIfAborted();const s=await crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},i,e,t.subarray());return(a=r==null?void 0:r.signal)==null||a.throwIfAborted(),s}const K8=Uint8Array.from([6,8,42,134,72,206,61,3,1,7]),X8=Uint8Array.from([6,5,43,129,4,0,34]),Y8=Uint8Array.from([6,5,43,129,4,0,35]),Z8={ext:!0,kty:"EC",crv:"P-256"},j8={ext:!0,kty:"EC",crv:"P-384"},J8={ext:!0,kty:"EC",crv:"P-521"},Ky=32,Xy=48,Yy=66;function AP(n){const e=Zd(n);return MP(e)}function MP(n){const e=n[1][1][0],t=1;let r,i;if(e.byteLength===Ky*2+1)return r=ne(e.subarray(t,t+Ky),"base64url"),i=ne(e.subarray(t+Ky),"base64url"),new Zy({...Z8,key_ops:["verify"],x:r,y:i});if(e.byteLength===Xy*2+1)return r=ne(e.subarray(t,t+Xy),"base64url"),i=ne(e.subarray(t+Xy),"base64url"),new Zy({...j8,key_ops:["verify"],x:r,y:i});if(e.byteLength===Yy*2+1)return r=ne(e.subarray(t,t+Yy),"base64url"),i=ne(e.subarray(t+Yy),"base64url"),new Zy({...J8,key_ops:["verify"],x:r,y:i});throw new Lu(`coordinates were wrong length, got ${e.byteLength}, expected 65, 97 or 133`)}function Q8(n){return Bh([vv(Uint8Array.from([1])),Bh([ez(n.crv)],160),Bh([TP(new ut(Uint8Array.from([4]),ge(n.x??"","base64url"),ge(n.y??"","base64url")))],161)]).subarray()}function ez(n){if(n==="P-256")return K8;if(n==="P-384")return X8;if(n==="P-521")return Y8;throw new Lu(`Invalid curve ${n}`)}let Zy=class{constructor(e){h(this,"type","ECDSA");h(this,"jwk");h(this,"_raw");this.jwk=e}get raw(){return this._raw==null&&(this._raw=Q8(this.jwk)),this._raw}toMultihash(){return Zt.digest(as(this))}toCID(){return ze.createV1(114,this.toMultihash())}toString(){return at.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Ne(this.raw,e.raw)}async verify(e,t,r){return q8(this.jwk,t,e,r)}};/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Pg(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function jo(n,e=""){if(!Number.isSafeInteger(n)||n<0){const t=e&&`"${e}" `;throw new Error(`${t}expected integer >= 0, got ${n}`)}}function tt(n,e,t=""){const r=Pg(n),i=n==null?void 0:n.length,s=e!==void 0;if(!r||s&&i!==e){const o=t&&`"${t}" `,a=s?` of length ${e}`:"",c=r?`length=${i}`:`type=${typeof n}`;throw new Error(o+"expected Uint8Array"+a+", got "+c)}return n}function Dg(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash must wrapped by utils.createHasher");jo(n.outputLen),jo(n.blockLen)}function dm(n,e=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(e&&n.finished)throw new Error("Hash#digest() has already been called")}function tz(n,e){tt(n,void 0,"digestInto() output");const t=e.outputLen;if(n.length<t)throw new Error('"digestInto() output" expected to be of length >='+t)}function Ka(...n){for(let e=0;e<n.length;e++)n[e].fill(0)}function jy(n){return new DataView(n.buffer,n.byteOffset,n.byteLength)}function Gi(n,e){return n<<32-e|n>>>e}const CP=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",nz=Array.from({length:256},(n,e)=>e.toString(16).padStart(2,"0"));function Jd(n){if(tt(n),CP)return n.toHex();let e="";for(let t=0;t<n.length;t++)e+=nz[n[t]];return e}const _s={_0:48,_9:57,A:65,F:70,a:97,f:102};function q1(n){if(n>=_s._0&&n<=_s._9)return n-_s._0;if(n>=_s.A&&n<=_s.F)return n-(_s.A-10);if(n>=_s.a&&n<=_s.f)return n-(_s.a-10)}function id(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);if(CP)return Uint8Array.fromHex(n);const e=n.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(t);for(let i=0,s=0;i<t;i++,s+=2){const o=q1(n.charCodeAt(s)),a=q1(n.charCodeAt(s+1));if(o===void 0||a===void 0){const c=n[s]+n[s+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+s)}r[i]=o*16+a}return r}function rs(...n){let e=0;for(let r=0;r<n.length;r++){const i=n[r];tt(i),e+=i.length}const t=new Uint8Array(e);for(let r=0,i=0;r<n.length;r++){const s=n[r];t.set(s,i),i+=s.length}return t}function IP(n,e={}){const t=(i,s)=>n(s).update(i).digest(),r=n(void 0);return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=i=>n(i),Object.assign(t,e),Object.freeze(t)}function Qd(n=32){const e=typeof globalThis=="object"?globalThis.crypto:null;if(typeof(e==null?void 0:e.getRandomValues)!="function")throw new Error("crypto.getRandomValues must be defined");return e.getRandomValues(new Uint8Array(n))}const PP=n=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,n])});function rz(n,e,t){return n&e^~n&t}function iz(n,e,t){return n&e^n&t^e&t}let DP=class{constructor(e,t,r,i){h(this,"blockLen");h(this,"outputLen");h(this,"padOffset");h(this,"isLE");h(this,"buffer");h(this,"view");h(this,"finished",!1);h(this,"length",0);h(this,"pos",0);h(this,"destroyed",!1);this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=i,this.buffer=new Uint8Array(e),this.view=jy(this.buffer)}update(e){dm(this),tt(e);const{view:t,buffer:r,blockLen:i}=this,s=e.length;for(let o=0;o<s;){const a=Math.min(i-this.pos,s-o);if(a===i){const c=jy(e);for(;i<=s-o;o+=i)this.process(c,o);continue}r.set(e.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===i&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){dm(this),tz(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:i,isLE:s}=this;let{pos:o}=this;t[o++]=128,Ka(this.buffer.subarray(o)),this.padOffset>i-o&&(this.process(r,0),o=0);for(let d=o;d<i;d++)t[d]=0;r.setBigUint64(i-8,BigInt(this.length*8),s),this.process(r,0);const a=jy(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen must be aligned to 32bit");const l=c/4,u=this.get();if(l>u.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<l;d++)a.setUint32(4*d,u[d],s)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:i,finished:s,destroyed:o,pos:a}=this;return e.destroyed=o,e.finished=s,e.length=i,e.pos=a,i%t&&e.buffer.set(r),e}clone(){return this._cloneInto()}};const bo=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),On=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),Hf=BigInt(2**32-1),K1=BigInt(32);function sz(n,e=!1){return e?{h:Number(n&Hf),l:Number(n>>K1&Hf)}:{h:Number(n>>K1&Hf)|0,l:Number(n&Hf)|0}}function oz(n,e=!1){const t=n.length;let r=new Uint32Array(t),i=new Uint32Array(t);for(let s=0;s<t;s++){const{h:o,l:a}=sz(n[s],e);[r[s],i[s]]=[o,a]}return[r,i]}const X1=(n,e,t)=>n>>>t,Y1=(n,e,t)=>n<<32-t|e>>>t,kc=(n,e,t)=>n>>>t|e<<32-t,$c=(n,e,t)=>n<<32-t|e>>>t,Gf=(n,e,t)=>n<<64-t|e>>>t-32,Wf=(n,e,t)=>n>>>t-32|e<<64-t;function Es(n,e,t,r){const i=(e>>>0)+(r>>>0);return{h:n+t+(i/2**32|0)|0,l:i|0}}const az=(n,e,t)=>(n>>>0)+(e>>>0)+(t>>>0),cz=(n,e,t,r)=>e+t+r+(n/2**32|0)|0,lz=(n,e,t,r)=>(n>>>0)+(e>>>0)+(t>>>0)+(r>>>0),uz=(n,e,t,r,i)=>e+t+r+i+(n/2**32|0)|0,hz=(n,e,t,r,i)=>(n>>>0)+(e>>>0)+(t>>>0)+(r>>>0)+(i>>>0),dz=(n,e,t,r,i,s)=>e+t+r+i+s+(n/2**32|0)|0,fz=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),wo=new Uint32Array(64);let pz=class extends DP{constructor(e){super(64,e,8,!1)}get(){const{A:e,B:t,C:r,D:i,E:s,F:o,G:a,H:c}=this;return[e,t,r,i,s,o,a,c]}set(e,t,r,i,s,o,a,c){this.A=e|0,this.B=t|0,this.C=r|0,this.D=i|0,this.E=s|0,this.F=o|0,this.G=a|0,this.H=c|0}process(e,t){for(let d=0;d<16;d++,t+=4)wo[d]=e.getUint32(t,!1);for(let d=16;d<64;d++){const f=wo[d-15],p=wo[d-2],g=Gi(f,7)^Gi(f,18)^f>>>3,b=Gi(p,17)^Gi(p,19)^p>>>10;wo[d]=b+wo[d-7]+g+wo[d-16]|0}let{A:r,B:i,C:s,D:o,E:a,F:c,G:l,H:u}=this;for(let d=0;d<64;d++){const f=Gi(a,6)^Gi(a,11)^Gi(a,25),p=u+f+rz(a,c,l)+fz[d]+wo[d]|0,b=(Gi(r,2)^Gi(r,13)^Gi(r,22))+iz(r,i,s)|0;u=l,l=c,c=a,a=o+p|0,o=s,s=i,i=r,r=p+b|0}r=r+this.A|0,i=i+this.B|0,s=s+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,l=l+this.G|0,u=u+this.H|0,this.set(r,i,s,o,a,c,l,u)}roundClean(){Ka(wo)}destroy(){this.set(0,0,0,0,0,0,0,0),Ka(this.buffer)}},mz=class extends pz{constructor(){super(32);h(this,"A",bo[0]|0);h(this,"B",bo[1]|0);h(this,"C",bo[2]|0);h(this,"D",bo[3]|0);h(this,"E",bo[4]|0);h(this,"F",bo[5]|0);h(this,"G",bo[6]|0);h(this,"H",bo[7]|0)}};const RP=oz(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(n=>BigInt(n))),gz=RP[0],yz=RP[1],vo=new Uint32Array(80),_o=new Uint32Array(80);let bz=class extends DP{constructor(e){super(128,e,16,!1)}get(){const{Ah:e,Al:t,Bh:r,Bl:i,Ch:s,Cl:o,Dh:a,Dl:c,Eh:l,El:u,Fh:d,Fl:f,Gh:p,Gl:g,Hh:b,Hl:m}=this;return[e,t,r,i,s,o,a,c,l,u,d,f,p,g,b,m]}set(e,t,r,i,s,o,a,c,l,u,d,f,p,g,b,m){this.Ah=e|0,this.Al=t|0,this.Bh=r|0,this.Bl=i|0,this.Ch=s|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=l|0,this.El=u|0,this.Fh=d|0,this.Fl=f|0,this.Gh=p|0,this.Gl=g|0,this.Hh=b|0,this.Hl=m|0}process(e,t){for(let w=0;w<16;w++,t+=4)vo[w]=e.getUint32(t),_o[w]=e.getUint32(t+=4);for(let w=16;w<80;w++){const x=vo[w-15]|0,M=_o[w-15]|0,A=kc(x,M,1)^kc(x,M,8)^X1(x,M,7),C=$c(x,M,1)^$c(x,M,8)^Y1(x,M,7),R=vo[w-2]|0,_=_o[w-2]|0,T=kc(R,_,19)^Gf(R,_,61)^X1(R,_,6),F=$c(R,_,19)^Wf(R,_,61)^Y1(R,_,6),k=lz(C,F,_o[w-7],_o[w-16]),z=uz(k,A,T,vo[w-7],vo[w-16]);vo[w]=z|0,_o[w]=k|0}let{Ah:r,Al:i,Bh:s,Bl:o,Ch:a,Cl:c,Dh:l,Dl:u,Eh:d,El:f,Fh:p,Fl:g,Gh:b,Gl:m,Hh:y,Hl:E}=this;for(let w=0;w<80;w++){const x=kc(d,f,14)^kc(d,f,18)^Gf(d,f,41),M=$c(d,f,14)^$c(d,f,18)^Wf(d,f,41),A=d&p^~d&b,C=f&g^~f&m,R=hz(E,M,C,yz[w],_o[w]),_=dz(R,y,x,A,gz[w],vo[w]),T=R|0,F=kc(r,i,28)^Gf(r,i,34)^Gf(r,i,39),k=$c(r,i,28)^Wf(r,i,34)^Wf(r,i,39),z=r&s^r&a^s&a,v=i&o^i&c^o&c;y=b|0,E=m|0,b=p|0,m=g|0,p=d|0,g=f|0,{h:d,l:f}=Es(l|0,u|0,_|0,T|0),l=a|0,u=c|0,a=s|0,c=o|0,s=r|0,o=i|0;const S=az(T,k,v);r=cz(S,_,F,z),i=S|0}({h:r,l:i}=Es(this.Ah|0,this.Al|0,r|0,i|0)),{h:s,l:o}=Es(this.Bh|0,this.Bl|0,s|0,o|0),{h:a,l:c}=Es(this.Ch|0,this.Cl|0,a|0,c|0),{h:l,l:u}=Es(this.Dh|0,this.Dl|0,l|0,u|0),{h:d,l:f}=Es(this.Eh|0,this.El|0,d|0,f|0),{h:p,l:g}=Es(this.Fh|0,this.Fl|0,p|0,g|0),{h:b,l:m}=Es(this.Gh|0,this.Gl|0,b|0,m|0),{h:y,l:E}=Es(this.Hh|0,this.Hl|0,y|0,E|0),this.set(r,i,s,o,a,c,l,u,d,f,p,g,b,m,y,E)}roundClean(){Ka(vo,_o)}destroy(){Ka(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}},wz=class extends bz{constructor(){super(64);h(this,"Ah",On[0]|0);h(this,"Al",On[1]|0);h(this,"Bh",On[2]|0);h(this,"Bl",On[3]|0);h(this,"Ch",On[4]|0);h(this,"Cl",On[5]|0);h(this,"Dh",On[6]|0);h(this,"Dl",On[7]|0);h(this,"Eh",On[8]|0);h(this,"El",On[9]|0);h(this,"Fh",On[10]|0);h(this,"Fl",On[11]|0);h(this,"Gh",On[12]|0);h(this,"Gl",On[13]|0);h(this,"Hh",On[14]|0);h(this,"Hl",On[15]|0)}};const kh=IP(()=>new mz,PP(1)),vz=IP(()=>new wz,PP(3));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const cE=BigInt(0),_v=BigInt(1);function Xa(n,e=""){if(typeof n!="boolean"){const t=e&&`"${e}" `;throw new Error(t+"expected boolean, got type="+typeof n)}return n}function LP(n){if(typeof n=="bigint"){if(!Op(n))throw new Error("positive bigint expected, got "+n)}else jo(n);return n}function qf(n){const e=LP(n).toString(16);return e.length&1?"0"+e:e}function OP(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return n===""?cE:BigInt("0x"+n)}function Rg(n){return OP(Jd(n))}function Ya(n){return OP(Jd(sd(tt(n)).reverse()))}function lE(n,e){jo(e),n=LP(n);const t=id(n.toString(16).padStart(e*2,"0"));if(t.length!==e)throw new Error("number too large");return t}function uE(n,e){return lE(n,e).reverse()}function sd(n){return Uint8Array.from(n)}const Op=n=>typeof n=="bigint"&&cE<=n;function _z(n,e,t){return Op(n)&&Op(e)&&Op(t)&&e<=n&&n<t}function od(n,e,t,r){if(!_z(e,t,r))throw new Error("expected valid "+n+": "+t+" <= n < "+r+", got "+e)}function Ez(n){let e;for(e=0;n>cE;n>>=_v,e+=1);return e}const hE=n=>(_v<<BigInt(n))-_v;function Sz(n,e,t){if(jo(n,"hashLen"),jo(e,"qByteLen"),typeof t!="function")throw new Error("hmacFn must be a function");const r=m=>new Uint8Array(m),i=Uint8Array.of(),s=Uint8Array.of(0),o=Uint8Array.of(1),a=1e3;let c=r(n),l=r(n),u=0;const d=()=>{c.fill(1),l.fill(0),u=0},f=(...m)=>t(l,rs(c,...m)),p=(m=i)=>{l=f(s,m),c=f(),m.length!==0&&(l=f(o,m),c=f())},g=()=>{if(u++>=a)throw new Error("drbg: tried max amount of iterations");let m=0;const y=[];for(;m<e;){c=f();const E=c.slice();y.push(E),m+=c.length}return rs(...y)};return(m,y)=>{d(),p(m);let E;for(;!(E=y(g()));)p();return d(),E}}function Ou(n,e={},t={}){if(!n||typeof n!="object")throw new Error("expected valid options object");function r(s,o,a){const c=n[s];if(a&&c===void 0)return;const l=typeof c;if(l!==o||c===null)throw new Error(`param "${s}" is invalid: expected ${o}, got ${l}`)}const i=(s,o)=>Object.entries(s).forEach(([a,c])=>r(a,c,o));i(e,!1),i(t,!0)}function fm(n){const e=new WeakMap;return(t,...r)=>{const i=e.get(t);if(i!==void 0)return i;const s=n(t,...r);return e.set(t,s),s}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const wr=BigInt(0),xn=BigInt(1),Sa=BigInt(2),NP=BigInt(3),UP=BigInt(4),BP=BigInt(5),xz=BigInt(7),kP=BigInt(8),Tz=BigInt(9),$P=BigInt(16);function qt(n,e){const t=n%e;return t>=wr?t:e+t}function Ft(n,e,t){let r=n;for(;e-- >wr;)r*=r,r%=t;return r}function Z1(n,e){if(n===wr)throw new Error("invert: expected non-zero number");if(e<=wr)throw new Error("invert: expected positive modulus, got "+e);let t=qt(n,e),r=e,i=wr,s=xn;for(;t!==wr;){const a=r/t,c=r%t,l=i-s*a;r=t,t=c,i=s,s=l}if(r!==xn)throw new Error("invert: does not exist");return qt(i,e)}function dE(n,e,t){if(!n.eql(n.sqr(e),t))throw new Error("Cannot find square root")}function FP(n,e){const t=(n.ORDER+xn)/UP,r=n.pow(e,t);return dE(n,r,e),r}function Az(n,e){const t=(n.ORDER-BP)/kP,r=n.mul(e,Sa),i=n.pow(r,t),s=n.mul(e,i),o=n.mul(n.mul(s,Sa),i),a=n.mul(s,n.sub(o,n.ONE));return dE(n,a,e),a}function Mz(n){const e=Lg(n),t=zP(n),r=t(e,e.neg(e.ONE)),i=t(e,r),s=t(e,e.neg(r)),o=(n+xz)/$P;return(a,c)=>{let l=a.pow(c,o),u=a.mul(l,r);const d=a.mul(l,i),f=a.mul(l,s),p=a.eql(a.sqr(u),c),g=a.eql(a.sqr(d),c);l=a.cmov(l,u,p),u=a.cmov(f,d,g);const b=a.eql(a.sqr(u),c),m=a.cmov(l,u,b);return dE(a,m,c),m}}function zP(n){if(n<NP)throw new Error("sqrt is not defined for small field");let e=n-xn,t=0;for(;e%Sa===wr;)e/=Sa,t++;let r=Sa;const i=Lg(n);for(;j1(i,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return FP;let s=i.pow(r,e);const o=(e+xn)/Sa;return function(c,l){if(c.is0(l))return l;if(j1(c,l)!==1)throw new Error("Cannot find square root");let u=t,d=c.mul(c.ONE,s),f=c.pow(l,e),p=c.pow(l,o);for(;!c.eql(f,c.ONE);){if(c.is0(f))return c.ZERO;let g=1,b=c.sqr(f);for(;!c.eql(b,c.ONE);)if(g++,b=c.sqr(b),g===u)throw new Error("Cannot find square root");const m=xn<<BigInt(u-g-1),y=c.pow(d,m);u=g,d=c.sqr(y),f=c.mul(f,d),p=c.mul(p,y)}return p}}function Cz(n){return n%UP===NP?FP:n%kP===BP?Az:n%$P===Tz?Mz(n):zP(n)}const Iz=(n,e)=>(qt(n,e)&xn)===xn,Pz=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Dz(n){const e={ORDER:"bigint",BYTES:"number",BITS:"number"},t=Pz.reduce((r,i)=>(r[i]="function",r),e);return Ou(n,t),n}function Rz(n,e,t){if(t<wr)throw new Error("invalid exponent, negatives unsupported");if(t===wr)return n.ONE;if(t===xn)return e;let r=n.ONE,i=e;for(;t>wr;)t&xn&&(r=n.mul(r,i)),i=n.sqr(i),t>>=xn;return r}function VP(n,e,t=!1){const r=new Array(e.length).fill(t?n.ZERO:void 0),i=e.reduce((o,a,c)=>n.is0(a)?o:(r[c]=o,n.mul(o,a)),n.ONE),s=n.inv(i);return e.reduceRight((o,a,c)=>n.is0(a)?o:(r[c]=n.mul(o,r[c]),n.mul(o,a)),s),r}function j1(n,e){const t=(n.ORDER-xn)/Sa,r=n.pow(e,t),i=n.eql(r,n.ONE),s=n.eql(r,n.ZERO),o=n.eql(r,n.neg(n.ONE));if(!i&&!s&&!o)throw new Error("invalid Legendre symbol result");return i?1:s?0:-1}function Lz(n,e){e!==void 0&&jo(e);const t=e!==void 0?e:n.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}let Oz=class{constructor(e,t={}){h(this,"ORDER");h(this,"BITS");h(this,"BYTES");h(this,"isLE");h(this,"ZERO",wr);h(this,"ONE",xn);h(this,"_lengths");h(this,"_sqrt");h(this,"_mod");var o;if(e<=wr)throw new Error("invalid field: expected ORDER > 0, got "+e);let r;this.isLE=!1,t!=null&&typeof t=="object"&&(typeof t.BITS=="number"&&(r=t.BITS),typeof t.sqrt=="function"&&(this.sqrt=t.sqrt),typeof t.isLE=="boolean"&&(this.isLE=t.isLE),t.allowedLengths&&(this._lengths=(o=t.allowedLengths)==null?void 0:o.slice()),typeof t.modFromBytes=="boolean"&&(this._mod=t.modFromBytes));const{nBitLength:i,nByteLength:s}=Lz(e,r);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=e,this.BITS=i,this.BYTES=s,this._sqrt=void 0,Object.preventExtensions(this)}create(e){return qt(e,this.ORDER)}isValid(e){if(typeof e!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof e);return wr<=e&&e<this.ORDER}is0(e){return e===wr}isValidNot0(e){return!this.is0(e)&&this.isValid(e)}isOdd(e){return(e&xn)===xn}neg(e){return qt(-e,this.ORDER)}eql(e,t){return e===t}sqr(e){return qt(e*e,this.ORDER)}add(e,t){return qt(e+t,this.ORDER)}sub(e,t){return qt(e-t,this.ORDER)}mul(e,t){return qt(e*t,this.ORDER)}pow(e,t){return Rz(this,e,t)}div(e,t){return qt(e*Z1(t,this.ORDER),this.ORDER)}sqrN(e){return e*e}addN(e,t){return e+t}subN(e,t){return e-t}mulN(e,t){return e*t}inv(e){return Z1(e,this.ORDER)}sqrt(e){return this._sqrt||(this._sqrt=Cz(this.ORDER)),this._sqrt(this,e)}toBytes(e){return this.isLE?uE(e,this.BYTES):lE(e,this.BYTES)}fromBytes(e,t=!1){tt(e);const{_lengths:r,BYTES:i,isLE:s,ORDER:o,_mod:a}=this;if(r){if(!r.includes(e.length)||e.length>i)throw new Error("Field.fromBytes: expected "+r+" bytes, got "+e.length);const l=new Uint8Array(i);l.set(e,s?0:l.length-e.length),e=l}if(e.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+e.length);let c=s?Ya(e):Rg(e);if(a&&(c=qt(c,o)),!t&&!this.isValid(c))throw new Error("invalid field element: outside of range 0..ORDER");return c}invertBatch(e){return VP(this,e)}cmov(e,t,r){return r?t:e}};function Lg(n,e={}){return new Oz(n,e)}function HP(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const e=n.toString(2).length;return Math.ceil(e/8)}function GP(n){const e=HP(n);return e+Math.ceil(e/2)}function Nz(n,e,t=!1){tt(n);const r=n.length,i=HP(e),s=GP(e);if(r<16||r<s||r>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+r);const o=t?Ya(n):Rg(n),a=qt(o,e-xn)+xn;return t?uE(a,i):lE(a,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ru=BigInt(0),xa=BigInt(1);function pm(n,e){const t=e.negate();return n?t:e}function $h(n,e){const t=VP(n.Fp,e.map(r=>r.Z));return e.map((r,i)=>n.fromAffine(r.toAffine(t[i])))}function WP(n,e){if(!Number.isSafeInteger(n)||n<=0||n>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+n)}function Jy(n,e){WP(n,e);const t=Math.ceil(e/n)+1,r=2**(n-1),i=2**n,s=hE(n),o=BigInt(n);return{windows:t,windowSize:r,mask:s,maxNumber:i,shiftBy:o}}function J1(n,e,t){const{windowSize:r,mask:i,maxNumber:s,shiftBy:o}=t;let a=Number(n&i),c=n>>o;a>r&&(a-=s,c+=xa);const l=e*r,u=l+Math.abs(a)-1,d=a===0,f=a<0,p=e%2!==0;return{nextN:c,offset:u,isZero:d,isNeg:f,isNegF:p,offsetF:l}}const Qy=new WeakMap,qP=new WeakMap;function e0(n){return qP.get(n)||1}function Q1(n){if(n!==ru)throw new Error("invalid wNAF")}let KP=class{constructor(e,t){h(this,"BASE");h(this,"ZERO");h(this,"Fn");h(this,"bits");this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=t}_unsafeLadder(e,t,r=this.ZERO){let i=e;for(;t>ru;)t&xa&&(r=r.add(i)),i=i.double(),t>>=xa;return r}precomputeWindow(e,t){const{windows:r,windowSize:i}=Jy(t,this.bits),s=[];let o=e,a=o;for(let c=0;c<r;c++){a=o,s.push(a);for(let l=1;l<i;l++)a=a.add(o),s.push(a);o=a.double()}return s}wNAF(e,t,r){if(!this.Fn.isValid(r))throw new Error("invalid scalar");let i=this.ZERO,s=this.BASE;const o=Jy(e,this.bits);for(let a=0;a<o.windows;a++){const{nextN:c,offset:l,isZero:u,isNeg:d,isNegF:f,offsetF:p}=J1(r,a,o);r=c,u?s=s.add(pm(f,t[p])):i=i.add(pm(d,t[l]))}return Q1(r),{p:i,f:s}}wNAFUnsafe(e,t,r,i=this.ZERO){const s=Jy(e,this.bits);for(let o=0;o<s.windows&&r!==ru;o++){const{nextN:a,offset:c,isZero:l,isNeg:u}=J1(r,o,s);if(r=a,!l){const d=t[c];i=i.add(u?d.negate():d)}}return Q1(r),i}getPrecomputes(e,t,r){let i=Qy.get(t);return i||(i=this.precomputeWindow(t,e),e!==1&&(typeof r=="function"&&(i=r(i)),Qy.set(t,i))),i}cached(e,t,r){const i=e0(e);return this.wNAF(i,this.getPrecomputes(i,e,r),t)}unsafe(e,t,r,i){const s=e0(e);return s===1?this._unsafeLadder(e,t,i):this.wNAFUnsafe(s,this.getPrecomputes(s,e,r),t,i)}createCache(e,t){WP(t,this.bits),qP.set(e,t),Qy.delete(e)}hasCache(e){return e0(e)!==1}};function Uz(n,e,t,r){let i=e,s=n.ZERO,o=n.ZERO;for(;t>ru||r>ru;)t&xa&&(s=s.add(i)),r&xa&&(o=o.add(i)),i=i.double(),t>>=xa,r>>=xa;return{p1:s,p2:o}}function eT(n,e,t){if(e){if(e.ORDER!==n)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return Dz(e),e}else return Lg(n,{isLE:t})}function XP(n,e,t={},r){if(r===void 0&&(r=n==="edwards"),!e||typeof e!="object")throw new Error(`expected valid ${n} CURVE object`);for(const c of["p","n","h"]){const l=e[c];if(!(typeof l=="bigint"&&l>ru))throw new Error(`CURVE.${c} must be positive bigint`)}const i=eT(e.p,t.Fp,r),s=eT(e.n,t.Fn,r),a=["Gx","Gy","a",n==="weierstrass"?"b":"d"];for(const c of a)if(!i.isValid(e[c]))throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);return e=Object.freeze(Object.assign({},e)),{CURVE:e,Fp:i,Fn:s}}function fE(n,e){return function(r){const i=n(r);return{secretKey:i,publicKey:e(i)}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Eo=BigInt(0),dn=BigInt(1),t0=BigInt(2),Bz=BigInt(8);function kz(n,e,t,r){const i=n.sqr(t),s=n.sqr(r),o=n.add(n.mul(e.a,i),s),a=n.add(n.ONE,n.mul(e.d,n.mul(i,s)));return n.eql(o,a)}function $z(n,e={}){const t=XP("edwards",n,e,e.FpFnLE),{Fp:r,Fn:i}=t;let s=t.CURVE;const{h:o}=s;Ou(e,{},{uvRatio:"function"});const a=t0<<BigInt(i.BYTES*8)-dn,c=y=>r.create(y),l=e.uvRatio||((y,E)=>{try{return{isValid:!0,value:r.sqrt(r.div(y,E))}}catch{return{isValid:!1,value:Eo}}});if(!kz(r,s,s.Gx,s.Gy))throw new Error("bad curve params: generator point");function u(y,E,w=!1){const x=w?dn:Eo;return od("coordinate "+y,E,x,a),E}function d(y){if(!(y instanceof g))throw new Error("EdwardsPoint expected")}const f=fm((y,E)=>{const{X:w,Y:x,Z:M}=y,A=y.is0();E==null&&(E=A?Bz:r.inv(M));const C=c(w*E),R=c(x*E),_=r.mul(M,E);if(A)return{x:Eo,y:dn};if(_!==dn)throw new Error("invZ was invalid");return{x:C,y:R}}),p=fm(y=>{const{a:E,d:w}=s;if(y.is0())throw new Error("bad point: ZERO");const{X:x,Y:M,Z:A,T:C}=y,R=c(x*x),_=c(M*M),T=c(A*A),F=c(T*T),k=c(R*E),z=c(T*c(k+_)),v=c(F+c(w*c(R*_)));if(z!==v)throw new Error("bad point: equation left != right (1)");const S=c(x*M),P=c(A*C);if(S!==P)throw new Error("bad point: equation left != right (2)");return!0}),m=class m{constructor(E,w,x,M){h(this,"X");h(this,"Y");h(this,"Z");h(this,"T");this.X=u("x",E),this.Y=u("y",w),this.Z=u("z",x,!0),this.T=u("t",M),Object.freeze(this)}static CURVE(){return s}static fromAffine(E){if(E instanceof m)throw new Error("extended point not allowed");const{x:w,y:x}=E||{};return u("x",w),u("y",x),new m(w,x,dn,c(w*x))}static fromBytes(E,w=!1){const x=r.BYTES,{a:M,d:A}=s;E=sd(tt(E,x,"point")),Xa(w,"zip215");const C=sd(E),R=E[x-1];C[x-1]=R&-129;const _=Ya(C),T=w?a:r.ORDER;od("point.y",_,Eo,T);const F=c(_*_),k=c(F-dn),z=c(A*F-M);let{isValid:v,value:S}=l(k,z);if(!v)throw new Error("bad point: invalid y coordinate");const P=(S&dn)===dn,U=(R&128)!==0;if(!w&&S===Eo&&U)throw new Error("bad point: x=0 and x_0=1");return U!==P&&(S=c(-S)),m.fromAffine({x:S,y:_})}static fromHex(E,w=!1){return m.fromBytes(id(E),w)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(E=8,w=!0){return b.createCache(this,E),w||this.multiply(t0),this}assertValidity(){p(this)}equals(E){d(E);const{X:w,Y:x,Z:M}=this,{X:A,Y:C,Z:R}=E,_=c(w*R),T=c(A*M),F=c(x*R),k=c(C*M);return _===T&&F===k}is0(){return this.equals(m.ZERO)}negate(){return new m(c(-this.X),this.Y,this.Z,c(-this.T))}double(){const{a:E}=s,{X:w,Y:x,Z:M}=this,A=c(w*w),C=c(x*x),R=c(t0*c(M*M)),_=c(E*A),T=w+x,F=c(c(T*T)-A-C),k=_+C,z=k-R,v=_-C,S=c(F*z),P=c(k*v),U=c(F*v),B=c(z*k);return new m(S,P,B,U)}add(E){d(E);const{a:w,d:x}=s,{X:M,Y:A,Z:C,T:R}=this,{X:_,Y:T,Z:F,T:k}=E,z=c(M*_),v=c(A*T),S=c(R*x*k),P=c(C*F),U=c((M+A)*(_+T)-z-v),B=P-S,O=P+S,V=c(v-w*z),$=c(U*B),W=c(O*V),H=c(U*V),Y=c(B*O);return new m($,W,Y,H)}subtract(E){return this.add(E.negate())}multiply(E){if(!i.isValidNot0(E))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:w,f:x}=b.cached(this,E,M=>$h(m,M));return $h(m,[w,x])[0]}multiplyUnsafe(E,w=m.ZERO){if(!i.isValid(E))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return E===Eo?m.ZERO:this.is0()||E===dn?this:b.unsafe(this,E,x=>$h(m,x),w)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}isTorsionFree(){return b.unsafe(this,s.n).is0()}toAffine(E){return f(this,E)}clearCofactor(){return o===dn?this:this.multiplyUnsafe(o)}toBytes(){const{x:E,y:w}=this.toAffine(),x=r.toBytes(w);return x[x.length-1]|=E&dn?128:0,x}toHex(){return Jd(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}};h(m,"BASE",new m(s.Gx,s.Gy,dn,c(s.Gx*s.Gy))),h(m,"ZERO",new m(Eo,dn,dn,Eo)),h(m,"Fp",r),h(m,"Fn",i);let g=m;const b=new KP(g,i.BITS);return g.BASE.precompute(8),g}function Fz(n,e,t={}){if(typeof e!="function")throw new Error('"hash" function param is required');Ou(t,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:r}=t,{BASE:i,Fp:s,Fn:o}=n,a=t.randomBytes||Qd,c=t.adjustScalarBytes||(R=>R),l=t.domain||((R,_,T)=>{if(Xa(T,"phflag"),_.length||T)throw new Error("Contexts/pre-hash are not supported");return R});function u(R){return o.create(Ya(R))}function d(R){const _=w.secretKey;tt(R,w.secretKey,"secretKey");const T=tt(e(R),2*_,"hashedSecretKey"),F=c(T.slice(0,_)),k=T.slice(_,2*_),z=u(F);return{head:F,prefix:k,scalar:z}}function f(R){const{head:_,prefix:T,scalar:F}=d(R),k=i.multiply(F),z=k.toBytes();return{head:_,prefix:T,scalar:F,point:k,pointBytes:z}}function p(R){return f(R).pointBytes}function g(R=Uint8Array.of(),..._){const T=rs(..._);return u(e(l(T,tt(R,void 0,"context"),!!r)))}function b(R,_,T={}){R=tt(R,void 0,"message"),r&&(R=r(R));const{prefix:F,scalar:k,pointBytes:z}=f(_),v=g(T.context,F,R),S=i.multiply(v).toBytes(),P=g(T.context,S,z,R),U=o.create(v+P*k);if(!o.isValid(U))throw new Error("sign failed: invalid s");const B=rs(S,o.toBytes(U));return tt(B,w.signature,"result")}const m={zip215:!0};function y(R,_,T,F=m){const{context:k,zip215:z}=F,v=w.signature;R=tt(R,v,"signature"),_=tt(_,void 0,"message"),T=tt(T,w.publicKey,"publicKey"),z!==void 0&&Xa(z,"zip215"),r&&(_=r(_));const S=v/2,P=R.subarray(0,S),U=Ya(R.subarray(S,v));let B,O,V;try{B=n.fromBytes(T,z),O=n.fromBytes(P,z),V=i.multiplyUnsafe(U)}catch{return!1}if(!z&&B.isSmallOrder())return!1;const $=g(k,O.toBytes(),B.toBytes(),_);return O.add(B.multiplyUnsafe($)).subtract(V).clearCofactor().is0()}const E=s.BYTES,w={secretKey:E,publicKey:E,signature:2*E,seed:E};function x(R=a(w.seed)){return tt(R,w.seed,"seed")}function M(R){return Pg(R)&&R.length===o.BYTES}function A(R,_){try{return!!n.fromBytes(R,_)}catch{return!1}}const C={getExtendedPublicKey:f,randomSecretKey:x,isValidSecretKey:M,isValidPublicKey:A,toMontgomery(R){const{y:_}=n.fromBytes(R),T=w.publicKey,F=T===32;if(!F&&T!==57)throw new Error("only defined for 25519 and 448");const k=F?s.div(dn+_,dn-_):s.div(_-dn,_+dn);return s.toBytes(k)},toMontgomerySecret(R){const _=w.secretKey;tt(R,_);const T=e(R.subarray(0,_));return c(T).subarray(0,_)}};return Object.freeze({keygen:fE(x,p),getPublicKey:p,sign:b,verify:y,utils:C,Point:n,lengths:w})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const oh=BigInt(0),Fc=BigInt(1),Kf=BigInt(2);function zz(n){return Ou(n,{adjustScalarBytes:"function",powPminus2:"function"}),Object.freeze({...n})}function Vz(n){const e=zz(n),{P:t,type:r,adjustScalarBytes:i,powPminus2:s,randomBytes:o}=e,a=r==="x25519";if(!a&&r!=="x448")throw new Error("invalid type");const c=o||Qd,l=a?255:448,u=a?32:56,d=BigInt(a?9:5),f=BigInt(a?121665:39081),p=a?Kf**BigInt(254):Kf**BigInt(447),g=a?BigInt(8)*Kf**BigInt(251)-Fc:BigInt(4)*Kf**BigInt(445)-Fc,b=p+g+Fc,m=v=>qt(v,t),y=E(d);function E(v){return uE(m(v),u)}function w(v){const S=sd(tt(v,u,"uCoordinate"));return a&&(S[31]&=127),m(Ya(S))}function x(v){return Ya(i(sd(tt(v,u,"scalar"))))}function M(v,S){const P=T(w(S),x(v));if(P===oh)throw new Error("invalid private or public key received");return E(P)}function A(v){return M(v,y)}const C=A,R=M;function _(v,S,P){const U=m(v*(S-P));return S=m(S-U),P=m(P+U),{x_2:S,x_3:P}}function T(v,S){od("u",v,oh,t),od("scalar",S,p,b);const P=S,U=v;let B=Fc,O=oh,V=v,$=Fc,W=oh;for(let Y=BigInt(l-1);Y>=oh;Y--){const te=P>>Y&Fc;W^=te,{x_2:B,x_3:V}=_(W,B,V),{x_2:O,x_3:$}=_(W,O,$),W=te;const j=B+O,re=m(j*j),le=B-O,fe=m(le*le),se=re-fe,ve=V+$,X=V-$,Ut=m(X*j),Ce=m(ve*le),ke=Ut+Ce,xe=Ut-Ce;V=m(ke*ke),$=m(U*m(xe*xe)),B=m(re*fe),O=m(se*(re+m(f*se)))}({x_2:B,x_3:V}=_(W,B,V)),{x_2:O,x_3:$}=_(W,O,$);const H=s(O);return m(B*H)}const F={secretKey:u,publicKey:u,seed:u},k=(v=c(u))=>(tt(v,F.seed,"seed"),v),z={randomSecretKey:k};return Object.freeze({keygen:fE(k,C),getSharedSecret:R,getPublicKey:C,scalarMult:M,scalarMultBase:A,utils:z,GuBytes:y.slice(),lengths:F})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Hz=BigInt(1),tT=BigInt(2),Gz=BigInt(3),Wz=BigInt(5),qz=BigInt(8),Og=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),Kz={p:Og,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:qz,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function YP(n){const e=BigInt(10),t=BigInt(20),r=BigInt(40),i=BigInt(80),s=Og,a=n*n%s*n%s,c=Ft(a,tT,s)*a%s,l=Ft(c,Hz,s)*n%s,u=Ft(l,Wz,s)*l%s,d=Ft(u,e,s)*u%s,f=Ft(d,t,s)*d%s,p=Ft(f,r,s)*f%s,g=Ft(p,i,s)*p%s,b=Ft(g,i,s)*p%s,m=Ft(b,e,s)*u%s;return{pow_p_5_8:Ft(m,tT,s)*n%s,b2:a}}function ZP(n){return n[0]&=248,n[31]&=127,n[31]|=64,n}const nT=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function Xz(n,e){const t=Og,r=qt(e*e*e,t),i=qt(r*r*e,t),s=YP(n*i).pow_p_5_8;let o=qt(n*r*s,t);const a=qt(e*o*o,t),c=o,l=qt(o*nT,t),u=a===n,d=a===qt(-n,t),f=a===qt(-n*nT,t);return u&&(o=c),(d||f)&&(o=l),Iz(o,t)&&(o=qt(-o,t)),{isValid:u||d,value:o}}const Yz=$z(Kz,{uvRatio:Xz});function Zz(n){return Fz(Yz,vz,Object.assign({adjustScalarBytes:ZP},n))}const mm=Zz({}),Xf=(()=>{const n=Og;return Vz({P:n,type:"x25519",powPminus2:e=>{const{pow_p_5_8:t,b2:r}=YP(e);return qt(Ft(t,Gz,n)*r,n)},adjustScalarBytes:ZP})})();let rT=class extends Error{constructor(e="An error occurred while verifying a message"){super(e),this.name="VerificationError"}},jz=class extends Error{constructor(e="Missing Web Crypto API"){super(e),this.name="WebCryptoMissingError"}};const Za={get(n=globalThis){const e=n.crypto;if((e==null?void 0:e.subtle)==null)throw new jz("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return e}},pE=32,mE=64,Ev=32;let ll;const jP=(async()=>{try{return await Za.get().subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),!0}catch{return!1}})();function Jz(){const n=mm.utils.randomSecretKey(),e=mm.getPublicKey(n);return{privateKey:sV(n,e),publicKey:e}}async function Qz(n,e){let t;n.length===mE?t=n.subarray(0,32):t=n;const r={crv:"Ed25519",kty:"OKP",x:ne(n.subarray(32),"base64url"),d:ne(t,"base64url"),ext:!0,key_ops:["sign"]},i=await Za.get().subtle.importKey("jwk",r,{name:"Ed25519"},!0,["sign"]),s=await Za.get().subtle.sign({name:"Ed25519"},i,e instanceof Uint8Array?e:e.subarray());return new Uint8Array(s,0,s.byteLength)}function eV(n,e){const t=n.subarray(0,Ev);return mm.sign(e instanceof Uint8Array?e:e.subarray(),t)}async function tV(n,e){return ll==null&&(ll=await jP),ll?Qz(n,e):eV(n,e)}async function nV(n,e,t){if(n.buffer instanceof ArrayBuffer){const r=await Za.get().subtle.importKey("raw",n.buffer,{name:"Ed25519"},!1,["verify"]);return await Za.get().subtle.verify({name:"Ed25519"},r,e,t instanceof Uint8Array?t:t.subarray())}throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys")}function rV(n,e,t){return mm.verify(e,t instanceof Uint8Array?t:t.subarray(),n)}async function iV(n,e,t){return ll==null&&(ll=await jP),ll?nV(n,e,t):rV(n,e,t)}function sV(n,e){const t=new Uint8Array(mE);for(let r=0;r<Ev;r++)t[r]=n[r],t[Ev+r]=e[r];return t}function gE(n){return n==null?!1:typeof n.then=="function"&&typeof n.catch=="function"&&typeof n.finally=="function"}let JP=class{constructor(e){h(this,"type","Ed25519");h(this,"raw");this.raw=bE(e,pE)}toMultihash(){return Zt.digest(as(this))}toCID(){return ze.createV1(114,this.toMultihash())}toString(){return at.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Ne(this.raw,e.raw)}verify(e,t,r){var s;(s=r==null?void 0:r.signal)==null||s.throwIfAborted();const i=iV(this.raw,t,e);return gE(i)?i.then(o=>{var a;return(a=r==null?void 0:r.signal)==null||a.throwIfAborted(),o}):i}};class oV{constructor(e,t){h(this,"type","Ed25519");h(this,"raw");h(this,"publicKey");this.raw=bE(e,mE),this.publicKey=new JP(t)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Ne(this.raw,e.raw)}sign(e,t){var i,s;(i=t==null?void 0:t.signal)==null||i.throwIfAborted();const r=tV(this.raw,e);return gE(r)?r.then(o=>{var a;return(a=t==null?void 0:t.signal)==null||a.throwIfAborted(),o}):((s=t==null?void 0:t.signal)==null||s.throwIfAborted(),r)}}function yE(n){return n=bE(n,pE),new JP(n)}async function aV(){const{privateKey:n,publicKey:e}=Jz();return new oV(n,e)}function bE(n,e){if(n=Uint8Array.from(n??[]),n.length!==e)throw new Lu(`Key must be a Uint8Array of length ${e}, got ${n.length}`);return n}const cV=Math.pow(2,7),lV=Math.pow(2,14),uV=Math.pow(2,21),wE=Math.pow(2,28),vE=Math.pow(2,35),_E=Math.pow(2,42),EE=Math.pow(2,49),ft=128,Yn=127;function Me(n){if(n<cV)return 1;if(n<lV)return 2;if(n<uV)return 3;if(n<wE)return 4;if(n<vE)return 5;if(n<_E)return 6;if(n<EE)return 7;if(Number.MAX_SAFE_INTEGER!=null&&n>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function Xt(n,e,t=0){switch(Me(n)){case 8:e[t++]=n&255|ft,n/=128;case 7:e[t++]=n&255|ft,n/=128;case 6:e[t++]=n&255|ft,n/=128;case 5:e[t++]=n&255|ft,n/=128;case 4:e[t++]=n&255|ft,n>>>=7;case 3:e[t++]=n&255|ft,n>>>=7;case 2:e[t++]=n&255|ft,n>>>=7;case 1:{e[t++]=n&255,n>>>=7;break}default:throw new Error("unreachable")}return e}function hV(n,e,t=0){switch(Me(n)){case 8:e.set(t++,n&255|ft),n/=128;case 7:e.set(t++,n&255|ft),n/=128;case 6:e.set(t++,n&255|ft),n/=128;case 5:e.set(t++,n&255|ft),n/=128;case 4:e.set(t++,n&255|ft),n>>>=7;case 3:e.set(t++,n&255|ft),n>>>=7;case 2:e.set(t++,n&255|ft),n>>>=7;case 1:{e.set(t++,n&255),n>>>=7;break}default:throw new Error("unreachable")}return e}function QP(n,e){let t=n[e],r=0;if(r+=t&Yn,t<ft||(t=n[e+1],r+=(t&Yn)<<7,t<ft)||(t=n[e+2],r+=(t&Yn)<<14,t<ft)||(t=n[e+3],r+=(t&Yn)<<21,t<ft)||(t=n[e+4],r+=(t&Yn)*wE,t<ft)||(t=n[e+5],r+=(t&Yn)*vE,t<ft)||(t=n[e+6],r+=(t&Yn)*_E,t<ft)||(t=n[e+7],r+=(t&Yn)*EE,t<ft))return r;throw new RangeError("Could not decode varint")}function dV(n,e){let t=n.get(e),r=0;if(r+=t&Yn,t<ft||(t=n.get(e+1),r+=(t&Yn)<<7,t<ft)||(t=n.get(e+2),r+=(t&Yn)<<14,t<ft)||(t=n.get(e+3),r+=(t&Yn)<<21,t<ft)||(t=n.get(e+4),r+=(t&Yn)*wE,t<ft)||(t=n.get(e+5),r+=(t&Yn)*vE,t<ft)||(t=n.get(e+6),r+=(t&Yn)*_E,t<ft)||(t=n.get(e+7),r+=(t&Yn)*EE,t<ft))return r;throw new RangeError("Could not decode varint")}function ul(n,e,t=0){return e==null&&(e=zi(Me(n))),e instanceof Uint8Array?Xt(n,e,t):hV(n,e,t)}function zt(n,e=0){return n instanceof Uint8Array?QP(n,e):dV(n,e)}const SE=new Float32Array([-0]),ko=new Uint8Array(SE.buffer);function fV(n,e,t){SE[0]=n,e[t]=ko[0],e[t+1]=ko[1],e[t+2]=ko[2],e[t+3]=ko[3]}function pV(n,e){return ko[0]=n[e],ko[1]=n[e+1],ko[2]=n[e+2],ko[3]=n[e+3],SE[0]}const xE=new Float64Array([-0]),Zn=new Uint8Array(xE.buffer);function mV(n,e,t){xE[0]=n,e[t]=Zn[0],e[t+1]=Zn[1],e[t+2]=Zn[2],e[t+3]=Zn[3],e[t+4]=Zn[4],e[t+5]=Zn[5],e[t+6]=Zn[6],e[t+7]=Zn[7]}function gV(n,e){return Zn[0]=n[e],Zn[1]=n[e+1],Zn[2]=n[e+2],Zn[3]=n[e+3],Zn[4]=n[e+4],Zn[5]=n[e+5],Zn[6]=n[e+6],Zn[7]=n[e+7],xE[0]}const yV=BigInt(Number.MAX_SAFE_INTEGER),bV=BigInt(Number.MIN_SAFE_INTEGER);let Rs=class ga{constructor(e,t){h(this,"lo");h(this,"hi");this.lo=e|0,this.hi=t|0}toNumber(e=!1){if(!e&&this.hi>>>31>0){const t=~this.lo+1>>>0;let r=~this.hi>>>0;return t===0&&(r=r+1>>>0),-(t+r*4294967296)}return this.lo+this.hi*4294967296}toBigInt(e=!1){if(e)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const t=~this.lo+1>>>0;let r=~this.hi>>>0;return t===0&&(r=r+1>>>0),-(BigInt(t)+(BigInt(r)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(e=!1){return this.toBigInt(e).toString()}zzEncode(){const e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this}zzDecode(){const e=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this}length(){const e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,r=this.hi>>>24;return r===0?t===0?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:r<128?9:10}static fromBigInt(e){if(e===0n)return za;if(e<yV&&e>bV)return this.fromNumber(Number(e));const t=e<0n;t&&(e=-e);let r=e>>32n,i=e-(r<<32n);return t&&(r=~r|0n,i=~i|0n,++i>iT&&(i=0n,++r>iT&&(r=0n))),new ga(Number(i),Number(r))}static fromNumber(e){if(e===0)return za;const t=e<0;t&&(e=-e);let r=e>>>0,i=(e-r)/4294967296>>>0;return t&&(i=~i>>>0,r=~r>>>0,++r>4294967295&&(r=0,++i>4294967295&&(i=0))),new ga(r,i)}static from(e){return typeof e=="number"?ga.fromNumber(e):typeof e=="bigint"?ga.fromBigInt(e):typeof e=="string"?ga.fromBigInt(BigInt(e)):e.low!=null||e.high!=null?new ga(e.low>>>0,e.high>>>0):za}};const za=new Rs(0,0);za.toBigInt=function(){return 0n};za.zzEncode=za.zzDecode=function(){return this};za.length=function(){return 1};const iT=4294967296n;function wV(n){let e=0,t=0;for(let r=0;r<n.length;++r)t=n.charCodeAt(r),t<128?e+=1:t<2048?e+=2:(t&64512)===55296&&(n.charCodeAt(r+1)&64512)===56320?(++r,e+=4):e+=3;return e}function vV(n,e,t){if(t-e<1)return"";let i;const s=[];let o=0,a;for(;e<t;)a=n[e++],a<128?s[o++]=a:a>191&&a<224?s[o++]=(a&31)<<6|n[e++]&63:a>239&&a<365?(a=((a&7)<<18|(n[e++]&63)<<12|(n[e++]&63)<<6|n[e++]&63)-65536,s[o++]=55296+(a>>10),s[o++]=56320+(a&1023)):s[o++]=(a&15)<<12|(n[e++]&63)<<6|n[e++]&63,o>8191&&((i??(i=[])).push(String.fromCharCode.apply(String,s)),o=0);return i!=null?(o>0&&i.push(String.fromCharCode.apply(String,s.slice(0,o))),i.join("")):String.fromCharCode.apply(String,s.slice(0,o))}function eD(n,e,t){const r=t;let i,s;for(let o=0;o<n.length;++o)i=n.charCodeAt(o),i<128?e[t++]=i:i<2048?(e[t++]=i>>6|192,e[t++]=i&63|128):(i&64512)===55296&&((s=n.charCodeAt(o+1))&64512)===56320?(i=65536+((i&1023)<<10)+(s&1023),++o,e[t++]=i>>18|240,e[t++]=i>>12&63|128,e[t++]=i>>6&63|128,e[t++]=i&63|128):(e[t++]=i>>12|224,e[t++]=i>>6&63|128,e[t++]=i&63|128);return t-r}function gi(n,e){return RangeError(`index out of range: ${n.pos} + ${e??1} > ${n.len}`)}function Yf(n,e){return(n[e-4]|n[e-3]<<8|n[e-2]<<16|n[e-1]<<24)>>>0}let _V=class{constructor(e){h(this,"buf");h(this,"pos");h(this,"len");h(this,"_slice",Uint8Array.prototype.subarray);this.buf=e,this.pos=0,this.len=e.length}uint32(){let e=4294967295;if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,gi(this,10);return e}int32(){return this.uint32()|0}sint32(){const e=this.uint32();return e>>>1^-(e&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw gi(this,4);return Yf(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw gi(this,4);return Yf(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw gi(this,4);const e=pV(this.buf,this.pos);return this.pos+=4,e}double(){if(this.pos+8>this.len)throw gi(this,4);const e=gV(this.buf,this.pos);return this.pos+=8,e}bytes(){const e=this.uint32(),t=this.pos,r=this.pos+e;if(r>this.len)throw gi(this,e);return this.pos+=e,t===r?new Uint8Array(0):this.buf.subarray(t,r)}string(){const e=this.bytes();return vV(e,0,e.length)}skip(e){if(typeof e=="number"){if(this.pos+e>this.len)throw gi(this,e);this.pos+=e}else do if(this.pos>=this.len)throw gi(this);while((this.buf[this.pos++]&128)!==0);return this}skipType(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(e=this.uint32()&7)!==4;)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${e} at offset ${this.pos}`)}return this}readLongVarint(){const e=new Rs(0,0);let t=0;if(this.len-this.pos>4){for(;t<4;++t)if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(this.buf[this.pos]&127)<<28)>>>0,e.hi=(e.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return e;t=0}else{for(;t<3;++t){if(this.pos>=this.len)throw gi(this);if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(this.buf[this.pos++]&127)<<t*7)>>>0,e}if(this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw gi(this);if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw gi(this,8);const e=Yf(this.buf,this.pos+=4),t=Yf(this.buf,this.pos+=4);return new Rs(e,t)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const e=QP(this.buf,this.pos);return this.pos+=Me(e),e}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}};function EV(n){return new _V(n instanceof Uint8Array?n:n.subarray())}function Lt(n,e,t){const r=EV(n);return e.decode(r,void 0,t)}function SV(n){let r,i=8192;return function(o){if(o<1||o>4096)return zi(o);i+o>8192&&(r=zi(8192),i=0);const a=r.subarray(i,i+=o);return(i&7)!==0&&(i=(i|7)+1),a}}let gh=class{constructor(e,t,r){h(this,"fn");h(this,"len");h(this,"next");h(this,"val");this.fn=e,this.len=t,this.next=void 0,this.val=r}};function n0(){}let xV=class{constructor(e){h(this,"head");h(this,"tail");h(this,"len");h(this,"next");this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}};const TV=SV();function AV(n){return globalThis.Buffer!=null?zi(n):TV(n)}let Sv=class{constructor(){h(this,"len");h(this,"head");h(this,"tail");h(this,"states");this.len=0,this.head=new gh(n0,0,0),this.tail=this.head,this.states=null}_push(e,t,r){return this.tail=this.tail.next=new gh(e,t,r),this.len+=t,this}uint32(e){return this.len+=(this.tail=this.tail.next=new CV((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this}int32(e){return e<0?this._push(Zf,10,Rs.fromNumber(e)):this.uint32(e)}sint32(e){return this.uint32((e<<1^e>>31)>>>0)}uint64(e){const t=Rs.fromBigInt(e);return this._push(Zf,t.length(),t)}uint64Number(e){return this._push(Xt,Me(e),e)}uint64String(e){return this.uint64(BigInt(e))}int64(e){return this.uint64(e)}int64Number(e){return this.uint64Number(e)}int64String(e){return this.uint64String(e)}sint64(e){const t=Rs.fromBigInt(e).zzEncode();return this._push(Zf,t.length(),t)}sint64Number(e){const t=Rs.fromNumber(e).zzEncode();return this._push(Zf,t.length(),t)}sint64String(e){return this.sint64(BigInt(e))}bool(e){return this._push(r0,1,e?1:0)}fixed32(e){return this._push(ah,4,e>>>0)}sfixed32(e){return this.fixed32(e)}fixed64(e){const t=Rs.fromBigInt(e);return this._push(ah,4,t.lo)._push(ah,4,t.hi)}fixed64Number(e){const t=Rs.fromNumber(e);return this._push(ah,4,t.lo)._push(ah,4,t.hi)}fixed64String(e){return this.fixed64(BigInt(e))}sfixed64(e){return this.fixed64(e)}sfixed64Number(e){return this.fixed64Number(e)}sfixed64String(e){return this.fixed64String(e)}float(e){return this._push(fV,4,e)}double(e){return this._push(mV,8,e)}bytes(e){const t=e.length>>>0;return t===0?this._push(r0,1,0):this.uint32(t)._push(IV,t,e)}string(e){const t=wV(e);return t!==0?this.uint32(t)._push(eD,t,e):this._push(r0,1,0)}fork(){return this.states=new xV(this),this.head=this.tail=new gh(n0,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new gh(n0,0,0),this.len=0),this}ldelim(){const e=this.head,t=this.tail,r=this.len;return this.reset().uint32(r),r!==0&&(this.tail.next=e.next,this.tail=t,this.len+=r),this}finish(){let e=this.head.next;const t=AV(this.len);let r=0;for(;e!=null;)e.fn(e.val,t,r),r+=e.len,e=e.next;return t}};function r0(n,e,t){e[t]=n&255}function MV(n,e,t){for(;n>127;)e[t++]=n&127|128,n>>>=7;e[t]=n}let CV=class extends gh{constructor(t,r){super(MV,t,r);h(this,"next");this.next=void 0}};function Zf(n,e,t){for(;n.hi!==0;)e[t++]=n.lo&127|128,n.lo=(n.lo>>>7|n.hi<<25)>>>0,n.hi>>>=7;for(;n.lo>127;)e[t++]=n.lo&127|128,n.lo=n.lo>>>7;e[t++]=n.lo}function ah(n,e,t){e[t]=n&255,e[t+1]=n>>>8&255,e[t+2]=n>>>16&255,e[t+3]=n>>>24}function IV(n,e,t){e.set(n,t)}globalThis.Buffer!=null&&(Sv.prototype.bytes=function(n){const e=n.length>>>0;return this.uint32(e),e>0&&this._push(PV,e,n),this},Sv.prototype.string=function(n){const e=globalThis.Buffer.byteLength(n);return this.uint32(e),e>0&&this._push(DV,e,n),this});function PV(n,e,t){e.set(n,t)}function DV(n,e,t){n.length<40?eD(n,e,t):e.utf8Write!=null?e.utf8Write(n,t):e.set(ge(n),t)}function RV(){return new Sv}function Ot(n,e){const t=RV();return e.encode(n,t,{lengthDelimited:!1}),t.finish()}var gm;(function(n){n[n.VARINT=0]="VARINT",n[n.BIT64=1]="BIT64",n[n.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",n[n.START_GROUP=3]="START_GROUP",n[n.END_GROUP=4]="END_GROUP",n[n.BIT32=5]="BIT32"})(gm||(gm={}));function tD(n,e,t,r){return{name:n,type:e,encode:t,decode:r}}function hc(n){function e(i){if(n[i.toString()]==null)throw new Error("Invalid enum value");return n[i]}const t=function(s,o){const a=e(s);o.int32(a)},r=function(s){const o=s.int32();return e(o)};return tD("enum",gm.VARINT,t,r)}function Nt(n,e){return tD("message",gm.LENGTH_DELIMITED,n,e)}let ls=class extends Error{constructor(){super(...arguments);h(this,"code","ERR_MAX_LENGTH");h(this,"name","MaxLengthError")}};class sT extends Error{constructor(){super(...arguments);h(this,"code","ERR_MAX_SIZE");h(this,"name","MaxSizeError")}}var En;(function(n){n.RSA="RSA",n.Ed25519="Ed25519",n.secp256k1="secp256k1",n.ECDSA="ECDSA"})(En||(En={}));var xv;(function(n){n[n.RSA=0]="RSA",n[n.Ed25519=1]="Ed25519",n[n.secp256k1=2]="secp256k1",n[n.ECDSA=3]="ECDSA"})(xv||(xv={}));(function(n){n.codec=()=>hc(xv)})(En||(En={}));var iu;(function(n){let e;n.codec=()=>(e==null&&(e=Nt((t,r,i={})=>{i.lengthDelimited!==!1&&r.fork(),t.Type!=null&&(r.uint32(8),En.codec().encode(t.Type,r)),t.Data!=null&&(r.uint32(18),r.bytes(t.Data)),i.lengthDelimited!==!1&&r.ldelim()},(t,r,i={})=>{const s={},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.Type=En.codec().decode(t);break}case 2:{s.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return s})),e),n.encode=t=>Ot(t,n.codec()),n.decode=(t,r)=>Lt(t,n.codec(),r)})(iu||(iu={}));var oT;(function(n){let e;n.codec=()=>(e==null&&(e=Nt((t,r,i={})=>{i.lengthDelimited!==!1&&r.fork(),t.Type!=null&&(r.uint32(8),En.codec().encode(t.Type,r)),t.Data!=null&&(r.uint32(18),r.bytes(t.Data)),i.lengthDelimited!==!1&&r.ldelim()},(t,r,i={})=>{const s={},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.Type=En.codec().decode(t);break}case 2:{s.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return s})),e),n.encode=t=>Ot(t,n.codec()),n.decode=(t,r)=>Lt(t,n.codec(),r)})(oT||(oT={}));function TE(n){if(isNaN(n)||n<=0)throw new Lu("random bytes length must be a Number bigger than 0");return Qd(n)}let LV=class{constructor(e,t){h(this,"type","RSA");h(this,"jwk");h(this,"_raw");h(this,"_multihash");this.jwk=e,this._multihash=t}get raw(){return this._raw==null&&(this._raw=kV(this.jwk)),this._raw}toMultihash(){return this._multihash}toCID(){return ze.createV1(114,this._multihash)}toString(){return at.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Ne(this.raw,e.raw)}verify(e,t,r){return zV(this.jwk,t,e,r)}};const OV=18,NV=1062,UV=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function BV(n){const e=Zd(n[1],{offset:0});return{kty:"RSA",n:ne(e[0],"base64url"),e:ne(e[1],"base64url")}}function kV(n){if(n.n==null||n.e==null)throw new Lu("JWK was missing components");return Bh([UV,TP(Bh([vv(ge(n.n,"base64url")),vv(ge(n.e,"base64url"))]))]).subarray()}function $V(n,e){if(n.byteLength>=NV)throw new pP("Key size is too large");const t=Zd(n,{offset:0});return nD(t,n,e)}function nD(n,e,t){const r=BV(n);if(t==null){const i=kh(iu.encode({Type:En.RSA,Data:e}));t=Ig(OV,i)}return new LV(r,t)}const FV="1.2.840.113549.1.1.1";async function zV(n,e,t,r){var o,a;const i=await Za.get().subtle.importKey("jwk",n,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);(o=r==null?void 0:r.signal)==null||o.throwIfAborted();const s=await Za.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},i,e,t instanceof Uint8Array?t:t.subarray());return(a=r==null?void 0:r.signal)==null||a.throwIfAborted(),s}let rD=class{constructor(e,t){h(this,"oHash");h(this,"iHash");h(this,"blockLen");h(this,"outputLen");h(this,"finished",!1);h(this,"destroyed",!1);if(Dg(e),tt(t,void 0,"key"),this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const r=this.blockLen,i=new Uint8Array(r);i.set(t.length>r?e.create().update(t).digest():t);for(let s=0;s<i.length;s++)i[s]^=54;this.iHash.update(i),this.oHash=e.create();for(let s=0;s<i.length;s++)i[s]^=106;this.oHash.update(i),Ka(i)}update(e){return dm(this),this.iHash.update(e),this}digestInto(e){dm(this),tt(e,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:i,destroyed:s,blockLen:o,outputLen:a}=this;return e=e,e.finished=i,e.destroyed=s,e.blockLen=o,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};const Ng=(n,e,t)=>new rD(n,e).update(t).digest();Ng.create=(n,e)=>new rD(n,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const aT=(n,e)=>(n+(n>=0?e:-e)/iD)/e;function VV(n,e,t){const[[r,i],[s,o]]=e,a=aT(o*n,t),c=aT(-i*n,t);let l=n-a*r-c*s,u=-a*i-c*o;const d=l<$s,f=u<$s;d&&(l=-l),f&&(u=-u);const p=hE(Math.ceil(Ez(t)/2))+hl;if(l<$s||l>=p||u<$s||u>=p)throw new Error("splitScalar (endomorphism): failed, k="+n);return{k1neg:d,k1:l,k2neg:f,k2:u}}function Tv(n){if(!["compact","recovered","der"].includes(n))throw new Error('Signature format must be "compact", "recovered", or "der"');return n}function i0(n,e){const t={};for(let r of Object.keys(e))t[r]=n[r]===void 0?e[r]:n[r];return Xa(t.lowS,"lowS"),Xa(t.prehash,"prehash"),t.format!==void 0&&Tv(t.format),t}let HV=class extends Error{constructor(e=""){super(e)}};const Io={Err:HV,_tlv:{encode:(n,e)=>{const{Err:t}=Io;if(n<0||n>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const r=e.length/2,i=qf(r);if(i.length/2&128)throw new t("tlv.encode: long form length too big");const s=r>127?qf(i.length/2|128):"";return qf(n)+s+i+e},decode(n,e){const{Err:t}=Io;let r=0;if(n<0||n>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[r++]!==n)throw new t("tlv.decode: wrong tlv");const i=e[r++],s=!!(i&128);let o=0;if(!s)o=i;else{const c=i&127;if(!c)throw new t("tlv.decode(long): indefinite length not supported");if(c>4)throw new t("tlv.decode(long): byte length is too big");const l=e.subarray(r,r+c);if(l.length!==c)throw new t("tlv.decode: length bytes not complete");if(l[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const u of l)o=o<<8|u;if(r+=c,o<128)throw new t("tlv.decode(long): not minimal encoding")}const a=e.subarray(r,r+o);if(a.length!==o)throw new t("tlv.decode: wrong value length");return{v:a,l:e.subarray(r+o)}}},_int:{encode(n){const{Err:e}=Io;if(n<$s)throw new e("integer: negative integers are not allowed");let t=qf(n);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(n){const{Err:e}=Io;if(n[0]&128)throw new e("invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return Rg(n)}},toSig(n){const{Err:e,_int:t,_tlv:r}=Io,i=tt(n,void 0,"signature"),{v:s,l:o}=r.decode(48,i);if(o.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=r.decode(2,s),{v:l,l:u}=r.decode(2,c);if(u.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(l)}},hexFromSig(n){const{_tlv:e,_int:t}=Io,r=e.encode(2,t.encode(n.r)),i=e.encode(2,t.encode(n.s)),s=r+i;return e.encode(48,s)}},$s=BigInt(0),hl=BigInt(1),iD=BigInt(2),jf=BigInt(3),GV=BigInt(4);function WV(n,e={}){const t=XP("weierstrass",n,e),{Fp:r,Fn:i}=t;let s=t.CURVE;const{h:o,n:a}=s;Ou(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});const{endo:c}=e;if(c&&(!r.is0(s.a)||typeof c.beta!="bigint"||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const l=oD(r,i);function u(){if(!r.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function d(z,v,S){const{x:P,y:U}=v.toAffine(),B=r.toBytes(P);if(Xa(S,"isCompressed"),S){u();const O=!r.isOdd(U);return rs(sD(O),B)}else return rs(Uint8Array.of(4),B,r.toBytes(U))}function f(z){tt(z,void 0,"Point");const{publicKey:v,publicKeyUncompressed:S}=l,P=z.length,U=z[0],B=z.subarray(1);if(P===v&&(U===2||U===3)){const O=r.fromBytes(B);if(!r.isValid(O))throw new Error("bad point: is not on curve, wrong x");const V=b(O);let $;try{$=r.sqrt(V)}catch(Y){const te=Y instanceof Error?": "+Y.message:"";throw new Error("bad point: is not on curve, sqrt error"+te)}u();const W=r.isOdd($);return(U&1)===1!==W&&($=r.neg($)),{x:O,y:$}}else if(P===S&&U===4){const O=r.BYTES,V=r.fromBytes(B.subarray(0,O)),$=r.fromBytes(B.subarray(O,O*2));if(!m(V,$))throw new Error("bad point: is not on curve");return{x:V,y:$}}else throw new Error(`bad point: got length ${P}, expected compressed=${v} or uncompressed=${S}`)}const p=e.toBytes||d,g=e.fromBytes||f;function b(z){const v=r.sqr(z),S=r.mul(v,z);return r.add(r.add(S,r.mul(z,s.a)),s.b)}function m(z,v){const S=r.sqr(v),P=b(z);return r.eql(S,P)}if(!m(s.Gx,s.Gy))throw new Error("bad curve params: generator point");const y=r.mul(r.pow(s.a,jf),GV),E=r.mul(r.sqr(s.b),BigInt(27));if(r.is0(r.add(y,E)))throw new Error("bad curve params: a or b");function w(z,v,S=!1){if(!r.isValid(v)||S&&r.is0(v))throw new Error(`bad point coordinate ${z}`);return v}function x(z){if(!(z instanceof _))throw new Error("Weierstrass Point expected")}function M(z){if(!c||!c.basises)throw new Error("no endo");return VV(z,c.basises,i.ORDER)}const A=fm((z,v)=>{const{X:S,Y:P,Z:U}=z;if(r.eql(U,r.ONE))return{x:S,y:P};const B=z.is0();v==null&&(v=B?r.ONE:r.inv(U));const O=r.mul(S,v),V=r.mul(P,v),$=r.mul(U,v);if(B)return{x:r.ZERO,y:r.ZERO};if(!r.eql($,r.ONE))throw new Error("invZ was invalid");return{x:O,y:V}}),C=fm(z=>{if(z.is0()){if(e.allowInfinityPoint&&!r.is0(z.Y))return;throw new Error("bad point: ZERO")}const{x:v,y:S}=z.toAffine();if(!r.isValid(v)||!r.isValid(S))throw new Error("bad point: x or y not field elements");if(!m(v,S))throw new Error("bad point: equation left != right");if(!z.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function R(z,v,S,P,U){return S=new _(r.mul(S.X,z),S.Y,S.Z),v=pm(P,v),S=pm(U,S),v.add(S)}const k=class k{constructor(v,S,P){h(this,"X");h(this,"Y");h(this,"Z");this.X=w("x",v),this.Y=w("y",S,!0),this.Z=w("z",P),Object.freeze(this)}static CURVE(){return s}static fromAffine(v){const{x:S,y:P}=v||{};if(!v||!r.isValid(S)||!r.isValid(P))throw new Error("invalid affine point");if(v instanceof k)throw new Error("projective point not allowed");return r.is0(S)&&r.is0(P)?k.ZERO:new k(S,P,r.ONE)}static fromBytes(v){const S=k.fromAffine(g(tt(v,void 0,"point")));return S.assertValidity(),S}static fromHex(v){return k.fromBytes(id(v))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(v=8,S=!0){return F.createCache(this,v),S||this.multiply(jf),this}assertValidity(){C(this)}hasEvenY(){const{y:v}=this.toAffine();if(!r.isOdd)throw new Error("Field doesn't support isOdd");return!r.isOdd(v)}equals(v){x(v);const{X:S,Y:P,Z:U}=this,{X:B,Y:O,Z:V}=v,$=r.eql(r.mul(S,V),r.mul(B,U)),W=r.eql(r.mul(P,V),r.mul(O,U));return $&&W}negate(){return new k(this.X,r.neg(this.Y),this.Z)}double(){const{a:v,b:S}=s,P=r.mul(S,jf),{X:U,Y:B,Z:O}=this;let V=r.ZERO,$=r.ZERO,W=r.ZERO,H=r.mul(U,U),Y=r.mul(B,B),te=r.mul(O,O),j=r.mul(U,B);return j=r.add(j,j),W=r.mul(U,O),W=r.add(W,W),V=r.mul(v,W),$=r.mul(P,te),$=r.add(V,$),V=r.sub(Y,$),$=r.add(Y,$),$=r.mul(V,$),V=r.mul(j,V),W=r.mul(P,W),te=r.mul(v,te),j=r.sub(H,te),j=r.mul(v,j),j=r.add(j,W),W=r.add(H,H),H=r.add(W,H),H=r.add(H,te),H=r.mul(H,j),$=r.add($,H),te=r.mul(B,O),te=r.add(te,te),H=r.mul(te,j),V=r.sub(V,H),W=r.mul(te,Y),W=r.add(W,W),W=r.add(W,W),new k(V,$,W)}add(v){x(v);const{X:S,Y:P,Z:U}=this,{X:B,Y:O,Z:V}=v;let $=r.ZERO,W=r.ZERO,H=r.ZERO;const Y=s.a,te=r.mul(s.b,jf);let j=r.mul(S,B),re=r.mul(P,O),le=r.mul(U,V),fe=r.add(S,P),se=r.add(B,O);fe=r.mul(fe,se),se=r.add(j,re),fe=r.sub(fe,se),se=r.add(S,U);let ve=r.add(B,V);return se=r.mul(se,ve),ve=r.add(j,le),se=r.sub(se,ve),ve=r.add(P,U),$=r.add(O,V),ve=r.mul(ve,$),$=r.add(re,le),ve=r.sub(ve,$),H=r.mul(Y,se),$=r.mul(te,le),H=r.add($,H),$=r.sub(re,H),H=r.add(re,H),W=r.mul($,H),re=r.add(j,j),re=r.add(re,j),le=r.mul(Y,le),se=r.mul(te,se),re=r.add(re,le),le=r.sub(j,le),le=r.mul(Y,le),se=r.add(se,le),j=r.mul(re,se),W=r.add(W,j),j=r.mul(ve,se),$=r.mul(fe,$),$=r.sub($,j),j=r.mul(fe,re),H=r.mul(ve,H),H=r.add(H,j),new k($,W,H)}subtract(v){return this.add(v.negate())}is0(){return this.equals(k.ZERO)}multiply(v){const{endo:S}=e;if(!i.isValidNot0(v))throw new Error("invalid scalar: out of range");let P,U;const B=O=>F.cached(this,O,V=>$h(k,V));if(S){const{k1neg:O,k1:V,k2neg:$,k2:W}=M(v),{p:H,f:Y}=B(V),{p:te,f:j}=B(W);U=Y.add(j),P=R(S.beta,H,te,O,$)}else{const{p:O,f:V}=B(v);P=O,U=V}return $h(k,[P,U])[0]}multiplyUnsafe(v){const{endo:S}=e,P=this;if(!i.isValid(v))throw new Error("invalid scalar: out of range");if(v===$s||P.is0())return k.ZERO;if(v===hl)return P;if(F.hasCache(this))return this.multiply(v);if(S){const{k1neg:U,k1:B,k2neg:O,k2:V}=M(v),{p1:$,p2:W}=Uz(k,P,B,V);return R(S.beta,$,W,U,O)}else return F.unsafe(P,v)}toAffine(v){return A(this,v)}isTorsionFree(){const{isTorsionFree:v}=e;return o===hl?!0:v?v(k,this):F.unsafe(this,a).is0()}clearCofactor(){const{clearCofactor:v}=e;return o===hl?this:v?v(k,this):this.multiplyUnsafe(o)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}toBytes(v=!0){return Xa(v,"isCompressed"),this.assertValidity(),p(k,this,v)}toHex(v=!0){return Jd(this.toBytes(v))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}};h(k,"BASE",new k(s.Gx,s.Gy,r.ONE)),h(k,"ZERO",new k(r.ZERO,r.ONE,r.ZERO)),h(k,"Fp",r),h(k,"Fn",i);let _=k;const T=i.BITS,F=new KP(_,e.endo?Math.ceil(T/2):T);return _.BASE.precompute(8),_}function sD(n){return Uint8Array.of(n?2:3)}function oD(n,e){return{secretKey:e.BYTES,publicKey:1+n.BYTES,publicKeyUncompressed:1+2*n.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}function qV(n,e={}){const{Fn:t}=n,r=e.randomBytes||Qd,i=Object.assign(oD(n.Fp,t),{seed:GP(t.ORDER)});function s(p){try{const g=t.fromBytes(p);return t.isValidNot0(g)}catch{return!1}}function o(p,g){const{publicKey:b,publicKeyUncompressed:m}=i;try{const y=p.length;return g===!0&&y!==b||g===!1&&y!==m?!1:!!n.fromBytes(p)}catch{return!1}}function a(p=r(i.seed)){return Nz(tt(p,i.seed,"seed"),t.ORDER)}function c(p,g=!0){return n.BASE.multiply(t.fromBytes(p)).toBytes(g)}function l(p){const{secretKey:g,publicKey:b,publicKeyUncompressed:m}=i;if(!Pg(p)||"_lengths"in t&&t._lengths||g===b)return;const y=tt(p,void 0,"key").length;return y===b||y===m}function u(p,g,b=!0){if(l(p)===!0)throw new Error("first arg must be private key");if(l(g)===!1)throw new Error("second arg must be public key");const m=t.fromBytes(p);return n.fromBytes(g).multiply(m).toBytes(b)}const d={isValidSecretKey:s,isValidPublicKey:o,randomSecretKey:a},f=fE(a,c);return Object.freeze({getPublicKey:c,getSharedSecret:u,keygen:f,Point:n,utils:d,lengths:i})}function KV(n,e,t={}){Dg(e),Ou(t,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"}),t=Object.assign({},t);const r=t.randomBytes||Qd,i=t.hmac||((v,S)=>Ng(e,v,S)),{Fp:s,Fn:o}=n,{ORDER:a,BITS:c}=o,{keygen:l,getPublicKey:u,getSharedSecret:d,utils:f,lengths:p}=qV(n,t),g={prehash:!0,lowS:typeof t.lowS=="boolean"?t.lowS:!0,format:"compact",extraEntropy:!1},b=a*iD<s.ORDER;function m(v){const S=a>>hl;return v>S}function y(v,S){if(!o.isValidNot0(S))throw new Error(`invalid signature ${v}: out of range 1..Point.Fn.ORDER`);return S}function E(){if(b)throw new Error('"recovered" sig type is not supported for cofactor >2 curves')}function w(v,S){Tv(S);const P=p.signature,U=S==="compact"?P:S==="recovered"?P+1:void 0;return tt(v,U)}class x{constructor(S,P,U){h(this,"r");h(this,"s");h(this,"recovery");if(this.r=y("r",S),this.s=y("s",P),U!=null){if(E(),![0,1,2,3].includes(U))throw new Error("invalid recovery id");this.recovery=U}Object.freeze(this)}static fromBytes(S,P=g.format){w(S,P);let U;if(P==="der"){const{r:$,s:W}=Io.toSig(tt(S));return new x($,W)}P==="recovered"&&(U=S[0],P="compact",S=S.subarray(1));const B=p.signature/2,O=S.subarray(0,B),V=S.subarray(B,B*2);return new x(o.fromBytes(O),o.fromBytes(V),U)}static fromHex(S,P){return this.fromBytes(id(S),P)}assertRecovery(){const{recovery:S}=this;if(S==null)throw new Error("invalid recovery id: must be present");return S}addRecoveryBit(S){return new x(this.r,this.s,S)}recoverPublicKey(S){const{r:P,s:U}=this,B=this.assertRecovery(),O=B===2||B===3?P+a:P;if(!s.isValid(O))throw new Error("invalid recovery id: sig.r+curve.n != R.x");const V=s.toBytes(O),$=n.fromBytes(rs(sD((B&1)===0),V)),W=o.inv(O),H=A(tt(S,void 0,"msgHash")),Y=o.create(-H*W),te=o.create(U*W),j=n.BASE.multiplyUnsafe(Y).add($.multiplyUnsafe(te));if(j.is0())throw new Error("invalid recovery: point at infinify");return j.assertValidity(),j}hasHighS(){return m(this.s)}toBytes(S=g.format){if(Tv(S),S==="der")return id(Io.hexFromSig(this));const{r:P,s:U}=this,B=o.toBytes(P),O=o.toBytes(U);return S==="recovered"?(E(),rs(Uint8Array.of(this.assertRecovery()),B,O)):rs(B,O)}toHex(S){return Jd(this.toBytes(S))}}const M=t.bits2int||function(S){if(S.length>8192)throw new Error("input is too large");const P=Rg(S),U=S.length*8-c;return U>0?P>>BigInt(U):P},A=t.bits2int_modN||function(S){return o.create(M(S))},C=hE(c);function R(v){return od("num < 2^"+c,v,$s,C),o.toBytes(v)}function _(v,S){return tt(v,void 0,"message"),S?tt(e(v),void 0,"prehashed message"):v}function T(v,S,P){const{lowS:U,prehash:B,extraEntropy:O}=i0(P,g);v=_(v,B);const V=A(v),$=o.fromBytes(S);if(!o.isValidNot0($))throw new Error("invalid private key");const W=[R($),R(V)];if(O!=null&&O!==!1){const j=O===!0?r(p.secretKey):O;W.push(tt(j,void 0,"extraEntropy"))}const H=rs(...W),Y=V;function te(j){const re=M(j);if(!o.isValidNot0(re))return;const le=o.inv(re),fe=n.BASE.multiply(re).toAffine(),se=o.create(fe.x);if(se===$s)return;const ve=o.create(le*o.create(Y+se*$));if(ve===$s)return;let X=(fe.x===se?0:2)|Number(fe.y&hl),Ut=ve;return U&&m(ve)&&(Ut=o.neg(ve),X^=1),new x(se,Ut,b?void 0:X)}return{seed:H,k2sig:te}}function F(v,S,P={}){const{seed:U,k2sig:B}=T(v,S,P);return Sz(e.outputLen,o.BYTES,i)(U,B).toBytes(P.format)}function k(v,S,P,U={}){const{lowS:B,prehash:O,format:V}=i0(U,g);if(P=tt(P,void 0,"publicKey"),S=_(S,O),!Pg(v)){const $=v instanceof x?", use sig.toBytes()":"";throw new Error("verify expects Uint8Array signature"+$)}w(v,V);try{const $=x.fromBytes(v,V),W=n.fromBytes(P);if(B&&$.hasHighS())return!1;const{r:H,s:Y}=$,te=A(S),j=o.inv(Y),re=o.create(te*j),le=o.create(H*j),fe=n.BASE.multiplyUnsafe(re).add(W.multiplyUnsafe(le));return fe.is0()?!1:o.create(fe.x)===H}catch{return!1}}function z(v,S,P={}){const{prehash:U}=i0(P,g);return S=_(S,U),x.fromBytes(v,"recovered").recoverPublicKey(S).toBytes()}return Object.freeze({keygen:l,getPublicKey:u,getSharedSecret:d,utils:f,lengths:p,Point:n,sign:F,verify:k,recoverPublicKey:z,Signature:x,hash:e})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const AE={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},XV={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},cT=BigInt(2);function YV(n){const e=AE.p,t=BigInt(3),r=BigInt(6),i=BigInt(11),s=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),l=n*n*n%e,u=l*l*n%e,d=Ft(u,t,e)*u%e,f=Ft(d,t,e)*u%e,p=Ft(f,cT,e)*l%e,g=Ft(p,i,e)*p%e,b=Ft(g,s,e)*g%e,m=Ft(b,a,e)*b%e,y=Ft(m,c,e)*m%e,E=Ft(y,a,e)*b%e,w=Ft(E,t,e)*u%e,x=Ft(w,o,e)*g%e,M=Ft(x,r,e)*l%e,A=Ft(M,cT,e);if(!Av.eql(Av.sqr(A),n))throw new Error("Cannot find square root");return A}const Av=Lg(AE.p,{sqrt:YV}),ZV=WV(AE,{Fp:Av,endo:XV}),ym=KV(ZV,kh),jV=33;function JV(n,e,t,r){var s;const i=ps.digest(t instanceof Uint8Array?t:t.subarray());if(gE(i))return i.then(({digest:o})=>{var a;return(a=r==null?void 0:r.signal)==null||a.throwIfAborted(),ym.verify(e,o,n,{prehash:!1,format:"der"})}).catch(o=>{throw o.name==="AbortError"?o:new rT(String(o))});try{return(s=r==null?void 0:r.signal)==null||s.throwIfAborted(),ym.verify(e,i.digest,n,{prehash:!1,format:"der"})}catch(o){throw new rT(String(o))}}let QV=class{constructor(e){h(this,"type","secp256k1");h(this,"raw");h(this,"_key");this._key=tH(e),this.raw=eH(this._key)}toMultihash(){return Zt.digest(as(this))}toCID(){return ze.createV1(114,this.toMultihash())}toString(){return at.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Ne(this.raw,e.raw)}verify(e,t,r){return JV(this._key,t,e,r)}};function ME(n){return new QV(n)}function eH(n){return ym.Point.fromBytes(n).toBytes()}function tH(n){try{return ym.Point.fromBytes(n),n}catch(e){throw new pP(String(e))}}async function nH(n,e){return aV()}function no(n,e){const{Type:t,Data:r}=iu.decode(n),i=r??new Uint8Array;switch(t){case En.RSA:return $V(i,e);case En.Ed25519:return yE(i);case En.secp256k1:return ME(i);case En.ECDSA:return AP(i);default:throw new mP}}function rH(n){var r,i;if(n.byteLength===pE)return yE(n);if(n.byteLength===jV)return ME(n);const e=Zd(n),t=(r=e[1])==null?void 0:r[0];if(t===H8||t===G8||t===W8)return MP(e);if(((i=e[0])==null?void 0:i[0])===FV)return nD(e,n);throw new Lu("Could not extract public key from raw bytes")}function lo(n){const{Type:e,Data:t}=iu.decode(n.digest),r=t??new Uint8Array;switch(e){case En.Ed25519:return yE(r);case En.secp256k1:return ME(r);case En.ECDSA:return AP(r);default:throw new mP}}function as(n){return iu.encode({Type:En[n.type],Data:n.raw})}const iH=Symbol.for("@libp2p/connection"),lT=Symbol.for("@libp2p/content-routing");var wb;let sH=(wb=class extends Error{constructor(e="The operation was aborted"){super(e),this.name="AbortError"}},h(wb,"name","AbortError"),wb);var vb;let zr=(vb=class extends Error{constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}},h(vb,"name","InvalidParametersError"),vb);class bm extends Error{constructor(e="The connection is closed"){super(e),this.name="ConnectionClosedError"}}h(bm,"name","ConnectionClosedError");var _b;let oH=(_b=class extends Error{constructor(e="Not found"){super(e),this.name="NotFoundError"}},h(_b,"name","NotFoundError"),_b);class CE extends Error{constructor(e="Invalid PeerID"){super(e),this.name="InvalidPeerIdError"}}h(CE,"name","InvalidPeerIdError");var Eb;let IE=(Eb=class extends Error{constructor(e="Invalid multiaddr"){super(e),this.name="InvalidMultiaddrError"}},h(Eb,"name","InvalidMultiaddrError"),Eb);var Sb;let aH=(Sb=class extends Error{constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}},h(Sb,"name","InvalidCIDError"),Sb);var xb;let cH=(xb=class extends Error{constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}},h(xb,"name","InvalidMultihashError"),xb);var Tb;let lH=(Tb=class extends Error{constructor(e="Timed out"){super(e),this.name="TimeoutError"}},h(Tb,"name","TimeoutError"),Tb);var Ab;let wm=(Ab=class extends Error{constructor(e="Not started"){super(e),this.name="NotStartedError"}},h(Ab,"name","NotStartedError"),Ab);var Mb;let s0=(Mb=class extends Error{constructor(e="Dial error"){super(e),this.name="DialError"}},h(Mb,"name","DialError"),Mb);class Mv extends Error{constructor(e="Limited connection"){super(e),this.name="LimitedConnectionError"}}h(Mv,"name","LimitedConnectionError");class aD extends Error{constructor(e="Too many inbound protocol streams"){super(e),this.name="TooManyInboundProtocolStreamsError"}}h(aD,"name","TooManyInboundProtocolStreamsError");var Cb;let uH=(Cb=class extends Error{constructor(e="Too many outbound protocol streams"){super(e),this.name="TooManyOutboundProtocolStreamsError"}},h(Cb,"name","TooManyOutboundProtocolStreamsError"),Cb);var Ib;let hH=(Ib=class extends Error{constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}},h(Ib,"name","UnsupportedKeyTypeError"),Ib),dH=class extends Event{constructor(t,r,i){super("close",i);h(this,"error");h(this,"local");this.error=r,this.local=t}};const uT=Symbol.for("@libp2p/peer-discovery"),PE=Symbol.for("@libp2p/peer-id");function fH(n){return!!(n!=null&&n[PE])}const hT=Symbol.for("@libp2p/peer-routing"),cD="keep-alive";function DE(n){return n!=null&&typeof n.start=="function"&&typeof n.stop=="function"}async function pH(...n){const e=[];for(const t of n)DE(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStart!=null&&await t.beforeStart()})),await Promise.all(e.map(async t=>{await t.start()})),await Promise.all(e.map(async t=>{t.afterStart!=null&&await t.afterStart()}))}async function mH(...n){const e=[];for(const t of n)DE(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStop!=null&&await t.beforeStop()})),await Promise.all(e.map(async t=>{await t.stop()})),await Promise.all(e.map(async t=>{t.afterStop!=null&&await t.afterStop()}))}var vm;(function(n){n[n.FATAL_ALL=0]="FATAL_ALL",n[n.NO_FATAL=1]="NO_FATAL"})(vm||(vm={}));const Cv=Symbol.for("@libp2p/service-capabilities"),dT=Symbol.for("@libp2p/service-dependencies"),lD=Symbol.for("nodejs.util.inspect.custom"),gH=114;var HM;let RE=class{constructor(e){h(this,"type");h(this,"multihash");h(this,"publicKey");h(this,"string");h(this,HM,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=at.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return ze.createV1(gH,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return Ne(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return Ne(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(HM=PE,lD)](){return`PeerId(${this.toString()})`}},uD=class extends RE{constructor(t){super({...t,type:"RSA"});h(this,"type","RSA");h(this,"publicKey");this.publicKey=t.publicKey}},hD=class extends RE{constructor(t){super({...t,type:"Ed25519"});h(this,"type","Ed25519");h(this,"publicKey");this.publicKey=t.publicKey}},dD=class extends RE{constructor(t){super({...t,type:"secp256k1"});h(this,"type","secp256k1");h(this,"publicKey");this.publicKey=t.publicKey}};const yH=2336;var GM,WM;let fD=class{constructor(e){h(this,"type","url");h(this,"multihash");h(this,"publicKey");h(this,"url");h(this,GM,!0);this.url=e.toString(),this.multihash=Zt.digest(ge(this.url))}[(WM=lD,GM=PE,WM)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return ze.createV1(yH,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=ne(e)),e.toString()===this.toString())}};const bH=114,fT=2336;function su(n,e){let t;if(n.charAt(0)==="1"||n.charAt(0)==="Q")t=co(at.decode(`z${n}`));else{if(n.startsWith("k51qzi5uqu5")||n.startsWith("kzwfwjn5ji4")||n.startsWith("k2k4r8")||n.startsWith("bafz"))return _H(ze.parse(n));throw new zr('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return pD(t)}function wH(n){if(n.type==="Ed25519")return new hD({multihash:n.toCID().multihash,publicKey:n});if(n.type==="secp256k1")return new dD({multihash:n.toCID().multihash,publicKey:n});if(n.type==="RSA")return new uD({multihash:n.toCID().multihash,publicKey:n});throw new hH}function vH(n){return wH(n.publicKey)}function pD(n){if(SH(n))return new uD({multihash:n});if(EH(n))try{const e=lo(n);if(e.type==="Ed25519")return new hD({multihash:n,publicKey:e});if(e.type==="secp256k1")return new dD({multihash:n,publicKey:e})}catch{const t=ne(n.digest);return new fD(new URL(t))}throw new cH("Supplied PeerID Multihash is invalid")}function _H(n){if((n==null?void 0:n.multihash)==null||n.version==null||n.version===1&&n.code!==bH&&n.code!==fT)throw new aH("Supplied PeerID CID is invalid");if(n.code===fT){const e=ne(n.multihash.digest);return new fD(new URL(e))}return pD(n.multihash)}function EH(n){return n.code===Zt.code}function SH(n){return n.code===ps.code}async function xH(n){var e,t;if(n.connectionProtector===null&&((t=(e=globalThis.process)==null?void 0:e.env)==null?void 0:t.LIBP2P_FORCE_PNET)!=null)throw new zr("Private network is enforced, but no protector was provided");return n}const ou=1e3,au=ou*60,cu=au*60,ja=cu*24,ad=ja*7,lu=ja*365.25,cd=lu/12;function TH(n,e){if(typeof n=="string")return AH(n);if(typeof n=="number")return IH(n,e);throw Error(`Value provided to ms() must be a string or number. value=${JSON.stringify(n)}`)}var mD=TH;function AH(n){if(typeof n!="string"||n.length===0||n.length>100)throw Error(`Value provided to ms.parse() must be a string with length between 1 and 99. value=${JSON.stringify(n)}`);let e=/^(?<value>-?\d*\.?\d+) *(?<unit>milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|months?|mo|years?|yrs?|y)?$/i.exec(n);if(!(e!=null&&e.groups))return NaN;let{value:t,unit:r="ms"}=e.groups,i=parseFloat(t),s=r.toLowerCase();switch(s){case"years":case"year":case"yrs":case"yr":case"y":return i*lu;case"months":case"month":case"mo":return i*cd;case"weeks":case"week":case"w":return i*ad;case"days":case"day":case"d":return i*ja;case"hours":case"hour":case"hrs":case"hr":case"h":return i*cu;case"minutes":case"minute":case"mins":case"min":case"m":return i*au;case"seconds":case"second":case"secs":case"sec":case"s":return i*ou;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return i;default:throw Error(`Unknown unit "${s}" provided to ms.parse(). value=${JSON.stringify(n)}`)}}function MH(n){let e=Math.abs(n);return e>=lu?`${Math.round(n/lu)}y`:e>=cd?`${Math.round(n/cd)}mo`:e>=ad?`${Math.round(n/ad)}w`:e>=ja?`${Math.round(n/ja)}d`:e>=cu?`${Math.round(n/cu)}h`:e>=au?`${Math.round(n/au)}m`:e>=ou?`${Math.round(n/ou)}s`:`${n}ms`}function CH(n){let e=Math.abs(n);return e>=lu?fa(n,e,lu,"year"):e>=cd?fa(n,e,cd,"month"):e>=ad?fa(n,e,ad,"week"):e>=ja?fa(n,e,ja,"day"):e>=cu?fa(n,e,cu,"hour"):e>=au?fa(n,e,au,"minute"):e>=ou?fa(n,e,ou,"second"):`${n} ms`}function IH(n,e){if(typeof n!="number"||!Number.isFinite(n))throw Error("Value provided to ms.format() must be of type number.");return e!=null&&e.long?CH(n):MH(n)}function fa(n,e,t,r){let i=e>=t*1.5;return`${Math.round(n/t)} ${r}${i?"s":""}`}function PH(n){t.debug=t,t.default=t,t.coerce=c,t.disable=s,t.enable=i,t.enabled=o,t.humanize=mD,t.destroy=l,Object.keys(n).forEach(u=>{t[u]=n[u]}),t.names=[],t.skips=[],t.formatters={};function e(u){let d=0;for(let f=0;f<u.length;f++)d=(d<<5)-d+u.charCodeAt(f),d|=0;return t.colors[Math.abs(d)%t.colors.length]}t.selectColor=e;function t(u,d){let f,p=null,g,b;function m(...y){if(!m.enabled)return;const E=m,w=Number(new Date),x=w-(f||w);E.diff=x,E.prev=f,E.curr=w,f=w,y[0]=t.coerce(y[0]),typeof y[0]!="string"&&y.unshift("%O");let M=0;y[0]=y[0].replace(/%([a-zA-Z%])/g,(C,R)=>{if(C==="%%")return"%";M++;const _=t.formatters[R];if(typeof _=="function"){const T=y[M];C=_.call(E,T),y.splice(M,1),M--}return C}),t.formatArgs.call(E,y),(d==null?void 0:d.onLog)!=null&&d.onLog(...y),(E.log||t.log).apply(E,y)}return m.namespace=u,m.useColors=t.useColors(),m.color=t.selectColor(u),m.extend=r,m.destroy=t.destroy,Object.defineProperty(m,"enabled",{enumerable:!0,configurable:!1,get:()=>p!==null?p:(g!==t.namespaces&&(g=t.namespaces,b=t.enabled(u)),b),set:y=>{p=y}}),typeof t.init=="function"&&t.init(m),m}function r(u,d){const f=t(this.namespace+(typeof d>"u"?":":d)+u);return f.log=this.log,f}function i(u){t.save(u),t.namespaces=u,t.names=[],t.skips=[];let d;const f=(typeof u=="string"?u:"").split(/[\s,]+/),p=f.length;for(d=0;d<p;d++)f[d]&&(u=f[d].replace(/\*/g,".*?"),u[0]==="-"?t.skips.push(new RegExp("^"+u.substr(1)+"$")):t.names.push(new RegExp("^"+u+"$")))}function s(){const u=[...t.names.map(a),...t.skips.map(a).map(d=>"-"+d)].join(",");return t.enable(""),u}function o(u){if(u[u.length-1]==="*")return!0;let d,f;for(d=0,f=t.skips.length;d<f;d++)if(t.skips[d].test(u))return!1;for(d=0,f=t.names.length;d<f;d++)if(t.names[d].test(u))return!0;return!1}function a(u){return u.toString().substring(2,u.toString().length-2).replace(/\.\*\?$/,"*")}function c(u){return u instanceof Error?u.stack??u.message:u}function l(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return t.setupFormatters(t.formatters),t.enable(t.load()),t}var DH={};const ts=kH(),RH=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function LH(){var n,e,t,r,i;return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&((n=navigator.userAgent)==null?void 0:n.toLowerCase().match(/(edge|trident)\/(\d+)/))!=null?!1:typeof document<"u"&&((t=(e=document.documentElement)==null?void 0:e.style)==null?void 0:t.WebkitAppearance)||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&((r=navigator.userAgent)==null?void 0:r.toLowerCase().match(/firefox\/(\d+)/))!=null&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&((i=navigator.userAgent)==null?void 0:i.toLowerCase().match(/applewebkit\/(\d+)/))}function OH(n){if(n[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+n[0]+(this.useColors?"%c ":" ")+"+"+mD(this.diff),!this.useColors)return;const e="color: "+this.color;n.splice(1,0,e,"color: inherit");let t=0,r=0;n[0].replace(/%[a-zA-Z%]/g,i=>{i!=="%%"&&(t++,i==="%c"&&(r=t))}),n.splice(r,0,e)}const NH=console.debug??console.log??(()=>{});function UH(n){try{n?ts==null||ts.setItem("debug",n):ts==null||ts.removeItem("debug")}catch{}}function BH(){let n;try{n=ts==null?void 0:ts.getItem("debug")}catch{}return!n&&typeof globalThis.process<"u"&&"env"in globalThis.process&&(n=DH.DEBUG),n}function kH(){try{return localStorage}catch{}}function $H(n){n.j=function(e){try{return JSON.stringify(e)}catch(t){return"[UnexpectedJSONParseError]: "+t.message}}}const Ur=PH({formatArgs:OH,save:UH,load:BH,useColors:LH,setupFormatters:$H,colors:RH,storage:ts,log:NH});Ur.formatters.b=n=>n==null?"undefined":at.baseEncode(n);Ur.formatters.t=n=>n==null?"undefined":yn.baseEncode(n);Ur.formatters.m=n=>n==null?"undefined":EP.baseEncode(n);Ur.formatters.p=n=>n==null?"undefined":n.toString();Ur.formatters.c=n=>n==null?"undefined":n.toString();Ur.formatters.k=n=>n==null?"undefined":n.toString();Ur.formatters.a=n=>n==null?"undefined":n.toString();function pT(n,e=""){const t=mT(n.message),r=mT(n.stack);return t!=null&&r!=null?r.includes(t)?`${r.split(`
`).join(`
${e}`)}`:`${t}
${e}${r.split(`
`).join(`
${e}`)}`:r!=null?`${r.split(`
`).join(`
${e}`)}`:t!=null?`${t}`:`${n.toString()}`}function FH(n){return n instanceof AggregateError||(n==null?void 0:n.name)==="AggregateError"&&Array.isArray(n.errors)}function gD(n,e=""){if(FH(n)){let t=pT(n,e);return n.errors.length>0?(e=`${e}    `,t+=`
${e}${n.errors.map(r=>`${gD(r,`${e}`)}`).join(`
${e}`)}`):t+=`
${e}[Error list was empty]`,t.trim()}return pT(n,e)}Ur.formatters.e=n=>n==null?"undefined":gD(n);function zH(n){const e=()=>{};return e.enabled=!1,e.color="",e.diff=0,e.log=()=>{},e.namespace=n,e.destroy=()=>!0,e.extend=()=>e,e}function yD(n){return{forComponent(e){return bD(e,n)}}}function bD(n,e){let t=zH(`${n}:trace`);return Ur.enabled(`${n}:trace`)&&Ur.names.map(r=>r.toString()).find(r=>r.includes(":trace"))!=null&&(t=Ur(`${n}:trace`,e)),Object.assign(Ur(n,e),{error:Ur(`${n}:error`,e),trace:t,newScope:r=>bD(`${n}:${r}`,e)})}function mT(n){if(n!=null&&(n=n.trim(),n.length!==0))return n}var Pb;let VH=(Pb=class extends Error{constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}},h(Pb,"name","InvalidMultihashError"),Pb);const wD=Symbol.for("@libp2p/peer-id"),vD=Symbol.for("nodejs.util.inspect.custom"),HH=114;var qM;let LE=class{constructor(e){h(this,"type");h(this,"multihash");h(this,"publicKey");h(this,"string");h(this,qM,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=at.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return ze.createV1(HH,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return Ne(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return Ne(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(qM=wD,vD)](){return`PeerId(${this.toString()})`}},GH=class extends LE{constructor(t){super({...t,type:"RSA"});h(this,"type","RSA");h(this,"publicKey");this.publicKey=t.publicKey}},WH=class extends LE{constructor(t){super({...t,type:"Ed25519"});h(this,"type","Ed25519");h(this,"publicKey");this.publicKey=t.publicKey}},qH=class extends LE{constructor(t){super({...t,type:"secp256k1"});h(this,"type","secp256k1");h(this,"publicKey");this.publicKey=t.publicKey}};const KH=2336;var KM,XM;let XH=class{constructor(e){h(this,"type","url");h(this,"multihash");h(this,"publicKey");h(this,"url");h(this,KM,!0);this.url=e.toString(),this.multihash=Zt.digest(ge(this.url))}[(XM=vD,KM=wD,XM)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return ze.createV1(KH,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=ne(e)),e.toString()===this.toString())}};function YH(n){if(jH(n))return new GH({multihash:n});if(ZH(n))try{const e=lo(n);if(e.type==="Ed25519")return new WH({multihash:n,publicKey:e});if(e.type==="secp256k1")return new qH({multihash:n,publicKey:e})}catch{const t=ne(n.digest);return new XH(new URL(t))}throw new VH("Supplied PeerID Multihash is invalid")}function ZH(n){return n.code===Zt.code}function jH(n){return n.code===ps.code}function Fh(n,e){const t={[Symbol.iterator]:()=>t,next:()=>{const r=n.next(),i=r.value;return r.done===!0||i==null?{done:!0,value:void 0}:{done:!1,value:e(i)}}};return t}function o0(n){const e=co(at.decode(`z${n}`));return YH(e)}let Nu=class{constructor(e){h(this,"map");if(this.map=new Map,e!=null)for(const[t,r]of e.entries())this.map.set(t.toString(),{key:t,value:r})}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(e){return this.map.delete(e.toString())}entries(){return Fh(this.map.entries(),e=>[e[1].key,e[1].value])}forEach(e){this.map.forEach((t,r)=>{e(t.value,t.key,this)})}get(e){var t;return(t=this.map.get(e.toString()))==null?void 0:t.value}has(e){return this.map.has(e.toString())}set(e,t){this.map.set(e.toString(),{key:e,value:t})}keys(){return Fh(this.map.values(),e=>e.key)}values(){return Fh(this.map.values(),e=>e.value)}get size(){return this.map.size}},_D=class Np{constructor(e){h(this,"set");if(this.set=new Set,e!=null)for(const t of e)this.set.add(t.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(e){this.set.add(e.toString())}clear(){this.set.clear()}delete(e){this.set.delete(e.toString())}entries(){return Fh(this.set.entries(),e=>{const t=o0(e[0]);return[t,t]})}forEach(e){this.set.forEach(t=>{const r=o0(t);e(r,r,this)})}has(e){return this.set.has(e.toString())}values(){return Fh(this.set.values(),e=>o0(e))}intersection(e){const t=new Np;for(const r of e)this.has(r)&&t.add(r);return t}difference(e){const t=new Np;for(const r of this)e.has(r)||t.add(r);return t}union(e){const t=new Np;for(const r of e)t.add(r);for(const r of this)t.add(r);return t}};const OE={32:16777619n,64:1099511628211n,128:309485009821345068724781371n,256:374144419156711147060143317175368453031918731002211n,512:35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,1024:5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n},ED={32:2166136261n,64:14695981039346656037n,128:144066263297769815596495629667062367629n,256:100029257958052580907070968620625704837092796014241193945225284501741471925557n,512:9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,1024:14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n},SD=new globalThis.TextEncoder;function JH(n,e){const t=OE[e];let r=ED[e];for(let i=0;i<n.length;i++)r^=BigInt(n[i]),r=BigInt.asUintN(e,r*t);return r}function QH(n,e,t){if(t.length===0)throw new Error("The `utf8Buffer` option must have a length greater than zero");const r=OE[e];let i=ED[e],s=n;for(;s.length>0;){const o=SD.encodeInto(s,t);s=s.slice(o.read);for(let a=0;a<o.written;a++)i^=BigInt(t[a]),i=BigInt.asUintN(e,i*r)}return i}function e9(n,{size:e=32,utf8Buffer:t}={}){if(!OE[e])throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");if(typeof n=="string"){if(t)return QH(n,e,t);n=SD.encode(n)}return JH(n,e)}const NE={hash:n=>Number(e9(n,{size:32})),hashV:(n,e)=>t9(NE.hash(n,e))};function t9(n){let e=n.toString(16);return e.length%2===1&&(e=`0${e}`),ge(e,"base16")}const xD=64;class Ta{constructor(e,t,r,i=2){h(this,"fp");h(this,"h");h(this,"seed");if(i>xD)throw new TypeError("Invalid Fingerprint Size");const s=t.hashV(e,r),o=ht(i);for(let a=0;a<o.length;a++)o[a]=s[a];o.length===0&&(o[0]=7),this.fp=o,this.h=t,this.seed=r}hash(){return this.h.hash(this.fp,this.seed)}equals(e){return(e==null?void 0:e.fp)instanceof Uint8Array?Ne(this.fp,e.fp):!1}}function _m(n,e){return Math.floor(Math.random()*(e-n))+n}class Jf{constructor(e){h(this,"contents");this.contents=new Array(e).fill(null)}has(e){if(!(e instanceof Ta))throw new TypeError("Invalid Fingerprint");return this.contents.some(t=>e.equals(t))}add(e){if(!(e instanceof Ta))throw new TypeError("Invalid Fingerprint");for(let t=0;t<this.contents.length;t++)if(this.contents[t]==null)return this.contents[t]=e,!0;return!0}swap(e){if(!(e instanceof Ta))throw new TypeError("Invalid Fingerprint");const t=_m(0,this.contents.length-1),r=this.contents[t];return this.contents[t]=e,r}remove(e){if(!(e instanceof Ta))throw new TypeError("Invalid Fingerprint");const t=this.contents.findIndex(r=>e.equals(r));return t>-1?(this.contents[t]=null,!0):!1}}const n9=500;class gT{constructor(e){h(this,"bucketSize");h(this,"filterSize");h(this,"fingerprintSize");h(this,"buckets");h(this,"count");h(this,"hash");h(this,"seed");this.filterSize=e.filterSize,this.bucketSize=e.bucketSize??4,this.fingerprintSize=e.fingerprintSize??2,this.count=0,this.buckets=[],this.hash=e.hash??NE,this.seed=e.seed??_m(0,Math.pow(2,10))}add(e){typeof e=="string"&&(e=ge(e));const t=new Ta(e,this.hash,this.seed,this.fingerprintSize),r=this.hash.hash(e,this.seed)%this.filterSize,i=(r^t.hash())%this.filterSize;if(this.buckets[r]==null&&(this.buckets[r]=new Jf(this.bucketSize)),this.buckets[i]==null&&(this.buckets[i]=new Jf(this.bucketSize)),this.buckets[r].add(t)||this.buckets[i].add(t))return this.count++,!0;const s=[r,i];let o=s[_m(0,s.length-1)];this.buckets[o]==null&&(this.buckets[o]=new Jf(this.bucketSize));for(let a=0;a<n9;a++){const c=this.buckets[o].swap(t);if(c!=null&&(o=(o^c.hash())%this.filterSize,this.buckets[o]==null&&(this.buckets[o]=new Jf(this.bucketSize)),this.buckets[o].add(c)))return this.count++,!0}return!1}has(e){var o,a;typeof e=="string"&&(e=ge(e));const t=new Ta(e,this.hash,this.seed,this.fingerprintSize),r=this.hash.hash(e,this.seed)%this.filterSize,i=((o=this.buckets[r])==null?void 0:o.has(t))??!1;if(i)return i;const s=(r^t.hash())%this.filterSize;return((a=this.buckets[s])==null?void 0:a.has(t))??!1}remove(e){var a,c;typeof e=="string"&&(e=ge(e));const t=new Ta(e,this.hash,this.seed,this.fingerprintSize),r=this.hash.hash(e,this.seed)%this.filterSize,i=((a=this.buckets[r])==null?void 0:a.remove(t))??!1;if(i)return this.count--,i;const s=(r^t.hash())%this.filterSize,o=((c=this.buckets[s])==null?void 0:c.remove(t))??!1;return o&&this.count--,o}get reliable(){return Math.floor(100*(this.count/this.filterSize))<=90}}const r9={1:.5,2:.84,4:.95,8:.98};function i9(n=.001){return n>.002?2:n>1e-5?4:8}function s9(n,e=.001){const t=i9(e),r=r9[t],i=Math.round(n/r),s=Math.min(Math.ceil(Math.log2(1/e)+Math.log2(2*t)),xD);return{filterSize:i,bucketSize:t,fingerprintSize:s}}class o9{constructor(e){h(this,"filterSize");h(this,"bucketSize");h(this,"fingerprintSize");h(this,"scale");h(this,"filterSeries");h(this,"hash");h(this,"seed");this.bucketSize=e.bucketSize??4,this.filterSize=e.filterSize??(1<<18)/this.bucketSize,this.fingerprintSize=e.fingerprintSize??2,this.scale=e.scale??2,this.hash=e.hash??NE,this.seed=e.seed??_m(0,Math.pow(2,10)),this.filterSeries=[new gT({filterSize:this.filterSize,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed})]}add(e){if(typeof e=="string"&&(e=ge(e)),this.has(e))return!0;let t=this.filterSeries.find(r=>r.reliable);if(t==null){const r=this.filterSize*Math.pow(this.scale,this.filterSeries.length);t=new gT({filterSize:r,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed}),this.filterSeries.push(t)}return t.add(e)}has(e){typeof e=="string"&&(e=ge(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].has(e))return!0;return!1}remove(e){typeof e=="string"&&(e=ge(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].remove(e))return!0;return!1}get count(){return this.filterSeries.reduce((e,t)=>e+t.count,0)}}function ld(n,e=.001,t){return new o9({...s9(n,e)})}var Db;let Em=(Db=class extends Error{constructor(e="The operation was aborted"){super(e),this.name="AbortError"}},h(Db,"name","AbortError"),Db);var Rb;let UE=(Rb=class extends Error{constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}},h(Rb,"name","InvalidParametersError"),Rb);var Lb;let a9=(Lb=class extends Error{constructor(e="The muxer is closed"){super(e),this.name="MuxerClosedError"}},h(Lb,"name","MuxerClosedError"),Lb);var Ob;let c9=(Ob=class extends Error{constructor(e="The stream has been reset"){super(e),this.name="StreamResetError"}},h(Ob,"name","StreamResetError"),Ob);var Nb;let ch=(Nb=class extends Error{constructor(e="The stream is in an invalid state"){super(e),this.name="StreamStateError"}},h(Nb,"name","StreamStateError"),Nb);class Iv extends Error{constructor(e="The stream buffer was full"){super(e),this.name="StreamBufferError"}}h(Iv,"name","StreamBufferError");class l9 extends Event{constructor(t,r){super("message",r);h(this,"data");this.data=t}}class BE extends Event{constructor(t,r,i){super("close",i);h(this,"error");h(this,"local");this.error=r,this.local=t}}class u9 extends BE{constructor(e,t){super(!0,e,t)}}class h9 extends BE{constructor(e,t){super(!1,e,t)}}function Rt(n){var i,s,o,a,c,l;const e=n.getComponents(),t={};let r=0;if(((i=e[r])==null?void 0:i.name)==="ip6zone"&&(t.zone=`${e[r].value}`,r++),e[r].name==="ip4"||e[r].name==="ip6"||e[r].name==="dns"||e[r].name==="dns4"||e[r].name==="dns6"?(t.type=e[r].name,t.host=e[r].value,r++):e[r].name==="dnsaddr"&&(t.type=e[r].name,t.host=`_dnsaddr.${e[r].value}`,r++),(((s=e[r])==null?void 0:s.name)==="tcp"||((o=e[r])==null?void 0:o.name)==="udp")&&(t.protocol=e[r].name==="tcp"?"tcp":"udp",t.port=parseInt(`${e[r].value}`),r++),((a=e[r])==null?void 0:a.name)==="ipcidr"&&(t.type==="ip4"?t.cidr=parseInt(`${e[r].value}`):t.type==="ip6"&&(t.cidr=`${e[r].value}`),r++),t.type==null||t.host==null)throw new UE(`Multiaddr ${n} was not an IPv4, IPv6, DNS, DNS4, DNS6 or DNSADDR address`);return((c=e[r])==null?void 0:c.name)==="tls"&&((l=e[r+1])==null?void 0:l.name)==="sni"&&(t.sni=e[r+1].value,r+=2),t}class d9{constructor(){h(this,"index",0);h(this,"input","")}new(e){return this.index=0,this.input=e,this}readAtomically(e){const t=this.index,r=e();return r===void 0&&(this.index=t),r}parseWith(e){const t=e();if(this.index===this.input.length)return t}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(e){return this.readAtomically(()=>{const t=this.readChar();if(t===e)return t})}readSeparator(e,t,r){return this.readAtomically(()=>{if(!(t>0&&this.readGivenChar(e)===void 0))return r()})}readNumber(e,t,r,i){return this.readAtomically(()=>{let s=0,o=0;const a=this.peekChar();if(a===void 0)return;const c=a==="0",l=2**(8*i)-1;for(;;){const u=this.readAtomically(()=>{const d=this.readChar();if(d===void 0)return;const f=Number.parseInt(d,e);if(!Number.isNaN(f))return f});if(u===void 0)break;if(s*=e,s+=u,s>l||(o+=1,t!==void 0&&o>t))return}if(o!==0)return!r&&c&&o>1?void 0:s})}readIPv4Addr(){return this.readAtomically(()=>{const e=new Uint8Array(4);for(let t=0;t<e.length;t++){const r=this.readSeparator(".",t,()=>this.readNumber(10,3,!1,1));if(r===void 0)return;e[t]=r}return e})}readIPv6Addr(){const e=t=>{for(let r=0;r<t.length/2;r++){const i=r*2;if(r<t.length-3){const o=this.readSeparator(":",r,()=>this.readIPv4Addr());if(o!==void 0)return t[i]=o[0],t[i+1]=o[1],t[i+2]=o[2],t[i+3]=o[3],[i+4,!0]}const s=this.readSeparator(":",r,()=>this.readNumber(16,4,!0,2));if(s===void 0)return[i,!1];t[i]=s>>8,t[i+1]=s&255}return[t.length,!1]};return this.readAtomically(()=>{const t=new Uint8Array(16),[r,i]=e(t);if(r===16)return t;if(i||this.readGivenChar(":")===void 0||this.readGivenChar(":")===void 0)return;const s=new Uint8Array(14),o=16-(r+2),[a]=e(s.subarray(0,o));return t.set(s.subarray(0,a),16-a),t})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}}const TD=45,f9=15,uu=new d9;function AD(n){if(!(n.length>f9))return uu.new(n).parseWith(()=>uu.readIPv4Addr())}function MD(n){if(n.includes("%")&&(n=n.split("%")[0]),!(n.length>TD))return uu.new(n).parseWith(()=>uu.readIPv6Addr())}function Pv(n,e=!1){if(n.includes("%")&&(n=n.split("%")[0]),n.length>TD)return;const t=uu.new(n).parseWith(()=>uu.readIPAddr());if(t)return e&&t.length===4?Uint8Array.from([0,0,0,0,0,0,0,0,0,0,255,255,t[0],t[1],t[2],t[3]]):t}function p9(n,e,t){let r=0;for(const i of n)if(!(r<e)){if(r>t)break;if(i!==255)return!1;r++}return!0}function m9(n,e,t,r){let i=0;for(const s of n)if(!(i<t)){if(i>r)break;if(s!==e[i])return!1;i++}return!0}function g9(n){switch(n.length){case ud:return n.join(".");case hd:{const e=[];for(let t=0;t<n.length;t++)t%2===0&&e.push(n[t].toString(16).padStart(2,"0")+n[t+1].toString(16).padStart(2,"0"));return e.join(":")}default:throw new Error("Invalid ip length")}}function y9(n){let e=0;for(let[t,r]of n.entries()){if(r===255){e+=8;continue}for(;(r&128)!=0;)e++,r=r<<1;if((r&128)!=0)return-1;for(let i=t+1;i<n.length;i++)if(n[i]!=0)return-1;break}return e}function b9(n){let e="0x";for(const t of n)e+=(t>>4).toString(16)+(t&15).toString(16);return e}const ud=4,hd=16,w9=new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]);function CD(n,e){e.length===hd&&n.length===ud&&p9(e,0,11)&&(e=e.slice(12)),e.length===ud&&n.length===hd&&m9(n,w9,0,11)&&(n=n.slice(12));const t=n.length;if(t!=e.length)throw new Error("Failed to mask ip");const r=new Uint8Array(t);for(let i=0;i<t;i++)r[i]=n[i]&e[i];return r}function v9(n,e){if(typeof e=="string"&&(e=Pv(e)),e==null)throw new Error("Invalid ip");if(e.length!==n.network.length)return!1;for(let t=0;t<e.length;t++)if((n.network[t]&n.mask[t])!==(e[t]&n.mask[t]))return!1;return!0}function _9(n){const[e,t]=n.split("/");if(!e||!t)throw new Error("Failed to parse given CIDR: "+n);let r=ud,i=AD(e);if(i==null&&(r=hd,i=MD(e),i==null))throw new Error("Failed to parse given CIDR: "+n);const s=parseInt(t,10);if(Number.isNaN(s)||String(s).length!==t.length||s<0||s>r*8)throw new Error("Failed to parse given CIDR: "+n);const o=ID(s,8*r);return{network:CD(i,o),mask:o}}function ID(n,e){if(e!==8*ud&&e!==8*hd)throw new Error("Invalid CIDR mask");if(n<0||n>e)throw new Error("Invalid CIDR mask");const t=e/8,r=new Uint8Array(t);for(let i=0;i<t;i++){if(n>=8){r[i]=255,n-=8;continue}r[i]=255-(255>>n),n=0}return r}class PD{constructor(e,t){if(t==null)({network:this.network,mask:this.mask}=_9(e));else{const r=Pv(e);if(r==null)throw new Error("Failed to parse network");t=String(t);const i=parseInt(t,10);if(Number.isNaN(i)||String(i).length!==t.length||i<0||i>r.length*8){const s=Pv(t);if(s==null)throw new Error("Failed to parse mask");this.mask=s}else this.mask=ID(i,8*r.length);this.network=CD(r,this.mask)}}contains(e){return v9({network:this.network,mask:this.mask},e)}toString(){const e=y9(this.mask),t=e!==-1?String(e):b9(this.mask);return g9(this.network)+"/"+t}}function E9(n,e){return new PD(n).contains(e)}function S9(n){try{const e=Rt(n);switch(e.type){case"ip6":return E9("2000::/3",e.host);default:return!1}}catch{return!1}}function x9(n){try{const e=Rt(n);switch(e.type){case"ip4":return e.host.startsWith("169.254.");case"ip6":return e.host.toLowerCase().startsWith("fe80");default:return!1}}catch{return!1}}function T9(n){return/^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(n)||/^::1$/.test(n)}function Dv(n){try{const e=Rt(n);switch(e.type){case"ip4":case"ip6":return T9(e.host);default:return!1}}catch{return!1}}function Ni(n){try{return Rt(n),!0}catch{return!1}}function Pt(n){return!!AD(n)}function hi(n){return!!MD(n)}function kE(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var zc={},yT;function A9(){return yT||(yT=1,(function(){var n,e,t,r,i,s,o,a;a=function(c){var l,u,d,f;return l=(c&255<<24)>>>24,u=(c&255<<16)>>>16,d=(c&65280)>>>8,f=c&255,[l,u,d,f].join(".")},o=function(c){var l,u,d,f,p,g;for(l=[],d=f=0;f<=3&&c.length!==0;d=++f){if(d>0){if(c[0]!==".")throw new Error("Invalid IP");c=c.substring(1)}g=e(c),p=g[0],u=g[1],c=c.substring(u),l.push(p)}if(c.length!==0)throw new Error("Invalid IP");switch(l.length){case 1:if(l[0]>4294967295)throw new Error("Invalid IP");return l[0]>>>0;case 2:if(l[0]>255||l[1]>16777215)throw new Error("Invalid IP");return(l[0]<<24|l[1])>>>0;case 3:if(l[0]>255||l[1]>255||l[2]>65535)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2])>>>0;case 4:if(l[0]>255||l[1]>255||l[2]>255||l[3]>255)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2]<<8|l[3])>>>0;default:throw new Error("Invalid IP")}},t=function(c){return c.charCodeAt(0)},r=t("0"),s=t("a"),i=t("A"),e=function(c){var l,u,d,f,p;for(f=0,l=10,u="9",d=0,c.length>1&&c[d]==="0"&&(c[d+1]==="x"||c[d+1]==="X"?(d+=2,l=16):"0"<=c[d+1]&&c[d+1]<="9"&&(d++,l=8,u="7")),p=d;d<c.length;){if("0"<=c[d]&&c[d]<=u)f=f*l+(t(c[d])-r)>>>0;else if(l===16)if("a"<=c[d]&&c[d]<="f")f=f*l+(10+t(c[d])-s)>>>0;else if("A"<=c[d]&&c[d]<="F")f=f*l+(10+t(c[d])-i)>>>0;else break;else break;if(f>4294967295)throw new Error("too large");d++}if(d===p)throw new Error("empty octet");return[f,d]},n=(function(){function c(l,u){var d,f,p;if(typeof l!="string")throw new Error("Missing `net' parameter");if(u||(p=l.split("/",2),l=p[0],u=p[1]),u||(u=32),typeof u=="string"&&u.indexOf(".")>-1){try{this.maskLong=o(u)}catch{throw new Error("Invalid mask: "+u)}for(d=f=32;f>=0;d=--f)if(this.maskLong===4294967295<<32-d>>>0){this.bitmask=d;break}}else if(u||u===0)this.bitmask=parseInt(u,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0);else throw new Error("Invalid mask: empty");try{this.netLong=(o(l)&this.maskLong)>>>0}catch{throw new Error("Invalid net address: "+l)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+u);this.size=Math.pow(2,32-this.bitmask),this.base=a(this.netLong),this.mask=a(this.maskLong),this.hostmask=a(~this.maskLong),this.first=this.bitmask<=30?a(this.netLong+1):this.base,this.last=this.bitmask<=30?a(this.netLong+this.size-2):a(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?a(this.netLong+this.size-1):void 0}return c.prototype.contains=function(l){return typeof l=="string"&&(l.indexOf("/")>0||l.split(".").length!==4)&&(l=new c(l)),l instanceof c?this.contains(l.base)&&this.contains(l.broadcast||l.last):(o(l)&this.maskLong)>>>0===(this.netLong&this.maskLong)>>>0},c.prototype.next=function(l){return l==null&&(l=1),new c(a(this.netLong+this.size*l),this.mask)},c.prototype.forEach=function(l){var u,d,f;for(f=o(this.first),d=o(this.last),u=0;f<=d;)l(a(f),f,u),u++,f++},c.prototype.toString=function(){return this.base+"/"+this.bitmask},c})(),zc.ip2long=o,zc.long2ip=a,zc.Netmask=n}).call(zc)),zc}var M9=A9();const C9=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"],I9=C9.map(n=>new M9.Netmask(n));function $E(n){for(const e of I9)if(e.contains(n))return!0;return!1}function P9(n){return/^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(n)}function D9(n){const e=n.split(":");if(e.length<2)return!1;const t=e[e.length-1].padStart(4,"0"),r=e[e.length-2].padStart(4,"0"),i=`${parseInt(r.substring(0,2),16)}.${parseInt(r.substring(2),16)}.${parseInt(t.substring(0,2),16)}.${parseInt(t.substring(2),16)}`;return $E(i)}function R9(n){return/^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(n)}function L9(n){const e=n.split(":"),t=e[e.length-1];return $E(t)}function O9(n){return/^::$/.test(n)||/^::1$/.test(n)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(n)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(n)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(n)||/^ff([0-9a-fA-F]{2,2}):/i.test(n)}function FE(n){if(Pt(n))return $E(n);if(P9(n))return D9(n);if(R9(n))return L9(n);if(hi(n))return O9(n)}function hu(n){try{const e=Rt(n);switch(e.type){case"ip4":case"ip6":return FE(e.host)??!1;default:return e.host==="localhost"}}catch{return!1}}function Qr(){const n={};return n.promise=new Promise((e,t)=>{n.resolve=e,n.reject=t}),n}class bT{constructor(e){h(this,"buffer");h(this,"mask");h(this,"top");h(this,"btm");h(this,"next");if(!(e>0)||(e-1&e)!==0)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){const e=this.buffer[this.btm];if(e!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return this.buffer[this.btm]===void 0}}class a0{constructor(e={}){h(this,"size");h(this,"hwm");h(this,"head");h(this,"tail");this.hwm=e.splitLimit??16,this.head=new bT(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return(e==null?void 0:e.byteLength)!=null?e.byteLength:1}push(e){if((e==null?void 0:e.value)!=null&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){const t=this.head;this.head=t.next=new bT(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(e===void 0&&this.tail.next!=null){const t=this.tail.next;this.tail.next=null,this.tail=t,e=this.tail.shift()}return(e==null?void 0:e.value)!=null&&(this.size-=this.calculateSize(e.value)),e}isEmpty(){return this.head.isEmpty()}}let N9=class extends Error{constructor(t,r){super(t??"The operation was aborted");h(this,"type");h(this,"code");this.type="aborted",this.code=r??"ABORT_ERR"}};function Ug(n={}){return U9(t=>{const r=t.shift();if(r==null)return{done:!0};if(r.error!=null)throw r.error;return{done:r.done===!0,value:r.value}},n)}function U9(n,e){e=e??{};let t=e.onEnd,r=new a0,i,s,o,a=Qr();const c=async()=>{try{return r.isEmpty()?o?{done:!0}:await new Promise((m,y)=>{s=E=>{s=null,r.push(E);try{m(n(r))}catch(w){y(w)}return i}}):n(r)}finally{r.isEmpty()&&queueMicrotask(()=>{a.resolve(),a=Qr()})}},l=m=>s!=null?s(m):(r.push(m),i),u=m=>(r=new a0,s!=null?s({error:m}):(r.push({error:m}),i)),d=m=>{if(o)return i;if((e==null?void 0:e.objectMode)!==!0&&(m==null?void 0:m.byteLength)==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return l({done:!1,value:m})},f=m=>o?i:(o=!0,m!=null?u(m):l({done:!0})),p=()=>(r=new a0,f(),{done:!0}),g=m=>(f(m),{done:!0});if(i={[Symbol.asyncIterator](){return this},next:c,return:p,throw:g,push:d,end:f,get readableLength(){return r.size},onEmpty:async m=>{const y=m==null?void 0:m.signal;if(y==null||y.throwIfAborted(),r.isEmpty())return;let E,w;y!=null&&(E=new Promise((x,M)=>{w=()=>{M(new N9)},y.addEventListener("abort",w)}));try{await Promise.race([a.promise,E])}finally{w!=null&&y!=null&&(y==null||y.removeEventListener("abort",w))}}},t==null)return i;const b=i;return i={[Symbol.asyncIterator](){return this},next(){return b.next()},throw(m){return b.throw(m),t!=null&&(t(m),t=void 0),{done:!0}},return(){return b.return(),t!=null&&(t(),t=void 0),{done:!0}},push:d,end(m){return b.end(m),t!=null&&(t(m),t=void 0),i},get readableLength(){return b.readableLength},onEmpty:m=>b.onEmpty(m)},i}let B9=class extends Error{constructor(e){super(e),this.name="TimeoutError"}},k9=class extends Error{constructor(e){super(),this.name="AbortError",this.message=e}};const wT=n=>globalThis.DOMException===void 0?new k9(n):new DOMException(n),vT=n=>{const e=n.reason===void 0?wT("This operation was aborted."):n.reason;return e instanceof Error?e:wT(e)};function $9(n,e){const{milliseconds:t,fallback:r,message:i,customTimers:s={setTimeout,clearTimeout}}=e;let o,a;const l=new Promise((u,d)=>{if(typeof t!="number"||Math.sign(t)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${t}\``);if(e.signal){const{signal:p}=e;p.aborted&&d(vT(p)),a=()=>{d(vT(p))},p.addEventListener("abort",a,{once:!0})}if(t===Number.POSITIVE_INFINITY){n.then(u,d);return}const f=new B9;o=s.setTimeout.call(void 0,()=>{if(r){try{u(r())}catch(p){d(p)}return}typeof n.cancel=="function"&&n.cancel(),i===!1?u():i instanceof Error?d(i):(f.message=i??`Promise timed out after ${t} milliseconds`,d(f))},t),(async()=>{try{u(await n)}catch(p){d(p)}})()}).finally(()=>{l.clear(),a&&e.signal&&e.signal.removeEventListener("abort",a)});return l.clear=()=>{s.clearTimeout.call(void 0,o),o=void 0},l}const F9=n=>{const e=n.addEventListener||n.on||n.addListener,t=n.removeEventListener||n.off||n.removeListener;if(!e||!t)throw new TypeError("Emitter is not compatible");return{addListener:e.bind(n),removeListener:t.bind(n)}};function z9(n,e,t){let r;const i=new Promise((s,o)=>{var p;if(t={rejectionEvents:["error"],multiArgs:!1,rejectionMultiArgs:!1,resolveImmediately:!1,...t},!(t.count>=0&&(t.count===Number.POSITIVE_INFINITY||Number.isInteger(t.count))))throw new TypeError("The `count` option should be at least 0 or more");(p=t.signal)==null||p.throwIfAborted();const a=[e].flat(),c=[],{addListener:l,removeListener:u}=F9(n),d=async(...g)=>{const b=t.multiArgs?g:g[0];if(t.filter)try{if(!await t.filter(b))return}catch(m){r(),o(m);return}c.push(b),t.count===c.length&&(r(),s(c))},f=(...g)=>{r(),o(t.rejectionMultiArgs?g:g[0])};r=()=>{for(const g of a)u(g,d);for(const g of t.rejectionEvents)a.includes(g)||u(g,f)};for(const g of a)l(g,d);for(const g of t.rejectionEvents)a.includes(g)||l(g,f);t.signal&&t.signal.addEventListener("abort",()=>{f(t.signal.reason)},{once:!0}),t.resolveImmediately&&s(c)});if(i.cancel=r,typeof t.timeout=="number"){const s=$9(i,{milliseconds:t.timeout});return s.cancel=()=>{r(),s.clear()},s}return i}function bn(n,e,t){typeof t=="function"&&(t={filter:t}),t={...t,count:1,resolveImmediately:!1};const r=z9(n,e,t),i=r.then(s=>s[0]);return i.cancel=r.cancel,i}function Sm(n,e){let t;const r=function(){const i=function(){t=void 0,n()};clearTimeout(t),t=setTimeout(i,e)};return r.start=()=>{},r.stop=()=>{clearTimeout(t)},r}class V9 extends Error{constructor(t="Rate limit exceeded",r){super(t);h(this,"remainingPoints");h(this,"msBeforeNext");h(this,"consumedPoints");h(this,"isFirstInDuration");this.name="RateLimitError",this.remainingPoints=r.remainingPoints,this.msBeforeNext=r.msBeforeNext,this.consumedPoints=r.consumedPoints,this.isFirstInDuration=r.isFirstInDuration}}var Ub;let H9=(Ub=class extends Error{constructor(e="The queue was full"){super(e),this.name="QueueFullError"}},h(Ub,"name","QueueFullError"),Ub);var Bb;let xm=(Bb=class extends Error{constructor(){super(...arguments);h(this,"name","UnexpectedEOFError")}},h(Bb,"name","UnexpectedEOFError"),Bb);class DD extends Error{constructor(){super(...arguments);h(this,"name","MaxEarlyStreamsError")}}h(DD,"name","MaxEarlyStreamsError");class RD extends Error{constructor(){super(...arguments);h(this,"name","StreamClosedError")}}h(RD,"name","StreamClosedError");function G9(n){return n.reason}async function Vi(n,e,t){if(e==null)return n;const r=G9;if(e.aborted)return n.catch(()=>{}),Promise.reject(r(e));let i;try{return await Promise.race([n,new Promise((s,o)=>{i=()=>{o(r(e))},e.addEventListener("abort",i)})])}finally{i!=null&&e.removeEventListener("abort",i)}}let W9=class{constructor(e){h(this,"deferred");h(this,"signal");var t;this.signal=e,this.deferred=Qr(),this.onAbort=this.onAbort.bind(this),(t=this.signal)==null||t.addEventListener("abort",this.onAbort)}onAbort(){var e;this.deferred.reject(((e=this.signal)==null?void 0:e.reason)??new Em)}cleanup(){var e;(e=this.signal)==null||e.removeEventListener("abort",this.onAbort)}};function q9(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}let K9=class{constructor(e,t){h(this,"id");h(this,"fn");h(this,"options");h(this,"recipients");h(this,"status");h(this,"timeline");h(this,"controller");this.id=q9(),this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((t,r)=>{var i;return t&&((i=r.signal)==null?void 0:i.aborted)===!0},!0)&&(this.controller.abort(new Em),this.cleanup())}async join(e={}){var r;const t=new W9(e.signal);return this.recipients.push(t),(r=e.signal)==null||r.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await Vi(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{var t;e.cleanup(),(t=e.signal)==null||t.removeEventListener("abort",this.onAbort)})}},LD=class extends fr{constructor(t={}){var r;super();h(this,"concurrency");h(this,"maxSize");h(this,"queue");h(this,"pending");h(this,"sort");h(this,"paused");this.concurrency=t.concurrency??Number.POSITIVE_INFINITY,this.maxSize=t.maxSize??Number.POSITIVE_INFINITY,this.pending=0,this.paused=!1,t.metricName!=null&&((r=t.metrics)==null||r.registerMetricGroup(t.metricName,{calculate:()=>({size:this.queue.length,running:this.pending,queued:this.queue.length-this.pending})})),this.sort=t.sort,this.queue=[],this.emitEmpty=Sm(this.emitEmpty.bind(this),1),this.emitIdle=Sm(this.emitIdle.bind(this),1)}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}pause(){this.paused=!0}resume(){this.paused&&(this.paused=!1,this.tryToStartAnother())}tryToStartAnother(){if(this.paused)return!1;if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let t;for(const r of this.queue)if(r.status==="queued"){t=r;break}return t==null?!1:(this.safeDispatchEvent("active"),this.pending++,t.run().finally(()=>{for(let r=0;r<this.queue.length;r++)if(this.queue[r]===t){this.queue.splice(r,1);break}this.pending--,this.tryToStartAnother(),this.safeDispatchEvent("next")}),!0)}return!1}enqueue(t){this.queue.push(t),this.sort!=null&&this.queue.sort(this.sort)}async add(t,r){var s;if((s=r==null?void 0:r.signal)==null||s.throwIfAborted(),this.size===this.maxSize)throw new H9;const i=new K9(t,r);return this.enqueue(i),this.safeDispatchEvent("add"),this.tryToStartAnother(),i.join(r).then(o=>(this.safeDispatchEvent("completed",{detail:o}),this.safeDispatchEvent("success",{detail:{job:i,result:o}}),o)).catch(o=>{if(i.status==="queued"){for(let a=0;a<this.queue.length;a++)if(this.queue[a]===i){this.queue.splice(a,1);break}}throw this.safeDispatchEvent("failure",{detail:{job:i,error:o}}),o})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(t=>{t.abort(new Em)}),this.clear()}async onEmpty(t){this.size!==0&&await bn(this,"empty",t)}async onSizeLessThan(t,r){this.size<t||await bn(this,"next",{...r,filter:()=>this.size<t})}async onIdle(t){this.pending===0&&this.size===0||await bn(this,"idle",t)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(t){var l,u,d;(l=t==null?void 0:t.signal)==null||l.throwIfAborted();const r=Ug({objectMode:!0}),i=f=>{f!=null?this.abort():this.clear(),r.end(f)},s=f=>{f.detail!=null&&r.push(f.detail)},o=f=>{i(f.detail.error)},a=()=>{i()},c=()=>{i(new Em("Queue aborted"))};this.addEventListener("completed",s),this.addEventListener("failure",o),this.addEventListener("idle",a),(u=t==null?void 0:t.signal)==null||u.addEventListener("abort",c);try{yield*r}finally{this.removeEventListener("completed",s),this.removeEventListener("failure",o),this.removeEventListener("idle",a),(d=t==null?void 0:t.signal)==null||d.removeEventListener("abort",c),i()}}};const X9=Math.pow(2,20)*4;class zE extends fr{constructor(t){super();h(this,"status");h(this,"timeline");h(this,"inactivityTimeout");h(this,"maxReadBufferLength");h(this,"maxWriteBufferLength");h(this,"log");h(this,"direction");h(this,"maxMessageSize");h(this,"readStatus");h(this,"writeStatus");h(this,"remoteReadStatus");h(this,"remoteWriteStatus");h(this,"writableNeedsDrain");h(this,"readBuffer");h(this,"writeBuffer");h(this,"sendingData");h(this,"onDrainPromise");this.status="open",this.log=t.log,this.direction=t.direction??"outbound",this.inactivityTimeout=t.inactivityTimeout??12e4,this.maxReadBufferLength=t.maxReadBufferLength??X9,this.maxWriteBufferLength=t.maxWriteBufferLength,this.maxMessageSize=t.maxMessageSize,this.readBuffer=new ut,this.writeBuffer=new ut,this.readStatus="readable",this.remoteReadStatus="readable",this.writeStatus="writable",this.remoteWriteStatus="writable",this.sendingData=!1,this.writableNeedsDrain=!1,this.timeline={open:Date.now()},this.processSendQueue=this.processSendQueue.bind(this);const r=()=>{var s;this.writableNeedsDrain&&(this.log.trace("drain event received, continue sending data"),this.writableNeedsDrain=!1,this.processSendQueue()),(s=this.onDrainPromise)==null||s.resolve()};this.addEventListener("drain",r);const i=s=>{var o;(o=this.onDrainPromise)==null||o.reject(s.error??new RD)};this.addEventListener("close",i)}get readBufferLength(){return this.readBuffer.byteLength}get writeBufferLength(){return this.writeBuffer.byteLength}async onDrain(t){return this.writableNeedsDrain!==!0?Promise.resolve():(this.onDrainPromise==null&&(this.onDrainPromise=Promise.withResolvers()),Vi(this.onDrainPromise.promise,t==null?void 0:t.signal))}async*[Symbol.asyncIterator](){if(this.readStatus!=="readable"&&this.readStatus!=="paused")return;const t=Ug(),r=o=>{t.push(o.data)};this.addEventListener("message",r);const i=o=>{t.end(o.error)};this.addEventListener("close",i);const s=()=>{t.end()};this.addEventListener("remoteCloseWrite",s);try{yield*t}finally{this.removeEventListener("message",r),this.removeEventListener("close",i),this.removeEventListener("remoteCloseWrite",s)}}isReadable(){return this.status==="open"}send(t){if(this.writeStatus==="closed"||this.writeStatus==="closing")throw new ch(`Cannot write to a stream that is ${this.writeStatus}`);return this.log.trace("append %d bytes to write buffer",t.byteLength),this.writeBuffer.append(t),this.processSendQueue()}abort(t){if(!(this.status==="aborted"||this.status==="reset"||this.status==="closed")){this.log.error("abort with error - %e",t),this.status="aborted",this.readBuffer.byteLength>0&&this.readBuffer.consume(this.readBuffer.byteLength),this.writeBuffer.byteLength>0&&(this.writeBuffer.consume(this.writeBuffer.byteLength),this.safeDispatchEvent("idle")),this.writeStatus="closed",this.remoteWriteStatus="closed",this.readStatus="closed",this.remoteReadStatus="closed",this.timeline.close=Date.now();try{this.sendReset(t)}catch(r){this.log("failed to send reset to remote - %e",r)}this.dispatchEvent(new u9(t))}}pause(){if(this.readStatus==="closed"||this.readStatus==="closing")throw new ch("Cannot pause a stream that is closing/closed");this.readStatus!=="paused"&&(this.readStatus="paused",this.sendPause())}resume(){if(this.readStatus==="closed"||this.readStatus==="closing")throw new ch("Cannot resume a stream that is closing/closed");this.readStatus!=="readable"&&(this.readStatus="readable",this.dispatchReadBuffer(),this.sendResume())}push(t){if(this.readStatus==="closed"||this.readStatus==="closing")throw new ch(`Cannot push data onto a stream that is ${this.readStatus}`);if(t.byteLength!==0){if(this.readBuffer.append(t),this.readStatus==="paused"||this.listenerCount("message")===0){this.checkReadBufferLength();return}setTimeout(()=>{this.dispatchReadBuffer()},0)}}unshift(t){if(this.readStatus==="closed"||this.readStatus==="closing")throw new ch(`Cannot push data onto a stream that is ${this.readStatus}`);if(t.byteLength!==0){if(this.readBuffer.prepend(t),this.readStatus==="paused"||this.listenerCount("message")===0){this.checkReadBufferLength();return}setTimeout(()=>{this.dispatchReadBuffer()},0)}}onData(t){if(t.byteLength!==0){if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("ignoring data - read status %s",this.readStatus);return}this.readBuffer.append(t),this.dispatchReadBuffer()}}addEventListener(...t){super.addEventListener.apply(this,t),t[0]==="message"&&this.readBuffer.byteLength>0&&queueMicrotask(()=>{this.dispatchReadBuffer()})}onRemoteReset(){this.log("remote reset"),this.status="reset",this.writeStatus="closed",this.remoteWriteStatus="closed",this.remoteReadStatus="closed",this.timeline.close=Date.now(),this.readBuffer.byteLength===0&&(this.readStatus="closed");const t=new c9;this.dispatchEvent(new h9(t))}onTransportClosed(t){this.log("transport closed"),this.readStatus==="readable"&&this.readBuffer.byteLength===0&&(this.log("close readable end after transport closed and read buffer is empty"),this.readStatus="closed"),this.remoteReadStatus!=="closed"&&(this.remoteReadStatus="closed"),this.remoteWriteStatus!=="closed"&&(this.remoteWriteStatus="closed"),this.writeStatus!=="closed"&&(this.writeStatus="closed"),t!=null?this.abort(t):(this.status==="open"||this.status==="closing")&&(this.timeline.close=Date.now(),this.status="closed",this.writeStatus="closed",this.remoteWriteStatus="closed",this.remoteReadStatus="closed",this.dispatchEvent(new BE))}onRemoteCloseWrite(){this.remoteWriteStatus!=="closed"&&(this.log.trace("on remote close write"),this.remoteWriteStatus="closed",this.safeDispatchEvent("remoteCloseWrite"),this.writeStatus==="closed"&&this.onTransportClosed())}onRemoteCloseRead(){this.log.trace("on remote close read"),this.remoteReadStatus="closed",this.writeBuffer.byteLength>0&&(this.writeBuffer.consume(this.writeBuffer.byteLength),this.safeDispatchEvent("idle"))}processSendQueue(){if(this.writableNeedsDrain)return this.log.trace("not processing send queue as drain is required"),this.checkWriteBufferLength(),!1;if(this.writeBuffer.byteLength===0)return this.log.trace("not processing send queue as no bytes to send"),!0;if(this.sendingData)return this.log.trace("not processing send queue as already sending data"),!0;this.sendingData=!0,this.log.trace("processing send queue with %d queued bytes",this.writeBuffer.byteLength);try{let t=!0;const r=this.writeBuffer.byteLength;let i=0;for(;this.writeBuffer.byteLength>0;){const s=Math.min(this.maxMessageSize??this.writeBuffer.byteLength,this.writeBuffer.byteLength);if(s===0){t=!1;break}const o=this.writeBuffer.sublist(0,s),a=new ut(o);this.writeBuffer.consume(o.byteLength);const c=this.sendData(o);if(t=c.canSendMore,i+=c.sentBytes,c.sentBytes!==a.byteLength&&(a.consume(c.sentBytes),this.writeBuffer.prepend(a)),!t)break}return t||(this.log.trace("sent %d/%d bytes, pausing sending because underlying stream is full, %d bytes left in the write buffer",i,r,this.writeBuffer.byteLength),this.writableNeedsDrain=!0,this.checkWriteBufferLength()),this.writeBuffer.byteLength===0&&this.safeDispatchEvent("idle"),t}finally{this.sendingData=!1}}dispatchReadBuffer(){try{if(this.listenerCount("message")===0){this.log.trace("not dispatching pause buffer as there are no listeners for the message event");return}if(this.readBuffer.byteLength===0){this.log.trace("not dispatching pause buffer as there is no data to dispatch");return}if(this.readStatus==="paused"){this.log.trace("not dispatching pause buffer we are paused");return}if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("dropping %d bytes because the readable end is %s",this.readBuffer.byteLength,this.readStatus),this.readBuffer.consume(this.readBuffer.byteLength);return}const t=this.readBuffer.sublist();this.readBuffer.consume(t.byteLength),this.dispatchEvent(new l9(t))}finally{this.readBuffer.byteLength===0&&this.remoteWriteStatus==="closed"&&(this.log("close readable end after dispatching read buffer and remote writable end is closed"),this.readStatus="closed"),this.checkReadBufferLength()}}checkReadBufferLength(){this.readBuffer.byteLength>this.maxReadBufferLength&&this.abort(new Iv(`Read buffer length of ${this.readBuffer.byteLength} exceeded limit of ${this.maxReadBufferLength}, read status is ${this.readStatus}`))}checkWriteBufferLength(){this.maxWriteBufferLength!=null&&this.writeBuffer.byteLength>this.maxWriteBufferLength&&this.abort(new Iv(`Write buffer length of ${this.writeBuffer.byteLength} exceeded limit of ${this.maxWriteBufferLength}, write status is ${this.writeStatus}`))}onMuxerNeedsDrain(){this.writableNeedsDrain=!0}onMuxerDrain(){this.safeDispatchEvent("drain")}}class VE extends zE{constructor(t){super(t);h(this,"remoteAddr");h(this,"metricPrefix");h(this,"metrics");this.metricPrefix=t.metricPrefix??"",this.metrics=t.metrics,this.remoteAddr=t.remoteAddr,this.addEventListener("close",r=>{var i,s,o,a,c;(i=this.metrics)==null||i.increment({[`${this.metricPrefix}end`]:!0}),r.error!=null?r.local?(s=this.metrics)==null||s.increment({[`${this.metricPrefix}abort`]:!0}):(o=this.metrics)==null||o.increment({[`${this.metricPrefix}reset`]:!0}):r.local?(a=this.metrics)==null||a.increment({[`${this.metricPrefix}_local_close`]:!0}):(c=this.metrics)==null||c.increment({[`${this.metricPrefix}_remote_close`]:!0})})}async close(t){this.status==="open"&&(this.status="closing",this.writeStatus="closing",this.remoteWriteStatus="closing",this.remoteReadStatus="closing",(this.sendingData||this.writeBuffer.byteLength>0)&&(this.log("waiting for write queue to become idle before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await bn(this,"idle",{...t,rejectionEvents:["close"]})),this.writableNeedsDrain&&(this.log("waiting for write queue to drain before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await bn(this,"drain",{...t,rejectionEvents:["close"]})),await this.sendClose(t),this.onTransportClosed())}}function Y9(n){return n==null?!1:typeof n.then=="function"&&typeof n.catch=="function"&&typeof n.finally=="function"}class OD extends fr{constructor(t,r){super();h(this,"streams");h(this,"protocol");h(this,"status");h(this,"log");h(this,"maConn");h(this,"streamOptions");h(this,"earlyStreams");h(this,"maxEarlyStreams");h(this,"metrics");this.maConn=t,this.protocol=r.protocol,this.streams=[],this.earlyStreams=[],this.status="open",this.log=t.log.newScope(r.name),this.streamOptions=r.streamOptions,this.maxEarlyStreams=r.maxEarlyStreams??10,this.metrics=r.metrics;const i=a=>{try{this.onData(a.data)}catch(c){this.abort(c),this.maConn.abort(c)}};this.maConn.addEventListener("message",i);const s=()=>{this.log("underlying stream drained, signal %d streams to continue writing",this.streams.length),this.streams.forEach(a=>{a.onMuxerDrain()})};this.maConn.addEventListener("drain",s);const o=()=>{this.log("underlying stream closed with status %s and %d streams",this.status,this.streams.length),this.onTransportClosed()};this.maConn.addEventListener("close",o)}send(t){const r=this.maConn.send(t);return r===!1&&(this.log("underlying stream saturated, signal %d streams to pause writing",this.streams.length),this.streams.forEach(i=>{i.onMuxerNeedsDrain()})),r}async close(t){this.status==="closed"||this.status==="closing"||(this.status="closing",await Vi(Promise.all([...this.streams].map(async r=>{await r.close(t)})),t==null?void 0:t.signal),this.status="closed")}abort(t){this.status!=="closed"&&(this.status="closing",[...this.streams].forEach(r=>{r.abort(t)}),this.status="closed")}onTransportClosed(t){this.status="closing";try{[...this.streams].forEach(r=>{r.onTransportClosed(t)})}catch(r){this.abort(r)}this.status="closed"}async createStream(t){if(this.status!=="open")throw new a9;let r=this.onCreateStream({...this.streamOptions,...t});return Y9(r)&&(r=await r),this.streams.push(r),this.cleanUpStream(r),r}onRemoteStream(t){if(this.streams.push(t),this.cleanUpStream(t),this.listenerCount("stream")===0){this.earlyStreams.push(t),this.earlyStreams.length>this.maxEarlyStreams&&this.abort(new DD(`Too many early streams were opened - ${this.earlyStreams.length}/${this.maxEarlyStreams}`));return}this.safeDispatchEvent("stream",{detail:t})}cleanUpStream(t){var i;const r=s=>{var a,c,l;const o=this.streams.findIndex(u=>u===t);o!==-1&&this.streams.splice(o,1),s.error!=null?s.local?(a=this.metrics)==null||a.increment({[`${t.direction}_stream_reset`]:!0}):(c=this.metrics)==null||c.increment({[`${t.direction}_stream_abort`]:!0}):(l=this.metrics)==null||l.increment({[`${t.direction}_stream_end`]:!0})};t.addEventListener("close",r),(i=this.metrics)==null||i.increment({[`${t.direction}_stream`]:!0})}addEventListener(...t){super.addEventListener.apply(this,t),t[0]==="stream"&&this.earlyStreams.length>0&&queueMicrotask(()=>{this.earlyStreams.forEach(r=>{this.safeDispatchEvent("stream",{detail:r})}),this.earlyStreams=[]})}}class ND extends zE{constructor(t){super(t);h(this,"id");h(this,"protocol");this.id=t.id,this.protocol=t.protocol??""}async close(t){this.writeStatus==="closing"||this.writeStatus==="closed"||(this.writeStatus="closing",(this.sendingData||this.writeBuffer.byteLength>0)&&(this.log("waiting for write queue to become idle before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await bn(this,"idle",{...t,rejectionEvents:["close"]})),this.writableNeedsDrain&&(this.log("waiting for write queue to drain before closing writable end of stream, %d unsent bytes, sending %s",this.writeBuffer.byteLength,this.sendingData),await bn(this,"drain",{...t,rejectionEvents:["close"]}),this.log("write queue drained, closing writable end of stream, %d unsent bytes, sending %s",this.writeBuffer.byteLength,this.sendingData)),await this.sendCloseWrite(t),this.writeStatus="closed",this.log("closed writable end gracefully"),this.remoteWriteStatus==="closed"&&this.onTransportClosed())}async closeRead(t){this.readStatus==="closing"||this.readStatus==="closed"||(this.readBuffer.byteLength>0&&this.readBuffer.consume(this.readBuffer.byteLength),this.readStatus="closing",await this.sendCloseRead(t),this.readStatus="closed",this.log("closed readable end gracefully"))}}function Ja(n){const e=new globalThis.AbortController;function t(){e.abort();for(const s of n)(s==null?void 0:s.removeEventListener)!=null&&s.removeEventListener("abort",t)}for(const s of n){if((s==null?void 0:s.aborted)===!0){t();break}(s==null?void 0:s.addEventListener)!=null&&s.addEventListener("abort",t)}function r(){for(const s of n)(s==null?void 0:s.removeEventListener)!=null&&s.removeEventListener("abort",t)}const i=e.signal;return i.clear=r,i}class c0{constructor(e){h(this,"movingAverage");h(this,"variance");h(this,"deviation");h(this,"forecast");h(this,"timeSpan");h(this,"previousTime");this.timeSpan=e,this.movingAverage=0,this.variance=0,this.deviation=0,this.forecast=0}alpha(e,t){return 1-Math.exp(-(e-t)/this.timeSpan)}push(e,t=Date.now()){if(this.previousTime!=null){const r=this.alpha(t,this.previousTime),i=e-this.movingAverage,s=r*i;this.movingAverage=r*e+(1-r)*this.movingAverage,this.variance=(1-r)*(this.variance+i*s),this.deviation=Math.sqrt(this.variance),this.forecast=this.movingAverage+r*i}else this.movingAverage=e;this.previousTime=t}}const Z9=1.2,j9=2,J9=5e3,Q9=6e4,eG=5e3;class tG{constructor(e={}){h(this,"success");h(this,"failure");h(this,"next");h(this,"metric");h(this,"timeoutMultiplier");h(this,"failureMultiplier");h(this,"minTimeout");h(this,"maxTimeout");var r;const t=e.interval??eG;this.success=new c0(t),this.failure=new c0(t),this.next=new c0(t),this.failureMultiplier=e.failureMultiplier??j9,this.timeoutMultiplier=e.timeoutMultiplier??Z9,this.minTimeout=e.minTimeout??J9,this.maxTimeout=e.maxTimeout??Q9,e.metricName!=null&&(this.metric=(r=e.metrics)==null?void 0:r.registerMetricGroup(e.metricName))}getTimeoutSignal(e={}){let t=Math.round(this.next.movingAverage*(e.timeoutFactor??this.timeoutMultiplier));t<this.minTimeout&&(t=this.minTimeout),t>this.maxTimeout&&(t=this.maxTimeout);const r=AbortSignal.timeout(t),i=Ja([e.signal,r]);return i.start=Date.now(),i.timeout=t,i}cleanUp(e){var r,i;const t=Date.now()-e.start;e.aborted?(this.failure.push(t),this.next.push(t*this.failureMultiplier),(r=this.metric)==null||r.update({failureMovingAverage:this.failure.movingAverage,failureDeviation:this.failure.deviation,failureForecast:this.failure.forecast,failureVariance:this.failure.variance,failure:t})):(this.success.push(t),this.next.push(t),(i=this.metric)==null||i.update({successMovingAverage:this.success.movingAverage,successDeviation:this.success.deviation,successForecast:this.success.forecast,successVariance:this.success.variance,success:t}))}}let _T=class extends Error{constructor(t,r,i){super(t??"The operation was aborted");h(this,"type");h(this,"code");this.type="aborted",this.name=i??"AbortError",this.code=r??"ABORT_ERR"}};async function nG(n,e,t){if(e==null)return n;if(e.aborted)return n.catch(()=>{}),Promise.reject(new _T(t==null?void 0:t.errorMessage,t==null?void 0:t.errorCode,t==null?void 0:t.errorName));let r;const i=new _T(t==null?void 0:t.errorMessage,t==null?void 0:t.errorCode,t==null?void 0:t.errorName);try{return await Promise.race([n,new Promise((s,o)=>{r=()=>{o(i)},e.addEventListener("abort",r)})])}finally{r!=null&&e.removeEventListener("abort",r)}}class rG{constructor(){h(this,"readNext");h(this,"haveNext");h(this,"ended");h(this,"nextResult");h(this,"error");this.ended=!1,this.readNext=Qr(),this.haveNext=Qr()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=Qr(),e}async throw(e){return this.ended=!0,this.error=e,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){e!=null?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(e!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=Qr(),await nG(this.readNext.promise,t==null?void 0:t.signal,t)}}function iG(){return new rG}function sG(n){return n[Symbol.asyncIterator]!=null}async function oG(n,e,t){try{await Promise.all(n.map(async r=>{for await(const i of r)await e.push(i,{signal:t}),t.throwIfAborted()})),await e.end(void 0,{signal:t})}catch(r){await e.end(r,{signal:t}).catch(()=>{})}}async function*aG(n){const e=new AbortController,t=iG();oG(n,t,e.signal).catch(()=>{});try{yield*t}finally{e.abort()}}function*cG(n){for(const e of n)yield*e}function Rv(...n){const e=[];for(const t of n)sG(t)||e.push(t);return e.length===n.length?cG(e):aG(n)}const lG=4194304;var kb;let ET=(kb=class extends Error{constructor(){super(...arguments);h(this,"name","UnwrappedError")}},h(kb,"name","UnwrappedError"),kb),UD=class extends Error{constructor(){super(...arguments);h(this,"name","InvalidMessageLengthError");h(this,"code","ERR_INVALID_MSG_LENGTH")}},uG=class extends Error{constructor(){super(...arguments);h(this,"name","InvalidDataLengthError");h(this,"code","ERR_MSG_DATA_TOO_LONG")}},hG=class extends Error{constructor(){super(...arguments);h(this,"name","InvalidDataLengthLengthError");h(this,"code","ERR_MSG_LENGTH_TOO_LONG")}};function dG(n){return typeof(n==null?void 0:n.closeRead)=="function"}function fG(n){return typeof(n==null?void 0:n.close)=="function"}function l0(n){return dG(n)?n.remoteWriteStatus!=="writable"&&n.readBufferLength===0:fG(n)?n.status!=="open":!1}function pG(n){return(n==null?void 0:n.addEventListener)!=null&&(n==null?void 0:n.removeEventListener)!=null&&(n==null?void 0:n.send)!=null&&(n==null?void 0:n.push)!=null&&(n==null?void 0:n.log)!=null}function BD(n,e){const t=(e==null?void 0:e.maxBufferSize)??lG,r=new ut;let i,s=!1;if(!pG(n))throw new UE("Argument should be a Stream or a Multiaddr");const o=u=>{if(r.append(u.data),r.byteLength>t){const d=r.byteLength;r.consume(r.byteLength),i==null||i.reject(new Error(`Read buffer overflow - ${d} > ${t}`))}i==null||i.resolve()};n.addEventListener("message",o);const a=u=>{u.error!=null?i==null||i.reject(u.error):i==null||i.resolve()};n.addEventListener("close",a);const c=()=>{i==null||i.resolve()};n.addEventListener("remoteCloseWrite",c);const l={readBuffer:r,async read(u){if(s===!0)throw new ET("Stream was unwrapped");if(l0(n)){if((u==null?void 0:u.bytes)==null)return null;if(r.byteLength<u.bytes)throw n.log.error("closed after reading %d/%d bytes",r.byteLength,u.bytes),new xm(`Unexpected EOF - stream closed after reading ${r.byteLength}/${u.bytes} bytes`)}const d=(u==null?void 0:u.bytes)??1;for(i=Promise.withResolvers();;){if(r.byteLength>=d){i.resolve();break}if(await Vi(i.promise,u==null?void 0:u.signal),l0(n)){if(r.byteLength===0&&(u==null?void 0:u.bytes)==null)return null;break}i=Promise.withResolvers()}const f=(u==null?void 0:u.bytes)??r.byteLength;if(r.byteLength<f){if(l0(n))throw n.log.error("closed while reading %d/%d bytes",r.byteLength,f),new xm(`Unexpected EOF - stream closed while reading ${r.byteLength}/${f} bytes`);return l.read(u)}const p=r.sublist(0,f);return r.consume(f),p},async write(u,d){if(s===!0)throw new ET("Stream was unwrapped");n.send(u)||await bn(n,"drain",{signal:d==null?void 0:d.signal,rejectionEvents:["close"]})},unwrap(){return s||(s=!0,n.removeEventListener("message",o),n.removeEventListener("close",a),n.removeEventListener("remoteCloseWrite",c),r.byteLength>0&&(n.log("stream unwrapped with %d unread bytes",r.byteLength),n.push(r))),n}};return l}function dd(n,e={}){const t=BD(n,e);e.maxDataLength!=null&&e.maxLengthLength==null&&(e.maxLengthLength=Me(e.maxDataLength));const r=(e==null?void 0:e.lengthDecoder)??zt,i=(e==null?void 0:e.lengthEncoder)??ul;return{async read(o){let a=-1;const c=new ut;for(;;){const u=await t.read({...o,bytes:1});if(u==null)break;c.append(u);try{a=r(c)}catch(d){if(d instanceof RangeError)continue;throw d}if(a<0)throw new UD("Invalid message length");if((e==null?void 0:e.maxLengthLength)!=null&&c.byteLength>e.maxLengthLength)throw new hG(`Message length length too long - ${c.byteLength} > ${e.maxLengthLength}`);if(a>-1)break}if((e==null?void 0:e.maxDataLength)!=null&&a>e.maxDataLength)throw new uG(`Message length too long - ${a} > ${e.maxDataLength}`);const l=await t.read({...o,bytes:a});if(l==null)throw n.log.error("tried to read %d bytes but the stream closed",a),new xm(`Unexpected EOF - tried to read ${a} bytes but the stream closed`);if(l.byteLength!==a)throw n.log.error("read %d/%d bytes before the stream closed",l.byteLength,a),new xm(`Unexpected EOF - read ${l.byteLength}/${a} bytes before the stream closed`);return l},async write(o,a){await t.write(new ut(i(o.byteLength),o),a)},async writeV(o,a){const c=new ut(...o.flatMap(l=>[i(l.byteLength),l]));await t.write(c,a)},unwrap(){return t.unwrap()}}}function Jo(n,e){const t=dd(n,e),r={read:async(i,s)=>{const o=await t.read(s);return i.decode(o)},write:async(i,s,o)=>{await t.write(s.encode(i),o)},writeV:async(i,s,o)=>{await t.writeV(i.map(a=>s.encode(a)),o)},pb:i=>({read:async s=>r.read(i,s),write:async(s,o)=>r.write(s,i,o),writeV:async(s,o)=>r.writeV(s,i,o),unwrap:()=>r}),unwrap:()=>t.unwrap()};return r}const mG=1024*1024*4,gG=1024*1024*4;class yG{constructor(e={}){h(this,"buffer");h(this,"maxBufferSize");h(this,"lengthDecoder");h(this,"maxDataLength");h(this,"encodingLength");this.buffer=new ut,this.maxBufferSize=e.maxBufferSize??mG,this.maxDataLength=e.maxDataLength??gG,this.lengthDecoder=e.lengthDecoder??zt,this.encodingLength=e.encodingLength??Me}*decode(e){if(this.buffer.append(e),this.buffer.byteLength>this.maxBufferSize)throw new UE(`Buffer length limit exceeded - ${this.buffer.byteLength}/${this.maxBufferSize}`);for(;;){let t;try{t=this.lengthDecoder(this.buffer)}catch(s){if(s instanceof RangeError)break;throw s}if(t<0||t>this.maxDataLength)throw new UD("Invalid message length");const r=this.encodingLength(t),i=r+t;if(this.buffer.byteLength>=i){const s=this.buffer.sublist(r,i);this.buffer.consume(i),s.byteLength>0&&(yield s)}else break}}}class HE extends LD{has(e){return this.find(e)!=null}find(e){return this.queue.find(t=>e.equals(t.options.peerId))}}let bG=class extends LD{constructor(e={}){super({...e,sort:(t,r)=>t.options.priority>r.options.priority?-1:t.options.priority<r.options.priority?1:0})}};class wG{constructor(e={}){h(this,"memoryStorage");h(this,"points");h(this,"duration");h(this,"blockDuration");h(this,"keyPrefix");this.points=e.points??4,this.duration=e.duration??1,this.blockDuration=e.blockDuration??0,this.keyPrefix=e.keyPrefix??"rlflx",this.memoryStorage=new vG}consume(e,t=1,r={}){const i=this.getKey(e),s=this._getKeySecDuration(r);let o=this.memoryStorage.incrby(i,t,s);if(o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o.consumedPoints>this.points)throw this.blockDuration>0&&o.consumedPoints<=this.points+t&&(o=this.memoryStorage.set(i,o.consumedPoints,this.blockDuration)),new V9("Rate limit exceeded",o);return o}penalty(e,t=1,r={}){const i=this.getKey(e),s=this._getKeySecDuration(r),o=this.memoryStorage.incrby(i,t,s);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}reward(e,t=1,r={}){const i=this.getKey(e),s=this._getKeySecDuration(r),o=this.memoryStorage.incrby(i,-t,s);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}block(e,t){const r=t*1e3,i=this.points+1;return this.memoryStorage.set(this.getKey(e),i,t),{remainingPoints:0,msBeforeNext:r===0?-1:r,consumedPoints:i,isFirstInDuration:!1}}set(e,t,r=0){const i=(r>=0?r:this.duration)*1e3;return this.memoryStorage.set(this.getKey(e),t,r),{remainingPoints:0,msBeforeNext:i===0?-1:i,consumedPoints:t,isFirstInDuration:!1}}get(e){const t=this.memoryStorage.get(this.getKey(e));return t!=null&&(t.remainingPoints=Math.max(this.points-t.consumedPoints,0)),t}delete(e){this.memoryStorage.delete(this.getKey(e))}_getKeySecDuration(e){return(e==null?void 0:e.customDuration)!=null&&e.customDuration>=0?e.customDuration:this.duration}getKey(e){return this.keyPrefix.length>0?`${this.keyPrefix}:${e}`:e}parseKey(e){return e.substring(this.keyPrefix.length)}}class vG{constructor(){h(this,"storage");this.storage=new Map}incrby(e,t,r){const i=this.storage.get(e);if(i!=null){const s=i.expiresAt!=null?i.expiresAt.getTime()-new Date().getTime():-1;return i.expiresAt==null||s>0?(i.value+=t,{remainingPoints:0,msBeforeNext:s,consumedPoints:i.value,isFirstInDuration:!1}):this.set(e,t,r)}return this.set(e,t,r)}set(e,t,r){const i=r*1e3,s=this.storage.get(e);s!=null&&clearTimeout(s.timeoutId);const o={value:t,expiresAt:i>0?new Date(Date.now()+i):void 0};return this.storage.set(e,o),i>0&&(o.timeoutId=setTimeout(()=>{this.storage.delete(e)},i),o.timeoutId.unref!=null&&o.timeoutId.unref()),{remainingPoints:0,msBeforeNext:i===0?-1:i,consumedPoints:o.value,isFirstInDuration:!0}}get(e){const t=this.storage.get(e);if(t!=null)return{remainingPoints:0,msBeforeNext:t.expiresAt!=null?t.expiresAt.getTime()-new Date().getTime():-1,consumedPoints:t.value,isFirstInDuration:!1}}delete(e){const t=this.storage.get(e);return t!=null?(t.timeoutId!=null&&clearTimeout(t.timeoutId),this.storage.delete(e),!0):!1}}function kD(n,e,t){let r,i,s=!1;function o(){const l={signal:i.signal};if((t==null?void 0:t.timeout)!=null){const u=Ja([i.signal,AbortSignal.timeout(t.timeout)]);l.signal=u}s=!0,Promise.resolve().then(async()=>{await n(l)}).catch(()=>{}).finally(()=>{s=!1,!i.signal.aborted&&(r=setTimeout(o,e))})}const a=Sm(o,(t==null?void 0:t.debounce)??100);let c=!1;return{setInterval:l=>{e!==l&&(e=l,r!=null&&(clearTimeout(r),r=setTimeout(o,e)))},setTimeout:l=>{t??(t={}),t.timeout=l},run:()=>{s||(clearTimeout(r),a())},start:()=>{c||(c=!0,i=new AbortController,i.signal,(t==null?void 0:t.runImmediately)===!0?queueMicrotask(()=>{o()}):r=setTimeout(o,e))},stop:()=>{clearTimeout(r),i==null||i.abort(),c=!1}}}class _G extends Map{constructor(t){super();h(this,"metric");const{name:r,metrics:i}=t;this.metric=i.registerMetric(r),this.updateComponentMetric()}set(t,r){return super.set(t,r),this.updateComponentMetric(),this}delete(t){const r=super.delete(t);return this.updateComponentMetric(),r}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function ro(n){const{name:e,metrics:t}=n;let r;return t!=null?r=new _G({name:e,metrics:t}):r=new Map,r}class EG{constructor(e,t){h(this,"filter");this.filter=ld(e,t)}has(e){return this.filter.has(e.toMultihash().bytes)}add(e){this.filter.add(e.toMultihash().bytes)}remove(e){var t,r;(r=(t=this.filter).remove)==null||r.call(t,e.toMultihash().bytes)}}function SG(n,e=.001){return new EG(n,e)}class xG extends Nu{constructor(t){super();h(this,"metric");const{name:r,metrics:i}=t;this.metric=i.registerMetric(r),this.updateComponentMetric()}set(t,r){return super.set(t,r),this.updateComponentMetric(),this}delete(t){const r=super.delete(t);return this.updateComponentMetric(),r}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function TG(n){const{name:e,metrics:t}=n;let r;return t!=null?r=new xG({name:e,metrics:t}):r=new Nu,r}var $b;let Zr=($b=class extends Error{constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}},h($b,"name","InvalidParametersError"),$b);var Fb;let ST=(Fb=class extends Error{constructor(e="Not found"){super(e),this.name="NotFoundError"}},h(Fb,"name","NotFoundError"),Fb);var zb;let AG=(zb=class extends Error{constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}},h(zb,"name","InvalidCIDError"),zb);var Vb;let MG=(Vb=class extends Error{constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}},h(Vb,"name","InvalidMultihashError"),Vb);var Hb;let CG=(Hb=class extends Error{constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}},h(Hb,"name","UnsupportedKeyTypeError"),Hb);const GE=Symbol.for("@libp2p/peer-id");function Up(n){return!!(n!=null&&n[GE])}const $D=Symbol.for("nodejs.util.inspect.custom"),IG=114;var YM;let WE=class{constructor(e){h(this,"type");h(this,"multihash");h(this,"publicKey");h(this,"string");h(this,YM,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=at.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return ze.createV1(IG,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return Ne(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return Ne(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(YM=GE,$D)](){return`PeerId(${this.toString()})`}},FD=class extends WE{constructor(t){super({...t,type:"RSA"});h(this,"type","RSA");h(this,"publicKey");this.publicKey=t.publicKey}},zD=class extends WE{constructor(t){super({...t,type:"Ed25519"});h(this,"type","Ed25519");h(this,"publicKey");this.publicKey=t.publicKey}},VD=class extends WE{constructor(t){super({...t,type:"secp256k1"});h(this,"type","secp256k1");h(this,"publicKey");this.publicKey=t.publicKey}};const PG=2336;var ZM,jM;let HD=class{constructor(e){h(this,"type","url");h(this,"multihash");h(this,"publicKey");h(this,"url");h(this,ZM,!0);this.url=e.toString(),this.multihash=Zt.digest(ge(this.url))}[(jM=$D,ZM=GE,jM)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return ze.createV1(PG,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=ne(e)),e.toString()===this.toString())}};const DG=114,xT=2336;function RG(n){if(n.type==="Ed25519")return new zD({multihash:n.toCID().multihash,publicKey:n});if(n.type==="secp256k1")return new VD({multihash:n.toCID().multihash,publicKey:n});if(n.type==="RSA")return new FD({multihash:n.toCID().multihash,publicKey:n});throw new CG}function LG(n){if(NG(n))return new FD({multihash:n});if(OG(n))try{const e=lo(n);if(e.type==="Ed25519")return new zD({multihash:n,publicKey:e});if(e.type==="secp256k1")return new VD({multihash:n,publicKey:e})}catch{const t=ne(n.digest);return new HD(new URL(t))}throw new MG("Supplied PeerID Multihash is invalid")}function GD(n){if((n==null?void 0:n.multihash)==null||n.version==null||n.version===1&&n.code!==DG&&n.code!==xT)throw new AG("Supplied PeerID CID is invalid");if(n.code===xT){const e=ne(n.multihash.digest);return new HD(new URL(e))}return LG(n.multihash)}function OG(n){return n.code===Zt.code}function NG(n){return n.code===ps.code}var Tm;(function(n){let e;n.codec=()=>(e==null&&(e=Nt((t,r,i={})=>{i.lengthDelimited!==!1&&r.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(r.uint32(10),r.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(r.uint32(18),r.bytes(t.payloadType)),t.payload!=null&&t.payload.byteLength>0&&(r.uint32(26),r.bytes(t.payload)),t.signature!=null&&t.signature.byteLength>0&&(r.uint32(42),r.bytes(t.signature)),i.lengthDelimited!==!1&&r.ldelim()},(t,r,i={})=>{const s={publicKey:ht(0),payloadType:ht(0),payload:ht(0),signature:ht(0)},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.publicKey=t.bytes();break}case 2:{s.payloadType=t.bytes();break}case 3:{s.payload=t.bytes();break}case 5:{s.signature=t.bytes();break}default:{t.skipType(a&7);break}}}return s})),e),n.encode=t=>Ot(t,n.codec()),n.decode=(t,r)=>Lt(t,n.codec(),r)})(Tm||(Tm={}));class UG extends Error{constructor(e="Invalid signature"){super(e),this.name="InvalidSignatureError"}}const Do=class Do{constructor(e){h(this,"publicKey");h(this,"payloadType");h(this,"payload");h(this,"signature");h(this,"marshaled");const{publicKey:t,payloadType:r,payload:i,signature:s}=e;this.publicKey=t,this.payloadType=r,this.payload=i,this.signature=s}marshal(){return this.marshaled==null&&(this.marshaled=Tm.encode({publicKey:as(this.publicKey),payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(e){return e==null?!1:Ne(this.marshal(),e.marshal())}async validate(e,t){const r=TT(e,this.payloadType,this.payload);return this.publicKey.verify(r.subarray(),this.signature,t)}};h(Do,"createFromProtobuf",e=>{const t=Tm.decode(e),r=no(t.publicKey);return new Do({publicKey:r,payloadType:t.payloadType,payload:t.payload,signature:t.signature})}),h(Do,"seal",async(e,t,r)=>{if(t==null)throw new Error("Missing private key");const i=e.domain,s=e.codec,o=e.marshal(),a=TT(i,s,o),c=await t.sign(a.subarray(),r);return new Do({publicKey:t.publicKey,payloadType:s,payload:o,signature:c})}),h(Do,"openAndCertify",async(e,t,r)=>{const i=Do.createFromProtobuf(e);if(!await i.validate(t,r))throw new UG("Envelope signature is not valid for the given domain");return i});let Qa=Do;const TT=(n,e,t)=>{const r=ge(n),i=ul(r.byteLength),s=ul(e.length),o=ul(t.length);return new ut(i,r,s,e,o,t)};var Gb;let BG=(Gb=class extends Error{constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}},h(Gb,"name","InvalidMultihashError"),Gb);const WD=Symbol.for("@libp2p/peer-id"),qD=Symbol.for("nodejs.util.inspect.custom"),kG=114;var JM;let qE=class{constructor(e){h(this,"type");h(this,"multihash");h(this,"publicKey");h(this,"string");h(this,JM,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=at.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return ze.createV1(kG,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return Ne(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return Ne(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(JM=WD,qD)](){return`PeerId(${this.toString()})`}},$G=class extends qE{constructor(t){super({...t,type:"RSA"});h(this,"type","RSA");h(this,"publicKey");this.publicKey=t.publicKey}},FG=class extends qE{constructor(t){super({...t,type:"Ed25519"});h(this,"type","Ed25519");h(this,"publicKey");this.publicKey=t.publicKey}},zG=class extends qE{constructor(t){super({...t,type:"secp256k1"});h(this,"type","secp256k1");h(this,"publicKey");this.publicKey=t.publicKey}};const VG=2336;var QM,eC;let HG=class{constructor(e){h(this,"type","url");h(this,"multihash");h(this,"publicKey");h(this,"url");h(this,QM,!0);this.url=e.toString(),this.multihash=Zt.digest(ge(this.url))}[(eC=qD,QM=WD,eC)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return ze.createV1(VG,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=ne(e)),e.toString()===this.toString())}};function GG(n){if(qG(n))return new $G({multihash:n});if(WG(n))try{const e=lo(n);if(e.type==="Ed25519")return new FG({multihash:n,publicKey:e});if(e.type==="secp256k1")return new zG({multihash:n,publicKey:e})}catch{const t=ne(n.digest);return new HG(new URL(t))}throw new BG("Supplied PeerID Multihash is invalid")}function WG(n){return n.code===Zt.code}function qG(n){return n.code===ps.code}var Wb;let ei=(Wb=class extends Error{constructor(){super(...arguments);h(this,"name","InvalidMultiaddrError")}},h(Wb,"name","InvalidMultiaddrError"),Wb);var qb;let fd=(qb=class extends Error{constructor(){super(...arguments);h(this,"name","ValidationError")}},h(qb,"name","ValidationError"),qb);var Kb;let KG=(Kb=class extends Error{constructor(){super(...arguments);h(this,"name","InvalidParametersError")}},h(Kb,"name","InvalidParametersError"),Kb);var Xb;let XG=(Xb=class extends Error{constructor(){super(...arguments);h(this,"name","UnknownProtocolError")}},h(Xb,"name","UnknownProtocolError"),Xb);const YG=4,ZG=6,jG=273,JG=33,QG=41,e7=42,t7=43,n7=53,r7=54,i7=55,s7=56,o7=132,a7=301,c7=302,l7=400,u7=421,h7=444,d7=445,f7=446,p7=447,m7=448,g7=449,y7=454,b7=460,w7=461,v7=465,_7=466,E7=480,S7=481,x7=443,T7=477,A7=478,M7=479,C7=277,I7=275,P7=276,D7=280,R7=281,L7=290,O7=777;function AT(n){return e=>ne(e,n)}function MT(n){return e=>ge(e,n)}function yh(n){return new DataView(n.buffer).getUint16(n.byteOffset).toString()}function Xc(n){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof n=="string"?parseInt(n):n),new Uint8Array(e)}function N7(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=ge(e[0],"base32"),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const i=Xc(r);return nt([t,i],t.length+i.length)}function U7(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=yn.decode(`b${e[0]}`),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const i=Xc(r);return nt([t,i],t.length+i.length)}function CT(n){const e=n.subarray(0,n.length-2),t=n.subarray(n.length-2),r=ne(e,"base32"),i=yh(t);return`${r}:${i}`}const KD=function(n){n=n.toString().trim();const e=new Uint8Array(4);return n.split(/\./g).forEach((t,r)=>{const i=parseInt(t,10);if(isNaN(i)||i<0||i>255)throw new ei("Invalid byte value in IP address");e[r]=i}),e},B7=function(n){let e=0;n=n.toString().trim();const t=n.split(":",8);let r;for(r=0;r<t.length;r++){const s=Pt(t[r]);let o;s&&(o=KD(t[r]),t[r]=ne(o.subarray(0,2),"base16")),o!=null&&++r<8&&t.splice(r,0,ne(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(r=0;r<t.length&&t[r]!=="";r++);const s=[r,1];for(r=9-t.length;r>0;r--)s.push("0");t.splice.apply(t,s)}const i=new Uint8Array(e+16);for(r=0;r<t.length;r++){t[r]===""&&(t[r]="0");const s=parseInt(t[r],16);if(isNaN(s)||s<0||s>65535)throw new ei("Invalid byte value in IP address");i[e++]=s>>8&255,i[e++]=s&255}return i},k7=function(n){if(n.byteLength!==4)throw new ei("IPv4 address was incorrect length");const e=[];for(let t=0;t<n.byteLength;t++)e.push(n[t]);return e.join(".")},$7=function(n){if(n.byteLength!==16)throw new ei("IPv6 address was incorrect length");const e=[];for(let r=0;r<n.byteLength;r+=2){const i=n[r],s=n[r+1],o=`${i.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const r=new URL(`http://[${t}]`);return r.hostname.substring(1,r.hostname.length-1)}catch{throw new ei(`Invalid IPv6 address "${t}"`)}};function F7(n){try{const e=new URL(`http://[${n}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new ei(`Invalid IPv6 address "${n}"`)}}const u0=Object.values(Fr).map(n=>n.decoder),z7=(function(){let n=u0[0].or(u0[1]);return u0.slice(2).forEach(e=>n=n.or(e)),n})();function V7(n){return z7.decode(n)}function H7(n){return e=>n.encoder.encode(e)}function G7(n){if(parseInt(n).toString()!==n)throw new fd("Value must be an integer")}function W7(n){if(n<0)throw new fd("Value must be a positive integer, or zero")}function q7(n){return e=>{if(e>n)throw new fd(`Value must be smaller than or equal to ${n}`)}}function K7(...n){return e=>{for(const t of n)t(e)}}const Qf=K7(G7,W7,q7(65535)),Bn=-1;let X7=class{constructor(){h(this,"protocolsByCode",new Map);h(this,"protocolsByName",new Map)}getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new XG(`Protocol ${e} was unknown`);return t}addProtocol(e){var t;this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),(t=e.aliases)==null||t.forEach(r=>{this.protocolsByName.set(r,e)})}removeProtocol(e){var r;const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),(r=t.aliases)==null||r.forEach(i=>{this.protocolsByName.delete(i)}))}};const Uu=new X7,Y7=[{code:YG,name:"ip4",size:32,valueToBytes:KD,bytesToValue:k7,validate:n=>{if(!Pt(n))throw new fd(`Invalid IPv4 address "${n}"`)}},{code:ZG,name:"tcp",size:16,valueToBytes:Xc,bytesToValue:yh,validate:Qf},{code:jG,name:"udp",size:16,valueToBytes:Xc,bytesToValue:yh,validate:Qf},{code:JG,name:"dccp",size:16,valueToBytes:Xc,bytesToValue:yh,validate:Qf},{code:QG,name:"ip6",size:128,valueToBytes:B7,bytesToValue:$7,stringToValue:F7,validate:n=>{if(!hi(n))throw new fd(`Invalid IPv6 address "${n}"`)}},{code:e7,name:"ip6zone",size:Bn},{code:t7,name:"ipcidr",size:8,bytesToValue:AT("base10"),valueToBytes:MT("base10")},{code:n7,name:"dns",size:Bn},{code:r7,name:"dns4",size:Bn},{code:i7,name:"dns6",size:Bn},{code:s7,name:"dnsaddr",size:Bn},{code:o7,name:"sctp",size:16,valueToBytes:Xc,bytesToValue:yh,validate:Qf},{code:a7,name:"udt"},{code:c7,name:"utp"},{code:l7,name:"unix",size:Bn,stringToValue:n=>decodeURIComponent(n),valueToString:n=>encodeURIComponent(n)},{code:u7,name:"p2p",aliases:["ipfs"],size:Bn,bytesToValue:AT("base58btc"),valueToBytes:n=>n.startsWith("Q")||n.startsWith("1")?MT("base58btc")(n):ze.parse(n).multihash.bytes},{code:h7,name:"onion",size:96,bytesToValue:CT,valueToBytes:N7},{code:d7,name:"onion3",size:296,bytesToValue:CT,valueToBytes:U7},{code:f7,name:"garlic64",size:Bn},{code:p7,name:"garlic32",size:Bn},{code:m7,name:"tls"},{code:g7,name:"sni",size:Bn},{code:y7,name:"noise"},{code:b7,name:"quic"},{code:w7,name:"quic-v1"},{code:v7,name:"webtransport"},{code:_7,name:"certhash",size:Bn,bytesToValue:H7(ui),valueToBytes:V7},{code:E7,name:"http"},{code:S7,name:"http-path",size:Bn,stringToValue:n=>`/${decodeURIComponent(n)}`,valueToString:n=>encodeURIComponent(n.substring(1))},{code:x7,name:"https"},{code:T7,name:"ws"},{code:A7,name:"wss"},{code:M7,name:"p2p-websocket-star"},{code:C7,name:"p2p-stardust"},{code:I7,name:"p2p-webrtc-star"},{code:P7,name:"p2p-webrtc-direct"},{code:D7,name:"webrtc-direct"},{code:R7,name:"webrtc"},{code:L7,name:"p2p-circuit"},{code:O7,name:"memory",size:Bn}];Y7.forEach(n=>{Uu.addProtocol(n)});function Z7(n){var r;const e=[];let t=0;for(;t<n.length;){const i=zt(n,t),s=Uu.getProtocol(i),o=Me(i),a=eW(s,n,t+o);let c=0;a>0&&s.size===Bn&&(c=Me(a));const l=o+c+a,u={code:i,name:s.name,bytes:n.subarray(t,t+l)};if(a>0){const d=t+o+c,f=n.subarray(d,d+a);u.value=((r=s.bytesToValue)==null?void 0:r.call(s,f))??ne(f)}e.push(u),t+=l}return e}function j7(n){var r;let e=0;const t=[];for(const i of n){if(i.bytes==null){const s=Uu.getProtocol(i.code),o=Me(i.code);let a,c=0,l=0;i.value!=null&&(a=((r=s.valueToBytes)==null?void 0:r.call(s,i.value))??ge(i.value),c=a.byteLength,s.size===Bn&&(l=Me(c)));const u=new Uint8Array(o+l+c);let d=0;Xt(i.code,u,d),d+=o,a!=null&&(s.size===Bn&&(Xt(c,u,d),d+=l),u.set(a,d)),i.bytes=u}t.push(i.bytes),e+=i.bytes.byteLength}return nt(t,e)}function J7(n){var s;if(n.charAt(0)!=="/")throw new ei('String multiaddr must start with "/"');const e=[];let t="protocol",r="",i="";for(let o=1;o<n.length;o++){const a=n.charAt(o);a!=="/"&&(t==="protocol"?i+=n.charAt(o):r+=n.charAt(o));const c=o===n.length-1;if(a==="/"||c){const l=Uu.getProtocol(i);if(t==="protocol"){if(l.size==null||l.size===0){e.push({code:l.code,name:l.name}),r="",i="",t="protocol";continue}else if(c)throw new ei(`Component ${i} was missing value`);t="value"}else if(t==="value"){const u={code:l.code,name:l.name};if(l.size!=null&&l.size!==0){if(r==="")throw new ei(`Component ${i} was missing value`);u.value=((s=l.stringToValue)==null?void 0:s.call(l,r))??r}e.push(u),r="",i="",t="protocol"}}}if(i!==""&&r!=="")throw new ei("Incomplete multiaddr");return e}function Q7(n){return`/${n.flatMap(e=>{var r;if(e.value==null)return e.name;const t=Uu.getProtocol(e.code);if(t==null)throw new ei(`Unknown protocol code ${e.code}`);return[e.name,((r=t.valueToString)==null?void 0:r.call(t,e.value))??e.value]}).join("/")}`}function eW(n,e,t){return n.size==null||n.size===0?0:n.size>0?n.size/8:zt(e,t)}const tW=Symbol.for("nodejs.util.inspect.custom"),XD=Symbol.for("@multiformats/multiaddr");function nW(n){if(n==null&&(n="/"),sW(n))return n.getComponents();if(n instanceof Uint8Array)return Z7(n);if(typeof n=="string")return n=n.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),n===""&&(n="/"),J7(n);if(Array.isArray(n))return n;throw new ei("Must be a string, Uint8Array, Component[], or another Multiaddr")}var tC,wi,El,Sl,Vs;let rW=(Vs=class{constructor(e="/",t={}){h(this,tC,!0);me(this,wi);me(this,El);me(this,Sl);pe(this,wi,nW(e)),t.validate!==!1&&iW(this)}get bytes(){return D(this,Sl)==null&&pe(this,Sl,j7(D(this,wi))),D(this,Sl)}toString(){return D(this,El)==null&&pe(this,El,Q7(D(this,wi))),D(this,El)}toJSON(){return this.toString()}getComponents(){return[...D(this,wi).map(e=>({...e}))]}encapsulate(e){const t=new Vs(e);return new Vs([...D(this,wi),...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),r=this.toString(),i=r.lastIndexOf(t);if(i<0)throw new KG(`Address ${this.toString()} does not contain subaddress: ${t}`);return new Vs(r.slice(0,i),{validate:!1})}decapsulateCode(e){let t;for(let r=D(this,wi).length-1;r>-1;r--)if(D(this,wi)[r].code===e){t=r;break}return new Vs(D(this,wi).slice(0,t),{validate:!1})}equals(e){return Ne(this.bytes,e.bytes)}[(tC=XD,tW)](){return`Multiaddr(${this.toString()})`}},wi=new WeakMap,El=new WeakMap,Sl=new WeakMap,Vs);function iW(n){n.getComponents().forEach(e=>{var r;const t=Uu.getProtocol(e.code);e.value!=null&&((r=t.validate)==null||r.call(t,e.value))})}function sW(n){return!!(n!=null&&n[XD])}function oW(n){return new rW(n)}const aW="libp2p-peer-record",cW=Uint8Array.from([3,1]);var Am;(function(n){(function(t){let r;t.codec=()=>(r==null&&(r=Nt((i,s,o={})=>{o.lengthDelimited!==!1&&s.fork(),i.multiaddr!=null&&i.multiaddr.byteLength>0&&(s.uint32(10),s.bytes(i.multiaddr)),o.lengthDelimited!==!1&&s.ldelim()},(i,s,o={})=>{const a={multiaddr:ht(0)},c=s==null?i.len:i.pos+s;for(;i.pos<c;){const l=i.uint32();switch(l>>>3){case 1:{a.multiaddr=i.bytes();break}default:{i.skipType(l&7);break}}}return a})),r),t.encode=i=>Ot(i,t.codec()),t.decode=(i,s)=>Lt(i,t.codec(),s)})(n.AddressInfo||(n.AddressInfo={}));let e;n.codec=()=>(e==null&&(e=Nt((t,r,i={})=>{if(i.lengthDelimited!==!1&&r.fork(),t.peerId!=null&&t.peerId.byteLength>0&&(r.uint32(10),r.bytes(t.peerId)),t.seq!=null&&t.seq!==0n&&(r.uint32(16),r.uint64(t.seq)),t.addresses!=null)for(const s of t.addresses)r.uint32(26),n.AddressInfo.codec().encode(s,r);i.lengthDelimited!==!1&&r.ldelim()},(t,r,i={})=>{var a,c;const s={peerId:ht(0),seq:0n,addresses:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const l=t.uint32();switch(l>>>3){case 1:{s.peerId=t.bytes();break}case 2:{s.seq=t.uint64();break}case 3:{if(((a=i.limits)==null?void 0:a.addresses)!=null&&s.addresses.length===i.limits.addresses)throw new ls('Decode error - map field "addresses" had too many elements');s.addresses.push(n.AddressInfo.codec().decode(t,t.uint32(),{limits:(c=i.limits)==null?void 0:c.addresses$}));break}default:{t.skipType(l&7);break}}}return s})),e),n.encode=t=>Ot(t,n.codec()),n.decode=(t,r)=>Lt(t,n.codec(),r)})(Am||(Am={}));function lW(n,e){const t=(r,i)=>r.toString().localeCompare(i.toString());return n.length!==e.length?!1:(e.sort(t),n.sort(t).every((r,i)=>e[i].equals(r)))}const Ds=class Ds{constructor(e){h(this,"peerId");h(this,"multiaddrs");h(this,"seqNumber");h(this,"domain",Ds.DOMAIN);h(this,"codec",Ds.CODEC);h(this,"marshaled");const{peerId:t,multiaddrs:r,seqNumber:i}=e;this.peerId=t,this.multiaddrs=r??[],this.seqNumber=i??BigInt(Date.now())}marshal(){return this.marshaled==null&&(this.marshaled=Am.encode({peerId:this.peerId.toMultihash().bytes,seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map(e=>({multiaddr:e.bytes}))})),this.marshaled}equals(e){return!(!(e instanceof Ds)||!this.peerId.equals(e.peerId)||this.seqNumber!==e.seqNumber||!lW(this.multiaddrs,e.multiaddrs))}};h(Ds,"createFromProtobuf",e=>{const t=Am.decode(e),r=GG(co(t.peerId)),i=(t.addresses??[]).map(o=>oW(o.multiaddr)),s=t.seq;return new Ds({peerId:r,multiaddrs:i,seqNumber:s})}),h(Ds,"DOMAIN",aW),h(Ds,"CODEC",cW);let js=Ds;function uW(n){return n[Symbol.asyncIterator]!=null}function Lv(n){if(uW(n))return(async()=>{const t=[];for await(const r of n)t.push(r);return t})();const e=[];for(const t of n)e.push(t);return e}var Yb;let du=(Yb=class extends Error{constructor(t="The operation was aborted",...r){super(t,...r);h(this,"name","AbortError")}},h(Yb,"name","AbortError"),Yb);async function h0(n,e,t,r){const i=new du(r==null?void 0:r.errorMessage);(r==null?void 0:r.errorCode)!=null&&(i.code=r.errorCode);const s=(r==null?void 0:r.errorEvent)??"error";return(t==null?void 0:t.aborted)===!0?Promise.reject(i):new Promise((o,a)=>{function c(){f0(t,"abort",d),f0(n,e,l),f0(n,s,u)}const l=f=>{var p;try{if(((p=r==null?void 0:r.filter)==null?void 0:p.call(r,f))===!1)return}catch(g){c(),a(g);return}c(),o(f)},u=f=>{if(c(),f instanceof Error){a(f);return}a(f.detail??(r==null?void 0:r.error)??new Error(`The "${r==null?void 0:r.errorEvent}" event was emitted but the event had no '.detail' field. Pass an 'error' option to race-event to change this message.`))},d=()=>{c(),a(i)};d0(t,"abort",d),d0(n,e,l),d0(n,s,u)})}function d0(n,e,t){n!=null&&(YD(n)?n.addEventListener(e,t):n.addListener(e,t))}function f0(n,e,t){n!=null&&(YD(n)?n.removeEventListener(e,t):n.removeListener(e,t))}function YD(n){return typeof n.addEventListener=="function"&&typeof n.removeEventListener=="function"}class ZD extends Error{constructor(e="The queue was full"){super(e),this.name="QueueFullError"}}h(ZD,"name","QueueFullError");let IT=class extends Error{constructor(t,r,i){super(t??"The operation was aborted");h(this,"type");h(this,"code");this.type="aborted",this.name=i??"AbortError",this.code=r??"ABORT_ERR"}};async function hW(n,e,t){if(e==null)return n;if(e.aborted)return n.catch(()=>{}),Promise.reject(new IT(t==null?void 0:t.errorMessage,t==null?void 0:t.errorCode,t==null?void 0:t.errorName));let r;const i=new IT(t==null?void 0:t.errorMessage,t==null?void 0:t.errorCode,t==null?void 0:t.errorName);try{return await Promise.race([n,new Promise((s,o)=>{r=()=>{o(i)},e.addEventListener("abort",r)})])}finally{r!=null&&e.removeEventListener("abort",r)}}class dW{constructor(e){h(this,"deferred");h(this,"signal");var t;this.signal=e,this.deferred=Promise.withResolvers(),this.onAbort=this.onAbort.bind(this),(t=this.signal)==null||t.addEventListener("abort",this.onAbort)}onAbort(){var e;this.deferred.reject(((e=this.signal)==null?void 0:e.reason)??new du)}cleanup(){var e;(e=this.signal)==null||e.removeEventListener("abort",this.onAbort)}}function fW(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}class pW{constructor(e,t){h(this,"id");h(this,"fn");h(this,"options");h(this,"recipients");h(this,"status");h(this,"timeline");h(this,"controller");this.id=fW(),this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((t,r)=>{var i;return t&&((i=r.signal)==null?void 0:i.aborted)===!0},!0)&&(this.controller.abort(new du),this.cleanup())}async join(e={}){var r;const t=new dW(e.signal);return this.recipients.push(t),(r=e.signal)==null||r.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await hW(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{var t;e.cleanup(),(t=e.signal)==null||t.removeEventListener("abort",this.onAbort)})}}function PT(n,e){let t;const r=function(){const i=function(){t=void 0,n()};clearTimeout(t),t=setTimeout(i,e)};return r.start=()=>{},r.stop=()=>{clearTimeout(t)},r}class DT extends fr{constructor(t={}){super();h(this,"concurrency");h(this,"maxSize");h(this,"queue");h(this,"pending");h(this,"sort");h(this,"autoStart");this.concurrency=t.concurrency??Number.POSITIVE_INFINITY,this.maxSize=t.maxSize??Number.POSITIVE_INFINITY,this.pending=0,this.autoStart=t.autoStart??!0,this.sort=t.sort,this.queue=[],this.emitEmpty=PT(this.emitEmpty.bind(this),1),this.emitIdle=PT(this.emitIdle.bind(this),1)}[Symbol.asyncIterator](){return this.toGenerator()}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let t;for(const r of this.queue)if(r.status==="queued"){t=r;break}return t==null?!1:(this.safeDispatchEvent("active"),this.pending++,t.run().finally(()=>{for(let r=0;r<this.queue.length;r++)if(this.queue[r]===t){this.queue.splice(r,1);break}this.pending--,this.safeDispatchEvent("next"),this.autoStart&&this.tryToStartAnother()}),!0)}return!1}enqueue(t){this.queue.push(t),this.sort!=null&&this.queue.sort(this.sort)}start(){this.autoStart===!1&&(this.autoStart=!0,this.tryToStartAnother())}pause(){this.autoStart=!1}async add(t,r){var s;if((s=r==null?void 0:r.signal)==null||s.throwIfAborted(),this.size===this.maxSize)throw new ZD;const i=new pW(t,r);return this.enqueue(i),this.safeDispatchEvent("add"),this.autoStart&&this.tryToStartAnother(),i.join(r).then(o=>(this.safeDispatchEvent("success",{detail:{job:i,result:o}}),o)).catch(o=>{if(i.status==="queued"){for(let a=0;a<this.queue.length;a++)if(this.queue[a]===i){this.queue.splice(a,1);break}}throw this.safeDispatchEvent("failure",{detail:{job:i,error:o}}),o})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(t=>{t.abort(new du)}),this.clear()}async onEmpty(t){this.size!==0&&await h0(this,"empty",t==null?void 0:t.signal)}async onSizeLessThan(t,r){this.size<t||await h0(this,"next",r==null?void 0:r.signal,{filter:()=>this.size<t})}async onIdle(t){this.pending===0&&this.size===0||await h0(this,"idle",t==null?void 0:t.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(t){var l,u,d;(l=t==null?void 0:t.signal)==null||l.throwIfAborted();const r=Ug({objectMode:!0}),i=f=>{f!=null?this.abort():this.clear(),r.end(f)},s=f=>{f.detail!=null&&r.push(f.detail.result)},o=f=>{i(f.detail.error)},a=()=>{i()},c=()=>{i(new du("Queue aborted"))};this.addEventListener("success",s),this.addEventListener("failure",o),this.addEventListener("idle",a),(u=t==null?void 0:t.signal)==null||u.addEventListener("abort",c);try{yield*r}finally{this.removeEventListener("success",s),this.removeEventListener("failure",o),this.removeEventListener("idle",a),(d=t==null?void 0:t.signal)==null||d.removeEventListener("abort",c),i()}}}const jD="lock:worker:request-read",JD="lock:worker:abort-read-request",QD="lock:worker:release-read",eR="lock:master:grant-read",tR="lock:master:error-read",nR="lock:worker:request-write",rR="lock:worker:abort-write-request",iR="lock:worker:release-write",sR="lock:master:grant-write",oR="lock:master:error-write",aR="lock:worker:finalize",cR="mortice",mW={singleProcess:!1},RT=(n,e,t,r,i,s,o,a,c)=>l=>{if(l.data==null)return;const u={type:l.data.type,name:l.data.name,identifier:l.data.identifier};u.type===i&&n.safeDispatchEvent(t,{detail:{name:u.name,identifier:u.identifier,handler:async()=>{e.postMessage({type:c,name:u.name,identifier:u.identifier}),await new Promise(d=>{const f=p=>{if((p==null?void 0:p.data)==null)return;const g={type:p.data.type,name:p.data.name,identifier:p.data.identifier};g.type===a&&g.identifier===u.identifier&&(e.removeEventListener("message",f),d())};e.addEventListener("message",f)})},onError:d=>{e.postMessage({type:o,name:u.name,identifier:u.identifier,error:{message:d.message,name:d.name,stack:d.stack}})}}}),u.type===s&&n.safeDispatchEvent(r,{detail:{name:u.name,identifier:u.identifier}}),u.type===aR&&n.safeDispatchEvent("finalizeRequest",{detail:{name:u.name}})},gW=(n=10)=>Math.random().toString().substring(2,n+2);class yW{constructor(e){h(this,"name");h(this,"channel");this.name=e,this.channel=new BroadcastChannel(cR)}readLock(e){return this.sendRequest(jD,JD,eR,tR,QD,e)}writeLock(e){return this.sendRequest(nR,rR,sR,oR,iR,e)}finalize(){this.channel.postMessage({type:aR,name:this.name}),this.channel.close()}async sendRequest(e,t,r,i,s,o){var c;(c=o==null?void 0:o.signal)==null||c.throwIfAborted();const a=gW();return this.channel.postMessage({type:e,identifier:a,name:this.name}),new Promise((l,u)=>{var p;const d=()=>{this.channel.postMessage({type:t,identifier:a,name:this.name})};(p=o==null?void 0:o.signal)==null||p.addEventListener("abort",d,{once:!0});const f=g=>{var b,m,y,E;if(((b=g.data)==null?void 0:b.identifier)===a&&(((m=g.data)==null?void 0:m.type)===r&&(this.channel.removeEventListener("message",f),(y=o==null?void 0:o.signal)==null||y.removeEventListener("abort",d),l(()=>{this.channel.postMessage({type:s,identifier:a,name:this.name})})),g.data.type===i)){this.channel.removeEventListener("message",f),(E=o==null?void 0:o.signal)==null||E.removeEventListener("abort",d);const w=new Error;g.data.error!=null&&(w.message=g.data.error.message,w.name=g.data.error.name,w.stack=g.data.error.stack),u(w)}};this.channel.addEventListener("message",f)})}}const bW=n=>{if(n=Object.assign({},mW,n),!!globalThis.document||n.singleProcess){const t=new BroadcastChannel(cR),r=new fr;return t.addEventListener("message",RT(r,t,"requestReadLock","abortReadLockRequest",jD,JD,tR,QD,eR)),t.addEventListener("message",RT(r,t,"requestWriteLock","abortWriteLockRequest",nR,rR,oR,iR,sR)),r}return new yW(n.name)},Aa=new Map;let lh;function lR(n){return typeof(n==null?void 0:n.readLock)=="function"&&typeof(n==null?void 0:n.writeLock)=="function"}function wW(n){if(lh==null&&(lh=bW(n),!lR(lh))){const e=lh;e.addEventListener("requestReadLock",t=>{const r=t.detail.name,i=t.detail.identifier,s=Aa.get(r);if(s==null)return;const o=new AbortController,a=c=>{c.detail.name!==r||c.detail.identifier!==i||o.abort()};e.addEventListener("abortReadLockRequest",a),s.readLock({signal:o.signal}).then(async c=>{await t.detail.handler().finally(()=>{c()})}).catch(c=>{t.detail.onError(c)}).finally(()=>{e.removeEventListener("abortReadLockRequest",a)})}),e.addEventListener("requestWriteLock",t=>{const r=t.detail.name,i=t.detail.identifier,s=Aa.get(r);if(s==null)return;const o=new AbortController,a=c=>{c.detail.name!==r||c.detail.identifier!==i||o.abort()};e.addEventListener("abortWriteLockRequest",a),s.writeLock({signal:o.signal}).then(async c=>{await t.detail.handler().finally(()=>{c()})}).catch(c=>{t.detail.onError(c)}).finally(()=>{e.removeEventListener("abortWriteLockRequest",a)})}),e.addEventListener("finalizeRequest",t=>{const r=t.detail.name,i=Aa.get(r);i!=null&&i.finalize()})}return lh}async function p0(n,e){var o;let t,r;const i=new Promise((a,c)=>{t=a,r=c}),s=()=>{r(new du)};return(o=e==null?void 0:e.signal)==null||o.addEventListener("abort",s,{once:!0}),n.add(async()=>{await new Promise(a=>{t(()=>{var c;(c=e==null?void 0:e.signal)==null||c.removeEventListener("abort",s),a()})})},{signal:e==null?void 0:e.signal}).catch(a=>{r(a)}),i}const vW=(n,e)=>{let t=Aa.get(n);if(t!=null)return t;const r=wW(e);if(lR(r))return t=r,Aa.set(n,t),t;const i=new DT({concurrency:1});let s;return t={async readLock(o){if(s!=null)return p0(s,o);s=new DT({concurrency:e.concurrency,autoStart:!1});const a=s,c=p0(s,o);return i.add(async()=>{a.start(),await a.onIdle().then(()=>{s===a&&(s=null)})}),c},async writeLock(o){return s=null,p0(i,o)},finalize:()=>{Aa.delete(n)},queue:i},Aa.set(n,t),e.autoFinalize===!0&&i.addEventListener("idle",()=>{t.finalize()},{once:!0}),t},_W={name:"lock",concurrency:1/0,singleProcess:!1,autoFinalize:!1};function EW(n){const e=Object.assign({},_W,n);return vW(e.name,e)}const SW=36e5,xW=216e5;var Ma;(function(n){(function(t){let r;t.codec=()=>(r==null&&(r=Nt((i,s,o={})=>{o.lengthDelimited!==!1&&s.fork(),i.key!=null&&i.key!==""&&(s.uint32(10),s.string(i.key)),i.value!=null&&i.value.byteLength>0&&(s.uint32(18),s.bytes(i.value)),o.lengthDelimited!==!1&&s.ldelim()},(i,s,o={})=>{const a={key:"",value:ht(0)},c=s==null?i.len:i.pos+s;for(;i.pos<c;){const l=i.uint32();switch(l>>>3){case 1:{a.key=i.string();break}case 2:{a.value=i.bytes();break}default:{i.skipType(l&7);break}}}return a})),r),t.encode=i=>Ot(i,t.codec()),t.decode=(i,s)=>Lt(i,t.codec(),s)})(n.Peer$metadataEntry||(n.Peer$metadataEntry={})),(function(t){let r;t.codec=()=>(r==null&&(r=Nt((i,s,o={})=>{o.lengthDelimited!==!1&&s.fork(),i.key!=null&&i.key!==""&&(s.uint32(10),s.string(i.key)),i.value!=null&&(s.uint32(18),Cm.codec().encode(i.value,s)),o.lengthDelimited!==!1&&s.ldelim()},(i,s,o={})=>{var l;const a={key:""},c=s==null?i.len:i.pos+s;for(;i.pos<c;){const u=i.uint32();switch(u>>>3){case 1:{a.key=i.string();break}case 2:{a.value=Cm.codec().decode(i,i.uint32(),{limits:(l=o.limits)==null?void 0:l.value});break}default:{i.skipType(u&7);break}}}return a})),r),t.encode=i=>Ot(i,t.codec()),t.decode=(i,s)=>Lt(i,t.codec(),s)})(n.Peer$tagsEntry||(n.Peer$tagsEntry={}));let e;n.codec=()=>(e==null&&(e=Nt((t,r,i={})=>{if(i.lengthDelimited!==!1&&r.fork(),t.addresses!=null)for(const s of t.addresses)r.uint32(10),Mm.codec().encode(s,r);if(t.protocols!=null)for(const s of t.protocols)r.uint32(18),r.string(s);if(t.publicKey!=null&&(r.uint32(34),r.bytes(t.publicKey)),t.peerRecordEnvelope!=null&&(r.uint32(42),r.bytes(t.peerRecordEnvelope)),t.metadata!=null&&t.metadata.size!==0)for(const[s,o]of t.metadata.entries())r.uint32(50),n.Peer$metadataEntry.codec().encode({key:s,value:o},r);if(t.tags!=null&&t.tags.size!==0)for(const[s,o]of t.tags.entries())r.uint32(58),n.Peer$tagsEntry.codec().encode({key:s,value:o},r);t.updated!=null&&(r.uint32(64),r.uint64Number(t.updated)),i.lengthDelimited!==!1&&r.ldelim()},(t,r,i={})=>{var a,c,l,u,d,f;const s={addresses:[],protocols:[],metadata:new Map,tags:new Map},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const p=t.uint32();switch(p>>>3){case 1:{if(((a=i.limits)==null?void 0:a.addresses)!=null&&s.addresses.length===i.limits.addresses)throw new ls('Decode error - map field "addresses" had too many elements');s.addresses.push(Mm.codec().decode(t,t.uint32(),{limits:(c=i.limits)==null?void 0:c.addresses$}));break}case 2:{if(((l=i.limits)==null?void 0:l.protocols)!=null&&s.protocols.length===i.limits.protocols)throw new ls('Decode error - map field "protocols" had too many elements');s.protocols.push(t.string());break}case 4:{s.publicKey=t.bytes();break}case 5:{s.peerRecordEnvelope=t.bytes();break}case 6:{if(((u=i.limits)==null?void 0:u.metadata)!=null&&s.metadata.size===i.limits.metadata)throw new sT('Decode error - map field "metadata" had too many elements');const g=n.Peer$metadataEntry.codec().decode(t,t.uint32());s.metadata.set(g.key,g.value);break}case 7:{if(((d=i.limits)==null?void 0:d.tags)!=null&&s.tags.size===i.limits.tags)throw new sT('Decode error - map field "tags" had too many elements');const g=n.Peer$tagsEntry.codec().decode(t,t.uint32(),{limits:{value:(f=i.limits)==null?void 0:f.tags$value}});s.tags.set(g.key,g.value);break}case 8:{s.updated=t.uint64Number();break}default:{t.skipType(p&7);break}}}return s})),e),n.encode=t=>Ot(t,n.codec()),n.decode=(t,r)=>Lt(t,n.codec(),r)})(Ma||(Ma={}));var Mm;(function(n){let e;n.codec=()=>(e==null&&(e=Nt((t,r,i={})=>{i.lengthDelimited!==!1&&r.fork(),t.multiaddr!=null&&t.multiaddr.byteLength>0&&(r.uint32(10),r.bytes(t.multiaddr)),t.isCertified!=null&&(r.uint32(16),r.bool(t.isCertified)),t.observed!=null&&(r.uint32(24),r.uint64Number(t.observed)),i.lengthDelimited!==!1&&r.ldelim()},(t,r,i={})=>{const s={multiaddr:ht(0)},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.multiaddr=t.bytes();break}case 2:{s.isCertified=t.bool();break}case 3:{s.observed=t.uint64Number();break}default:{t.skipType(a&7);break}}}return s})),e),n.encode=t=>Ot(t,n.codec()),n.decode=(t,r)=>Lt(t,n.codec(),r)})(Mm||(Mm={}));var Cm;(function(n){let e;n.codec=()=>(e==null&&(e=Nt((t,r,i={})=>{i.lengthDelimited!==!1&&r.fork(),t.value!=null&&t.value!==0&&(r.uint32(8),r.uint32(t.value)),t.expiry!=null&&(r.uint32(16),r.uint64(t.expiry)),i.lengthDelimited!==!1&&r.ldelim()},(t,r,i={})=>{const s={value:0},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.value=t.uint32();break}case 2:{s.expiry=t.uint64();break}default:{t.skipType(a&7);break}}}return s})),e),n.encode=t=>Ot(t,n.codec()),n.decode=(t,r)=>Lt(t,n.codec(),r)})(Cm||(Cm={}));var Zb;let ti=(Zb=class extends Error{constructor(){super(...arguments);h(this,"name","InvalidMultiaddrError")}},h(Zb,"name","InvalidMultiaddrError"),Zb);var jb;let pd=(jb=class extends Error{constructor(){super(...arguments);h(this,"name","ValidationError")}},h(jb,"name","ValidationError"),jb);var Jb;let TW=(Jb=class extends Error{constructor(){super(...arguments);h(this,"name","InvalidParametersError")}},h(Jb,"name","InvalidParametersError"),Jb);var Qb;let AW=(Qb=class extends Error{constructor(){super(...arguments);h(this,"name","UnknownProtocolError")}},h(Qb,"name","UnknownProtocolError"),Qb);const MW=4,CW=6,IW=273,PW=33,DW=41,RW=42,LW=43,OW=53,NW=54,UW=55,BW=56,kW=132,$W=301,FW=302,zW=400,uR=421,VW=444,HW=445,GW=446,WW=447,qW=448,KW=449,XW=454,YW=460,ZW=461,jW=465,JW=466,QW=480,eq=481,tq=443,nq=477,rq=478,iq=479,sq=277,oq=275,aq=276,cq=280,lq=281,uq=290,hq=777;function LT(n){return e=>ne(e,n)}function OT(n){return e=>ge(e,n)}function bh(n){return new DataView(n.buffer).getUint16(n.byteOffset).toString()}function Yc(n){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof n=="string"?parseInt(n):n),new Uint8Array(e)}function dq(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=ge(e[0],"base32"),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const i=Yc(r);return nt([t,i],t.length+i.length)}function fq(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=yn.decode(`b${e[0]}`),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const i=Yc(r);return nt([t,i],t.length+i.length)}function NT(n){const e=n.subarray(0,n.length-2),t=n.subarray(n.length-2),r=ne(e,"base32"),i=bh(t);return`${r}:${i}`}const hR=function(n){n=n.toString().trim();const e=new Uint8Array(4);return n.split(/\./g).forEach((t,r)=>{const i=parseInt(t,10);if(isNaN(i)||i<0||i>255)throw new ti("Invalid byte value in IP address");e[r]=i}),e},pq=function(n){let e=0;n=n.toString().trim();const t=n.split(":",8);let r;for(r=0;r<t.length;r++){const s=Pt(t[r]);let o;s&&(o=hR(t[r]),t[r]=ne(o.subarray(0,2),"base16")),o!=null&&++r<8&&t.splice(r,0,ne(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(r=0;r<t.length&&t[r]!=="";r++);const s=[r,1];for(r=9-t.length;r>0;r--)s.push("0");t.splice.apply(t,s)}const i=new Uint8Array(e+16);for(r=0;r<t.length;r++){t[r]===""&&(t[r]="0");const s=parseInt(t[r],16);if(isNaN(s)||s<0||s>65535)throw new ti("Invalid byte value in IP address");i[e++]=s>>8&255,i[e++]=s&255}return i},mq=function(n){if(n.byteLength!==4)throw new ti("IPv4 address was incorrect length");const e=[];for(let t=0;t<n.byteLength;t++)e.push(n[t]);return e.join(".")},gq=function(n){if(n.byteLength!==16)throw new ti("IPv6 address was incorrect length");const e=[];for(let r=0;r<n.byteLength;r+=2){const i=n[r],s=n[r+1],o=`${i.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const r=new URL(`http://[${t}]`);return r.hostname.substring(1,r.hostname.length-1)}catch{throw new ti(`Invalid IPv6 address "${t}"`)}};function yq(n){try{const e=new URL(`http://[${n}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new ti(`Invalid IPv6 address "${n}"`)}}const m0=Object.values(Fr).map(n=>n.decoder),bq=(function(){let n=m0[0].or(m0[1]);return m0.slice(2).forEach(e=>n=n.or(e)),n})();function wq(n){return bq.decode(n)}function vq(n){return e=>n.encoder.encode(e)}function _q(n){if(parseInt(n).toString()!==n)throw new pd("Value must be an integer")}function Eq(n){if(n<0)throw new pd("Value must be a positive integer, or zero")}function Sq(n){return e=>{if(e>n)throw new pd(`Value must be smaller than or equal to ${n}`)}}function xq(...n){return e=>{for(const t of n)t(e)}}const ep=xq(_q,Eq,Sq(65535)),kn=-1;let Tq=class{constructor(){h(this,"protocolsByCode",new Map);h(this,"protocolsByName",new Map)}getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new AW(`Protocol ${e} was unknown`);return t}addProtocol(e){var t;this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),(t=e.aliases)==null||t.forEach(r=>{this.protocolsByName.set(r,e)})}removeProtocol(e){var r;const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),(r=t.aliases)==null||r.forEach(i=>{this.protocolsByName.delete(i)}))}};const Bu=new Tq,Aq=[{code:MW,name:"ip4",size:32,valueToBytes:hR,bytesToValue:mq,validate:n=>{if(!Pt(n))throw new pd(`Invalid IPv4 address "${n}"`)}},{code:CW,name:"tcp",size:16,valueToBytes:Yc,bytesToValue:bh,validate:ep},{code:IW,name:"udp",size:16,valueToBytes:Yc,bytesToValue:bh,validate:ep},{code:PW,name:"dccp",size:16,valueToBytes:Yc,bytesToValue:bh,validate:ep},{code:DW,name:"ip6",size:128,valueToBytes:pq,bytesToValue:gq,stringToValue:yq,validate:n=>{if(!hi(n))throw new pd(`Invalid IPv6 address "${n}"`)}},{code:RW,name:"ip6zone",size:kn},{code:LW,name:"ipcidr",size:8,bytesToValue:LT("base10"),valueToBytes:OT("base10")},{code:OW,name:"dns",size:kn},{code:NW,name:"dns4",size:kn},{code:UW,name:"dns6",size:kn},{code:BW,name:"dnsaddr",size:kn},{code:kW,name:"sctp",size:16,valueToBytes:Yc,bytesToValue:bh,validate:ep},{code:$W,name:"udt"},{code:FW,name:"utp"},{code:zW,name:"unix",size:kn,stringToValue:n=>decodeURIComponent(n),valueToString:n=>encodeURIComponent(n)},{code:uR,name:"p2p",aliases:["ipfs"],size:kn,bytesToValue:LT("base58btc"),valueToBytes:n=>n.startsWith("Q")||n.startsWith("1")?OT("base58btc")(n):ze.parse(n).multihash.bytes},{code:VW,name:"onion",size:96,bytesToValue:NT,valueToBytes:dq},{code:HW,name:"onion3",size:296,bytesToValue:NT,valueToBytes:fq},{code:GW,name:"garlic64",size:kn},{code:WW,name:"garlic32",size:kn},{code:qW,name:"tls"},{code:KW,name:"sni",size:kn},{code:XW,name:"noise"},{code:YW,name:"quic"},{code:ZW,name:"quic-v1"},{code:jW,name:"webtransport"},{code:JW,name:"certhash",size:kn,bytesToValue:vq(ui),valueToBytes:wq},{code:QW,name:"http"},{code:eq,name:"http-path",size:kn,stringToValue:n=>`/${decodeURIComponent(n)}`,valueToString:n=>encodeURIComponent(n.substring(1))},{code:tq,name:"https"},{code:nq,name:"ws"},{code:rq,name:"wss"},{code:iq,name:"p2p-websocket-star"},{code:sq,name:"p2p-stardust"},{code:oq,name:"p2p-webrtc-star"},{code:aq,name:"p2p-webrtc-direct"},{code:cq,name:"webrtc-direct"},{code:lq,name:"webrtc"},{code:uq,name:"p2p-circuit"},{code:hq,name:"memory",size:kn}];Aq.forEach(n=>{Bu.addProtocol(n)});function Mq(n){var r;const e=[];let t=0;for(;t<n.length;){const i=zt(n,t),s=Bu.getProtocol(i),o=Me(i),a=Dq(s,n,t+o);let c=0;a>0&&s.size===kn&&(c=Me(a));const l=o+c+a,u={code:i,name:s.name,bytes:n.subarray(t,t+l)};if(a>0){const d=t+o+c,f=n.subarray(d,d+a);u.value=((r=s.bytesToValue)==null?void 0:r.call(s,f))??ne(f)}e.push(u),t+=l}return e}function Cq(n){var r;let e=0;const t=[];for(const i of n){if(i.bytes==null){const s=Bu.getProtocol(i.code),o=Me(i.code);let a,c=0,l=0;i.value!=null&&(a=((r=s.valueToBytes)==null?void 0:r.call(s,i.value))??ge(i.value),c=a.byteLength,s.size===kn&&(l=Me(c)));const u=new Uint8Array(o+l+c);let d=0;Xt(i.code,u,d),d+=o,a!=null&&(s.size===kn&&(Xt(c,u,d),d+=l),u.set(a,d)),i.bytes=u}t.push(i.bytes),e+=i.bytes.byteLength}return nt(t,e)}function Iq(n){var s;if(n.charAt(0)!=="/")throw new ti('String multiaddr must start with "/"');const e=[];let t="protocol",r="",i="";for(let o=1;o<n.length;o++){const a=n.charAt(o);a!=="/"&&(t==="protocol"?i+=n.charAt(o):r+=n.charAt(o));const c=o===n.length-1;if(a==="/"||c){const l=Bu.getProtocol(i);if(t==="protocol"){if(l.size==null||l.size===0){e.push({code:l.code,name:l.name}),r="",i="",t="protocol";continue}else if(c)throw new ti(`Component ${i} was missing value`);t="value"}else if(t==="value"){const u={code:l.code,name:l.name};if(l.size!=null&&l.size!==0){if(r==="")throw new ti(`Component ${i} was missing value`);u.value=((s=l.stringToValue)==null?void 0:s.call(l,r))??r}e.push(u),r="",i="",t="protocol"}}}if(i!==""&&r!=="")throw new ti("Incomplete multiaddr");return e}function Pq(n){return`/${n.flatMap(e=>{var r;if(e.value==null)return e.name;const t=Bu.getProtocol(e.code);if(t==null)throw new ti(`Unknown protocol code ${e.code}`);return[e.name,((r=t.valueToString)==null?void 0:r.call(t,e.value))??e.value]}).join("/")}`}function Dq(n,e,t){return n.size==null||n.size===0?0:n.size>0?n.size/8:zt(e,t)}const Rq=Symbol.for("nodejs.util.inspect.custom"),dR=Symbol.for("@multiformats/multiaddr");function Lq(n){if(n==null&&(n="/"),fR(n))return n.getComponents();if(n instanceof Uint8Array)return Mq(n);if(typeof n=="string")return n=n.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),n===""&&(n="/"),Iq(n);if(Array.isArray(n))return n;throw new ti("Must be a string, Uint8Array, Component[], or another Multiaddr")}var nC,vi,xl,Tl,Hs;let Oq=(Hs=class{constructor(e="/",t={}){h(this,nC,!0);me(this,vi);me(this,xl);me(this,Tl);pe(this,vi,Lq(e)),t.validate!==!1&&Nq(this)}get bytes(){return D(this,Tl)==null&&pe(this,Tl,Cq(D(this,vi))),D(this,Tl)}toString(){return D(this,xl)==null&&pe(this,xl,Pq(D(this,vi))),D(this,xl)}toJSON(){return this.toString()}getComponents(){return[...D(this,vi).map(e=>({...e}))]}encapsulate(e){const t=new Hs(e);return new Hs([...D(this,vi),...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),r=this.toString(),i=r.lastIndexOf(t);if(i<0)throw new TW(`Address ${this.toString()} does not contain subaddress: ${t}`);return new Hs(r.slice(0,i),{validate:!1})}decapsulateCode(e){let t;for(let r=D(this,vi).length-1;r>-1;r--)if(D(this,vi)[r].code===e){t=r;break}return new Hs(D(this,vi).slice(0,t),{validate:!1})}equals(e){return Ne(this.bytes,e.bytes)}[(nC=dR,Rq)](){return`Multiaddr(${this.toString()})`}},vi=new WeakMap,xl=new WeakMap,Tl=new WeakMap,Hs);function Nq(n){n.getComponents().forEach(e=>{var r;const t=Bu.getProtocol(e.code);e.value!=null&&((r=t.validate)==null||r.call(t,e.value))})}function fR(n){return!!(n!=null&&n[dR])}function Ov(n){return new Oq(n)}function Uq(n,e){if(n.publicKey!=null||e.publicKey==null)return n;let t;n.type==="RSA"&&(t=n.toMultihash());const r=no(e.publicKey,t);return RG(r)}function Bq(n,e,t){const r=Ma.decode(e);return wh(n,r,t)}function wh(n,e,t){const r=new Map,i=BigInt(Date.now());for(const[s,o]of e.tags.entries())o.expiry!=null&&o.expiry<i||r.set(s,o);return{...e,id:Uq(n,e),addresses:e.addresses.filter(({observed:s})=>s!=null&&s>Date.now()-t).map(({multiaddr:s,isCertified:o})=>({multiaddr:Ov(s),isCertified:o??!1})),metadata:e.metadata,peerRecordEnvelope:e.peerRecordEnvelope??void 0,tags:r}}function kq(n,e){return $q(n.addresses,e.addresses)&&Fq(n.protocols,e.protocols)&&zq(n.publicKey,e.publicKey)&&Vq(n.peerRecordEnvelope,e.peerRecordEnvelope)&&Hq(n.metadata,e.metadata)&&Gq(n.tags,e.tags)}function $q(n,e){return mR(n,e,(t,r)=>!(t.isCertified!==r.isCertified||!Ne(t.multiaddr,r.multiaddr)))}function Fq(n,e){return mR(n,e,(t,r)=>t===r)}function zq(n,e){return pR(n,e)}function Vq(n,e){return pR(n,e)}function Hq(n,e){return gR(n,e,(t,r)=>Ne(t,r))}function Gq(n,e){return gR(n,e,(t,r)=>t.value===r.value&&t.expiry===r.expiry)}function pR(n,e){return n==null&&e==null?!0:n!=null&&e!=null?Ne(n,e):!1}function mR(n,e,t){if(n.length!==e.length)return!1;for(let r=0;r<n.length;r++)if(!t(n[r],e[r]))return!1;return!0}function gR(n,e,t){if(n.size!==e.size)return!1;for(const[r,i]of n.entries()){const s=e.get(r);if(s==null||!t(i,s))return!1}return!0}const Ms="/",yR=new TextEncoder().encode(Ms),tp=yR[0];class or{constructor(e,t){h(this,"_buf");if(typeof e=="string")this._buf=ge(e);else if(e instanceof Uint8Array)this._buf=e;else throw new Error("Invalid key, should be String of Uint8Array");if(t==null&&(t=!0),t&&this.clean(),this._buf.byteLength===0||this._buf[0]!==tp)throw new Error("Invalid key")}toString(e="utf8"){return ne(this._buf,e)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(e){return new or(e.join(Ms))}static random(){return new or(Math.random().toString().substring(2))}static asKey(e){return e instanceof Uint8Array||typeof e=="string"?new or(e):typeof e.uint8Array=="function"?new or(e.uint8Array()):null}clean(){if((this._buf==null||this._buf.byteLength===0)&&(this._buf=yR),this._buf[0]!==tp){const e=new Uint8Array(this._buf.byteLength+1);e.fill(tp,0,1),e.set(this._buf,1),this._buf=e}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===tp;)this._buf=this._buf.subarray(0,-1)}less(e){const t=this.list(),r=e.list();for(let i=0;i<t.length;i++){if(r.length<i+1)return!1;const s=t[i],o=r[i];if(s<o)return!0;if(s>o)return!1}return t.length<r.length}reverse(){return or.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(Ms).slice(1)}type(){return Wq(this.baseNamespace())}name(){return qq(this.baseNamespace())}instance(e){return new or(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(Ms)||(e+=Ms),e+=this.type(),new or(e)}parent(){const e=this.list();return e.length===1?new or(Ms):new or(e.slice(0,-1).join(Ms))}child(e){return this.toString()===Ms?e:e.toString()===Ms?this:new or(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()===this.toString()?!1:e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()===this.toString()?!1:this.toString().startsWith(e.toString())}isTopLevel(){return this.list().length===1}concat(...e){return or.withNamespaces([...this.namespaces(),...Kq(e.map(t=>t.namespaces()))])}}function Wq(n){const e=n.split(":");return e.length<2?"":e.slice(0,-1).join(":")}function qq(n){const e=n.split(":");return e[e.length-1]}function Kq(n){return[].concat(...n)}const bR="/peers/";function np(n){if(!Up(n)||n.type==null)throw new Zr("Invalid PeerId");const e=n.toCID().toString();return new or(`${bR}${e}`)}async function Xq(n,e,t,r,i){const s=new Map;for(const o of t){if(o==null)continue;if(o.multiaddr instanceof Uint8Array&&(o.multiaddr=Ov(o.multiaddr)),!fR(o.multiaddr))throw new Zr("Multiaddr was invalid");if(!await e(n,o.multiaddr,i))continue;const a=o.isCertified??!1,c=o.multiaddr.toString(),l=s.get(c);l!=null?o.isCertified=l.isCertified||a:s.set(c,{multiaddr:o.multiaddr,isCertified:a})}return[...s.values()].sort((o,a)=>o.multiaddr.toString().localeCompare(a.multiaddr.toString())).map(({isCertified:o,multiaddr:a})=>{var l;const c=(l=a.getComponents().find(u=>u.code===uR))==null?void 0:l.value;return n.equals(c)&&(a=a.decapsulate(Ov(`/p2p/${n}`))),{isCertified:o,multiaddr:a.bytes}})}async function g0(n,e,t,r){var f,p;if(e==null)throw new Zr("Invalid PeerData");if(e.publicKey!=null&&n.publicKey!=null&&!e.publicKey.equals(n.publicKey))throw new Zr("publicKey bytes do not match peer id publicKey bytes");const i=(f=r.existingPeer)==null?void 0:f.peer;if(i!=null&&!n.equals(i.id))throw new Zr("peer id did not match existing peer id");let s=(i==null?void 0:i.addresses)??[],o=new Set((i==null?void 0:i.protocols)??[]),a=(i==null?void 0:i.metadata)??new Map,c=(i==null?void 0:i.tags)??new Map,l=i==null?void 0:i.peerRecordEnvelope;if(t==="patch"){if((e.multiaddrs!=null||e.addresses!=null)&&(s=[],e.multiaddrs!=null&&s.push(...e.multiaddrs.map(g=>({isCertified:!1,multiaddr:g}))),e.addresses!=null&&s.push(...e.addresses)),e.protocols!=null&&(o=new Set(e.protocols)),e.metadata!=null){const g=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);a=rp(g,{validate:UT})}if(e.tags!=null){const g=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags);c=rp(g,{validate:BT,map:kT})}e.peerRecordEnvelope!=null&&(l=e.peerRecordEnvelope)}if(t==="merge"){if(e.multiaddrs!=null&&s.push(...e.multiaddrs.map(g=>({isCertified:!1,multiaddr:g}))),e.addresses!=null&&s.push(...e.addresses),e.protocols!=null&&(o=new Set([...o,...e.protocols])),e.metadata!=null){const g=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);for(const[b,m]of g)m==null?a.delete(b):a.set(b,m);a=rp([...a.entries()],{validate:UT})}if(e.tags!=null){const g=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags),b=new Map(c);for(const[m,y]of g)y==null?b.delete(m):b.set(m,y);c=rp([...b.entries()],{validate:BT,map:kT})}e.peerRecordEnvelope!=null&&(l=e.peerRecordEnvelope)}let u;(i==null?void 0:i.id.publicKey)!=null?u=as(i.id.publicKey):e.publicKey!=null?u=as(e.publicKey):n.publicKey!=null&&(u=as(n.publicKey));const d={addresses:await Xq(n,r.addressFilter??(async()=>!0),s,(p=r.existingPeer)==null?void 0:p.peerPB.addresses,r),protocols:[...o.values()].sort((g,b)=>g.localeCompare(b)),metadata:a,tags:c,publicKey:u,peerRecordEnvelope:l};return d.addresses.forEach(g=>{var b,m,y;g.observed=((y=(m=(b=r.existingPeer)==null?void 0:b.peerPB.addresses)==null?void 0:m.find(E=>Ne(E.multiaddr,E.multiaddr)))==null?void 0:y.observed)??Date.now()}),n.type!=="RSA"&&delete d.publicKey,d}function rp(n,e){var r;const t=new Map;for(const[i,s]of n)s!=null&&e.validate(i,s);for(const[i,s]of n.sort(([o],[a])=>o.localeCompare(a)))s!=null&&t.set(i,((r=e.map)==null?void 0:r.call(e,i,s))??s);return t}function UT(n,e){if(typeof n!="string")throw new Zr("Metadata key must be a string");if(!(e instanceof Uint8Array))throw new Zr("Metadata value must be a Uint8Array")}function BT(n,e){if(typeof n!="string")throw new Zr("Tag name must be a string");if(e.value!=null){if(parseInt(`${e.value}`,10)!==e.value)throw new Zr("Tag value must be an integer");if(e.value<0||e.value>100)throw new Zr("Tag value must be between 0-100")}if(e.ttl!=null){if(parseInt(`${e.ttl}`,10)!==e.ttl)throw new Zr("Tag ttl must be an integer");if(e.ttl<0)throw new Zr("Tag ttl must be between greater than 0")}}function kT(n,e){let t;e.expiry!=null&&(t=e.expiry),e.ttl!=null&&(t=BigInt(Date.now()+Number(e.ttl)));const r={value:e.value??0};return t!=null&&(r.expiry=t),r}function wR(n){const e=n.toString().split("/")[2],t=ze.parse(e,yn);return GD(t)}function y0(n,e,t){const r=wR(n);return Bq(r,e,t)}function Yq(n,e){return{prefix:bR,filters:(n.filters??[]).map(t=>({key:r,value:i})=>t(y0(r,i,e))),orders:(n.orders??[]).map(t=>(r,i)=>t(y0(r.key,r.value,e),y0(i.key,i.value,e)))}}var xr,Bp,kp,$p;class Zq{constructor(e,t={}){me(this,xr);h(this,"peerId");h(this,"datastore");h(this,"locks");h(this,"addressFilter");h(this,"log");h(this,"maxAddressAge");h(this,"maxPeerAge");this.log=e.logger.forComponent("libp2p:peer-store"),this.peerId=e.peerId,this.datastore=e.datastore,this.addressFilter=t.addressFilter,this.locks=TG({name:"libp2p_peer_store_locks",metrics:e.metrics}),this.maxAddressAge=t.maxAddressAge??SW,this.maxPeerAge=t.maxPeerAge??xW}getLock(e){let t=this.locks.get(e);return t==null&&(t={refs:0,lock:EW({name:e.toString(),singleProcess:!0})},this.locks.set(e,t)),t.refs++,t}maybeRemoveLock(e,t){t.refs--,t.refs===0&&(t.lock.finalize(),this.locks.delete(e))}async getReadLock(e,t){const r=this.getLock(e);try{const i=await r.lock.readLock(t);return()=>{i(),this.maybeRemoveLock(e,r)}}catch(i){throw this.maybeRemoveLock(e,r),i}}async getWriteLock(e,t){const r=this.getLock(e);try{const i=await r.lock.writeLock(t);return()=>{i(),this.maybeRemoveLock(e,r)}}catch(i){throw this.maybeRemoveLock(e,r),i}}async has(e,t){try{return await this.load(e,t),!0}catch(r){if(r.name!=="NotFoundError")throw r}return!1}async delete(e,t){this.peerId.equals(e)||await this.datastore.delete(np(e),t)}async load(e,t){const r=np(e),i=await this.datastore.get(r,t),s=Ma.decode(i);if(ue(this,xr,$p).call(this,e,s))throw await this.datastore.delete(r,t),new ST;return wh(e,s,this.peerId.equals(e)?1/0:this.maxAddressAge)}async save(e,t,r){const i=await ue(this,xr,Bp).call(this,e,r),s=await g0(e,t,"patch",{...r,addressFilter:this.addressFilter});return ue(this,xr,kp).call(this,e,s,i)}async patch(e,t,r){const i=await ue(this,xr,Bp).call(this,e,r),s=await g0(e,t,"patch",{...r,addressFilter:this.addressFilter,existingPeer:i});return ue(this,xr,kp).call(this,e,s,i)}async merge(e,t,r){const i=await ue(this,xr,Bp).call(this,e,r),s=await g0(e,t,"merge",{addressFilter:this.addressFilter,existingPeer:i});return ue(this,xr,kp).call(this,e,s,i)}async*all(e){for await(const{key:t,value:r}of this.datastore.query(Yq(e??{},this.maxAddressAge),e)){const i=wR(t);if(i.equals(this.peerId))continue;const s=Ma.decode(r);if(ue(this,xr,$p).call(this,i,s)){await this.datastore.delete(t,e);continue}yield wh(i,s,this.peerId.equals(i)?1/0:this.maxAddressAge)}}}xr=new WeakSet,Bp=async function(e,t){try{const r=np(e),i=await this.datastore.get(r,t),s=Ma.decode(i);if(ue(this,xr,$p).call(this,e,s))throw await this.datastore.delete(r,t),new ST;return{peerPB:s,peer:wh(e,s,this.maxAddressAge)}}catch(r){r.name!=="NotFoundError"&&this.log.error("invalid peer data found in peer store - %e",r)}},kp=async function(e,t,r,i){t.updated=Date.now();const s=Ma.encode(t);return await this.datastore.put(np(e),s,i),{peer:wh(e,t,this.maxAddressAge),previous:r==null?void 0:r.peer,updated:r==null||!kq(t,r.peerPB)}},$p=function(e,t){if(t.updated==null)return!0;if(this.peerId.equals(e))return!1;const r=t.updated<Date.now()-this.maxPeerAge,i=Date.now()-this.maxAddressAge,s=t.addresses.filter(o=>o.observed!=null&&o.observed>i);return r&&s.length===0};var rC,Al,Fp;rC=Symbol.toStringTag;class jq{constructor(e,t={}){me(this,Al);h(this,"store");h(this,"events");h(this,"peerId");h(this,"log");h(this,rC,"@libp2p/peer-store");this.log=e.logger.forComponent("libp2p:peer-store"),this.events=e.events,this.peerId=e.peerId,this.store=new Zq(e,t)}async forEach(e,t){for await(const r of this.store.all(t))e(r)}async all(e){return Lv(this.store.all(e))}async delete(e,t){const r=await this.store.getReadLock(e,t);try{await this.store.delete(e,t)}finally{r()}}async has(e,t){const r=await this.store.getReadLock(e,t);try{return await this.store.has(e,t)}finally{this.log.trace("has release read lock"),r==null||r()}}async get(e,t){const r=await this.store.getReadLock(e,t);try{return await this.store.load(e,t)}finally{r==null||r()}}async getInfo(e,t){const r=await this.get(e,t);return{id:r.id,multiaddrs:r.addresses.map(({multiaddr:i})=>i)}}async save(e,t,r){const i=await this.store.getWriteLock(e,r);try{const s=await this.store.save(e,t,r);return ue(this,Al,Fp).call(this,e,s),s.peer}finally{i==null||i()}}async patch(e,t,r){const i=await this.store.getWriteLock(e,r);try{const s=await this.store.patch(e,t,r);return ue(this,Al,Fp).call(this,e,s),s.peer}finally{i==null||i()}}async merge(e,t,r){const i=await this.store.getWriteLock(e,r);try{const s=await this.store.merge(e,t,r);return ue(this,Al,Fp).call(this,e,s),s.peer}finally{i==null||i()}}async consumePeerRecord(e,t,r){const i=Up(t)?t:Up(t==null?void 0:t.expectedPeer)?t.expectedPeer:void 0,s=Up(t)||t===void 0?r:t,o=await Qa.openAndCertify(e,js.DOMAIN,s),a=GD(o.publicKey.toCID());if((i==null?void 0:i.equals(a))===!1)return this.log("envelope peer id was not the expected peer id - expected: %p received: %p",i,a),!1;const c=js.createFromProtobuf(o.payload);let l;try{l=await this.get(a,s)}catch(u){if(u.name!=="NotFoundError")throw u}if((l==null?void 0:l.peerRecordEnvelope)!=null){const u=Qa.createFromProtobuf(l.peerRecordEnvelope),d=js.createFromProtobuf(u.payload);if(d.seqNumber>=c.seqNumber)return this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d",d.seqNumber,c.seqNumber),!1}return await this.patch(c.peerId,{peerRecordEnvelope:e,addresses:c.multiaddrs.map(u=>({isCertified:!0,multiaddr:u}))},s),!0}}Al=new WeakSet,Fp=function(e,t){t.updated&&(this.peerId.equals(e)?this.events.safeDispatchEvent("self:peer:update",{detail:t}):this.events.safeDispatchEvent("peer:update",{detail:t}))};function Jq(n,e={}){return new jq(n,e)}var ew;let ni=(ew=class extends Error{constructor(){super(...arguments);h(this,"name","InvalidMultiaddrError")}},h(ew,"name","InvalidMultiaddrError"),ew);var tw;let md=(tw=class extends Error{constructor(){super(...arguments);h(this,"name","ValidationError")}},h(tw,"name","ValidationError"),tw);var nw;let Qq=(nw=class extends Error{constructor(){super(...arguments);h(this,"name","InvalidParametersError")}},h(nw,"name","InvalidParametersError"),nw);var rw;let eK=(rw=class extends Error{constructor(){super(...arguments);h(this,"name","UnknownProtocolError")}},h(rw,"name","UnknownProtocolError"),rw);const Nv=4,tK=6,nK=273,rK=33,Uv=41,iK=42,sK=43,oK=53,aK=54,cK=55,lK=56,uK=132,hK=301,dK=302,fK=400,us=421,pK=444,mK=445,gK=446,yK=447,vR=448,Bv=449,bK=454,wK=460,vK=461,_K=465,EK=466,SK=480,xK=481,TK=443,AK=477,MK=478,CK=479,IK=277,PK=275,DK=276,RK=280,LK=281,OK=290,NK=777;function $T(n){return e=>ne(e,n)}function FT(n){return e=>ge(e,n)}function vh(n){return new DataView(n.buffer).getUint16(n.byteOffset).toString()}function Zc(n){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof n=="string"?parseInt(n):n),new Uint8Array(e)}function UK(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=ge(e[0],"base32"),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const i=Zc(r);return nt([t,i],t.length+i.length)}function BK(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=yn.decode(`b${e[0]}`),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const i=Zc(r);return nt([t,i],t.length+i.length)}function zT(n){const e=n.subarray(0,n.length-2),t=n.subarray(n.length-2),r=ne(e,"base32"),i=vh(t);return`${r}:${i}`}const _R=function(n){n=n.toString().trim();const e=new Uint8Array(4);return n.split(/\./g).forEach((t,r)=>{const i=parseInt(t,10);if(isNaN(i)||i<0||i>255)throw new ni("Invalid byte value in IP address");e[r]=i}),e},kK=function(n){let e=0;n=n.toString().trim();const t=n.split(":",8);let r;for(r=0;r<t.length;r++){const s=Pt(t[r]);let o;s&&(o=_R(t[r]),t[r]=ne(o.subarray(0,2),"base16")),o!=null&&++r<8&&t.splice(r,0,ne(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(r=0;r<t.length&&t[r]!=="";r++);const s=[r,1];for(r=9-t.length;r>0;r--)s.push("0");t.splice.apply(t,s)}const i=new Uint8Array(e+16);for(r=0;r<t.length;r++){t[r]===""&&(t[r]="0");const s=parseInt(t[r],16);if(isNaN(s)||s<0||s>65535)throw new ni("Invalid byte value in IP address");i[e++]=s>>8&255,i[e++]=s&255}return i},$K=function(n){if(n.byteLength!==4)throw new ni("IPv4 address was incorrect length");const e=[];for(let t=0;t<n.byteLength;t++)e.push(n[t]);return e.join(".")},FK=function(n){if(n.byteLength!==16)throw new ni("IPv6 address was incorrect length");const e=[];for(let r=0;r<n.byteLength;r+=2){const i=n[r],s=n[r+1],o=`${i.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const r=new URL(`http://[${t}]`);return r.hostname.substring(1,r.hostname.length-1)}catch{throw new ni(`Invalid IPv6 address "${t}"`)}};function zK(n){try{const e=new URL(`http://[${n}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new ni(`Invalid IPv6 address "${n}"`)}}const b0=Object.values(Fr).map(n=>n.decoder),VK=(function(){let n=b0[0].or(b0[1]);return b0.slice(2).forEach(e=>n=n.or(e)),n})();function HK(n){return VK.decode(n)}function GK(n){return e=>n.encoder.encode(e)}function WK(n){if(parseInt(n).toString()!==n)throw new md("Value must be an integer")}function qK(n){if(n<0)throw new md("Value must be a positive integer, or zero")}function KK(n){return e=>{if(e>n)throw new md(`Value must be smaller than or equal to ${n}`)}}function XK(...n){return e=>{for(const t of n)t(e)}}const ip=XK(WK,qK,KK(65535)),$n=-1;let YK=class{constructor(){h(this,"protocolsByCode",new Map);h(this,"protocolsByName",new Map)}getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new eK(`Protocol ${e} was unknown`);return t}addProtocol(e){var t;this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),(t=e.aliases)==null||t.forEach(r=>{this.protocolsByName.set(r,e)})}removeProtocol(e){var r;const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),(r=t.aliases)==null||r.forEach(i=>{this.protocolsByName.delete(i)}))}};const ku=new YK,ZK=[{code:Nv,name:"ip4",size:32,valueToBytes:_R,bytesToValue:$K,validate:n=>{if(!Pt(n))throw new md(`Invalid IPv4 address "${n}"`)}},{code:tK,name:"tcp",size:16,valueToBytes:Zc,bytesToValue:vh,validate:ip},{code:nK,name:"udp",size:16,valueToBytes:Zc,bytesToValue:vh,validate:ip},{code:rK,name:"dccp",size:16,valueToBytes:Zc,bytesToValue:vh,validate:ip},{code:Uv,name:"ip6",size:128,valueToBytes:kK,bytesToValue:FK,stringToValue:zK,validate:n=>{if(!hi(n))throw new md(`Invalid IPv6 address "${n}"`)}},{code:iK,name:"ip6zone",size:$n},{code:sK,name:"ipcidr",size:8,bytesToValue:$T("base10"),valueToBytes:FT("base10")},{code:oK,name:"dns",size:$n},{code:aK,name:"dns4",size:$n},{code:cK,name:"dns6",size:$n},{code:lK,name:"dnsaddr",size:$n},{code:uK,name:"sctp",size:16,valueToBytes:Zc,bytesToValue:vh,validate:ip},{code:hK,name:"udt"},{code:dK,name:"utp"},{code:fK,name:"unix",size:$n,stringToValue:n=>decodeURIComponent(n),valueToString:n=>encodeURIComponent(n)},{code:us,name:"p2p",aliases:["ipfs"],size:$n,bytesToValue:$T("base58btc"),valueToBytes:n=>n.startsWith("Q")||n.startsWith("1")?FT("base58btc")(n):ze.parse(n).multihash.bytes},{code:pK,name:"onion",size:96,bytesToValue:zT,valueToBytes:UK},{code:mK,name:"onion3",size:296,bytesToValue:zT,valueToBytes:BK},{code:gK,name:"garlic64",size:$n},{code:yK,name:"garlic32",size:$n},{code:vR,name:"tls"},{code:Bv,name:"sni",size:$n},{code:bK,name:"noise"},{code:wK,name:"quic"},{code:vK,name:"quic-v1"},{code:_K,name:"webtransport"},{code:EK,name:"certhash",size:$n,bytesToValue:GK(ui),valueToBytes:HK},{code:SK,name:"http"},{code:xK,name:"http-path",size:$n,stringToValue:n=>`/${decodeURIComponent(n)}`,valueToString:n=>encodeURIComponent(n.substring(1))},{code:TK,name:"https"},{code:AK,name:"ws"},{code:MK,name:"wss"},{code:CK,name:"p2p-websocket-star"},{code:IK,name:"p2p-stardust"},{code:PK,name:"p2p-webrtc-star"},{code:DK,name:"p2p-webrtc-direct"},{code:RK,name:"webrtc-direct"},{code:LK,name:"webrtc"},{code:OK,name:"p2p-circuit"},{code:NK,name:"memory",size:$n}];ZK.forEach(n=>{ku.addProtocol(n)});function jK(n){var r;const e=[];let t=0;for(;t<n.length;){const i=zt(n,t),s=ku.getProtocol(i),o=Me(i),a=tX(s,n,t+o);let c=0;a>0&&s.size===$n&&(c=Me(a));const l=o+c+a,u={code:i,name:s.name,bytes:n.subarray(t,t+l)};if(a>0){const d=t+o+c,f=n.subarray(d,d+a);u.value=((r=s.bytesToValue)==null?void 0:r.call(s,f))??ne(f)}e.push(u),t+=l}return e}function JK(n){var r;let e=0;const t=[];for(const i of n){if(i.bytes==null){const s=ku.getProtocol(i.code),o=Me(i.code);let a,c=0,l=0;i.value!=null&&(a=((r=s.valueToBytes)==null?void 0:r.call(s,i.value))??ge(i.value),c=a.byteLength,s.size===$n&&(l=Me(c)));const u=new Uint8Array(o+l+c);let d=0;Xt(i.code,u,d),d+=o,a!=null&&(s.size===$n&&(Xt(c,u,d),d+=l),u.set(a,d)),i.bytes=u}t.push(i.bytes),e+=i.bytes.byteLength}return nt(t,e)}function QK(n){var s;if(n.charAt(0)!=="/")throw new ni('String multiaddr must start with "/"');const e=[];let t="protocol",r="",i="";for(let o=1;o<n.length;o++){const a=n.charAt(o);a!=="/"&&(t==="protocol"?i+=n.charAt(o):r+=n.charAt(o));const c=o===n.length-1;if(a==="/"||c){const l=ku.getProtocol(i);if(t==="protocol"){if(l.size==null||l.size===0){e.push({code:l.code,name:l.name}),r="",i="",t="protocol";continue}else if(c)throw new ni(`Component ${i} was missing value`);t="value"}else if(t==="value"){const u={code:l.code,name:l.name};if(l.size!=null&&l.size!==0){if(r==="")throw new ni(`Component ${i} was missing value`);u.value=((s=l.stringToValue)==null?void 0:s.call(l,r))??r}e.push(u),r="",i="",t="protocol"}}}if(i!==""&&r!=="")throw new ni("Incomplete multiaddr");return e}function eX(n){return`/${n.flatMap(e=>{var r;if(e.value==null)return e.name;const t=ku.getProtocol(e.code);if(t==null)throw new ni(`Unknown protocol code ${e.code}`);return[e.name,((r=t.valueToString)==null?void 0:r.call(t,e.value))??e.value]}).join("/")}`}function tX(n,e,t){return n.size==null||n.size===0?0:n.size>0?n.size/8:zt(e,t)}const nX=Symbol.for("nodejs.util.inspect.custom"),ER=Symbol.for("@multiformats/multiaddr");function rX(n){if(n==null&&(n="/"),KE(n))return n.getComponents();if(n instanceof Uint8Array)return jK(n);if(typeof n=="string")return n=n.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),n===""&&(n="/"),QK(n);if(Array.isArray(n))return n;throw new ni("Must be a string, Uint8Array, Component[], or another Multiaddr")}var iC,_i,Ml,Cl,Gs;let iX=(Gs=class{constructor(e="/",t={}){h(this,iC,!0);me(this,_i);me(this,Ml);me(this,Cl);pe(this,_i,rX(e)),t.validate!==!1&&sX(this)}get bytes(){return D(this,Cl)==null&&pe(this,Cl,JK(D(this,_i))),D(this,Cl)}toString(){return D(this,Ml)==null&&pe(this,Ml,eX(D(this,_i))),D(this,Ml)}toJSON(){return this.toString()}getComponents(){return[...D(this,_i).map(e=>({...e}))]}encapsulate(e){const t=new Gs(e);return new Gs([...D(this,_i),...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),r=this.toString(),i=r.lastIndexOf(t);if(i<0)throw new Qq(`Address ${this.toString()} does not contain subaddress: ${t}`);return new Gs(r.slice(0,i),{validate:!1})}decapsulateCode(e){let t;for(let r=D(this,_i).length-1;r>-1;r--)if(D(this,_i)[r].code===e){t=r;break}return new Gs(D(this,_i).slice(0,t),{validate:!1})}equals(e){return Ne(this.bytes,e.bytes)}[(iC=ER,nX)](){return`Multiaddr(${this.toString()})`}},_i=new WeakMap,Ml=new WeakMap,Cl=new WeakMap,Gs);function sX(n){n.getComponents().forEach(e=>{var r;const t=ku.getProtocol(e.code);e.value!=null&&((r=t.validate)==null||r.call(t,e.value))})}function KE(n){return!!(n!=null&&n[ER])}function Qn(n){return new iX(n)}const sl=class sl extends Error{constructor(t="Not Found"){super(t);h(this,"name",sl.name);h(this,"code",sl.code)}};h(sl,"name","NotFoundError"),h(sl,"code","ERR_NOT_FOUND");let kv=sl;function oX(n){return n[Symbol.asyncIterator]!=null}function VT(n){if(oX(n))return(async()=>{for await(const e of n);})();for(const e of n);}function aX(n){const[e,t]=n[Symbol.asyncIterator]!=null?[n[Symbol.asyncIterator](),Symbol.asyncIterator]:[n[Symbol.iterator](),Symbol.iterator],r=[];return{peek:()=>e.next(),push:i=>{r.push(i)},next:()=>r.length>0?{done:!1,value:r.shift()}:e.next(),[t](){return this}}}function cX(n){return n[Symbol.asyncIterator]!=null}function Vc(n,e){let t=0;if(cX(n))return(async function*(){for await(const c of n)await e(c,t++)&&(yield c)})();const r=aX(n),{value:i,done:s}=r.next();if(s===!0)return(function*(){})();const o=e(i,t++);if(typeof o.then=="function")return(async function*(){await o&&(yield i);for(const c of r)await e(c,t++)&&(yield c)})();const a=e;return(function*(){o===!0&&(yield i);for(const c of r)a(c,t++)&&(yield c)})()}function lX(n){return n[Symbol.asyncIterator]!=null}function HT(n,e){return lX(n)?(async function*(){yield*(await Lv(n)).sort(e)})():(function*(){yield*Lv(n).sort(e)})()}function uX(n){return n[Symbol.asyncIterator]!=null}function GT(n,e){return uX(n)?(async function*(){let t=0;if(!(e<1)){for await(const r of n)if(yield r,t++,t===e)return}})():(function*(){let t=0;if(!(e<1)){for(const r of n)if(yield r,t++,t===e)return}})()}class hX{put(e,t,r){return Promise.reject(new Error(".put is not implemented"))}get(e,t){return Promise.reject(new Error(".get is not implemented"))}has(e,t){return Promise.reject(new Error(".has is not implemented"))}delete(e,t){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(e,t={}){for await(const{key:r,value:i}of e)await this.put(r,i,t),yield r}async*getMany(e,t={}){for await(const r of e)yield{key:r,value:await this.get(r,t)}}async*deleteMany(e,t={}){for await(const r of e)await this.delete(r,t),yield r}batch(){let e=[],t=[];return{put(r,i){e.push({key:r,value:i})},delete(r){t.push(r)},commit:async r=>{await VT(this.putMany(e,r)),e=[],await VT(this.deleteMany(t,r)),t=[]}}}async*_all(e,t){throw new Error("._all is not implemented")}async*_allKeys(e,t){throw new Error("._allKeys is not implemented")}query(e,t){let r=this._all(e,t);if(e.prefix!=null){const i=e.prefix;r=Vc(r,s=>s.key.toString().startsWith(i))}if(Array.isArray(e.filters)&&(r=e.filters.reduce((i,s)=>Vc(i,s),r)),Array.isArray(e.orders)&&(r=e.orders.reduce((i,s)=>HT(i,s),r)),e.offset!=null){let i=0;const s=e.offset;r=Vc(r,()=>i++>=s)}return e.limit!=null&&(r=GT(r,e.limit)),r}queryKeys(e,t){let r=this._allKeys(e,t);if(e.prefix!=null){const i=e.prefix;r=Vc(r,s=>s.toString().startsWith(i))}if(Array.isArray(e.filters)&&(r=e.filters.reduce((i,s)=>Vc(i,s),r)),Array.isArray(e.orders)&&(r=e.orders.reduce((i,s)=>HT(i,s),r)),e.offset!=null){const i=e.offset;let s=0;r=Vc(r,()=>s++>=i)}return e.limit!=null&&(r=GT(r,e.limit)),r}}class dX extends hX{constructor(){super();h(this,"data");this.data=new Map}put(t,r,i){var s;return(s=i==null?void 0:i.signal)==null||s.throwIfAborted(),this.data.set(t.toString(),r),t}get(t,r){var s;(s=r==null?void 0:r.signal)==null||s.throwIfAborted();const i=this.data.get(t.toString());if(i==null)throw new kv;return i}has(t,r){var i;return(i=r==null?void 0:r.signal)==null||i.throwIfAborted(),this.data.has(t.toString())}delete(t,r){var i;(i=r==null?void 0:r.signal)==null||i.throwIfAborted(),this.data.delete(t.toString())}*_all(t,r){var i,s;(i=r==null?void 0:r.signal)==null||i.throwIfAborted();for(const[o,a]of this.data.entries())yield{key:new or(o),value:a},(s=r==null?void 0:r.signal)==null||s.throwIfAborted()}*_allKeys(t,r){var i,s;(i=r==null?void 0:r.signal)==null||i.throwIfAborted();for(const o of this.data.keys())yield new or(o),(s=r==null?void 0:r.signal)==null||s.throwIfAborted()}}var iw;let fu=(iw=class extends Error{constructor(){super(...arguments);h(this,"name","InvalidMultiaddrError")}},h(iw,"name","InvalidMultiaddrError"),iw);var sw;let gd=(sw=class extends Error{constructor(){super(...arguments);h(this,"name","ValidationError")}},h(sw,"name","ValidationError"),sw);var ow;let fX=(ow=class extends Error{constructor(){super(...arguments);h(this,"name","UnknownProtocolError")}},h(ow,"name","UnknownProtocolError"),ow);const SR=4,dl=6,xR=273,pX=33,TR=41,AR=42,XE=43,MR=53,CR=54,IR=55,PR=56,mX=132,gX=301,yX=302,DR=400,_t=421,bX=444,wX=445,vX=446,_X=447,zh=448,RR=449,EX=454,LR=460,OR=461,NR=465,yd=466,fl=480,SX=481,$v=443,YE=477,UR=478,xX=479,TX=277,AX=275,MX=276,BR=280,Vh=281,ZE=290,kR=777;function WT(n){return e=>ne(e,n)}function qT(n){return e=>ge(e,n)}function _h(n){return new DataView(n.buffer).getUint16(n.byteOffset).toString()}function jc(n){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof n=="string"?parseInt(n):n),new Uint8Array(e)}function CX(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=ge(e[0],"base32"),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const i=jc(r);return nt([t,i],t.length+i.length)}function IX(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=yn.decode(`b${e[0]}`),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const i=jc(r);return nt([t,i],t.length+i.length)}function KT(n){const e=n.subarray(0,n.length-2),t=n.subarray(n.length-2),r=ne(e,"base32"),i=_h(t);return`${r}:${i}`}const $R=function(n){n=n.toString().trim();const e=new Uint8Array(4);return n.split(/\./g).forEach((t,r)=>{const i=parseInt(t,10);if(isNaN(i)||i<0||i>255)throw new fu("Invalid byte value in IP address");e[r]=i}),e},PX=function(n){let e=0;n=n.toString().trim();const t=n.split(":",8);let r;for(r=0;r<t.length;r++){const s=Pt(t[r]);let o;s&&(o=$R(t[r]),t[r]=ne(o.subarray(0,2),"base16")),o!=null&&++r<8&&t.splice(r,0,ne(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(r=0;r<t.length&&t[r]!=="";r++);const s=[r,1];for(r=9-t.length;r>0;r--)s.push("0");t.splice.apply(t,s)}const i=new Uint8Array(e+16);for(r=0;r<t.length;r++){t[r]===""&&(t[r]="0");const s=parseInt(t[r],16);if(isNaN(s)||s<0||s>65535)throw new fu("Invalid byte value in IP address");i[e++]=s>>8&255,i[e++]=s&255}return i},DX=function(n){if(n.byteLength!==4)throw new fu("IPv4 address was incorrect length");const e=[];for(let t=0;t<n.byteLength;t++)e.push(n[t]);return e.join(".")},RX=function(n){if(n.byteLength!==16)throw new fu("IPv6 address was incorrect length");const e=[];for(let r=0;r<n.byteLength;r+=2){const i=n[r],s=n[r+1],o=`${i.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const r=new URL(`http://[${t}]`);return r.hostname.substring(1,r.hostname.length-1)}catch{throw new fu(`Invalid IPv6 address "${t}"`)}};function LX(n){try{const e=new URL(`http://[${n}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new fu(`Invalid IPv6 address "${n}"`)}}const w0=Object.values(Fr).map(n=>n.decoder),OX=(function(){let n=w0[0].or(w0[1]);return w0.slice(2).forEach(e=>n=n.or(e)),n})();function NX(n){return OX.decode(n)}function UX(n){return e=>n.encoder.encode(e)}function BX(n){if(parseInt(n).toString()!==n)throw new gd("Value must be an integer")}function kX(n){if(n<0)throw new gd("Value must be a positive integer, or zero")}function $X(n){return e=>{if(e>n)throw new gd(`Value must be smaller than or equal to ${n}`)}}function FX(...n){return e=>{for(const t of n)t(e)}}const sp=FX(BX,kX,$X(65535)),Cr=-1;let zX=class{constructor(){h(this,"protocolsByCode",new Map);h(this,"protocolsByName",new Map)}getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new fX(`Protocol ${e} was unknown`);return t}addProtocol(e){var t;this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),(t=e.aliases)==null||t.forEach(r=>{this.protocolsByName.set(r,e)})}removeProtocol(e){var r;const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),(r=t.aliases)==null||r.forEach(i=>{this.protocolsByName.delete(i)}))}};const VX=new zX,HX=[{code:SR,name:"ip4",size:32,valueToBytes:$R,bytesToValue:DX,validate:n=>{if(!Pt(n))throw new gd(`Invalid IPv4 address "${n}"`)}},{code:dl,name:"tcp",size:16,valueToBytes:jc,bytesToValue:_h,validate:sp},{code:xR,name:"udp",size:16,valueToBytes:jc,bytesToValue:_h,validate:sp},{code:pX,name:"dccp",size:16,valueToBytes:jc,bytesToValue:_h,validate:sp},{code:TR,name:"ip6",size:128,valueToBytes:PX,bytesToValue:RX,stringToValue:LX,validate:n=>{if(!hi(n))throw new gd(`Invalid IPv6 address "${n}"`)}},{code:AR,name:"ip6zone",size:Cr},{code:XE,name:"ipcidr",size:8,bytesToValue:WT("base10"),valueToBytes:qT("base10")},{code:MR,name:"dns",size:Cr},{code:CR,name:"dns4",size:Cr},{code:IR,name:"dns6",size:Cr},{code:PR,name:"dnsaddr",size:Cr},{code:mX,name:"sctp",size:16,valueToBytes:jc,bytesToValue:_h,validate:sp},{code:gX,name:"udt"},{code:yX,name:"utp"},{code:DR,name:"unix",size:Cr,stringToValue:n=>decodeURIComponent(n),valueToString:n=>encodeURIComponent(n)},{code:_t,name:"p2p",aliases:["ipfs"],size:Cr,bytesToValue:WT("base58btc"),valueToBytes:n=>n.startsWith("Q")||n.startsWith("1")?qT("base58btc")(n):ze.parse(n).multihash.bytes},{code:bX,name:"onion",size:96,bytesToValue:KT,valueToBytes:CX},{code:wX,name:"onion3",size:296,bytesToValue:KT,valueToBytes:IX},{code:vX,name:"garlic64",size:Cr},{code:_X,name:"garlic32",size:Cr},{code:zh,name:"tls"},{code:RR,name:"sni",size:Cr},{code:EX,name:"noise"},{code:LR,name:"quic"},{code:OR,name:"quic-v1"},{code:NR,name:"webtransport"},{code:yd,name:"certhash",size:Cr,bytesToValue:UX(ui),valueToBytes:NX},{code:fl,name:"http"},{code:SX,name:"http-path",size:Cr,stringToValue:n=>`/${decodeURIComponent(n)}`,valueToString:n=>encodeURIComponent(n.substring(1))},{code:$v,name:"https"},{code:YE,name:"ws"},{code:UR,name:"wss"},{code:xX,name:"p2p-websocket-star"},{code:TX,name:"p2p-stardust"},{code:AX,name:"p2p-webrtc-star"},{code:MX,name:"p2p-webrtc-direct"},{code:BR,name:"webrtc-direct"},{code:Vh,name:"webrtc"},{code:ZE,name:"p2p-circuit"},{code:kR,name:"memory",size:Cr}];HX.forEach(n=>{VX.addProtocol(n)});const xt=n=>({match:e=>{const t=e[0];return t==null||t.code!==n||t.value!=null?!1:e.slice(1)}}),Le=(n,e)=>({match:t=>{const r=t[0];return(r==null?void 0:r.code)!==n||r.value==null||e!=null&&r.value!==e?!1:t.slice(1)}}),GX=n=>({match:e=>n.match(e)===!1?e:!1}),st=n=>({match:e=>{const t=n.match(e);return t===!1?e:t}}),pr=(...n)=>({match:e=>{let t;for(const r of n){const i=r.match(e);i!==!1&&(t==null||i.length<t.length)&&(t=i)}return t??!1}}),mt=(...n)=>({match:e=>{for(const t of n){const r=t.match(e);if(r===!1)return!1;e=r}return e}});function Tt(...n){function e(i){if(i==null)return!1;let s=i.getComponents();for(const o of n){const a=o.match(s);if(a===!1)return!1;s=a}return s}function t(i){return e(i)!==!1}function r(i){const s=e(i);return s===!1?!1:s.length===0}return{matchers:n,matches:t,exactMatch:r}}const WX=Le(_t),qX=Tt(WX),Bg=Le(CR),kg=Le(IR),$g=Le(PR),jE=Le(MR);Tt(Bg,st(Le(_t)));Tt(kg,st(Le(_t)));Tt($g,st(Le(_t)));Tt(pr(jE,$g,Bg,kg),st(Le(_t)));const FR=mt(Le(SR),st(Le(XE))),zR=mt(st(Le(AR)),Le(TR),st(Le(XE))),JE=pr(FR,zR),ec=pr(JE,jE,Bg,kg,$g),KX=Tt(pr(JE,mt(pr(jE,$g,Bg,kg),st(Le(_t))))),XT=Tt(FR),YT=Tt(zR);Tt(JE);const QE=mt(ec,Le(dl)),ef=mt(ec,Le(xR)),Im=Tt(mt(QE,st(Le(_t))));Tt(ef);const eS=mt(ef,xt(LR),st(Le(_t))),Fg=mt(ef,xt(OR),st(Le(_t))),XX=pr(eS,Fg);Tt(eS);const YX=Tt(Fg),Fv=pr(ec,QE,ef,eS,Fg),VR=pr(mt(Fv,xt(YE),st(Le(_t)))),bd=Tt(VR),HR=pr(mt(Fv,xt(UR),st(Le(_t))),mt(Fv,xt(zh),st(Le(RR)),xt(YE),st(Le(_t)))),Pm=Tt(HR),GR=mt(ef,xt(BR),st(Le(yd)),st(Le(yd)),st(Le(_t))),ZT=Tt(GR),WR=mt(Fg,xt(NR),st(Le(yd)),st(Le(yd)),st(Le(_t))),jT=Tt(WR),Dm=pr(VR,HR,mt(QE,st(Le(_t))),mt(XX,st(Le(_t))),mt(ec,st(Le(_t))),GR,WR,Le(_t)),tS=Tt(Dm),ZX=mt(st(Dm),xt(ZE),GX(xt(Vh)),st(Le(_t))),pu=Tt(ZX),jX=pr(mt(Dm,xt(ZE),xt(Vh),st(Le(_t))),mt(Dm,xt(Vh),st(Le(_t))),mt(xt(Vh),st(Le(_t)))),zv=Tt(jX),JX=pr(mt(ec,Le(dl),xt(fl),st(Le(_t))),mt(ec,xt(fl),st(Le(_t))));Tt(JX);const QX=mt(ec,pr(mt(Le(dl,"443"),xt(fl)),mt(Le(dl),xt($v)),mt(Le(dl),xt(zh),xt(fl)),mt(xt(zh),xt(fl)),xt(zh),xt($v)),st(Le(_t)));Tt(QX);const eY=pr(mt(Le(kR),st(Le(_t))));Tt(eY);const tY=pr(mt(Le(DR),st(Le(_t))));Tt(tY);const JT=864e13;class nY{constructor(e,t={}){h(this,"log");h(this,"mappings");this.log=e.logger.forComponent("libp2p:address-manager:dns-mappings"),this.mappings=ro({name:"libp2p_address_manager_dns_mappings",metrics:e.metrics})}has(e){const t=Rt(e);let r=t.host;(t.type==="ip4"||t.type==="ip6")&&t.sni!=null&&(r=t.sni);for(const i of this.mappings.values())if(i.domain===r)return!0;return!1}add(e,t){t.forEach(r=>{this.log("add DNS mapping %s to %s",r,e);const i=FE(r)===!0;this.mappings.set(r,{domain:e,verified:i,expires:i?JT-Date.now():0,lastVerified:i?JT-Date.now():void 0})})}remove(e){const t=Rt(e);if(t.type!=="ip4"&&t.type!=="ip6")return!1;let r=!1;for(const[i,s]of this.mappings.entries())s.domain===t.sni&&(this.log("removing %s to %s DNS mapping %e",i,s.domain),this.mappings.delete(i),r=r||s.verified);return r}getAll(e){const t=[];for(let r=0;r<e.length;r++){const i=e[r].multiaddr;if(!Ni(i))continue;const s=Rt(i);for(const[o,a]of this.mappings.entries()){if(s.host!==o)continue;const c=this.maybeAddSNIComponent(i,a.domain);c!=null&&(e.splice(r,1),r--,t.push({multiaddr:c,verified:a.verified,type:"dns-mapping",expires:a.expires,lastVerified:a.lastVerified}))}}return t}maybeAddSNIComponent(e,t){var i;const r=e.getComponents();for(let s=0;s<r.length;s++)if(r[s].code===vR&&((i=r[s+1])==null?void 0:i.code)!==Bv)return r.splice(s+1,0,{name:"sni",code:Bv,value:t}),Qn(r)}confirm(e,t){const r=Rt(e);let i=r.host;(r.type==="ip4"||r.type==="ip6")&&r.sni!=null&&(i=r.sni);let s=!1;for(const[o,a]of this.mappings.entries())a.domain===i&&(this.log("marking %s to %s DNS mapping as verified",o,a.domain),s=a.verified,a.verified=!0,a.expires=Date.now()+t,a.lastVerified=Date.now());return s}unconfirm(e,t){const r=Rt(e);if(r.type!=="ip4"&&r.type!=="ip6")return!1;const i=r.sni??r.host;let s=!1;for(const[o,a]of this.mappings.entries())a.domain===i&&(this.log("removing verification of %s to %s DNS mapping",o,a.domain),s=s||a.verified,a.verified=!1,a.expires=Date.now()+t);return s}}class rY{constructor(e,t={}){h(this,"log");h(this,"mappings");this.log=e.logger.forComponent("libp2p:address-manager:ip-mappings"),this.mappings=ro({name:"libp2p_address_manager_ip_mappings",metrics:e.metrics})}has(e){const t=Rt(e);if(t.type!=="ip4"&&t.type!=="ip6")return!1;for(const r of this.mappings.values())for(const i of r)if(i.externalIp===t.host)return!0;return!1}add(e,t,r,i=t,s="tcp"){const o=`${e}-${t}-${s}`,a=this.mappings.get(o)??[],c={internalIp:e,internalPort:t,externalIp:r,externalPort:i,externalFamily:Pt(r)?4:6,protocol:s,verified:!1,expires:0};a.push(c),this.mappings.set(o,a)}remove(e){const t=Rt(e);if(t.type!=="ip4"&&t.type!=="ip6")return!1;let r=!1;for(const[i,s]of this.mappings.entries()){for(let o=0;o<s.length;o++){const a=s[o];a.externalIp===t.host&&a.externalPort===t.port&&a.protocol===t.protocol&&(this.log("removing %s:%s to %s:%s %s IP mapping",a.externalIp,a.externalPort,t.host,t.port,t.protocol),r=r||a.verified,s.splice(o,1),o--)}s.length===0&&this.mappings.delete(i)}return r}getAll(e){const t=[];for(const{multiaddr:r}of e){if(!Ni(r))continue;const i=Rt(r);if(i.type!=="ip4"&&i.type!=="ip6")continue;let s;if(i.protocol==="tcp"?s=`${i.host}-${i.port}-tcp`:i.protocol==="udp"&&(s=`${i.host}-${i.port}-udp`),s==null)continue;const o=this.mappings.get(s);if(o!=null)for(const a of o)t.push({multiaddr:this.maybeOverrideIp(r,a.externalIp,a.externalFamily,a.protocol,a.externalPort),verified:a.verified,type:"ip-mapping",expires:a.expires,lastVerified:a.lastVerified})}return t}maybeOverrideIp(e,t,r,i,s){const o=e.getComponents(),a=o.findIndex(l=>l.code===Nv||l.code===Uv),c=o.findIndex(l=>l.name===i);return a>-1&&c>-1?(o[a].value=t,o[a].code=r===4?Nv:Uv,o[c].value=`${s}`,Qn(o)):e}confirm(e,t){if(!Ni(e))return!1;const r=Rt(e);let i=!1;for(const s of this.mappings.values())for(const o of s)o.externalIp===r.host&&(this.log("marking %s to %s IP mapping as verified",o.internalIp,o.externalIp),i=o.verified,o.verified=!0,o.expires=Date.now()+t,o.lastVerified=Date.now());return i}unconfirm(e,t){if(!Ni(e))return!1;const r=Rt(e);let i=!1;for(const s of this.mappings.values())for(let o=0;o<s.length;o++){const a=s[o];a.externalIp===r.host&&a.externalPort===r.port&&a.protocol===r.protocol&&(this.log("removing verification of %s:%s to %s:%s %s IP mapping",a.externalIp,a.externalPort,r.host,r.port,r.protocol),i=i||a.verified,a.verified=!1,a.expires=Date.now()+t)}return i}}const iY={maxObservedAddresses:10};class sY{constructor(e,t={}){h(this,"log");h(this,"addresses");h(this,"maxObservedAddresses");this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=ro({name:"libp2p_address_manager_observed_addresses",metrics:e.metrics}),this.maxObservedAddresses=t.maxObservedAddresses??iY.maxObservedAddresses}has(e){return this.addresses.has(e.toString())}removePrefixed(e){for(const t of this.addresses.keys())t.toString().startsWith(e)&&this.addresses.delete(t)}add(e){this.addresses.size!==this.maxObservedAddresses&&(hu(e)||x9(e)||(this.log("adding observed address %a",e),this.addresses.set(e.toString(),{verified:!1,expires:0})))}getAll(){return Array.from(this.addresses).map(([e,t])=>({multiaddr:Qn(e),verified:t.verified,type:"observed",expires:t.expires,lastVerified:t.lastVerified}))}remove(e){var r;const t=((r=this.addresses.get(e.toString()))==null?void 0:r.verified)??!1;return this.log("removing observed address %a",e),this.addresses.delete(e.toString()),t}confirm(e,t){const r=e.toString(),i=this.addresses.get(r)??{verified:!1,expires:Date.now()+t,lastVerified:Date.now()},s=i.verified;return i.verified=!0,i.expires=Date.now()+t,i.lastVerified=Date.now(),this.log("marking observed address %a as verified",r),this.addresses.set(r,i),s}}const oY={maxObservedAddresses:10};class aY{constructor(e,t={}){h(this,"log");h(this,"addresses");h(this,"maxObservedAddresses");this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=ro({name:"libp2p_address_manager_transport_addresses",metrics:e.metrics}),this.maxObservedAddresses=t.maxObservedAddresses??oY.maxObservedAddresses}get(e,t){if(hu(e))return{multiaddr:e,verified:!0,type:"transport",expires:Date.now()+t,lastVerified:Date.now()};const r=this.toKey(e);let i=this.addresses.get(r);return i==null&&(i={verified:!Ni(e),expires:0},this.addresses.set(r,i)),{multiaddr:e,verified:i.verified,type:"transport",expires:i.expires,lastVerified:i.lastVerified}}has(e){const t=this.toKey(e);return this.addresses.has(t)}remove(e){var i;const t=this.toKey(e),r=((i=this.addresses.get(t))==null?void 0:i.verified)??!1;return this.log("removing observed address %a",e),this.addresses.delete(t),r}confirm(e,t){const r=this.toKey(e),i=this.addresses.get(r)??{verified:!1,expires:0,lastVerified:0},s=i.verified;return i.verified=!0,i.expires=Date.now()+t,i.lastVerified=Date.now(),this.addresses.set(r,i),s}unconfirm(e,t){const r=this.toKey(e),i=this.addresses.get(r)??{verified:!1,expires:0},s=i.verified;return i.verified=!1,i.expires=Date.now()+t,this.addresses.set(r,i),s}toKey(e){if(!Ni(e))return e.toString();const t=Rt(e);return`${t.host}-${t.port}-${t.protocol}`}}const QT=6e4,eA={addressVerificationTTL:QT*10,addressVerificationRetry:QT*5},cY=n=>n;function v0(n,e){var r;const t=(r=n.getComponents().findLast(i=>i.code===us))==null?void 0:r.value;return t!=null&&su(t).equals(e)&&(n=n.decapsulate(Qn(`/p2p/${e.toString()}`))),n}var sC;sC=Symbol.toStringTag;class lY{constructor(e,t={}){h(this,"log");h(this,"components");h(this,"listen");h(this,"announce");h(this,"appendAnnounce");h(this,"announceFilter");h(this,"observed");h(this,"dnsMappings");h(this,"ipMappings");h(this,"transportAddresses");h(this,"observedAddressFilter");h(this,"addressVerificationTTL");h(this,"addressVerificationRetry");h(this,sC,"@libp2p/address-manager");const{listen:r=[],announce:i=[],appendAnnounce:s=[]}=t;this.components=e,this.log=e.logger.forComponent("libp2p:address-manager"),this.listen=r.map(o=>o.toString()),this.announce=new Set(i.map(o=>o.toString())),this.appendAnnounce=new Set(s.map(o=>o.toString())),this.observed=new sY(e,t),this.dnsMappings=new nY(e,t),this.ipMappings=new rY(e,t),this.transportAddresses=new aY(e,t),this.announceFilter=t.announceFilter??cY,this.observedAddressFilter=ld(1024),this.addressVerificationTTL=t.addressVerificationTTL??eA.addressVerificationTTL,this.addressVerificationRetry=t.addressVerificationRetry??eA.addressVerificationRetry,this._updatePeerStoreAddresses=Sm(this._updatePeerStoreAddresses.bind(this),1e3),e.events.addEventListener("transport:listening",()=>{this._updatePeerStoreAddresses()}),e.events.addEventListener("transport:close",()=>{this._updatePeerStoreAddresses()})}_updatePeerStoreAddresses(){const e=this.getAddresses().map(t=>{var r;return((r=t.getComponents().findLast(i=>i.code===us))==null?void 0:r.value)===this.components.peerId.toString()?t.decapsulate(`/p2p/${this.components.peerId.toString()}`):t});this.components.peerStore.patch(this.components.peerId,{multiaddrs:e}).catch(t=>{this.log.error("error updating addresses - %e",t)})}getListenAddrs(){return Array.from(this.listen).map(e=>Qn(e))}getAnnounceAddrs(){return Array.from(this.announce).map(e=>Qn(e))}getAppendAnnounceAddrs(){return Array.from(this.appendAnnounce).map(e=>Qn(e))}getObservedAddrs(){return this.observed.getAll().map(e=>e.multiaddr)}addObservedAddr(e){const t=Rt(e);let r;switch(t.type){case"ip4":{r=`${t.host}:${t.port}`;break}case"ip6":{r=`[${t.host}]:${t.port}`;break}default:return}this.observedAddressFilter.has(r)||(this.observedAddressFilter.add(r),e=v0(e,this.components.peerId),!this.ipMappings.has(e)&&(this.dnsMappings.has(e)||this.observed.add(e)))}confirmObservedAddr(e,t){e=v0(e,this.components.peerId);let r=!0;((t==null?void 0:t.type)==="transport"||this.transportAddresses.has(e))&&!this.transportAddresses.confirm(e,(t==null?void 0:t.ttl)??this.addressVerificationTTL)&&r&&(r=!1),((t==null?void 0:t.type)==="dns-mapping"||this.dnsMappings.has(e))&&!this.dnsMappings.confirm(e,(t==null?void 0:t.ttl)??this.addressVerificationTTL)&&r&&(r=!1),((t==null?void 0:t.type)==="ip-mapping"||this.ipMappings.has(e))&&!this.ipMappings.confirm(e,(t==null?void 0:t.ttl)??this.addressVerificationTTL)&&r&&(r=!1),((t==null?void 0:t.type)==="observed"||this.observed.has(e))&&(this.maybeUpgradeToIPMapping(e)?(this.ipMappings.confirm(e,(t==null?void 0:t.ttl)??this.addressVerificationTTL),r=!1):!this.observed.confirm(e,(t==null?void 0:t.ttl)??this.addressVerificationTTL)&&r&&(r=!1)),r||this._updatePeerStoreAddresses()}removeObservedAddr(e,t){e=v0(e,this.components.peerId),this.observed.has(e)&&this.observed.remove(e),this.transportAddresses.has(e)&&this.transportAddresses.unconfirm(e,(t==null?void 0:t.ttl)??this.addressVerificationRetry),this.dnsMappings.has(e)&&this.dnsMappings.unconfirm(e,(t==null?void 0:t.ttl)??this.addressVerificationRetry),this.ipMappings.has(e)&&this.ipMappings.unconfirm(e,(t==null?void 0:t.ttl)??this.addressVerificationRetry)}getAddresses(){const e=new Set,t=this.getAddressesWithMetadata().filter(r=>{if(!r.verified)return!1;const i=r.multiaddr.toString();return e.has(i)?!1:(e.add(i),!0)}).map(r=>r.multiaddr);return this.announceFilter(t.map(r=>{const i=Qn(r),s=i.getComponents().pop();return(s==null?void 0:s.value)===this.components.peerId.toString()?i:i.encapsulate(`/p2p/${this.components.peerId.toString()}`)}))}getAddressesWithMetadata(){const e=this.getAnnounceAddrs();if(e.length>0)return this.components.transportManager.getListeners().forEach(i=>{i.updateAnnounceAddrs(e)}),e.map(i=>({multiaddr:i,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()}));let t=[];t=t.concat(this.components.transportManager.getAddrs().map(i=>this.transportAddresses.get(i,this.addressVerificationTTL)));const r=this.getAppendAnnounceAddrs();return r.length>0&&(this.components.transportManager.getListeners().forEach(i=>{i.updateAnnounceAddrs(r)}),t=t.concat(r.map(i=>({multiaddr:i,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()})))),t=t.concat(this.observed.getAll()),t=t.concat(this.ipMappings.getAll(t)),t=t.concat(this.dnsMappings.getAll(t)),t}addDNSMapping(e,t){this.dnsMappings.add(e,t)}removeDNSMapping(e){this.dnsMappings.remove(Qn(`/dns/${e}`))&&this._updatePeerStoreAddresses()}addPublicAddressMapping(e,t,r,i=t,s="tcp"){this.ipMappings.add(e,t,r,i,s),this.observed.removePrefixed(`/ip${Pt(r)?4:6}/${r}/${s}/${i}`)}removePublicAddressMapping(e,t,r,i=t,s="tcp"){this.ipMappings.remove(Qn(`/ip${Pt(r)?4:6}/${r}/${s}/${i}`))&&this._updatePeerStoreAddresses()}maybeUpgradeToIPMapping(e){if(this.ipMappings.has(e)||!Ni(e))return!1;const t=Rt(e);if(t.type!=="ip4"||FE(t.host)===!0)return!1;const r=this.components.transportManager.getListeners(),i=[s=>bd.exactMatch(s)||Pm.exactMatch(s),s=>Im.exactMatch(s),s=>YX.exactMatch(s)];for(const s of i){if(!s(e))continue;const o=r.filter(l=>l.getAddrs().filter(u=>Rt(u).type==="ip4"&&s(u)).length>0);if(o.length!==1)continue;const a=o[0].getAddrs().filter(l=>!Dv(l)).pop();if(a==null)continue;const c=Rt(a);return c.port==null?!1:(this.observed.remove(e),this.ipMappings.add(c.host,c.port,t.host,t.port,t.protocol),!0)}return!1}}var tA;(function(n){n.NOT_STARTED_YET="The libp2p node is not started yet",n.NOT_FOUND="Not found"})(tA||(tA={}));class uY extends Error{constructor(e="Missing service"){super(e),this.name="MissingServiceError"}}class hY extends Error{constructor(e="Unmet service dependencies"){super(e),this.name="UnmetServiceDependenciesError"}}class _0 extends Error{constructor(e="No content routers available"){super(e),this.name="NoContentRoutersError"}}class nA extends Error{constructor(e="No peer routers available"){super(e),this.name="NoPeerRoutersError"}}class dY extends Error{constructor(e="Should not try to find self"){super(e),this.name="QueriedForSelfError"}}class fY extends Error{constructor(e="Unhandled protocol error"){super(e),this.name="UnhandledProtocolError"}}class pY extends Error{constructor(e="Duplicate protocol handler error"){super(e),this.name="DuplicateProtocolHandlerError"}}class rA extends Error{constructor(e="Dial denied error"){super(e),this.name="DialDeniedError"}}class mY extends Error{constructor(e="No transport was configured to listen on this address"){super(e),this.name="UnsupportedListenAddressError"}}class gY extends Error{constructor(e="Configured listen addresses could not be listened on"){super(e),this.name="UnsupportedListenAddressesError"}}class yY extends Error{constructor(e="No valid addresses"){super(e),this.name="NoValidAddressesError"}}class bY extends Error{constructor(e="Connection intercepted"){super(e),this.name="ConnectionInterceptedError"}}class wY extends Error{constructor(e="Connection denied"){super(e),this.name="ConnectionDeniedError"}}class zp extends Error{constructor(e="Stream is not multiplexed"){super(e),this.name="MuxerUnavailableError"}}class op extends Error{constructor(e="Encryption failed"){super(e),this.name="EncryptionFailedError"}}class vY extends Error{constructor(e="Transport unavailable"){super(e),this.name="TransportUnavailableError"}}class _Y extends Error{constructor(e="Max recursive depth reached"){super(e),this.name="RecursionLimitError"}}class EY{constructor(e={}){h(this,"components",{});h(this,"_started",!1);this.components={};for(const[t,r]of Object.entries(e))this.components[t]=r;this.components.logger==null&&(this.components.logger=yD())}isStarted(){return this._started}async _invokeStartableMethod(e){await Promise.all(Object.values(this.components).filter(t=>DE(t)).map(async t=>{var r;await((r=t[e])==null?void 0:r.call(t))}))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const SY=["metrics","connectionProtector","dns"],xY=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function TY(n={}){const e=new EY(n);return new Proxy(e,{get(r,i,s){if(typeof i=="string"&&!xY.includes(i)){const o=e.components[i];if(o==null&&!SY.includes(i))throw new uY(`${i} not set`);return o}return Reflect.get(r,i,s)},set(r,i,s){return typeof i=="string"?e.components[i]=s:Reflect.set(r,i,s),!0}})}function AY(n){const e={};for(const t of Object.values(n.components))for(const r of MY(t))e[r]=!0;for(const t of Object.values(n.components))for(const r of CY(t))if(e[r]!==!0)throw new hY(`Service "${IY(t)}" required capability "${r}" but it was not provided by any component, you may need to add additional configuration when creating your node.`)}function MY(n){return Array.isArray(n==null?void 0:n[Cv])?n[Cv]:[]}function CY(n){return Array.isArray(n==null?void 0:n[dT])?n[dT]:[]}function IY(n){return(n==null?void 0:n[Symbol.toStringTag])??(n==null?void 0:n.toString())??"unknown"}function PY(n={}){return n.denyDialMultiaddr==null&&(n.denyDialMultiaddr=e=>bd.matches(e)?!0:hu(e)),n}class vt extends Event{constructor(t,r){super(t);h(this,"type");h(this,"detail");this.type=t,this.detail=r}}function qR(n){var r;if(fH(n))return{peerId:n,multiaddrs:[]};let e=Array.isArray(n)?n:[n],t;if(e.length>0){const i=(r=e[0].getComponents().findLast(s=>s.code===us))==null?void 0:r.value;t=i==null?void 0:su(i),e.forEach(s=>{var a;if(!KE(s))throw new IE("Invalid multiaddr");const o=(a=s.getComponents().findLast(c=>c.code===us))==null?void 0:a.value;if(o==null){if(t!=null)throw new zr("Multiaddrs must all have the same peer id or have no peer id")}else{const c=su(o);if((t==null?void 0:t.equals(c))!==!0)throw new zr("Multiaddrs must all have the same peer id or have no peer id")}})}return e=e.filter(i=>!qX.exactMatch(i)),{peerId:t,multiaddrs:e}}const DY=["/ipfs/id/1.0.0","/ipfs/id/push/1.0.0","/libp2p/autonat/1.0.0","/libp2p/dcutr"];async function RY(n,e){var i;const t=((i=n==null?void 0:n.streams)==null?void 0:i.map(s=>s.protocol))??[],r=(e==null?void 0:e.closableProtocols)??DY;if(!(t.filter(s=>s!=null&&!r.includes(s)).length>0))try{await(n==null?void 0:n.close(e))}catch(s){n==null||n.abort(s)}}function Vv(n){const e=Rt(n);let t=e.cidr;if(e.type!=="ip4"&&e.type!=="ip6")throw new zr(`Multiaddr ${n} was not an IPv4 or IPv6 address`);if(t==null)switch(e.type){case"ip4":{t=32;break}case"ip6":{t=128;break}default:throw new zr(`Multiaddr ${n} was not an IPv4 or IPv6 address`)}return new PD(e.host,t)}function KR(n){return!pu.exactMatch(n)}function XR(n,e,t){if(n==null||e==null)return;const r=e.sort((s,o)=>s.direct?-1:o.direct?1:0).find(s=>s.limits==null);if(r==null||r.direct||t==null)return r;if(!t.some(s=>KR(s)))return r}class LY{constructor(e,t={}){h(this,"connectionManager");h(this,"peerStore");h(this,"allow");h(this,"events");h(this,"log");this.allow=(t.allow??[]).map(r=>Vv(r)),this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager:connection-pruner"),this.maybePruneConnections=this.maybePruneConnections.bind(this)}start(){this.events.addEventListener("connection:open",this.maybePruneConnections)}stop(){this.events.removeEventListener("connection:open",this.maybePruneConnections)}maybePruneConnections(){this._maybePruneConnections().catch(e=>{this.log.error("error while pruning connections - %e",e)})}async _maybePruneConnections(){const e=this.connectionManager.getConnections(),t=e.length,r=this.connectionManager.getMaxConnections();if(this.log("checking max connections limit %d/%d",t,r),t<=r)return;const i=new Nu;for(const c of e){const l=c.remotePeer;if(!i.has(l)){i.set(l,0);try{const u=await this.peerStore.get(l);i.set(l,[...u.tags.values()].reduce((d,f)=>d+f.value,0))}catch(u){u.name!=="NotFoundError"&&this.log.error("error loading peer tags - %e",u)}}}const s=this.sortConnections(e,i),o=Math.max(t-r,0),a=[];for(const c of s)if(this.log("too many connections open - closing a connection to %p",c.remotePeer),this.allow.some(u=>{if(Ni(c.remoteAddr)){const d=Rt(c.remoteAddr);return u.contains(d.host)}return!0})||a.push(c),a.length===o)break;await Promise.all(a.map(async c=>{await RY(c,{signal:AbortSignal.timeout(1e3)})})),this.events.safeDispatchEvent("connection:prune",{detail:a})}sortConnections(e,t){return e.sort((r,i)=>{const s=r.timeline.open,o=i.timeline.open;return s<o?1:s>o?-1:0}).sort((r,i)=>r.direction==="outbound"&&i.direction==="inbound"?1:r.direction==="inbound"&&i.direction==="outbound"?-1:0).sort((r,i)=>r.streams.length>i.streams.length?1:r.streams.length<i.streams.length?-1:0).sort((r,i)=>{const s=t.get(r.remotePeer)??0,o=t.get(i.remotePeer)??0;return s>o?1:s<o?-1:0})}}const YR=1e4,ZR=1e3,OY=1e4,Rm=1e4,jR=25,NY=5,UY=10,BY=5,kY="last-dial-failure",$Y="last-dial-success",JR=500,FY=32,zY=100,QR=50;function VY(n,e){const t=Im.exactMatch(n.multiaddr),r=Im.exactMatch(e.multiaddr);if(t&&!r)return-1;if(!t&&r)return 1;const i=Pm.exactMatch(n.multiaddr),s=Pm.exactMatch(e.multiaddr);if(i&&!s)return-1;if(!i&&s)return 1;const o=bd.exactMatch(n.multiaddr),a=bd.exactMatch(e.multiaddr);if(o&&!a)return-1;if(!o&&a)return 1;const c=zv.exactMatch(n.multiaddr),l=zv.exactMatch(e.multiaddr);if(c&&!l)return-1;if(!c&&l)return 1;const u=ZT.exactMatch(n.multiaddr),d=ZT.exactMatch(e.multiaddr);if(u&&!d)return-1;if(!u&&d)return 1;const f=jT.exactMatch(n.multiaddr),p=jT.exactMatch(e.multiaddr);return f&&!p?-1:!f&&p?1:0}function HY(n,e){const t=Dv(n.multiaddr),r=Dv(e.multiaddr);return t&&!r?1:!t&&r?-1:0}function GY(n,e){const t=hu(n.multiaddr),r=hu(e.multiaddr);return t&&!r?1:!t&&r?-1:0}function WY(n,e){return n.isCertified&&!e.isCertified?-1:!n.isCertified&&e.isCertified?1:0}function qY(n,e){const t=pu.exactMatch(n.multiaddr),r=pu.exactMatch(e.multiaddr);return t&&!r?1:!t&&r?-1:0}function KY(n){return n.sort(VY).sort(WY).sort(qY).sort(GY).sort(HY)}var E0={exports:{}},iA;function XY(){return iA||(iA=1,(function(n){var e=Object.prototype.hasOwnProperty,t="~";function r(){}Object.create&&(r.prototype=Object.create(null),new r().__proto__||(t=!1));function i(c,l,u){this.fn=c,this.context=l,this.once=u||!1}function s(c,l,u,d,f){if(typeof u!="function")throw new TypeError("The listener must be a function");var p=new i(u,d||c,f),g=t?t+l:l;return c._events[g]?c._events[g].fn?c._events[g]=[c._events[g],p]:c._events[g].push(p):(c._events[g]=p,c._eventsCount++),c}function o(c,l){--c._eventsCount===0?c._events=new r:delete c._events[l]}function a(){this._events=new r,this._eventsCount=0}a.prototype.eventNames=function(){var l=[],u,d;if(this._eventsCount===0)return l;for(d in u=this._events)e.call(u,d)&&l.push(t?d.slice(1):d);return Object.getOwnPropertySymbols?l.concat(Object.getOwnPropertySymbols(u)):l},a.prototype.listeners=function(l){var u=t?t+l:l,d=this._events[u];if(!d)return[];if(d.fn)return[d.fn];for(var f=0,p=d.length,g=new Array(p);f<p;f++)g[f]=d[f].fn;return g},a.prototype.listenerCount=function(l){var u=t?t+l:l,d=this._events[u];return d?d.fn?1:d.length:0},a.prototype.emit=function(l,u,d,f,p,g){var b=t?t+l:l;if(!this._events[b])return!1;var m=this._events[b],y=arguments.length,E,w;if(m.fn){switch(m.once&&this.removeListener(l,m.fn,void 0,!0),y){case 1:return m.fn.call(m.context),!0;case 2:return m.fn.call(m.context,u),!0;case 3:return m.fn.call(m.context,u,d),!0;case 4:return m.fn.call(m.context,u,d,f),!0;case 5:return m.fn.call(m.context,u,d,f,p),!0;case 6:return m.fn.call(m.context,u,d,f,p,g),!0}for(w=1,E=new Array(y-1);w<y;w++)E[w-1]=arguments[w];m.fn.apply(m.context,E)}else{var x=m.length,M;for(w=0;w<x;w++)switch(m[w].once&&this.removeListener(l,m[w].fn,void 0,!0),y){case 1:m[w].fn.call(m[w].context);break;case 2:m[w].fn.call(m[w].context,u);break;case 3:m[w].fn.call(m[w].context,u,d);break;case 4:m[w].fn.call(m[w].context,u,d,f);break;default:if(!E)for(M=1,E=new Array(y-1);M<y;M++)E[M-1]=arguments[M];m[w].fn.apply(m[w].context,E)}}return!0},a.prototype.on=function(l,u,d){return s(this,l,u,d,!1)},a.prototype.once=function(l,u,d){return s(this,l,u,d,!0)},a.prototype.removeListener=function(l,u,d,f){var p=t?t+l:l;if(!this._events[p])return this;if(!u)return o(this,p),this;var g=this._events[p];if(g.fn)g.fn===u&&(!f||g.once)&&(!d||g.context===d)&&o(this,p);else{for(var b=0,m=[],y=g.length;b<y;b++)(g[b].fn!==u||f&&!g[b].once||d&&g[b].context!==d)&&m.push(g[b]);m.length?this._events[p]=m.length===1?m[0]:m:o(this,p)}return this},a.prototype.removeAllListeners=function(l){var u;return l?(u=t?t+l:l,this._events[u]&&o(this,u)):(this._events=new r,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=t,a.EventEmitter=a,n.exports=a})(E0)),E0.exports}var YY=XY();const ZY=kE(YY);let jY=class eL extends Error{constructor(t,r){var i;super(t,r);h(this,"name","TimeoutError");(i=Error.captureStackTrace)==null||i.call(Error,this,eL)}};const sA=n=>n.reason??new DOMException("This operation was aborted.","AbortError");function JY(n,e){const{milliseconds:t,fallback:r,message:i,customTimers:s={setTimeout,clearTimeout},signal:o}=e;let a,c;const u=new Promise((d,f)=>{if(typeof t!="number"||Math.sign(t)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${t}\``);if(o!=null&&o.aborted){f(sA(o));return}if(o&&(c=()=>{f(sA(o))},o.addEventListener("abort",c,{once:!0})),n.then(d,f),t===Number.POSITIVE_INFINITY)return;const p=new jY;a=s.setTimeout.call(void 0,()=>{if(r){try{d(r())}catch(g){f(g)}return}typeof n.cancel=="function"&&n.cancel(),i===!1?d():i instanceof Error?f(i):(p.message=i??`Promise timed out after ${t} milliseconds`,f(p))},t)}).finally(()=>{u.clear(),c&&o&&o.removeEventListener("abort",c)});return u.clear=()=>{s.clearTimeout.call(void 0,a),a=void 0},u}function QY(n,e,t){let r=0,i=n.length;for(;i>0;){const s=Math.trunc(i/2);let o=r+s;t(n[o],e)<=0?(r=++o,i-=s+1):i=s}return r}var Wr,oC;let eZ=(oC=class{constructor(){me(this,Wr,[])}enqueue(e,t){const{priority:r=0,id:i}=t??{},s={priority:r,id:i,run:e};if(this.size===0||D(this,Wr)[this.size-1].priority>=r){D(this,Wr).push(s);return}const o=QY(D(this,Wr),s,(a,c)=>c.priority-a.priority);D(this,Wr).splice(o,0,s)}setPriority(e,t){const r=D(this,Wr).findIndex(s=>s.id===e);if(r===-1)throw new ReferenceError(`No promise function with the id "${e}" exists in the queue.`);const[i]=D(this,Wr).splice(r,1);this.enqueue(i.run,{priority:t,id:e})}dequeue(){const e=D(this,Wr).shift();return e==null?void 0:e.run}filter(e){return D(this,Wr).filter(t=>t.priority===e.priority).map(t=>t.run)}get size(){return D(this,Wr).length}},Wr=new WeakMap,oC);var Il,Ei,Yi,Pl,Dl,Rl,Oo,Hd,Ll,Zi,Ls,Jt,Gd,Kn,La,Os,vg,Oa,Pe,tL,nL,rL,iL,sL,Hv,Gv,oL,Vp,Wv,qv,Hp,ya,aL,Eh,Kv,aC;let tZ=(aC=class extends ZY{constructor(t){var r,i;super();me(this,Pe);me(this,Il);me(this,Ei);me(this,Yi,0);me(this,Pl);me(this,Dl,!1);me(this,Rl,!1);me(this,Oo);me(this,Hd,0);me(this,Ll,0);me(this,Zi);me(this,Ls);me(this,Jt);me(this,Gd);me(this,Kn,0);me(this,La);me(this,Os);me(this,vg,1n);me(this,Oa,new Map);h(this,"timeout");if(t={carryoverIntervalCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:eZ,...t},!(typeof t.intervalCap=="number"&&t.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${((r=t.intervalCap)==null?void 0:r.toString())??""}\` (${typeof t.intervalCap})`);if(t.interval===void 0||!(Number.isFinite(t.interval)&&t.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${((i=t.interval)==null?void 0:i.toString())??""}\` (${typeof t.interval})`);if(pe(this,Il,t.carryoverIntervalCount??t.carryoverConcurrencyCount??!1),pe(this,Ei,t.intervalCap===Number.POSITIVE_INFINITY||t.interval===0),pe(this,Pl,t.intervalCap),pe(this,Oo,t.interval),pe(this,Jt,new t.queueClass),pe(this,Gd,t.queueClass),this.concurrency=t.concurrency,t.timeout!==void 0&&!(Number.isFinite(t.timeout)&&t.timeout>0))throw new TypeError(`Expected \`timeout\` to be a positive finite number, got \`${t.timeout}\` (${typeof t.timeout})`);this.timeout=t.timeout,pe(this,Os,t.autoStart===!1),ue(this,Pe,aL).call(this)}get concurrency(){return D(this,La)}set concurrency(t){if(!(typeof t=="number"&&t>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${t}\` (${typeof t})`);pe(this,La,t),ue(this,Pe,Hp).call(this)}setPriority(t,r){if(typeof r!="number"||!Number.isFinite(r))throw new TypeError(`Expected \`priority\` to be a finite number, got \`${r}\` (${typeof r})`);D(this,Jt).setPriority(t,r)}async add(t,r={}){return r.id??(r.id=(di(this,vg)._++).toString()),r={timeout:this.timeout,...r},new Promise((i,s)=>{const o=Symbol(`task-${r.id}`);D(this,Jt).enqueue(async()=>{var c,l;di(this,Kn)._++,D(this,Oa).set(o,{id:r.id,priority:r.priority??0,startTime:Date.now(),timeout:r.timeout});let a;try{try{(c=r.signal)==null||c.throwIfAborted()}catch(f){throw D(this,Ei)||di(this,Yi)._--,D(this,Oa).delete(o),f}let u=t({signal:r.signal});if(r.timeout&&(u=JY(Promise.resolve(u),{milliseconds:r.timeout,message:`Task timed out after ${r.timeout}ms (queue has ${D(this,Kn)} running, ${D(this,Jt).size} waiting)`})),r.signal){const{signal:f}=r;u=Promise.race([u,new Promise((p,g)=>{a=()=>{g(f.reason)},f.addEventListener("abort",a,{once:!0})})])}const d=await u;i(d),this.emit("completed",d)}catch(u){s(u),this.emit("error",u)}finally{a&&((l=r.signal)==null||l.removeEventListener("abort",a)),D(this,Oa).delete(o),queueMicrotask(()=>{ue(this,Pe,rL).call(this)})}},r),this.emit("add"),ue(this,Pe,Vp).call(this)})}async addAll(t,r){return Promise.all(t.map(async i=>this.add(i,r)))}start(){return D(this,Os)?(pe(this,Os,!1),ue(this,Pe,Hp).call(this),this):this}pause(){pe(this,Os,!0)}clear(){pe(this,Jt,new(D(this,Gd))),ue(this,Pe,Kv).call(this)}async onEmpty(){D(this,Jt).size!==0&&await ue(this,Pe,ya).call(this,"empty")}async onSizeLessThan(t){D(this,Jt).size<t||await ue(this,Pe,ya).call(this,"next",()=>D(this,Jt).size<t)}async onIdle(){D(this,Kn)===0&&D(this,Jt).size===0||await ue(this,Pe,ya).call(this,"idle")}async onPendingZero(){D(this,Kn)!==0&&await ue(this,Pe,ya).call(this,"pendingZero")}async onRateLimit(){this.isRateLimited||await ue(this,Pe,ya).call(this,"rateLimit")}async onRateLimitCleared(){this.isRateLimited&&await ue(this,Pe,ya).call(this,"rateLimitCleared")}async onError(){return new Promise((t,r)=>{const i=s=>{this.off("error",i),r(s)};this.on("error",i)})}get size(){return D(this,Jt).size}sizeBy(t){return D(this,Jt).filter(t).length}get pending(){return D(this,Kn)}get isPaused(){return D(this,Os)}get isRateLimited(){return D(this,Dl)}get isSaturated(){return D(this,Kn)===D(this,La)&&D(this,Jt).size>0||this.isRateLimited&&D(this,Jt).size>0}get runningTasks(){return[...D(this,Oa).values()].map(t=>({...t}))}},Il=new WeakMap,Ei=new WeakMap,Yi=new WeakMap,Pl=new WeakMap,Dl=new WeakMap,Rl=new WeakMap,Oo=new WeakMap,Hd=new WeakMap,Ll=new WeakMap,Zi=new WeakMap,Ls=new WeakMap,Jt=new WeakMap,Gd=new WeakMap,Kn=new WeakMap,La=new WeakMap,Os=new WeakMap,vg=new WeakMap,Oa=new WeakMap,Pe=new WeakSet,tL=function(){return D(this,Ei)||D(this,Yi)<D(this,Pl)},nL=function(){return D(this,Kn)<D(this,La)},rL=function(){di(this,Kn)._--,D(this,Kn)===0&&this.emit("pendingZero"),ue(this,Pe,Vp).call(this),this.emit("next")},iL=function(){ue(this,Pe,qv).call(this),ue(this,Pe,Wv).call(this),pe(this,Ls,void 0)},sL=function(){const t=Date.now();if(D(this,Zi)===void 0){const r=D(this,Hd)-t;if(r<0){if(D(this,Ll)>0){const i=t-D(this,Ll);if(i<D(this,Oo))return ue(this,Pe,Hv).call(this,D(this,Oo)-i),!0}pe(this,Yi,D(this,Il)?D(this,Kn):0)}else return ue(this,Pe,Hv).call(this,r),!0}return!1},Hv=function(t){D(this,Ls)===void 0&&pe(this,Ls,setTimeout(()=>{ue(this,Pe,iL).call(this)},t))},Gv=function(){D(this,Zi)&&(clearInterval(D(this,Zi)),pe(this,Zi,void 0))},oL=function(){D(this,Ls)&&(clearTimeout(D(this,Ls)),pe(this,Ls,void 0))},Vp=function(){if(D(this,Jt).size===0)return ue(this,Pe,Gv).call(this),this.emit("empty"),D(this,Kn)===0&&(ue(this,Pe,oL).call(this),this.emit("idle")),!1;let t=!1;if(!D(this,Os)){const r=!D(this,Pe,sL);if(D(this,Pe,tL)&&D(this,Pe,nL)){const i=D(this,Jt).dequeue();D(this,Ei)||(di(this,Yi)._++,ue(this,Pe,Eh).call(this)),this.emit("active"),pe(this,Ll,Date.now()),i(),r&&ue(this,Pe,Wv).call(this),t=!0}}return t},Wv=function(){D(this,Ei)||D(this,Zi)!==void 0||(pe(this,Zi,setInterval(()=>{ue(this,Pe,qv).call(this)},D(this,Oo))),pe(this,Hd,Date.now()+D(this,Oo)))},qv=function(){D(this,Yi)===0&&D(this,Kn)===0&&D(this,Zi)&&ue(this,Pe,Gv).call(this),pe(this,Yi,D(this,Il)?D(this,Kn):0),ue(this,Pe,Hp).call(this),ue(this,Pe,Eh).call(this)},Hp=function(){for(;ue(this,Pe,Vp).call(this););},ya=async function(t,r){return new Promise(i=>{const s=()=>{r&&!r()||(this.off(t,s),i())};this.on(t,s)})},aL=function(){D(this,Ei)||(this.on("add",()=>{D(this,Jt).size>0&&ue(this,Pe,Eh).call(this)}),this.on("next",()=>{ue(this,Pe,Eh).call(this)}))},Eh=function(){D(this,Ei)||D(this,Rl)||(pe(this,Rl,!0),queueMicrotask(()=>{pe(this,Rl,!1),ue(this,Pe,Kv).call(this)}))},Kv=function(){const t=D(this,Dl),r=!D(this,Ei)&&D(this,Yi)>=D(this,Pl)&&D(this,Jt).size>0;r!==t&&(pe(this,Dl,r),this.emit(r?"rateLimit":"rateLimitCleared"))},aC);function cL(n){const e=[Qo.A];return n==null?e:Array.isArray(n)?n.length===0?e:n:[n]}const lL=60;function uL(n){return{Status:n.Status??0,TC:n.TC??n.flag_tc??!1,RD:n.RD??n.flag_rd??!1,RA:n.RA??n.flag_ra??!1,AD:n.AD??n.flag_ad??!1,CD:n.CD??n.flag_cd??!1,Question:(n.Question??n.questions??[]).map(e=>({name:e.name,type:Qo[e.type]})),Answer:(n.Answer??n.answers??[]).map(e=>({name:e.name,type:Qo[e.type],TTL:e.TTL??e.ttl??lL,data:e.data instanceof Uint8Array?ne(e.data):e.data}))}}const nZ=4;function oA(n,e={}){const t=new tZ({concurrency:e.queryConcurrency??nZ});return async(r,i={})=>{var a;const s=new URLSearchParams;s.set("name",r),cL(i.types).forEach(c=>{s.append("type",Qo[c])}),(a=i.onProgress)==null||a.call(i,new vt("dns:query",r));const o=await t.add(async()=>{var u;const c=await fetch(`${n}?${s}`,{headers:{accept:"application/dns-json"},signal:i==null?void 0:i.signal});if(c.status!==200)throw new Error(`Unexpected HTTP status: ${c.status} - ${c.statusText}`);const l=uL(await c.json());return(u=i.onProgress)==null||u.call(i,new vt("dns:response",l)),l},{signal:i.signal});if(o==null)throw new Error("No DNS response received");return o}}function rZ(){return[oA("https://cloudflare-dns.com/dns-query"),oA("https://dns.google/resolve")]}var S0,aA;function iZ(){return aA||(aA=1,S0=function(n){if(!n)throw Error("hashlru must have a max value, of type number, greater than 0");var e=0,t=Object.create(null),r=Object.create(null);function i(s,o){t[s]=o,e++,e>=n&&(e=0,r=t,t=Object.create(null))}return{has:function(s){return t[s]!==void 0||r[s]!==void 0},remove:function(s){t[s]!==void 0&&(t[s]=void 0),r[s]!==void 0&&(r[s]=void 0)},get:function(s){var o=t[s];if(o!==void 0)return o;if((o=r[s])!==void 0)return i(s,o),o},set:function(s,o){t[s]!==void 0?t[s]=o:i(s,o)},clear:function(){t=Object.create(null),r=Object.create(null)}}}),S0}var sZ=iZ();const oZ=kE(sZ);class aZ{constructor(e){h(this,"lru");this.lru=oZ(e)}get(e,t){let r=!0;const i=[];for(const s of t){const o=this.getAnswers(e,s);if(o.length===0){r=!1;break}i.push(...o)}if(r)return uL({answers:i})}getAnswers(e,t){const r=`${e.toLowerCase()}-${t}`,i=this.lru.get(r);if(i!=null){const s=i.filter(o=>o.expires>Date.now()).map(({expires:o,value:a})=>({...a,TTL:Math.round((o-Date.now())/1e3),type:Qo[a.type]}));return s.length===0&&this.lru.remove(r),s}return[]}add(e,t){const r=`${e.toLowerCase()}-${t.type}`,i=this.lru.get(r)??[];i.push({expires:Date.now()+(t.TTL??lL)*1e3,value:t}),this.lru.set(r,i)}remove(e,t){const r=`${e.toLowerCase()}-${t}`;this.lru.remove(r)}clear(){this.lru.clear()}}function cZ(n){return new aZ(n)}const lZ=1e3;class uZ{constructor(e){h(this,"resolvers");h(this,"cache");this.resolvers={},this.cache=cZ(e.cacheSize??lZ),Object.entries(e.resolvers??{}).forEach(([t,r])=>{Array.isArray(r)||(r=[r]),t.endsWith(".")||(t=`${t}.`),this.resolvers[t]=r}),this.resolvers["."]==null&&(this.resolvers["."]=rZ())}async query(e,t={}){var c,l,u;const r=cL(t.types),i=t.cached!==!1?this.cache.get(e,r):void 0;if(i!=null)return(c=t.onProgress)==null||c.call(t,new vt("dns:cache",i)),i;const s=`${e.split(".").pop()}.`,o=(this.resolvers[s]??this.resolvers["."]).sort(()=>Math.random()>.5?-1:1),a=[];for(const d of o){if(((l=t.signal)==null?void 0:l.aborted)===!0)break;try{const f=await d(e,{...t,types:r});for(const p of f.Answer)this.cache.add(e,p);return f}catch(f){a.push(f),(u=t.onProgress)==null||u.call(t,new vt("dns:error",f))}}throw a.length===1?a[0]:new AggregateError(a,`DNS lookup of ${e} ${r} failed`)}}var Qo;(function(n){n[n.A=1]="A",n[n.CNAME=5]="CNAME",n[n.TXT=16]="TXT",n[n.AAAA=28]="AAAA"})(Qo||(Qo={}));function hZ(n={}){return new uZ(n)}class dZ{constructor(){h(this,"dns")}canResolve(e){return e.getComponents().some(({name:t})=>t==="dnsaddr")}async resolve(e,t){var c,l;const r=(c=e.getComponents().find(u=>u.name==="dnsaddr"))==null?void 0:c.value;if(r==null)return[e];const s=await this.getDNS(t).query(`_dnsaddr.${r}`,{signal:t==null?void 0:t.signal,types:[Qo.TXT]}),o=(l=e.getComponents().find(u=>u.name==="p2p"))==null?void 0:l.value,a=[];for(const u of s.Answer){const d=u.data.replace(/["']/g,"").trim().split("=")[1];d!=null&&(o!=null&&!d.includes(o)||a.push(Qn(d)))}return a}getDNS(e){return e.dns!=null?e.dns:(this.dns==null&&(this.dns=hZ()),this.dns)}}const hL=new dZ;async function dL(n,e,t){const r=t.depth??0;if(r>(t.maxRecursiveDepth??FY))throw new _Y("Max recursive depth reached");let i=!1;const s=[];for(const o of Object.values(e))if(o.canResolve(n)){i=!0;const a=await o.resolve(n,t);for(const c of a)s.push(...await dL(c,e,{...t,depth:r+1}))}return i===!1&&s.push(n),s}const uh={maxParallelDials:QR,maxDialQueueLength:JR,maxPeerAddrsToDial:jR,dialTimeout:YR,resolvers:{dnsaddr:hL}};class fZ{constructor(e,t={}){h(this,"queue");h(this,"components");h(this,"addressSorter");h(this,"maxPeerAddrsToDial");h(this,"maxDialQueueLength");h(this,"dialTimeout");h(this,"shutDownController");h(this,"connections");h(this,"log");h(this,"resolvers");this.addressSorter=t.addressSorter,this.maxPeerAddrsToDial=t.maxPeerAddrsToDial??uh.maxPeerAddrsToDial,this.maxDialQueueLength=t.maxDialQueueLength??uh.maxDialQueueLength,this.dialTimeout=t.dialTimeout??uh.dialTimeout,this.connections=t.connections??new Nu,this.log=e.logger.forComponent("libp2p:connection-manager:dial-queue"),this.components=e,this.resolvers=t.resolvers??uh.resolvers,this.shutDownController=new AbortController,this.shutDownController.signal,this.queue=new bG({concurrency:t.maxParallelDials??uh.maxParallelDials,metricName:"libp2p_dial_queue",metrics:e.metrics}),this.queue.addEventListener("failure",r=>{var i;((i=r.detail)==null?void 0:i.error.name)!==sH.name&&this.log.error("error in dial queue - %e",r.detail.error)})}start(){this.shutDownController=new AbortController,this.shutDownController.signal}stop(){this.shutDownController.abort(),this.queue.abort()}async dial(e,t={}){var o,a,c;const{peerId:r,multiaddrs:i}=qR(e);if(r!=null&&t.force!==!0){const l=XR(r,this.connections.get(r),i);if(l!=null)return this.log("already connected to %a",l.remoteAddr),(o=t.onProgress)==null||o.call(t,new vt("dial-queue:already-connected")),l}const s=this.queue.queue.find(l=>{if((r==null?void 0:r.equals(l.options.peerId))===!0)return!0;const u=l.options.multiaddrs;if(u==null)return!1;for(const d of i)if(u.has(d.toString()))return!0;return!1});if(s!=null){this.log("joining existing dial target for %p",r);for(const l of i)s.options.multiaddrs.add(l.toString());return(a=t.onProgress)==null||a.call(t,new vt("dial-queue:already-in-dial-queue")),s.join(t)}if(this.queue.size>=this.maxDialQueueLength)throw new s0("Dial queue is full");return this.log("creating dial target for %p",r,i.map(l=>l.toString())),(c=t.onProgress)==null||c.call(t,new vt("dial-queue:add-to-dial-queue")),this.queue.add(async l=>{var d;(d=l.onProgress)==null||d.call(l,new vt("dial-queue:start-dial"));const u=Ja([this.shutDownController.signal,l.signal]);try{return await this.dialPeer(l,u)}finally{u.clear()}},{peerId:r,priority:t.priority??fL,multiaddrs:new Set(i.map(l=>l.toString())),signal:t.signal??AbortSignal.timeout(this.dialTimeout),onProgress:t.onProgress})}async dialPeer(e,t){var u;const r=e.peerId,i=e.multiaddrs,s=new Set;let o=e.multiaddrs.size===0,a=0,c=0;const l=[];for(this.log("starting dial to %p",r);o||i.size>0;){c++,o=!1;const d=[],f=new Set(e.multiaddrs);i.clear(),this.log("calculating addrs to dial %p from %s",r,[...f]);const p=await this.calculateMultiaddrs(r,f,{...e,signal:t});for(const g of p){if(s.has(g.multiaddr.toString())){this.log.trace("skipping previously failed multiaddr %a while dialing %p",g.multiaddr,r);continue}d.push(g)}this.log("%s dial to %p with %s",c===1?"starting":"continuing",r,d.map(g=>g.multiaddr.toString())),(u=e==null?void 0:e.onProgress)==null||u.call(e,new vt("dial-queue:calculated-addresses",d));for(const g of d){if(a===this.maxPeerAddrsToDial)throw this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others",a,e.peerId),new s0("Peer had more than maxPeerAddrsToDial");a++;try{const b=await this.components.transportManager.dial(g.multiaddr,{...e,signal:t});this.log("dial to %a succeeded",g.multiaddr);try{await this.components.peerStore.merge(b.remotePeer,{multiaddrs:[b.remoteAddr],metadata:{[$Y]:ge(Date.now().toString())}})}catch(m){this.log.error("could not update last dial failure key for %p - %e",r,m)}return b}catch(b){if(this.log.error("dial failed to %a - %e",g.multiaddr,b),s.add(g.multiaddr.toString()),r!=null)try{await this.components.peerStore.merge(r,{metadata:{[kY]:ge(Date.now().toString())}})}catch(m){this.log.error("could not update last dial failure key for %p - %e",r,m)}if(t.aborted)throw new lH(b.message);l.push(b)}}}throw l.length===1?l[0]:new AggregateError(l,"All multiaddr dials failed")}async calculateMultiaddrs(e,t=new Set,r={}){var d,f;const i=[...t].map(p=>({multiaddr:Qn(p),isCertified:!1}));if(e!=null){if(this.components.peerId.equals(e))throw new s0("Tried to dial self");if(await((f=(d=this.components.connectionGater).denyDialPeer)==null?void 0:f.call(d,e))===!0)throw new rA("The dial request is blocked by gater.allowDialPeer");if(i.length===0){this.log("loading multiaddrs for %p",e);try{const p=await this.components.peerStore.get(e);i.push(...p.addresses),this.log("loaded multiaddrs for %p",e,i.map(({multiaddr:g})=>g.toString()))}catch(p){if(p.name!=="NotFoundError")throw p}}if(i.length===0){this.log("looking up multiaddrs for %p in the peer routing",e);try{const p=await this.components.peerRouting.findPeer(e,r);this.log("found multiaddrs for %p in the peer routing",e,i.map(({multiaddr:g})=>g.toString())),i.push(...p.multiaddrs.map(g=>({multiaddr:g,isCertified:!1})))}catch(p){p.name==="NoPeerRoutersError"?this.log("no peer routers configured",e):this.log.error("looking up multiaddrs for %p in the peer routing failed - %e",e,p)}}}let s=(await Promise.all(i.map(async p=>{const g=await dL(p.multiaddr,this.resolvers,{dns:this.components.dns,log:this.log,...r});return g.length===1&&g[0].equals(p.multiaddr)?p:g.map(b=>({multiaddr:b,isCertified:!1}))}))).flat();if(e!=null){const p=`/p2p/${e.toString()}`;s=s.map(g=>{const b=g.multiaddr.getComponents().pop();return(b==null?void 0:b.name)!=="p2p"?{multiaddr:g.multiaddr.encapsulate(p),isCertified:g.isCertified}:g})}const o=s.filter(p=>{var b;if(this.components.transportManager.dialTransportForMultiaddr(p.multiaddr)==null)return!1;const g=(b=p.multiaddr.getComponents().findLast(m=>m.code===us))==null?void 0:b.value;return e!=null&&g!=null?e.equals(g):!0}),a=new Map;for(const p of o){const g=p.multiaddr.toString(),b=a.get(g);if(b!=null){b.isCertified=b.isCertified||p.isCertified||!1;continue}a.set(g,p)}const c=[...a.values()];if(c.length===0)throw new yY("The dial request has no valid addresses");const l=[];for(const p of c)this.components.connectionGater.denyDialMultiaddr!=null&&await this.components.connectionGater.denyDialMultiaddr(p.multiaddr)||l.push(p);const u=this.addressSorter==null?KY(l):l.sort(this.addressSorter);if(u.length===0)throw new rA("The connection gater denied all addresses in the dial request");return this.log.trace("addresses for %p before filtering",e??"unknown peer",s.map(({multiaddr:p})=>p.toString())),this.log.trace("addresses for %p after filtering",e??"unknown peer",u.map(({multiaddr:p})=>p.toString())),u}async isDialable(e,t={}){Array.isArray(e)||(e=[e]);try{const r=await this.calculateMultiaddrs(void 0,new Set(e.map(i=>i.toString())),t);return t.runOnLimitedConnection===!1?r.find(i=>!pu.matches(i.multiaddr))!=null:!0}catch{}return!1}}const pZ=Object.prototype.toString,mZ=n=>pZ.call(n)==="[object Error]",gZ=new Set(["network error","Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Network request failed","fetch failed","terminated"," A network error occurred.","Network connection lost"]);function yZ(n){if(!(n&&mZ(n)&&n.name==="TypeError"&&typeof n.message=="string"))return!1;const{message:t,stack:r}=n;return t==="Load failed"?r===void 0||"__sentry_captured__"in n:t.startsWith("error sending request for url")?!0:gZ.has(t)}function bZ(n){if(typeof n=="number"){if(n<0)throw new TypeError("Expected `retries` to be a non-negative number.");if(Number.isNaN(n))throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.")}else if(n!==void 0)throw new TypeError("Expected `retries` to be a number or Infinity.")}function ap(n,e,{min:t=0,allowInfinity:r=!1}={}){if(e!==void 0){if(typeof e!="number"||Number.isNaN(e))throw new TypeError(`Expected \`${n}\` to be a number${r?" or Infinity":""}.`);if(!r&&!Number.isFinite(e))throw new TypeError(`Expected \`${n}\` to be a finite number.`);if(e<t)throw new TypeError(`Expected \`${n}\` to be  ${t}.`)}}let wZ=class extends Error{constructor(e){super(),e instanceof Error?(this.originalError=e,{message:e}=e):(this.originalError=new Error(e),this.originalError.stack=this.stack),this.name="AbortError",this.message=e}};function vZ(n,e){const t=Math.max(1,n+1),r=e.randomize?Math.random()+1:1;let i=Math.round(r*e.minTimeout*e.factor**(t-1));return i=Math.min(i,e.maxTimeout),i}function cA(n,e){return Number.isFinite(e)?e-(performance.now()-n):e}async function _Z({error:n,attemptNumber:e,retriesConsumed:t,startTime:r,options:i}){var p,g,b;const s=n instanceof Error?n:new TypeError(`Non-error was thrown: "${n}". You should only throw errors.`);if(s instanceof wZ)throw s.originalError;const o=Number.isFinite(i.retries)?Math.max(0,i.retries-t):i.retries,a=i.maxRetryTime??Number.POSITIVE_INFINITY,c=Object.freeze({error:s,attemptNumber:e,retriesLeft:o,retriesConsumed:t});if(await i.onFailedAttempt(c),cA(r,a)<=0)throw s;const l=await i.shouldConsumeRetry(c),u=cA(r,a);if(u<=0||o<=0)throw s;if(s instanceof TypeError&&!yZ(s)){if(l)throw s;return(p=i.signal)==null||p.throwIfAborted(),!1}if(!await i.shouldRetry(c))throw s;if(!l)return(g=i.signal)==null||g.throwIfAborted(),!1;const d=vZ(t,i),f=Math.min(d,u);return f>0&&await new Promise((m,y)=>{var x,M;const E=()=>{var A;clearTimeout(w),(A=i.signal)==null||A.removeEventListener("abort",E),y(i.signal.reason)},w=setTimeout(()=>{var A;(A=i.signal)==null||A.removeEventListener("abort",E),m()},f);i.unref&&((x=w.unref)==null||x.call(w)),(M=i.signal)==null||M.addEventListener("abort",E,{once:!0})}),(b=i.signal)==null||b.throwIfAborted(),!0}async function EZ(n,e={}){var s,o,a;if(e={...e},bZ(e.retries),Object.hasOwn(e,"forever"))throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");e.retries??(e.retries=10),e.factor??(e.factor=2),e.minTimeout??(e.minTimeout=1e3),e.maxTimeout??(e.maxTimeout=Number.POSITIVE_INFINITY),e.maxRetryTime??(e.maxRetryTime=Number.POSITIVE_INFINITY),e.randomize??(e.randomize=!1),e.onFailedAttempt??(e.onFailedAttempt=()=>{}),e.shouldRetry??(e.shouldRetry=()=>!0),e.shouldConsumeRetry??(e.shouldConsumeRetry=()=>!0),ap("factor",e.factor,{min:0,allowInfinity:!1}),ap("minTimeout",e.minTimeout,{min:0,allowInfinity:!1}),ap("maxTimeout",e.maxTimeout,{min:0,allowInfinity:!0}),ap("maxRetryTime",e.maxRetryTime,{min:0,allowInfinity:!0}),e.factor>0||(e.factor=1),(s=e.signal)==null||s.throwIfAborted();let t=0,r=0;const i=performance.now();for(;!Number.isFinite(e.retries)||r<=e.retries;){t++;try{(o=e.signal)==null||o.throwIfAborted();const c=await n(t);return(a=e.signal)==null||a.throwIfAborted(),c}catch(c){await _Z({error:c,attemptNumber:t,retriesConsumed:r,startTime:i,options:e})&&r++}}throw new Error("Retry attempts exhausted without throwing an error.")}class SZ{constructor(e,t={}){h(this,"log");h(this,"queue");h(this,"started");h(this,"peerStore");h(this,"retries");h(this,"retryInterval");h(this,"backoffFactor");h(this,"connectionManager");h(this,"events");this.log=e.logger.forComponent("libp2p:reconnect-queue"),this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.queue=new HE({concurrency:t.maxParallelReconnects??BY,metricName:"libp2p_reconnect_queue",metrics:e.metrics}),this.started=!1,this.retries=t.retries??5,this.backoffFactor=t.backoffFactor,this.retryInterval=t.retryInterval,this.events=e.events,e.events.addEventListener("peer:disconnect",r=>{this.maybeReconnect(r.detail).catch(i=>{this.log.error("failed to maybe reconnect to %p - %e",r.detail,i)})})}async maybeReconnect(e){if(!this.started)return;const t=await this.peerStore.get(e);lA(t)&&(this.queue.has(e)||this.queue.add(async r=>{await EZ(async i=>{if(this.started)try{await this.connectionManager.openConnection(e,{signal:r==null?void 0:r.signal})}catch(s){throw this.log("reconnecting to %p attempt %d of %d failed - %e",e,i,this.retries,s),s}},{signal:r==null?void 0:r.signal,retries:this.retries,factor:this.backoffFactor,minTimeout:this.retryInterval})},{peerId:e}).catch(async r=>{this.log.error("failed to reconnect to %p - %e",e,r);const i={};[...t.tags.keys()].forEach(s=>{s.startsWith(cD)&&(i[s]=void 0)}),await this.peerStore.merge(e,{tags:i}),this.events.safeDispatchEvent("peer:reconnect-failure",{detail:e})}).catch(async r=>{this.log.error("failed to remove keep-alive tag from %p - %e",e,r)}))}start(){this.started=!0}async afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[t=>lA(t)]});await Promise.all(e.map(async t=>{await this.connectionManager.openConnection(t.id).catch(r=>{this.log.error("could not open connection to keepalive peer - %e",r)})}))}).catch(e=>{this.log.error("error reconnect to peers after start - %e",e)})}stop(){this.started=!1,this.queue.abort()}}function lA(n){for(const e of n.tags.keys())if(e.startsWith(cD))return!0;return!1}const fL=50,x0={maxConnections:zY,inboundConnectionThreshold:NY,maxIncomingPendingConnections:UY};var cC;cC=Symbol.toStringTag;class xZ{constructor(e,t={}){h(this,"started");h(this,"connections");h(this,"allow");h(this,"deny");h(this,"maxIncomingPendingConnections");h(this,"incomingPendingConnections");h(this,"outboundPendingConnections");h(this,"maxConnections");h(this,"dialQueue");h(this,"reconnectQueue");h(this,"connectionPruner");h(this,"inboundConnectionRateLimiter");h(this,"peerStore");h(this,"metrics");h(this,"events");h(this,"log");h(this,"peerId");h(this,cC,"@libp2p/connection-manager");var r;if(this.maxConnections=t.maxConnections??x0.maxConnections,this.maxConnections<1)throw new zr("Connection Manager maxConnections must be greater than 0");this.connections=new Nu,this.started=!1,this.peerId=e.peerId,this.peerStore=e.peerStore,this.metrics=e.metrics,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager"),this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.allow=(t.allow??[]).map(i=>Vv(Qn(i))),this.deny=(t.deny??[]).map(i=>Vv(Qn(i))),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=t.maxIncomingPendingConnections??x0.maxIncomingPendingConnections,this.outboundPendingConnections=0,this.inboundConnectionRateLimiter=new wG({points:t.inboundConnectionThreshold??x0.inboundConnectionThreshold,duration:1}),this.connectionPruner=new LY({connectionManager:this,peerStore:e.peerStore,events:e.events,logger:e.logger},{allow:(r=t.allow)==null?void 0:r.map(i=>Qn(i))}),this.dialQueue=new fZ(e,{addressSorter:t.addressSorter,maxParallelDials:t.maxParallelDials??QR,maxDialQueueLength:t.maxDialQueueLength??JR,maxPeerAddrsToDial:t.maxPeerAddrsToDial??jR,dialTimeout:t.dialTimeout??YR,resolvers:t.resolvers??{dnsaddr:hL},connections:this.connections}),this.reconnectQueue=new SZ({events:e.events,peerStore:e.peerStore,logger:e.logger,connectionManager:this},{retries:t.reconnectRetries,retryInterval:t.reconnectRetryInterval,backoffFactor:t.reconnectBackoffFactor,maxParallelReconnects:t.maxParallelReconnects})}async start(){var e,t,r;(e=this.metrics)==null||e.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const i={inbound:0,"inbound pending":this.incomingPendingConnections,outbound:0,"outbound pending":this.outboundPendingConnections};for(const s of this.connections.values())for(const o of s)i[o.direction]++;return i}}),(t=this.metrics)==null||t.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const i={};for(const s of this.connections.values())for(const o of s)for(const a of o.streams){const c=`${a.direction} ${a.protocol??"unnegotiated"}`;i[c]=(i[c]??0)+1}return i}}),(r=this.metrics)==null||r.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const i={};for(const o of this.connections.values())for(const a of o){const c={};for(const l of a.streams){const u=`${l.direction} ${l.protocol??"unnegotiated"}`;c[u]=(c[u]??0)+1}for(const[l,u]of Object.entries(c))i[l]=i[l]??[],i[l].push(u)}const s={};for(let[o,a]of Object.entries(i)){a=a.sort((l,u)=>l-u);const c=Math.floor(a.length*.9);s[o]=a[c]}return s}}),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),await pH(this.dialQueue,this.reconnectQueue,this.connectionPruner),this.started=!0,this.log("started")}async stop(){this.events.removeEventListener("connection:open",this.onConnect),this.events.removeEventListener("connection:close",this.onDisconnect),await mH(this.reconnectQueue,this.dialQueue,this.connectionPruner);const e=[];for(const t of this.connections.values())for(const r of t)e.push(Promise.all([bn(r,"close",{signal:AbortSignal.timeout(500)}),r.close({signal:AbortSignal.timeout(500)})]).catch(i=>{r.abort(i)}));this.log("closing %d connections",e.length),await Promise.all(e),this.connections.clear(),this.log("stopped")}getMaxConnections(){return this.maxConnections}setMaxConnections(e){if(this.maxConnections<1)throw new zr("Connection Manager maxConnections must be greater than 0");let t=!1;e<this.maxConnections&&(t=!0),this.maxConnections=e,t&&this.connectionPruner.maybePruneConnections()}onConnect(e){this._onConnect(e).catch(t=>{this.log.error("could not connect - %e",t)})}async _onConnect(e){const{detail:t}=e;if(!this.started){await t.close();return}if(t.status!=="open")return;const r=t.remotePeer,i=!this.connections.has(r),s=this.connections.get(r)??[];s.push(t),this.connections.set(r,s),r.publicKey!=null&&r.type==="RSA"&&await this.peerStore.patch(r,{publicKey:r.publicKey}),i&&this.events.safeDispatchEvent("peer:connect",{detail:t.remotePeer})}onDisconnect(e){const{detail:t}=e,r=t.remotePeer,s=(this.connections.get(r)??[]).filter(o=>o.id!==t.id);this.connections.set(r,s),s.length===0&&(this.log.trace("peer %p disconnected, removing connection map entry",r),this.connections.delete(r),this.events.safeDispatchEvent("peer:disconnect",{detail:r}))}getConnections(e){if(e!=null)return this.connections.get(e)??[];let t=[];for(const r of this.connections.values())t=t.concat(r);return t}getConnectionsMap(){return this.connections}async openConnection(e,t={}){var r,i;if(!this.started)throw new wm("Not started");this.outboundPendingConnections++;try{(r=t.signal)==null||r.throwIfAborted();const{peerId:s,multiaddrs:o}=qR(e);if(this.peerId.equals(s))throw new CE("Can not dial self");if(s!=null&&t.force!==!0){this.log("dial %p",s);const u=XR(s,this.getConnections(s),o);if(u!=null)return this.log("had an existing connection to %p as %a",s,u.remoteAddr),(i=t.onProgress)==null||i.call(t,new vt("dial-queue:already-connected")),u}const a=await this.dialQueue.dial(e,{...t,priority:t.priority??fL});if(a.status!=="open")throw new bm("Remote closed connection during opening");let c=this.connections.get(a.remotePeer);c==null&&(c=[],this.connections.set(a.remotePeer,c));let l=!1;for(const u of c)if(u.id===a.id&&(l=!0),t.force!==!0&&u.id!==a.id&&u.remoteAddr.equals(a.remoteAddr))return a.abort(new IE("Duplicate multiaddr connection")),u;return l||c.push(a),a}finally{this.outboundPendingConnections--}}async openStream(e,t,r={}){return(await this.openConnection(e,r)).newStream(t,r)}async closeConnections(e,t={}){const r=this.connections.get(e)??[];await Promise.all(r.map(async i=>{try{await Promise.all([bn(i,"close",t),i.close(t)])}catch(s){i.abort(s)}}))}acceptIncomingConnection(e){if(this.deny.some(i=>{if(Ni(e.remoteAddr)){const s=Rt(e.remoteAddr);return i.contains(s.host)}return!1}))return this.log("connection from %a refused - connection remote address was in deny list",e.remoteAddr),!1;if(this.allow.some(i=>{if(Ni(e.remoteAddr)){const s=Rt(e.remoteAddr);return i.contains(s.host)}return!0}))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return this.log("connection from %a refused - incomingPendingConnections exceeded by host",e.remoteAddr),!1;if(Ni(e.remoteAddr)){const i=Rt(e.remoteAddr);try{this.inboundConnectionRateLimiter.consume(i.host,1)}catch{return this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s",e.remoteAddr,i.host),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(this.log("connection from %a refused - maxConnections exceeded",e.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){const e={queued:"queued",running:"active",errored:"error",complete:"success"};return this.dialQueue.queue.queue.map(t=>({id:t.id,status:e[t.status],peerId:t.options.peerId,multiaddrs:[...t.options.multiaddrs].map(r=>Qn(r))}))}async isDialable(e,t={}){return this.dialQueue.isDialable(e,t)}}const TZ=1e4,AZ="1.0.0",MZ="ping",CZ="ipfs",uA=32,IZ=!0;var lC,uC;uC=Symbol.toStringTag,lC=Cv;class PZ{constructor(e,t={}){h(this,"protocol");h(this,"components");h(this,"log");h(this,"heartbeatInterval");h(this,"pingIntervalMs");h(this,"abortController");h(this,"timeout");h(this,"abortConnectionOnPingFailure");h(this,uC,"@libp2p/connection-monitor");h(this,lC,["@libp2p/connection-monitor"]);this.components=e,this.protocol=`/${t.protocolPrefix??CZ}/${MZ}/${AZ}`,this.log=e.logger.forComponent("libp2p:connection-monitor"),this.pingIntervalMs=t.pingInterval??TZ,this.abortConnectionOnPingFailure=t.abortConnectionOnPingFailure??IZ,this.timeout=new tG({...t.pingTimeout??{},metrics:e.metrics,metricName:"libp2p_connection_monitor_ping_time_milliseconds"})}start(){this.abortController=new AbortController,this.abortController.signal,this.heartbeatInterval=setInterval(()=>{this.components.connectionManager.getConnections().forEach(e=>{Promise.resolve().then(async()=>{var r;let t=Date.now();try{const i=this.timeout.getTimeoutSignal({signal:(r=this.abortController)==null?void 0:r.signal}),s=await e.newStream(this.protocol,{signal:i,runOnLimitedConnection:!0}),o=BD(s);t=Date.now(),await Promise.all([o.write(TE(uA),{signal:i}),o.read({bytes:uA,signal:i})]),e.rtt=Date.now()-t,await s.close({signal:i})}catch(i){if(i.name!=="UnsupportedProtocolError")throw i;e.rtt=(Date.now()-t)/2}}).catch(t=>{this.log.error("error during heartbeat - %e",t),this.abortConnectionOnPingFailure?(this.log.error("aborting connection due to ping failure"),e.abort(t)):this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag")})})},this.pingIntervalMs)}stop(){var e;(e=this.abortController)==null||e.abort(),this.heartbeatInterval!=null&&clearInterval(this.heartbeatInterval)}}var hC;hC=Symbol.toStringTag;class DZ{constructor(e,t){h(this,"routers");h(this,"started");h(this,"components");h(this,hC,"@libp2p/content-routing");var r,i,s,o,a;this.routers=t.routers??[],this.started=!1,this.components=e,this.findProviders=((r=e.metrics)==null?void 0:r.traceFunction("libp2p.contentRouting.findProviders",this.findProviders.bind(this),{optionsIndex:1,getAttributesFromArgs:([c],l)=>({...l,cid:c.toString()}),getAttributesFromYieldedValue:(c,l)=>({...l,providers:[...Array.isArray(l.providers)?l.providers:[],c.id.toString()]})}))??this.findProviders,this.provide=((i=e.metrics)==null?void 0:i.traceFunction("libp2p.contentRouting.provide",this.provide.bind(this),{optionsIndex:1,getAttributesFromArgs:([c],l)=>({...l,cid:c.toString()})}))??this.provide,this.cancelReprovide=((s=e.metrics)==null?void 0:s.traceFunction("libp2p.contentRouting.cancelReprovide",this.cancelReprovide.bind(this),{optionsIndex:1,getAttributesFromArgs:([c],l)=>({...l,cid:c.toString()})}))??this.cancelReprovide,this.put=((o=e.metrics)==null?void 0:o.traceFunction("libp2p.contentRouting.put",this.put.bind(this),{optionsIndex:2,getAttributesFromArgs:([c])=>({key:ne(c,"base36")})}))??this.put,this.get=((a=e.metrics)==null?void 0:a.traceFunction("libp2p.contentRouting.get",this.get.bind(this),{optionsIndex:1,getAttributesFromArgs:([c])=>({key:ne(c,"base36")})}))??this.get}isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(e,t={}){if(this.routers.length===0)throw new _0("No content routers available");const r=this,i=new _D;for await(const s of Rv(...r.routers.filter(o=>o.findProviders instanceof Function).map(o=>o.findProviders(e,t))))s!=null&&(s.multiaddrs.length>0&&await this.components.peerStore.merge(s.id,{multiaddrs:s.multiaddrs},t),!i.has(s.id)&&(i.add(s.id),yield s))}async provide(e,t={}){if(this.routers.length===0)throw new _0("No content routers available");await Promise.all(this.routers.filter(r=>r.provide instanceof Function).map(async r=>{await r.provide(e,t)}))}async cancelReprovide(e,t={}){if(this.routers.length===0)throw new _0("No content routers available");await Promise.all(this.routers.filter(r=>r.cancelReprovide instanceof Function).map(async r=>{await r.cancelReprovide(e,t)}))}async put(e,t,r){if(!this.isStarted())throw new wm;await Promise.all(this.routers.filter(i=>i.put instanceof Function).map(async i=>{await i.put(e,t,r)}))}async get(e,t){if(!this.isStarted())throw new wm;return Promise.any(this.routers.filter(r=>r.get instanceof Function).map(async r=>r.get(e,t)))}}const cp=globalThis.CustomEvent??Event;async function*RZ(n,e={}){let t=e.concurrency??1/0;t<1&&(t=1/0);const r=e.ordered??!1,i=new EventTarget,s=[];let o=Qr(),a=Qr(),c=!1,l,u=!1;i.addEventListener("task-complete",()=>{a.resolve()}),Promise.resolve().then(async()=>{try{for await(const g of n){if(s.length===t&&(o=Qr(),await o.promise),u)break;const b={done:!1};s.push(b),g().then(m=>{b.done=!0,b.ok=!0,b.value=m,i.dispatchEvent(new cp("task-complete"))},m=>{b.done=!0,b.err=m,i.dispatchEvent(new cp("task-complete"))})}c=!0,i.dispatchEvent(new cp("task-complete"))}catch(g){l=g,i.dispatchEvent(new cp("task-complete"))}});function d(){var g;return r?(g=s[0])==null?void 0:g.done:!!s.find(b=>b.done)}function*f(){for(;s.length>0&&s[0].done;){const g=s[0];if(s.shift(),g.ok)yield g.value;else throw u=!0,o.resolve(),g.err;o.resolve()}}function*p(){for(;d();)for(let g=0;g<s.length;g++)if(s[g].done){const b=s[g];if(s.splice(g,1),g--,b.ok)yield b.value;else throw u=!0,o.resolve(),b.err;o.resolve()}}for(;;){if(d()||(a=Qr(),await a.promise),l!=null||(r?yield*f():yield*p(),l!=null))throw l;if(c&&s.length===0)break}}var dC;dC=Symbol.toStringTag;class LZ{constructor(e,t={}){h(this,"log");h(this,"peerId");h(this,"peerStore");h(this,"routers");h(this,dC,"@libp2p/peer-routing");var r,i;this.log=e.logger.forComponent("libp2p:peer-routing"),this.peerId=e.peerId,this.peerStore=e.peerStore,this.routers=t.routers??[],this.findPeer=((r=e.metrics)==null?void 0:r.traceFunction("libp2p.peerRouting.findPeer",this.findPeer.bind(this),{optionsIndex:1,getAttributesFromArgs:([s],o)=>({...o,peer:s.toString()})}))??this.findPeer,this.getClosestPeers=((i=e.metrics)==null?void 0:i.traceFunction("libp2p.peerRouting.getClosestPeers",this.getClosestPeers.bind(this),{optionsIndex:1,getAttributesFromArgs:([s],o)=>({...o,key:ne(s,"base36")}),getAttributesFromYieldedValue:(s,o)=>({...o,peers:[...Array.isArray(o.peers)?o.peers:[],s.id.toString()]})}))??this.getClosestPeers}async findPeer(e,t){if(this.routers.length===0)throw new nA("No peer routers available");if(e.toString()===this.peerId.toString())throw new dY("Should not try to find self");const r=this,i=Rv(...this.routers.filter(s=>s.findPeer instanceof Function).map(s=>(async function*(){try{yield await s.findPeer(e,t)}catch(o){r.log.error("router failed to find peer - %e",o)}})()));for await(const s of i)if(s!=null)return s.multiaddrs.length>0&&await this.peerStore.merge(s.id,{multiaddrs:s.multiaddrs},t),s;throw new oH}async*getClosestPeers(e,t={}){if(this.routers.length===0)throw new nA("No peer routers available");const r=this,i=ld(1024);for await(const s of RZ((async function*(){const o=Rv(...r.routers.filter(a=>a.getClosestPeers instanceof Function).map(a=>a.getClosestPeers(e,t)));for await(let a of o)yield async()=>{if(a.multiaddrs.length===0)try{a=await r.findPeer(a.id,{...t,useCache:!1})}catch(c){r.log.error("could not find peer multiaddrs - %e",c);return}return a}})()))s!=null&&(s.multiaddrs.length>0&&await this.peerStore.merge(s.id,{multiaddrs:s.multiaddrs},t),!i.has(s.id.toMultihash().bytes)&&(i.add(s.id.toMultihash().bytes),yield s))}}var fC,pC;class OZ extends(pC=fr,fC=Symbol.toStringTag,pC){constructor(t){super();h(this,"peerRouting");h(this,"log");h(this,"walking");h(this,"walkers");h(this,"shutdownController");h(this,"walkController");h(this,"needNext");h(this,fC,"@libp2p/random-walk");this.log=t.logger.forComponent("libp2p:random-walk"),this.peerRouting=t.peerRouting,this.walkers=0,this.walking=!1,this.shutdownController=new AbortController,this.shutdownController.signal}start(){this.shutdownController=new AbortController,this.shutdownController.signal}stop(){this.shutdownController.abort()}async*walk(t){var i,s;this.walking||this.startWalk(),this.walkers++;const r=Ja([this.shutdownController.signal,t==null?void 0:t.signal]);try{for(;;)(i=this.needNext)==null||i.resolve(),this.needNext=Qr(),yield(await bn(this,"walk:peer",{signal:r,rejectionEvents:["walk:error"]})).detail}catch(o){throw o.detail!=null?o.detail:o}finally{r.clear(),this.walkers--,this.walkers===0&&((s=this.walkController)==null||s.abort(),this.walkController=void 0)}}startWalk(){this.walking=!0,this.walkController=new AbortController,this.walkController.signal;const t=Ja([this.walkController.signal,this.shutdownController.signal]),r=Date.now();let i=0;Promise.resolve().then(async()=>{for(this.log("start walk");this.walkers>0;)try{const s=TE(32);let o=Date.now();for await(const a of this.peerRouting.getClosestPeers(s,{signal:t}))t.aborted&&this.log("aborting walk"),t.throwIfAborted(),this.log("found peer %p after %dms for %d walkers",a.id,Date.now()-o,this.walkers),i++,this.safeDispatchEvent("walk:peer",{detail:a}),this.walkers===1&&this.needNext!=null&&(this.log("wait for need next"),await Vi(this.needNext.promise,t)),o=Date.now();this.log("walk iteration for %b and %d walkers finished, found %d peers",s,this.walkers,i)}catch(s){this.log.error("random walk errored - %e",s),this.safeDispatchEvent("walk:error",{detail:s})}this.log("no walkers left, ended walk")}).catch(s=>{this.log.error("random walk errored - %e",s)}).finally(()=>{this.log("finished walk, found %d peers after %dms",i,Date.now()-r),this.walking=!1})}}const pL=32,mL=64;var mC;mC=Symbol.toStringTag;class NZ{constructor(e){h(this,"log");h(this,"topologies");h(this,"handlers");h(this,"components");h(this,"middleware");h(this,mC,"@libp2p/registrar");var t;this.components=e,this.log=e.logger.forComponent("libp2p:registrar"),this.middleware=new Map,this.topologies=new Map,(t=e.metrics)==null||t.registerMetricGroup("libp2p_registrar_topologies",{calculate:()=>{const r={};for(const[i,s]of this.topologies)r[i]=s.size;return r}}),this.handlers=ro({name:"libp2p_registrar_protocol_handlers",metrics:e.metrics}),this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onPeerIdentify=this._onPeerIdentify.bind(this),this.components.events.addEventListener("peer:disconnect",this._onDisconnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate),this.components.events.addEventListener("peer:identify",this._onPeerIdentify)}getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(e){const t=this.handlers.get(e);if(t==null)throw new fY(`No handler registered for protocol ${e}`);return t}getTopologies(e){const t=this.topologies.get(e);return t==null?[]:[...t.values()]}async handle(e,t,r){if(this.handlers.has(e)&&(r==null?void 0:r.force)!==!0)throw new pY(`Handler already registered for protocol ${e}`);this.handlers.set(e,{handler:t,options:{maxInboundStreams:pL,maxOutboundStreams:mL,...r}}),await this.components.peerStore.merge(this.components.peerId,{protocols:[e]},r)}async unhandle(e,t){(Array.isArray(e)?e:[e]).forEach(i=>{this.handlers.delete(i)}),await this.components.peerStore.patch(this.components.peerId,{protocols:this.getProtocols()},t)}async register(e,t){if(t==null)throw new zr("invalid topology");const r=`${(Math.random()*1e9).toString(36)}${Date.now()}`;let i=this.topologies.get(e);return i==null&&(i=new Map,this.topologies.set(e,i)),i.set(r,t),r}unregister(e){for(const[t,r]of this.topologies.entries())r.has(e)&&(r.delete(e),r.size===0&&this.topologies.delete(t))}use(e,t){this.middleware.set(e,t)}unuse(e){this.middleware.delete(e)}getMiddleware(e){return this.middleware.get(e)??[]}async _onDisconnect(e){const t=e.detail,r={signal:AbortSignal.timeout(5e3)};try{const i=await this.components.peerStore.get(t,r);for(const s of i.protocols){const o=this.topologies.get(s);o!=null&&await Promise.all([...o.values()].map(async a=>{var c,l,u;((c=a.filter)==null?void 0:c.has(t))!==!1&&((l=a.filter)==null||l.remove(t),await((u=a.onDisconnect)==null?void 0:u.call(a,t)))}))}}catch(i){if(i.name==="NotFoundError")return;this.log.error("could not inform topologies of disconnecting peer %p - %e",t,i)}}async _onPeerUpdate(e){const{peer:t,previous:r}=e.detail,i=((r==null?void 0:r.protocols)??[]).filter(s=>!t.protocols.includes(s));try{for(const s of i){const o=this.topologies.get(s);o!=null&&await Promise.all([...o.values()].map(async a=>{var c,l,u;((c=a.filter)==null?void 0:c.has(t.id))!==!1&&((l=a.filter)==null||l.remove(t.id),await((u=a.onDisconnect)==null?void 0:u.call(a,t.id)))}))}}catch(s){this.log.error("could not inform topologies of updated peer %p - %e",t.id,s)}}async _onPeerIdentify(e){const t=e.detail.protocols,r=e.detail.connection,i=e.detail.peerId;try{for(const s of t){const o=this.topologies.get(s);o!=null&&await Promise.all([...o.values()].map(async a=>{var c,l,u;r.limits!=null&&a.notifyOnLimitedConnection!==!0||((c=a.filter)==null?void 0:c.has(i))!==!0&&((l=a.filter)==null||l.add(i),await((u=a.onConnect)==null?void 0:u.call(a,i,r)))}))}}catch(s){this.log.error("could not inform topologies of updated peer after identify %p - %e",i,s)}}}var gC;gC=Symbol.toStringTag;class UZ{constructor(e,t={}){h(this,"log");h(this,"components");h(this,"transports");h(this,"listeners");h(this,"faultTolerance");h(this,"started");h(this,gC,"@libp2p/transport-manager");this.log=e.logger.forComponent("libp2p:transports"),this.components=e,this.started=!1,this.transports=ro({name:"libp2p_transport_manager_transports",metrics:this.components.metrics}),this.listeners=ro({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=t.faultTolerance??vm.FATAL_ALL}add(e){const t=e[Symbol.toStringTag];if(t==null)throw new zr("Transport must have a valid tag");if(this.transports.has(t))throw new zr(`There is already a transport with the tag ${t}`);this.log("adding transport %s",t),this.transports.set(t,e),this.listeners.has(t)||this.listeners.set(t,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const e=this.components.addressManager.getListenAddrs();await this.listen(e)}async stop(){const e=[];for(const[t,r]of this.listeners)for(this.log("closing listeners for %s",t);r.length>0;){const i=r.pop();i!=null&&e.push(i.close())}await Promise.all(e),this.log("all listeners closed");for(const t of this.listeners.keys())this.listeners.set(t,[]);this.started=!1}async dial(e,t){var i;const r=this.dialTransportForMultiaddr(e);if(r==null)throw new vY(`No transport available for address ${String(e)}`);return(i=t==null?void 0:t.onProgress)==null||i.call(t,new vt("transport-manager:selected-transport",r[Symbol.toStringTag])),r.dial(e,{...t,upgrader:this.components.upgrader})}getAddrs(){let e=[];for(const t of this.listeners.values())for(const r of t)e=[...e,...r.getAddrs()];return e}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}dialTransportForMultiaddr(e){for(const t of this.transports.values())if(t.dialFilter([e]).length>0)return t}listenTransportForMultiaddr(e){for(const t of this.transports.values())if(t.listenFilter([e]).length>0)return t}async listen(e){if(!this.isStarted())throw new wm("Not started");if(e==null||e.length===0){this.log("no addresses were provided for listening, this node is dial only");return}const t={errors:new Map,ipv4:{success:0,attempts:0},ipv6:{success:0,attempts:0}};e.forEach(s=>{t.errors.set(s.toString(),new mY)});const r=[];for(const[s,o]of this.transports.entries()){const a=o.listenFilter(e);for(const c of a){this.log("creating listener for %s on %a",s,c);const l=o.createListener({upgrader:this.components.upgrader});let u=this.listeners.get(s)??[];u==null&&(u=[],this.listeners.set(s,u)),u.push(l),l.addEventListener("listening",()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:l})}),l.addEventListener("close",()=>{const d=u.findIndex(f=>f===l);u.splice(d,1),this.components.events.safeDispatchEvent("transport:close",{detail:l})}),XT.matches(c)?t.ipv4.attempts++:YT.matches(c)&&t.ipv6.attempts++,r.push(l.listen(c).then(()=>{t.errors.delete(c.toString()),XT.matches(c)&&t.ipv4.success++,YT.matches(c)&&t.ipv6.success++},d=>{throw this.log.error("transport %s could not listen on address %a - %e",s,c,d),t.errors.set(c.toString(),d),d}))}}const i=await Promise.allSettled(r);if(!(i.length>0&&i.every(s=>s.status==="fulfilled"))){if(this.ipv6Unsupported(t)){this.log("all IPv4 addresses succeed but all IPv6 failed");return}if(this.faultTolerance===vm.NO_FATAL){this.log("failed to listen on any address but fault tolerance allows this");return}throw new gY(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[...t.errors.entries()].map(([s,o])=>`
  ${s}: ${`${BZ(o)}`.split(`
`).join(`
  `)}
`).join("")}`)}}ipv6Unsupported(e){if(e.ipv4.attempts===0||e.ipv6.attempts===0)return!1;const t=e.ipv4.attempts===e.ipv4.success,r=e.ipv6.success===0;return t&&r}async remove(e){const t=this.listeners.get(e)??[];this.log.trace("removing transport %s",e);const r=[];for(this.log.trace("closing listeners for %s",e);t.length>0;){const i=t.pop();i!=null&&r.push(i.close())}await Promise.all(r),this.transports.delete(e),this.listeners.delete(e)}async removeAll(){const e=[];for(const t of this.transports.keys())e.push(this.remove(t));await Promise.all(e)}}function BZ(n){return n.stack!=null&&n.stack.trim()!==""?n.stack:n.message!=null?n.message:n.toString()}const Ca="/multistream/1.0.0",gL=1024;class yL extends Error{constructor(e="Unsupported protocol error"){super(e),this.name="UnsupportedProtocolError"}}h(yL,"name","UnsupportedProtocolError");var aw;let kZ=(aw=class extends Error{constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}},h(aw,"name","InvalidMessageError"),aw);const $Z=ge(`
`);async function Xv(n,e){const r=(await n.read(e)).subarray();if(r.byteLength===0||r[r.length-1]!==$Z[0])throw new kZ("Missing newline");return ne(r).trimEnd()}async function Yv(n,e,t={}){if(e=Array.isArray(e)?[...e]:[e],e.length===0)throw new Error("At least one protocol must be specified");const r=n.log.newScope("mss:select"),i=dd(n,{...t,maxDataLength:gL});for(let s=0;s<e.length;s++){const o=e[s];let a;if(s===0){r.trace('write ["%s", "%s"]',Ca,o);const c=ge(`${Ca}
`),l=ge(`${o}
`);if(await i.writeV([c,l],t),r.trace("reading multistream-select header"),a=await Xv(i,t),r.trace('read "%s"',a),a!==Ca){r.error("did not read multistream-select header from response");break}}else r.trace('write "%s"',o),await i.write(ge(`${o}
`),t);if(r.trace("reading protocol response"),a=await Xv(i,t),r.trace('read "%s"',a),a===o)return r.trace('selected "%s" after negotiation',a),i.unwrap(),o}throw new yL(`Protocol selection failed - could not negotiate ${e}`)}const bL=1024*1024*4;let FZ=class extends Error{constructor(){super(...arguments);h(this,"name","InvalidDataLengthError");h(this,"code","ERR_MSG_DATA_TOO_LONG")}};function zZ(n){return n[Symbol.asyncIterator]!=null}function wL(n,e){if(n.byteLength>e)throw new FZ("Message length too long")}const zg=n=>{const e=Me(n),t=zi(e);return ul(n,t),zg.bytes=e,t};zg.bytes=0;function vL(n,e){e=e??{};const t=e.lengthEncoder??zg,r=(e==null?void 0:e.maxDataLength)??bL;function*i(s){wL(s,r);const o=t(s.byteLength);o instanceof Uint8Array?yield o:yield*o,s instanceof Uint8Array?yield s:yield*s}return zZ(n)?(async function*(){for await(const s of n)yield*i(s)})():(function*(){for(const s of n)yield*i(s)})()}vL.single=(n,e)=>{e=e??{};const t=e.lengthEncoder??zg,r=(e==null?void 0:e.maxDataLength)??bL;return wL(n,r),new ut(t(n.byteLength),n)};var hA;(function(n){n[n.LENGTH=0]="LENGTH",n[n.DATA=1]="DATA"})(hA||(hA={}));async function Zv(n,e,t={}){e=Array.isArray(e)?e:[e];const r=n.log.newScope("mss:handle"),i=dd(n,{...t,maxDataLength:gL,maxLengthLength:2});for(;;){r.trace("reading incoming string");const s=await Xv(i,t);if(r.trace('read "%s"',s),s===Ca){r.trace('respond with "%s" for "%s"',Ca,s),await i.write(ge(`${Ca}
`),t),r.trace('responded with "%s" for "%s"',Ca,s);continue}if(e.includes(s))return r.trace('respond with "%s" for "%s"',s,s),await i.write(ge(`${s}
`),t),r.trace('responded with "%s" for "%s"',s,s),i.unwrap(),s;if(s==="ls"){const o=new ut(...e.map(a=>vL.single(ge(`${a}
`))),ge(`
`));r.trace('respond with "%s" for %s',e,s),await i.write(o,t),r.trace('responded with "%s" for %s',e,s);continue}r.trace('respond with "na" for "%s"',s),await i.write(ge(`na
`),t),r('responded with "na" for "%s"',s)}}var yC,bC,wC;class VZ extends(wC=fr,bC=Symbol.toStringTag,yC=iH,wC){constructor(t,r){super();h(this,"id");h(this,"remoteAddr");h(this,"remotePeer");h(this,"direction");h(this,"timeline");h(this,"direct");h(this,"multiplexer");h(this,"encryption");h(this,"limits");h(this,"log");h(this,"maConn");h(this,"muxer");h(this,"components");h(this,"outboundStreamProtocolNegotiationTimeout");h(this,"inboundStreamProtocolNegotiationTimeout");h(this,"closeTimeout");h(this,bC,"Connection");h(this,yC,!0);h(this,"newStream",async(t,r={})=>{var s;if(this.muxer==null)throw new zp("Connection is not multiplexed");if(this.muxer.status!=="open")throw new bm(`The connection muxer is "${this.muxer.status}" and not "open"`);if(this.maConn.status!=="open")throw new bm(`The connection is "${this.status}" and not "open"`);if(this.limits!=null&&(r==null?void 0:r.runOnLimitedConnection)!==!0)throw new Mv("Cannot open protocol stream on limited connection");Array.isArray(t)||(t=[t]),this.log.trace("starting new stream for protocols %s",t);const i=await this.muxer.createStream({...r,protocol:t.length===1?t[0]:void 0});this.log.trace("started new stream %s for protocols %s",i.id,t);try{if(r.signal==null){i.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout",t);const l=AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);r={...r,signal:l}}i.protocol===""?(i.log.trace("selecting protocol from protocols %s",t),i.protocol=await Yv(i,t,r),i.log("negotiated protocol %s",i.protocol)):i.log("pre-negotiated protocol %s",i.protocol);const o=WZ(i.protocol,this.components.registrar,r),a=dA(i.protocol,"outbound",this);if(a>o){const l=new uH(`Too many outbound protocol streams for protocol "${i.protocol}" - ${a}/${o}`);throw i.abort(l),l}await this.components.peerStore.merge(this.remotePeer,{protocols:[i.protocol]}),(s=this.components.metrics)==null||s.trackProtocolStream(i);const c=this.components.registrar.getMiddleware(i.protocol);return await this.runMiddlewareChain(i,this,c)}catch(o){throw i.status==="open"?i.abort(o):this.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e",this.direction==="inbound"?"from":"to",this.remoteAddr,t,o),o}});this.components=t,this.id=r.id,this.remoteAddr=r.maConn.remoteAddr,this.remotePeer=r.remotePeer,this.direction=r.direction??"outbound",this.timeline=r.maConn.timeline,this.encryption=r.cryptoProtocol,this.limits=r.limits,this.maConn=r.maConn,this.log=r.maConn.log,this.outboundStreamProtocolNegotiationTimeout=r.outboundStreamProtocolNegotiationTimeout??Rm,this.inboundStreamProtocolNegotiationTimeout=r.inboundStreamProtocolNegotiationTimeout??Rm,this.closeTimeout=r.closeTimeout??ZR,this.direct=KR(r.maConn.remoteAddr),this.onIncomingStream=this.onIncomingStream.bind(this),this.remoteAddr.getComponents().find(i=>i.code===us)==null&&(this.remoteAddr=this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)),r.muxer!=null&&(this.multiplexer=r.muxer.protocol,this.muxer=r.muxer,this.muxer.addEventListener("stream",this.onIncomingStream)),this.maConn.addEventListener("close",i=>{this.dispatchEvent(new dH(i.local,i.error))})}get streams(){var t;return((t=this.muxer)==null?void 0:t.streams)??[]}get status(){return this.maConn.status}async onIncomingStream(t){var s;const r=t.detail,i=AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout);r.log("start protocol negotiation, timing out after %dms",this.inboundStreamProtocolNegotiationTimeout);try{if(r.protocol===""){const d=this.components.registrar.getProtocols();r.log.trace("selecting protocol from protocols %s",d),r.protocol=await Zv(r,d,{signal:i}),r.log("negotiated protocol %s",r.protocol)}else r.log("pre-negotiated protocol %s",r.protocol);const o=GZ(r.protocol,this.components.registrar);if(dA(r.protocol,"inbound",this)>o)throw new aD(`Too many inbound protocol streams for protocol "${r.protocol}" - limit ${o}`);await this.components.peerStore.merge(this.remotePeer,{protocols:[r.protocol]},{signal:i}),(s=this.components.metrics)==null||s.trackProtocolStream(r);const{handler:c,options:l}=this.components.registrar.getHandler(r.protocol);if(this.limits!=null&&l.runOnLimitedConnection!==!0)throw new Mv("Cannot open protocol stream on limited connection");const u=this.components.registrar.getMiddleware(r.protocol);u.push(async(d,f,p)=>{await c(d,f),p(d,f)}),await this.runMiddlewareChain(r,this,u)}catch(o){r.abort(o)}}async runMiddlewareChain(t,r,i){for(let s=0;s<i.length;s++){const o=i[s];t.log.trace("running middleware",s,o),await new Promise((a,c)=>{try{const l=o(t,r,(u,d)=>{t=u,r=d,a()});l instanceof Promise&&l.catch(c)}catch(l){c(l)}}),t.log.trace("ran middleware",s,o)}return t}async close(t={}){var r;if(this.log("closing connection to %a",this.remoteAddr),t.signal==null){const i=AbortSignal.timeout(this.closeTimeout);t={...t,signal:i}}await((r=this.muxer)==null?void 0:r.close(t)),await this.maConn.close(t)}abort(t){var r;(r=this.muxer)==null||r.abort(t),this.maConn.abort(t)}}function HZ(n,e){return new VZ(n,e)}function GZ(n,e){try{const{options:t}=e.getHandler(n);if(t.maxInboundStreams!=null)return t.maxInboundStreams}catch(t){if(t.name!=="UnhandledProtocolError")throw t}return pL}function WZ(n,e,t={}){try{const{options:r}=e.getHandler(n);if(r.maxOutboundStreams!=null)return r.maxOutboundStreams}catch(r){if(r.name!=="UnhandledProtocolError")throw r}return t.maxOutboundStreams??mL}function dA(n,e,t){let r=0;return t.streams.forEach(i=>{i.direction===e&&i.protocol===n&&r++}),r}var vC;vC=Symbol.toStringTag;class qZ{constructor(e,t){h(this,"components");h(this,"connectionEncrypters");h(this,"streamMuxers");h(this,"inboundUpgradeTimeout");h(this,"inboundStreamProtocolNegotiationTimeout");h(this,"outboundStreamProtocolNegotiationTimeout");h(this,"events");h(this,"metrics");h(this,"connectionCloseTimeout");h(this,vC,"@libp2p/upgrader");var r,i,s,o;this.components=e,this.connectionEncrypters=ro({name:"libp2p_upgrader_connection_encrypters",metrics:this.components.metrics}),t.connectionEncrypters.forEach(a=>{this.connectionEncrypters.set(a.protocol,a)}),this.streamMuxers=ro({name:"libp2p_upgrader_stream_multiplexers",metrics:this.components.metrics}),t.streamMuxers.forEach(a=>{this.streamMuxers.set(a.protocol,a)}),this.inboundUpgradeTimeout=t.inboundUpgradeTimeout??OY,this.inboundStreamProtocolNegotiationTimeout=t.inboundStreamProtocolNegotiationTimeout??Rm,this.outboundStreamProtocolNegotiationTimeout=t.outboundStreamProtocolNegotiationTimeout??Rm,this.connectionCloseTimeout=t.connectionCloseTimeout??ZR,this.events=e.events,this.metrics={dials:(r=e.metrics)==null?void 0:r.registerCounterGroup("libp2p_connection_manager_dials_total"),errors:(i=e.metrics)==null?void 0:i.registerCounterGroup("libp2p_connection_manager_dial_errors_total"),inboundErrors:(s=e.metrics)==null?void 0:s.registerCounterGroup("libp2p_connection_manager_dials_inbound_errors_total"),outboundErrors:(o=e.metrics)==null?void 0:o.registerCounterGroup("libp2p_connection_manager_dials_outbound_errors_total")}}async shouldBlockConnection(e,...t){const r=this.components.connectionGater[e];if(r==null)return;if(await r.apply(this.components.connectionGater,t)===!0)throw new bY(`The multiaddr connection is blocked by gater.${e}`)}createInboundAbortSignal(e){return Ja([AbortSignal.timeout(this.inboundUpgradeTimeout),e])}async upgradeInbound(e,t){var s,o,a;let r=!1;const i=this.createInboundAbortSignal(t.signal);try{if((s=this.metrics.dials)==null||s.increment({inbound:!0}),r=this.components.connectionManager.acceptIncomingConnection(e),!r)throw new wY("Connection denied");await Vi(this.shouldBlockConnection("denyInboundConnection",e),i),await this._performUpgrade(e,"inbound",{...t,signal:i})}catch(c){throw(o=this.metrics.errors)==null||o.increment({inbound:!0}),(a=this.metrics.inboundErrors)==null||a.increment({[c.name??"Error"]:!0}),c}finally{i.clear(),r&&this.components.connectionManager.afterUpgradeInbound()}}async upgradeOutbound(e,t){var r,i,s,o;try{(r=this.metrics.dials)==null||r.increment({outbound:!0});const a=(i=e.remoteAddr.getComponents().findLast(u=>u.code===us))==null?void 0:i.value;let c;a!=null&&(c=su(a),await Vi(this.shouldBlockConnection("denyOutboundConnection",c,e),t.signal));let l="outbound";return t.initiator===!1&&(l="inbound"),await this._performUpgrade(e,l,t)}catch(a){throw(s=this.metrics.errors)==null||s.increment({outbound:!0}),(o=this.metrics.outboundErrors)==null||o.increment({[a.name??"Error"]:!0}),a}}async _performUpgrade(e,t,r){var d,f,p,g;let i=e,s,o,a,c;const l=`${parseInt(String(Math.random()*1e9)).toString(36)}${Date.now()}`;if(e.log=e.log.newScope(`${t}:${l}`),(d=this.components.metrics)==null||d.trackMultiaddrConnection(e),e.log.trace("starting the %s connection upgrade",t),(r==null?void 0:r.skipProtection)!==!0){const b=this.components.connectionProtector;b!=null&&(e.log("protecting the %s connection",t),i=await b.protect(i,r))}try{if(KZ(r)){if(r.remotePeer==null)throw new IE(`${t} connection that skipped encryption must have a peer id`);c="native",s=r.remotePeer}else{const b=(f=e.remoteAddr.getComponents().findLast(y=>y.code===us))==null?void 0:f.value;let m;b!=null&&(m=su(b)),(p=r==null?void 0:r.onProgress)==null||p.call(r,new vt(`upgrader:encrypt-${t}-connection`)),{connection:i,remotePeer:s,protocol:c,streamMuxer:o}=await(t==="inbound"?this._encryptInbound(i,{...r,remotePeer:m}):this._encryptOutbound(i,{...r,remotePeer:m}))}if(s.equals(this.components.peerId)){const b=new CE("Can not dial self");throw e.abort(b),b}await this.shouldBlockConnection(t==="inbound"?"denyInboundEncryptedConnection":"denyOutboundEncryptedConnection",s,e),(r==null?void 0:r.muxerFactory)!=null?o=r.muxerFactory:o==null&&this.streamMuxers.size>0&&((g=r==null?void 0:r.onProgress)==null||g.call(r,new vt(`upgrader:multiplex-${t}-connection`)),o=await(t==="inbound"?this._multiplexInbound(i,this.streamMuxers,r):this._multiplexOutbound(i,this.streamMuxers,r)))}catch(b){throw e.log.error("failed to upgrade %s connection %s %a - %e",t,t==="inbound"?"from":"to",e.remoteAddr,b),b}o!=null&&(e.log("create muxer %s",o.protocol),a=o.createStreamMuxer(i)),await this.shouldBlockConnection(t==="inbound"?"denyInboundUpgradedConnection":"denyOutboundUpgradedConnection",s,e);const u=this._createConnection({id:l,cryptoProtocol:c,direction:t,maConn:e,stream:i,muxer:a,remotePeer:s,limits:r==null?void 0:r.limits,closeTimeout:this.connectionCloseTimeout});return u.log("successfully upgraded connection"),u}_createConnection(e){const t=HZ(this.components,{...e,outboundStreamProtocolNegotiationTimeout:this.outboundStreamProtocolNegotiationTimeout,inboundStreamProtocolNegotiationTimeout:this.inboundStreamProtocolNegotiationTimeout});return t.addEventListener("close",()=>{this.events.safeDispatchEvent("connection:close",{detail:t})}),this.events.safeDispatchEvent("connection:open",{detail:t}),t}async _encryptInbound(e,t){const r=Array.from(this.connectionEncrypters.keys());try{const i=await Zv(e,r,t),s=this.connectionEncrypters.get(i);if(s==null)throw new op(`no crypto module found for ${i}`);return e.log("encrypting inbound connection using %s",i),{...await s.secureInbound(e,t),protocol:i}}catch(i){throw new op(i.message)}}async _encryptOutbound(e,t){const r=Array.from(this.connectionEncrypters.keys());try{e.log.trace("selecting encrypter from %s",r);const i=await Yv(e,r,t),s=this.connectionEncrypters.get(i);if(s==null)throw new op(`no crypto module found for ${i}`);return e.log("encrypting outbound connection using %s",i),{...await s.secureOutbound(e,t),protocol:i}}catch(i){throw new op(i.message)}}async _multiplexOutbound(e,t,r){const i=Array.from(t.keys());e.log("outbound selecting muxer %s",i);try{e.log.trace("selecting stream muxer from %s",i);const s=await Yv(e,i,r),o=t.get(s);if(o==null)throw new zp(`No muxer configured for protocol "${s}"`);return e.log("selected %s as muxer protocol",s),o}catch(s){throw e.log.error("error multiplexing outbound connection - %e",s),new zp(String(s))}}async _multiplexInbound(e,t,r){const i=Array.from(t.keys());e.log("inbound handling muxers %s",i);try{e.log.trace("selecting stream muxer from %s",i);const s=await Zv(e,i,r),o=t.get(s);if(o==null)throw new zp(`No muxer configured for protocol "${s}"`);return e.log("selected %s as muxer protocol",s),o}catch(s){throw e.log.error("error multiplexing inbound connection - %e",s),s}}getConnectionEncrypters(){return this.connectionEncrypters}getStreamMuxers(){return this.streamMuxers}}function KZ(n){return n.skipEncryption===!0}const _L="3.1.2",EL="js-libp2p";function XZ(n,e){return`${n??EL}/${e??_L} browser/${globalThis.navigator.userAgent}`}var Wd,jv;class YZ extends fr{constructor(t){var u,d,f,p,g,b,m,y,E,w,x;super();me(this,Wd);h(this,"peerId");h(this,"peerStore");h(this,"contentRouting");h(this,"peerRouting");h(this,"metrics");h(this,"services");h(this,"logger");h(this,"status");h(this,"components");h(this,"log");this.status="stopped";const r=new fr,i=r.dispatchEvent.bind(r);r.dispatchEvent=M=>{const A=i(M),C=this.dispatchEvent(new CustomEvent(M.type,{detail:M.detail}));return A||C},this.peerId=t.peerId,this.logger=t.logger??yD(),this.log=this.logger.forComponent("libp2p"),this.services={};const s=((u=t.nodeInfo)==null?void 0:u.name)??EL,o=((d=t.nodeInfo)==null?void 0:d.version)??_L,a=this.components=TY({peerId:t.peerId,privateKey:t.privateKey,nodeInfo:{name:s,version:o,userAgent:((f=t.nodeInfo)==null?void 0:f.userAgent)??XZ(s,o)},logger:this.logger,events:r,datastore:t.datastore??new dX,connectionGater:PY(t.connectionGater),dns:t.dns});t.metrics!=null&&(this.metrics=this.configureComponent("metrics",t.metrics(this.components))),this.peerStore=this.configureComponent("peerStore",Jq(a,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...t.peerStore})),a.events.addEventListener("peer:update",M=>{if(M.detail.previous==null){const A={id:M.detail.peer.id,multiaddrs:M.detail.peer.addresses.map(C=>C.multiaddr)};a.events.safeDispatchEvent("peer:discovery",{detail:A})}}),t.connectionProtector!=null&&this.configureComponent("connectionProtector",t.connectionProtector(a)),this.components.upgrader=new qZ(this.components,{connectionEncrypters:(t.connectionEncrypters??[]).map((M,A)=>this.configureComponent(`connection-encryption-${A}`,M(this.components))),streamMuxers:(t.streamMuxers??[]).map((M,A)=>this.configureComponent(`stream-muxers-${A}`,M(this.components))),inboundUpgradeTimeout:(p=t.connectionManager)==null?void 0:p.inboundUpgradeTimeout,inboundStreamProtocolNegotiationTimeout:(g=t.connectionManager)==null?void 0:g.inboundStreamProtocolNegotiationTimeout,outboundStreamProtocolNegotiationTimeout:(b=t.connectionManager)==null?void 0:b.outboundStreamProtocolNegotiationTimeout,connectionCloseTimeout:(m=t.connectionManager)==null?void 0:m.connectionCloseTimeout}),this.configureComponent("transportManager",new UZ(this.components,t.transportManager)),this.configureComponent("connectionManager",new xZ(this.components,t.connectionManager)),((y=t.connectionMonitor)==null?void 0:y.enabled)!==!1&&this.configureComponent("connectionMonitor",new PZ(this.components,t.connectionMonitor)),this.configureComponent("registrar",new NZ(this.components)),this.configureComponent("addressManager",new lY(this.components,t.addresses));const c=(t.peerRouters??[]).map((M,A)=>this.configureComponent(`peer-router-${A}`,M(this.components)));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new LZ(this.components,{routers:c}));const l=(t.contentRouters??[]).map((M,A)=>this.configureComponent(`content-router-${A}`,M(this.components)));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new DZ(this.components,{routers:l})),this.configureComponent("randomWalk",new OZ(this.components)),(t.peerDiscovery??[]).forEach((M,A)=>{this.configureComponent(`peer-discovery-${A}`,M(this.components)).addEventListener("peer",R=>{ue(this,Wd,jv).call(this,R)})}),(E=t.transports)==null||E.forEach((M,A)=>{this.components.transportManager.add(this.configureComponent(`transport-${A}`,M(this.components)))}),t.services!=null)for(const M of Object.keys(t.services)){const A=t.services[M],C=A(this.components);if(C==null){this.log.error("service factory %s returned null or undefined instance",M);continue}this.services[M]=C,this.configureComponent(M,C),C[lT]!=null&&(this.log("registering service %s for content routing",M),l.push(C[lT])),C[hT]!=null&&(this.log("registering service %s for peer routing",M),c.push(C[hT])),C[uT]!=null&&(this.log("registering service %s for peer discovery",M),(x=(w=C[uT]).addEventListener)==null||x.call(w,"peer",R=>{ue(this,Wd,jv).call(this,R)}))}AY(a)}configureComponent(t,r){return r==null&&this.log.error("component %s was null or undefined",t),this.components[t]=r,r}async start(){var t,r,i,s;if(this.status==="stopped"){this.status="starting",this.log("libp2p is starting");try{await((r=(t=this.components).beforeStart)==null?void 0:r.call(t)),await this.components.start(),await((s=(i=this.components).afterStart)==null?void 0:s.call(i)),this.status="started",this.safeDispatchEvent("start",{detail:this}),this.log("libp2p has started with peer id %p",this.peerId)}catch(o){throw this.log.error("an error occurred starting libp2p - %e",o),this.status="started",await this.stop(),o}}}async stop(){var t,r,i,s;this.status==="started"&&(this.log("libp2p is stopping"),this.status="stopping",await((r=(t=this.components).beforeStop)==null?void 0:r.call(t)),await this.components.stop(),await((s=(i=this.components).afterStop)==null?void 0:s.call(i)),this.status="stopped",this.safeDispatchEvent("stop",{detail:this}),this.log("libp2p has stopped"))}getConnections(t){return this.components.connectionManager.getConnections(t)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const t=new _D;for(const r of this.components.connectionManager.getConnections())t.add(r.remotePeer);return Array.from(t)}async dial(t,r={}){return this.components.connectionManager.openConnection(t,{priority:75,...r})}async dialProtocol(t,r,i={}){if(r==null)throw new zr("no protocols were provided to open a stream");if(r=Array.isArray(r)?r:[r],r.length===0)throw new zr("no protocols were provided to open a stream");return this.components.connectionManager.openStream(t,r,i)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(t,r={}){var i;KE(t)&&(t=su(((i=t.getComponents().findLast(s=>s.code===us))==null?void 0:i.value)??"")),await this.components.connectionManager.closeConnections(t,r)}async getPublicKey(t,r={}){if(this.log("getPublicKey %p",t),t.publicKey!=null)return t.publicKey;try{const a=await this.peerStore.get(t,r);if(a.id.publicKey!=null)return a.id.publicKey}catch(a){if(a.name!=="NotFoundError")throw a}const i=nt([ge("/pk/"),t.toMultihash().bytes]),s=await this.contentRouting.get(i,r),o=no(s);return await this.peerStore.patch(t,{publicKey:o},r),o}async handle(t,r,i){Array.isArray(t)||(t=[t]),await Promise.all(t.map(async s=>{await this.components.registrar.handle(s,r,i)}))}async unhandle(t,r){Array.isArray(t)||(t=[t]),await Promise.all(t.map(async i=>{await this.components.registrar.unhandle(i,r)}))}async register(t,r,i){return this.components.registrar.register(t,r,i)}unregister(t){this.components.registrar.unregister(t)}use(t,r){this.components.registrar.use(t,Array.isArray(r)?r:[r])}unuse(t){this.components.registrar.unuse(t)}async isDialable(t,r={}){return this.components.connectionManager.isDialable(t,r)}}Wd=new WeakSet,jv=function(t){const{detail:r}=t;if(r.id.toString()===this.peerId.toString()){this.log.error("peer discovery mechanism discovered self");return}this.components.peerStore.merge(r.id,{multiaddrs:r.multiaddrs}).catch(i=>{this.log.error("could not update multiaddrs of discovered peer - %e",i)})};async function ZZ(n={}){n.privateKey??(n.privateKey=await nH());const e=new YZ({...await xH(n),peerId:vH(n.privateKey)});return n.start!==!1&&await e.start(),e}var cw;let jZ=(cw=class extends Error{constructor(e="Connection failed"){super(e),this.name="ConnectionFailedError"}},h(cw,"name","ConnectionFailedError"),cw);const JZ=Symbol.for("@libp2p/transport");var fA;(function(n){n[n.FATAL_ALL=0]="FATAL_ALL",n[n.NO_FATAL=1]="NO_FATAL"})(fA||(fA={}));const QZ=Symbol.for("@libp2p/service-capabilities");var lw;let ri=(lw=class extends Error{constructor(){super(...arguments);h(this,"name","InvalidMultiaddrError")}},h(lw,"name","InvalidMultiaddrError"),lw);var uw;let wd=(uw=class extends Error{constructor(){super(...arguments);h(this,"name","ValidationError")}},h(uw,"name","ValidationError"),uw);var hw;let ej=(hw=class extends Error{constructor(){super(...arguments);h(this,"name","InvalidParametersError")}},h(hw,"name","InvalidParametersError"),hw);var dw;let tj=(dw=class extends Error{constructor(){super(...arguments);h(this,"name","UnknownProtocolError")}},h(dw,"name","UnknownProtocolError"),dw);const nj=4,SL=6,rj=273,ij=33,xL=41,sj=42,oj=43,TL=53,AL=54,ML=55,CL=56,aj=132,cj=301,lj=302,uj=400,hj=421,dj=444,fj=445,pj=446,mj=447,IL=448,gj=449,yj=454,bj=460,wj=461,vj=465,_j=466,Ej=480,Sj=481,xj=443,Tj=477,Aj=478,Mj=479,Cj=277,Ij=275,Pj=276,Dj=280,Rj=281,Lj=290,Oj=777;function pA(n){return e=>ne(e,n)}function mA(n){return e=>ge(e,n)}function Sh(n){return new DataView(n.buffer).getUint16(n.byteOffset).toString()}function Jc(n){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof n=="string"?parseInt(n):n),new Uint8Array(e)}function Nj(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=ge(e[0],"base32"),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const i=Jc(r);return nt([t,i],t.length+i.length)}function Uj(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=yn.decode(`b${e[0]}`),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const i=Jc(r);return nt([t,i],t.length+i.length)}function gA(n){const e=n.subarray(0,n.length-2),t=n.subarray(n.length-2),r=ne(e,"base32"),i=Sh(t);return`${r}:${i}`}const PL=function(n){n=n.toString().trim();const e=new Uint8Array(4);return n.split(/\./g).forEach((t,r)=>{const i=parseInt(t,10);if(isNaN(i)||i<0||i>255)throw new ri("Invalid byte value in IP address");e[r]=i}),e},Bj=function(n){let e=0;n=n.toString().trim();const t=n.split(":",8);let r;for(r=0;r<t.length;r++){const s=Pt(t[r]);let o;s&&(o=PL(t[r]),t[r]=ne(o.subarray(0,2),"base16")),o!=null&&++r<8&&t.splice(r,0,ne(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(r=0;r<t.length&&t[r]!=="";r++);const s=[r,1];for(r=9-t.length;r>0;r--)s.push("0");t.splice.apply(t,s)}const i=new Uint8Array(e+16);for(r=0;r<t.length;r++){t[r]===""&&(t[r]="0");const s=parseInt(t[r],16);if(isNaN(s)||s<0||s>65535)throw new ri("Invalid byte value in IP address");i[e++]=s>>8&255,i[e++]=s&255}return i},kj=function(n){if(n.byteLength!==4)throw new ri("IPv4 address was incorrect length");const e=[];for(let t=0;t<n.byteLength;t++)e.push(n[t]);return e.join(".")},$j=function(n){if(n.byteLength!==16)throw new ri("IPv6 address was incorrect length");const e=[];for(let r=0;r<n.byteLength;r+=2){const i=n[r],s=n[r+1],o=`${i.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const r=new URL(`http://[${t}]`);return r.hostname.substring(1,r.hostname.length-1)}catch{throw new ri(`Invalid IPv6 address "${t}"`)}};function Fj(n){try{const e=new URL(`http://[${n}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new ri(`Invalid IPv6 address "${n}"`)}}const T0=Object.values(Fr).map(n=>n.decoder),zj=(function(){let n=T0[0].or(T0[1]);return T0.slice(2).forEach(e=>n=n.or(e)),n})();function Vj(n){return zj.decode(n)}function Hj(n){return e=>n.encoder.encode(e)}function Gj(n){if(parseInt(n).toString()!==n)throw new wd("Value must be an integer")}function Wj(n){if(n<0)throw new wd("Value must be a positive integer, or zero")}function qj(n){return e=>{if(e>n)throw new wd(`Value must be smaller than or equal to ${n}`)}}function Kj(...n){return e=>{for(const t of n)t(e)}}const lp=Kj(Gj,Wj,qj(65535)),Fn=-1;let Xj=class{constructor(){h(this,"protocolsByCode",new Map);h(this,"protocolsByName",new Map)}getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new tj(`Protocol ${e} was unknown`);return t}addProtocol(e){var t;this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),(t=e.aliases)==null||t.forEach(r=>{this.protocolsByName.set(r,e)})}removeProtocol(e){var r;const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),(r=t.aliases)==null||r.forEach(i=>{this.protocolsByName.delete(i)}))}};const $u=new Xj,Yj=[{code:nj,name:"ip4",size:32,valueToBytes:PL,bytesToValue:kj,validate:n=>{if(!Pt(n))throw new wd(`Invalid IPv4 address "${n}"`)}},{code:SL,name:"tcp",size:16,valueToBytes:Jc,bytesToValue:Sh,validate:lp},{code:rj,name:"udp",size:16,valueToBytes:Jc,bytesToValue:Sh,validate:lp},{code:ij,name:"dccp",size:16,valueToBytes:Jc,bytesToValue:Sh,validate:lp},{code:xL,name:"ip6",size:128,valueToBytes:Bj,bytesToValue:$j,stringToValue:Fj,validate:n=>{if(!hi(n))throw new wd(`Invalid IPv6 address "${n}"`)}},{code:sj,name:"ip6zone",size:Fn},{code:oj,name:"ipcidr",size:8,bytesToValue:pA("base10"),valueToBytes:mA("base10")},{code:TL,name:"dns",size:Fn},{code:AL,name:"dns4",size:Fn},{code:ML,name:"dns6",size:Fn},{code:CL,name:"dnsaddr",size:Fn},{code:aj,name:"sctp",size:16,valueToBytes:Jc,bytesToValue:Sh,validate:lp},{code:cj,name:"udt"},{code:lj,name:"utp"},{code:uj,name:"unix",size:Fn,stringToValue:n=>decodeURIComponent(n),valueToString:n=>encodeURIComponent(n)},{code:hj,name:"p2p",aliases:["ipfs"],size:Fn,bytesToValue:pA("base58btc"),valueToBytes:n=>n.startsWith("Q")||n.startsWith("1")?mA("base58btc")(n):ze.parse(n).multihash.bytes},{code:dj,name:"onion",size:96,bytesToValue:gA,valueToBytes:Nj},{code:fj,name:"onion3",size:296,bytesToValue:gA,valueToBytes:Uj},{code:pj,name:"garlic64",size:Fn},{code:mj,name:"garlic32",size:Fn},{code:IL,name:"tls"},{code:gj,name:"sni",size:Fn},{code:yj,name:"noise"},{code:bj,name:"quic"},{code:wj,name:"quic-v1"},{code:vj,name:"webtransport"},{code:_j,name:"certhash",size:Fn,bytesToValue:Hj(ui),valueToBytes:Vj},{code:Ej,name:"http"},{code:Sj,name:"http-path",size:Fn,stringToValue:n=>`/${decodeURIComponent(n)}`,valueToString:n=>encodeURIComponent(n.substring(1))},{code:xj,name:"https"},{code:Tj,name:"ws"},{code:Aj,name:"wss"},{code:Mj,name:"p2p-websocket-star"},{code:Cj,name:"p2p-stardust"},{code:Ij,name:"p2p-webrtc-star"},{code:Pj,name:"p2p-webrtc-direct"},{code:Dj,name:"webrtc-direct"},{code:Rj,name:"webrtc"},{code:Lj,name:"p2p-circuit"},{code:Oj,name:"memory",size:Fn}];Yj.forEach(n=>{$u.addProtocol(n)});function Zj(n){var r;const e=[];let t=0;for(;t<n.length;){const i=zt(n,t),s=$u.getProtocol(i),o=Me(i),a=eJ(s,n,t+o);let c=0;a>0&&s.size===Fn&&(c=Me(a));const l=o+c+a,u={code:i,name:s.name,bytes:n.subarray(t,t+l)};if(a>0){const d=t+o+c,f=n.subarray(d,d+a);u.value=((r=s.bytesToValue)==null?void 0:r.call(s,f))??ne(f)}e.push(u),t+=l}return e}function jj(n){var r;let e=0;const t=[];for(const i of n){if(i.bytes==null){const s=$u.getProtocol(i.code),o=Me(i.code);let a,c=0,l=0;i.value!=null&&(a=((r=s.valueToBytes)==null?void 0:r.call(s,i.value))??ge(i.value),c=a.byteLength,s.size===Fn&&(l=Me(c)));const u=new Uint8Array(o+l+c);let d=0;Xt(i.code,u,d),d+=o,a!=null&&(s.size===Fn&&(Xt(c,u,d),d+=l),u.set(a,d)),i.bytes=u}t.push(i.bytes),e+=i.bytes.byteLength}return nt(t,e)}function Jj(n){var s;if(n.charAt(0)!=="/")throw new ri('String multiaddr must start with "/"');const e=[];let t="protocol",r="",i="";for(let o=1;o<n.length;o++){const a=n.charAt(o);a!=="/"&&(t==="protocol"?i+=n.charAt(o):r+=n.charAt(o));const c=o===n.length-1;if(a==="/"||c){const l=$u.getProtocol(i);if(t==="protocol"){if(l.size==null||l.size===0){e.push({code:l.code,name:l.name}),r="",i="",t="protocol";continue}else if(c)throw new ri(`Component ${i} was missing value`);t="value"}else if(t==="value"){const u={code:l.code,name:l.name};if(l.size!=null&&l.size!==0){if(r==="")throw new ri(`Component ${i} was missing value`);u.value=((s=l.stringToValue)==null?void 0:s.call(l,r))??r}e.push(u),r="",i="",t="protocol"}}}if(i!==""&&r!=="")throw new ri("Incomplete multiaddr");return e}function Qj(n){return`/${n.flatMap(e=>{var r;if(e.value==null)return e.name;const t=$u.getProtocol(e.code);if(t==null)throw new ri(`Unknown protocol code ${e.code}`);return[e.name,((r=t.valueToString)==null?void 0:r.call(t,e.value))??e.value]}).join("/")}`}function eJ(n,e,t){return n.size==null||n.size===0?0:n.size>0?n.size/8:zt(e,t)}const tJ=Symbol.for("nodejs.util.inspect.custom"),DL=Symbol.for("@multiformats/multiaddr");function nJ(n){if(n==null&&(n="/"),sJ(n))return n.getComponents();if(n instanceof Uint8Array)return Zj(n);if(typeof n=="string")return n=n.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),n===""&&(n="/"),Jj(n);if(Array.isArray(n))return n;throw new ri("Must be a string, Uint8Array, Component[], or another Multiaddr")}var _C,Si,Ol,Nl,Ws;let rJ=(Ws=class{constructor(e="/",t={}){h(this,_C,!0);me(this,Si);me(this,Ol);me(this,Nl);pe(this,Si,nJ(e)),t.validate!==!1&&iJ(this)}get bytes(){return D(this,Nl)==null&&pe(this,Nl,jj(D(this,Si))),D(this,Nl)}toString(){return D(this,Ol)==null&&pe(this,Ol,Qj(D(this,Si))),D(this,Ol)}toJSON(){return this.toString()}getComponents(){return[...D(this,Si).map(e=>({...e}))]}encapsulate(e){const t=new Ws(e);return new Ws([...D(this,Si),...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),r=this.toString(),i=r.lastIndexOf(t);if(i<0)throw new ej(`Address ${this.toString()} does not contain subaddress: ${t}`);return new Ws(r.slice(0,i),{validate:!1})}decapsulateCode(e){let t;for(let r=D(this,Si).length-1;r>-1;r--)if(D(this,Si)[r].code===e){t=r;break}return new Ws(D(this,Si).slice(0,t),{validate:!1})}equals(e){return Ne(this.bytes,e.bytes)}[(_C=DL,tJ)](){return`Multiaddr(${this.toString()})`}},Si=new WeakMap,Ol=new WeakMap,Nl=new WeakMap,Ws);function iJ(n){n.getComponents().forEach(e=>{var r;const t=$u.getProtocol(e.code);e.value!=null&&((r=t.validate)==null||r.call(t,e.value))})}function sJ(n){return!!(n!=null&&n[DL])}function oJ(n){return new rJ(n)}const aJ=[SL,TL,CL,AL,ML];function yA(n){var e;return(e=RL("sni",n))==null?void 0:e.value}function bA(n){var t;const e=(t=RL("tcp",n))==null?void 0:t.value;return e==null?"":`:${e}`}function RL(n,e){return e.find(t=>t.name===n)}function wA(n){return n.some(({code:e})=>e===IL)}function yi(n,e){const t=LL[n.name];if(t==null)throw new Error(`Can't interpret protocol ${n.name}`);const r=t(n,e);return n.code===xL?`[${r}]`:r}const LL={ip4:(n,e)=>n.value,ip6:(n,e)=>e.length===0?n.value:`[${n.value}]`,tcp:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`tcp://${yi(t,e)}:${n.value}`},udp:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`udp://${yi(t,e)}:${n.value}`},dnsaddr:(n,e)=>n.value,dns4:(n,e)=>n.value,dns6:(n,e)=>n.value,dns:(n,e)=>n.value,ipfs:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`${yi(t,e)}`},p2p:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`${yi(t,e)}`},http:(n,e)=>{const t=wA(e),r=yA(e),i=bA(e);if(t&&r!=null)return`https://${r}${i}`;const s=t?"https://":"http://",o=e.pop();if(o==null)throw new Error("Unexpected end of multiaddr");let a=yi(o,e);return a=a==null?void 0:a.replace("tcp://",""),`${s}${a}`},"http-path":(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");const r=yi(t,e),i=decodeURIComponent(n.value??"");return`${r}${i}`},tls:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return yi(t,e)},sni:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return yi(t,e)},https:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");let r=yi(t,e);return r=r==null?void 0:r.replace("tcp://",""),`https://${r}`},ws:(n,e)=>{const t=wA(e),r=yA(e),i=bA(e);if(t&&r!=null)return`wss://${r}${i}`;const s=t?"wss://":"ws://",o=e.pop();if(o==null)throw new Error("Unexpected end of multiaddr");let a=yi(o,e);return a=a==null?void 0:a.replace("tcp://",""),`${s}${a}`},wss:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");let r=yi(t,e);return r=r==null?void 0:r.replace("tcp://",""),`wss://${r}`}};function cJ(n,e){const r=oJ(n).getComponents(),i=r.pop();if(i==null)throw new Error("Unexpected end of multiaddr");const s=LL[i.name];if(s==null)throw new Error(`No interpreter found for ${i.name}`);let o=s(i,r)??"";return aJ.includes(i.code)&&(o=o.replace(/^.*:\/\//,""),i.value==="443"?o=`https://${o}`:o=`http://${o}`),(o.startsWith("http://")||o.startsWith("https://")||o.startsWith("ws://")||o.startsWith("wss://"))&&(o=new URL(o).toString(),o.endsWith("/")&&(o=o.substring(0,o.length-1))),o}function lJ(){throw new Error("WebSocket Servers can not be created in the browser!")}const uJ=1024*1024*4,hJ=10;class dJ extends VE{constructor(t){super(t);h(this,"websocket");h(this,"maxBufferedAmount");h(this,"checkBufferedAmountTask");this.websocket=t.websocket,this.maxBufferedAmount=t.maxBufferedAmount??uJ,this.checkBufferedAmountTask=kD(this.checkBufferedAmount.bind(this),t.bufferedAmountPollInterval??hJ),this.websocket.addEventListener("close",r=>{if(this.log('closed - code %d, reason "%s", wasClean %s',r.code,r.reason,r.wasClean),this.checkBufferedAmountTask.stop(),!r.wasClean){this.onRemoteReset();return}this.onTransportClosed()},{once:!0}),this.websocket.addEventListener("message",r=>{try{let i;if(typeof r.data=="string")i=ge(r.data);else if(r.data instanceof ArrayBuffer)i=new Uint8Array(r.data,0,r.data.byteLength);else{this.abort(new Error("Incorrect binary type"));return}this.onData(i)}catch(i){this.log.error("error receiving data - %e",i)}})}sendData(t){for(const i of t)this.websocket.send(i);const r=this.websocket.bufferedAmount<this.maxBufferedAmount;return r||this.checkBufferedAmountTask.start(),{sentBytes:t.byteLength,canSendMore:r}}sendReset(){this.websocket.close(1006)}async sendClose(t){var r;this.websocket.close(),(r=t==null?void 0:t.signal)==null||r.throwIfAborted()}sendPause(){}sendResume(){}checkBufferedAmount(){this.log("buffered amount now %d",this.websocket.bufferedAmount),this.websocket.bufferedAmount===0&&(this.checkBufferedAmountTask.stop(),this.safeDispatchEvent("drain"))}}function fJ(n){return new dJ(n)}var EC,SC,xC;xC=JZ,SC=Symbol.toStringTag,EC=QZ;class pJ{constructor(e,t={}){h(this,"log");h(this,"init");h(this,"logger");h(this,"metrics");h(this,"components");h(this,xC,!0);h(this,SC,"@libp2p/websockets");h(this,EC,["@libp2p/transport"]);this.log=e.logger.forComponent("libp2p:websockets"),this.logger=e.logger,this.components=e,this.init=t,e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_websockets_dialer_events_total",{label:"event",help:"Total count of WebSockets dialer events by type"})})}async dial(e,t){var s;this.log("dialing %s",e),t=t??{};const r=fJ({websocket:await this._connect(e,t),remoteAddr:e,metrics:(s=this.metrics)==null?void 0:s.dialerEvents,direction:"outbound",log:this.components.logger.forComponent("libp2p:websockets:connection"),maxBufferedAmount:this.init.maxBufferedAmount,bufferedAmountPollInterval:this.init.bufferedAmountPollInterval});this.log("new outbound connection %s",r.remoteAddr);const i=await t.upgrader.upgradeOutbound(r,t);return this.log("outbound connection %s upgraded",r.remoteAddr),i}async _connect(e,t){var s,o,a,c,l,u;(s=t==null?void 0:t.signal)==null||s.throwIfAborted();const r=cJ(e);this.log("create websocket connection to %s",r);const i=new WebSocket(r);i.binaryType="arraybuffer";try{(o=t.onProgress)==null||o.call(t,new vt("websockets:open-connection")),await bn(i,"open",t)}catch(d){if((a=t.signal)!=null&&a.aborted)throw(c=this.metrics)==null||c.dialerEvents.increment({abort:!0}),new jZ(`Could not connect to ${r}`);(l=this.metrics)==null||l.dialerEvents.increment({error:!0});try{i.close()}catch{}throw d}return this.log("connected %s",e),(u=this.metrics)==null||u.dialerEvents.increment({connect:!0}),i}createListener(e){return lJ({logger:this.logger,events:this.components.events,metrics:this.components.metrics},{...this.init,...e})}listenFilter(e){return e.filter(t=>bd.exactMatch(t)||Pm.exactMatch(t))}dialFilter(e){return this.listenFilter(e)}}function mJ(n={}){return e=>new pJ(e,n)}var fw;let OL=(fw=class extends Error{constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}},h(fw,"name","InvalidParametersError"),fw);class NL extends Error{constructor(e="Connection failed"){super(e),this.name="ConnectionFailedError"}}h(NL,"name","ConnectionFailedError");class UL extends Error{constructor(e="The stream has been reset"){super(e),this.name="StreamResetError"}}h(UL,"name","StreamResetError");class BL extends Error{constructor(e="The stream is in an invalid state"){super(e),this.name="StreamStateError"}}h(BL,"name","StreamStateError");var pw;let gJ=(pw=class extends Error{constructor(e="Invalid multiaddr"){super(e),this.name="InvalidMultiaddrError"}},h(pw,"name","InvalidMultiaddrError"),pw);var mw;let yJ=(mw=class extends Error{constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}},h(mw,"name","InvalidCIDError"),mw);var gw;let bJ=(gw=class extends Error{constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}},h(gw,"name","InvalidMultihashError"),gw);var yw;let wJ=(yw=class extends Error{constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}},h(yw,"name","InvalidMessageError"),yw);const kL=Symbol.for("@libp2p/peer-id"),vJ=Symbol.for("@libp2p/transport");var vA;(function(n){n[n.FATAL_ALL=0]="FATAL_ALL",n[n.NO_FATAL=1]="NO_FATAL"})(vA||(vA={}));const _J=Symbol.for("@libp2p/service-capabilities"),EJ=Symbol.for("@libp2p/service-dependencies"),$L=Symbol.for("nodejs.util.inspect.custom"),SJ=114;var TC;let nS=class{constructor(e){h(this,"type");h(this,"multihash");h(this,"publicKey");h(this,"string");h(this,TC,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=at.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return ze.createV1(SJ,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return Ne(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return Ne(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(TC=kL,$L)](){return`PeerId(${this.toString()})`}},xJ=class extends nS{constructor(t){super({...t,type:"RSA"});h(this,"type","RSA");h(this,"publicKey");this.publicKey=t.publicKey}},TJ=class extends nS{constructor(t){super({...t,type:"Ed25519"});h(this,"type","Ed25519");h(this,"publicKey");this.publicKey=t.publicKey}},AJ=class extends nS{constructor(t){super({...t,type:"secp256k1"});h(this,"type","secp256k1");h(this,"publicKey");this.publicKey=t.publicKey}};const MJ=2336;var AC,MC;let FL=class{constructor(e){h(this,"type","url");h(this,"multihash");h(this,"publicKey");h(this,"url");h(this,AC,!0);this.url=e.toString(),this.multihash=Zt.digest(ge(this.url))}[(MC=$L,AC=kL,MC)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return ze.createV1(MJ,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=ne(e)),e.toString()===this.toString())}};const CJ=114,_A=2336;function zL(n,e){let t;if(n.charAt(0)==="1"||n.charAt(0)==="Q")t=co(at.decode(`z${n}`));else{if(n.startsWith("k51qzi5uqu5")||n.startsWith("kzwfwjn5ji4")||n.startsWith("k2k4r8")||n.startsWith("bafz"))return IJ(ze.parse(n));throw new OL('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return VL(t)}function VL(n){if(DJ(n))return new xJ({multihash:n});if(PJ(n))try{const e=lo(n);if(e.type==="Ed25519")return new TJ({multihash:n,publicKey:e});if(e.type==="secp256k1")return new AJ({multihash:n,publicKey:e})}catch{const t=ne(n.digest);return new FL(new URL(t))}throw new bJ("Supplied PeerID Multihash is invalid")}function IJ(n){if((n==null?void 0:n.multihash)==null||n.version==null||n.version===1&&n.code!==CJ&&n.code!==_A)throw new yJ("Supplied PeerID CID is invalid");if(n.code===_A){const e=ne(n.multihash.digest);return new FL(new URL(e))}return VL(n.multihash)}function PJ(n){return n.code===Zt.code}function DJ(n){return n.code===ps.code}var bw;let ii=(bw=class extends Error{constructor(){super(...arguments);h(this,"name","InvalidMultiaddrError")}},h(bw,"name","InvalidMultiaddrError"),bw);var ww;let vd=(ww=class extends Error{constructor(){super(...arguments);h(this,"name","ValidationError")}},h(ww,"name","ValidationError"),ww);var vw;let RJ=(vw=class extends Error{constructor(){super(...arguments);h(this,"name","InvalidParametersError")}},h(vw,"name","InvalidParametersError"),vw);var _w;let LJ=(_w=class extends Error{constructor(){super(...arguments);h(this,"name","UnknownProtocolError")}},h(_w,"name","UnknownProtocolError"),_w);const OJ=4,NJ=6,UJ=273,BJ=33,kJ=41,$J=42,FJ=43,zJ=53,VJ=54,HJ=55,GJ=56,WJ=132,qJ=301,KJ=302,XJ=400,YJ=421,ZJ=444,jJ=445,JJ=446,QJ=447,eQ=448,tQ=449,nQ=454,rQ=460,iQ=461,sQ=465,oQ=466,aQ=480,cQ=481,lQ=443,uQ=477,hQ=478,dQ=479,fQ=277,pQ=275,mQ=276,gQ=280,yQ=281,HL=290,bQ=777;function EA(n){return e=>ne(e,n)}function SA(n){return e=>ge(e,n)}function xh(n){return new DataView(n.buffer).getUint16(n.byteOffset).toString()}function Qc(n){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof n=="string"?parseInt(n):n),new Uint8Array(e)}function wQ(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=ge(e[0],"base32"),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const i=Qc(r);return nt([t,i],t.length+i.length)}function vQ(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=yn.decode(`b${e[0]}`),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const i=Qc(r);return nt([t,i],t.length+i.length)}function xA(n){const e=n.subarray(0,n.length-2),t=n.subarray(n.length-2),r=ne(e,"base32"),i=xh(t);return`${r}:${i}`}const GL=function(n){n=n.toString().trim();const e=new Uint8Array(4);return n.split(/\./g).forEach((t,r)=>{const i=parseInt(t,10);if(isNaN(i)||i<0||i>255)throw new ii("Invalid byte value in IP address");e[r]=i}),e},_Q=function(n){let e=0;n=n.toString().trim();const t=n.split(":",8);let r;for(r=0;r<t.length;r++){const s=Pt(t[r]);let o;s&&(o=GL(t[r]),t[r]=ne(o.subarray(0,2),"base16")),o!=null&&++r<8&&t.splice(r,0,ne(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(r=0;r<t.length&&t[r]!=="";r++);const s=[r,1];for(r=9-t.length;r>0;r--)s.push("0");t.splice.apply(t,s)}const i=new Uint8Array(e+16);for(r=0;r<t.length;r++){t[r]===""&&(t[r]="0");const s=parseInt(t[r],16);if(isNaN(s)||s<0||s>65535)throw new ii("Invalid byte value in IP address");i[e++]=s>>8&255,i[e++]=s&255}return i},EQ=function(n){if(n.byteLength!==4)throw new ii("IPv4 address was incorrect length");const e=[];for(let t=0;t<n.byteLength;t++)e.push(n[t]);return e.join(".")},SQ=function(n){if(n.byteLength!==16)throw new ii("IPv6 address was incorrect length");const e=[];for(let r=0;r<n.byteLength;r+=2){const i=n[r],s=n[r+1],o=`${i.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const r=new URL(`http://[${t}]`);return r.hostname.substring(1,r.hostname.length-1)}catch{throw new ii(`Invalid IPv6 address "${t}"`)}};function xQ(n){try{const e=new URL(`http://[${n}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new ii(`Invalid IPv6 address "${n}"`)}}const A0=Object.values(Fr).map(n=>n.decoder),TQ=(function(){let n=A0[0].or(A0[1]);return A0.slice(2).forEach(e=>n=n.or(e)),n})();function AQ(n){return TQ.decode(n)}function MQ(n){return e=>n.encoder.encode(e)}function CQ(n){if(parseInt(n).toString()!==n)throw new vd("Value must be an integer")}function IQ(n){if(n<0)throw new vd("Value must be a positive integer, or zero")}function PQ(n){return e=>{if(e>n)throw new vd(`Value must be smaller than or equal to ${n}`)}}function DQ(...n){return e=>{for(const t of n)t(e)}}const up=DQ(CQ,IQ,PQ(65535)),zn=-1;let RQ=class{constructor(){h(this,"protocolsByCode",new Map);h(this,"protocolsByName",new Map)}getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new LJ(`Protocol ${e} was unknown`);return t}addProtocol(e){var t;this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),(t=e.aliases)==null||t.forEach(r=>{this.protocolsByName.set(r,e)})}removeProtocol(e){var r;const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),(r=t.aliases)==null||r.forEach(i=>{this.protocolsByName.delete(i)}))}};const Fu=new RQ,LQ=[{code:OJ,name:"ip4",size:32,valueToBytes:GL,bytesToValue:EQ,validate:n=>{if(!Pt(n))throw new vd(`Invalid IPv4 address "${n}"`)}},{code:NJ,name:"tcp",size:16,valueToBytes:Qc,bytesToValue:xh,validate:up},{code:UJ,name:"udp",size:16,valueToBytes:Qc,bytesToValue:xh,validate:up},{code:BJ,name:"dccp",size:16,valueToBytes:Qc,bytesToValue:xh,validate:up},{code:kJ,name:"ip6",size:128,valueToBytes:_Q,bytesToValue:SQ,stringToValue:xQ,validate:n=>{if(!hi(n))throw new vd(`Invalid IPv6 address "${n}"`)}},{code:$J,name:"ip6zone",size:zn},{code:FJ,name:"ipcidr",size:8,bytesToValue:EA("base10"),valueToBytes:SA("base10")},{code:zJ,name:"dns",size:zn},{code:VJ,name:"dns4",size:zn},{code:HJ,name:"dns6",size:zn},{code:GJ,name:"dnsaddr",size:zn},{code:WJ,name:"sctp",size:16,valueToBytes:Qc,bytesToValue:xh,validate:up},{code:qJ,name:"udt"},{code:KJ,name:"utp"},{code:XJ,name:"unix",size:zn,stringToValue:n=>decodeURIComponent(n),valueToString:n=>encodeURIComponent(n)},{code:YJ,name:"p2p",aliases:["ipfs"],size:zn,bytesToValue:EA("base58btc"),valueToBytes:n=>n.startsWith("Q")||n.startsWith("1")?SA("base58btc")(n):ze.parse(n).multihash.bytes},{code:ZJ,name:"onion",size:96,bytesToValue:xA,valueToBytes:wQ},{code:jJ,name:"onion3",size:296,bytesToValue:xA,valueToBytes:vQ},{code:JJ,name:"garlic64",size:zn},{code:QJ,name:"garlic32",size:zn},{code:eQ,name:"tls"},{code:tQ,name:"sni",size:zn},{code:nQ,name:"noise"},{code:rQ,name:"quic"},{code:iQ,name:"quic-v1"},{code:sQ,name:"webtransport"},{code:oQ,name:"certhash",size:zn,bytesToValue:MQ(ui),valueToBytes:AQ},{code:aQ,name:"http"},{code:cQ,name:"http-path",size:zn,stringToValue:n=>`/${decodeURIComponent(n)}`,valueToString:n=>encodeURIComponent(n.substring(1))},{code:lQ,name:"https"},{code:uQ,name:"ws"},{code:hQ,name:"wss"},{code:dQ,name:"p2p-websocket-star"},{code:fQ,name:"p2p-stardust"},{code:pQ,name:"p2p-webrtc-star"},{code:mQ,name:"p2p-webrtc-direct"},{code:gQ,name:"webrtc-direct"},{code:yQ,name:"webrtc"},{code:HL,name:"p2p-circuit"},{code:bQ,name:"memory",size:zn}];LQ.forEach(n=>{Fu.addProtocol(n)});function OQ(n){var r;const e=[];let t=0;for(;t<n.length;){const i=zt(n,t),s=Fu.getProtocol(i),o=Me(i),a=kQ(s,n,t+o);let c=0;a>0&&s.size===zn&&(c=Me(a));const l=o+c+a,u={code:i,name:s.name,bytes:n.subarray(t,t+l)};if(a>0){const d=t+o+c,f=n.subarray(d,d+a);u.value=((r=s.bytesToValue)==null?void 0:r.call(s,f))??ne(f)}e.push(u),t+=l}return e}function NQ(n){var r;let e=0;const t=[];for(const i of n){if(i.bytes==null){const s=Fu.getProtocol(i.code),o=Me(i.code);let a,c=0,l=0;i.value!=null&&(a=((r=s.valueToBytes)==null?void 0:r.call(s,i.value))??ge(i.value),c=a.byteLength,s.size===zn&&(l=Me(c)));const u=new Uint8Array(o+l+c);let d=0;Xt(i.code,u,d),d+=o,a!=null&&(s.size===zn&&(Xt(c,u,d),d+=l),u.set(a,d)),i.bytes=u}t.push(i.bytes),e+=i.bytes.byteLength}return nt(t,e)}function UQ(n){var s;if(n.charAt(0)!=="/")throw new ii('String multiaddr must start with "/"');const e=[];let t="protocol",r="",i="";for(let o=1;o<n.length;o++){const a=n.charAt(o);a!=="/"&&(t==="protocol"?i+=n.charAt(o):r+=n.charAt(o));const c=o===n.length-1;if(a==="/"||c){const l=Fu.getProtocol(i);if(t==="protocol"){if(l.size==null||l.size===0){e.push({code:l.code,name:l.name}),r="",i="",t="protocol";continue}else if(c)throw new ii(`Component ${i} was missing value`);t="value"}else if(t==="value"){const u={code:l.code,name:l.name};if(l.size!=null&&l.size!==0){if(r==="")throw new ii(`Component ${i} was missing value`);u.value=((s=l.stringToValue)==null?void 0:s.call(l,r))??r}e.push(u),r="",i="",t="protocol"}}}if(i!==""&&r!=="")throw new ii("Incomplete multiaddr");return e}function BQ(n){return`/${n.flatMap(e=>{var r;if(e.value==null)return e.name;const t=Fu.getProtocol(e.code);if(t==null)throw new ii(`Unknown protocol code ${e.code}`);return[e.name,((r=t.valueToString)==null?void 0:r.call(t,e.value))??e.value]}).join("/")}`}function kQ(n,e,t){return n.size==null||n.size===0?0:n.size>0?n.size/8:zt(e,t)}const $Q=Symbol.for("nodejs.util.inspect.custom"),WL=Symbol.for("@multiformats/multiaddr");function FQ(n){if(n==null&&(n="/"),HQ(n))return n.getComponents();if(n instanceof Uint8Array)return OQ(n);if(typeof n=="string")return n=n.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),n===""&&(n="/"),UQ(n);if(Array.isArray(n))return n;throw new ii("Must be a string, Uint8Array, Component[], or another Multiaddr")}var CC,xi,Ul,Bl,qs;let zQ=(qs=class{constructor(e="/",t={}){h(this,CC,!0);me(this,xi);me(this,Ul);me(this,Bl);pe(this,xi,FQ(e)),t.validate!==!1&&VQ(this)}get bytes(){return D(this,Bl)==null&&pe(this,Bl,NQ(D(this,xi))),D(this,Bl)}toString(){return D(this,Ul)==null&&pe(this,Ul,BQ(D(this,xi))),D(this,Ul)}toJSON(){return this.toString()}getComponents(){return[...D(this,xi).map(e=>({...e}))]}encapsulate(e){const t=new qs(e);return new qs([...D(this,xi),...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),r=this.toString(),i=r.lastIndexOf(t);if(i<0)throw new RJ(`Address ${this.toString()} does not contain subaddress: ${t}`);return new qs(r.slice(0,i),{validate:!1})}decapsulateCode(e){let t;for(let r=D(this,xi).length-1;r>-1;r--)if(D(this,xi)[r].code===e){t=r;break}return new qs(D(this,xi).slice(0,t),{validate:!1})}equals(e){return Ne(this.bytes,e.bytes)}[(CC=WL,$Q)](){return`Multiaddr(${this.toString()})`}},xi=new WeakMap,Ul=new WeakMap,Bl=new WeakMap,qs);function VQ(n){n.getComponents().forEach(e=>{var r;const t=Fu.getProtocol(e.code);e.value!=null&&((r=t.validate)==null||r.call(t,e.value))})}function HQ(n){return!!(n!=null&&n[WL])}function qL(n){return new zQ(n)}var mr;(function(n){(function(r){r.FIN="FIN",r.STOP_SENDING="STOP_SENDING",r.RESET="RESET",r.FIN_ACK="FIN_ACK"})(n.Flag||(n.Flag={}));let e;(function(r){r[r.FIN=0]="FIN",r[r.STOP_SENDING=1]="STOP_SENDING",r[r.RESET=2]="RESET",r[r.FIN_ACK=3]="FIN_ACK"})(e||(e={})),(function(r){r.codec=()=>hc(e)})(n.Flag||(n.Flag={}));let t;n.codec=()=>(t==null&&(t=Nt((r,i,s={})=>{s.lengthDelimited!==!1&&i.fork(),r.flag!=null&&(i.uint32(8),n.Flag.codec().encode(r.flag,i)),r.message!=null&&(i.uint32(18),i.bytes(r.message)),s.lengthDelimited!==!1&&i.ldelim()},(r,i,s={})=>{const o={},a=i==null?r.len:r.pos+i;for(;r.pos<a;){const c=r.uint32();switch(c>>>3){case 1:{o.flag=n.Flag.codec().decode(r);break}case 2:{o.message=r.bytes();break}default:{r.skipType(c&7);break}}}return o})),t),n.encode=r=>Ot(r,n.codec()),n.decode=(r,i)=>Lt(r,n.codec(),i)})(mr||(mr={}));const GQ=["stun:stun.l.google.com:19302","stun:global.stun.twilio.com:3478","stun:stun.cloudflare.com:3478","stun:stun.services.mozilla.com:3478"];Array.from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890");const WQ=2*1024*1024,KL=16*1024;function qQ(n=KL){const e=Me(n-Me(n)),t=1+Me(Object.keys(mr.Flag).length-1),r=1,i=n-e-t-r,s=Me(i);return e+t+r+s}const KQ=qQ(),XQ=1e4,XL="/webrtc",Jv="/webrtc-signaling/0.0.1",YQ=8,rS=1024*1024*4;let ZQ=class extends Error{constructor(){super(...arguments);h(this,"name","InvalidMessageLengthError");h(this,"code","ERR_INVALID_MSG_LENGTH")}},YL=class extends Error{constructor(){super(...arguments);h(this,"name","InvalidDataLengthError");h(this,"code","ERR_MSG_DATA_TOO_LONG")}},jQ=class extends Error{constructor(){super(...arguments);h(this,"name","InvalidDataLengthLengthError");h(this,"code","ERR_MSG_LENGTH_TOO_LONG")}},TA=class extends Error{constructor(){super(...arguments);h(this,"name","UnexpectedEOFError");h(this,"code","ERR_UNEXPECTED_EOF")}};function ZL(n){return n[Symbol.asyncIterator]!=null}function jL(n,e){if(n.byteLength>e)throw new YL("Message length too long")}const Vg=n=>{const e=Me(n),t=zi(e);return ul(n,t),Vg.bytes=e,t};Vg.bytes=0;function Qv(n,e){e=e??{};const t=e.lengthEncoder??Vg,r=(e==null?void 0:e.maxDataLength)??rS;function*i(s){jL(s,r);const o=t(s.byteLength);o instanceof Uint8Array?yield o:yield*o,s instanceof Uint8Array?yield s:yield*s}return ZL(n)?(async function*(){for await(const s of n)yield*i(s)})():(function*(){for(const s of n)yield*i(s)})()}Qv.single=(n,e)=>{e=e??{};const t=e.lengthEncoder??Vg,r=(e==null?void 0:e.maxDataLength)??rS;return jL(n,r),new ut(t(n.byteLength),n)};var Ea;(function(n){n[n.LENGTH=0]="LENGTH",n[n.DATA=1]="DATA"})(Ea||(Ea={}));const iS=n=>{const e=zt(n);return iS.bytes=Me(e),e};iS.bytes=0;function e_(n,e){const t=new ut;let r=Ea.LENGTH,i=-1;const s=(e==null?void 0:e.lengthDecoder)??iS,o=(e==null?void 0:e.maxLengthLength)??YQ,a=(e==null?void 0:e.maxDataLength)??rS;function*c(){for(;t.byteLength>0;){if(r===Ea.LENGTH)try{if(i=s(t),i<0)throw new ZQ("Invalid message length");if(i>a)throw new YL("Message length too long");const l=s.bytes;t.consume(l),(e==null?void 0:e.onLength)!=null&&e.onLength(i),r=Ea.DATA}catch(l){if(l instanceof RangeError){if(t.byteLength>o)throw new jQ("Message length length too long");break}throw l}if(r===Ea.DATA){if(t.byteLength<i)break;const l=t.sublist(0,i);t.consume(i),(e==null?void 0:e.onData)!=null&&e.onData(l),yield l,r=Ea.LENGTH}}}return ZL(n)?(async function*(){for await(const l of n)t.append(l),yield*c();if(t.byteLength>0)throw new TA("Unexpected end of input")})():(function*(){for(const l of n)t.append(l),yield*c();if(t.byteLength>0)throw new TA("Unexpected end of input")})()}e_.fromReader=(n,e)=>{let t=1;const r=(async function*(){for(;;)try{const{done:s,value:o}=await n.next(t);if(s===!0)return;o!=null&&(yield o)}catch(s){if(s.code==="ERR_UNDER_READ")return{done:!0,value:null};throw s}finally{t=1}})();return e_(r,{...e??{},onLength:s=>{t=s}})};var AA=function(n,e,t){if(t||arguments.length===2)for(var r=0,i=e.length,s;r<i;r++)(s||!(r in e))&&(s||(s=Array.prototype.slice.call(e,0,r)),s[r]=e[r]);return n.concat(s||Array.prototype.slice.call(e))},JQ=(function(){function n(e,t,r){this.name=e,this.version=t,this.os=r,this.type="browser"}return n})(),QQ=(function(){function n(e){this.version=e,this.type="node",this.name="node",this.os=process.platform}return n})(),eee=(function(){function n(e,t,r,i){this.name=e,this.version=t,this.os=r,this.bot=i,this.type="bot-device"}return n})(),tee=(function(){function n(){this.type="bot",this.bot=!0,this.name="bot",this.version=null,this.os=null}return n})(),nee=(function(){function n(){this.type="react-native",this.name="react-native",this.version=null,this.os=null}return n})(),ree=/alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,iee=/(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,MA=3,see=[["aol",/AOLShield\/([0-9\._]+)/],["edge",/Edge\/([0-9\._]+)/],["edge-ios",/EdgiOS\/([0-9\._]+)/],["yandexbrowser",/YaBrowser\/([0-9\._]+)/],["kakaotalk",/KAKAOTALK\s([0-9\.]+)/],["samsung",/SamsungBrowser\/([0-9\.]+)/],["silk",/\bSilk\/([0-9._-]+)\b/],["miui",/MiuiBrowser\/([0-9\.]+)$/],["beaker",/BeakerBrowser\/([0-9\.]+)/],["edge-chromium",/EdgA?\/([0-9\.]+)/],["chromium-webview",/(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["chrome",/(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["phantomjs",/PhantomJS\/([0-9\.]+)(:?\s|$)/],["crios",/CriOS\/([0-9\.]+)(:?\s|$)/],["firefox",/Firefox\/([0-9\.]+)(?:\s|$)/],["fxios",/FxiOS\/([0-9\.]+)/],["opera-mini",/Opera Mini.*Version\/([0-9\.]+)/],["opera",/Opera\/([0-9\.]+)(?:\s|$)/],["opera",/OPR\/([0-9\.]+)(:?\s|$)/],["pie",/^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],["pie",/^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],["netfront",/^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],["ie",/Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],["ie",/MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],["ie",/MSIE\s(7\.0)/],["bb10",/BB10;\sTouch.*Version\/([0-9\.]+)/],["android",/Android\s([0-9\.]+)/],["ios",/Version\/([0-9\._]+).*Mobile.*Safari.*/],["safari",/Version\/([0-9\._]+).*Safari/],["facebook",/FB[AS]V\/([0-9\.]+)/],["instagram",/Instagram\s([0-9\.]+)/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Mobile/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Gecko\)$/],["curl",/^curl\/([0-9\.]+)$/],["searchbot",ree]],CA=[["iOS",/iP(hone|od|ad)/],["Android OS",/Android/],["BlackBerry OS",/BlackBerry|BB10/],["Windows Mobile",/IEMobile/],["Amazon OS",/Kindle/],["Windows 3.11",/Win16/],["Windows 95",/(Windows 95)|(Win95)|(Windows_95)/],["Windows 98",/(Windows 98)|(Win98)/],["Windows 2000",/(Windows NT 5.0)|(Windows 2000)/],["Windows XP",/(Windows NT 5.1)|(Windows XP)/],["Windows Server 2003",/(Windows NT 5.2)/],["Windows Vista",/(Windows NT 6.0)/],["Windows 7",/(Windows NT 6.1)/],["Windows 8",/(Windows NT 6.2)/],["Windows 8.1",/(Windows NT 6.3)/],["Windows 10",/(Windows NT 10.0)/],["Windows ME",/Windows ME/],["Windows CE",/Windows CE|WinCE|Microsoft Pocket Internet Explorer/],["Open BSD",/OpenBSD/],["Sun OS",/SunOS/],["Chrome OS",/CrOS/],["Linux",/(Linux)|(X11)/],["Mac OS",/(Mac_PowerPC)|(Macintosh)/],["QNX",/QNX/],["BeOS",/BeOS/],["OS/2",/OS\/2/]];function oee(n){return typeof document>"u"&&typeof navigator<"u"&&navigator.product==="ReactNative"?new nee:typeof navigator<"u"?cee(navigator.userAgent):uee()}function aee(n){return n!==""&&see.reduce(function(e,t){var r=t[0],i=t[1];if(e)return e;var s=i.exec(n);return!!s&&[r,s]},!1)}function cee(n){var e=aee(n);if(!e)return null;var t=e[0],r=e[1];if(t==="searchbot")return new tee;var i=r[1]&&r[1].split(".").join("_").split("_").slice(0,3);i?i.length<MA&&(i=AA(AA([],i,!0),hee(MA-i.length),!0)):i=[];var s=i.join("."),o=lee(n),a=iee.exec(n);return a&&a[1]?new eee(t,s,o,a[1]):new JQ(t,s,o)}function lee(n){for(var e=0,t=CA.length;e<t;e++){var r=CA[e],i=r[0],s=r[1],o=s.exec(n);if(o)return i}return null}function uee(){var n=typeof process<"u"&&process.version;return n?new QQ(process.version.slice(1)):null}function hee(n){for(var e=[],t=0;t<n;t++)e.push("0");return e}const IA=oee(),dee=IA!=null&&IA.name==="firefox";async function PA(n){return n=n??{},typeof n=="function"&&(n=await n()),n.iceServers=n.iceServers??GQ.map(e=>({urls:[e]})),n}class fee extends ND{constructor(t){super({...t,maxMessageSize:(t.maxMessageSize??KL)-KQ});h(this,"channel");h(this,"incomingData");h(this,"maxBufferedAmount");h(this,"receivedFinAck");h(this,"finAckTimeout");this.channel=t.channel,this.channel.binaryType="arraybuffer",this.incomingData=Ug(),this.maxBufferedAmount=t.maxBufferedAmount??WQ,this.finAckTimeout=t.finAckTimeout??XQ,this.channel.onclose=()=>{this.log.trace("received datachannel close event"),this.onRemoteCloseWrite(),this.onTransportClosed()},this.channel.onerror=i=>{const s=i.error;this.log.trace("received datachannel error event - %e",s),this.abort(s)},this.channel.onmessage=async i=>{this.log("incoming message %d bytes",i.data.byteLength);const{data:s}=i;s===null||s.byteLength===0||this.incomingData.push(new Uint8Array(s,0,s.byteLength))},this.channel.bufferedAmountLowThreshold=0,this.channel.onbufferedamountlow=()=>{this.writableNeedsDrain&&this.safeDispatchEvent("drain")},Promise.resolve().then(async()=>{for await(const i of e_(this.incomingData))this.processIncomingProtobuf(i)}).catch(i=>{this.log.error("error processing incoming data channel messages - %e",i)});const r=()=>{this.channel.readyState==="open"&&(this.log.trace("stream closed, closing underlying datachannel"),this.channel.close())};this.addEventListener("close",r),this.channel.readyState!=="open"&&(this.log('channel ready state is "%s" and not "open", waiting for "open" event before sending data',this.channel.readyState),bn(this.channel,"open",{rejectionEvents:["close","error"]}).then(()=>{this.log('channel ready state is now "%s", dispatching drain',this.channel.readyState),this.safeDispatchEvent("drain")}).catch(i=>{this.abort(i.error??i)}))}sendNewStream(){}_sendMessage(t){if(this.channel.readyState!=="open")throw new BL(`Invalid datachannel state - ${this.channel.readyState}`);if(this.log.trace('sending message, channel state "%s"',this.channel.readyState),dee){this.channel.send(t.subarray());return}for(const r of t)this.channel.send(r)}sendData(t){return this.channel.readyState!=="open"?{sentBytes:0,canSendMore:!1}:(this._sendMessage(Qv.single(mr.encode({message:t.subarray()}))),{sentBytes:t.byteLength,canSendMore:this.channel.bufferedAmount<this.maxBufferedAmount})}sendReset(t){var r;try{this.log.error("sending reset - %e",t),this._sendFlag(mr.Flag.RESET),(r=this.receivedFinAck)==null||r.reject(t)}catch(i){this.log.error("failed to send reset - %e",i)}}async sendCloseWrite(t){var s;this._sendFlag(mr.Flag.FIN),(s=t==null?void 0:t.signal)==null||s.throwIfAborted(),this.receivedFinAck=Promise.withResolvers();const r=(t==null?void 0:t.signal)??AbortSignal.timeout(this.finAckTimeout),i=[bn(this.channel,"close",{signal:r}),bn(this.channel,"error",{signal:r})];await Promise.any([Vi(this.receivedFinAck.promise,r),...i]).finally(()=>{i.forEach(o=>o.cancel())})}async sendCloseRead(t){var r;this._sendFlag(mr.Flag.STOP_SENDING),(r=t==null?void 0:t.signal)==null||r.throwIfAborted()}processIncomingProtobuf(t){var i,s;const r=mr.decode(t);r.message!=null&&(this.readStatus==="readable"||this.readStatus==="paused")&&this.onData(new ut(r.message)),r.flag!==void 0&&(this.log.trace('incoming flag %s, write status "%s", read status "%s"',r.flag,this.writeStatus,this.readStatus),r.flag===mr.Flag.FIN&&(this._sendFlag(mr.Flag.FIN_ACK),this.onRemoteCloseWrite()),r.flag===mr.Flag.RESET&&((i=this.receivedFinAck)==null||i.reject(new UL("The stream was reset")),this.onRemoteReset()),r.flag===mr.Flag.STOP_SENDING&&this.onRemoteCloseRead(),r.flag===mr.Flag.FIN_ACK&&((s=this.receivedFinAck)==null||s.resolve()))}_sendFlag(t){if(this.channel.readyState!=="open")return this.log.trace('not sending flag %s because channel is "%s" and not "open"',t.toString(),this.channel.readyState),!1;this.log.trace("sending flag %s",t.toString());const r=mr.encode({flag:t}),i=Qv.single(r);try{return this._sendMessage(i),!0}catch(s){this.log.error("could not send flag %s - %e",t.toString(),s)}return!1}sendPause(){}sendResume(){}}function DA(n){const{channel:e,direction:t,isHandshake:r}=n;return new fee({...n,id:`${e.id}`,log:n.log.newScope(`${r===!0?"handshake":t}:${e.id}`),protocol:""})}class JL{constructor(e){h(this,"protocol");h(this,"peerConnection");h(this,"metrics");h(this,"dataChannelOptions");h(this,"earlyDataChannels");this.onEarlyDataChannel=this.onEarlyDataChannel.bind(this),this.peerConnection=e.peerConnection,this.metrics=e.metrics,this.protocol=e.protocol??XL,this.dataChannelOptions=e.dataChannelOptions??{},this.peerConnection.addEventListener("datachannel",this.onEarlyDataChannel),this.earlyDataChannels=[]}onEarlyDataChannel(e){this.earlyDataChannels.push(e.channel)}createStreamMuxer(e){return this.peerConnection.removeEventListener("datachannel",this.onEarlyDataChannel),new pee(e,{peerConnection:this.peerConnection,dataChannelOptions:this.dataChannelOptions,metrics:this.metrics,protocol:this.protocol,earlyDataChannels:this.earlyDataChannels})}}class pee extends OD{constructor(t,r){super(t,{...r,name:"muxer"});h(this,"peerConnection");h(this,"dataChannelOptions");this.peerConnection=r.peerConnection,this.protocol=r.protocol??XL,this.dataChannelOptions=r.dataChannelOptions??{},this.peerConnection.ondatachannel=({channel:i})=>{this.onDataChannel(i)},queueMicrotask(()=>{if(this.status!=="open"){r.earlyDataChannels.forEach(i=>{i.close()});return}r.earlyDataChannels.forEach(i=>{this.onDataChannel(i)})})}onDataChannel(t){if(this.log("incoming datachannel with channel id %d, protocol %s and status %s",t.id,t.protocol,t.readyState),t.label==="init"){this.log.trace("closing init channel %d",t.id),t.close();return}const r=DA({...this.streamOptions,...this.dataChannelOptions,channel:t,direction:"inbound",log:this.log});this.onRemoteStream(r)}async onCreateStream(t){const r=this.peerConnection.createDataChannel("",{});return this.log("open channel %d for protocol %s",r.id,t==null?void 0:t.protocol),DA({...t,...this.dataChannelOptions,channel:r,direction:"outbound",log:this.log})}onData(){}}class mee extends VE{constructor(t){super(t);h(this,"peerConnection");this.peerConnection=t.peerConnection;const r=t.peerConnection.connectionState;this.peerConnection.onconnectionstatechange=()=>{this.log.trace("peer connection state change %s initial state %s",this.peerConnection.connectionState,r),(this.peerConnection.connectionState==="disconnected"||this.peerConnection.connectionState==="failed"||this.peerConnection.connectionState==="closed")&&(this.onTransportClosed(),this.peerConnection.close())}}sendData(t){return{sentBytes:t.byteLength,canSendMore:!0}}async sendClose(t){var r;this.peerConnection.close(),(r=t==null?void 0:t.signal)==null||r.throwIfAborted()}sendReset(){this.peerConnection.close()}sendPause(){}sendResume(){}}const RA=n=>new mee(n),QL=globalThis.RTCPeerConnection,e3=globalThis.RTCSessionDescription,gee=globalThis.RTCIceCandidate;class yee extends Error{constructor(e){super(`WebRTC transport error: ${e}`),this.name="WebRTCTransportError"}}class $o extends yee{constructor(e="SDP handshake failed"){super(e),this.name="SDPHandshakeFailedError"}}var Ri;(function(n){(function(r){r.SDP_OFFER="SDP_OFFER",r.SDP_ANSWER="SDP_ANSWER",r.ICE_CANDIDATE="ICE_CANDIDATE"})(n.Type||(n.Type={}));let e;(function(r){r[r.SDP_OFFER=0]="SDP_OFFER",r[r.SDP_ANSWER=1]="SDP_ANSWER",r[r.ICE_CANDIDATE=2]="ICE_CANDIDATE"})(e||(e={})),(function(r){r.codec=()=>hc(e)})(n.Type||(n.Type={}));let t;n.codec=()=>(t==null&&(t=Nt((r,i,s={})=>{s.lengthDelimited!==!1&&i.fork(),r.type!=null&&(i.uint32(8),n.Type.codec().encode(r.type,i)),r.data!=null&&(i.uint32(18),i.string(r.data)),s.lengthDelimited!==!1&&i.ldelim()},(r,i,s={})=>{const o={},a=i==null?r.len:r.pos+i;for(;r.pos<a;){const c=r.uint32();switch(c>>>3){case 1:{o.type=n.Type.codec().decode(r);break}case 2:{o.data=r.string();break}default:{r.skipType(c&7);break}}}return o})),t),n.encode=r=>Ot(r,n.codec()),n.decode=(r,i)=>Lt(r,n.codec(),i)})(Ri||(Ri={}));const t3=async(n,e,t)=>{var r,i,s,o;try{const a=Promise.withResolvers();for(bee(n,a);;){const c=await Promise.race([a.promise,e.read({signal:t.signal})]);if(c==null){(r=t.signal)==null||r.throwIfAborted();break}if(c.type!==Ri.Type.ICE_CANDIDATE)throw new wJ("ICE candidate message expected");const l=JSON.parse(c.data??"null");if(l===""||l===null){(i=t.onProgress)==null||i.call(t,new vt("webrtc:end-of-ice-candidates")),t.log.trace("end-of-candidates received");continue}const u=new gee(l);t.log.trace("%s received new ICE candidate %o",t.direction,l);try{(s=t.onProgress)==null||s.call(t,new vt("webrtc:add-ice-candidate",u.candidate)),await n.addIceCandidate(u)}catch(d){t.log.error("%s bad candidate received %o - %e",t.direction,l,d)}}}catch(a){if(t.log.error("%s error parsing ICE candidate - %e",t.direction,a),((o=t.signal)==null?void 0:o.aborted)===!0&&n.connectionState!=="connected")throw a}};function bee(n,e){if(n.connectionState==="connected"){e.resolve();return}n.onconnectionstatechange=t=>{switch(n.connectionState){case"connected":e.resolve();break;case"failed":case"disconnected":case"closed":e.reject(new NL(`RTCPeerConnection connection state became "${n.connectionState}"`));break}}}function n3(n){let e;for(const t of n.getComponents())t.name==="p2p"&&(e=zL(t.value??""));if(e==null)throw new gJ("Remote peerId must be present in multiaddr");return e}async function wee({rtcConfiguration:n,dataChannel:e,signal:t,metrics:r,multiaddr:i,connectionManager:s,transportManager:o,log:a,logger:c,onProgress:l}){const{circuitAddress:u,targetPeer:d}=Eee(i);r==null||r.dialerEvents.increment({open:!0}),a.trace("dialing circuit address: %a",u);const f=s.getConnections(d);let p;f.length===0?(l==null||l(new vt("webrtc:dial-relay")),p=await o.dial(u,{signal:t,onProgress:l})):(l==null||l(new vt("webrtc:reuse-relay-connection")),p=f[0]),l==null||l(new vt("webrtc:open-signaling-stream"));const g=await p.newStream(Jv,{signal:t,runOnLimitedConnection:!0}),b=Jo(g).pb(Ri),m=new QL(n);m.addEventListener("connectionstatechange",()=>{switch(m.connectionState){case"closed":m.close();break}});const y=new JL({peerConnection:m,dataChannelOptions:e});try{const E=m.createDataChannel("init");m.onicecandidate=({candidate:A})=>{if(m.connectionState==="connected"){a.trace("ignore new ice candidate as peer connection is already connected");return}if(A==null||(A==null?void 0:A.candidate)===""){a.trace("initiator detected end of ICE candidates");return}const C=JSON.stringify((A==null?void 0:A.toJSON())??null);a.trace("initiator sending ICE candidate %o",A),b.write({type:Ri.Type.ICE_CANDIDATE,data:C},{signal:t}).catch(R=>{a.error("error sending ICE candidate - %e",R)})},m.onicecandidateerror=A=>{a.error("initiator ICE candidate error",A)};const w=await m.createOffer().catch(A=>{throw a.error("could not execute createOffer - %e",A),new $o("Failed to set createOffer")});a.trace("initiator send SDP offer %s",w.sdp),l==null||l(new vt("webrtc:send-sdp-offer")),await b.write({type:Ri.Type.SDP_OFFER,data:w.sdp},{signal:t}),await m.setLocalDescription(w).catch(A=>{throw a.error("could not execute setLocalDescription - %e",A),new $o("Failed to set localDescription")}),l==null||l(new vt("webrtc:read-sdp-answer")),a.trace("initiator read SDP answer");const x=await b.read({signal:t});if(x.type!==Ri.Type.SDP_ANSWER)throw new $o("Remote should send an SDP answer");a.trace("initiator received SDP answer %s",x.data);const M=new e3({type:"answer",sdp:x.data});return await m.setRemoteDescription(M).catch(A=>{throw a.error("could not execute setRemoteDescription - %e",A),new $o("Failed to set remoteDescription")}),a.trace("initiator read candidates until connected"),l==null||l(new vt("webrtc:read-ice-candidates")),await t3(m,b,{direction:"initiator",signal:t,log:a,onProgress:l}),a.trace("initiator connected"),E.readyState!=="open"&&(a.trace("wait for init channel to open"),await bn(E,"open",{signal:t})),a.trace("closing init channel"),E.close(),a.trace("waiting for init channel to close"),await bn(E,"close",{signal:t}),l==null||l(new vt("webrtc:close-signaling-stream")),a.trace("closing signaling channel"),await g.close({signal:t}),a.trace("initiator connected to remote address %s",i),{remoteAddress:i,peerConnection:m,muxerFactory:y}}catch(E){throw a.error("outgoing signaling error - %e",E),m.close(),g.abort(E),E}finally{m.onicecandidate=null,m.onicecandidateerror=null}}const LA=Tt(tS.matchers[0],xt(HL));class sS extends fr{constructor(t,r){super();h(this,"transportManager");h(this,"shutdownController");h(this,"events");this.transportManager=t.transportManager,this.events=t.events,this.shutdownController=r.shutdownController,this.onTransportListening=this.onTransportListening.bind(this)}async listen(){this.events.addEventListener("transport:listening",this.onTransportListening)}onTransportListening(t){t.detail.getAddrs().filter(i=>LA.exactMatch(i)).map(i=>i.encapsulate("/webrtc")).length>0&&this.safeDispatchEvent("listening")}getAddrs(){return this.transportManager.getListeners().filter(t=>!(t instanceof sS)).map(t=>t.getAddrs().filter(r=>LA.exactMatch(r)).map(r=>r.encapsulate("/webrtc"))).flat()}updateAnnounceAddrs(){}async close(){this.events.removeEventListener("transport:listening",this.onTransportListening),this.shutdownController.abort(),queueMicrotask(()=>{this.safeDispatchEvent("close")})}}async function vee(n,e,{peerConnection:t,signal:r,log:i}){i.trace("new inbound signaling stream");const s=Jo(n).pb(Ri);try{t.onicecandidate=({candidate:d})=>{if(t.connectionState==="connected"){i.trace("ignore new ice candidate as peer connection is already connected");return}if(d==null||(d==null?void 0:d.candidate)===""){i.trace("recipient detected end of ICE candidates");return}const f=JSON.stringify((d==null?void 0:d.toJSON())??null);i.trace("recipient sending ICE candidate %s",f),s.write({type:Ri.Type.ICE_CANDIDATE,data:f},{signal:r}).catch(p=>{i.error("error sending ICE candidate - %e",p)})},i.trace("recipient read SDP offer");const c=await s.read({signal:r});if(c.type!==Ri.Type.SDP_OFFER)throw new $o(`expected message type SDP_OFFER, received: ${c.type??"undefined"} `);i.trace("recipient received SDP offer %s",c.data);const l=new e3({type:"offer",sdp:c.data});await t.setRemoteDescription(l).catch(d=>{throw i.error("could not execute setRemoteDescription - %e",d),new $o("Failed to set remoteDescription")});const u=await t.createAnswer().catch(d=>{throw i.error("could not execute createAnswer - %e",d),new $o("Failed to create answer")});i.trace("recipient send SDP answer %s",u.sdp),await s.write({type:Ri.Type.SDP_ANSWER,data:u.sdp},{signal:r}),await t.setLocalDescription(u).catch(d=>{throw i.error("could not execute setLocalDescription - %e",d),new $o("Failed to set localDescription")}),i.trace("recipient read candidates until connected"),await t3(t,s,{direction:"recipient",signal:r,log:i})}catch(c){if(t.connectionState!=="connected")throw i.error("error while handling signaling stream from peer %a - %e",e.remoteAddr,c),t.close(),c;i("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected",e.remoteAddr,c)}const o=n3(e.remoteAddr),a=qL(`/webrtc/p2p/${o}`);return i.trace("recipient connected to remote address %s",a),{remoteAddress:a,remotePeer:o}}var IC,PC,DC,RC;RC=vJ,DC=Symbol.toStringTag,PC=_J,IC=EJ;class _ee{constructor(e,t={}){h(this,"components");h(this,"init");h(this,"log");h(this,"_started",!1);h(this,"metrics");h(this,"shutdownController");h(this,RC,!0);h(this,DC,"@libp2p/webrtc");h(this,PC,["@libp2p/transport"]);h(this,IC,["@libp2p/identify","@libp2p/circuit-relay-v2-transport"]);this.components=e,this.init=t,this.log=e.logger.forComponent("libp2p:webrtc"),this.shutdownController=new AbortController,this.shutdownController.signal,e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total",{label:"event",help:"Total count of WebRTC dialer events by type"}),listenerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total",{label:"event",help:"Total count of WebRTC listener events by type"})})}isStarted(){return this._started}async start(){await this.components.registrar.handle(Jv,(e,t)=>{const r=this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);this._onProtocol(e,t,r).catch(i=>{this.log.error("failed to handle incoming connect from %p - %e",t.remotePeer,i)}).finally(()=>{r.clear()})},{runOnLimitedConnection:!0}),this._started=!0}async stop(){await this.components.registrar.unhandle(Jv),this._started=!1}createListener(e){return new sS(this.components,{shutdownController:this.shutdownController})}listenFilter(e){return e.filter(zv.exactMatch)}dialFilter(e){return this.listenFilter(e)}async dial(e,t){var c;this.log.trace("dialing address: %a",e);const{remoteAddress:r,peerConnection:i,muxerFactory:s}=await wee({rtcConfiguration:await PA(this.init.rtcConfiguration),dataChannel:this.init.dataChannel,multiaddr:e,dataChannelOptions:this.init.dataChannel,signal:t.signal,connectionManager:this.components.connectionManager,transportManager:this.components.transportManager,log:this.log,logger:this.components.logger,onProgress:t.onProgress}),o=RA({peerConnection:i,remoteAddr:r,metrics:(c=this.metrics)==null?void 0:c.dialerEvents,direction:"outbound",log:this.components.logger.forComponent("libp2p:webrtc:connection")}),a=await t.upgrader.upgradeOutbound(o,{skipProtection:!0,skipEncryption:!0,remotePeer:n3(e),muxerFactory:s,onProgress:t.onProgress,signal:t.signal});return this._closeOnShutdown(i,o),a}async _onProtocol(e,t,r){var o;const i=new QL(await PA(this.init.rtcConfiguration));i.addEventListener("connectionstatechange",()=>{switch(i.connectionState){case"closed":i.close();break}});const s=new JL({peerConnection:i,dataChannelOptions:this.init.dataChannel});try{const{remoteAddress:a,remotePeer:c}=await vee(e,t,{peerConnection:i,signal:r,log:this.log});await e.close({signal:r});const l=RA({peerConnection:i,remoteAddr:a,metrics:(o=this.metrics)==null?void 0:o.listenerEvents,direction:"inbound",log:this.components.logger.forComponent("libp2p:webrtc:connection")});await this.components.upgrader.upgradeInbound(l,{skipEncryption:!0,skipProtection:!0,remotePeer:c,muxerFactory:s,signal:r}),this._closeOnShutdown(i,l)}catch(a){throw this.log.error("incoming signaling error - %e",a),i.close(),e.abort(a),a}}_closeOnShutdown(e,t){const r=()=>{t.close().catch(i=>{this.log.error("could not close WebRTCMultiaddrConnection - %e",i)})};this.shutdownController.signal.addEventListener("abort",r),e.addEventListener("close",()=>{this.shutdownController.signal.removeEventListener("abort",r)})}}function Eee(n){const e=n.getComponents().filter(({name:r})=>r==="p2p").map(({value:r})=>r).pop();if(e==null)throw new OL("Destination peer id was missing");return{circuitAddress:qL(n.getComponents().filter(({name:r})=>r!=="webrtc")),targetPeer:zL(e)}}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function See(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function t_(n){if(typeof n!="boolean")throw new Error(`boolean expected, not ${n}`)}function M0(n){if(!Number.isSafeInteger(n)||n<0)throw new Error("positive integer expected, got "+n)}function lr(n,e,t=""){const r=See(n),i=n==null?void 0:n.length,s=e!==void 0;if(!r||s&&i!==e){const o=t&&`"${t}" `,a=s?` of length ${e}`:"",c=r?`length=${i}`:`type=${typeof n}`;throw new Error(o+"expected Uint8Array"+a+", got "+c)}return n}function OA(n,e=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(e&&n.finished)throw new Error("Hash#digest() has already been called")}function xee(n,e){lr(n,void 0,"output");const t=e.outputLen;if(n.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function Xo(n){return new Uint32Array(n.buffer,n.byteOffset,Math.floor(n.byteLength/4))}function mu(...n){for(let e=0;e<n.length;e++)n[e].fill(0)}function Tee(n){return new DataView(n.buffer,n.byteOffset,n.byteLength)}const Aee=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function Mee(n,e){if(e==null||typeof e!="object")throw new Error("options must be defined");return Object.assign(n,e)}function Cee(n,e){if(n.length!==e.length)return!1;let t=0;for(let r=0;r<n.length;r++)t|=n[r]^e[r];return t===0}const Iee=(n,e)=>{function t(r,...i){if(lr(r,void 0,"key"),!Aee)throw new Error("Non little-endian hardware is not yet supported");if(n.nonceLength!==void 0){const u=i[0];lr(u,n.varSizeNonce?void 0:n.nonceLength,"nonce")}const s=n.tagLength;s&&i[1]!==void 0&&lr(i[1],void 0,"AAD");const o=e(r,...i),a=(u,d)=>{if(d!==void 0){if(u!==2)throw new Error("cipher output not supported");lr(d,void 0,"output")}};let c=!1;return{encrypt(u,d){if(c)throw new Error("cannot encrypt() twice with same key + nonce");return c=!0,lr(u),a(o.encrypt.length,d),o.encrypt(u,d)},decrypt(u,d){if(lr(u),s&&u.length<s)throw new Error('"ciphertext" expected length bigger than tagLength='+s);return a(o.decrypt.length,d),o.decrypt(u,d)}}}return Object.assign(t,n),t};function NA(n,e,t=!0){if(e===void 0)return new Uint8Array(n);if(e.length!==n)throw new Error('"output" expected Uint8Array of length '+n+", got: "+e.length);if(t&&!Dee(e))throw new Error("invalid output, must be aligned");return e}function Pee(n,e,t){t_(t);const r=new Uint8Array(16),i=Tee(r);return i.setBigUint64(0,BigInt(e),t),i.setBigUint64(8,BigInt(n),t),r}function Dee(n){return n.byteOffset%4===0}function Lm(n){return Uint8Array.from(n)}const r3=n=>Uint8Array.from(n.split(""),e=>e.charCodeAt(0)),Ree=r3("expand 16-byte k"),Lee=r3("expand 32-byte k"),Oee=Xo(Ree),Nee=Xo(Lee);function ct(n,e){return n<<e|n>>>32-e}function n_(n){return n.byteOffset%4===0}const hp=64,Uee=16,i3=2**32-1,UA=Uint32Array.of();function Bee(n,e,t,r,i,s,o,a){const c=i.length,l=new Uint8Array(hp),u=Xo(l),d=n_(i)&&n_(s),f=d?Xo(i):UA,p=d?Xo(s):UA;for(let g=0;g<c;o++){if(n(e,t,r,u,o,a),o>=i3)throw new Error("arx: counter overflow");const b=Math.min(hp,c-g);if(d&&b===hp){const m=g/4;if(g%4!==0)throw new Error("arx: invalid block position");for(let y=0,E;y<Uee;y++)E=m+y,p[E]=f[E]^u[y];g+=hp;continue}for(let m=0,y;m<b;m++)y=g+m,s[y]=i[y]^l[m];g+=b}}function kee(n,e){const{allowShortKeys:t,extendNonceFn:r,counterLength:i,counterRight:s,rounds:o}=Mee({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},e);if(typeof n!="function")throw new Error("core must be a function");return M0(i),M0(o),t_(s),t_(t),(a,c,l,u,d=0)=>{lr(a,void 0,"key"),lr(c,void 0,"nonce"),lr(l,void 0,"data");const f=l.length;if(u===void 0&&(u=new Uint8Array(f)),lr(u,void 0,"output"),M0(d),d<0||d>=i3)throw new Error("arx: counter overflow");if(u.length<f)throw new Error(`arx: output (${u.length}) is shorter than data (${f})`);const p=[];let g=a.length,b,m;if(g===32)p.push(b=Lm(a)),m=Nee;else if(g===16&&t)b=new Uint8Array(32),b.set(a),b.set(a,16),m=Oee,p.push(b);else throw lr(a,32,"arx key"),new Error("invalid key size");n_(c)||p.push(c=Lm(c));const y=Xo(b);if(r){if(c.length!==24)throw new Error("arx: extended nonce must be 24 bytes");r(m,y,Xo(c.subarray(0,16)),y),c=c.subarray(16)}const E=16-i;if(E!==c.length)throw new Error(`arx: nonce must be ${E} or 16 bytes`);if(E!==12){const x=new Uint8Array(12);x.set(c,s?0:12-c.length),c=x,p.push(c)}const w=Xo(c);return Bee(n,m,y,w,l,u,d,o),mu(...p),u}}function wn(n,e){return n[e++]&255|(n[e++]&255)<<8}class $ee{constructor(e){h(this,"blockLen",16);h(this,"outputLen",16);h(this,"buffer",new Uint8Array(16));h(this,"r",new Uint16Array(10));h(this,"h",new Uint16Array(10));h(this,"pad",new Uint16Array(8));h(this,"pos",0);h(this,"finished",!1);e=Lm(lr(e,32,"key"));const t=wn(e,0),r=wn(e,2),i=wn(e,4),s=wn(e,6),o=wn(e,8),a=wn(e,10),c=wn(e,12),l=wn(e,14);this.r[0]=t&8191,this.r[1]=(t>>>13|r<<3)&8191,this.r[2]=(r>>>10|i<<6)&7939,this.r[3]=(i>>>7|s<<9)&8191,this.r[4]=(s>>>4|o<<12)&255,this.r[5]=o>>>1&8190,this.r[6]=(o>>>14|a<<2)&8191,this.r[7]=(a>>>11|c<<5)&8065,this.r[8]=(c>>>8|l<<8)&8191,this.r[9]=l>>>5&127;for(let u=0;u<8;u++)this.pad[u]=wn(e,16+2*u)}process(e,t,r=!1){const i=r?0:2048,{h:s,r:o}=this,a=o[0],c=o[1],l=o[2],u=o[3],d=o[4],f=o[5],p=o[6],g=o[7],b=o[8],m=o[9],y=wn(e,t+0),E=wn(e,t+2),w=wn(e,t+4),x=wn(e,t+6),M=wn(e,t+8),A=wn(e,t+10),C=wn(e,t+12),R=wn(e,t+14);let _=s[0]+(y&8191),T=s[1]+((y>>>13|E<<3)&8191),F=s[2]+((E>>>10|w<<6)&8191),k=s[3]+((w>>>7|x<<9)&8191),z=s[4]+((x>>>4|M<<12)&8191),v=s[5]+(M>>>1&8191),S=s[6]+((M>>>14|A<<2)&8191),P=s[7]+((A>>>11|C<<5)&8191),U=s[8]+((C>>>8|R<<8)&8191),B=s[9]+(R>>>5|i),O=0,V=O+_*a+T*(5*m)+F*(5*b)+k*(5*g)+z*(5*p);O=V>>>13,V&=8191,V+=v*(5*f)+S*(5*d)+P*(5*u)+U*(5*l)+B*(5*c),O+=V>>>13,V&=8191;let $=O+_*c+T*a+F*(5*m)+k*(5*b)+z*(5*g);O=$>>>13,$&=8191,$+=v*(5*p)+S*(5*f)+P*(5*d)+U*(5*u)+B*(5*l),O+=$>>>13,$&=8191;let W=O+_*l+T*c+F*a+k*(5*m)+z*(5*b);O=W>>>13,W&=8191,W+=v*(5*g)+S*(5*p)+P*(5*f)+U*(5*d)+B*(5*u),O+=W>>>13,W&=8191;let H=O+_*u+T*l+F*c+k*a+z*(5*m);O=H>>>13,H&=8191,H+=v*(5*b)+S*(5*g)+P*(5*p)+U*(5*f)+B*(5*d),O+=H>>>13,H&=8191;let Y=O+_*d+T*u+F*l+k*c+z*a;O=Y>>>13,Y&=8191,Y+=v*(5*m)+S*(5*b)+P*(5*g)+U*(5*p)+B*(5*f),O+=Y>>>13,Y&=8191;let te=O+_*f+T*d+F*u+k*l+z*c;O=te>>>13,te&=8191,te+=v*a+S*(5*m)+P*(5*b)+U*(5*g)+B*(5*p),O+=te>>>13,te&=8191;let j=O+_*p+T*f+F*d+k*u+z*l;O=j>>>13,j&=8191,j+=v*c+S*a+P*(5*m)+U*(5*b)+B*(5*g),O+=j>>>13,j&=8191;let re=O+_*g+T*p+F*f+k*d+z*u;O=re>>>13,re&=8191,re+=v*l+S*c+P*a+U*(5*m)+B*(5*b),O+=re>>>13,re&=8191;let le=O+_*b+T*g+F*p+k*f+z*d;O=le>>>13,le&=8191,le+=v*u+S*l+P*c+U*a+B*(5*m),O+=le>>>13,le&=8191;let fe=O+_*m+T*b+F*g+k*p+z*f;O=fe>>>13,fe&=8191,fe+=v*d+S*u+P*l+U*c+B*a,O+=fe>>>13,fe&=8191,O=(O<<2)+O|0,O=O+V|0,V=O&8191,O=O>>>13,$+=O,s[0]=V,s[1]=$,s[2]=W,s[3]=H,s[4]=Y,s[5]=te,s[6]=j,s[7]=re,s[8]=le,s[9]=fe}finalize(){const{h:e,pad:t}=this,r=new Uint16Array(10);let i=e[1]>>>13;e[1]&=8191;for(let a=2;a<10;a++)e[a]+=i,i=e[a]>>>13,e[a]&=8191;e[0]+=i*5,i=e[0]>>>13,e[0]&=8191,e[1]+=i,i=e[1]>>>13,e[1]&=8191,e[2]+=i,r[0]=e[0]+5,i=r[0]>>>13,r[0]&=8191;for(let a=1;a<10;a++)r[a]=e[a]+i,i=r[a]>>>13,r[a]&=8191;r[9]-=8192;let s=(i^1)-1;for(let a=0;a<10;a++)r[a]&=s;s=~s;for(let a=0;a<10;a++)e[a]=e[a]&s|r[a];e[0]=(e[0]|e[1]<<13)&65535,e[1]=(e[1]>>>3|e[2]<<10)&65535,e[2]=(e[2]>>>6|e[3]<<7)&65535,e[3]=(e[3]>>>9|e[4]<<4)&65535,e[4]=(e[4]>>>12|e[5]<<1|e[6]<<14)&65535,e[5]=(e[6]>>>2|e[7]<<11)&65535,e[6]=(e[7]>>>5|e[8]<<8)&65535,e[7]=(e[8]>>>8|e[9]<<5)&65535;let o=e[0]+t[0];e[0]=o&65535;for(let a=1;a<8;a++)o=(e[a]+t[a]|0)+(o>>>16)|0,e[a]=o&65535;mu(r)}update(e){OA(this),lr(e),e=Lm(e);const{buffer:t,blockLen:r}=this,i=e.length;for(let s=0;s<i;){const o=Math.min(r-this.pos,i-s);if(o===r){for(;r<=i-s;s+=r)this.process(e,s);continue}t.set(e.subarray(s,s+o),this.pos),this.pos+=o,s+=o,this.pos===r&&(this.process(t,0,!1),this.pos=0)}return this}destroy(){mu(this.h,this.r,this.buffer,this.pad)}digestInto(e){OA(this),xee(e,this),this.finished=!0;const{buffer:t,h:r}=this;let{pos:i}=this;if(i){for(t[i++]=1;i<16;i++)t[i]=0;this.process(t,0,!0)}this.finalize();let s=0;for(let o=0;o<8;o++)e[s++]=r[o]>>>0,e[s++]=r[o]>>>8;return e}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}}function Fee(n){const e=(r,i)=>n(i).update(r).digest(),t=n(new Uint8Array(32));return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=r=>n(r),e}const zee=Fee(n=>new $ee(n));function Vee(n,e,t,r,i,s=20){let o=n[0],a=n[1],c=n[2],l=n[3],u=e[0],d=e[1],f=e[2],p=e[3],g=e[4],b=e[5],m=e[6],y=e[7],E=i,w=t[0],x=t[1],M=t[2],A=o,C=a,R=c,_=l,T=u,F=d,k=f,z=p,v=g,S=b,P=m,U=y,B=E,O=w,V=x,$=M;for(let H=0;H<s;H+=2)A=A+T|0,B=ct(B^A,16),v=v+B|0,T=ct(T^v,12),A=A+T|0,B=ct(B^A,8),v=v+B|0,T=ct(T^v,7),C=C+F|0,O=ct(O^C,16),S=S+O|0,F=ct(F^S,12),C=C+F|0,O=ct(O^C,8),S=S+O|0,F=ct(F^S,7),R=R+k|0,V=ct(V^R,16),P=P+V|0,k=ct(k^P,12),R=R+k|0,V=ct(V^R,8),P=P+V|0,k=ct(k^P,7),_=_+z|0,$=ct($^_,16),U=U+$|0,z=ct(z^U,12),_=_+z|0,$=ct($^_,8),U=U+$|0,z=ct(z^U,7),A=A+F|0,$=ct($^A,16),P=P+$|0,F=ct(F^P,12),A=A+F|0,$=ct($^A,8),P=P+$|0,F=ct(F^P,7),C=C+k|0,B=ct(B^C,16),U=U+B|0,k=ct(k^U,12),C=C+k|0,B=ct(B^C,8),U=U+B|0,k=ct(k^U,7),R=R+z|0,O=ct(O^R,16),v=v+O|0,z=ct(z^v,12),R=R+z|0,O=ct(O^R,8),v=v+O|0,z=ct(z^v,7),_=_+T|0,V=ct(V^_,16),S=S+V|0,T=ct(T^S,12),_=_+T|0,V=ct(V^_,8),S=S+V|0,T=ct(T^S,7);let W=0;r[W++]=o+A|0,r[W++]=a+C|0,r[W++]=c+R|0,r[W++]=l+_|0,r[W++]=u+T|0,r[W++]=d+F|0,r[W++]=f+k|0,r[W++]=p+z|0,r[W++]=g+v|0,r[W++]=b+S|0,r[W++]=m+P|0,r[W++]=y+U|0,r[W++]=E+B|0,r[W++]=w+O|0,r[W++]=x+V|0,r[W++]=M+$|0}const Hee=kee(Vee,{counterRight:!1,counterLength:4,allowShortKeys:!1}),Gee=new Uint8Array(16),BA=(n,e)=>{n.update(e);const t=e.length%16;t&&n.update(Gee.subarray(t))},Wee=new Uint8Array(32);function kA(n,e,t,r,i){i!==void 0&&lr(i,void 0,"AAD");const s=n(e,t,Wee),o=Pee(r.length,i?i.length:0,!0),a=zee.create(s);i&&BA(a,i),BA(a,r),a.update(o);const c=a.digest();return mu(s,o),c}const qee=n=>(e,t,r)=>({encrypt(s,o){const a=s.length;o=NA(a+16,o,!1),o.set(s);const c=o.subarray(0,-16);n(e,t,c,c,1);const l=kA(n,e,t,c,r);return o.set(l,a),mu(l),o},decrypt(s,o){o=NA(s.length-16,o,!1);const a=s.subarray(0,-16),c=s.subarray(-16),l=kA(n,e,t,a,r);if(!Cee(c,l))throw new Error("invalid tag");return o.set(s.subarray(0,-16)),n(e,t,o,o,1),mu(l),o}}),$A=Iee({blockSize:64,nonceLength:12,tagLength:16},qee(Hee));function Kee(n,e,t){return Dg(n),t===void 0&&(t=new Uint8Array(n.outputLen)),Ng(n,t,e)}const C0=Uint8Array.of(0),FA=Uint8Array.of();function Xee(n,e,t,r=32){Dg(n),jo(r,"length");const i=n.outputLen;if(r>255*i)throw new Error("Length must be <= 255*HashLen");const s=Math.ceil(r/i);t===void 0?t=FA:tt(t,void 0,"info");const o=new Uint8Array(s*i),a=Ng.create(n,e),c=a._cloneInto(),l=new Uint8Array(a.outputLen);for(let u=0;u<s;u++)C0[0]=u+1,c.update(u===0?FA:l).update(t).update(C0).digestInto(l),o.set(l,i*u),a._cloneInto(c);return a.destroy(),c.destroy(),Ka(l,C0),o.slice(0,r)}function Yee(n){return e=>new _ee(e,n)}var Ew;let Zee=(Ew=class extends Error{constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}},h(Ew,"name","InvalidParametersError"),Ew);var Sw;let jee=(Sw=class extends Error{constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}},h(Sw,"name","InvalidCIDError"),Sw);var xw;let Jee=(xw=class extends Error{constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}},h(xw,"name","InvalidMultihashError"),xw);var Tw;let Qee=(Tw=class extends Error{constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}},h(Tw,"name","InvalidMessageError"),Tw);class s3 extends Error{constructor(e="Dial error"){super(e),this.name="DialError"}}h(s3,"name","DialError");class Om extends Error{constructor(e="Listen error"){super(e),this.name="ListenError"}}h(Om,"name","ListenError");const o3=Symbol.for("@libp2p/peer-id"),ete="keep-alive";function a3(n){return n!=null&&typeof n.start=="function"&&typeof n.stop=="function"}async function tte(...n){const e=[];for(const t of n)a3(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStart!=null&&await t.beforeStart()})),await Promise.all(e.map(async t=>{await t.start()})),await Promise.all(e.map(async t=>{t.afterStart!=null&&await t.afterStart()}))}async function nte(...n){const e=[];for(const t of n)a3(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStop!=null&&await t.beforeStop()})),await Promise.all(e.map(async t=>{await t.stop()})),await Promise.all(e.map(async t=>{t.afterStop!=null&&await t.afterStop()}))}const rte=Symbol.for("@libp2p/transport");var zA;(function(n){n[n.FATAL_ALL=0]="FATAL_ALL",n[n.NO_FATAL=1]="NO_FATAL"})(zA||(zA={}));const ite=Symbol.for("@libp2p/service-capabilities"),ste=Symbol.for("@libp2p/service-dependencies"),c3=Symbol.for("nodejs.util.inspect.custom"),ote=114;var LC;let oS=class{constructor(e){h(this,"type");h(this,"multihash");h(this,"publicKey");h(this,"string");h(this,LC,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=at.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return ze.createV1(ote,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return Ne(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return Ne(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(LC=o3,c3)](){return`PeerId(${this.toString()})`}},ate=class extends oS{constructor(t){super({...t,type:"RSA"});h(this,"type","RSA");h(this,"publicKey");this.publicKey=t.publicKey}},cte=class extends oS{constructor(t){super({...t,type:"Ed25519"});h(this,"type","Ed25519");h(this,"publicKey");this.publicKey=t.publicKey}},lte=class extends oS{constructor(t){super({...t,type:"secp256k1"});h(this,"type","secp256k1");h(this,"publicKey");this.publicKey=t.publicKey}};const ute=2336;var OC,NC;let l3=class{constructor(e){h(this,"type","url");h(this,"multihash");h(this,"publicKey");h(this,"url");h(this,OC,!0);this.url=e.toString(),this.multihash=Zt.digest(ge(this.url))}[(NC=c3,OC=o3,NC)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return ze.createV1(ute,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=ne(e)),e.toString()===this.toString())}};const hte=114,VA=2336;function HA(n,e){let t;if(n.charAt(0)==="1"||n.charAt(0)==="Q")t=co(at.decode(`z${n}`));else{if(n.startsWith("k51qzi5uqu5")||n.startsWith("kzwfwjn5ji4")||n.startsWith("k2k4r8")||n.startsWith("bafz"))return dte(ze.parse(n));throw new Zee('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return aS(t)}function aS(n){if(pte(n))return new ate({multihash:n});if(fte(n))try{const e=lo(n);if(e.type==="Ed25519")return new cte({multihash:n,publicKey:e});if(e.type==="secp256k1")return new lte({multihash:n,publicKey:e})}catch{const t=ne(n.digest);return new l3(new URL(t))}throw new Jee("Supplied PeerID Multihash is invalid")}function dte(n){if((n==null?void 0:n.multihash)==null||n.version==null||n.version===1&&n.code!==hte&&n.code!==VA)throw new jee("Supplied PeerID CID is invalid");if(n.code===VA){const e=ne(n.multihash.digest);return new l3(new URL(e))}return aS(n.multihash)}function fte(n){return n.code===Zt.code}function pte(n){return n.code===ps.code}var Aw;let si=(Aw=class extends Error{constructor(){super(...arguments);h(this,"name","InvalidMultiaddrError")}},h(Aw,"name","InvalidMultiaddrError"),Aw);var Mw;let _d=(Mw=class extends Error{constructor(){super(...arguments);h(this,"name","ValidationError")}},h(Mw,"name","ValidationError"),Mw);var Cw;let mte=(Cw=class extends Error{constructor(){super(...arguments);h(this,"name","InvalidParametersError")}},h(Cw,"name","InvalidParametersError"),Cw);var Iw;let gte=(Iw=class extends Error{constructor(){super(...arguments);h(this,"name","UnknownProtocolError")}},h(Iw,"name","UnknownProtocolError"),Iw);const yte=4,bte=6,wte=273,vte=33,_te=41,Ete=42,Ste=43,xte=53,Tte=54,Ate=55,Mte=56,Cte=132,Ite=301,Pte=302,Dte=400,Nm=421,Rte=444,Lte=445,Ote=446,Nte=447,Ute=448,Bte=449,kte=454,$te=460,Fte=461,zte=465,Vte=466,Hte=480,Gte=481,Wte=443,qte=477,Kte=478,Xte=479,Yte=277,Zte=275,jte=276,Jte=280,Qte=281,cS=290,ene=777;function GA(n){return e=>ne(e,n)}function WA(n){return e=>ge(e,n)}function Th(n){return new DataView(n.buffer).getUint16(n.byteOffset).toString()}function el(n){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof n=="string"?parseInt(n):n),new Uint8Array(e)}function tne(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=ge(e[0],"base32"),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const i=el(r);return nt([t,i],t.length+i.length)}function nne(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=yn.decode(`b${e[0]}`),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const i=el(r);return nt([t,i],t.length+i.length)}function qA(n){const e=n.subarray(0,n.length-2),t=n.subarray(n.length-2),r=ne(e,"base32"),i=Th(t);return`${r}:${i}`}const u3=function(n){n=n.toString().trim();const e=new Uint8Array(4);return n.split(/\./g).forEach((t,r)=>{const i=parseInt(t,10);if(isNaN(i)||i<0||i>255)throw new si("Invalid byte value in IP address");e[r]=i}),e},rne=function(n){let e=0;n=n.toString().trim();const t=n.split(":",8);let r;for(r=0;r<t.length;r++){const s=Pt(t[r]);let o;s&&(o=u3(t[r]),t[r]=ne(o.subarray(0,2),"base16")),o!=null&&++r<8&&t.splice(r,0,ne(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(r=0;r<t.length&&t[r]!=="";r++);const s=[r,1];for(r=9-t.length;r>0;r--)s.push("0");t.splice.apply(t,s)}const i=new Uint8Array(e+16);for(r=0;r<t.length;r++){t[r]===""&&(t[r]="0");const s=parseInt(t[r],16);if(isNaN(s)||s<0||s>65535)throw new si("Invalid byte value in IP address");i[e++]=s>>8&255,i[e++]=s&255}return i},ine=function(n){if(n.byteLength!==4)throw new si("IPv4 address was incorrect length");const e=[];for(let t=0;t<n.byteLength;t++)e.push(n[t]);return e.join(".")},sne=function(n){if(n.byteLength!==16)throw new si("IPv6 address was incorrect length");const e=[];for(let r=0;r<n.byteLength;r+=2){const i=n[r],s=n[r+1],o=`${i.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const r=new URL(`http://[${t}]`);return r.hostname.substring(1,r.hostname.length-1)}catch{throw new si(`Invalid IPv6 address "${t}"`)}};function one(n){try{const e=new URL(`http://[${n}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new si(`Invalid IPv6 address "${n}"`)}}const I0=Object.values(Fr).map(n=>n.decoder),ane=(function(){let n=I0[0].or(I0[1]);return I0.slice(2).forEach(e=>n=n.or(e)),n})();function cne(n){return ane.decode(n)}function lne(n){return e=>n.encoder.encode(e)}function une(n){if(parseInt(n).toString()!==n)throw new _d("Value must be an integer")}function hne(n){if(n<0)throw new _d("Value must be a positive integer, or zero")}function dne(n){return e=>{if(e>n)throw new _d(`Value must be smaller than or equal to ${n}`)}}function fne(...n){return e=>{for(const t of n)t(e)}}const dp=fne(une,hne,dne(65535)),Vn=-1;let pne=class{constructor(){h(this,"protocolsByCode",new Map);h(this,"protocolsByName",new Map)}getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new gte(`Protocol ${e} was unknown`);return t}addProtocol(e){var t;this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),(t=e.aliases)==null||t.forEach(r=>{this.protocolsByName.set(r,e)})}removeProtocol(e){var r;const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),(r=t.aliases)==null||r.forEach(i=>{this.protocolsByName.delete(i)}))}};const zu=new pne,mne=[{code:yte,name:"ip4",size:32,valueToBytes:u3,bytesToValue:ine,validate:n=>{if(!Pt(n))throw new _d(`Invalid IPv4 address "${n}"`)}},{code:bte,name:"tcp",size:16,valueToBytes:el,bytesToValue:Th,validate:dp},{code:wte,name:"udp",size:16,valueToBytes:el,bytesToValue:Th,validate:dp},{code:vte,name:"dccp",size:16,valueToBytes:el,bytesToValue:Th,validate:dp},{code:_te,name:"ip6",size:128,valueToBytes:rne,bytesToValue:sne,stringToValue:one,validate:n=>{if(!hi(n))throw new _d(`Invalid IPv6 address "${n}"`)}},{code:Ete,name:"ip6zone",size:Vn},{code:Ste,name:"ipcidr",size:8,bytesToValue:GA("base10"),valueToBytes:WA("base10")},{code:xte,name:"dns",size:Vn},{code:Tte,name:"dns4",size:Vn},{code:Ate,name:"dns6",size:Vn},{code:Mte,name:"dnsaddr",size:Vn},{code:Cte,name:"sctp",size:16,valueToBytes:el,bytesToValue:Th,validate:dp},{code:Ite,name:"udt"},{code:Pte,name:"utp"},{code:Dte,name:"unix",size:Vn,stringToValue:n=>decodeURIComponent(n),valueToString:n=>encodeURIComponent(n)},{code:Nm,name:"p2p",aliases:["ipfs"],size:Vn,bytesToValue:GA("base58btc"),valueToBytes:n=>n.startsWith("Q")||n.startsWith("1")?WA("base58btc")(n):ze.parse(n).multihash.bytes},{code:Rte,name:"onion",size:96,bytesToValue:qA,valueToBytes:tne},{code:Lte,name:"onion3",size:296,bytesToValue:qA,valueToBytes:nne},{code:Ote,name:"garlic64",size:Vn},{code:Nte,name:"garlic32",size:Vn},{code:Ute,name:"tls"},{code:Bte,name:"sni",size:Vn},{code:kte,name:"noise"},{code:$te,name:"quic"},{code:Fte,name:"quic-v1"},{code:zte,name:"webtransport"},{code:Vte,name:"certhash",size:Vn,bytesToValue:lne(ui),valueToBytes:cne},{code:Hte,name:"http"},{code:Gte,name:"http-path",size:Vn,stringToValue:n=>`/${decodeURIComponent(n)}`,valueToString:n=>encodeURIComponent(n.substring(1))},{code:Wte,name:"https"},{code:qte,name:"ws"},{code:Kte,name:"wss"},{code:Xte,name:"p2p-websocket-star"},{code:Yte,name:"p2p-stardust"},{code:Zte,name:"p2p-webrtc-star"},{code:jte,name:"p2p-webrtc-direct"},{code:Jte,name:"webrtc-direct"},{code:Qte,name:"webrtc"},{code:cS,name:"p2p-circuit"},{code:ene,name:"memory",size:Vn}];mne.forEach(n=>{zu.addProtocol(n)});function gne(n){var r;const e=[];let t=0;for(;t<n.length;){const i=zt(n,t),s=zu.getProtocol(i),o=Me(i),a=vne(s,n,t+o);let c=0;a>0&&s.size===Vn&&(c=Me(a));const l=o+c+a,u={code:i,name:s.name,bytes:n.subarray(t,t+l)};if(a>0){const d=t+o+c,f=n.subarray(d,d+a);u.value=((r=s.bytesToValue)==null?void 0:r.call(s,f))??ne(f)}e.push(u),t+=l}return e}function yne(n){var r;let e=0;const t=[];for(const i of n){if(i.bytes==null){const s=zu.getProtocol(i.code),o=Me(i.code);let a,c=0,l=0;i.value!=null&&(a=((r=s.valueToBytes)==null?void 0:r.call(s,i.value))??ge(i.value),c=a.byteLength,s.size===Vn&&(l=Me(c)));const u=new Uint8Array(o+l+c);let d=0;Xt(i.code,u,d),d+=o,a!=null&&(s.size===Vn&&(Xt(c,u,d),d+=l),u.set(a,d)),i.bytes=u}t.push(i.bytes),e+=i.bytes.byteLength}return nt(t,e)}function bne(n){var s;if(n.charAt(0)!=="/")throw new si('String multiaddr must start with "/"');const e=[];let t="protocol",r="",i="";for(let o=1;o<n.length;o++){const a=n.charAt(o);a!=="/"&&(t==="protocol"?i+=n.charAt(o):r+=n.charAt(o));const c=o===n.length-1;if(a==="/"||c){const l=zu.getProtocol(i);if(t==="protocol"){if(l.size==null||l.size===0){e.push({code:l.code,name:l.name}),r="",i="",t="protocol";continue}else if(c)throw new si(`Component ${i} was missing value`);t="value"}else if(t==="value"){const u={code:l.code,name:l.name};if(l.size!=null&&l.size!==0){if(r==="")throw new si(`Component ${i} was missing value`);u.value=((s=l.stringToValue)==null?void 0:s.call(l,r))??r}e.push(u),r="",i="",t="protocol"}}}if(i!==""&&r!=="")throw new si("Incomplete multiaddr");return e}function wne(n){return`/${n.flatMap(e=>{var r;if(e.value==null)return e.name;const t=zu.getProtocol(e.code);if(t==null)throw new si(`Unknown protocol code ${e.code}`);return[e.name,((r=t.valueToString)==null?void 0:r.call(t,e.value))??e.value]}).join("/")}`}function vne(n,e,t){return n.size==null||n.size===0?0:n.size>0?n.size/8:zt(e,t)}const _ne=Symbol.for("nodejs.util.inspect.custom"),h3=Symbol.for("@multiformats/multiaddr");function Ene(n){if(n==null&&(n="/"),Tne(n))return n.getComponents();if(n instanceof Uint8Array)return gne(n);if(typeof n=="string")return n=n.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),n===""&&(n="/"),bne(n);if(Array.isArray(n))return n;throw new si("Must be a string, Uint8Array, Component[], or another Multiaddr")}var UC,Ti,kl,$l,Ks;let Sne=(Ks=class{constructor(e="/",t={}){h(this,UC,!0);me(this,Ti);me(this,kl);me(this,$l);pe(this,Ti,Ene(e)),t.validate!==!1&&xne(this)}get bytes(){return D(this,$l)==null&&pe(this,$l,yne(D(this,Ti))),D(this,$l)}toString(){return D(this,kl)==null&&pe(this,kl,wne(D(this,Ti))),D(this,kl)}toJSON(){return this.toString()}getComponents(){return[...D(this,Ti).map(e=>({...e}))]}encapsulate(e){const t=new Ks(e);return new Ks([...D(this,Ti),...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),r=this.toString(),i=r.lastIndexOf(t);if(i<0)throw new mte(`Address ${this.toString()} does not contain subaddress: ${t}`);return new Ks(r.slice(0,i),{validate:!1})}decapsulateCode(e){let t;for(let r=D(this,Ti).length-1;r>-1;r--)if(D(this,Ti)[r].code===e){t=r;break}return new Ks(D(this,Ti).slice(0,t),{validate:!1})}equals(e){return Ne(this.bytes,e.bytes)}[(UC=h3,_ne)](){return`Multiaddr(${this.toString()})`}},Ti=new WeakMap,kl=new WeakMap,$l=new WeakMap,Ks);function xne(n){n.getComponents().forEach(e=>{var r;const t=zu.getProtocol(e.code);e.value!=null&&((r=t.validate)==null||r.call(t,e.value))})}function Tne(n){return!!(n!=null&&n[h3])}function Yo(n){return new Sne(n)}const Ane=1,d3=5e3,Mne=100,fp=`${ete}-circuit-relay`;BigInt(1<<17);const Um="/libp2p/circuit/relay/0.2.0/hop",KA="/libp2p/circuit/relay/0.2.0/stop",XA=300,Cne=4096,Ine=.001;var gu;(function(n){(function(r){r.RESERVE="RESERVE",r.CONNECT="CONNECT",r.STATUS="STATUS"})(n.Type||(n.Type={}));let e;(function(r){r[r.RESERVE=0]="RESERVE",r[r.CONNECT=1]="CONNECT",r[r.STATUS=2]="STATUS"})(e||(e={})),(function(r){r.codec=()=>hc(e)})(n.Type||(n.Type={}));let t;n.codec=()=>(t==null&&(t=Nt((r,i,s={})=>{s.lengthDelimited!==!1&&i.fork(),r.type!=null&&(i.uint32(8),n.Type.codec().encode(r.type,i)),r.peer!=null&&(i.uint32(18),yu.codec().encode(r.peer,i)),r.reservation!=null&&(i.uint32(26),Bm.codec().encode(r.reservation,i)),r.limit!=null&&(i.uint32(34),bu.codec().encode(r.limit,i)),r.status!=null&&(i.uint32(40),ur.codec().encode(r.status,i)),s.lengthDelimited!==!1&&i.ldelim()},(r,i,s={})=>{var c,l,u;const o={},a=i==null?r.len:r.pos+i;for(;r.pos<a;){const d=r.uint32();switch(d>>>3){case 1:{o.type=n.Type.codec().decode(r);break}case 2:{o.peer=yu.codec().decode(r,r.uint32(),{limits:(c=s.limits)==null?void 0:c.peer});break}case 3:{o.reservation=Bm.codec().decode(r,r.uint32(),{limits:(l=s.limits)==null?void 0:l.reservation});break}case 4:{o.limit=bu.codec().decode(r,r.uint32(),{limits:(u=s.limits)==null?void 0:u.limit});break}case 5:{o.status=ur.codec().decode(r);break}default:{r.skipType(d&7);break}}}return o})),t),n.encode=r=>Ot(r,n.codec()),n.decode=(r,i)=>Lt(r,n.codec(),i)})(gu||(gu={}));var Cs;(function(n){(function(r){r.CONNECT="CONNECT",r.STATUS="STATUS"})(n.Type||(n.Type={}));let e;(function(r){r[r.CONNECT=0]="CONNECT",r[r.STATUS=1]="STATUS"})(e||(e={})),(function(r){r.codec=()=>hc(e)})(n.Type||(n.Type={}));let t;n.codec=()=>(t==null&&(t=Nt((r,i,s={})=>{s.lengthDelimited!==!1&&i.fork(),r.type!=null&&(i.uint32(8),n.Type.codec().encode(r.type,i)),r.peer!=null&&(i.uint32(18),yu.codec().encode(r.peer,i)),r.limit!=null&&(i.uint32(26),bu.codec().encode(r.limit,i)),r.status!=null&&(i.uint32(32),ur.codec().encode(r.status,i)),s.lengthDelimited!==!1&&i.ldelim()},(r,i,s={})=>{var c,l;const o={},a=i==null?r.len:r.pos+i;for(;r.pos<a;){const u=r.uint32();switch(u>>>3){case 1:{o.type=n.Type.codec().decode(r);break}case 2:{o.peer=yu.codec().decode(r,r.uint32(),{limits:(c=s.limits)==null?void 0:c.peer});break}case 3:{o.limit=bu.codec().decode(r,r.uint32(),{limits:(l=s.limits)==null?void 0:l.limit});break}case 4:{o.status=ur.codec().decode(r);break}default:{r.skipType(u&7);break}}}return o})),t),n.encode=r=>Ot(r,n.codec()),n.decode=(r,i)=>Lt(r,n.codec(),i)})(Cs||(Cs={}));var yu;(function(n){let e;n.codec=()=>(e==null&&(e=Nt((t,r,i={})=>{if(i.lengthDelimited!==!1&&r.fork(),t.id!=null&&t.id.byteLength>0&&(r.uint32(10),r.bytes(t.id)),t.addrs!=null)for(const s of t.addrs)r.uint32(18),r.bytes(s);i.lengthDelimited!==!1&&r.ldelim()},(t,r,i={})=>{var a;const s={id:ht(0),addrs:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const c=t.uint32();switch(c>>>3){case 1:{s.id=t.bytes();break}case 2:{if(((a=i.limits)==null?void 0:a.addrs)!=null&&s.addrs.length===i.limits.addrs)throw new ls('Decode error - map field "addrs" had too many elements');s.addrs.push(t.bytes());break}default:{t.skipType(c&7);break}}}return s})),e),n.encode=t=>Ot(t,n.codec()),n.decode=(t,r)=>Lt(t,n.codec(),r)})(yu||(yu={}));var Bm;(function(n){let e;n.codec=()=>(e==null&&(e=Nt((t,r,i={})=>{if(i.lengthDelimited!==!1&&r.fork(),t.expire!=null&&t.expire!==0n&&(r.uint32(8),r.uint64(t.expire)),t.addrs!=null)for(const s of t.addrs)r.uint32(18),r.bytes(s);t.voucher!=null&&(r.uint32(26),$m.codec().encode(t.voucher,r)),i.lengthDelimited!==!1&&r.ldelim()},(t,r,i={})=>{var a,c;const s={expire:0n,addrs:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const l=t.uint32();switch(l>>>3){case 1:{s.expire=t.uint64();break}case 2:{if(((a=i.limits)==null?void 0:a.addrs)!=null&&s.addrs.length===i.limits.addrs)throw new ls('Decode error - map field "addrs" had too many elements');s.addrs.push(t.bytes());break}case 3:{s.voucher=$m.codec().decode(t,t.uint32(),{limits:(c=i.limits)==null?void 0:c.voucher});break}default:{t.skipType(l&7);break}}}return s})),e),n.encode=t=>Ot(t,n.codec()),n.decode=(t,r)=>Lt(t,n.codec(),r)})(Bm||(Bm={}));var bu;(function(n){let e;n.codec=()=>(e==null&&(e=Nt((t,r,i={})=>{i.lengthDelimited!==!1&&r.fork(),t.duration!=null&&(r.uint32(8),r.uint32(t.duration)),t.data!=null&&(r.uint32(16),r.uint64(t.data)),i.lengthDelimited!==!1&&r.ldelim()},(t,r,i={})=>{const s={},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.duration=t.uint32();break}case 2:{s.data=t.uint64();break}default:{t.skipType(a&7);break}}}return s})),e),n.encode=t=>Ot(t,n.codec()),n.decode=(t,r)=>Lt(t,n.codec(),r)})(bu||(bu={}));var ur;(function(n){n.UNUSED="UNUSED",n.OK="OK",n.RESERVATION_REFUSED="RESERVATION_REFUSED",n.RESOURCE_LIMIT_EXCEEDED="RESOURCE_LIMIT_EXCEEDED",n.PERMISSION_DENIED="PERMISSION_DENIED",n.CONNECTION_FAILED="CONNECTION_FAILED",n.NO_RESERVATION="NO_RESERVATION",n.MALFORMED_MESSAGE="MALFORMED_MESSAGE",n.UNEXPECTED_MESSAGE="UNEXPECTED_MESSAGE"})(ur||(ur={}));var r_;(function(n){n[n.UNUSED=0]="UNUSED",n[n.OK=100]="OK",n[n.RESERVATION_REFUSED=200]="RESERVATION_REFUSED",n[n.RESOURCE_LIMIT_EXCEEDED=201]="RESOURCE_LIMIT_EXCEEDED",n[n.PERMISSION_DENIED=202]="PERMISSION_DENIED",n[n.CONNECTION_FAILED=203]="CONNECTION_FAILED",n[n.NO_RESERVATION=204]="NO_RESERVATION",n[n.MALFORMED_MESSAGE=400]="MALFORMED_MESSAGE",n[n.UNEXPECTED_MESSAGE=401]="UNEXPECTED_MESSAGE"})(r_||(r_={}));(function(n){n.codec=()=>hc(r_)})(ur||(ur={}));var km;(function(n){let e;n.codec=()=>(e==null&&(e=Nt((t,r,i={})=>{i.lengthDelimited!==!1&&r.fork(),t.relay!=null&&t.relay.byteLength>0&&(r.uint32(10),r.bytes(t.relay)),t.peer!=null&&t.peer.byteLength>0&&(r.uint32(18),r.bytes(t.peer)),t.expiration!=null&&t.expiration!==0n&&(r.uint32(24),r.uint64(t.expiration)),i.lengthDelimited!==!1&&r.ldelim()},(t,r,i={})=>{const s={relay:ht(0),peer:ht(0),expiration:0n},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.relay=t.bytes();break}case 2:{s.peer=t.bytes();break}case 3:{s.expiration=t.uint64();break}default:{t.skipType(a&7);break}}}return s})),e),n.encode=t=>Ot(t,n.codec()),n.decode=(t,r)=>Lt(t,n.codec(),r)})(km||(km={}));var $m;(function(n){let e;n.codec=()=>(e==null&&(e=Nt((t,r,i={})=>{i.lengthDelimited!==!1&&r.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(r.uint32(10),r.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(r.uint32(18),r.bytes(t.payloadType)),t.payload!=null&&(r.uint32(26),km.codec().encode(t.payload,r)),t.signature!=null&&t.signature.byteLength>0&&(r.uint32(42),r.bytes(t.signature)),i.lengthDelimited!==!1&&r.ldelim()},(t,r,i={})=>{var a;const s={publicKey:ht(0),payloadType:ht(0),signature:ht(0)},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const c=t.uint32();switch(c>>>3){case 1:{s.publicKey=t.bytes();break}case 2:{s.payloadType=t.bytes();break}case 3:{s.payload=km.codec().decode(t,t.uint32(),{limits:(a=i.limits)==null?void 0:a.payload});break}case 5:{s.signature=t.bytes();break}default:{t.skipType(c&7);break}}}return s})),e),n.encode=t=>Ot(t,n.codec()),n.decode=(t,r)=>Lt(t,n.codec(),r)})($m||($m={}));class i_ extends Error{constructor(){super(...arguments);h(this,"name","HadEnoughRelaysError")}}h(i_,"name","HadEnoughRelaysError");class f3 extends Error{constructor(){super(...arguments);h(this,"name","DoubleRelayError")}}h(f3,"name","DoubleRelayError");class p3 extends Error{constructor(){super(...arguments);h(this,"name","RelayQueueFullError")}}h(p3,"name","RelayQueueFullError");function YA(n){const e=n*BigInt(1e3),t=new Date().getTime();return Number(e-BigInt(t))}class ZA{constructor(e){h(this,"expires");h(this,"bytes");(e==null?void 0:e.duration)!=null&&(e==null?void 0:e.duration)!==0&&(this.expires=Date.now()+e.duration*1e3),this.bytes=e==null?void 0:e.data,this.bytes===0n&&(this.bytes=void 0),this.onData=this.onData.bind(this)}onData(e){this.bytes!=null&&(this.bytes-=BigInt(e.byteLength),this.bytes<0n&&(this.bytes=0n))}getLimits(){if(this.expires==null&&this.bytes==null)return;const e={};if(this.bytes!=null){const t=this;Object.defineProperty(e,"bytes",{get(){return t.bytes}})}if(this.expires!=null){const t=this;Object.defineProperty(e,"seconds",{get(){return Math.round(((t.expires??0)-Date.now())/1e3)}})}return e}}const m3=Tt(mt(tS.matchers[0],xt(cS))),g3=Tt(xt(cS));class Pne extends fr{constructor(t,r={}){super();h(this,"components");h(this,"started");h(this,"running");h(this,"topologyId");h(this,"log");h(this,"discoveryController");h(this,"filter");h(this,"queue");this.log=t.logger.forComponent("libp2p:circuit-relay:discover-relays"),this.components=t,this.started=!1,this.running=!1,this.filter=r.filter,this.discoveryController=new AbortController,this.discoveryController.signal,this.dialPeer=this.dialPeer.bind(this),this.onPeer=this.onPeer.bind(this)}isStarted(){return this.started}async start(){this.topologyId=await this.components.registrar.register(Um,{filter:this.filter,onConnect:t=>{var r,i;this.log.trace("discovered relay %p queue (length: %d, active %d)",t,(r=this.queue)==null?void 0:r.size,(i=this.queue)==null?void 0:i.running),this.safeDispatchEvent("relay:discover",{detail:t})}}),this.started=!0}stop(){this.topologyId!=null&&this.components.registrar.unregister(this.topologyId),this.running&&this.stopDiscovery(),this.started=!1}startDiscovery(){this.running||(this.log("start discovery"),this.running=!0,this.discoveryController=new AbortController,this.discoveryController.signal,this.components.events.addEventListener("peer:discovery",this.onPeer),Promise.resolve().then(async()=>{var i;this.log("searching peer store for relays");const t=await this.components.peerStore.all({filters:[s=>s.protocols.includes(Um)],orders:[()=>Math.random()<.5?1:-1,(s,o)=>{const a=jA(s),c=jA(o);return a>c?-1:c>a?1:0}]});for(const s of t)this.log.trace("found relay peer %p in peer store",s.id),this.safeDispatchEvent("relay:discover",{detail:s.id});this.log("found %d relay peers in peer store",t.length);const r=this.queue=new HE({concurrency:5});this.log("start random walk");for await(const s of this.components.randomWalk.walk({signal:this.discoveryController.signal})){if(this.log.trace("found random peer %p",s.id),r.has(s.id)){this.log.trace("random peer %p was already in queue",s.id);continue}if(((i=this.components.connectionManager.getConnections(s.id))==null?void 0:i.length)>0){this.log.trace("random peer %p was already connected",s.id);continue}if(!await this.components.connectionManager.isDialable(s.multiaddrs)){this.log.trace("random peer %p was not dialable",s.id,s.multiaddrs.map(o=>o.toString()));continue}r.queued>10&&(this.log.trace("wait for space in queue for %p",s.id),await r.onSizeLessThan(10,{signal:this.discoveryController.signal})),this.log("adding random peer %p to dial queue (length: %d, active %d)",s.id,r.size,r.running),r.add(this.dialPeer,{peerId:s.id,signal:this.discoveryController.signal}).catch(o=>{this.log.error("error opening connection to random peer %p - %e",s.id,o)})}this.log("stop random walk"),await r.onIdle()}).catch(t=>{this.discoveryController.signal.aborted||this.log.error("failed when finding relays on the network - %e",t)}))}stopDiscovery(){var t,r;this.log("stop discovery"),this.running=!1,(t=this.discoveryController)==null||t.abort(),(r=this.queue)==null||r.clear(),this.components.events.removeEventListener("peer:discovery",this.onPeer)}onPeer(t){this.log.trace("maybe dialing discovered peer %p",t.detail.id),this.maybeDialPeer(t).catch(r=>{this.log.trace("error dialing discovered peer %p - %e",t.detail.id,r)})}async maybeDialPeer(t){var s,o;if(this.queue==null)return;const r=t.detail.id,i=t.detail.multiaddrs;if(this.queue.has(r)){this.log.trace("random peer %p was already in queue",r);return}if(((s=this.components.connectionManager.getConnections(r))==null?void 0:s.length)>0){this.log.trace("random peer %p was already connected",r);return}if(!await this.components.connectionManager.isDialable(i)){this.log.trace("random peer %p was not dialable",r);return}(o=this.queue)==null||o.add(this.dialPeer,{peerId:t.detail.id,signal:this.discoveryController.signal}).catch(a=>{this.log.error("error opening connection to discovered peer %p - %e",t.detail.id,a)})}async dialPeer({peerId:t,signal:r}){const i=Ja([AbortSignal.timeout(5e3),r]);try{await this.components.connectionManager.openConnection(t,{signal:i})}finally{i.clear()}}}function jA(n){const e=n.metadata.get("last-dial-success");return e==null?0:new Date(ne(e)).getTime()}class Dne extends fr{constructor(t,r={}){super();h(this,"connectionManager");h(this,"addressManager");h(this,"reservationStore");h(this,"listeningAddrs");h(this,"log");h(this,"listenTimeout");h(this,"reservationId");h(this,"relay");h(this,"_onRemoveRelayPeer",t=>{var r,i;this.log("relay removed %p our relay %p",t.detail.relay,this.relay,(r=this.relay)==null?void 0:r.equals(t.detail.relay)),((i=this.relay)==null?void 0:i.equals(t.detail.relay))===!0&&(this.log("relay peer removed %p",t.detail.relay),this.listeningAddrs.forEach(s=>{this.addressManager.removeObservedAddr(s)}),this.listeningAddrs=[],this.safeDispatchEvent("listening"))});h(this,"_onAddRelayPeer",t=>{const{details:r}=t.detail;r.type!=="configured"&&r.id===this.reservationId&&this.addedRelay(t.detail)});this.log=t.logger.forComponent("libp2p:circuit-relay:transport:listener"),this.connectionManager=t.connectionManager,this.addressManager=t.addressManager,this.reservationStore=t.reservationStore,this.listeningAddrs=[],this.listenTimeout=r.listenTimeout??d3,this.reservationStore.addEventListener("relay:removed",this._onRemoveRelayPeer),this.reservationStore.addEventListener("relay:created-reservation",this._onAddRelayPeer)}async listen(t){if(g3.exactMatch(t))this.log("searching for circuit relay servers"),this.reservationId=this.reservationStore.reserveRelay();else if(m3.exactMatch(t)){this.log("listen on specific relay server %a",t);const r=AbortSignal.timeout(this.listenTimeout),i=t.decapsulate("/p2p-circuit"),s=await this.connectionManager.openConnection(i,{signal:r});if(!this.reservationStore.hasReservation(s.remotePeer)){this.log("making reservation on peer %p",s.remotePeer);const o=await this.reservationStore.addRelay(s.remotePeer,"configured");this.addedRelay(o)}}else throw new Om(`Could not listen on p2p-circuit address "${t}"`)}getAddrs(){return[...this.listeningAddrs.values()].flat()}updateAnnounceAddrs(){}async close(){this.reservationStore.cancelReservations(),this.listeningAddrs=[],this.reservationStore.removeEventListener("relay:removed",this._onRemoveRelayPeer),queueMicrotask(()=>{this.safeDispatchEvent("close")})}addedRelay(t){this.log("relay peer added %p",t.relay),this.relay=t.relay,this.listeningAddrs=t.details.reservation.addrs.map(r=>Yo(r).encapsulate("/p2p-circuit")),this.listeningAddrs.forEach(r=>{this.addressManager.confirmObservedAddr(r,{type:"transport"})}),queueMicrotask(()=>{this.safeDispatchEvent("listening")})}}function Rne(n){return new Dne(n)}const Lne="useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";let One=(n=21)=>{let e="",t=crypto.getRandomValues(new Uint8Array(n|=0));for(;n--;)e+=Lne[t[n]&63];return e};const Nne=60*1e3*10,Une=60*1e3*5,Bne=30*1e3;var _r,y3,Ah,Mh;class kne extends fr{constructor(t,r){super();me(this,_r);h(this,"peerId");h(this,"connectionManager");h(this,"peerStore");h(this,"events");h(this,"reserveQueue");h(this,"reservations");h(this,"pendingReservations");h(this,"maxReservationQueueLength");h(this,"reservationCompletionTimeout");h(this,"started");h(this,"log");h(this,"relayFilter");this.log=t.logger.forComponent("libp2p:circuit-relay:transport:reservation-store"),this.peerId=t.peerId,this.connectionManager=t.connectionManager,this.peerStore=t.peerStore,this.events=t.events,this.reservations=new Nu,this.pendingReservations=[],this.maxReservationQueueLength=(r==null?void 0:r.maxReservationQueueLength)??Mne,this.reservationCompletionTimeout=(r==null?void 0:r.reservationCompletionTimeout)??d3,this.started=!1,this.relayFilter=ld(100),this.reserveQueue=new HE({concurrency:(r==null?void 0:r.reservationConcurrency)??Ane,metricName:"libp2p_relay_reservation_queue",metrics:t.metrics}),this.events.addEventListener("connection:close",i=>{[...this.reservations.values()].find(o=>o.connection===i.detail.id)!=null&&ue(this,_r,Ah).call(this,i.detail.remotePeer).catch(o=>{this.log("could not remove relay %p - %e",i.detail,o)})})}isStarted(){return this.started}start(){this.started=!0}afterStart(){Promise.resolve().then(async()=>{const t=await this.peerStore.all({filters:[r=>r.tags.has(fp)]});this.log("removing tag from %d old relays",t.length),await Promise.all(t.map(async r=>{await this.peerStore.merge(r.id,{tags:{[fp]:void 0}})})),this.log("redialing %d old relays",t.length),await Promise.all(t.map(async r=>this.addRelay(r.id,"discovered"))),ue(this,_r,Mh).call(this)}).catch(t=>{this.log.error("failed to clean up and redial old relays during afterStart - %e",t)})}stop(){this.reserveQueue.clear(),this.reservations.forEach(({timeout:t})=>{clearTimeout(t)}),this.reservations.clear(),this.started=!1}reserveRelay(){const t=One();return this.pendingReservations.push(t),ue(this,_r,Mh).call(this),t}async addRelay(t,r){if(this.peerId.equals(t))throw this.log.trace("not trying to use self as relay"),new Om("Cannot use self as relay");if(this.reserveQueue.size>this.maxReservationQueueLength)throw new p3("The reservation queue is full");const i=this.reserveQueue.find(t);if(i!=null)return this.log.trace("potential relay peer %p is already in the reservation queue",t),i.join();if(this.relayFilter.has(t.toMultihash().bytes))throw new Om("The relay was previously invalid");return this.log.trace("try to reserve relay slot with %p",t),this.reserveQueue.add(async()=>{const s=Date.now();try{const o=this.reservations.get(t);if(o!=null){const b=this.connectionManager.getConnections(t);let m=!1;if(b.length===0&&this.log("already have relay reservation with %p but we are no longer connected",t),b.map(y=>y.id).includes(o.connection)&&(this.log("already have relay reservation with %p and the original connection is still open",t),m=!0),m&&YA(o.reservation.expire)>Nne)return this.log("already have relay reservation with %p but we are still connected and it does not expire soon",t),{relay:t,details:o};await ue(this,_r,Ah).call(this,t)}if(r==="discovered"&&this.pendingReservations.length===0)throw new i_("Not making reservation on discovered relay because we do not need any more relays");const a=AbortSignal.timeout(this.reservationCompletionTimeout);const c=await this.connectionManager.openConnection(t,{signal:a});if(pu.matches(c.remoteAddr))throw new f3("not creating reservation over relayed connection");const l=await ue(this,_r,y3).call(this,c,{signal:a}),u=YA(l.expire);this.log("created reservation on relay peer %p, expiry date is %s",t,new Date(Date.now()+u).toString());const d=Math.min(Math.max(u-Une,Bne),Math.pow(2,31)-1),f=setTimeout(()=>{this.log("refresh reservation to relay %p",t),this.addRelay(t,r).catch(async b=>{this.log.error("could not refresh reservation to relay %p - %e",t,b),await ue(this,_r,Ah).call(this,t)}).catch(b=>{this.log.error("could not remove expired reservation to relay %p - %e",t,b)})},d);let p;if(r==="discovered"){const b=this.pendingReservations.pop();if(b==null)throw new i_("Made reservation on relay but did not need any more discovered relays");p={timeout:f,reservation:l,type:r,connection:c.id,id:b}}else p={timeout:f,reservation:l,type:r,connection:c.id};this.reservations.set(t,p),await this.peerStore.merge(t,{tags:{[fp]:{value:1,ttl:u}}}),ue(this,_r,Mh).call(this);const g={relay:t,details:p};return this.safeDispatchEvent("relay:created-reservation",{detail:g}),g}catch(o){throw r==="discovered"&&o.name==="HadEnoughRelaysError"||this.log.error("could not reserve slot on %p after %dms - %e",t,Date.now()-s,o),(o.name==="DialError"||o.name==="UnsupportedProtocolError")&&this.relayFilter.add(t.toMultihash().bytes),ue(this,_r,Ah).call(this,t).catch(a=>{this.log.error("could not remove reservation on %p after reserving slot failed - %e",t,a)}),o}},{peerId:t})}hasReservation(t){return this.reservations.has(t)}getReservation(t){var r;return(r=this.reservations.get(t))==null?void 0:r.reservation}reservationCount(t){return t==null?this.reservations.size:[...this.reservations.values()].reduce((r,i)=>(i.type===t&&r++,r),0)}cancelReservations(){[...this.reservations.values()].forEach(t=>{clearTimeout(t.timeout)}),this.reservations.clear()}}_r=new WeakSet,y3=async function(t,r){var l;(l=r.signal)==null||l.throwIfAborted(),this.log("requesting reservation from %p",t.remotePeer);const i=await t.newStream(Um,r),o=Jo(i).pb(gu);this.log.trace("send RESERVE to %p",t.remotePeer),await o.write({type:gu.Type.RESERVE},r);let a;try{this.log.trace("reading response from %p",t.remotePeer),a=await o.read(r)}catch(u){throw i.abort(u),u}finally{i.status!=="closed"&&await i.close(r)}if(this.log.trace("read response %s",a.status),a.status===ur.OK&&a.reservation!=null){const u=new Set;u.add(t.remoteAddr.toString());for(const d of a.reservation.addrs){let f=Yo(d);f.getComponents().find(p=>p.code===Nm)==null&&(f=f.encapsulate(`/p2p/${t.remotePeer}`)),f=Yo(f.toString().replace(`/p2p/${t.remotePeer}/p2p/${t.remotePeer}`,`/p2p/${t.remotePeer}`)),u.add(f.toString())}return a.reservation.addrs=[...u].map(d=>Yo(d).bytes),a.reservation}const c=`reservation failed with status ${a.status??"undefined"}`;throw this.log.error(c),new Error(c)},Ah=async function(t){const r=this.reservations.get(t);r!=null&&(this.log("removing relay reservation with %p from local store",t),clearTimeout(r.timeout),this.reservations.delete(t),r.type==="discovered"&&this.pendingReservations.push(r.id),await this.peerStore.merge(t,{tags:{[fp]:void 0}}),this.safeDispatchEvent("relay:removed",{detail:{relay:t,details:r}}),ue(this,_r,Mh).call(this))},Mh=function(){if(this.pendingReservations.length===0){this.log.trace("have discovered enough relays"),this.reserveQueue.clear(),this.safeDispatchEvent("relay:found-enough-relays");return}this.relayFilter=ld(100),this.log("not discovered enough relays %d/%d",this.reservations.size,this.pendingReservations.length),this.safeDispatchEvent("relay:not-enough-relays")};class $ne extends VE{constructor(t){super({...t,direction:t.stream.direction});h(this,"stream");h(this,"init");this.init=t,this.stream=t.stream,this.stream.addEventListener("close",r=>{this.onTransportClosed(r.error)}),this.stream.addEventListener("remoteCloseWrite",r=>{this.onRemoteCloseWrite(),this.close().catch(i=>{this.abort(i)})}),this.stream.addEventListener("message",r=>{var i;(i=t.onDataRead)==null||i.call(t,r.data),this.onData(r.data)}),this.stream.addEventListener("drain",()=>{this.safeDispatchEvent("drain")})}sendData(t){var r,i;return(i=(r=this.init).onDataWrite)==null||i.call(r,t),{sentBytes:t.byteLength,canSendMore:this.stream.send(t)}}async sendClose(t){await this.stream.close(t)}sendReset(){this.stream.abort(new Error("An error occurred"))}sendPause(){this.stream.pause()}sendResume(){this.stream.resume()}}function JA(n){return new $ne(n)}const Fne=n=>{if(n.peer==null)return!1;try{n.peer.addrs.forEach(Yo)}catch{return!1}return!0},QA={maxInboundStopStreams:XA,maxOutboundStopStreams:XA};var BC,kC,$C,FC;class zne{constructor(e,t={}){h(this,"components");h(this,"discovery");h(this,"reservationStore");h(this,"maxInboundStopStreams");h(this,"maxOutboundStopStreams");h(this,"started");h(this,"log");h(this,"shutdownController");h(this,FC,"@libp2p/circuit-relay-v2-transport");h(this,$C,["@libp2p/transport","@libp2p/circuit-relay-v2-transport"]);h(this,BC,!0);this.components=e,this.log=e.logger.forComponent("libp2p:circuit-relay:transport"),this.maxInboundStopStreams=t.maxInboundStopStreams??QA.maxInboundStopStreams,this.maxOutboundStopStreams=t.maxOutboundStopStreams??QA.maxOutboundStopStreams,this.shutdownController=new AbortController,this.discovery=new Pne(e,{filter:t.discoveryFilter??SG(Cne,Ine)}),this.discovery.addEventListener("relay:discover",r=>{this.reservationStore.addRelay(r.detail,"discovered").catch(i=>{i.name!=="HadEnoughRelaysError"&&i.name!=="RelayQueueFullError"&&this.log.error("could not add discovered relay %p - %e",r.detail,i)})}),this.reservationStore=new kne(e,t),this.reservationStore.addEventListener("relay:not-enough-relays",()=>{var r;(r=this.discovery)==null||r.startDiscovery()}),this.reservationStore.addEventListener("relay:found-enough-relays",()=>{var r;(r=this.discovery)==null||r.stopDiscovery()}),this.started=!1,this.onStop=this.onStop.bind(this)}get[(FC=Symbol.toStringTag,$C=ite,kC=ste,BC=rte,kC)](){return this.discovery!=null?["@libp2p/identify"]:[]}isStarted(){return this.started}async start(){this.shutdownController=new AbortController,this.shutdownController.signal,await this.components.registrar.handle(KA,this.onStop,{maxInboundStreams:this.maxInboundStopStreams,maxOutboundStreams:this.maxOutboundStopStreams,runOnLimitedConnection:!0}),await tte(this.discovery,this.reservationStore),this.started=!0}async stop(){this.shutdownController.abort(),await nte(this.discovery,this.reservationStore),await this.components.registrar.unhandle(KA),this.started=!1}async dial(e,t){var p,g,b,m,y,E,w,x;const r=e.toString().split("/p2p-circuit"),i=Yo(r[0]),s=Yo(r[r.length-1]),o=(p=i.getComponents().find(M=>M.code===Nm))==null?void 0:p.value,a=(g=s.getComponents().find(M=>M.code===Nm))==null?void 0:g.value;if(o==null||a==null){const M=`ircuit relay dial to ${e.toString()} failed as address did not have both relay and destination PeerIDs`;throw this.log.error(`c${M}`),new s3(`C${M}`)}const c=HA(o),l=HA(a);let d=this.components.connectionManager.getConnections(c)[0];d==null?(await this.components.peerStore.merge(c,{multiaddrs:[i]}),(b=t.onProgress)==null||b.call(t,new vt("circuit-relay:open-connection")),d=await this.components.connectionManager.openConnection(c,t)):(m=t.onProgress)==null||m.call(t,new vt("circuit-relay:reuse-connection"));let f;try{(y=t.onProgress)==null||y.call(t,new vt("circuit-relay:open-hop-stream")),f=await d.newStream(Um,t);const M=Jo(f).pb(gu);(E=t.onProgress)==null||E.call(t,new vt("circuit-relay:write-connect-message")),await M.write({type:gu.Type.CONNECT,peer:{id:l.toMultihash().bytes,addrs:[Yo(s).bytes]}},t),(w=t.onProgress)==null||w.call(t,new vt("circuit-relay:read-connect-response"));const A=await M.read(t);if(A.status!==ur.OK)throw new Qee(`failed to connect via relay with status ${((x=A==null?void 0:A.status)==null?void 0:x.toString())??"undefined"}`);const C=new ZA(A.limit),R=JA({stream:M.unwrap().unwrap(),remoteAddr:e,localAddr:i.encapsulate(`/p2p-circuit/p2p/${this.components.peerId.toString()}`),onDataRead:C.onData,onDataWrite:C.onData,log:f.log.newScope("circuit-relay:connection")}),_=await this.components.upgrader.upgradeOutbound(R,{...t,limits:C.getLimits()});return _.log("outbound relayed connection established to %p with limits %o, over connection %s",_.remotePeer,A.limit??"none",d.id),_}catch(M){throw this.log.error("circuit relay dial to destination %p via relay %p failed - %e",l,c,M),f==null||f.abort(M),M}}createListener(e){return Rne({peerId:this.components.peerId,connectionManager:this.components.connectionManager,addressManager:this.components.addressManager,reservationStore:this.reservationStore,logger:this.components.logger})}listenFilter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>m3.exactMatch(t)||g3.exactMatch(t))}dialFilter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>pu.exactMatch(t))}async onStop(e,t){var i,s;const r=this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);try{if(!this.reservationStore.hasReservation(t.remotePeer))try{this.log("dialed via relay we did not have a reservation on, start listening on that relay address"),await this.components.transportManager.listen([t.remoteAddr.encapsulate("/p2p-circuit")])}catch(p){this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on - %e",p)}const o=Jo(e).pb(Cs),a=await o.read({signal:r});if(this.log("new circuit relay v2 stop stream from %p with type %s",t.remotePeer,a.type),(a==null?void 0:a.type)===void 0){this.log.error("type was missing from circuit v2 stop protocol request from %s",t.remotePeer),await o.write({type:Cs.Type.STATUS,status:ur.MALFORMED_MESSAGE},{signal:r}),await e.close({signal:r});return}if(a.type!==Cs.Type.CONNECT){this.log.error("invalid stop connect request via peer %p",t.remotePeer),await o.write({type:Cs.Type.STATUS,status:ur.UNEXPECTED_MESSAGE},{signal:r}),await e.close({signal:r});return}if(!Fne(a)){this.log.error("invalid stop connect request via peer %p",t.remotePeer),await o.write({type:Cs.Type.STATUS,status:ur.MALFORMED_MESSAGE},{signal:r}),await e.close({signal:r});return}const c=aS(co(a.peer.id));if(await((s=(i=this.components.connectionGater).denyInboundRelayedConnection)==null?void 0:s.call(i,t.remotePeer,c))===!0){this.log.error("connection gater denied inbound relayed connection from %p",t.remotePeer),await o.write({type:Cs.Type.STATUS,status:ur.PERMISSION_DENIED},{signal:r}),await e.close({signal:r});return}this.log.trace("sending success response to %p",t.remotePeer),await o.write({type:Cs.Type.STATUS,status:ur.OK},{signal:r});const l=new ZA(a.limit),u=t.remoteAddr.encapsulate(`/p2p-circuit/p2p/${c.toString()}`),d=this.components.addressManager.getAddresses()[0],f=JA({stream:o.unwrap().unwrap(),remoteAddr:u,localAddr:d,onDataRead:l.onData,onDataWrite:l.onData,log:e.log.newScope("circuit-relay:connection")});await this.components.upgrader.upgradeInbound(f,{limits:l.getLimits(),signal:r}),f.log("inbound relayed connection established to %p with limits %o, over connection %s",c,a.limit??"none",t.id)}finally{r==null||r.clear()}}}function Vne(n={}){return e=>new zne(e,n)}var Pw;let Hne=(Pw=class extends Error{constructor(e="Unexpected Peer"){super(e),this.name="UnexpectedPeerError"}},h(Pw,"name","UnexpectedPeerError"),Pw);var Dw;let Gne=(Dw=class extends Error{constructor(e="Invalid crypto exchange"){super(e),this.name="InvalidCryptoExchangeError"}},h(Dw,"name","InvalidCryptoExchangeError"),Dw);var Rw;let Wne=(Rw=class extends Error{constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}},h(Rw,"name","UnsupportedKeyTypeError"),Rw);const qne=Symbol.for("@libp2p/peer-id"),Kne=Symbol.for("@libp2p/service-capabilities"),Xne=Symbol.for("nodejs.util.inspect.custom"),Yne=114;var zC;let lS=class{constructor(e){h(this,"type");h(this,"multihash");h(this,"publicKey");h(this,"string");h(this,zC,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=at.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return ze.createV1(Yne,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return Ne(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return Ne(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(zC=qne,Xne)](){return`PeerId(${this.toString()})`}},Zne=class extends lS{constructor(t){super({...t,type:"RSA"});h(this,"type","RSA");h(this,"publicKey");this.publicKey=t.publicKey}},jne=class extends lS{constructor(t){super({...t,type:"Ed25519"});h(this,"type","Ed25519");h(this,"publicKey");this.publicKey=t.publicKey}},Jne=class extends lS{constructor(t){super({...t,type:"secp256k1"});h(this,"type","secp256k1");h(this,"publicKey");this.publicKey=t.publicKey}};function e2(n){if(n.type==="Ed25519")return new jne({multihash:n.toCID().multihash,publicKey:n});if(n.type==="secp256k1")return new Jne({multihash:n.toCID().multihash,publicKey:n});if(n.type==="RSA")return new Zne({multihash:n.toCID().multihash,publicKey:n});throw new Wne}const Ed=65535,t2=Ed-16;var VC,HC;const tf=!!((HC=(VC=globalThis.process)==null?void 0:VC.env)!=null&&HC.DUMP_SESSION_KEYS),n2=16,Qne={hashSHA256(n){return kh(n.subarray())},getHKDF(n,e){const t=Kee(kh,e,n),i=Xee(kh,t,void 0,96),s=i.subarray(0,32),o=i.subarray(32,64),a=i.subarray(64,96);return[s,o,a]},generateX25519KeyPair(){const n=Xf.utils.randomSecretKey();return{publicKey:Xf.getPublicKey(n),privateKey:n}},generateX25519KeyPairFromSeed(n){return{publicKey:Xf.getPublicKey(n),privateKey:n}},generateX25519SharedKey(n,e){return Xf.getSharedSecret(n.subarray(),e.subarray())},chaCha20Poly1305Encrypt(n,e,t,r){return $A(r,e,t).encrypt(n.subarray())},chaCha20Poly1305Decrypt(n,e,t,r,i){return $A(r,e,t).decrypt(n.subarray(),i)}},ere=Qne;function tre(n){return{generateKeypair:n.generateX25519KeyPair,dh:(e,t)=>n.generateX25519SharedKey(e.privateKey,t).subarray(0,32),encrypt:n.chaCha20Poly1305Encrypt,decrypt:n.chaCha20Poly1305Decrypt,hash:n.hashSHA256,hkdf:n.getHKDF}}const Fm=n=>{const e=zi(2);return e[0]=n>>8,e[1]=n,e};Fm.bytes=2;const zm=n=>{if(n.length<2)throw RangeError("Could not decode int16BE");if(n instanceof Uint8Array){let e=0;return e+=n[0]<<8,e+=n[1],e}return n.getUint16(0)};zm.bytes=2;function nre(n){return{xxHandshakeSuccesses:n.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:n.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:n.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:n.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:n.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}function b3(n,e){!e.enabled||!tf||(n?(e(`LOCAL_STATIC_PUBLIC_KEY ${ne(n.publicKey,"hex")}`),e(`LOCAL_STATIC_PRIVATE_KEY ${ne(n.privateKey,"hex")}`)):e("Missing local static keys."))}function w3(n,e){!e.enabled||!tf||(n?(e(`LOCAL_PUBLIC_EPHEMERAL_KEY ${ne(n.publicKey,"hex")}`),e(`LOCAL_PRIVATE_EPHEMERAL_KEY ${ne(n.privateKey,"hex")}`)):e("Missing local ephemeral keys."))}function rre(n,e){!e.enabled||!tf||e(n?`REMOTE_STATIC_PUBLIC_KEY ${ne(n.subarray(),"hex")}`:"Missing remote static public key.")}function v3(n,e){!e.enabled||!tf||e(n?`REMOTE_EPHEMERAL_PUBLIC_KEY ${ne(n.subarray(),"hex")}`:"Missing remote ephemeral keys.")}function _3(n,e,t){!t.enabled||!tf||(t(`CIPHER_STATE_1 ${n.n.getUint64()} ${n.k&&ne(n.k,"hex")}`),t(`CIPHER_STATE_2 ${e.n.getUint64()} ${e.k&&ne(e.k,"hex")}`))}var Na;let P0=(Na=class extends Error{constructor(t="Invalid crypto exchange"){super(t);h(this,"code");this.code=Na.code}},h(Na,"code","ERR_INVALID_CRYPTO_EXCHANGE"),Na);const ire=0,sre=4294967295,ore="Cipher state has reached maximum n, a new handshake must be performed";class are{constructor(e=ire){h(this,"n");h(this,"bytes");h(this,"view");this.n=e,this.bytes=ht(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,e,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>sre)throw new Error(ore)}}const pl=ht(0);class pp{constructor(e,t=void 0,r=0){h(this,"k");h(this,"n");h(this,"crypto");this.crypto=e,this.k=t,this.n=new are(r)}hasKey(){return!!this.k}encryptWithAd(e,t){if(!this.hasKey())return t;this.n.assertValue();const r=this.crypto.encrypt(t,this.n.getBytes(),e,this.k);return this.n.increment(),r}decryptWithAd(e,t,r){if(!this.hasKey())return t;this.n.assertValue();const i=this.crypto.decrypt(t,this.n.getBytes(),e,this.k,r);return this.n.increment(),i}}class cre{constructor(e,t){h(this,"cs");h(this,"ck");h(this,"h");h(this,"crypto");this.crypto=e;const r=ge(t,"utf-8");this.h=ure(e,r),this.ck=this.h,this.cs=new pp(e)}mixKey(e){const[t,r]=this.crypto.hkdf(this.ck,e);this.ck=t,this.cs=new pp(this.crypto,r)}mixHash(e){this.h=this.crypto.hash(new ut(this.h,e))}encryptAndHash(e){const t=this.cs.encryptWithAd(this.h,e);return this.mixHash(t),t}decryptAndHash(e){const t=this.cs.decryptWithAd(this.h,e);return this.mixHash(e),t}split(){const[e,t]=this.crypto.hkdf(this.ck,pl);return[new pp(this.crypto,e),new pp(this.crypto,t)]}}class lre{constructor(e){h(this,"ss");h(this,"s");h(this,"e");h(this,"rs");h(this,"re");h(this,"initiator");h(this,"crypto");const{crypto:t,protocolName:r,prologue:i,initiator:s,s:o,e:a,rs:c,re:l}=e;this.crypto=t,this.ss=new cre(t,r),this.ss.mixHash(i),this.initiator=s,this.s=o,this.e=a,this.rs=c,this.re=l}writeE(){if(this.e)throw new Error("ephemeral keypair is already set");const e=this.crypto.generateKeypair();return this.ss.mixHash(e.publicKey),this.e=e,e.publicKey}writeS(){if(!this.s)throw new Error("static keypair is not set");return this.ss.encryptAndHash(this.s.publicKey)}writeEE(){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.re))}writeES(){if(this.initiator){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}else{if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}}writeSE(){if(this.initiator){if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}else{if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}}readE(e,t=0){if(this.re)throw new Error("remote ephemeral public key is already set");if(e.byteLength<t+32)throw new Error("message is not long enough");this.re=e.sublist(t,t+32),this.ss.mixHash(this.re)}readS(e,t=0){if(this.rs)throw new Error("remote static public key is already set");const r=32+(this.ss.cs.hasKey()?16:0);if(e.byteLength<t+r)throw new Error("message is not long enough");const i=e.sublist(t,t+r);return this.rs=this.ss.decryptAndHash(i),r}readEE(){this.writeEE()}readES(){this.writeES()}readSE(){this.writeSE()}}class E3 extends lre{writeMessageA(e){return new ut(this.writeE(),this.ss.encryptAndHash(e))}writeMessageB(e){const t=this.writeE();this.writeEE();const r=this.writeS();return this.writeES(),new ut(t,r,this.ss.encryptAndHash(e))}writeMessageC(e){const t=this.writeS();return this.writeSE(),new ut(t,this.ss.encryptAndHash(e))}readMessageA(e){try{return this.readE(e),this.ss.decryptAndHash(e.sublist(32))}catch(t){throw new P0(`handshake stage 0 validation fail: ${t.message}`)}}readMessageB(e){try{this.readE(e),this.readEE();const t=this.readS(e,32);return this.readES(),this.ss.decryptAndHash(e.sublist(32+t))}catch(t){throw new P0(`handshake stage 1 validation fail: ${t.message}`)}}readMessageC(e){try{const t=this.readS(e);return this.readSE(),this.ss.decryptAndHash(e.sublist(t))}catch(t){throw new P0(`handshake stage 2 validation fail: ${t.message}`)}}}function ure(n,e){if(e.length<=32){const t=ht(32);return t.set(e),t}else return n.hash(e)}var Vm;(function(n){let e;n.codec=()=>(e==null&&(e=Nt((t,r,i={})=>{if(i.lengthDelimited!==!1&&r.fork(),t.webtransportCerthashes!=null)for(const s of t.webtransportCerthashes)r.uint32(10),r.bytes(s);if(t.streamMuxers!=null)for(const s of t.streamMuxers)r.uint32(18),r.string(s);i.lengthDelimited!==!1&&r.ldelim()},(t,r,i={})=>{var a,c;const s={webtransportCerthashes:[],streamMuxers:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const l=t.uint32();switch(l>>>3){case 1:{if(((a=i.limits)==null?void 0:a.webtransportCerthashes)!=null&&s.webtransportCerthashes.length===i.limits.webtransportCerthashes)throw new ls('Decode error - map field "webtransportCerthashes" had too many elements');s.webtransportCerthashes.push(t.bytes());break}case 2:{if(((c=i.limits)==null?void 0:c.streamMuxers)!=null&&s.streamMuxers.length===i.limits.streamMuxers)throw new ls('Decode error - map field "streamMuxers" had too many elements');s.streamMuxers.push(t.string());break}default:{t.skipType(l&7);break}}}return s})),e),n.encode=t=>Ot(t,n.codec()),n.decode=(t,r)=>Lt(t,n.codec(),r)})(Vm||(Vm={}));var Hm;(function(n){let e;n.codec=()=>(e==null&&(e=Nt((t,r,i={})=>{i.lengthDelimited!==!1&&r.fork(),t.identityKey!=null&&t.identityKey.byteLength>0&&(r.uint32(10),r.bytes(t.identityKey)),t.identitySig!=null&&t.identitySig.byteLength>0&&(r.uint32(18),r.bytes(t.identitySig)),t.extensions!=null&&(r.uint32(34),Vm.codec().encode(t.extensions,r)),i.lengthDelimited!==!1&&r.ldelim()},(t,r,i={})=>{var a;const s={identityKey:ht(0),identitySig:ht(0)},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const c=t.uint32();switch(c>>>3){case 1:{s.identityKey=t.bytes();break}case 2:{s.identitySig=t.bytes();break}case 4:{s.extensions=Vm.codec().decode(t,t.uint32(),{limits:(a=i.limits)==null?void 0:a.extensions});break}default:{t.skipType(c&7);break}}}return s})),e),n.encode=t=>Ot(t,n.codec()),n.decode=(t,r)=>Lt(t,n.codec(),r)})(Hm||(Hm={}));async function S3(n,e,t){const r=await n.sign(T3(e));return Hm.encode({identityKey:as(n.publicKey),identitySig:r,extensions:t})}async function x3(n,e,t){try{const r=Hm.decode(n),i=no(r.identityKey);if((t==null?void 0:t.equals(i))===!1)throw new Error(`Payload identity key ${i} does not match expected remote identity key ${t}`);if(!e)throw new Error("Remote static does not exist");const s=T3(e);if(!await i.verify(s,r.identitySig))throw new Error("Invalid payload signature");return r}catch(r){throw new Hne(r.message)}}function T3(n){const e=ge("noise-libp2p-static-key:");return n instanceof Uint8Array?nt([e,n],e.length+n.length):(n.prepend(e),n)}class hre extends zE{constructor(t,r,i){super({log:t.log,inactivityTimeout:t.inactivityTimeout,maxReadBufferLength:t.maxReadBufferLength,direction:t.direction});h(this,"stream");h(this,"handshake");h(this,"metrics");h(this,"decoder");this.stream=t,this.handshake=r,this.metrics=i,this.decoder=new yG({lengthDecoder:zm,maxBufferSize:16*1024*1024,encodingLength:()=>2});const s=l=>{try{for(const u of this.decoder.decode(l.data))this.onData(this.decrypt(u))}catch(u){this.abort(u)}};this.stream.addEventListener("message",s);const o=l=>{l.error!=null?l.local===!0?this.abort(l.error):this.onRemoteReset():this.onTransportClosed()};this.stream.addEventListener("close",o);const a=()=>{this.safeDispatchEvent("drain")};this.stream.addEventListener("drain",a);const c=()=>{this.onRemoteCloseWrite()};this.stream.addEventListener("remoteCloseWrite",c)}encrypt(t){var i;const r=new ut;for(let s=0;s<t.byteLength;s+=t2){let o=s+t2;o>t.byteLength&&(o=t.byteLength);let a;t instanceof Uint8Array?a=this.handshake.encrypt(t.subarray(s,o)):a=this.handshake.encrypt(t.sublist(s,o)),(i=this.metrics)==null||i.encryptedPackets.increment(),r.append(Fm(a.byteLength)),r.append(a)}return r}decrypt(t){var i,s;const r=new ut;for(let o=0;o<t.byteLength;o+=Ed){let a=o+Ed;if(a>t.byteLength&&(a=t.byteLength),a-n2<o)throw new Error("Invalid chunk");let c;t instanceof Uint8Array?c=t.subarray(o,a):c=t.sublist(o,a);const l=t.subarray(o,a-n2);try{const u=this.handshake.decrypt(c,l);(i=this.metrics)==null||i.decryptedPackets.increment(),r.append(u)}catch(u){throw(s=this.metrics)==null||s.decryptErrors.increment(),u}}return r}close(t){return this.stream.close(t)}sendPause(){this.stream.pause()}sendResume(){this.stream.resume()}sendReset(t){this.stream.abort(t)}sendData(t){return{sentBytes:t.byteLength,canSendMore:this.stream.send(this.encrypt(t))}}}function r2(n,e,t){return new hre(n,e,t)}async function dre(n,e){const{log:t,connection:r,crypto:i,privateKey:s,prologue:o,s:a,remoteIdentityKey:c,extensions:l}=n,u=await S3(s,a.publicKey,l),d=new E3({crypto:i,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!0,prologue:o,s:a});b3(d.s,t),t.trace("Stage 0 - Initiator starting to send first message."),await r.write(d.writeMessageA(pl),e),t.trace("Stage 0 - Initiator finished sending first message."),w3(d.e,t),t.trace("Stage 1 - Initiator waiting to receive first message from responder...");const f=d.readMessageB(await r.read(e));t.trace("Stage 1 - Initiator received the message."),v3(d.re,t),rre(d.rs,t),t.trace("Initiator going to check remote's signature...");const p=await x3(f,d.rs,c);t.trace("All good with the signature!"),t.trace("Stage 2 - Initiator sending third handshake message."),await r.write(d.writeMessageC(u),e),t.trace("Stage 2 - Initiator sent message with signed payload.");const[g,b]=d.ss.split();return _3(g,b,t),{payload:p,encrypt:m=>g.encryptWithAd(pl,m),decrypt:(m,y)=>b.decryptWithAd(pl,m,y)}}async function fre(n,e){const{log:t,connection:r,crypto:i,privateKey:s,prologue:o,s:a,remoteIdentityKey:c,extensions:l}=n,u=await S3(s,a.publicKey,l),d=new E3({crypto:i,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!1,prologue:o,s:a});b3(d.s,t),t.trace("Stage 0 - Responder waiting to receive first message."),d.readMessageA(await r.read(e)),t.trace("Stage 0 - Responder received first message."),v3(d.re,t),t.trace("Stage 1 - Responder sending out first message with signed payload and static key."),await r.write(d.writeMessageB(u),e),t.trace("Stage 1 - Responder sent the second handshake message with signed payload."),w3(d.e,t),t.trace("Stage 2 - Responder waiting for third handshake message...");const f=d.readMessageC(await r.read(e));t.trace("Stage 2 - Responder received the message, finished handshake.");const p=await x3(f,d.rs,c),[g,b]=d.ss.split();return _3(g,b,t),{payload:p,encrypt:m=>b.encryptWithAd(pl,m),decrypt:(m,y)=>g.decryptWithAd(pl,m,y)}}var GC,WC;WC=Symbol.toStringTag,GC=Kne;class pre{constructor(e,t={}){h(this,"protocol","/noise");h(this,"crypto");h(this,"prologue");h(this,"staticKey");h(this,"extensions");h(this,"metrics");h(this,"components");h(this,"log");h(this,WC,"@libp2p/noise");h(this,GC,["@libp2p/connection-encryption","@libp2p/noise"]);const{staticNoiseKey:r,extensions:i,crypto:s,prologueBytes:o}=t,{metrics:a}=e;this.components=e,this.log=e.logger.forComponent("libp2p:noise");const c=s??ere;this.crypto=tre(c),this.extensions={webtransportCerthashes:[],...i},this.metrics=a?nre(a):void 0,r?this.staticKey=c.generateX25519KeyPairFromSeed(r):this.staticKey=c.generateX25519KeyPair(),this.prologue=o??ht(0)}async secureOutbound(e,t){var a,c,l;const r=((a=e.log)==null?void 0:a.newScope("noise"))??this.log,i=dd(e,{lengthEncoder:Fm,lengthDecoder:zm,maxDataLength:Ed}),s=await this.performHandshakeInitiator(i,this.components.privateKey,r,(c=t==null?void 0:t.remotePeer)==null?void 0:c.publicKey,t),o=no(s.payload.identityKey);return{connection:r2(i.unwrap(),s,this.metrics),remoteExtensions:s.payload.extensions,remotePeer:e2(o),streamMuxer:(t==null?void 0:t.skipStreamMuxerNegotiation)===!0?void 0:this.getStreamMuxer((l=s.payload.extensions)==null?void 0:l.streamMuxers)}}getStreamMuxer(e){if(e==null||e.length===0)return;const t=this.components.upgrader.getStreamMuxers();if(t!=null)for(const r of e){const i=t.get(r);if(i!=null)return i}if(e.length)throw new Gne("Early muxer negotiation was requested but the initiator and responder had no common muxers")}async secureInbound(e,t){var a,c,l;const r=((a=e.log)==null?void 0:a.newScope("noise"))??this.log,i=dd(e,{lengthEncoder:Fm,lengthDecoder:zm,maxDataLength:Ed}),s=await this.performHandshakeResponder(i,this.components.privateKey,r,(c=t==null?void 0:t.remotePeer)==null?void 0:c.publicKey,t),o=no(s.payload.identityKey);return{connection:r2(i.unwrap(),s,this.metrics),remoteExtensions:s.payload.extensions,remotePeer:e2(o),streamMuxer:(t==null?void 0:t.skipStreamMuxerNegotiation)===!0?void 0:this.getStreamMuxer((l=s.payload.extensions)==null?void 0:l.streamMuxers)}}async performHandshakeInitiator(e,t,r,i,s){var c,l;let o;const a=(s==null?void 0:s.skipStreamMuxerNegotiation)===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{o=await dre({connection:e,privateKey:t,remoteIdentityKey:i,log:r.newScope("xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:a,webtransportCerthashes:[],...this.extensions}},s),(c=this.metrics)==null||c.xxHandshakeSuccesses.increment()}catch(u){throw(l=this.metrics)==null||l.xxHandshakeErrors.increment(),u}return o}async performHandshakeResponder(e,t,r,i,s){var c,l;let o;const a=(s==null?void 0:s.skipStreamMuxerNegotiation)===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{o=await fre({connection:e,privateKey:t,remoteIdentityKey:i,log:r.newScope("xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:a,webtransportCerthashes:[],...this.extensions}},s),(c=this.metrics)==null||c.xxHandshakeSuccesses.increment()}catch(u){throw(l=this.metrics)==null||l.xxHandshakeErrors.increment(),u}return o}}function mre(n={}){return e=>new pre(e,n)}class A3 extends Error{constructor(e="Unexpected Peer"){super(e),this.name="UnexpectedPeerError"}}h(A3,"name","UnexpectedPeerError");class s_ extends Error{constructor(e="Invalid crypto exchange"){super(e),this.name="InvalidCryptoExchangeError"}}h(s_,"name","InvalidCryptoExchangeError");var Lw;let D0=(Lw=class extends Error{constructor(e="Protocol error"){super(e),this.name="ProtocolError"}},h(Lw,"name","ProtocolError"),Lw);var Ow;let gre=(Ow=class extends Error{constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}},h(Ow,"name","UnsupportedKeyTypeError"),Ow);const yre=Symbol.for("@libp2p/peer-id"),bre=Symbol.for("@libp2p/service-capabilities"),wre=Symbol.for("nodejs.util.inspect.custom"),vre=114;var qC;let uS=class{constructor(e){h(this,"type");h(this,"multihash");h(this,"publicKey");h(this,"string");h(this,qC,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=at.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return ze.createV1(vre,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return Ne(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return Ne(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(qC=yre,wre)](){return`PeerId(${this.toString()})`}},_re=class extends uS{constructor(t){super({...t,type:"RSA"});h(this,"type","RSA");h(this,"publicKey");this.publicKey=t.publicKey}},Ere=class extends uS{constructor(t){super({...t,type:"Ed25519"});h(this,"type","Ed25519");h(this,"publicKey");this.publicKey=t.publicKey}},Sre=class extends uS{constructor(t){super({...t,type:"secp256k1"});h(this,"type","secp256k1");h(this,"publicKey");this.publicKey=t.publicKey}};function xre(n){if(n.type==="Ed25519")return new Ere({multihash:n.toCID().multihash,publicKey:n});if(n.type==="secp256k1")return new Sre({multihash:n.toCID().multihash,publicKey:n});if(n.type==="RSA")return new _re({multihash:n.toCID().multihash,publicKey:n});throw new gre}var o_;(function(n){let e;n.codec=()=>(e==null&&(e=Nt((t,r,i={})=>{i.lengthDelimited!==!1&&r.fork(),t.id!=null&&(r.uint32(10),r.bytes(t.id)),t.pubkey!=null&&(r.uint32(18),Gm.codec().encode(t.pubkey,r)),i.lengthDelimited!==!1&&r.ldelim()},(t,r,i={})=>{var a;const s={},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const c=t.uint32();switch(c>>>3){case 1:{s.id=t.bytes();break}case 2:{s.pubkey=Gm.codec().decode(t,t.uint32(),{limits:(a=i.limits)==null?void 0:a.pubkey});break}default:{t.skipType(c&7);break}}}return s})),e),n.encode=t=>Ot(t,n.codec()),n.decode=(t,r)=>Lt(t,n.codec(),r)})(o_||(o_={}));var tc;(function(n){n.RSA="RSA",n.Ed25519="Ed25519",n.secp256k1="secp256k1",n.ECDSA="ECDSA"})(tc||(tc={}));var a_;(function(n){n[n.RSA=0]="RSA",n[n.Ed25519=1]="Ed25519",n[n.secp256k1=2]="secp256k1",n[n.ECDSA=3]="ECDSA"})(a_||(a_={}));(function(n){n.codec=()=>hc(a_)})(tc||(tc={}));var Gm;(function(n){let e;n.codec=()=>(e==null&&(e=Nt((t,r,i={})=>{i.lengthDelimited!==!1&&r.fork(),t.Type!=null&&(r.uint32(8),tc.codec().encode(t.Type,r)),t.Data!=null&&t.Data.byteLength>0&&(r.uint32(18),r.bytes(t.Data)),i.lengthDelimited!==!1&&r.ldelim()},(t,r,i={})=>{const s={Data:ht(0)},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.Type=tc.codec().decode(t);break}case 2:{s.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return s})),e),n.encode=t=>Ot(t,n.codec()),n.decode=(t,r)=>Lt(t,n.codec(),r)})(Gm||(Gm={}));const Tre="/plaintext/2.0.0";var KC,XC;XC=Symbol.toStringTag,KC=bre;class Are{constructor(e){h(this,"protocol",Tre);h(this,"privateKey");h(this,"log");h(this,XC,"@libp2p/plaintext");h(this,KC,["@libp2p/connection-encryption"]);this.privateKey=e.privateKey,this.log=e.logger.forComponent("libp2p:plaintext")}async secureInbound(e,t){return this._encrypt(e,t)}async secureOutbound(e,t){return this._encrypt(e,t)}async _encrypt(e,t){var c;const r=((c=e.log)==null?void 0:c.newScope("plaintext"))??this.log,i=Jo(e).pb(o_);r("write pubkey exchange to peer %p",t==null?void 0:t.remotePeer);const s=this.privateKey.publicKey;await i.write({id:s.toMultihash().bytes,pubkey:{Type:tc[s.type],Data:s.raw}},t);const o=await i.read(t);let a;try{if(o.pubkey==null)throw new D0("Public key missing");if(o.pubkey.Data.byteLength===0)throw new D0("Public key data too short");if(o.id==null)throw new D0("Remote id missing");const l=rH(o.pubkey.Data);if(a=xre(l),!Ne(a.toMultihash().bytes,o.id))throw new s_("Public key did not match id")}catch(l){throw r.error("invalid public key - %e",l),new s_(`Invalid public key - ${l.message}`)}if((t==null?void 0:t.remotePeer)!=null&&!a.equals(t==null?void 0:t.remotePeer))throw new A3;return r("plaintext key exchange completed successfully with peer %p",a),{connection:i.unwrap().unwrap(),remotePeer:a}}}function Mre(){return n=>new Are(n)}var Nw;let Is=(Nw=class extends Error{constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}},h(Nw,"name","InvalidParametersError"),Nw);class Ch extends Error{constructor(e="The muxer is closed"){super(e),this.name="MuxerClosedError"}}h(Ch,"name","MuxerClosedError");class M3 extends Error{constructor(e="Too many outbound protocol streams"){super(e),this.name="TooManyOutboundProtocolStreamsError"}}h(M3,"name","TooManyOutboundProtocolStreamsError");const Cre=Symbol.for("@libp2p/service-capabilities");var en;(function(n){n[n.Data=0]="Data",n[n.WindowUpdate=1]="WindowUpdate",n[n.Ping=2]="Ping",n[n.GoAway=3]="GoAway"})(en||(en={}));var dt;(function(n){n[n.SYN=1]="SYN",n[n.ACK=2]="ACK",n[n.FIN=4]="FIN",n[n.RST=8]="RST"})(dt||(dt={}));Object.values(dt).filter(n=>typeof n!="string");const Ire=0;var Rr;(function(n){n[n.NormalTermination=0]="NormalTermination",n[n.ProtocolError=1]="ProtocolError",n[n.InternalError=2]="InternalError"})(Rr||(Rr={}));const Ia=12;var Uw;let Hg=(Uw=class extends Error{constructor(t,r){super(t);h(this,"reason");this.name="ProtocolError",this.reason=r}},h(Uw,"name","ProtocolError"),Uw);function Pre(n){return(n==null?void 0:n.reason)!==null}class Pa extends Hg{constructor(e="The frame was invalid"){super(e,Rr.ProtocolError),this.name="InvalidFrameError"}}h(Pa,"name","InvalidFrameError");class C3 extends Hg{constructor(e="Un-requested ping error"){super(e,Rr.ProtocolError),this.name="UnRequestedPingError"}}h(C3,"name","UnRequestedPingError");class I3 extends Hg{constructor(e="Not matching ping error"){super(e,Rr.ProtocolError),this.name="NotMatchingPingError"}}h(I3,"name","NotMatchingPingError");class P3 extends Hg{constructor(e="Receive window exceeded"){super(e,Rr.ProtocolError),this.name="ReceiveWindowExceededError"}}h(P3,"name","ReceiveWindowExceededError");const D3=256*1024,Dre=16*1024*1024,mp={enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3};function Rre(n){var e,t,r,i,s,o,a,c;if(n.keepAliveInterval!=null&&n.keepAliveInterval<=0)throw new Is("keep-alive interval must be positive");if(n.maxInboundStreams!=null&&n.maxInboundStreams<0)throw new Is("max inbound streams must be larger or equal 0");if(n.maxOutboundStreams!=null&&n.maxOutboundStreams<0)throw new Is("max outbound streams must be larger or equal 0");if(n.maxMessageSize!=null&&n.maxMessageSize<1024)throw new Is("MaxMessageSize must be greater than a kilobyte");if(((e=n.streamOptions)==null?void 0:e.initialStreamWindowSize)!=null&&((t=n.streamOptions)==null?void 0:t.initialStreamWindowSize)<D3)throw new Is("InitialStreamWindowSize must be larger or equal 256 kB");if(((r=n.streamOptions)==null?void 0:r.maxStreamWindowSize)!=null&&((i=n.streamOptions)==null?void 0:i.initialStreamWindowSize)!=null&&((s=n.streamOptions)==null?void 0:s.maxStreamWindowSize)<((o=n.streamOptions)==null?void 0:o.initialStreamWindowSize))throw new Is("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");if(((a=n.streamOptions)==null?void 0:a.maxStreamWindowSize)!=null&&((c=n.streamOptions)==null?void 0:c.maxStreamWindowSize)>2**32-1)throw new Is("MaxStreamWindowSize must be less than equal MAX_UINT32")}function Lre(n){return n.header.type===en.Data&&n.data!==null}const i2=2**24;function Ore(n){if(n[0]!==Ire)throw new Pa("Invalid frame version");return{type:n[1],flag:(n[2]<<8)+n[3],streamID:n[4]*i2+(n[5]<<16)+(n[6]<<8)+n[7],length:n[8]*i2+(n[9]<<16)+(n[10]<<8)+n[11]}}let Nre=class{constructor(){h(this,"buffer");this.buffer=new ut}*emitFrames(e){for(this.buffer.append(e);;){const t=this.readFrame();if(t===void 0)break;yield t}}readFrame(){let e=Ia;if(this.buffer.byteLength<Ia)return;const t=Ore(this.buffer.subarray(0,Ia));if(t.type===en.Data){if(e+=t.length,this.buffer.byteLength<e)return;const r=this.buffer.sublist(Ia,e);return this.buffer.consume(e),{header:t,data:r}}return this.buffer.consume(e),{header:t}}};function s2(n){const e=new Uint8Array(Ia);return e[1]=n.type,e[2]=n.flag>>>8,e[3]=n.flag,e[4]=n.streamID>>>24,e[5]=n.streamID>>>16,e[6]=n.streamID>>>8,e[7]=n.streamID,e[8]=n.length>>>24,e[9]=n.length>>>16,e[10]=n.length>>>8,e[11]=n.length,e}var gr;(function(n){n[n.Init=0]="Init",n[n.SYNSent=1]="SYNSent",n[n.SYNReceived=2]="SYNReceived",n[n.Established=3]="Established",n[n.Finished=4]="Finished",n[n.Paused=5]="Paused"})(gr||(gr={}));class Ure extends ND{constructor(t){const r=t.initialStreamWindowSize??D3;super({...t,maxMessageSize:r-Ia});h(this,"streamId");h(this,"state");h(this,"sendWindowCapacity");h(this,"recvWindow");h(this,"recvWindowCapacity");h(this,"maxStreamWindowSize");h(this,"epochStart");h(this,"getRTT");h(this,"sendFrame");this.streamId=t.streamId,this.state=t.state,this.sendWindowCapacity=r,this.recvWindow=r,this.recvWindowCapacity=this.recvWindow,this.maxStreamWindowSize=t.maxStreamWindowSize??Dre,this.epochStart=Date.now(),this.getRTT=t.getRTT,this.sendFrame=t.sendFrame;const i=()=>{this.state=gr.Finished};this.addEventListener("close",i)}sendData(t){var o,a;const r=t.byteLength;let i=0,s=!0;for((o=this.log)==null||o.trace("send window capacity is %d bytes",this.sendWindowCapacity);t.byteLength>0;){if(this.sendWindowCapacity===0){s=!1,(a=this.log)==null||a.trace("sent %d/%d bytes, exhausted send window, waiting for window update",i,r);break}const c=Math.min(this.sendWindowCapacity,t.byteLength),l=this.getSendFlags(),u=t.sublist(0,c);t.consume(c);const d=this.sendFrame({type:en.Data,flag:l,streamID:this.streamId,length:c},u);if(this.sendWindowCapacity-=c,i+=c,!d){s=d,this.log.trace("sent %d/%d bytes, wait for muxer to have more send capacity",i,r);break}}return{sentBytes:i,canSendMore:s}}async sendReset(){this.sendFrame({type:en.WindowUpdate,flag:dt.RST,streamID:this.streamId,length:0})}async sendCloseWrite(){const t=this.getSendFlags()|dt.FIN;this.sendFrame({type:en.WindowUpdate,flag:t,streamID:this.streamId,length:0})}async sendCloseRead(t){var r;(r=t==null?void 0:t.signal)==null||r.throwIfAborted()}sendPause(){this.state=gr.Paused}sendResume(){this.state=gr.Established,this.sendWindowUpdate()}handleWindowUpdate(t){var r;this.processFlags(t.header.flag),this.sendWindowCapacity+=t.header.length,this.maxMessageSize=this.sendWindowCapacity-Ia,this.maxMessageSize<0&&(this.maxMessageSize=0),this.maxMessageSize!==0&&this.writeBuffer.byteLength>0&&((r=this.log)==null||r.trace("window update of %d bytes allows more data to be sent, have %d bytes queued, sending data %s",t.header.length,this.writeBuffer.byteLength,this.sendingData),this.safeDispatchEvent("drain"))}handleData(t){if(!Lre(t))throw new Pa("Frame was not data frame");if(this.processFlags(t.header.flag),this.recvWindowCapacity<t.header.length)throw new P3("Receive window exceeded");this.recvWindowCapacity-=t.header.length,this.onData(t.data),this.sendWindowUpdate()}processFlags(t){(t&dt.ACK)===dt.ACK&&this.state===gr.SYNSent&&(this.state=gr.Established),(t&dt.FIN)===dt.FIN&&this.onRemoteCloseWrite(),(t&dt.RST)===dt.RST&&this.onRemoteReset()}getSendFlags(){switch(this.state){case gr.Init:return this.state=gr.SYNSent,dt.SYN;case gr.SYNReceived:return this.state=gr.Established,dt.ACK;default:return 0}}sendWindowUpdate(){if(this.state===gr.Paused){this.epochStart=Date.now();return}const t=this.getSendFlags(),r=Date.now(),i=this.getRTT();if(t===0&&i>-1&&r-this.epochStart<=i*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&t===0)return;const s=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=r,this.sendFrame({type:en.WindowUpdate,flag:t,streamID:this.streamId,length:s})}}function o2(n){return{type:en[n.type],flags:[(n.flag&dt.SYN)===dt.SYN?"SYN":void 0,(n.flag&dt.ACK)===dt.ACK?"ACK":void 0,(n.flag&dt.FIN)===dt.FIN?"FIN":void 0,(n.flag&dt.RST)===dt.RST?"RST":void 0].filter(Boolean),streamID:n.streamID,length:n.length}}const R3="/yamux/1.0.0";var YC,ZC;ZC=Symbol.toStringTag,YC=Cre;class Bre{constructor(e={}){h(this,"protocol",R3);h(this,"_init");h(this,ZC,"@libp2p/yamux");h(this,YC,["@libp2p/stream-multiplexing"]);this._init=e}createStreamMuxer(e){return new kre(e,{...this._init})}}class kre extends OD{constructor(t,r={}){super(t,{...r,protocol:R3,name:"yamux"});h(this,"nextStreamID");h(this,"nextPingID");h(this,"activePing");h(this,"rtt");h(this,"client");h(this,"localGoAway");h(this,"remoteGoAway");h(this,"numInboundStreams");h(this,"numOutboundStreams");h(this,"decoder");h(this,"keepAlive");h(this,"enableKeepAlive");h(this,"keepAliveInterval");h(this,"maxInboundStreams");h(this,"maxOutboundStreams");this.client=t.direction==="outbound",Rre(r),this.enableKeepAlive=r.enableKeepAlive??mp.enableKeepAlive,this.keepAliveInterval=r.keepAliveInterval??mp.keepAliveInterval,this.maxInboundStreams=r.maxInboundStreams??mp.maxInboundStreams,this.maxOutboundStreams=r.maxOutboundStreams??mp.maxOutboundStreams,this.decoder=new Nre,this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=-1,this.log.trace("muxer created"),this.enableKeepAlive&&(this.log.trace("muxer keepalive enabled interval=%s",this.keepAliveInterval),this.keepAlive=kD(async i=>{try{await this.ping(i)}catch(s){this.log.error("ping error: %s",s)}},this.keepAliveInterval,{runImmediately:!0}),this.keepAlive.start())}onData(t){for(const r of this.decoder.emitFrames(t))this.handleFrame(r)}onCreateStream(){if(this.remoteGoAway!==void 0)throw new Ch("Muxer closed remotely");if(this.localGoAway!==void 0)throw new Ch("Muxer closed locally");const t=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.maxOutboundStreams)throw new M3("max outbound streams exceeded");this.log.trace("new outgoing stream id=%s",t);const r=this._newStream(t,gr.Init,"outbound");return this.numOutboundStreams++,queueMicrotask(()=>{r.sendWindowUpdate()}),r}async ping(t){if(this.remoteGoAway!==void 0)throw new Ch("Muxer closed remotely");if(this.localGoAway!==void 0)throw new Ch("Muxer closed locally");if(this.activePing!=null)return Vi(this.activePing.promise,t==null?void 0:t.signal);this.activePing=Object.assign(Promise.withResolvers(),{id:this.nextPingID++,start:Date.now()}),this.sendPing(this.activePing.id);try{this.rtt=await Vi(this.activePing.promise,t==null?void 0:t.signal)}finally{this.activePing=void 0}return this.rtt}getRTT(){return this.rtt}async close(t={}){var r;if(this.status==="open")try{const i=(t==null?void 0:t.reason)??Rr.NormalTermination;this.log.trace("muxer close reason=%s",Rr[i]),await super.close(t),this.sendGoAway(i)}finally{(r=this.keepAlive)==null||r.stop()}}abort(t){var r;if(this.status==="open")try{super.abort(t);let i=Rr.InternalError;Pre(t)&&(i=t.reason),this.log.error("muxer abort reason=%s error=%s",i,t),this.sendGoAway(i)}finally{(r=this.keepAlive)==null||r.stop()}}onTransportClosed(){var t;try{super.onTransportClosed()}finally{(t=this.keepAlive)==null||t.stop()}}_newStream(t,r,i){if(this.streams.find(o=>o.streamId===t)!=null)throw new Is("Stream already exists with that id");const s=new Ure({...this.streamOptions,id:`${t}`,streamId:t,state:r,direction:i,sendFrame:this.sendFrame.bind(this),log:this.log.newScope(`${i}:${t}`),getRTT:this.getRTT.bind(this)});return s.addEventListener("close",()=>{this.closeStream(t)},{once:!0}),s}closeStream(t){this.client===(t%2===0)?this.numInboundStreams--:this.numOutboundStreams--}handleFrame(t){const{streamID:r,type:i,length:s}=t.header;if(this.log.trace("received frame %o",o2(t.header)),r===0)switch(i){case en.Ping:{this.handlePing(t.header);return}case en.GoAway:{this.handleGoAway(s);return}default:throw new Pa("Invalid frame type")}else switch(t.header.type){case en.Data:case en.WindowUpdate:{this.handleStreamMessage(t);return}default:throw new Pa("Invalid frame type")}}handlePing(t){if(t.flag===dt.SYN)this.log.trace("received ping request pingId=%s",t.length),this.sendPing(t.length,dt.ACK);else if(t.flag===dt.ACK)this.log.trace("received ping response pingId=%s",t.length),this.handlePingResponse(t.length);else throw new Pa("Invalid frame flag")}handlePingResponse(t){if(this.activePing===void 0)throw new C3("ping not requested");if(this.activePing.id!==t)throw new I3("ping doesn't match our id");this.activePing.resolve(Date.now()-this.activePing.start)}handleGoAway(t){this.log.trace("received GoAway reason=%s",Rr[t]??"unknown"),this.remoteGoAway=t,t===Rr.NormalTermination?this.onTransportClosed():this.abort(new Error("Remote sent GoAway"))}handleStreamMessage(t){const{streamID:r,flag:i,type:s}=t.header;(i&dt.SYN)===dt.SYN&&this.incomingStream(r);const o=this.streams.find(a=>a.streamId===r);if(o===void 0){this.log.trace("frame for missing stream id=%s",r);return}switch(s){case en.WindowUpdate:{o.handleWindowUpdate(t);return}case en.Data:{o.handleData(t);return}default:throw new Error("unreachable")}}incomingStream(t){if(this.client!==(t%2===0))throw new Is("Both endpoints are clients");if(this.streams.find(i=>i.streamId===t))return;if(this.log.trace("new incoming stream id=%s",t),this.localGoAway!==void 0){this.sendFrame({type:en.WindowUpdate,flag:dt.RST,streamID:t,length:0});return}if(this.numInboundStreams>=this.maxInboundStreams){this.log("maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:en.WindowUpdate,flag:dt.RST,streamID:t,length:0});return}const r=this._newStream(t,gr.SYNReceived,"inbound");this.numInboundStreams++,this.onRemoteStream(r)}sendFrame(t,r){let i;if(t.type===en.Data){if(r==null)throw new Pa("Invalid frame");i=new ut(s2(t),r)}else i=s2(t);return this.log.trace("sending frame %o",o2(t)),this.send(i)}sendPing(t,r=dt.SYN){r===dt.SYN?this.log.trace("sending ping request pingId=%s",t):this.log.trace("sending ping response pingId=%s",t),this.sendFrame({type:en.Ping,flag:r,streamID:0,length:t})}sendGoAway(t=Rr.NormalTermination){this.log("sending GoAway reason=%s",Rr[t]),this.localGoAway=t,this.sendFrame({type:en.GoAway,flag:0,streamID:0,length:t})}}function $re(n={}){return()=>new Bre(n)}const Fre=Symbol.for("@libp2p/pubsub");var Bw;let dc=(Bw=class extends Error{constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}},h(Bw,"name","InvalidParametersError"),Bw);class hS extends Error{constructor(e="Invalid public key"){super(e),this.name="InvalidPublicKeyError"}}h(hS,"name","InvalidPublicKeyError");var kw;let zre=(kw=class extends Error{constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}},h(kw,"name","InvalidMultihashError"),kw);var $w;let vn=($w=class extends Error{constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}},h($w,"name","InvalidMessageError"),$w);class L3 extends Error{constructor(e="Not started"){super(e),this.name="NotStartedError"}}h(L3,"name","NotStartedError");var Fw;let dS=(Fw=class extends Error{constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}},h(Fw,"name","UnsupportedKeyTypeError"),Fw);const O3=Symbol.for("@libp2p/peer-id");var ji;class N3 extends EventTarget{constructor(){super();me(this,ji,new Map)}listenerCount(t){const r=D(this,ji).get(t);return r==null?0:r.length}addEventListener(t,r,i){super.addEventListener(t,r,i);let s=D(this,ji).get(t);s==null&&(s=[],D(this,ji).set(t,s)),s.push({callback:r,once:(i!==!0&&i!==!1&&(i==null?void 0:i.once))??!1})}removeEventListener(t,r,i){super.removeEventListener(t.toString(),r??null,i);let s=D(this,ji).get(t);s!=null&&(s=s.filter(({callback:o})=>o!==r),D(this,ji).set(t,s))}dispatchEvent(t){const r=super.dispatchEvent(t);let i=D(this,ji).get(t.type);return i==null||(i=i.filter(({once:s})=>!s),D(this,ji).set(t.type,i)),r}safeDispatchEvent(t,r={}){return this.dispatchEvent(new CustomEvent(t,r))}}ji=new WeakMap;const Vre=Symbol.for("@libp2p/service-capabilities"),Hre=Symbol.for("@libp2p/service-dependencies");function Gre(n,e){if(n===e)return!0;if(n.byteLength!==e.byteLength)return!1;for(let t=0;t<n.byteLength;t++)if(n[t]!==e[t])return!1;return!0}function Gg(n){if(n instanceof Uint8Array&&n.constructor.name==="Uint8Array")return n;if(n instanceof ArrayBuffer)return new Uint8Array(n);if(ArrayBuffer.isView(n))return new Uint8Array(n.buffer,n.byteOffset,n.byteLength);throw new Error("Unknown type, must be binary type")}function Wre(n){return new TextEncoder().encode(n)}function qre(n){return new TextDecoder().decode(n)}function Kre(n,e){if(n.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),r=0;r<t.length;r++)t[r]=255;for(var i=0;i<n.length;i++){var s=n.charAt(i),o=s.charCodeAt(0);if(t[o]!==255)throw new TypeError(s+" is ambiguous");t[o]=i}var a=n.length,c=n.charAt(0),l=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function d(g){if(g instanceof Uint8Array||(ArrayBuffer.isView(g)?g=new Uint8Array(g.buffer,g.byteOffset,g.byteLength):Array.isArray(g)&&(g=Uint8Array.from(g))),!(g instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(g.length===0)return"";for(var b=0,m=0,y=0,E=g.length;y!==E&&g[y]===0;)y++,b++;for(var w=(E-y)*u+1>>>0,x=new Uint8Array(w);y!==E;){for(var M=g[y],A=0,C=w-1;(M!==0||A<m)&&C!==-1;C--,A++)M+=256*x[C]>>>0,x[C]=M%a>>>0,M=M/a>>>0;if(M!==0)throw new Error("Non-zero carry");m=A,y++}for(var R=w-m;R!==w&&x[R]===0;)R++;for(var _=c.repeat(b);R<w;++R)_+=n.charAt(x[R]);return _}function f(g){if(typeof g!="string")throw new TypeError("Expected String");if(g.length===0)return new Uint8Array;var b=0;if(g[b]!==" "){for(var m=0,y=0;g[b]===c;)m++,b++;for(var E=(g.length-b)*l+1>>>0,w=new Uint8Array(E);g[b];){var x=t[g.charCodeAt(b)];if(x===255)return;for(var M=0,A=E-1;(x!==0||M<y)&&A!==-1;A--,M++)x+=a*w[A]>>>0,w[A]=x%256>>>0,x=x/256>>>0;if(x!==0)throw new Error("Non-zero carry");y=M,b++}if(g[b]!==" "){for(var C=E-y;C!==E&&w[C]===0;)C++;for(var R=new Uint8Array(m+(E-C)),_=m;C!==E;)R[_++]=w[C++];return R}}}function p(g){var b=f(g);if(b)return b;throw new Error(`Non-${e} character`)}return{encode:d,decodeUnsafe:f,decode:p}}var Xre=Kre,Yre=Xre;let Zre=class{constructor(e,t,r){h(this,"name");h(this,"prefix");h(this,"baseEncode");this.name=e,this.prefix=t,this.baseEncode=r}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},jre=class{constructor(e,t,r){h(this,"name");h(this,"prefix");h(this,"baseDecode");h(this,"prefixCodePoint");this.name=e,this.prefix=t;const i=t.codePointAt(0);if(i===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=i,this.baseDecode=r}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return U3(this,e)}};class Jre{constructor(e){h(this,"decoders");this.decoders=e}or(e){return U3(this,e)}decode(e){const t=e[0],r=this.decoders[t];if(r!=null)return r.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function U3(n,e){return new Jre({...n.decoders??{[n.prefix]:n},...e.decoders??{[e.prefix]:e}})}class Qre{constructor(e,t,r,i){h(this,"name");h(this,"prefix");h(this,"baseEncode");h(this,"baseDecode");h(this,"encoder");h(this,"decoder");this.name=e,this.prefix=t,this.baseEncode=r,this.baseDecode=i,this.encoder=new Zre(e,t,r),this.decoder=new jre(e,t,i)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}function Wg({name:n,prefix:e,encode:t,decode:r}){return new Qre(n,e,t,r)}function nf({name:n,prefix:e,alphabet:t}){const{encode:r,decode:i}=Yre(t,n);return Wg({prefix:e,name:n,encode:r,decode:s=>Gg(i(s))})}function eie(n,e,t,r){let i=n.length;for(;n[i-1]==="=";)--i;const s=new Uint8Array(i*t/8|0);let o=0,a=0,c=0;for(let l=0;l<i;++l){const u=e[n[l]];if(u===void 0)throw new SyntaxError(`Non-${r} character`);a=a<<t|u,o+=t,o>=8&&(o-=8,s[c++]=255&a>>o)}if(o>=t||(255&a<<8-o)!==0)throw new SyntaxError("Unexpected end of data");return s}function tie(n,e,t){const r=e[e.length-1]==="=",i=(1<<t)-1;let s="",o=0,a=0;for(let c=0;c<n.length;++c)for(a=a<<8|n[c],o+=8;o>t;)o-=t,s+=e[i&a>>o];if(o!==0&&(s+=e[i&a<<t-o]),r)for(;(s.length*t&7)!==0;)s+="=";return s}function nie(n){const e={};for(let t=0;t<n.length;++t)e[n[t]]=t;return e}function Pn({name:n,prefix:e,bitsPerChar:t,alphabet:r}){const i=nie(r);return Wg({prefix:e,name:n,encode(s){return tie(s,r,t)},decode(s){return eie(s,i,t,n)}})}const hr=nf({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),rie=nf({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),iie=Object.freeze(Object.defineProperty({__proto__:null,base58btc:hr,base58flickr:rie},Symbol.toStringTag,{value:"Module"})),Hh=Pn({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),sie=Pn({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),oie=Pn({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),aie=Pn({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),cie=Pn({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),lie=Pn({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),uie=Pn({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),hie=Pn({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),die=Pn({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),fie=Object.freeze(Object.defineProperty({__proto__:null,base32:Hh,base32hex:cie,base32hexpad:uie,base32hexpadupper:hie,base32hexupper:lie,base32pad:oie,base32padupper:aie,base32upper:sie,base32z:die},Symbol.toStringTag,{value:"Module"})),Gp=nf({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),pie=nf({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),mie=Object.freeze(Object.defineProperty({__proto__:null,base36:Gp,base36upper:pie},Symbol.toStringTag,{value:"Module"}));var gie=B3,a2=128,yie=-128,bie=Math.pow(2,31);function B3(n,e,t){e=e||[],t=t||0;for(var r=t;n>=bie;)e[t++]=n&255|a2,n/=128;for(;n&yie;)e[t++]=n&255|a2,n>>>=7;return e[t]=n|0,B3.bytes=t-r+1,e}var wie=c_,vie=128,c2=127;function c_(n,r){var t=0,r=r||0,i=0,s=r,o,a=n.length;do{if(s>=a)throw c_.bytes=0,new RangeError("Could not decode varint");o=n[s++],t+=i<28?(o&c2)<<i:(o&c2)*Math.pow(2,i),i+=7}while(o>=vie);return c_.bytes=s-r,t}var _ie=Math.pow(2,7),Eie=Math.pow(2,14),Sie=Math.pow(2,21),xie=Math.pow(2,28),Tie=Math.pow(2,35),Aie=Math.pow(2,42),Mie=Math.pow(2,49),Cie=Math.pow(2,56),Iie=Math.pow(2,63),Pie=function(n){return n<_ie?1:n<Eie?2:n<Sie?3:n<xie?4:n<Tie?5:n<Aie?6:n<Mie?7:n<Cie?8:n<Iie?9:10},Die={encode:gie,decode:wie,encodingLength:Pie},Wm=Die;function l_(n,e=0){return[Wm.decode(n,e),Wm.decode.bytes]}function qm(n,e,t=0){return Wm.encode(n,e,t),e}function Km(n){return Wm.encodingLength(n)}function qg(n,e){const t=e.byteLength,r=Km(n),i=r+Km(t),s=new Uint8Array(i+t);return qm(n,s,0),qm(t,s,r),s.set(e,i),new fS(n,t,e,s)}function Kg(n){const e=Gg(n),[t,r]=l_(e),[i,s]=l_(e.subarray(r)),o=e.subarray(r+s);if(o.byteLength!==i)throw new Error("Incorrect length");return new fS(t,i,o,e)}function Rie(n,e){if(n===e)return!0;{const t=e;return n.code===t.code&&n.size===t.size&&t.bytes instanceof Uint8Array&&Gre(n.bytes,t.bytes)}}class fS{constructor(e,t,r,i){h(this,"code");h(this,"size");h(this,"digest");h(this,"bytes");this.code=e,this.size=t,this.digest=r,this.bytes=i}}function l2(n,e){const{bytes:t,version:r}=n;switch(r){case 0:return Oie(t,u_(n),e??hr.encoder);default:return Nie(t,u_(n),e??Hh.encoder)}}const u2=new WeakMap;function u_(n){const e=u2.get(n);if(e==null){const t=new Map;return u2.set(n,t),t}return e}var jC;class Gt{constructor(e,t,r,i){h(this,"code");h(this,"version");h(this,"multihash");h(this,"bytes");h(this,"/");h(this,jC,"CID");this.code=t,this.version=e,this.multihash=r,this.bytes=i,this["/"]=i}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==hh)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==Uie)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return Gt.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,r=qg(e,t);return Gt.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return Gt.equals(this,e)}static equals(e,t){const r=t;return r!=null&&e.code===r.code&&e.version===r.version&&Rie(e.multihash,r.multihash)}toString(e){return l2(this,e)}toJSON(){return{"/":l2(this)}}link(){return this}[(jC=Symbol.toStringTag,Symbol.for("nodejs.util.inspect.custom"))](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const t=e;if(t instanceof Gt)return t;if(t["/"]!=null&&t["/"]===t.bytes||t.asCID===t){const{version:r,code:i,multihash:s,bytes:o}=t;return new Gt(r,i,s,o??h2(r,i,s.bytes))}else if(t[Bie]===!0){const{version:r,multihash:i,code:s}=t,o=Kg(i);return Gt.create(r,s,o)}else return null}static create(e,t,r){if(typeof t!="number")throw new Error("String codecs are no longer supported");if(!(r.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(t!==hh)throw new Error(`Version 0 CID must use dag-pb (code: ${hh}) block encoding`);return new Gt(e,t,r,r.bytes)}case 1:{const i=h2(e,t,r.bytes);return new Gt(e,t,r,i)}default:throw new Error("Invalid version")}}static createV0(e){return Gt.create(0,hh,e)}static createV1(e,t){return Gt.create(1,e,t)}static decode(e){const[t,r]=Gt.decodeFirst(e);if(r.length!==0)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=Gt.inspectBytes(e),r=t.size-t.multihashSize,i=Gg(e.subarray(r,r+t.multihashSize));if(i.byteLength!==t.multihashSize)throw new Error("Incorrect length");const s=i.subarray(t.multihashSize-t.digestSize),o=new fS(t.multihashCode,t.digestSize,s,i);return[t.version===0?Gt.createV0(o):Gt.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0;const r=()=>{const[d,f]=l_(e.subarray(t));return t+=f,d};let i=r(),s=hh;if(i===18?(i=0,t=0):s=r(),i!==0&&i!==1)throw new RangeError(`Invalid CID version ${i}`);const o=t,a=r(),c=r(),l=t+c,u=l-o;return{version:i,codec:s,multihashCode:a,digestSize:c,multihashSize:u,size:l}}static parse(e,t){const[r,i]=Lie(e,t),s=Gt.decode(i);if(s.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return u_(s).set(r,e),s}}function Lie(n,e){switch(n[0]){case"Q":{const t=e??hr;return[hr.prefix,t.decode(`${hr.prefix}${n}`)]}case hr.prefix:{const t=e??hr;return[hr.prefix,t.decode(n)]}case Hh.prefix:{const t=e??Hh;return[Hh.prefix,t.decode(n)]}case Gp.prefix:{const t=e??Gp;return[Gp.prefix,t.decode(n)]}default:{if(e==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[n[0],e.decode(n)]}}}function Oie(n,e,t){const{prefix:r}=t;if(r!==hr.prefix)throw Error(`Cannot string encode V0 in ${t.name} encoding`);const i=e.get(r);if(i==null){const s=t.encode(n).slice(1);return e.set(r,s),s}else return i}function Nie(n,e,t){const{prefix:r}=t,i=e.get(r);if(i==null){const s=t.encode(n);return e.set(r,s),s}else return i}const hh=112,Uie=18;function h2(n,e,t){const r=Km(n),i=r+Km(e),s=new Uint8Array(i+t.byteLength);return qm(n,s,0),qm(e,s,r),s.set(t,i),s}const Bie=Symbol.for("@ipld/js-cid/CID"),k3=0,kie="identity",$3=Gg;function $ie(n,e){if((e==null?void 0:e.truncate)!=null&&e.truncate!==n.byteLength){if(e.truncate<0||e.truncate>n.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${n.byteLength}`);n=n.subarray(0,e.truncate)}return qg(k3,$3(n))}const rf={code:k3,name:kie,encode:$3,digest:$ie};function nc(n,e){if(n===e)return!0;if(n.byteLength!==e.byteLength)return!1;for(let t=0;t<n.byteLength;t++)if(n[t]!==e[t])return!1;return!0}function So(n=0){return new Uint8Array(n)}function ea(n=0){return new Uint8Array(n)}function Xm(n,e){e==null&&(e=n.reduce((i,s)=>i+s.length,0));const t=ea(e);let r=0;for(const i of n)t.set(i,r),r+=i.length;return t}const F3=Symbol.for("@achingbrain/uint8arraylist");function d2(n,e){if(e==null||e<0)throw new RangeError("index is out of bounds");let t=0;for(const r of n){const i=t+r.byteLength;if(e<i)return{buf:r,index:e-t};t=i}throw new RangeError("index is out of bounds")}function gp(n){return!!(n!=null&&n[F3])}var JC;class Tn{constructor(...e){h(this,"bufs");h(this,"length");h(this,JC,!0);this.bufs=[],this.length=0,e.length>0&&this.appendAll(e)}*[(JC=F3,Symbol.iterator)](){yield*this.bufs}get byteLength(){return this.length}append(...e){this.appendAll(e)}appendAll(e){let t=0;for(const r of e)if(r instanceof Uint8Array)t+=r.byteLength,this.bufs.push(r);else if(gp(r))t+=r.byteLength,this.bufs.push(...r.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}prepend(...e){this.prependAll(e)}prependAll(e){let t=0;for(const r of e.reverse())if(r instanceof Uint8Array)t+=r.byteLength,this.bufs.unshift(r);else if(gp(r))t+=r.byteLength,this.bufs.unshift(...r.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}get(e){const t=d2(this.bufs,e);return t.buf[t.index]}set(e,t){const r=d2(this.bufs,e);r.buf[r.index]=t}write(e,t=0){if(e instanceof Uint8Array)for(let r=0;r<e.length;r++)this.set(t+r,e[r]);else if(gp(e))for(let r=0;r<e.length;r++)this.set(t+r,e.get(r));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(e){if(e=Math.trunc(e),!(Number.isNaN(e)||e<=0)){if(e===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(e>=this.bufs[0].byteLength)e-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(e),this.length-=e;break}}}slice(e,t){const{bufs:r,length:i}=this._subList(e,t);return Xm(r,i)}subarray(e,t){const{bufs:r,length:i}=this._subList(e,t);return r.length===1?r[0]:Xm(r,i)}sublist(e,t){const{bufs:r,length:i}=this._subList(e,t),s=new Tn;return s.length=i,s.bufs=[...r],s}_subList(e,t){if(e=e??0,t=t??this.length,e<0&&(e=this.length+e),t<0&&(t=this.length+t),e<0||t>this.length)throw new RangeError("index is out of bounds");if(e===t)return{bufs:[],length:0};if(e===0&&t===this.length)return{bufs:this.bufs,length:this.length};const r=[];let i=0;for(let s=0;s<this.bufs.length;s++){const o=this.bufs[s],a=i,c=a+o.byteLength;if(i=c,e>=c)continue;const l=e>=a&&e<c,u=t>a&&t<=c;if(l&&u){if(e===a&&t===c){r.push(o);break}const d=e-a;r.push(o.subarray(d,d+(t-e)));break}if(l){if(e===0){r.push(o);continue}r.push(o.subarray(e-a));continue}if(u){if(t===c){r.push(o);break}r.push(o.subarray(0,t-a));break}r.push(o)}return{bufs:r,length:t-e}}indexOf(e,t=0){if(!gp(e)&&!(e instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const r=e instanceof Uint8Array?e:e.subarray();if(t=Number(t??0),isNaN(t)&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),e.length===0)return t>this.length?this.length:t;const i=r.byteLength;if(i===0)throw new TypeError("search must be at least 1 byte long");const s=256,o=new Int32Array(s);for(let d=0;d<s;d++)o[d]=-1;for(let d=0;d<i;d++)o[r[d]]=d;const a=o,c=this.byteLength-r.byteLength,l=r.byteLength-1;let u;for(let d=t;d<=c;d+=u){u=0;for(let f=l;f>=0;f--){const p=this.get(d+f);if(r[f]!==p){u=Math.max(1,f-a[p]);break}}if(u===0)return d}return-1}getInt8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getInt8(0)}setInt8(e,t){const r=ea(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setInt8(0,t),this.write(r,e)}getInt16(e,t){const r=this.subarray(e,e+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt16(0,t)}setInt16(e,t,r){const i=So(2);new DataView(i.buffer,i.byteOffset,i.byteLength).setInt16(0,t,r),this.write(i,e)}getInt32(e,t){const r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt32(0,t)}setInt32(e,t,r){const i=So(4);new DataView(i.buffer,i.byteOffset,i.byteLength).setInt32(0,t,r),this.write(i,e)}getBigInt64(e,t){const r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigInt64(0,t)}setBigInt64(e,t,r){const i=So(8);new DataView(i.buffer,i.byteOffset,i.byteLength).setBigInt64(0,t,r),this.write(i,e)}getUint8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getUint8(0)}setUint8(e,t){const r=ea(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setUint8(0,t),this.write(r,e)}getUint16(e,t){const r=this.subarray(e,e+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint16(0,t)}setUint16(e,t,r){const i=So(2);new DataView(i.buffer,i.byteOffset,i.byteLength).setUint16(0,t,r),this.write(i,e)}getUint32(e,t){const r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint32(0,t)}setUint32(e,t,r){const i=So(4);new DataView(i.buffer,i.byteOffset,i.byteLength).setUint32(0,t,r),this.write(i,e)}getBigUint64(e,t){const r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigUint64(0,t)}setBigUint64(e,t,r){const i=So(8);new DataView(i.buffer,i.byteOffset,i.byteLength).setBigUint64(0,t,r),this.write(i,e)}getFloat32(e,t){const r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat32(0,t)}setFloat32(e,t,r){const i=So(4);new DataView(i.buffer,i.byteOffset,i.byteLength).setFloat32(0,t,r),this.write(i,e)}getFloat64(e,t){const r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat64(0,t)}setFloat64(e,t,r){const i=So(8);new DataView(i.buffer,i.byteOffset,i.byteLength).setFloat64(0,t,r),this.write(i,e)}equals(e){if(e==null||!(e instanceof Tn)||e.bufs.length!==this.bufs.length)return!1;for(let t=0;t<this.bufs.length;t++)if(!nc(this.bufs[t],e.bufs[t]))return!1;return!0}static fromUint8Arrays(e,t){const r=new Tn;return r.bufs=e,t==null&&(t=e.reduce((i,s)=>i+s.byteLength,0)),r.length=t,r}}const Fie=nf({prefix:"9",name:"base10",alphabet:"0123456789"}),zie=Object.freeze(Object.defineProperty({__proto__:null,base10:Fie},Symbol.toStringTag,{value:"Module"})),Vie=Pn({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Hie=Pn({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),Gie=Object.freeze(Object.defineProperty({__proto__:null,base16:Vie,base16upper:Hie},Symbol.toStringTag,{value:"Module"})),Wie=Pn({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),qie=Object.freeze(Object.defineProperty({__proto__:null,base2:Wie},Symbol.toStringTag,{value:"Module"})),z3=Array.from(""),Kie=z3.reduce((n,e,t)=>(n[t]=e,n),[]),Xie=z3.reduce((n,e,t)=>{const r=e.codePointAt(0);if(r==null)throw new Error(`Invalid character: ${e}`);return n[r]=t,n},[]);function Yie(n){return n.reduce((e,t)=>(e+=Kie[t],e),"")}function Zie(n){const e=[];for(const t of n){const r=t.codePointAt(0);if(r==null)throw new Error(`Invalid character: ${t}`);const i=Xie[r];if(i==null)throw new Error(`Non-base256emoji character: ${t}`);e.push(i)}return new Uint8Array(e)}const jie=Wg({prefix:"",name:"base256emoji",encode:Yie,decode:Zie}),Jie=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:jie},Symbol.toStringTag,{value:"Module"})),Qie=Pn({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),ese=Pn({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),tse=Pn({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),nse=Pn({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),rse=Object.freeze(Object.defineProperty({__proto__:null,base64:Qie,base64pad:ese,base64url:tse,base64urlpad:nse},Symbol.toStringTag,{value:"Module"})),ise=Pn({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),sse=Object.freeze(Object.defineProperty({__proto__:null,base8:ise},Symbol.toStringTag,{value:"Module"})),ose=Wg({prefix:"\0",name:"identity",encode:n=>qre(n),decode:n=>Wre(n)}),ase=Object.freeze(Object.defineProperty({__proto__:null,identity:ose},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const cse=20;function lse({name:n,code:e,encode:t,minDigestLength:r,maxDigestLength:i}){return new use(n,e,t,r,i)}class use{constructor(e,t,r,i,s){h(this,"name");h(this,"code");h(this,"encode");h(this,"minDigestLength");h(this,"maxDigestLength");this.name=e,this.code=t,this.encode=r,this.minDigestLength=i??cse,this.maxDigestLength=s}digest(e,t){if((t==null?void 0:t.truncate)!=null){if(t.truncate<this.minDigestLength)throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);if(this.maxDigestLength!=null&&t.truncate>this.maxDigestLength)throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`)}if(e instanceof Uint8Array){const r=this.encode(e);return r instanceof Uint8Array?f2(r,this.code,t==null?void 0:t.truncate):r.then(i=>f2(i,this.code,t==null?void 0:t.truncate))}else throw Error("Unknown type, must be binary type")}}function f2(n,e,t){if(t!=null&&t!==n.byteLength){if(t>n.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${n.byteLength}`);n=n.subarray(0,t)}return qg(e,n)}function hse(n){return async e=>new Uint8Array(await crypto.subtle.digest(n,e))}const pS=lse({name:"sha2-256",code:18,encode:hse("SHA-256")}),p2={...ase,...qie,...sse,...zie,...Gie,...fie,...mie,...iie,...rse,...Jie};function V3(n,e,t,r){return{name:n,prefix:e,encoder:{name:n,prefix:e,encode:t},decoder:{decode:r}}}const m2=V3("utf8","u",n=>"u"+new TextDecoder("utf8").decode(n),n=>new TextEncoder().encode(n.substring(1))),R0=V3("ascii","a",n=>{let e="a";for(let t=0;t<n.length;t++)e+=String.fromCharCode(n[t]);return e},n=>{n=n.substring(1);const e=ea(n.length);for(let t=0;t<n.length;t++)e[t]=n.charCodeAt(t);return e}),H3={utf8:m2,"utf-8":m2,hex:p2.base16,latin1:R0,ascii:R0,binary:R0,...p2};function io(n,e="utf8"){const t=H3[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.decoder.decode(`${t.prefix}${n}`)}function Or(n,e="utf8"){const t=H3[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.encoder.encode(n).substring(1)}const dse=parseInt("11111",2),h_=parseInt("10000000",2),fse=parseInt("01111111",2),g2={0:dh,1:dh,2:pse,3:yse,4:bse,5:gse,6:mse,16:dh,22:dh,48:dh};function Xg(n,e={offset:0}){const t=n[e.offset]&dse;if(e.offset++,g2[t]!=null)return g2[t](n,e);throw new Error("No decoder for tag "+t)}function sf(n,e){let t=0;if((n[e.offset]&h_)===h_){const r=n[e.offset]&fse;let i="0x";e.offset++;for(let s=0;s<r;s++,e.offset++)i+=n[e.offset].toString(16).padStart(2,"0");t=parseInt(i,16)}else t=n[e.offset],e.offset++;return t}function dh(n,e){sf(n,e);const t=[];for(;!(e.offset>=n.byteLength);){const r=Xg(n,e);if(r===null)break;t.push(r)}return t}function pse(n,e){const t=sf(n,e),r=e.offset,i=e.offset+t,s=[];for(let o=r;o<i;o++)o===r&&n[o]===0||s.push(n[o]);return e.offset+=t,Uint8Array.from(s)}function mse(n,e){const t=sf(n,e),r=e.offset+t,i=n[e.offset];e.offset++;let s=0,o=0;i<40?(s=0,o=i):i<80?(s=1,o=i-40):(s=2,o=i-80);let a=`${s}.${o}`,c=[];for(;e.offset<r;){const l=n[e.offset];if(e.offset++,c.push(l&127),l<128){c.reverse();let u=0;for(let d=0;d<c.length;d++)u+=c[d]<<d*7;a+=`.${u}`,c=[]}}return a}function gse(n,e){return e.offset++,null}function yse(n,e){const t=sf(n,e),r=n[e.offset];e.offset++;const i=n.subarray(e.offset,e.offset+t-1);if(e.offset+=t,r!==0)throw new Error("Unused bits in bit string is unimplemented");return i}function bse(n,e){const t=sf(n,e),r=n.subarray(e.offset,e.offset+t);return e.offset+=t,r}function wse(n){let e=n.toString(16);e.length%2===1&&(e="0"+e);const t=new Tn;for(let r=0;r<e.length;r+=2)t.append(Uint8Array.from([parseInt(`${e[r]}${e[r+1]}`,16)]));return t}function mS(n){if(n.byteLength<128)return Uint8Array.from([n.byteLength]);const e=wse(n.byteLength);return new Tn(Uint8Array.from([e.byteLength|h_]),e)}function d_(n){const e=new Tn,t=128;return(n.subarray()[0]&t)===t&&e.append(Uint8Array.from([0])),e.append(n),new Tn(Uint8Array.from([2]),mS(e),e)}function G3(n){const e=Uint8Array.from([0]),t=new Tn(e,n);return new Tn(Uint8Array.from([3]),mS(t),t)}function Gh(n,e=48){const t=new Tn;for(const r of n)t.append(r);return new Tn(Uint8Array.from([e]),mS(t),t)}async function vse(n,e,t,r){var o,a;const i=await crypto.subtle.importKey("jwk",n,{name:"ECDSA",namedCurve:n.crv??"P-256"},!1,["verify"]);(o=r==null?void 0:r.signal)==null||o.throwIfAborted();const s=await crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},i,e,t.subarray());return(a=r==null?void 0:r.signal)==null||a.throwIfAborted(),s}const _se=Uint8Array.from([6,8,42,134,72,206,61,3,1,7]),Ese=Uint8Array.from([6,5,43,129,4,0,34]),Sse=Uint8Array.from([6,5,43,129,4,0,35]),xse={ext:!0,kty:"EC",crv:"P-256"},Tse={ext:!0,kty:"EC",crv:"P-384"},Ase={ext:!0,kty:"EC",crv:"P-521"},L0=32,O0=48,N0=66;function W3(n){const e=Xg(n);return Mse(e)}function Mse(n){const e=n[1][1][0],t=1;let r,i;if(e.byteLength===L0*2+1)return r=Or(e.subarray(t,t+L0),"base64url"),i=Or(e.subarray(t+L0),"base64url"),new U0({...xse,key_ops:["verify"],x:r,y:i});if(e.byteLength===O0*2+1)return r=Or(e.subarray(t,t+O0),"base64url"),i=Or(e.subarray(t+O0),"base64url"),new U0({...Tse,key_ops:["verify"],x:r,y:i});if(e.byteLength===N0*2+1)return r=Or(e.subarray(t,t+N0),"base64url"),i=Or(e.subarray(t+N0),"base64url"),new U0({...Ase,key_ops:["verify"],x:r,y:i});throw new dc(`coordinates were wrong length, got ${e.byteLength}, expected 65, 97 or 133`)}function Cse(n){return Gh([d_(Uint8Array.from([1])),Gh([Ise(n.crv)],160),Gh([G3(new Tn(Uint8Array.from([4]),io(n.x??"","base64url"),io(n.y??"","base64url")))],161)]).subarray()}function Ise(n){if(n==="P-256")return _se;if(n==="P-384")return Ese;if(n==="P-521")return Sse;throw new dc(`Invalid curve ${n}`)}class U0{constructor(e){h(this,"type","ECDSA");h(this,"jwk");h(this,"_raw");this.jwk=e}get raw(){return this._raw==null&&(this._raw=Cse(this.jwk)),this._raw}toMultihash(){return rf.digest(cf(this))}toCID(){return Gt.createV1(114,this.toMultihash())}toString(){return hr.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:nc(this.raw,e.raw)}async verify(e,t,r){return vse(this.jwk,t,e,r)}}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Yg(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function rc(n,e=""){if(!Number.isSafeInteger(n)||n<0){const t=e&&`"${e}" `;throw new Error(`${t}expected integer >= 0, got ${n}`)}}function lt(n,e,t=""){const r=Yg(n),i=n==null?void 0:n.length,s=e!==void 0;if(!r||s&&i!==e){const o=t&&`"${t}" `,a=s?` of length ${e}`:"",c=r?`length=${i}`:`type=${typeof n}`;throw new Error(o+"expected Uint8Array"+a+", got "+c)}return n}function q3(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash must wrapped by utils.createHasher");rc(n.outputLen),rc(n.blockLen)}function Ym(n,e=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(e&&n.finished)throw new Error("Hash#digest() has already been called")}function Pse(n,e){lt(n,void 0,"digestInto() output");const t=e.outputLen;if(n.length<t)throw new Error('"digestInto() output" expected to be of length >='+t)}function wu(...n){for(let e=0;e<n.length;e++)n[e].fill(0)}function B0(n){return new DataView(n.buffer,n.byteOffset,n.byteLength)}function Wi(n,e){return n<<32-e|n>>>e}const K3=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Dse=Array.from({length:256},(n,e)=>e.toString(16).padStart(2,"0"));function of(n){if(lt(n),K3)return n.toHex();let e="";for(let t=0;t<n.length;t++)e+=Dse[n[t]];return e}const Ss={_0:48,_9:57,A:65,F:70,a:97,f:102};function y2(n){if(n>=Ss._0&&n<=Ss._9)return n-Ss._0;if(n>=Ss.A&&n<=Ss.F)return n-(Ss.A-10);if(n>=Ss.a&&n<=Ss.f)return n-(Ss.a-10)}function Sd(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);if(K3)return Uint8Array.fromHex(n);const e=n.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(t);for(let i=0,s=0;i<t;i++,s+=2){const o=y2(n.charCodeAt(s)),a=y2(n.charCodeAt(s+1));if(o===void 0||a===void 0){const c=n[s]+n[s+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+s)}r[i]=o*16+a}return r}function is(...n){let e=0;for(let r=0;r<n.length;r++){const i=n[r];lt(i),e+=i.length}const t=new Uint8Array(e);for(let r=0,i=0;r<n.length;r++){const s=n[r];t.set(s,i),i+=s.length}return t}function X3(n,e={}){const t=(i,s)=>n(s).update(i).digest(),r=n(void 0);return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=i=>n(i),Object.assign(t,e),Object.freeze(t)}function Zg(n=32){const e=typeof globalThis=="object"?globalThis.crypto:null;if(typeof(e==null?void 0:e.getRandomValues)!="function")throw new Error("crypto.getRandomValues must be defined");return e.getRandomValues(new Uint8Array(n))}const Y3=n=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,n])});function Rse(n,e,t){return n&e^~n&t}function Lse(n,e,t){return n&e^n&t^e&t}class Z3{constructor(e,t,r,i){h(this,"blockLen");h(this,"outputLen");h(this,"padOffset");h(this,"isLE");h(this,"buffer");h(this,"view");h(this,"finished",!1);h(this,"length",0);h(this,"pos",0);h(this,"destroyed",!1);this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=i,this.buffer=new Uint8Array(e),this.view=B0(this.buffer)}update(e){Ym(this),lt(e);const{view:t,buffer:r,blockLen:i}=this,s=e.length;for(let o=0;o<s;){const a=Math.min(i-this.pos,s-o);if(a===i){const c=B0(e);for(;i<=s-o;o+=i)this.process(c,o);continue}r.set(e.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===i&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Ym(this),Pse(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:i,isLE:s}=this;let{pos:o}=this;t[o++]=128,wu(this.buffer.subarray(o)),this.padOffset>i-o&&(this.process(r,0),o=0);for(let d=o;d<i;d++)t[d]=0;r.setBigUint64(i-8,BigInt(this.length*8),s),this.process(r,0);const a=B0(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen must be aligned to 32bit");const l=c/4,u=this.get();if(l>u.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<l;d++)a.setUint32(4*d,u[d],s)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:i,finished:s,destroyed:o,pos:a}=this;return e.destroyed=o,e.finished=s,e.length=i,e.pos=a,i%t&&e.buffer.set(r),e}clone(){return this._cloneInto()}}const xo=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Nn=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),yp=BigInt(2**32-1),b2=BigInt(32);function Ose(n,e=!1){return e?{h:Number(n&yp),l:Number(n>>b2&yp)}:{h:Number(n>>b2&yp)|0,l:Number(n&yp)|0}}function Nse(n,e=!1){const t=n.length;let r=new Uint32Array(t),i=new Uint32Array(t);for(let s=0;s<t;s++){const{h:o,l:a}=Ose(n[s],e);[r[s],i[s]]=[o,a]}return[r,i]}const w2=(n,e,t)=>n>>>t,v2=(n,e,t)=>n<<32-t|e>>>t,Hc=(n,e,t)=>n>>>t|e<<32-t,Gc=(n,e,t)=>n<<32-t|e>>>t,bp=(n,e,t)=>n<<64-t|e>>>t-32,wp=(n,e,t)=>n>>>t-32|e<<64-t;function xs(n,e,t,r){const i=(e>>>0)+(r>>>0);return{h:n+t+(i/2**32|0)|0,l:i|0}}const Use=(n,e,t)=>(n>>>0)+(e>>>0)+(t>>>0),Bse=(n,e,t,r)=>e+t+r+(n/2**32|0)|0,kse=(n,e,t,r)=>(n>>>0)+(e>>>0)+(t>>>0)+(r>>>0),$se=(n,e,t,r,i)=>e+t+r+i+(n/2**32|0)|0,Fse=(n,e,t,r,i)=>(n>>>0)+(e>>>0)+(t>>>0)+(r>>>0)+(i>>>0),zse=(n,e,t,r,i,s)=>e+t+r+i+s+(n/2**32|0)|0,Vse=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),To=new Uint32Array(64);class Hse extends Z3{constructor(e){super(64,e,8,!1)}get(){const{A:e,B:t,C:r,D:i,E:s,F:o,G:a,H:c}=this;return[e,t,r,i,s,o,a,c]}set(e,t,r,i,s,o,a,c){this.A=e|0,this.B=t|0,this.C=r|0,this.D=i|0,this.E=s|0,this.F=o|0,this.G=a|0,this.H=c|0}process(e,t){for(let d=0;d<16;d++,t+=4)To[d]=e.getUint32(t,!1);for(let d=16;d<64;d++){const f=To[d-15],p=To[d-2],g=Wi(f,7)^Wi(f,18)^f>>>3,b=Wi(p,17)^Wi(p,19)^p>>>10;To[d]=b+To[d-7]+g+To[d-16]|0}let{A:r,B:i,C:s,D:o,E:a,F:c,G:l,H:u}=this;for(let d=0;d<64;d++){const f=Wi(a,6)^Wi(a,11)^Wi(a,25),p=u+f+Rse(a,c,l)+Vse[d]+To[d]|0,b=(Wi(r,2)^Wi(r,13)^Wi(r,22))+Lse(r,i,s)|0;u=l,l=c,c=a,a=o+p|0,o=s,s=i,i=r,r=p+b|0}r=r+this.A|0,i=i+this.B|0,s=s+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,l=l+this.G|0,u=u+this.H|0,this.set(r,i,s,o,a,c,l,u)}roundClean(){wu(To)}destroy(){this.set(0,0,0,0,0,0,0,0),wu(this.buffer)}}class Gse extends Hse{constructor(){super(32);h(this,"A",xo[0]|0);h(this,"B",xo[1]|0);h(this,"C",xo[2]|0);h(this,"D",xo[3]|0);h(this,"E",xo[4]|0);h(this,"F",xo[5]|0);h(this,"G",xo[6]|0);h(this,"H",xo[7]|0)}}const j3=Nse(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(n=>BigInt(n))),Wse=j3[0],qse=j3[1],Ao=new Uint32Array(80),Mo=new Uint32Array(80);class Kse extends Z3{constructor(e){super(128,e,16,!1)}get(){const{Ah:e,Al:t,Bh:r,Bl:i,Ch:s,Cl:o,Dh:a,Dl:c,Eh:l,El:u,Fh:d,Fl:f,Gh:p,Gl:g,Hh:b,Hl:m}=this;return[e,t,r,i,s,o,a,c,l,u,d,f,p,g,b,m]}set(e,t,r,i,s,o,a,c,l,u,d,f,p,g,b,m){this.Ah=e|0,this.Al=t|0,this.Bh=r|0,this.Bl=i|0,this.Ch=s|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=l|0,this.El=u|0,this.Fh=d|0,this.Fl=f|0,this.Gh=p|0,this.Gl=g|0,this.Hh=b|0,this.Hl=m|0}process(e,t){for(let w=0;w<16;w++,t+=4)Ao[w]=e.getUint32(t),Mo[w]=e.getUint32(t+=4);for(let w=16;w<80;w++){const x=Ao[w-15]|0,M=Mo[w-15]|0,A=Hc(x,M,1)^Hc(x,M,8)^w2(x,M,7),C=Gc(x,M,1)^Gc(x,M,8)^v2(x,M,7),R=Ao[w-2]|0,_=Mo[w-2]|0,T=Hc(R,_,19)^bp(R,_,61)^w2(R,_,6),F=Gc(R,_,19)^wp(R,_,61)^v2(R,_,6),k=kse(C,F,Mo[w-7],Mo[w-16]),z=$se(k,A,T,Ao[w-7],Ao[w-16]);Ao[w]=z|0,Mo[w]=k|0}let{Ah:r,Al:i,Bh:s,Bl:o,Ch:a,Cl:c,Dh:l,Dl:u,Eh:d,El:f,Fh:p,Fl:g,Gh:b,Gl:m,Hh:y,Hl:E}=this;for(let w=0;w<80;w++){const x=Hc(d,f,14)^Hc(d,f,18)^bp(d,f,41),M=Gc(d,f,14)^Gc(d,f,18)^wp(d,f,41),A=d&p^~d&b,C=f&g^~f&m,R=Fse(E,M,C,qse[w],Mo[w]),_=zse(R,y,x,A,Wse[w],Ao[w]),T=R|0,F=Hc(r,i,28)^bp(r,i,34)^bp(r,i,39),k=Gc(r,i,28)^wp(r,i,34)^wp(r,i,39),z=r&s^r&a^s&a,v=i&o^i&c^o&c;y=b|0,E=m|0,b=p|0,m=g|0,p=d|0,g=f|0,{h:d,l:f}=xs(l|0,u|0,_|0,T|0),l=a|0,u=c|0,a=s|0,c=o|0,s=r|0,o=i|0;const S=Use(T,k,v);r=Bse(S,_,F,z),i=S|0}({h:r,l:i}=xs(this.Ah|0,this.Al|0,r|0,i|0)),{h:s,l:o}=xs(this.Bh|0,this.Bl|0,s|0,o|0),{h:a,l:c}=xs(this.Ch|0,this.Cl|0,a|0,c|0),{h:l,l:u}=xs(this.Dh|0,this.Dl|0,l|0,u|0),{h:d,l:f}=xs(this.Eh|0,this.El|0,d|0,f|0),{h:p,l:g}=xs(this.Fh|0,this.Fl|0,p|0,g|0),{h:b,l:m}=xs(this.Gh|0,this.Gl|0,b|0,m|0),{h:y,l:E}=xs(this.Hh|0,this.Hl|0,y|0,E|0),this.set(r,i,s,o,a,c,l,u,d,f,p,g,b,m,y,E)}roundClean(){wu(Ao,Mo)}destroy(){wu(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class Xse extends Kse{constructor(){super(64);h(this,"Ah",Nn[0]|0);h(this,"Al",Nn[1]|0);h(this,"Bh",Nn[2]|0);h(this,"Bl",Nn[3]|0);h(this,"Ch",Nn[4]|0);h(this,"Cl",Nn[5]|0);h(this,"Dh",Nn[6]|0);h(this,"Dl",Nn[7]|0);h(this,"Eh",Nn[8]|0);h(this,"El",Nn[9]|0);h(this,"Fh",Nn[10]|0);h(this,"Fl",Nn[11]|0);h(this,"Gh",Nn[12]|0);h(this,"Gl",Nn[13]|0);h(this,"Hh",Nn[14]|0);h(this,"Hl",Nn[15]|0)}}const J3=X3(()=>new Gse,Y3(1)),Yse=X3(()=>new Xse,Y3(3));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const gS=BigInt(0),f_=BigInt(1);function ic(n,e=""){if(typeof n!="boolean"){const t=e&&`"${e}" `;throw new Error(t+"expected boolean, got type="+typeof n)}return n}function Q3(n){if(typeof n=="bigint"){if(!Wp(n))throw new Error("positive bigint expected, got "+n)}else rc(n);return n}function vp(n){const e=Q3(n).toString(16);return e.length&1?"0"+e:e}function eO(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return n===""?gS:BigInt("0x"+n)}function jg(n){return eO(of(n))}function xd(n){return eO(of(p_(lt(n)).reverse()))}function yS(n,e){rc(e),n=Q3(n);const t=Sd(n.toString(16).padStart(e*2,"0"));if(t.length!==e)throw new Error("number too large");return t}function tO(n,e){return yS(n,e).reverse()}function p_(n){return Uint8Array.from(n)}const Wp=n=>typeof n=="bigint"&&gS<=n;function Zse(n,e,t){return Wp(n)&&Wp(e)&&Wp(t)&&e<=n&&n<t}function m_(n,e,t,r){if(!Zse(e,t,r))throw new Error("expected valid "+n+": "+t+" <= n < "+r+", got "+e)}function jse(n){let e;for(e=0;n>gS;n>>=f_,e+=1);return e}const bS=n=>(f_<<BigInt(n))-f_;function Jse(n,e,t){if(rc(n,"hashLen"),rc(e,"qByteLen"),typeof t!="function")throw new Error("hmacFn must be a function");const r=m=>new Uint8Array(m),i=Uint8Array.of(),s=Uint8Array.of(0),o=Uint8Array.of(1),a=1e3;let c=r(n),l=r(n),u=0;const d=()=>{c.fill(1),l.fill(0),u=0},f=(...m)=>t(l,is(c,...m)),p=(m=i)=>{l=f(s,m),c=f(),m.length!==0&&(l=f(o,m),c=f())},g=()=>{if(u++>=a)throw new Error("drbg: tried max amount of iterations");let m=0;const y=[];for(;m<e;){c=f();const E=c.slice();y.push(E),m+=c.length}return is(...y)};return(m,y)=>{d(),p(m);let E;for(;!(E=y(g()));)p();return d(),E}}function af(n,e={},t={}){if(!n||typeof n!="object")throw new Error("expected valid options object");function r(s,o,a){const c=n[s];if(a&&c===void 0)return;const l=typeof c;if(l!==o||c===null)throw new Error(`param "${s}" is invalid: expected ${o}, got ${l}`)}const i=(s,o)=>Object.entries(s).forEach(([a,c])=>r(a,c,o));i(e,!1),i(t,!0)}function Zm(n){const e=new WeakMap;return(t,...r)=>{const i=e.get(t);if(i!==void 0)return i;const s=n(t,...r);return e.set(t,s),s}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const vr=BigInt(0),An=BigInt(1),Da=BigInt(2),nO=BigInt(3),rO=BigInt(4),iO=BigInt(5),Qse=BigInt(7),sO=BigInt(8),eoe=BigInt(9),oO=BigInt(16);function tn(n,e){const t=n%e;return t>=vr?t:e+t}function Wt(n,e,t){let r=n;for(;e-- >vr;)r*=r,r%=t;return r}function _2(n,e){if(n===vr)throw new Error("invert: expected non-zero number");if(e<=vr)throw new Error("invert: expected positive modulus, got "+e);let t=tn(n,e),r=e,i=vr,s=An;for(;t!==vr;){const a=r/t,c=r%t,l=i-s*a;r=t,t=c,i=s,s=l}if(r!==An)throw new Error("invert: does not exist");return tn(i,e)}function wS(n,e,t){if(!n.eql(n.sqr(e),t))throw new Error("Cannot find square root")}function aO(n,e){const t=(n.ORDER+An)/rO,r=n.pow(e,t);return wS(n,r,e),r}function toe(n,e){const t=(n.ORDER-iO)/sO,r=n.mul(e,Da),i=n.pow(r,t),s=n.mul(e,i),o=n.mul(n.mul(s,Da),i),a=n.mul(s,n.sub(o,n.ONE));return wS(n,a,e),a}function noe(n){const e=Jg(n),t=cO(n),r=t(e,e.neg(e.ONE)),i=t(e,r),s=t(e,e.neg(r)),o=(n+Qse)/oO;return(a,c)=>{let l=a.pow(c,o),u=a.mul(l,r);const d=a.mul(l,i),f=a.mul(l,s),p=a.eql(a.sqr(u),c),g=a.eql(a.sqr(d),c);l=a.cmov(l,u,p),u=a.cmov(f,d,g);const b=a.eql(a.sqr(u),c),m=a.cmov(l,u,b);return wS(a,m,c),m}}function cO(n){if(n<nO)throw new Error("sqrt is not defined for small field");let e=n-An,t=0;for(;e%Da===vr;)e/=Da,t++;let r=Da;const i=Jg(n);for(;E2(i,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return aO;let s=i.pow(r,e);const o=(e+An)/Da;return function(c,l){if(c.is0(l))return l;if(E2(c,l)!==1)throw new Error("Cannot find square root");let u=t,d=c.mul(c.ONE,s),f=c.pow(l,e),p=c.pow(l,o);for(;!c.eql(f,c.ONE);){if(c.is0(f))return c.ZERO;let g=1,b=c.sqr(f);for(;!c.eql(b,c.ONE);)if(g++,b=c.sqr(b),g===u)throw new Error("Cannot find square root");const m=An<<BigInt(u-g-1),y=c.pow(d,m);u=g,d=c.sqr(y),f=c.mul(f,d),p=c.mul(p,y)}return p}}function roe(n){return n%rO===nO?aO:n%sO===iO?toe:n%oO===eoe?noe(n):cO(n)}const ioe=(n,e)=>(tn(n,e)&An)===An,soe=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ooe(n){const e={ORDER:"bigint",BYTES:"number",BITS:"number"},t=soe.reduce((r,i)=>(r[i]="function",r),e);return af(n,t),n}function aoe(n,e,t){if(t<vr)throw new Error("invalid exponent, negatives unsupported");if(t===vr)return n.ONE;if(t===An)return e;let r=n.ONE,i=e;for(;t>vr;)t&An&&(r=n.mul(r,i)),i=n.sqr(i),t>>=An;return r}function lO(n,e,t=!1){const r=new Array(e.length).fill(t?n.ZERO:void 0),i=e.reduce((o,a,c)=>n.is0(a)?o:(r[c]=o,n.mul(o,a)),n.ONE),s=n.inv(i);return e.reduceRight((o,a,c)=>n.is0(a)?o:(r[c]=n.mul(o,r[c]),n.mul(o,a)),s),r}function E2(n,e){const t=(n.ORDER-An)/Da,r=n.pow(e,t),i=n.eql(r,n.ONE),s=n.eql(r,n.ZERO),o=n.eql(r,n.neg(n.ONE));if(!i&&!s&&!o)throw new Error("invalid Legendre symbol result");return i?1:s?0:-1}function coe(n,e){e!==void 0&&rc(e);const t=e!==void 0?e:n.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}class loe{constructor(e,t={}){h(this,"ORDER");h(this,"BITS");h(this,"BYTES");h(this,"isLE");h(this,"ZERO",vr);h(this,"ONE",An);h(this,"_lengths");h(this,"_sqrt");h(this,"_mod");var o;if(e<=vr)throw new Error("invalid field: expected ORDER > 0, got "+e);let r;this.isLE=!1,t!=null&&typeof t=="object"&&(typeof t.BITS=="number"&&(r=t.BITS),typeof t.sqrt=="function"&&(this.sqrt=t.sqrt),typeof t.isLE=="boolean"&&(this.isLE=t.isLE),t.allowedLengths&&(this._lengths=(o=t.allowedLengths)==null?void 0:o.slice()),typeof t.modFromBytes=="boolean"&&(this._mod=t.modFromBytes));const{nBitLength:i,nByteLength:s}=coe(e,r);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=e,this.BITS=i,this.BYTES=s,this._sqrt=void 0,Object.preventExtensions(this)}create(e){return tn(e,this.ORDER)}isValid(e){if(typeof e!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof e);return vr<=e&&e<this.ORDER}is0(e){return e===vr}isValidNot0(e){return!this.is0(e)&&this.isValid(e)}isOdd(e){return(e&An)===An}neg(e){return tn(-e,this.ORDER)}eql(e,t){return e===t}sqr(e){return tn(e*e,this.ORDER)}add(e,t){return tn(e+t,this.ORDER)}sub(e,t){return tn(e-t,this.ORDER)}mul(e,t){return tn(e*t,this.ORDER)}pow(e,t){return aoe(this,e,t)}div(e,t){return tn(e*_2(t,this.ORDER),this.ORDER)}sqrN(e){return e*e}addN(e,t){return e+t}subN(e,t){return e-t}mulN(e,t){return e*t}inv(e){return _2(e,this.ORDER)}sqrt(e){return this._sqrt||(this._sqrt=roe(this.ORDER)),this._sqrt(this,e)}toBytes(e){return this.isLE?tO(e,this.BYTES):yS(e,this.BYTES)}fromBytes(e,t=!1){lt(e);const{_lengths:r,BYTES:i,isLE:s,ORDER:o,_mod:a}=this;if(r){if(!r.includes(e.length)||e.length>i)throw new Error("Field.fromBytes: expected "+r+" bytes, got "+e.length);const l=new Uint8Array(i);l.set(e,s?0:l.length-e.length),e=l}if(e.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+e.length);let c=s?xd(e):jg(e);if(a&&(c=tn(c,o)),!t&&!this.isValid(c))throw new Error("invalid field element: outside of range 0..ORDER");return c}invertBatch(e){return lO(this,e)}cmov(e,t,r){return r?t:e}}function Jg(n,e={}){return new loe(n,e)}function uO(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const e=n.toString(2).length;return Math.ceil(e/8)}function hO(n){const e=uO(n);return e+Math.ceil(e/2)}function uoe(n,e,t=!1){lt(n);const r=n.length,i=uO(e),s=hO(e);if(r<16||r<s||r>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+r);const o=t?xd(n):jg(n),a=tn(o,e-An)+An;return t?tO(a,i):yS(a,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const vu=BigInt(0),Ra=BigInt(1);function jm(n,e){const t=e.negate();return n?t:e}function Wh(n,e){const t=lO(n.Fp,e.map(r=>r.Z));return e.map((r,i)=>n.fromAffine(r.toAffine(t[i])))}function dO(n,e){if(!Number.isSafeInteger(n)||n<=0||n>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+n)}function k0(n,e){dO(n,e);const t=Math.ceil(e/n)+1,r=2**(n-1),i=2**n,s=bS(n),o=BigInt(n);return{windows:t,windowSize:r,mask:s,maxNumber:i,shiftBy:o}}function S2(n,e,t){const{windowSize:r,mask:i,maxNumber:s,shiftBy:o}=t;let a=Number(n&i),c=n>>o;a>r&&(a-=s,c+=Ra);const l=e*r,u=l+Math.abs(a)-1,d=a===0,f=a<0,p=e%2!==0;return{nextN:c,offset:u,isZero:d,isNeg:f,isNegF:p,offsetF:l}}const $0=new WeakMap,fO=new WeakMap;function F0(n){return fO.get(n)||1}function x2(n){if(n!==vu)throw new Error("invalid wNAF")}class pO{constructor(e,t){h(this,"BASE");h(this,"ZERO");h(this,"Fn");h(this,"bits");this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=t}_unsafeLadder(e,t,r=this.ZERO){let i=e;for(;t>vu;)t&Ra&&(r=r.add(i)),i=i.double(),t>>=Ra;return r}precomputeWindow(e,t){const{windows:r,windowSize:i}=k0(t,this.bits),s=[];let o=e,a=o;for(let c=0;c<r;c++){a=o,s.push(a);for(let l=1;l<i;l++)a=a.add(o),s.push(a);o=a.double()}return s}wNAF(e,t,r){if(!this.Fn.isValid(r))throw new Error("invalid scalar");let i=this.ZERO,s=this.BASE;const o=k0(e,this.bits);for(let a=0;a<o.windows;a++){const{nextN:c,offset:l,isZero:u,isNeg:d,isNegF:f,offsetF:p}=S2(r,a,o);r=c,u?s=s.add(jm(f,t[p])):i=i.add(jm(d,t[l]))}return x2(r),{p:i,f:s}}wNAFUnsafe(e,t,r,i=this.ZERO){const s=k0(e,this.bits);for(let o=0;o<s.windows&&r!==vu;o++){const{nextN:a,offset:c,isZero:l,isNeg:u}=S2(r,o,s);if(r=a,!l){const d=t[c];i=i.add(u?d.negate():d)}}return x2(r),i}getPrecomputes(e,t,r){let i=$0.get(t);return i||(i=this.precomputeWindow(t,e),e!==1&&(typeof r=="function"&&(i=r(i)),$0.set(t,i))),i}cached(e,t,r){const i=F0(e);return this.wNAF(i,this.getPrecomputes(i,e,r),t)}unsafe(e,t,r,i){const s=F0(e);return s===1?this._unsafeLadder(e,t,i):this.wNAFUnsafe(s,this.getPrecomputes(s,e,r),t,i)}createCache(e,t){dO(t,this.bits),fO.set(e,t),$0.delete(e)}hasCache(e){return F0(e)!==1}}function hoe(n,e,t,r){let i=e,s=n.ZERO,o=n.ZERO;for(;t>vu||r>vu;)t&Ra&&(s=s.add(i)),r&Ra&&(o=o.add(i)),i=i.double(),t>>=Ra,r>>=Ra;return{p1:s,p2:o}}function T2(n,e,t){if(e){if(e.ORDER!==n)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return ooe(e),e}else return Jg(n,{isLE:t})}function mO(n,e,t={},r){if(r===void 0&&(r=n==="edwards"),!e||typeof e!="object")throw new Error(`expected valid ${n} CURVE object`);for(const c of["p","n","h"]){const l=e[c];if(!(typeof l=="bigint"&&l>vu))throw new Error(`CURVE.${c} must be positive bigint`)}const i=T2(e.p,t.Fp,r),s=T2(e.n,t.Fn,r),a=["Gx","Gy","a",n==="weierstrass"?"b":"d"];for(const c of a)if(!i.isValid(e[c]))throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);return e=Object.freeze(Object.assign({},e)),{CURVE:e,Fp:i,Fn:s}}function gO(n,e){return function(r){const i=n(r);return{secretKey:i,publicKey:e(i)}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Co=BigInt(0),fn=BigInt(1),z0=BigInt(2),doe=BigInt(8);function foe(n,e,t,r){const i=n.sqr(t),s=n.sqr(r),o=n.add(n.mul(e.a,i),s),a=n.add(n.ONE,n.mul(e.d,n.mul(i,s)));return n.eql(o,a)}function poe(n,e={}){const t=mO("edwards",n,e,e.FpFnLE),{Fp:r,Fn:i}=t;let s=t.CURVE;const{h:o}=s;af(e,{},{uvRatio:"function"});const a=z0<<BigInt(i.BYTES*8)-fn,c=y=>r.create(y),l=e.uvRatio||((y,E)=>{try{return{isValid:!0,value:r.sqrt(r.div(y,E))}}catch{return{isValid:!1,value:Co}}});if(!foe(r,s,s.Gx,s.Gy))throw new Error("bad curve params: generator point");function u(y,E,w=!1){const x=w?fn:Co;return m_("coordinate "+y,E,x,a),E}function d(y){if(!(y instanceof g))throw new Error("EdwardsPoint expected")}const f=Zm((y,E)=>{const{X:w,Y:x,Z:M}=y,A=y.is0();E==null&&(E=A?doe:r.inv(M));const C=c(w*E),R=c(x*E),_=r.mul(M,E);if(A)return{x:Co,y:fn};if(_!==fn)throw new Error("invZ was invalid");return{x:C,y:R}}),p=Zm(y=>{const{a:E,d:w}=s;if(y.is0())throw new Error("bad point: ZERO");const{X:x,Y:M,Z:A,T:C}=y,R=c(x*x),_=c(M*M),T=c(A*A),F=c(T*T),k=c(R*E),z=c(T*c(k+_)),v=c(F+c(w*c(R*_)));if(z!==v)throw new Error("bad point: equation left != right (1)");const S=c(x*M),P=c(A*C);if(S!==P)throw new Error("bad point: equation left != right (2)");return!0}),m=class m{constructor(E,w,x,M){h(this,"X");h(this,"Y");h(this,"Z");h(this,"T");this.X=u("x",E),this.Y=u("y",w),this.Z=u("z",x,!0),this.T=u("t",M),Object.freeze(this)}static CURVE(){return s}static fromAffine(E){if(E instanceof m)throw new Error("extended point not allowed");const{x:w,y:x}=E||{};return u("x",w),u("y",x),new m(w,x,fn,c(w*x))}static fromBytes(E,w=!1){const x=r.BYTES,{a:M,d:A}=s;E=p_(lt(E,x,"point")),ic(w,"zip215");const C=p_(E),R=E[x-1];C[x-1]=R&-129;const _=xd(C),T=w?a:r.ORDER;m_("point.y",_,Co,T);const F=c(_*_),k=c(F-fn),z=c(A*F-M);let{isValid:v,value:S}=l(k,z);if(!v)throw new Error("bad point: invalid y coordinate");const P=(S&fn)===fn,U=(R&128)!==0;if(!w&&S===Co&&U)throw new Error("bad point: x=0 and x_0=1");return U!==P&&(S=c(-S)),m.fromAffine({x:S,y:_})}static fromHex(E,w=!1){return m.fromBytes(Sd(E),w)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(E=8,w=!0){return b.createCache(this,E),w||this.multiply(z0),this}assertValidity(){p(this)}equals(E){d(E);const{X:w,Y:x,Z:M}=this,{X:A,Y:C,Z:R}=E,_=c(w*R),T=c(A*M),F=c(x*R),k=c(C*M);return _===T&&F===k}is0(){return this.equals(m.ZERO)}negate(){return new m(c(-this.X),this.Y,this.Z,c(-this.T))}double(){const{a:E}=s,{X:w,Y:x,Z:M}=this,A=c(w*w),C=c(x*x),R=c(z0*c(M*M)),_=c(E*A),T=w+x,F=c(c(T*T)-A-C),k=_+C,z=k-R,v=_-C,S=c(F*z),P=c(k*v),U=c(F*v),B=c(z*k);return new m(S,P,B,U)}add(E){d(E);const{a:w,d:x}=s,{X:M,Y:A,Z:C,T:R}=this,{X:_,Y:T,Z:F,T:k}=E,z=c(M*_),v=c(A*T),S=c(R*x*k),P=c(C*F),U=c((M+A)*(_+T)-z-v),B=P-S,O=P+S,V=c(v-w*z),$=c(U*B),W=c(O*V),H=c(U*V),Y=c(B*O);return new m($,W,Y,H)}subtract(E){return this.add(E.negate())}multiply(E){if(!i.isValidNot0(E))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:w,f:x}=b.cached(this,E,M=>Wh(m,M));return Wh(m,[w,x])[0]}multiplyUnsafe(E,w=m.ZERO){if(!i.isValid(E))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return E===Co?m.ZERO:this.is0()||E===fn?this:b.unsafe(this,E,x=>Wh(m,x),w)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}isTorsionFree(){return b.unsafe(this,s.n).is0()}toAffine(E){return f(this,E)}clearCofactor(){return o===fn?this:this.multiplyUnsafe(o)}toBytes(){const{x:E,y:w}=this.toAffine(),x=r.toBytes(w);return x[x.length-1]|=E&fn?128:0,x}toHex(){return of(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}};h(m,"BASE",new m(s.Gx,s.Gy,fn,c(s.Gx*s.Gy))),h(m,"ZERO",new m(Co,fn,fn,Co)),h(m,"Fp",r),h(m,"Fn",i);let g=m;const b=new pO(g,i.BITS);return g.BASE.precompute(8),g}function moe(n,e,t={}){if(typeof e!="function")throw new Error('"hash" function param is required');af(t,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:r}=t,{BASE:i,Fp:s,Fn:o}=n,a=t.randomBytes||Zg,c=t.adjustScalarBytes||(R=>R),l=t.domain||((R,_,T)=>{if(ic(T,"phflag"),_.length||T)throw new Error("Contexts/pre-hash are not supported");return R});function u(R){return o.create(xd(R))}function d(R){const _=w.secretKey;lt(R,w.secretKey,"secretKey");const T=lt(e(R),2*_,"hashedSecretKey"),F=c(T.slice(0,_)),k=T.slice(_,2*_),z=u(F);return{head:F,prefix:k,scalar:z}}function f(R){const{head:_,prefix:T,scalar:F}=d(R),k=i.multiply(F),z=k.toBytes();return{head:_,prefix:T,scalar:F,point:k,pointBytes:z}}function p(R){return f(R).pointBytes}function g(R=Uint8Array.of(),..._){const T=is(..._);return u(e(l(T,lt(R,void 0,"context"),!!r)))}function b(R,_,T={}){R=lt(R,void 0,"message"),r&&(R=r(R));const{prefix:F,scalar:k,pointBytes:z}=f(_),v=g(T.context,F,R),S=i.multiply(v).toBytes(),P=g(T.context,S,z,R),U=o.create(v+P*k);if(!o.isValid(U))throw new Error("sign failed: invalid s");const B=is(S,o.toBytes(U));return lt(B,w.signature,"result")}const m={zip215:!0};function y(R,_,T,F=m){const{context:k,zip215:z}=F,v=w.signature;R=lt(R,v,"signature"),_=lt(_,void 0,"message"),T=lt(T,w.publicKey,"publicKey"),z!==void 0&&ic(z,"zip215"),r&&(_=r(_));const S=v/2,P=R.subarray(0,S),U=xd(R.subarray(S,v));let B,O,V;try{B=n.fromBytes(T,z),O=n.fromBytes(P,z),V=i.multiplyUnsafe(U)}catch{return!1}if(!z&&B.isSmallOrder())return!1;const $=g(k,O.toBytes(),B.toBytes(),_);return O.add(B.multiplyUnsafe($)).subtract(V).clearCofactor().is0()}const E=s.BYTES,w={secretKey:E,publicKey:E,signature:2*E,seed:E};function x(R=a(w.seed)){return lt(R,w.seed,"seed")}function M(R){return Yg(R)&&R.length===o.BYTES}function A(R,_){try{return!!n.fromBytes(R,_)}catch{return!1}}const C={getExtendedPublicKey:f,randomSecretKey:x,isValidSecretKey:M,isValidPublicKey:A,toMontgomery(R){const{y:_}=n.fromBytes(R),T=w.publicKey,F=T===32;if(!F&&T!==57)throw new Error("only defined for 25519 and 448");const k=F?s.div(fn+_,fn-_):s.div(_-fn,_+fn);return s.toBytes(k)},toMontgomerySecret(R){const _=w.secretKey;lt(R,_);const T=e(R.subarray(0,_));return c(T).subarray(0,_)}};return Object.freeze({keygen:gO(x,p),getPublicKey:p,sign:b,verify:y,utils:C,Point:n,lengths:w})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const goe=BigInt(1),A2=BigInt(2),yoe=BigInt(5),boe=BigInt(8),vS=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),woe={p:vS,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:boe,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function voe(n){const e=BigInt(10),t=BigInt(20),r=BigInt(40),i=BigInt(80),s=vS,a=n*n%s*n%s,c=Wt(a,A2,s)*a%s,l=Wt(c,goe,s)*n%s,u=Wt(l,yoe,s)*l%s,d=Wt(u,e,s)*u%s,f=Wt(d,t,s)*d%s,p=Wt(f,r,s)*f%s,g=Wt(p,i,s)*p%s,b=Wt(g,i,s)*p%s,m=Wt(b,e,s)*u%s;return{pow_p_5_8:Wt(m,A2,s)*n%s,b2:a}}function _oe(n){return n[0]&=248,n[31]&=127,n[31]|=64,n}const M2=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function Eoe(n,e){const t=vS,r=tn(e*e*e,t),i=tn(r*r*e,t),s=voe(n*i).pow_p_5_8;let o=tn(n*r*s,t);const a=tn(e*o*o,t),c=o,l=tn(o*M2,t),u=a===n,d=a===tn(-n,t),f=a===tn(-n*M2,t);return u&&(o=c),(d||f)&&(o=l),ioe(o,t)&&(o=tn(-o,t)),{isValid:u||d,value:o}}const Soe=poe(woe,{uvRatio:Eoe});function xoe(n){return moe(Soe,Yse,Object.assign({adjustScalarBytes:_oe},n))}const Toe=xoe({});class C2 extends Error{constructor(e="An error occurred while verifying a message"){super(e),this.name="VerificationError"}}class Aoe extends Error{constructor(e="Missing Web Crypto API"){super(e),this.name="WebCryptoMissingError"}}const Td={get(n=globalThis){const e=n.crypto;if((e==null?void 0:e.subtle)==null)throw new Aoe("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return e}},yO=32;let V0;const Moe=(async()=>{try{return await Td.get().subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),!0}catch{return!1}})();async function Coe(n,e,t){if(n.buffer instanceof ArrayBuffer){const r=await Td.get().subtle.importKey("raw",n.buffer,{name:"Ed25519"},!1,["verify"]);return await Td.get().subtle.verify({name:"Ed25519"},r,e,t instanceof Uint8Array?t:t.subarray())}throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys")}function Ioe(n,e,t){return Toe.verify(e,t instanceof Uint8Array?t:t.subarray(),n)}async function Poe(n,e,t){return V0==null&&(V0=await Moe),V0?Coe(n,e,t):Ioe(n,e,t)}function bO(n){return n==null?!1:typeof n.then=="function"&&typeof n.catch=="function"&&typeof n.finally=="function"}class Doe{constructor(e){h(this,"type","Ed25519");h(this,"raw");this.raw=vO(e,yO)}toMultihash(){return rf.digest(cf(this))}toCID(){return Gt.createV1(114,this.toMultihash())}toString(){return hr.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:nc(this.raw,e.raw)}verify(e,t,r){var s;(s=r==null?void 0:r.signal)==null||s.throwIfAborted();const i=Poe(this.raw,t,e);return bO(i)?i.then(o=>{var a;return(a=r==null?void 0:r.signal)==null||a.throwIfAborted(),o}):i}}function wO(n){return n=vO(n,yO),new Doe(n)}function vO(n,e){if(n=Uint8Array.from(n??[]),n.length!==e)throw new dc(`Key must be a Uint8Array of length ${e}, got ${n.length}`);return n}const Roe=Math.pow(2,7),Loe=Math.pow(2,14),Ooe=Math.pow(2,21),_S=Math.pow(2,28),ES=Math.pow(2,35),SS=Math.pow(2,42),xS=Math.pow(2,49),pt=128,jn=127;function Vu(n){if(n<Roe)return 1;if(n<Loe)return 2;if(n<Ooe)return 3;if(n<_S)return 4;if(n<ES)return 5;if(n<SS)return 6;if(n<xS)return 7;if(Number.MAX_SAFE_INTEGER!=null&&n>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function _O(n,e,t=0){switch(Vu(n)){case 8:e[t++]=n&255|pt,n/=128;case 7:e[t++]=n&255|pt,n/=128;case 6:e[t++]=n&255|pt,n/=128;case 5:e[t++]=n&255|pt,n/=128;case 4:e[t++]=n&255|pt,n>>>=7;case 3:e[t++]=n&255|pt,n>>>=7;case 2:e[t++]=n&255|pt,n>>>=7;case 1:{e[t++]=n&255,n>>>=7;break}default:throw new Error("unreachable")}return e}function Noe(n,e,t=0){switch(Vu(n)){case 8:e.set(t++,n&255|pt),n/=128;case 7:e.set(t++,n&255|pt),n/=128;case 6:e.set(t++,n&255|pt),n/=128;case 5:e.set(t++,n&255|pt),n/=128;case 4:e.set(t++,n&255|pt),n>>>=7;case 3:e.set(t++,n&255|pt),n>>>=7;case 2:e.set(t++,n&255|pt),n>>>=7;case 1:{e.set(t++,n&255),n>>>=7;break}default:throw new Error("unreachable")}return e}function EO(n,e){let t=n[e],r=0;if(r+=t&jn,t<pt||(t=n[e+1],r+=(t&jn)<<7,t<pt)||(t=n[e+2],r+=(t&jn)<<14,t<pt)||(t=n[e+3],r+=(t&jn)<<21,t<pt)||(t=n[e+4],r+=(t&jn)*_S,t<pt)||(t=n[e+5],r+=(t&jn)*ES,t<pt)||(t=n[e+6],r+=(t&jn)*SS,t<pt)||(t=n[e+7],r+=(t&jn)*xS,t<pt))return r;throw new RangeError("Could not decode varint")}function Uoe(n,e){let t=n.get(e),r=0;if(r+=t&jn,t<pt||(t=n.get(e+1),r+=(t&jn)<<7,t<pt)||(t=n.get(e+2),r+=(t&jn)<<14,t<pt)||(t=n.get(e+3),r+=(t&jn)<<21,t<pt)||(t=n.get(e+4),r+=(t&jn)*_S,t<pt)||(t=n.get(e+5),r+=(t&jn)*ES,t<pt)||(t=n.get(e+6),r+=(t&jn)*SS,t<pt)||(t=n.get(e+7),r+=(t&jn)*xS,t<pt))return r;throw new RangeError("Could not decode varint")}function Boe(n,e,t=0){return e==null&&(e=ea(Vu(n))),e instanceof Uint8Array?_O(n,e,t):Noe(n,e,t)}function koe(n,e=0){return n instanceof Uint8Array?EO(n,e):Uoe(n,e)}const TS=new Float32Array([-0]),Fo=new Uint8Array(TS.buffer);function $oe(n,e,t){TS[0]=n,e[t]=Fo[0],e[t+1]=Fo[1],e[t+2]=Fo[2],e[t+3]=Fo[3]}function Foe(n,e){return Fo[0]=n[e],Fo[1]=n[e+1],Fo[2]=n[e+2],Fo[3]=n[e+3],TS[0]}const AS=new Float64Array([-0]),Jn=new Uint8Array(AS.buffer);function zoe(n,e,t){AS[0]=n,e[t]=Jn[0],e[t+1]=Jn[1],e[t+2]=Jn[2],e[t+3]=Jn[3],e[t+4]=Jn[4],e[t+5]=Jn[5],e[t+6]=Jn[6],e[t+7]=Jn[7]}function Voe(n,e){return Jn[0]=n[e],Jn[1]=n[e+1],Jn[2]=n[e+2],Jn[3]=n[e+3],Jn[4]=n[e+4],Jn[5]=n[e+5],Jn[6]=n[e+6],Jn[7]=n[e+7],AS[0]}const Hoe=BigInt(Number.MAX_SAFE_INTEGER),Goe=BigInt(Number.MIN_SAFE_INTEGER);class er{constructor(e,t){h(this,"lo");h(this,"hi");this.lo=e|0,this.hi=t|0}toNumber(e=!1){if(!e&&this.hi>>>31>0){const t=~this.lo+1>>>0;let r=~this.hi>>>0;return t===0&&(r=r+1>>>0),-(t+r*4294967296)}return this.lo+this.hi*4294967296}toBigInt(e=!1){if(e)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const t=~this.lo+1>>>0;let r=~this.hi>>>0;return t===0&&(r=r+1>>>0),-(BigInt(t)+(BigInt(r)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(e=!1){return this.toBigInt(e).toString()}zzEncode(){const e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this}zzDecode(){const e=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this}length(){const e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,r=this.hi>>>24;return r===0?t===0?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:r<128?9:10}static fromBigInt(e){if(e===0n)return Va;if(e<Hoe&&e>Goe)return this.fromNumber(Number(e));const t=e<0n;t&&(e=-e);let r=e>>32n,i=e-(r<<32n);return t&&(r=~r|0n,i=~i|0n,++i>I2&&(i=0n,++r>I2&&(r=0n))),new er(Number(i),Number(r))}static fromNumber(e){if(e===0)return Va;const t=e<0;t&&(e=-e);let r=e>>>0,i=(e-r)/4294967296>>>0;return t&&(i=~i>>>0,r=~r>>>0,++r>4294967295&&(r=0,++i>4294967295&&(i=0))),new er(r,i)}static from(e){return typeof e=="number"?er.fromNumber(e):typeof e=="bigint"?er.fromBigInt(e):typeof e=="string"?er.fromBigInt(BigInt(e)):e.low!=null||e.high!=null?new er(e.low>>>0,e.high>>>0):Va}}const Va=new er(0,0);Va.toBigInt=function(){return 0n};Va.zzEncode=Va.zzDecode=function(){return this};Va.length=function(){return 1};const I2=4294967296n;function Woe(n){let e=0,t=0;for(let r=0;r<n.length;++r)t=n.charCodeAt(r),t<128?e+=1:t<2048?e+=2:(t&64512)===55296&&(n.charCodeAt(r+1)&64512)===56320?(++r,e+=4):e+=3;return e}function qoe(n,e,t){if(t-e<1)return"";let i;const s=[];let o=0,a;for(;e<t;)a=n[e++],a<128?s[o++]=a:a>191&&a<224?s[o++]=(a&31)<<6|n[e++]&63:a>239&&a<365?(a=((a&7)<<18|(n[e++]&63)<<12|(n[e++]&63)<<6|n[e++]&63)-65536,s[o++]=55296+(a>>10),s[o++]=56320+(a&1023)):s[o++]=(a&15)<<12|(n[e++]&63)<<6|n[e++]&63,o>8191&&((i??(i=[])).push(String.fromCharCode.apply(String,s)),o=0);return i!=null?(o>0&&i.push(String.fromCharCode.apply(String,s.slice(0,o))),i.join("")):String.fromCharCode.apply(String,s.slice(0,o))}function SO(n,e,t){const r=t;let i,s;for(let o=0;o<n.length;++o)i=n.charCodeAt(o),i<128?e[t++]=i:i<2048?(e[t++]=i>>6|192,e[t++]=i&63|128):(i&64512)===55296&&((s=n.charCodeAt(o+1))&64512)===56320?(i=65536+((i&1023)<<10)+(s&1023),++o,e[t++]=i>>18|240,e[t++]=i>>12&63|128,e[t++]=i>>6&63|128,e[t++]=i&63|128):(e[t++]=i>>12|224,e[t++]=i>>6&63|128,e[t++]=i&63|128);return t-r}function bi(n,e){return RangeError(`index out of range: ${n.pos} + ${e??1} > ${n.len}`)}function _p(n,e){return(n[e-4]|n[e-3]<<8|n[e-2]<<16|n[e-1]<<24)>>>0}class Koe{constructor(e){h(this,"buf");h(this,"pos");h(this,"len");h(this,"_slice",Uint8Array.prototype.subarray);this.buf=e,this.pos=0,this.len=e.length}uint32(){let e=4294967295;if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,bi(this,10);return e}int32(){return this.uint32()|0}sint32(){const e=this.uint32();return e>>>1^-(e&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw bi(this,4);return _p(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw bi(this,4);return _p(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw bi(this,4);const e=Foe(this.buf,this.pos);return this.pos+=4,e}double(){if(this.pos+8>this.len)throw bi(this,4);const e=Voe(this.buf,this.pos);return this.pos+=8,e}bytes(){const e=this.uint32(),t=this.pos,r=this.pos+e;if(r>this.len)throw bi(this,e);return this.pos+=e,t===r?new Uint8Array(0):this.buf.subarray(t,r)}string(){const e=this.bytes();return qoe(e,0,e.length)}skip(e){if(typeof e=="number"){if(this.pos+e>this.len)throw bi(this,e);this.pos+=e}else do if(this.pos>=this.len)throw bi(this);while((this.buf[this.pos++]&128)!==0);return this}skipType(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(e=this.uint32()&7)!==4;)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${e} at offset ${this.pos}`)}return this}readLongVarint(){const e=new er(0,0);let t=0;if(this.len-this.pos>4){for(;t<4;++t)if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(this.buf[this.pos]&127)<<28)>>>0,e.hi=(e.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return e;t=0}else{for(;t<3;++t){if(this.pos>=this.len)throw bi(this);if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(this.buf[this.pos++]&127)<<t*7)>>>0,e}if(this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw bi(this);if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw bi(this,8);const e=_p(this.buf,this.pos+=4),t=_p(this.buf,this.pos+=4);return new er(e,t)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const e=EO(this.buf,this.pos);return this.pos+=Vu(e),e}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function Xoe(n){return new Koe(n instanceof Uint8Array?n:n.subarray())}function Ui(n,e,t){const r=Xoe(n);return e.decode(r,void 0,t)}function Yoe(n){let r,i=8192;return function(o){if(o<1||o>4096)return ea(o);i+o>8192&&(r=ea(8192),i=0);const a=r.subarray(i,i+=o);return(i&7)!==0&&(i=(i|7)+1),a}}class Ih{constructor(e,t,r){h(this,"fn");h(this,"len");h(this,"next");h(this,"val");this.fn=e,this.len=t,this.next=void 0,this.val=r}}function H0(){}class Zoe{constructor(e){h(this,"head");h(this,"tail");h(this,"len");h(this,"next");this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}}const joe=Yoe();function Joe(n){return globalThis.Buffer!=null?ea(n):joe(n)}class g_{constructor(){h(this,"len");h(this,"head");h(this,"tail");h(this,"states");this.len=0,this.head=new Ih(H0,0,0),this.tail=this.head,this.states=null}_push(e,t,r){return this.tail=this.tail.next=new Ih(e,t,r),this.len+=t,this}uint32(e){return this.len+=(this.tail=this.tail.next=new eae((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this}int32(e){return e<0?this._push(Ep,10,er.fromNumber(e)):this.uint32(e)}sint32(e){return this.uint32((e<<1^e>>31)>>>0)}uint64(e){const t=er.fromBigInt(e);return this._push(Ep,t.length(),t)}uint64Number(e){return this._push(_O,Vu(e),e)}uint64String(e){return this.uint64(BigInt(e))}int64(e){return this.uint64(e)}int64Number(e){return this.uint64Number(e)}int64String(e){return this.uint64String(e)}sint64(e){const t=er.fromBigInt(e).zzEncode();return this._push(Ep,t.length(),t)}sint64Number(e){const t=er.fromNumber(e).zzEncode();return this._push(Ep,t.length(),t)}sint64String(e){return this.sint64(BigInt(e))}bool(e){return this._push(G0,1,e?1:0)}fixed32(e){return this._push(fh,4,e>>>0)}sfixed32(e){return this.fixed32(e)}fixed64(e){const t=er.fromBigInt(e);return this._push(fh,4,t.lo)._push(fh,4,t.hi)}fixed64Number(e){const t=er.fromNumber(e);return this._push(fh,4,t.lo)._push(fh,4,t.hi)}fixed64String(e){return this.fixed64(BigInt(e))}sfixed64(e){return this.fixed64(e)}sfixed64Number(e){return this.fixed64Number(e)}sfixed64String(e){return this.fixed64String(e)}float(e){return this._push($oe,4,e)}double(e){return this._push(zoe,8,e)}bytes(e){const t=e.length>>>0;return t===0?this._push(G0,1,0):this.uint32(t)._push(tae,t,e)}string(e){const t=Woe(e);return t!==0?this.uint32(t)._push(SO,t,e):this._push(G0,1,0)}fork(){return this.states=new Zoe(this),this.head=this.tail=new Ih(H0,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Ih(H0,0,0),this.len=0),this}ldelim(){const e=this.head,t=this.tail,r=this.len;return this.reset().uint32(r),r!==0&&(this.tail.next=e.next,this.tail=t,this.len+=r),this}finish(){let e=this.head.next;const t=Joe(this.len);let r=0;for(;e!=null;)e.fn(e.val,t,r),r+=e.len,e=e.next;return t}}function G0(n,e,t){e[t]=n&255}function Qoe(n,e,t){for(;n>127;)e[t++]=n&127|128,n>>>=7;e[t]=n}class eae extends Ih{constructor(t,r){super(Qoe,t,r);h(this,"next");this.next=void 0}}function Ep(n,e,t){for(;n.hi!==0;)e[t++]=n.lo&127|128,n.lo=(n.lo>>>7|n.hi<<25)>>>0,n.hi>>>=7;for(;n.lo>127;)e[t++]=n.lo&127|128,n.lo=n.lo>>>7;e[t++]=n.lo}function fh(n,e,t){e[t]=n&255,e[t+1]=n>>>8&255,e[t+2]=n>>>16&255,e[t+3]=n>>>24}function tae(n,e,t){e.set(n,t)}globalThis.Buffer!=null&&(g_.prototype.bytes=function(n){const e=n.length>>>0;return this.uint32(e),e>0&&this._push(nae,e,n),this},g_.prototype.string=function(n){const e=globalThis.Buffer.byteLength(n);return this.uint32(e),e>0&&this._push(rae,e,n),this});function nae(n,e,t){e.set(n,t)}function rae(n,e,t){n.length<40?SO(n,e,t):e.utf8Write!=null?e.utf8Write(n,t):e.set(io(n),t)}function iae(){return new g_}function Bi(n,e){const t=iae();return e.encode(n,t,{lengthDelimited:!1}),t.finish()}var Jm;(function(n){n[n.VARINT=0]="VARINT",n[n.BIT64=1]="BIT64",n[n.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",n[n.START_GROUP=3]="START_GROUP",n[n.END_GROUP=4]="END_GROUP",n[n.BIT32=5]="BIT32"})(Jm||(Jm={}));function xO(n,e,t,r){return{name:n,type:e,encode:t,decode:r}}function sae(n){function e(i){if(n[i.toString()]==null)throw new Error("Invalid enum value");return n[i]}const t=function(s,o){const a=e(s);o.int32(a)},r=function(s){const o=s.int32();return e(o)};return xO("enum",Jm.VARINT,t,r)}function ki(n,e){return xO("message",Jm.LENGTH_DELIMITED,n,e)}class Fs extends Error{constructor(){super(...arguments);h(this,"code","ERR_MAX_LENGTH");h(this,"name","MaxLengthError")}}var Sn;(function(n){n.RSA="RSA",n.Ed25519="Ed25519",n.secp256k1="secp256k1",n.ECDSA="ECDSA"})(Sn||(Sn={}));var y_;(function(n){n[n.RSA=0]="RSA",n[n.Ed25519=1]="Ed25519",n[n.secp256k1=2]="secp256k1",n[n.ECDSA=3]="ECDSA"})(y_||(y_={}));(function(n){n.codec=()=>sae(y_)})(Sn||(Sn={}));var _u;(function(n){let e;n.codec=()=>(e==null&&(e=ki((t,r,i={})=>{i.lengthDelimited!==!1&&r.fork(),t.Type!=null&&(r.uint32(8),Sn.codec().encode(t.Type,r)),t.Data!=null&&(r.uint32(18),r.bytes(t.Data)),i.lengthDelimited!==!1&&r.ldelim()},(t,r,i={})=>{const s={},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.Type=Sn.codec().decode(t);break}case 2:{s.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return s})),e),n.encode=t=>Bi(t,n.codec()),n.decode=(t,r)=>Ui(t,n.codec(),r)})(_u||(_u={}));var P2;(function(n){let e;n.codec=()=>(e==null&&(e=ki((t,r,i={})=>{i.lengthDelimited!==!1&&r.fork(),t.Type!=null&&(r.uint32(8),Sn.codec().encode(t.Type,r)),t.Data!=null&&(r.uint32(18),r.bytes(t.Data)),i.lengthDelimited!==!1&&r.ldelim()},(t,r,i={})=>{const s={},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.Type=Sn.codec().decode(t);break}case 2:{s.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return s})),e),n.encode=t=>Bi(t,n.codec()),n.decode=(t,r)=>Ui(t,n.codec(),r)})(P2||(P2={}));function oae(n){if(isNaN(n)||n<=0)throw new dc("random bytes length must be a Number bigger than 0");return Zg(n)}class aae{constructor(e,t){h(this,"type","RSA");h(this,"jwk");h(this,"_raw");h(this,"_multihash");this.jwk=e,this._multihash=t}get raw(){return this._raw==null&&(this._raw=dae(this.jwk)),this._raw}toMultihash(){return this._multihash}toCID(){return Gt.createV1(114,this._multihash)}toString(){return hr.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:nc(this.raw,e.raw)}verify(e,t,r){return mae(this.jwk,t,e,r)}}const cae=18,lae=1062,uae=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function hae(n){const e=Xg(n[1],{offset:0});return{kty:"RSA",n:Or(e[0],"base64url"),e:Or(e[1],"base64url")}}function dae(n){if(n.n==null||n.e==null)throw new dc("JWK was missing components");return Gh([uae,G3(Gh([d_(io(n.n,"base64url")),d_(io(n.e,"base64url"))]))]).subarray()}function fae(n,e){if(n.byteLength>=lae)throw new hS("Key size is too large");const t=Xg(n,{offset:0});return pae(t,n,e)}function pae(n,e,t){const r=hae(n);if(t==null){const i=J3(_u.encode({Type:Sn.RSA,Data:e}));t=qg(cae,i)}return new aae(r,t)}async function mae(n,e,t,r){var o,a;const i=await Td.get().subtle.importKey("jwk",n,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);(o=r==null?void 0:r.signal)==null||o.throwIfAborted();const s=await Td.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},i,e,t instanceof Uint8Array?t:t.subarray());return(a=r==null?void 0:r.signal)==null||a.throwIfAborted(),s}class TO{constructor(e,t){h(this,"oHash");h(this,"iHash");h(this,"blockLen");h(this,"outputLen");h(this,"finished",!1);h(this,"destroyed",!1);if(q3(e),lt(t,void 0,"key"),this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const r=this.blockLen,i=new Uint8Array(r);i.set(t.length>r?e.create().update(t).digest():t);for(let s=0;s<i.length;s++)i[s]^=54;this.iHash.update(i),this.oHash=e.create();for(let s=0;s<i.length;s++)i[s]^=106;this.oHash.update(i),wu(i)}update(e){return Ym(this),this.iHash.update(e),this}digestInto(e){Ym(this),lt(e,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:i,destroyed:s,blockLen:o,outputLen:a}=this;return e=e,e.finished=i,e.destroyed=s,e.blockLen=o,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const AO=(n,e,t)=>new TO(n,e).update(t).digest();AO.create=(n,e)=>new TO(n,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const D2=(n,e)=>(n+(n>=0?e:-e)/MO)/e;function gae(n,e,t){const[[r,i],[s,o]]=e,a=D2(o*n,t),c=D2(-i*n,t);let l=n-a*r-c*s,u=-a*i-c*o;const d=l<zs,f=u<zs;d&&(l=-l),f&&(u=-u);const p=bS(Math.ceil(jse(t)/2))+ml;if(l<zs||l>=p||u<zs||u>=p)throw new Error("splitScalar (endomorphism): failed, k="+n);return{k1neg:d,k1:l,k2neg:f,k2:u}}function b_(n){if(!["compact","recovered","der"].includes(n))throw new Error('Signature format must be "compact", "recovered", or "der"');return n}function W0(n,e){const t={};for(let r of Object.keys(e))t[r]=n[r]===void 0?e[r]:n[r];return ic(t.lowS,"lowS"),ic(t.prehash,"prehash"),t.format!==void 0&&b_(t.format),t}class yae extends Error{constructor(e=""){super(e)}}const Po={Err:yae,_tlv:{encode:(n,e)=>{const{Err:t}=Po;if(n<0||n>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const r=e.length/2,i=vp(r);if(i.length/2&128)throw new t("tlv.encode: long form length too big");const s=r>127?vp(i.length/2|128):"";return vp(n)+s+i+e},decode(n,e){const{Err:t}=Po;let r=0;if(n<0||n>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[r++]!==n)throw new t("tlv.decode: wrong tlv");const i=e[r++],s=!!(i&128);let o=0;if(!s)o=i;else{const c=i&127;if(!c)throw new t("tlv.decode(long): indefinite length not supported");if(c>4)throw new t("tlv.decode(long): byte length is too big");const l=e.subarray(r,r+c);if(l.length!==c)throw new t("tlv.decode: length bytes not complete");if(l[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const u of l)o=o<<8|u;if(r+=c,o<128)throw new t("tlv.decode(long): not minimal encoding")}const a=e.subarray(r,r+o);if(a.length!==o)throw new t("tlv.decode: wrong value length");return{v:a,l:e.subarray(r+o)}}},_int:{encode(n){const{Err:e}=Po;if(n<zs)throw new e("integer: negative integers are not allowed");let t=vp(n);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(n){const{Err:e}=Po;if(n[0]&128)throw new e("invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return jg(n)}},toSig(n){const{Err:e,_int:t,_tlv:r}=Po,i=lt(n,void 0,"signature"),{v:s,l:o}=r.decode(48,i);if(o.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=r.decode(2,s),{v:l,l:u}=r.decode(2,c);if(u.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(l)}},hexFromSig(n){const{_tlv:e,_int:t}=Po,r=e.encode(2,t.encode(n.r)),i=e.encode(2,t.encode(n.s)),s=r+i;return e.encode(48,s)}},zs=BigInt(0),ml=BigInt(1),MO=BigInt(2),Sp=BigInt(3),bae=BigInt(4);function wae(n,e={}){const t=mO("weierstrass",n,e),{Fp:r,Fn:i}=t;let s=t.CURVE;const{h:o,n:a}=s;af(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});const{endo:c}=e;if(c&&(!r.is0(s.a)||typeof c.beta!="bigint"||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const l=IO(r,i);function u(){if(!r.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function d(z,v,S){const{x:P,y:U}=v.toAffine(),B=r.toBytes(P);if(ic(S,"isCompressed"),S){u();const O=!r.isOdd(U);return is(CO(O),B)}else return is(Uint8Array.of(4),B,r.toBytes(U))}function f(z){lt(z,void 0,"Point");const{publicKey:v,publicKeyUncompressed:S}=l,P=z.length,U=z[0],B=z.subarray(1);if(P===v&&(U===2||U===3)){const O=r.fromBytes(B);if(!r.isValid(O))throw new Error("bad point: is not on curve, wrong x");const V=b(O);let $;try{$=r.sqrt(V)}catch(Y){const te=Y instanceof Error?": "+Y.message:"";throw new Error("bad point: is not on curve, sqrt error"+te)}u();const W=r.isOdd($);return(U&1)===1!==W&&($=r.neg($)),{x:O,y:$}}else if(P===S&&U===4){const O=r.BYTES,V=r.fromBytes(B.subarray(0,O)),$=r.fromBytes(B.subarray(O,O*2));if(!m(V,$))throw new Error("bad point: is not on curve");return{x:V,y:$}}else throw new Error(`bad point: got length ${P}, expected compressed=${v} or uncompressed=${S}`)}const p=e.toBytes||d,g=e.fromBytes||f;function b(z){const v=r.sqr(z),S=r.mul(v,z);return r.add(r.add(S,r.mul(z,s.a)),s.b)}function m(z,v){const S=r.sqr(v),P=b(z);return r.eql(S,P)}if(!m(s.Gx,s.Gy))throw new Error("bad curve params: generator point");const y=r.mul(r.pow(s.a,Sp),bae),E=r.mul(r.sqr(s.b),BigInt(27));if(r.is0(r.add(y,E)))throw new Error("bad curve params: a or b");function w(z,v,S=!1){if(!r.isValid(v)||S&&r.is0(v))throw new Error(`bad point coordinate ${z}`);return v}function x(z){if(!(z instanceof _))throw new Error("Weierstrass Point expected")}function M(z){if(!c||!c.basises)throw new Error("no endo");return gae(z,c.basises,i.ORDER)}const A=Zm((z,v)=>{const{X:S,Y:P,Z:U}=z;if(r.eql(U,r.ONE))return{x:S,y:P};const B=z.is0();v==null&&(v=B?r.ONE:r.inv(U));const O=r.mul(S,v),V=r.mul(P,v),$=r.mul(U,v);if(B)return{x:r.ZERO,y:r.ZERO};if(!r.eql($,r.ONE))throw new Error("invZ was invalid");return{x:O,y:V}}),C=Zm(z=>{if(z.is0()){if(e.allowInfinityPoint&&!r.is0(z.Y))return;throw new Error("bad point: ZERO")}const{x:v,y:S}=z.toAffine();if(!r.isValid(v)||!r.isValid(S))throw new Error("bad point: x or y not field elements");if(!m(v,S))throw new Error("bad point: equation left != right");if(!z.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function R(z,v,S,P,U){return S=new _(r.mul(S.X,z),S.Y,S.Z),v=jm(P,v),S=jm(U,S),v.add(S)}const k=class k{constructor(v,S,P){h(this,"X");h(this,"Y");h(this,"Z");this.X=w("x",v),this.Y=w("y",S,!0),this.Z=w("z",P),Object.freeze(this)}static CURVE(){return s}static fromAffine(v){const{x:S,y:P}=v||{};if(!v||!r.isValid(S)||!r.isValid(P))throw new Error("invalid affine point");if(v instanceof k)throw new Error("projective point not allowed");return r.is0(S)&&r.is0(P)?k.ZERO:new k(S,P,r.ONE)}static fromBytes(v){const S=k.fromAffine(g(lt(v,void 0,"point")));return S.assertValidity(),S}static fromHex(v){return k.fromBytes(Sd(v))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(v=8,S=!0){return F.createCache(this,v),S||this.multiply(Sp),this}assertValidity(){C(this)}hasEvenY(){const{y:v}=this.toAffine();if(!r.isOdd)throw new Error("Field doesn't support isOdd");return!r.isOdd(v)}equals(v){x(v);const{X:S,Y:P,Z:U}=this,{X:B,Y:O,Z:V}=v,$=r.eql(r.mul(S,V),r.mul(B,U)),W=r.eql(r.mul(P,V),r.mul(O,U));return $&&W}negate(){return new k(this.X,r.neg(this.Y),this.Z)}double(){const{a:v,b:S}=s,P=r.mul(S,Sp),{X:U,Y:B,Z:O}=this;let V=r.ZERO,$=r.ZERO,W=r.ZERO,H=r.mul(U,U),Y=r.mul(B,B),te=r.mul(O,O),j=r.mul(U,B);return j=r.add(j,j),W=r.mul(U,O),W=r.add(W,W),V=r.mul(v,W),$=r.mul(P,te),$=r.add(V,$),V=r.sub(Y,$),$=r.add(Y,$),$=r.mul(V,$),V=r.mul(j,V),W=r.mul(P,W),te=r.mul(v,te),j=r.sub(H,te),j=r.mul(v,j),j=r.add(j,W),W=r.add(H,H),H=r.add(W,H),H=r.add(H,te),H=r.mul(H,j),$=r.add($,H),te=r.mul(B,O),te=r.add(te,te),H=r.mul(te,j),V=r.sub(V,H),W=r.mul(te,Y),W=r.add(W,W),W=r.add(W,W),new k(V,$,W)}add(v){x(v);const{X:S,Y:P,Z:U}=this,{X:B,Y:O,Z:V}=v;let $=r.ZERO,W=r.ZERO,H=r.ZERO;const Y=s.a,te=r.mul(s.b,Sp);let j=r.mul(S,B),re=r.mul(P,O),le=r.mul(U,V),fe=r.add(S,P),se=r.add(B,O);fe=r.mul(fe,se),se=r.add(j,re),fe=r.sub(fe,se),se=r.add(S,U);let ve=r.add(B,V);return se=r.mul(se,ve),ve=r.add(j,le),se=r.sub(se,ve),ve=r.add(P,U),$=r.add(O,V),ve=r.mul(ve,$),$=r.add(re,le),ve=r.sub(ve,$),H=r.mul(Y,se),$=r.mul(te,le),H=r.add($,H),$=r.sub(re,H),H=r.add(re,H),W=r.mul($,H),re=r.add(j,j),re=r.add(re,j),le=r.mul(Y,le),se=r.mul(te,se),re=r.add(re,le),le=r.sub(j,le),le=r.mul(Y,le),se=r.add(se,le),j=r.mul(re,se),W=r.add(W,j),j=r.mul(ve,se),$=r.mul(fe,$),$=r.sub($,j),j=r.mul(fe,re),H=r.mul(ve,H),H=r.add(H,j),new k($,W,H)}subtract(v){return this.add(v.negate())}is0(){return this.equals(k.ZERO)}multiply(v){const{endo:S}=e;if(!i.isValidNot0(v))throw new Error("invalid scalar: out of range");let P,U;const B=O=>F.cached(this,O,V=>Wh(k,V));if(S){const{k1neg:O,k1:V,k2neg:$,k2:W}=M(v),{p:H,f:Y}=B(V),{p:te,f:j}=B(W);U=Y.add(j),P=R(S.beta,H,te,O,$)}else{const{p:O,f:V}=B(v);P=O,U=V}return Wh(k,[P,U])[0]}multiplyUnsafe(v){const{endo:S}=e,P=this;if(!i.isValid(v))throw new Error("invalid scalar: out of range");if(v===zs||P.is0())return k.ZERO;if(v===ml)return P;if(F.hasCache(this))return this.multiply(v);if(S){const{k1neg:U,k1:B,k2neg:O,k2:V}=M(v),{p1:$,p2:W}=hoe(k,P,B,V);return R(S.beta,$,W,U,O)}else return F.unsafe(P,v)}toAffine(v){return A(this,v)}isTorsionFree(){const{isTorsionFree:v}=e;return o===ml?!0:v?v(k,this):F.unsafe(this,a).is0()}clearCofactor(){const{clearCofactor:v}=e;return o===ml?this:v?v(k,this):this.multiplyUnsafe(o)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}toBytes(v=!0){return ic(v,"isCompressed"),this.assertValidity(),p(k,this,v)}toHex(v=!0){return of(this.toBytes(v))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}};h(k,"BASE",new k(s.Gx,s.Gy,r.ONE)),h(k,"ZERO",new k(r.ZERO,r.ONE,r.ZERO)),h(k,"Fp",r),h(k,"Fn",i);let _=k;const T=i.BITS,F=new pO(_,e.endo?Math.ceil(T/2):T);return _.BASE.precompute(8),_}function CO(n){return Uint8Array.of(n?2:3)}function IO(n,e){return{secretKey:e.BYTES,publicKey:1+n.BYTES,publicKeyUncompressed:1+2*n.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}function vae(n,e={}){const{Fn:t}=n,r=e.randomBytes||Zg,i=Object.assign(IO(n.Fp,t),{seed:hO(t.ORDER)});function s(p){try{const g=t.fromBytes(p);return t.isValidNot0(g)}catch{return!1}}function o(p,g){const{publicKey:b,publicKeyUncompressed:m}=i;try{const y=p.length;return g===!0&&y!==b||g===!1&&y!==m?!1:!!n.fromBytes(p)}catch{return!1}}function a(p=r(i.seed)){return uoe(lt(p,i.seed,"seed"),t.ORDER)}function c(p,g=!0){return n.BASE.multiply(t.fromBytes(p)).toBytes(g)}function l(p){const{secretKey:g,publicKey:b,publicKeyUncompressed:m}=i;if(!Yg(p)||"_lengths"in t&&t._lengths||g===b)return;const y=lt(p,void 0,"key").length;return y===b||y===m}function u(p,g,b=!0){if(l(p)===!0)throw new Error("first arg must be private key");if(l(g)===!1)throw new Error("second arg must be public key");const m=t.fromBytes(p);return n.fromBytes(g).multiply(m).toBytes(b)}const d={isValidSecretKey:s,isValidPublicKey:o,randomSecretKey:a},f=gO(a,c);return Object.freeze({getPublicKey:c,getSharedSecret:u,keygen:f,Point:n,utils:d,lengths:i})}function _ae(n,e,t={}){q3(e),af(t,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"}),t=Object.assign({},t);const r=t.randomBytes||Zg,i=t.hmac||((v,S)=>AO(e,v,S)),{Fp:s,Fn:o}=n,{ORDER:a,BITS:c}=o,{keygen:l,getPublicKey:u,getSharedSecret:d,utils:f,lengths:p}=vae(n,t),g={prehash:!0,lowS:typeof t.lowS=="boolean"?t.lowS:!0,format:"compact",extraEntropy:!1},b=a*MO<s.ORDER;function m(v){const S=a>>ml;return v>S}function y(v,S){if(!o.isValidNot0(S))throw new Error(`invalid signature ${v}: out of range 1..Point.Fn.ORDER`);return S}function E(){if(b)throw new Error('"recovered" sig type is not supported for cofactor >2 curves')}function w(v,S){b_(S);const P=p.signature,U=S==="compact"?P:S==="recovered"?P+1:void 0;return lt(v,U)}class x{constructor(S,P,U){h(this,"r");h(this,"s");h(this,"recovery");if(this.r=y("r",S),this.s=y("s",P),U!=null){if(E(),![0,1,2,3].includes(U))throw new Error("invalid recovery id");this.recovery=U}Object.freeze(this)}static fromBytes(S,P=g.format){w(S,P);let U;if(P==="der"){const{r:$,s:W}=Po.toSig(lt(S));return new x($,W)}P==="recovered"&&(U=S[0],P="compact",S=S.subarray(1));const B=p.signature/2,O=S.subarray(0,B),V=S.subarray(B,B*2);return new x(o.fromBytes(O),o.fromBytes(V),U)}static fromHex(S,P){return this.fromBytes(Sd(S),P)}assertRecovery(){const{recovery:S}=this;if(S==null)throw new Error("invalid recovery id: must be present");return S}addRecoveryBit(S){return new x(this.r,this.s,S)}recoverPublicKey(S){const{r:P,s:U}=this,B=this.assertRecovery(),O=B===2||B===3?P+a:P;if(!s.isValid(O))throw new Error("invalid recovery id: sig.r+curve.n != R.x");const V=s.toBytes(O),$=n.fromBytes(is(CO((B&1)===0),V)),W=o.inv(O),H=A(lt(S,void 0,"msgHash")),Y=o.create(-H*W),te=o.create(U*W),j=n.BASE.multiplyUnsafe(Y).add($.multiplyUnsafe(te));if(j.is0())throw new Error("invalid recovery: point at infinify");return j.assertValidity(),j}hasHighS(){return m(this.s)}toBytes(S=g.format){if(b_(S),S==="der")return Sd(Po.hexFromSig(this));const{r:P,s:U}=this,B=o.toBytes(P),O=o.toBytes(U);return S==="recovered"?(E(),is(Uint8Array.of(this.assertRecovery()),B,O)):is(B,O)}toHex(S){return of(this.toBytes(S))}}const M=t.bits2int||function(S){if(S.length>8192)throw new Error("input is too large");const P=jg(S),U=S.length*8-c;return U>0?P>>BigInt(U):P},A=t.bits2int_modN||function(S){return o.create(M(S))},C=bS(c);function R(v){return m_("num < 2^"+c,v,zs,C),o.toBytes(v)}function _(v,S){return lt(v,void 0,"message"),S?lt(e(v),void 0,"prehashed message"):v}function T(v,S,P){const{lowS:U,prehash:B,extraEntropy:O}=W0(P,g);v=_(v,B);const V=A(v),$=o.fromBytes(S);if(!o.isValidNot0($))throw new Error("invalid private key");const W=[R($),R(V)];if(O!=null&&O!==!1){const j=O===!0?r(p.secretKey):O;W.push(lt(j,void 0,"extraEntropy"))}const H=is(...W),Y=V;function te(j){const re=M(j);if(!o.isValidNot0(re))return;const le=o.inv(re),fe=n.BASE.multiply(re).toAffine(),se=o.create(fe.x);if(se===zs)return;const ve=o.create(le*o.create(Y+se*$));if(ve===zs)return;let X=(fe.x===se?0:2)|Number(fe.y&ml),Ut=ve;return U&&m(ve)&&(Ut=o.neg(ve),X^=1),new x(se,Ut,b?void 0:X)}return{seed:H,k2sig:te}}function F(v,S,P={}){const{seed:U,k2sig:B}=T(v,S,P);return Jse(e.outputLen,o.BYTES,i)(U,B).toBytes(P.format)}function k(v,S,P,U={}){const{lowS:B,prehash:O,format:V}=W0(U,g);if(P=lt(P,void 0,"publicKey"),S=_(S,O),!Yg(v)){const $=v instanceof x?", use sig.toBytes()":"";throw new Error("verify expects Uint8Array signature"+$)}w(v,V);try{const $=x.fromBytes(v,V),W=n.fromBytes(P);if(B&&$.hasHighS())return!1;const{r:H,s:Y}=$,te=A(S),j=o.inv(Y),re=o.create(te*j),le=o.create(H*j),fe=n.BASE.multiplyUnsafe(re).add(W.multiplyUnsafe(le));return fe.is0()?!1:o.create(fe.x)===H}catch{return!1}}function z(v,S,P={}){const{prehash:U}=W0(P,g);return S=_(S,U),x.fromBytes(v,"recovered").recoverPublicKey(S).toBytes()}return Object.freeze({keygen:l,getPublicKey:u,getSharedSecret:d,utils:f,lengths:p,Point:n,sign:F,verify:k,recoverPublicKey:z,Signature:x,hash:e})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const MS={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},Eae={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},R2=BigInt(2);function Sae(n){const e=MS.p,t=BigInt(3),r=BigInt(6),i=BigInt(11),s=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),l=n*n*n%e,u=l*l*n%e,d=Wt(u,t,e)*u%e,f=Wt(d,t,e)*u%e,p=Wt(f,R2,e)*l%e,g=Wt(p,i,e)*p%e,b=Wt(g,s,e)*g%e,m=Wt(b,a,e)*b%e,y=Wt(m,c,e)*m%e,E=Wt(y,a,e)*b%e,w=Wt(E,t,e)*u%e,x=Wt(w,o,e)*g%e,M=Wt(x,r,e)*l%e,A=Wt(M,R2,e);if(!w_.eql(w_.sqr(A),n))throw new Error("Cannot find square root");return A}const w_=Jg(MS.p,{sqrt:Sae}),xae=wae(MS,{Fp:w_,endo:Eae}),Qm=_ae(xae,J3);function Tae(n,e,t,r){var s;const i=pS.digest(t instanceof Uint8Array?t:t.subarray());if(bO(i))return i.then(({digest:o})=>{var a;return(a=r==null?void 0:r.signal)==null||a.throwIfAborted(),Qm.verify(e,o,n,{prehash:!1,format:"der"})}).catch(o=>{throw o.name==="AbortError"?o:new C2(String(o))});try{return(s=r==null?void 0:r.signal)==null||s.throwIfAborted(),Qm.verify(e,i.digest,n,{prehash:!1,format:"der"})}catch(o){throw new C2(String(o))}}class Aae{constructor(e){h(this,"type","secp256k1");h(this,"raw");h(this,"_key");this._key=Cae(e),this.raw=Mae(this._key)}toMultihash(){return rf.digest(cf(this))}toCID(){return Gt.createV1(114,this.toMultihash())}toString(){return hr.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:nc(this.raw,e.raw)}verify(e,t,r){return Tae(this._key,t,e,r)}}function PO(n){return new Aae(n)}function Mae(n){return Qm.Point.fromBytes(n).toBytes()}function Cae(n){try{return Qm.Point.fromBytes(n),n}catch(e){throw new hS(String(e))}}function DO(n,e){const{Type:t,Data:r}=_u.decode(n),i=r??new Uint8Array;switch(t){case Sn.RSA:return fae(i,e);case Sn.Ed25519:return wO(i);case Sn.secp256k1:return PO(i);case Sn.ECDSA:return W3(i);default:throw new dS}}function Iae(n){const{Type:e,Data:t}=_u.decode(n.digest),r=t??new Uint8Array;switch(e){case Sn.Ed25519:return wO(r);case Sn.secp256k1:return PO(r);case Sn.ECDSA:return W3(r);default:throw new dS}}function cf(n){return _u.encode({Type:Sn[n.type],Data:n.raw})}const RO=Symbol.for("nodejs.util.inspect.custom"),Pae=114;var QC;let CS=class{constructor(e){h(this,"type");h(this,"multihash");h(this,"publicKey");h(this,"string");h(this,QC,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=hr.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return Gt.createV1(Pae,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return nc(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return nc(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(QC=O3,RO)](){return`PeerId(${this.toString()})`}},LO=class extends CS{constructor(t){super({...t,type:"RSA"});h(this,"type","RSA");h(this,"publicKey");this.publicKey=t.publicKey}},OO=class extends CS{constructor(t){super({...t,type:"Ed25519"});h(this,"type","Ed25519");h(this,"publicKey");this.publicKey=t.publicKey}},NO=class extends CS{constructor(t){super({...t,type:"secp256k1"});h(this,"type","secp256k1");h(this,"publicKey");this.publicKey=t.publicKey}};const Dae=2336;var eI,tI;let Rae=class{constructor(e){h(this,"type","url");h(this,"multihash");h(this,"publicKey");h(this,"url");h(this,eI,!0);this.url=e.toString(),this.multihash=rf.digest(io(this.url))}[(tI=RO,eI=O3,tI)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return Gt.createV1(Dae,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=Or(e)),e.toString()===this.toString())}};function UO(n){if(n.type==="Ed25519")return new OO({multihash:n.toCID().multihash,publicKey:n});if(n.type==="secp256k1")return new NO({multihash:n.toCID().multihash,publicKey:n});if(n.type==="RSA")return new LO({multihash:n.toCID().multihash,publicKey:n});throw new dS}function Lae(n){return UO(n.publicKey)}function IS(n){if(Nae(n))return new LO({multihash:n});if(Oae(n))try{const e=Iae(n);if(e.type==="Ed25519")return new OO({multihash:n,publicKey:e});if(e.type==="secp256k1")return new NO({multihash:n,publicKey:e})}catch{const t=Or(n.digest);return new Rae(new URL(t))}throw new zre("Supplied PeerID Multihash is invalid")}function Oae(n){return n.code===rf.code}function Nae(n){return n.code===pS.code}function qh(n,e){const t={[Symbol.iterator]:()=>t,next:()=>{const r=n.next(),i=r.value;return r.done===!0||i==null?{done:!0,value:void 0}:{done:!1,value:e(i)}}};return t}function q0(n){const e=Kg(hr.decode(`z${n}`));return IS(e)}class Uae{constructor(e){h(this,"map");if(this.map=new Map,e!=null)for(const[t,r]of e.entries())this.map.set(t.toString(),{key:t,value:r})}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(e){return this.map.delete(e.toString())}entries(){return qh(this.map.entries(),e=>[e[1].key,e[1].value])}forEach(e){this.map.forEach((t,r)=>{e(t.value,t.key,this)})}get(e){var t;return(t=this.map.get(e.toString()))==null?void 0:t.value}has(e){return this.map.has(e.toString())}set(e,t){this.map.set(e.toString(),{key:e,value:t})}keys(){return qh(this.map.values(),e=>e.key)}values(){return qh(this.map.values(),e=>e.value)}get size(){return this.map.size}}class Kh{constructor(e){h(this,"set");if(this.set=new Set,e!=null)for(const t of e)this.set.add(t.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(e){this.set.add(e.toString())}clear(){this.set.clear()}delete(e){this.set.delete(e.toString())}entries(){return qh(this.set.entries(),e=>{const t=q0(e[0]);return[t,t]})}forEach(e){this.set.forEach(t=>{const r=q0(t);e(r,r,this)})}has(e){return this.set.has(e.toString())}values(){return qh(this.set.values(),e=>q0(e))}intersection(e){const t=new Kh;for(const r of e)this.has(r)&&t.add(r);return t}difference(e){const t=new Kh;for(const r of this)e.has(r)||t.add(r);return t}union(e){const t=new Kh;for(const r of e)t.add(r);for(const r of this)t.add(r);return t}}let Bae=class extends Error{constructor(e){super(e),this.name="TimeoutError"}};class kae extends Error{constructor(e){super(),this.name="AbortError",this.message=e}}const L2=n=>globalThis.DOMException===void 0?new kae(n):new DOMException(n),O2=n=>{const e=n.reason===void 0?L2("This operation was aborted."):n.reason;return e instanceof Error?e:L2(e)};function $ae(n,e){const{milliseconds:t,fallback:r,message:i,customTimers:s={setTimeout,clearTimeout}}=e;let o,a;const l=new Promise((u,d)=>{if(typeof t!="number"||Math.sign(t)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${t}\``);if(e.signal){const{signal:p}=e;p.aborted&&d(O2(p)),a=()=>{d(O2(p))},p.addEventListener("abort",a,{once:!0})}if(t===Number.POSITIVE_INFINITY){n.then(u,d);return}const f=new Bae;o=s.setTimeout.call(void 0,()=>{if(r){try{u(r())}catch(p){d(p)}return}typeof n.cancel=="function"&&n.cancel(),i===!1?u():i instanceof Error?d(i):(f.message=i??`Promise timed out after ${t} milliseconds`,d(f))},t),(async()=>{try{u(await n)}catch(p){d(p)}})()}).finally(()=>{l.clear(),a&&e.signal&&e.signal.removeEventListener("abort",a)});return l.clear=()=>{s.clearTimeout.call(void 0,o),o=void 0},l}const Fae=n=>{const e=n.addEventListener||n.on||n.addListener,t=n.removeEventListener||n.off||n.removeListener;if(!e||!t)throw new TypeError("Emitter is not compatible");return{addListener:e.bind(n),removeListener:t.bind(n)}};function zae(n,e,t){let r;const i=new Promise((s,o)=>{var p;if(t={rejectionEvents:["error"],multiArgs:!1,rejectionMultiArgs:!1,resolveImmediately:!1,...t},!(t.count>=0&&(t.count===Number.POSITIVE_INFINITY||Number.isInteger(t.count))))throw new TypeError("The `count` option should be at least 0 or more");(p=t.signal)==null||p.throwIfAborted();const a=[e].flat(),c=[],{addListener:l,removeListener:u}=Fae(n),d=async(...g)=>{const b=t.multiArgs?g:g[0];if(t.filter)try{if(!await t.filter(b))return}catch(m){r(),o(m);return}c.push(b),t.count===c.length&&(r(),s(c))},f=(...g)=>{r(),o(t.rejectionMultiArgs?g:g[0])};r=()=>{for(const g of a)u(g,d);for(const g of t.rejectionEvents)a.includes(g)||u(g,f)};for(const g of a)l(g,d);for(const g of t.rejectionEvents)a.includes(g)||l(g,f);t.signal&&t.signal.addEventListener("abort",()=>{f(t.signal.reason)},{once:!0}),t.resolveImmediately&&s(c)});if(i.cancel=r,typeof t.timeout=="number"){const s=$ae(i,{milliseconds:t.timeout});return s.cancel=()=>{r(),s.clear()},s}return i}function Vae(n,e,t){typeof t=="function"&&(t={filter:t}),t={...t,count:1,resolveImmediately:!1};const r=zae(n,e,t),i=r.then(s=>s[0]);return i.cancel=r.cancel,i}class Ad extends Error{constructor(){super(...arguments);h(this,"name","UnexpectedEOFError")}}h(Ad,"name","UnexpectedEOFError");function Hae(n){return n.reason}async function Gae(n,e,t){if(e==null)return n;const r=Hae;if(e.aborted)return n.catch(()=>{}),Promise.reject(r(e));let i;try{return await Promise.race([n,new Promise((s,o)=>{i=()=>{o(r(e))},e.addEventListener("abort",i)})])}finally{i!=null&&e.removeEventListener("abort",i)}}const Wae=4194304;class v_ extends Error{constructor(){super(...arguments);h(this,"name","UnwrappedError")}}h(v_,"name","UnwrappedError");class qae extends Error{constructor(){super(...arguments);h(this,"name","InvalidMessageLengthError");h(this,"code","ERR_INVALID_MSG_LENGTH")}}class Kae extends Error{constructor(){super(...arguments);h(this,"name","InvalidDataLengthError");h(this,"code","ERR_MSG_DATA_TOO_LONG")}}class Xae extends Error{constructor(){super(...arguments);h(this,"name","InvalidDataLengthLengthError");h(this,"code","ERR_MSG_LENGTH_TOO_LONG")}}function Yae(n){return typeof(n==null?void 0:n.closeRead)=="function"}function Zae(n){return typeof(n==null?void 0:n.close)=="function"}function K0(n){return Yae(n)?n.remoteWriteStatus!=="writable"&&n.readBufferLength===0:Zae(n)?n.status!=="open":!1}function jae(n){return(n==null?void 0:n.addEventListener)!=null&&(n==null?void 0:n.removeEventListener)!=null&&(n==null?void 0:n.send)!=null&&(n==null?void 0:n.push)!=null&&(n==null?void 0:n.log)!=null}function Jae(n,e){const t=(e==null?void 0:e.maxBufferSize)??Wae,r=new Tn;let i,s=!1;if(!jae(n))throw new dc("Argument should be a Stream or a Multiaddr");const o=u=>{if(r.append(u.data),r.byteLength>t){const d=r.byteLength;r.consume(r.byteLength),i==null||i.reject(new Error(`Read buffer overflow - ${d} > ${t}`))}i==null||i.resolve()};n.addEventListener("message",o);const a=u=>{u.error!=null?i==null||i.reject(u.error):i==null||i.resolve()};n.addEventListener("close",a);const c=()=>{i==null||i.resolve()};n.addEventListener("remoteCloseWrite",c);const l={readBuffer:r,async read(u){if(s===!0)throw new v_("Stream was unwrapped");if(K0(n)){if((u==null?void 0:u.bytes)==null)return null;if(r.byteLength<u.bytes)throw n.log.error("closed after reading %d/%d bytes",r.byteLength,u.bytes),new Ad(`Unexpected EOF - stream closed after reading ${r.byteLength}/${u.bytes} bytes`)}const d=(u==null?void 0:u.bytes)??1;for(i=Promise.withResolvers();;){if(r.byteLength>=d){i.resolve();break}if(await Gae(i.promise,u==null?void 0:u.signal),K0(n)){if(r.byteLength===0&&(u==null?void 0:u.bytes)==null)return null;break}i=Promise.withResolvers()}const f=(u==null?void 0:u.bytes)??r.byteLength;if(r.byteLength<f){if(K0(n))throw n.log.error("closed while reading %d/%d bytes",r.byteLength,f),new Ad(`Unexpected EOF - stream closed while reading ${r.byteLength}/${f} bytes`);return l.read(u)}const p=r.sublist(0,f);return r.consume(f),p},async write(u,d){if(s===!0)throw new v_("Stream was unwrapped");n.send(u)||await Vae(n,"drain",{signal:d==null?void 0:d.signal,rejectionEvents:["close"]})},unwrap(){return s||(s=!0,n.removeEventListener("message",o),n.removeEventListener("close",a),n.removeEventListener("remoteCloseWrite",c),r.byteLength>0&&(n.log("stream unwrapped with %d unread bytes",r.byteLength),n.push(r))),n}};return l}function Qae(n,e={}){const t=Jae(n,e);e.maxDataLength!=null&&e.maxLengthLength==null&&(e.maxLengthLength=Vu(e.maxDataLength));const r=(e==null?void 0:e.lengthDecoder)??koe,i=(e==null?void 0:e.lengthEncoder)??Boe;return{async read(o){let a=-1;const c=new Tn;for(;;){const u=await t.read({...o,bytes:1});if(u==null)break;c.append(u);try{a=r(c)}catch(d){if(d instanceof RangeError)continue;throw d}if(a<0)throw new qae("Invalid message length");if((e==null?void 0:e.maxLengthLength)!=null&&c.byteLength>e.maxLengthLength)throw new Xae(`Message length length too long - ${c.byteLength} > ${e.maxLengthLength}`);if(a>-1)break}if((e==null?void 0:e.maxDataLength)!=null&&a>e.maxDataLength)throw new Kae(`Message length too long - ${a} > ${e.maxDataLength}`);const l=await t.read({...o,bytes:a});if(l==null)throw n.log.error("tried to read %d bytes but the stream closed",a),new Ad(`Unexpected EOF - tried to read ${a} bytes but the stream closed`);if(l.byteLength!==a)throw n.log.error("read %d/%d bytes before the stream closed",l.byteLength,a),new Ad(`Unexpected EOF - read ${l.byteLength}/${a} bytes before the stream closed`);return l},async write(o,a){await t.write(new Tn(i(o.byteLength),o),a)},async writeV(o,a){const c=new Tn(...o.flatMap(l=>[i(l.byteLength),l]));await t.write(c,a)},unwrap(){return t.unwrap()}}}function N2(n,e){const t=Qae(n,e),r={read:async(i,s)=>{const o=await t.read(s);return i.decode(o)},write:async(i,s,o)=>{await t.write(s.encode(i),o)},writeV:async(i,s,o)=>{await t.writeV(i.map(a=>s.encode(a)),o)},pb:i=>({read:async s=>r.read(i,s),write:async(s,o)=>r.write(s,i,o),writeV:async(s,o)=>r.writeV(s,i,o),unwrap:()=>r}),unwrap:()=>t.unwrap()};return r}var X0={exports:{}},U2;function ece(){return U2||(U2=1,(function(n){var e=Object.prototype.hasOwnProperty,t="~";function r(){}Object.create&&(r.prototype=Object.create(null),new r().__proto__||(t=!1));function i(c,l,u){this.fn=c,this.context=l,this.once=u||!1}function s(c,l,u,d,f){if(typeof u!="function")throw new TypeError("The listener must be a function");var p=new i(u,d||c,f),g=t?t+l:l;return c._events[g]?c._events[g].fn?c._events[g]=[c._events[g],p]:c._events[g].push(p):(c._events[g]=p,c._eventsCount++),c}function o(c,l){--c._eventsCount===0?c._events=new r:delete c._events[l]}function a(){this._events=new r,this._eventsCount=0}a.prototype.eventNames=function(){var l=[],u,d;if(this._eventsCount===0)return l;for(d in u=this._events)e.call(u,d)&&l.push(t?d.slice(1):d);return Object.getOwnPropertySymbols?l.concat(Object.getOwnPropertySymbols(u)):l},a.prototype.listeners=function(l){var u=t?t+l:l,d=this._events[u];if(!d)return[];if(d.fn)return[d.fn];for(var f=0,p=d.length,g=new Array(p);f<p;f++)g[f]=d[f].fn;return g},a.prototype.listenerCount=function(l){var u=t?t+l:l,d=this._events[u];return d?d.fn?1:d.length:0},a.prototype.emit=function(l,u,d,f,p,g){var b=t?t+l:l;if(!this._events[b])return!1;var m=this._events[b],y=arguments.length,E,w;if(m.fn){switch(m.once&&this.removeListener(l,m.fn,void 0,!0),y){case 1:return m.fn.call(m.context),!0;case 2:return m.fn.call(m.context,u),!0;case 3:return m.fn.call(m.context,u,d),!0;case 4:return m.fn.call(m.context,u,d,f),!0;case 5:return m.fn.call(m.context,u,d,f,p),!0;case 6:return m.fn.call(m.context,u,d,f,p,g),!0}for(w=1,E=new Array(y-1);w<y;w++)E[w-1]=arguments[w];m.fn.apply(m.context,E)}else{var x=m.length,M;for(w=0;w<x;w++)switch(m[w].once&&this.removeListener(l,m[w].fn,void 0,!0),y){case 1:m[w].fn.call(m[w].context);break;case 2:m[w].fn.call(m[w].context,u);break;case 3:m[w].fn.call(m[w].context,u,d);break;case 4:m[w].fn.call(m[w].context,u,d,f);break;default:if(!E)for(M=1,E=new Array(y-1);M<y;M++)E[M-1]=arguments[M];m[w].fn.apply(m[w].context,E)}}return!0},a.prototype.on=function(l,u,d){return s(this,l,u,d,!1)},a.prototype.once=function(l,u,d){return s(this,l,u,d,!0)},a.prototype.removeListener=function(l,u,d,f){var p=t?t+l:l;if(!this._events[p])return this;if(!u)return o(this,p),this;var g=this._events[p];if(g.fn)g.fn===u&&(!f||g.once)&&(!d||g.context===d)&&o(this,p);else{for(var b=0,m=[],y=g.length;b<y;b++)(g[b].fn!==u||f&&!g[b].once||d&&g[b].context!==d)&&m.push(g[b]);m.length?this._events[p]=m.length===1?m[0]:m:o(this,p)}return this},a.prototype.removeAllListeners=function(l){var u;return l?(u=t?t+l:l,this._events[u]&&o(this,u)):(this._events=new r,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=t,a.EventEmitter=a,n.exports=a})(X0)),X0.exports}var tce=ece();const nce=kE(tce);let rce=class BO extends Error{constructor(t,r){var i;super(t,r);h(this,"name","TimeoutError");(i=Error.captureStackTrace)==null||i.call(Error,this,BO)}};const B2=n=>n.reason??new DOMException("This operation was aborted.","AbortError");function ice(n,e){const{milliseconds:t,fallback:r,message:i,customTimers:s={setTimeout,clearTimeout},signal:o}=e;let a,c;const u=new Promise((d,f)=>{if(typeof t!="number"||Math.sign(t)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${t}\``);if(o!=null&&o.aborted){f(B2(o));return}if(o&&(c=()=>{f(B2(o))},o.addEventListener("abort",c,{once:!0})),n.then(d,f),t===Number.POSITIVE_INFINITY)return;const p=new rce;a=s.setTimeout.call(void 0,()=>{if(r){try{d(r())}catch(g){f(g)}return}typeof n.cancel=="function"&&n.cancel(),i===!1?d():i instanceof Error?f(i):(p.message=i??`Promise timed out after ${t} milliseconds`,f(p))},t)}).finally(()=>{u.clear(),c&&o&&o.removeEventListener("abort",c)});return u.clear=()=>{s.clearTimeout.call(void 0,a),a=void 0},u}function sce(n,e,t){let r=0,i=n.length;for(;i>0;){const s=Math.trunc(i/2);let o=r+s;t(n[o],e)<=0?(r=++o,i-=s+1):i=s}return r}var qr;class oce{constructor(){me(this,qr,[])}enqueue(e,t){const{priority:r=0,id:i}=t??{},s={priority:r,id:i,run:e};if(this.size===0||D(this,qr)[this.size-1].priority>=r){D(this,qr).push(s);return}const o=sce(D(this,qr),s,(a,c)=>c.priority-a.priority);D(this,qr).splice(o,0,s)}setPriority(e,t){const r=D(this,qr).findIndex(s=>s.id===e);if(r===-1)throw new ReferenceError(`No promise function with the id "${e}" exists in the queue.`);const[i]=D(this,qr).splice(r,1);this.enqueue(i.run,{priority:t,id:e})}dequeue(){const e=D(this,qr).shift();return e==null?void 0:e.run}filter(e){return D(this,qr).filter(t=>t.priority===e.priority).map(t=>t.run)}get size(){return D(this,qr).length}}qr=new WeakMap;var Fl,Ai,Ji,zl,Vl,Hl,No,qd,Gl,Qi,Ns,Qt,Kd,Xn,Ua,Us,_g,Ba,De,kO,$O,FO,zO,VO,__,E_,HO,qp,S_,x_,Kp,ba,GO,Ph,T_;class ace extends nce{constructor(t){var r,i;super();me(this,De);me(this,Fl);me(this,Ai);me(this,Ji,0);me(this,zl);me(this,Vl,!1);me(this,Hl,!1);me(this,No);me(this,qd,0);me(this,Gl,0);me(this,Qi);me(this,Ns);me(this,Qt);me(this,Kd);me(this,Xn,0);me(this,Ua);me(this,Us);me(this,_g,1n);me(this,Ba,new Map);h(this,"timeout");if(t={carryoverIntervalCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:oce,...t},!(typeof t.intervalCap=="number"&&t.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${((r=t.intervalCap)==null?void 0:r.toString())??""}\` (${typeof t.intervalCap})`);if(t.interval===void 0||!(Number.isFinite(t.interval)&&t.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${((i=t.interval)==null?void 0:i.toString())??""}\` (${typeof t.interval})`);if(pe(this,Fl,t.carryoverIntervalCount??t.carryoverConcurrencyCount??!1),pe(this,Ai,t.intervalCap===Number.POSITIVE_INFINITY||t.interval===0),pe(this,zl,t.intervalCap),pe(this,No,t.interval),pe(this,Qt,new t.queueClass),pe(this,Kd,t.queueClass),this.concurrency=t.concurrency,t.timeout!==void 0&&!(Number.isFinite(t.timeout)&&t.timeout>0))throw new TypeError(`Expected \`timeout\` to be a positive finite number, got \`${t.timeout}\` (${typeof t.timeout})`);this.timeout=t.timeout,pe(this,Us,t.autoStart===!1),ue(this,De,GO).call(this)}get concurrency(){return D(this,Ua)}set concurrency(t){if(!(typeof t=="number"&&t>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${t}\` (${typeof t})`);pe(this,Ua,t),ue(this,De,Kp).call(this)}setPriority(t,r){if(typeof r!="number"||!Number.isFinite(r))throw new TypeError(`Expected \`priority\` to be a finite number, got \`${r}\` (${typeof r})`);D(this,Qt).setPriority(t,r)}async add(t,r={}){return r.id??(r.id=(di(this,_g)._++).toString()),r={timeout:this.timeout,...r},new Promise((i,s)=>{const o=Symbol(`task-${r.id}`);D(this,Qt).enqueue(async()=>{var c,l;di(this,Xn)._++,D(this,Ba).set(o,{id:r.id,priority:r.priority??0,startTime:Date.now(),timeout:r.timeout});let a;try{try{(c=r.signal)==null||c.throwIfAborted()}catch(f){throw D(this,Ai)||di(this,Ji)._--,D(this,Ba).delete(o),f}let u=t({signal:r.signal});if(r.timeout&&(u=ice(Promise.resolve(u),{milliseconds:r.timeout,message:`Task timed out after ${r.timeout}ms (queue has ${D(this,Xn)} running, ${D(this,Qt).size} waiting)`})),r.signal){const{signal:f}=r;u=Promise.race([u,new Promise((p,g)=>{a=()=>{g(f.reason)},f.addEventListener("abort",a,{once:!0})})])}const d=await u;i(d),this.emit("completed",d)}catch(u){s(u),this.emit("error",u)}finally{a&&((l=r.signal)==null||l.removeEventListener("abort",a)),D(this,Ba).delete(o),queueMicrotask(()=>{ue(this,De,FO).call(this)})}},r),this.emit("add"),ue(this,De,qp).call(this)})}async addAll(t,r){return Promise.all(t.map(async i=>this.add(i,r)))}start(){return D(this,Us)?(pe(this,Us,!1),ue(this,De,Kp).call(this),this):this}pause(){pe(this,Us,!0)}clear(){pe(this,Qt,new(D(this,Kd))),ue(this,De,T_).call(this)}async onEmpty(){D(this,Qt).size!==0&&await ue(this,De,ba).call(this,"empty")}async onSizeLessThan(t){D(this,Qt).size<t||await ue(this,De,ba).call(this,"next",()=>D(this,Qt).size<t)}async onIdle(){D(this,Xn)===0&&D(this,Qt).size===0||await ue(this,De,ba).call(this,"idle")}async onPendingZero(){D(this,Xn)!==0&&await ue(this,De,ba).call(this,"pendingZero")}async onRateLimit(){this.isRateLimited||await ue(this,De,ba).call(this,"rateLimit")}async onRateLimitCleared(){this.isRateLimited&&await ue(this,De,ba).call(this,"rateLimitCleared")}async onError(){return new Promise((t,r)=>{const i=s=>{this.off("error",i),r(s)};this.on("error",i)})}get size(){return D(this,Qt).size}sizeBy(t){return D(this,Qt).filter(t).length}get pending(){return D(this,Xn)}get isPaused(){return D(this,Us)}get isRateLimited(){return D(this,Vl)}get isSaturated(){return D(this,Xn)===D(this,Ua)&&D(this,Qt).size>0||this.isRateLimited&&D(this,Qt).size>0}get runningTasks(){return[...D(this,Ba).values()].map(t=>({...t}))}}Fl=new WeakMap,Ai=new WeakMap,Ji=new WeakMap,zl=new WeakMap,Vl=new WeakMap,Hl=new WeakMap,No=new WeakMap,qd=new WeakMap,Gl=new WeakMap,Qi=new WeakMap,Ns=new WeakMap,Qt=new WeakMap,Kd=new WeakMap,Xn=new WeakMap,Ua=new WeakMap,Us=new WeakMap,_g=new WeakMap,Ba=new WeakMap,De=new WeakSet,kO=function(){return D(this,Ai)||D(this,Ji)<D(this,zl)},$O=function(){return D(this,Xn)<D(this,Ua)},FO=function(){di(this,Xn)._--,D(this,Xn)===0&&this.emit("pendingZero"),ue(this,De,qp).call(this),this.emit("next")},zO=function(){ue(this,De,x_).call(this),ue(this,De,S_).call(this),pe(this,Ns,void 0)},VO=function(){const t=Date.now();if(D(this,Qi)===void 0){const r=D(this,qd)-t;if(r<0){if(D(this,Gl)>0){const i=t-D(this,Gl);if(i<D(this,No))return ue(this,De,__).call(this,D(this,No)-i),!0}pe(this,Ji,D(this,Fl)?D(this,Xn):0)}else return ue(this,De,__).call(this,r),!0}return!1},__=function(t){D(this,Ns)===void 0&&pe(this,Ns,setTimeout(()=>{ue(this,De,zO).call(this)},t))},E_=function(){D(this,Qi)&&(clearInterval(D(this,Qi)),pe(this,Qi,void 0))},HO=function(){D(this,Ns)&&(clearTimeout(D(this,Ns)),pe(this,Ns,void 0))},qp=function(){if(D(this,Qt).size===0)return ue(this,De,E_).call(this),this.emit("empty"),D(this,Xn)===0&&(ue(this,De,HO).call(this),this.emit("idle")),!1;let t=!1;if(!D(this,Us)){const r=!D(this,De,VO);if(D(this,De,kO)&&D(this,De,$O)){const i=D(this,Qt).dequeue();D(this,Ai)||(di(this,Ji)._++,ue(this,De,Ph).call(this)),this.emit("active"),pe(this,Gl,Date.now()),i(),r&&ue(this,De,S_).call(this),t=!0}}return t},S_=function(){D(this,Ai)||D(this,Qi)!==void 0||(pe(this,Qi,setInterval(()=>{ue(this,De,x_).call(this)},D(this,No))),pe(this,qd,Date.now()+D(this,No)))},x_=function(){D(this,Ji)===0&&D(this,Xn)===0&&D(this,Qi)&&ue(this,De,E_).call(this),pe(this,Ji,D(this,Fl)?D(this,Xn):0),ue(this,De,Kp).call(this),ue(this,De,Ph).call(this)},Kp=function(){for(;ue(this,De,qp).call(this););},ba=async function(t,r){return new Promise(i=>{const s=()=>{r&&!r()||(this.off(t,s),i())};this.on(t,s)})},GO=function(){D(this,Ai)||(this.on("add",()=>{D(this,Qt).size>0&&ue(this,De,Ph).call(this)}),this.on("next",()=>{ue(this,De,Ph).call(this)}))},Ph=function(){D(this,Ai)||D(this,Hl)||(pe(this,Hl,!0),queueMicrotask(()=>{pe(this,Hl,!1),ue(this,De,T_).call(this)}))},T_=function(){const t=D(this,Vl),r=!D(this,Ai)&&D(this,Ji)>=D(this,zl)&&D(this,Qt).size>0;r!==t&&(pe(this,Vl,r),this.emit(r?"rateLimit":"rateLimitCleared"))};class cce{constructor(e){h(this,"entries");h(this,"validityMs");h(this,"lastPruneTime",0);this.entries=new Map,this.validityMs=e.validityMs}put(e,t){this.entries.set(e,{value:t,validUntilMs:Date.now()+this.validityMs}),this.prune()}prune(){const e=Date.now();if(!(e-this.lastPruneTime<200)){this.lastPruneTime=e;for(const[t,r]of this.entries.entries())if(r.validUntilMs<e)this.entries.delete(t);else break}}has(e){return this.entries.has(e)}get(e){const t=this.entries.get(e);return t!=null&&t.validUntilMs>=Date.now()?t.value:void 0}clear(){this.entries=new Map,this.lastPruneTime=0}}var Md;(function(n){(function(t){let r;t.codec=()=>(r==null&&(r=ki((i,s,o={})=>{o.lengthDelimited!==!1&&s.fork(),i.subscribe!=null&&(s.uint32(8),s.bool(i.subscribe)),i.topic!=null&&(s.uint32(18),s.string(i.topic)),o.lengthDelimited!==!1&&s.ldelim()},(i,s,o={})=>{const a={},c=s==null?i.len:i.pos+s;for(;i.pos<c;){const l=i.uint32();switch(l>>>3){case 1:{a.subscribe=i.bool();break}case 2:{a.topic=i.string();break}default:{i.skipType(l&7);break}}}return a})),r),t.encode=i=>Bi(i,t.codec()),t.decode=(i,s)=>Ui(i,t.codec(),s)})(n.SubOpts||(n.SubOpts={})),(function(t){let r;t.codec=()=>(r==null&&(r=ki((i,s,o={})=>{o.lengthDelimited!==!1&&s.fork(),i.from!=null&&(s.uint32(10),s.bytes(i.from)),i.data!=null&&(s.uint32(18),s.bytes(i.data)),i.sequenceNumber!=null&&(s.uint32(26),s.bytes(i.sequenceNumber)),i.topic!=null&&(s.uint32(34),s.string(i.topic)),i.signature!=null&&(s.uint32(42),s.bytes(i.signature)),i.key!=null&&(s.uint32(50),s.bytes(i.key)),o.lengthDelimited!==!1&&s.ldelim()},(i,s,o={})=>{const a={},c=s==null?i.len:i.pos+s;for(;i.pos<c;){const l=i.uint32();switch(l>>>3){case 1:{a.from=i.bytes();break}case 2:{a.data=i.bytes();break}case 3:{a.sequenceNumber=i.bytes();break}case 4:{a.topic=i.string();break}case 5:{a.signature=i.bytes();break}case 6:{a.key=i.bytes();break}default:{i.skipType(l&7);break}}}return a})),r),t.encode=i=>Bi(i,t.codec()),t.decode=(i,s)=>Ui(i,t.codec(),s)})(n.Message||(n.Message={}));let e;n.codec=()=>(e==null&&(e=ki((t,r,i={})=>{if(i.lengthDelimited!==!1&&r.fork(),t.subscriptions!=null)for(const s of t.subscriptions)r.uint32(10),n.SubOpts.codec().encode(s,r);if(t.messages!=null)for(const s of t.messages)r.uint32(18),n.Message.codec().encode(s,r);t.control!=null&&(r.uint32(26),eg.codec().encode(t.control,r)),i.lengthDelimited!==!1&&r.ldelim()},(t,r,i={})=>{var a,c,l,u,d;const s={subscriptions:[],messages:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const f=t.uint32();switch(f>>>3){case 1:{if(((a=i.limits)==null?void 0:a.subscriptions)!=null&&s.subscriptions.length===i.limits.subscriptions)throw new Fs('Decode error - map field "subscriptions" had too many elements');s.subscriptions.push(n.SubOpts.codec().decode(t,t.uint32(),{limits:(c=i.limits)==null?void 0:c.subscriptions$}));break}case 2:{if(((l=i.limits)==null?void 0:l.messages)!=null&&s.messages.length===i.limits.messages)throw new Fs('Decode error - map field "messages" had too many elements');s.messages.push(n.Message.codec().decode(t,t.uint32(),{limits:(u=i.limits)==null?void 0:u.messages$}));break}case 3:{s.control=eg.codec().decode(t,t.uint32(),{limits:(d=i.limits)==null?void 0:d.control});break}default:{t.skipType(f&7);break}}}return s})),e),n.encode=t=>Bi(t,n.codec()),n.decode=(t,r)=>Ui(t,n.codec(),r)})(Md||(Md={}));var eg;(function(n){let e;n.codec=()=>(e==null&&(e=ki((t,r,i={})=>{if(i.lengthDelimited!==!1&&r.fork(),t.ihave!=null)for(const s of t.ihave)r.uint32(10),tg.codec().encode(s,r);if(t.iwant!=null)for(const s of t.iwant)r.uint32(18),ng.codec().encode(s,r);if(t.graft!=null)for(const s of t.graft)r.uint32(26),rg.codec().encode(s,r);if(t.prune!=null)for(const s of t.prune)r.uint32(34),ig.codec().encode(s,r);i.lengthDelimited!==!1&&r.ldelim()},(t,r,i={})=>{var a,c,l,u,d,f,p,g;const s={ihave:[],iwant:[],graft:[],prune:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const b=t.uint32();switch(b>>>3){case 1:{if(((a=i.limits)==null?void 0:a.ihave)!=null&&s.ihave.length===i.limits.ihave)throw new Fs('Decode error - map field "ihave" had too many elements');s.ihave.push(tg.codec().decode(t,t.uint32(),{limits:(c=i.limits)==null?void 0:c.ihave$}));break}case 2:{if(((l=i.limits)==null?void 0:l.iwant)!=null&&s.iwant.length===i.limits.iwant)throw new Fs('Decode error - map field "iwant" had too many elements');s.iwant.push(ng.codec().decode(t,t.uint32(),{limits:(u=i.limits)==null?void 0:u.iwant$}));break}case 3:{if(((d=i.limits)==null?void 0:d.graft)!=null&&s.graft.length===i.limits.graft)throw new Fs('Decode error - map field "graft" had too many elements');s.graft.push(rg.codec().decode(t,t.uint32(),{limits:(f=i.limits)==null?void 0:f.graft$}));break}case 4:{if(((p=i.limits)==null?void 0:p.prune)!=null&&s.prune.length===i.limits.prune)throw new Fs('Decode error - map field "prune" had too many elements');s.prune.push(ig.codec().decode(t,t.uint32(),{limits:(g=i.limits)==null?void 0:g.prune$}));break}default:{t.skipType(b&7);break}}}return s})),e),n.encode=t=>Bi(t,n.codec()),n.decode=(t,r)=>Ui(t,n.codec(),r)})(eg||(eg={}));var tg;(function(n){let e;n.codec=()=>(e==null&&(e=ki((t,r,i={})=>{if(i.lengthDelimited!==!1&&r.fork(),t.topic!=null&&(r.uint32(10),r.string(t.topic)),t.messageIDs!=null)for(const s of t.messageIDs)r.uint32(18),r.bytes(s);i.lengthDelimited!==!1&&r.ldelim()},(t,r,i={})=>{var a;const s={messageIDs:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const c=t.uint32();switch(c>>>3){case 1:{s.topic=t.string();break}case 2:{if(((a=i.limits)==null?void 0:a.messageIDs)!=null&&s.messageIDs.length===i.limits.messageIDs)throw new Fs('Decode error - map field "messageIDs" had too many elements');s.messageIDs.push(t.bytes());break}default:{t.skipType(c&7);break}}}return s})),e),n.encode=t=>Bi(t,n.codec()),n.decode=(t,r)=>Ui(t,n.codec(),r)})(tg||(tg={}));var ng;(function(n){let e;n.codec=()=>(e==null&&(e=ki((t,r,i={})=>{if(i.lengthDelimited!==!1&&r.fork(),t.messageIDs!=null)for(const s of t.messageIDs)r.uint32(10),r.bytes(s);i.lengthDelimited!==!1&&r.ldelim()},(t,r,i={})=>{var a;const s={messageIDs:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const c=t.uint32();switch(c>>>3){case 1:{if(((a=i.limits)==null?void 0:a.messageIDs)!=null&&s.messageIDs.length===i.limits.messageIDs)throw new Fs('Decode error - map field "messageIDs" had too many elements');s.messageIDs.push(t.bytes());break}default:{t.skipType(c&7);break}}}return s})),e),n.encode=t=>Bi(t,n.codec()),n.decode=(t,r)=>Ui(t,n.codec(),r)})(ng||(ng={}));var rg;(function(n){let e;n.codec=()=>(e==null&&(e=ki((t,r,i={})=>{i.lengthDelimited!==!1&&r.fork(),t.topic!=null&&(r.uint32(10),r.string(t.topic)),i.lengthDelimited!==!1&&r.ldelim()},(t,r,i={})=>{const s={},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.topic=t.string();break}default:{t.skipType(a&7);break}}}return s})),e),n.encode=t=>Bi(t,n.codec()),n.decode=(t,r)=>Ui(t,n.codec(),r)})(rg||(rg={}));var ig;(function(n){let e;n.codec=()=>(e==null&&(e=ki((t,r,i={})=>{if(i.lengthDelimited!==!1&&r.fork(),t.topic!=null&&(r.uint32(10),r.string(t.topic)),t.peers!=null)for(const s of t.peers)r.uint32(18),sg.codec().encode(s,r);t.backoff!=null&&(r.uint32(24),r.uint64(t.backoff)),i.lengthDelimited!==!1&&r.ldelim()},(t,r,i={})=>{var a,c;const s={peers:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const l=t.uint32();switch(l>>>3){case 1:{s.topic=t.string();break}case 2:{if(((a=i.limits)==null?void 0:a.peers)!=null&&s.peers.length===i.limits.peers)throw new Fs('Decode error - map field "peers" had too many elements');s.peers.push(sg.codec().decode(t,t.uint32(),{limits:(c=i.limits)==null?void 0:c.peers$}));break}case 3:{s.backoff=t.uint64();break}default:{t.skipType(l&7);break}}}return s})),e),n.encode=t=>Bi(t,n.codec()),n.decode=(t,r)=>Ui(t,n.codec(),r)})(ig||(ig={}));var sg;(function(n){let e;n.codec=()=>(e==null&&(e=ki((t,r,i={})=>{i.lengthDelimited!==!1&&r.fork(),t.peerID!=null&&(r.uint32(10),r.bytes(t.peerID)),t.signedPeerRecord!=null&&(r.uint32(18),r.bytes(t.signedPeerRecord)),i.lengthDelimited!==!1&&r.ldelim()},(t,r,i={})=>{const s={},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.peerID=t.bytes();break}case 2:{s.signedPeerRecord=t.bytes();break}default:{t.skipType(a&7);break}}}return s})),e),n.encode=t=>Bi(t,n.codec()),n.decode=(t,r)=>Ui(t,n.codec(),r)})(sg||(sg={}));class lce extends N3{constructor(t){super();h(this,"peerId");h(this,"shutDownController");h(this,"inboundPb");h(this,"outboundPb");this.peerId=t,this.shutDownController=new AbortController}attachInboundStream(t,r){this.inboundPb=N2(t,r).pb(Md),Promise.resolve().then(async()=>{for(;;){if(this.inboundPb==null)return;const i=await this.inboundPb.read({signal:this.shutDownController.signal});this.safeDispatchEvent("message",{detail:i})}}).catch(i=>{var s;(s=this.inboundPb)==null||s.unwrap().unwrap().abort(i)})}attachOutboundStream(t,r){this.outboundPb=N2(t,r).pb(Md)}write(t){this.outboundPb!=null&&this.outboundPb.write(t,{signal:this.shutDownController.signal}).catch(r=>{var i;(i=this.outboundPb)==null||i.unwrap().unwrap().abort(r)})}close(){var t,r;this.shutDownController.abort(),Promise.all([(t=this.inboundPb)==null?void 0:t.unwrap().unwrap().close().catch(i=>{var s;(s=this.inboundPb)==null||s.unwrap().unwrap().abort(i)}),(r=this.outboundPb)==null?void 0:r.unwrap().unwrap().close().catch(i=>{var s;(s=this.inboundPb)==null||s.unwrap().unwrap().abort(i)})]).finally(()=>{this.safeDispatchEvent("close")})}}function uce(){return BigInt(`0x${Or(oae(8),"base16")}`)}const hce=(n,e)=>{const t=io(e.toString(16).padStart(16,"0"),"base16"),r=cf(n),i=new Uint8Array(r.byteLength+t.length);return i.set(r,0),i.set(t,r.byteLength),i},dce=n=>pS.encode(n),fce=async n=>{if(n.sequenceNumber==null||n.from==null||n.signature==null)return!1;const e=IS(Kg(n.from));if(e.publicKey!=null)return!0;if(n.key!=null){const t=n.key;return UO(DO(t)).equals(e)}return!1},pce=async n=>{if(n.from==null)throw new vn("RPC message was missing from");if(!await fce(n))return{type:"unsigned",topic:n.topic??"",data:n.data??new Uint8Array(0)};const e=IS(Kg(n.from)),t=n.key??e.publicKey;if(t==null)throw new vn("RPC message was missing public key");return{type:"signed",from:e,topic:n.topic??"",sequenceNumber:gce(n.sequenceNumber??new Uint8Array(0)),data:n.data??new Uint8Array(0),signature:n.signature??new Uint8Array(0),key:t instanceof Uint8Array?DO(t):t}},PS=n=>n.type==="signed"?{from:n.from.toMultihash().bytes,data:n.data,sequenceNumber:mce(n.sequenceNumber),topic:n.topic,signature:n.signature,key:n.key?cf(n.key):void 0}:{data:n.data,topic:n.topic},mce=n=>{let e=n.toString(16);return e.length%2!==0&&(e=`0${e}`),io(e,"base16")},gce=n=>BigInt(`0x${Or(n,"base16")}`),WO=io("libp2p-pubsub:");async function yce(n,e,t){const r={type:"signed",topic:e.topic,data:e.data,sequenceNumber:e.sequenceNumber,from:Lae(n)},i=Xm([WO,t(PS(r)).subarray()]);return r.signature=await n.sign(i),r.key=n.publicKey,r}async function bce(n,e){if(n.type!=="signed")throw new Error('Message type must be "signed" to be verified');if(n.signature==null)throw new Error("Message must contain a signature to be verified");if(n.from==null)throw new Error("Message must contain a from property to be verified");const t=Xm([WO,e({...PS(n),signature:void 0,key:void 0}).subarray()]);return wce(n).verify(t,n.signature)}function wce(n){if(n.type!=="signed")throw new Error('Message type must be "signed" to have a public key');if(n.from==null)throw new Error("Could not get the public key from the originator id");if(n.key!=null)return n.key;if(n.from.publicKey!=null)return n.from.publicKey;throw new Error("Could not get the public key from the originator id")}var nI,rI,iI,sI,oI;class vce extends(oI=N3,sI=Fre,iI=Symbol.toStringTag,rI=Vre,nI=Hre,oI){constructor(t,r){super();h(this,"log");h(this,"started");h(this,"topics");h(this,"subscriptions");h(this,"peers");h(this,"globalSignaturePolicy");h(this,"canRelayMessage");h(this,"emitSelf");h(this,"topicValidators");h(this,"queue");h(this,"protocol");h(this,"components");h(this,"_registrarTopologyId");h(this,"maxInboundStreams");h(this,"maxOutboundStreams");h(this,"seenCache");h(this,sI,!0);h(this,iI,"@libp2p/floodsub");h(this,rI,["@libp2p/pubsub"]);h(this,nI,["@libp2p/identify"]);this.log=t.logger.forComponent("libp2p:floodsub"),this.components=t,this.protocol=r.protocol??_ce,this.started=!1,this.topics=new Map,this.subscriptions=new Set,this.peers=new Uae,this.globalSignaturePolicy=r.globalSignaturePolicy==="StrictNoSign"?"StrictNoSign":"StrictSign",this.canRelayMessage=r.canRelayMessage??!0,this.emitSelf=r.emitSelf??!1,this.topicValidators=new Map,this.queue=new ace({concurrency:r.messageProcessingConcurrency??10}),this.maxInboundStreams=r.maxInboundStreams??1,this.maxOutboundStreams=r.maxOutboundStreams??1,this.seenCache=new cce({validityMs:(r==null?void 0:r.seenTTL)??3e4}),this._onIncomingStream=this._onIncomingStream.bind(this),this._onPeerConnected=this._onPeerConnected.bind(this),this._onPeerDisconnected=this._onPeerDisconnected.bind(this)}async start(){this.started||(this.log("starting"),await this.components.registrar.handle(this.protocol,this._onIncomingStream,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams}),this._registrarTopologyId=await this.components.registrar.register(this.protocol,{onConnect:this._onPeerConnected,onDisconnect:this._onPeerDisconnected}),this.log("started"),this.started=!0)}async stop(){if(!this.started)return;const t=this.components.registrar;this._registrarTopologyId!=null&&t.unregister(this._registrarTopologyId),await t.unhandle(this.protocol),this.log("stopping");for(const r of this.peers.values())r.close();this.peers.clear(),this.subscriptions=new Set,this.started=!1,this.log("stopped")}isStarted(){return this.started}_onIncomingStream(t,r){this.addPeer(r.remotePeer,t).attachInboundStream(t)}async _onPeerConnected(t,r){if(this.log("connected %p",t),r.streams.find(o=>o.direction==="outbound"&&o.protocol===this.protocol)){this.log("outbound pubsub stream already present on connection from %p",t);return}const i=await r.newStream(this.protocol);this.addPeer(t,i).attachOutboundStream(i),this.send(t,{subscriptions:Array.from(this.subscriptions).map(o=>o.toString()),subscribe:!0})}_onPeerDisconnected(t,r){this.log("connection ended %p",t),this._removePeer(t)}addPeer(t,r){const i=this.peers.get(t);if(i!=null)return i;this.log("new peer %p",t);const s=new lce(t);return this.peers.set(t,s),s.addEventListener("message",o=>{const a=o.detail,c=[];for(const l of a.messages??[]){if(l.from==null||l.data==null||l.topic==null){this.log("message from %p was missing from, data or topic fields, dropping",t);continue}c.push({from:l.from,data:l.data,topic:l.topic,sequenceNumber:l.sequenceNumber??void 0,signature:l.signature??void 0,key:l.key??void 0})}this.processRpc(s,{subscriptions:(a.subscriptions??[]).map(l=>({subscribe:!!l.subscribe,topic:l.topic??""})),messages:c}).catch(l=>{this.log(l)})}),s.addEventListener("close",()=>this._removePeer(t),{once:!0}),s}_removePeer(t){const r=this.peers.get(t);if(r!=null){r.close(),this.log("delete peer %p",t),this.peers.delete(t);for(const i of this.topics.values())i.delete(t)}}async processRpc(t,r){this.log("rpc from %p",t.peerId);const{subscriptions:i,messages:s}=r;return i!=null&&i.length>0&&(this.log("subscription update from %p",t.peerId),i.forEach(o=>{this.processRpcSubOpt(t.peerId,o)}),super.dispatchEvent(new CustomEvent("subscription-change",{detail:{peerId:t.peerId,subscriptions:i.map(({topic:o,subscribe:a})=>({topic:`${o??""}`,subscribe:!!a}))}}))),s!=null&&s.length>0&&(this.log("messages from %p",t.peerId),this.queue.addAll(s.map(o=>async()=>{if(o.topic==null||!this.subscriptions.has(o.topic)&&!this.canRelayMessage)return this.log("received message we didn't subscribe to. Dropping."),!1;try{const a=await pce(o);await this.processMessage(t.peerId,a)}catch(a){this.log.error("failed to queue messages from %p - %e",t.peerId,a)}})).catch(o=>{this.log(o)})),!0}processRpcSubOpt(t,r){const i=r.topic;if(i==null)return;let s=this.topics.get(i);s==null&&(s=new Kh,this.topics.set(i,s)),r.subscribe===!0?s.add(t):s.delete(t)}async processMessage(t,r){if(this.components.peerId.equals(t)&&!this.emitSelf)return;const i=await this.getMsgId(r),s=Or(i,"base64");if(!this.seenCache.has(s)){this.seenCache.put(s,!0);try{await this.validate(t,r)}catch(o){this.log("Message is invalid, dropping it. %O",o);return}this.subscriptions.has(r.topic)&&(!this.components.peerId.equals(t)||this.emitSelf)&&super.dispatchEvent(new CustomEvent("message",{detail:r})),await this.publishMessage(t,r)}}getMsgId(t){switch(this.globalSignaturePolicy){case"StrictSign":if(t.type!=="signed")throw new vn('Message type should be "signed" when signature policy is StrictSign but it was not');if(t.sequenceNumber==null)throw new vn("Need sequence number when signature policy is StrictSign but it was missing");if(t.key==null)throw new vn("Need key when signature policy is StrictSign but it was missing");return hce(t.key,t.sequenceNumber);case"StrictNoSign":return dce(t.data);default:throw new vn("Cannot get message id: unhandled signature policy")}}encodeMessage(t){return Md.Message.encode(t)}send(t,r){const{messages:i,subscriptions:s,subscribe:o}=r;this.sendRpc(t,{subscriptions:(s??[]).map(a=>({topic:a,subscribe:!!o})),messages:(i??[]).map(PS)})}sendRpc(t,r){const i=this.peers.get(t);if(i==null){this.log.error("cannot send RPC to %p as there are no streams to it available",t);return}i.write(r)}async validate(t,r){switch(this.globalSignaturePolicy){case"StrictNoSign":if(r.type!=="unsigned")throw new vn('Message type should be "unsigned" when signature policy is StrictNoSign but it was not');if(r.signature!=null)throw new vn("StrictNoSigning: signature should not be present");if(r.key!=null)throw new vn("StrictNoSigning: key should not be present");if(r.sequenceNumber!=null)throw new vn("StrictNoSigning: seqno should not be present");break;case"StrictSign":if(r.type!=="signed")throw new vn('Message type should be "signed" when signature policy is StrictSign but it was not');if(r.signature==null)throw new vn("StrictSigning: Signing required and no signature was present");if(r.sequenceNumber==null)throw new vn("StrictSigning: Signing required and no sequenceNumber was present");if(!await bce(r,this.encodeMessage.bind(this)))throw new vn("StrictSigning: Invalid message signature");break;default:throw new vn("Cannot validate message: unhandled signature policy")}const s=this.topicValidators.get(r.topic);if(s!=null){const o=await s(t,r);if(o===og.Reject||o===og.Ignore)throw new vn("Message validation failed")}}async buildMessage(t){switch(this.globalSignaturePolicy){case"StrictSign":return yce(this.components.privateKey,t,this.encodeMessage.bind(this));case"StrictNoSign":return Promise.resolve({type:"unsigned",...t});default:throw new vn("Cannot build message: unhandled signature policy")}}getSubscribers(t){if(!this.started)throw new L3("not started yet");if(t==null)throw new dc("Topic is required");const r=this.topics.get(t.toString());return r==null?[]:Array.from(r.values())}async publish(t,r){if(!this.started)throw new Error("Pubsub has not started");const i={from:this.components.peerId,topic:t,data:r??new Uint8Array(0),sequenceNumber:uce()};this.log("publish topic: %s from: %p data: %m",t,i.from,i.data);const s=await this.buildMessage(i);let o=!1;this.emitSelf&&this.subscriptions.has(t)&&(o=!0,super.dispatchEvent(new CustomEvent("message",{detail:s})));const a=await this.publishMessage(this.components.peerId,s);return o&&(a.recipients=[...a.recipients,this.components.peerId]),a}async publishMessage(t,r){const i=this.getSubscribers(r.topic),s=[];return i==null||i.length===0?(this.log("no peers are subscribed to topic %s",r.topic),{recipients:s}):(i.forEach(o=>{if(this.components.peerId.equals(o)){this.log("not sending message on topic %s to myself",r.topic);return}if(o.equals(t)){this.log("not sending message on topic %s to sender %p",r.topic,o);return}this.log("publish msgs on topics %s %p",r.topic,o),s.push(o),this.send(o,{messages:[r]})}),{recipients:s})}subscribe(t){if(!this.started)throw new Error("Pubsub has not started");if(!this.subscriptions.has(t)){this.log("subscribe to topic: %s",t),this.subscriptions.add(t);for(const r of this.peers.keys())this.send(r,{subscriptions:[t],subscribe:!0})}}unsubscribe(t){if(!this.started)throw new Error("Pubsub is not started");if(this.subscriptions.has(t)){this.log("unsubscribe from %s",t),this.subscriptions.delete(t);for(const r of this.peers.keys())this.send(r,{subscriptions:[t],subscribe:!1})}}getTopics(){if(!this.started)throw new Error("Pubsub is not started");return Array.from(this.subscriptions)}getPeers(){if(!this.started)throw new Error("Pubsub is not started");return Array.from(this.peers.keys())}}const _ce="/floodsub/1.0.0";var og;(function(n){n.Accept="accept",n.Ignore="ignore",n.Reject="reject"})(og||(og={}));function Ece(n={}){return e=>new vce(e,n)}var zw;let Sce=(zw=class extends Error{constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}},h(zw,"name","InvalidCIDError"),zw);var Vw;let xce=(Vw=class extends Error{constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}},h(Vw,"name","InvalidMultihashError"),Vw);class zo extends Error{constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}}h(zo,"name","InvalidMessageError");var Hw;let Tce=(Hw=class extends Error{constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}},h(Hw,"name","UnsupportedKeyTypeError"),Hw);const qO=Symbol.for("@libp2p/peer-id"),Ace=Symbol.for("@libp2p/service-capabilities");var Gw;let oi=(Gw=class extends Error{constructor(){super(...arguments);h(this,"name","InvalidMultiaddrError")}},h(Gw,"name","InvalidMultiaddrError"),Gw);var Ww;let Cd=(Ww=class extends Error{constructor(){super(...arguments);h(this,"name","ValidationError")}},h(Ww,"name","ValidationError"),Ww);var qw;let Mce=(qw=class extends Error{constructor(){super(...arguments);h(this,"name","InvalidParametersError")}},h(qw,"name","InvalidParametersError"),qw);var Kw;let Cce=(Kw=class extends Error{constructor(){super(...arguments);h(this,"name","UnknownProtocolError")}},h(Kw,"name","UnknownProtocolError"),Kw);const Ice=4,Pce=6,Dce=273,Rce=33,A_=41,KO=42,Lce=43,Oce=53,Nce=54,Uce=55,Bce=56,kce=132,$ce=301,Fce=302,zce=400,XO=421,Vce=444,Hce=445,Gce=446,Wce=447,qce=448,Kce=449,Xce=454,Yce=460,Zce=461,jce=465,Jce=466,Qce=480,ele=481,tle=443,nle=477,rle=478,ile=479,sle=277,ole=275,ale=276,cle=280,lle=281,ule=290,hle=777;function k2(n){return e=>ne(e,n)}function $2(n){return e=>ge(e,n)}function Dh(n){return new DataView(n.buffer).getUint16(n.byteOffset).toString()}function tl(n){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof n=="string"?parseInt(n):n),new Uint8Array(e)}function dle(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=ge(e[0],"base32"),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const i=tl(r);return nt([t,i],t.length+i.length)}function fle(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=yn.decode(`b${e[0]}`),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const i=tl(r);return nt([t,i],t.length+i.length)}function F2(n){const e=n.subarray(0,n.length-2),t=n.subarray(n.length-2),r=ne(e,"base32"),i=Dh(t);return`${r}:${i}`}const YO=function(n){n=n.toString().trim();const e=new Uint8Array(4);return n.split(/\./g).forEach((t,r)=>{const i=parseInt(t,10);if(isNaN(i)||i<0||i>255)throw new oi("Invalid byte value in IP address");e[r]=i}),e},ple=function(n){let e=0;n=n.toString().trim();const t=n.split(":",8);let r;for(r=0;r<t.length;r++){const s=Pt(t[r]);let o;s&&(o=YO(t[r]),t[r]=ne(o.subarray(0,2),"base16")),o!=null&&++r<8&&t.splice(r,0,ne(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(r=0;r<t.length&&t[r]!=="";r++);const s=[r,1];for(r=9-t.length;r>0;r--)s.push("0");t.splice.apply(t,s)}const i=new Uint8Array(e+16);for(r=0;r<t.length;r++){t[r]===""&&(t[r]="0");const s=parseInt(t[r],16);if(isNaN(s)||s<0||s>65535)throw new oi("Invalid byte value in IP address");i[e++]=s>>8&255,i[e++]=s&255}return i},mle=function(n){if(n.byteLength!==4)throw new oi("IPv4 address was incorrect length");const e=[];for(let t=0;t<n.byteLength;t++)e.push(n[t]);return e.join(".")},gle=function(n){if(n.byteLength!==16)throw new oi("IPv6 address was incorrect length");const e=[];for(let r=0;r<n.byteLength;r+=2){const i=n[r],s=n[r+1],o=`${i.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const r=new URL(`http://[${t}]`);return r.hostname.substring(1,r.hostname.length-1)}catch{throw new oi(`Invalid IPv6 address "${t}"`)}};function yle(n){try{const e=new URL(`http://[${n}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new oi(`Invalid IPv6 address "${n}"`)}}const Y0=Object.values(Fr).map(n=>n.decoder),ble=(function(){let n=Y0[0].or(Y0[1]);return Y0.slice(2).forEach(e=>n=n.or(e)),n})();function wle(n){return ble.decode(n)}function vle(n){return e=>n.encoder.encode(e)}function _le(n){if(parseInt(n).toString()!==n)throw new Cd("Value must be an integer")}function Ele(n){if(n<0)throw new Cd("Value must be a positive integer, or zero")}function Sle(n){return e=>{if(e>n)throw new Cd(`Value must be smaller than or equal to ${n}`)}}function xle(...n){return e=>{for(const t of n)t(e)}}const xp=xle(_le,Ele,Sle(65535)),Hn=-1;let Tle=class{constructor(){h(this,"protocolsByCode",new Map);h(this,"protocolsByName",new Map)}getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new Cce(`Protocol ${e} was unknown`);return t}addProtocol(e){var t;this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),(t=e.aliases)==null||t.forEach(r=>{this.protocolsByName.set(r,e)})}removeProtocol(e){var r;const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),(r=t.aliases)==null||r.forEach(i=>{this.protocolsByName.delete(i)}))}};const Hu=new Tle,Ale=[{code:Ice,name:"ip4",size:32,valueToBytes:YO,bytesToValue:mle,validate:n=>{if(!Pt(n))throw new Cd(`Invalid IPv4 address "${n}"`)}},{code:Pce,name:"tcp",size:16,valueToBytes:tl,bytesToValue:Dh,validate:xp},{code:Dce,name:"udp",size:16,valueToBytes:tl,bytesToValue:Dh,validate:xp},{code:Rce,name:"dccp",size:16,valueToBytes:tl,bytesToValue:Dh,validate:xp},{code:A_,name:"ip6",size:128,valueToBytes:ple,bytesToValue:gle,stringToValue:yle,validate:n=>{if(!hi(n))throw new Cd(`Invalid IPv6 address "${n}"`)}},{code:KO,name:"ip6zone",size:Hn},{code:Lce,name:"ipcidr",size:8,bytesToValue:k2("base10"),valueToBytes:$2("base10")},{code:Oce,name:"dns",size:Hn},{code:Nce,name:"dns4",size:Hn},{code:Uce,name:"dns6",size:Hn},{code:Bce,name:"dnsaddr",size:Hn},{code:kce,name:"sctp",size:16,valueToBytes:tl,bytesToValue:Dh,validate:xp},{code:$ce,name:"udt"},{code:Fce,name:"utp"},{code:zce,name:"unix",size:Hn,stringToValue:n=>decodeURIComponent(n),valueToString:n=>encodeURIComponent(n)},{code:XO,name:"p2p",aliases:["ipfs"],size:Hn,bytesToValue:k2("base58btc"),valueToBytes:n=>n.startsWith("Q")||n.startsWith("1")?$2("base58btc")(n):ze.parse(n).multihash.bytes},{code:Vce,name:"onion",size:96,bytesToValue:F2,valueToBytes:dle},{code:Hce,name:"onion3",size:296,bytesToValue:F2,valueToBytes:fle},{code:Gce,name:"garlic64",size:Hn},{code:Wce,name:"garlic32",size:Hn},{code:qce,name:"tls"},{code:Kce,name:"sni",size:Hn},{code:Xce,name:"noise"},{code:Yce,name:"quic"},{code:Zce,name:"quic-v1"},{code:jce,name:"webtransport"},{code:Jce,name:"certhash",size:Hn,bytesToValue:vle(ui),valueToBytes:wle},{code:Qce,name:"http"},{code:ele,name:"http-path",size:Hn,stringToValue:n=>`/${decodeURIComponent(n)}`,valueToString:n=>encodeURIComponent(n.substring(1))},{code:tle,name:"https"},{code:nle,name:"ws"},{code:rle,name:"wss"},{code:ile,name:"p2p-websocket-star"},{code:sle,name:"p2p-stardust"},{code:ole,name:"p2p-webrtc-star"},{code:ale,name:"p2p-webrtc-direct"},{code:cle,name:"webrtc-direct"},{code:lle,name:"webrtc"},{code:ule,name:"p2p-circuit"},{code:hle,name:"memory",size:Hn}];Ale.forEach(n=>{Hu.addProtocol(n)});function Mle(n){var r;const e=[];let t=0;for(;t<n.length;){const i=zt(n,t),s=Hu.getProtocol(i),o=Me(i),a=Dle(s,n,t+o);let c=0;a>0&&s.size===Hn&&(c=Me(a));const l=o+c+a,u={code:i,name:s.name,bytes:n.subarray(t,t+l)};if(a>0){const d=t+o+c,f=n.subarray(d,d+a);u.value=((r=s.bytesToValue)==null?void 0:r.call(s,f))??ne(f)}e.push(u),t+=l}return e}function Cle(n){var r;let e=0;const t=[];for(const i of n){if(i.bytes==null){const s=Hu.getProtocol(i.code),o=Me(i.code);let a,c=0,l=0;i.value!=null&&(a=((r=s.valueToBytes)==null?void 0:r.call(s,i.value))??ge(i.value),c=a.byteLength,s.size===Hn&&(l=Me(c)));const u=new Uint8Array(o+l+c);let d=0;Xt(i.code,u,d),d+=o,a!=null&&(s.size===Hn&&(Xt(c,u,d),d+=l),u.set(a,d)),i.bytes=u}t.push(i.bytes),e+=i.bytes.byteLength}return nt(t,e)}function Ile(n){var s;if(n.charAt(0)!=="/")throw new oi('String multiaddr must start with "/"');const e=[];let t="protocol",r="",i="";for(let o=1;o<n.length;o++){const a=n.charAt(o);a!=="/"&&(t==="protocol"?i+=n.charAt(o):r+=n.charAt(o));const c=o===n.length-1;if(a==="/"||c){const l=Hu.getProtocol(i);if(t==="protocol"){if(l.size==null||l.size===0){e.push({code:l.code,name:l.name}),r="",i="",t="protocol";continue}else if(c)throw new oi(`Component ${i} was missing value`);t="value"}else if(t==="value"){const u={code:l.code,name:l.name};if(l.size!=null&&l.size!==0){if(r==="")throw new oi(`Component ${i} was missing value`);u.value=((s=l.stringToValue)==null?void 0:s.call(l,r))??r}e.push(u),r="",i="",t="protocol"}}}if(i!==""&&r!=="")throw new oi("Incomplete multiaddr");return e}function Ple(n){return`/${n.flatMap(e=>{var r;if(e.value==null)return e.name;const t=Hu.getProtocol(e.code);if(t==null)throw new oi(`Unknown protocol code ${e.code}`);return[e.name,((r=t.valueToString)==null?void 0:r.call(t,e.value))??e.value]}).join("/")}`}function Dle(n,e,t){return n.size==null||n.size===0?0:n.size>0?n.size/8:zt(e,t)}const Rle=Symbol.for("nodejs.util.inspect.custom"),ZO=Symbol.for("@multiformats/multiaddr");function Lle(n){if(n==null&&(n="/"),Ule(n))return n.getComponents();if(n instanceof Uint8Array)return Mle(n);if(typeof n=="string")return n=n.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),n===""&&(n="/"),Ile(n);if(Array.isArray(n))return n;throw new oi("Must be a string, Uint8Array, Component[], or another Multiaddr")}var aI,Mi,Wl,ql,Xs;let Ole=(Xs=class{constructor(e="/",t={}){h(this,aI,!0);me(this,Mi);me(this,Wl);me(this,ql);pe(this,Mi,Lle(e)),t.validate!==!1&&Nle(this)}get bytes(){return D(this,ql)==null&&pe(this,ql,Cle(D(this,Mi))),D(this,ql)}toString(){return D(this,Wl)==null&&pe(this,Wl,Ple(D(this,Mi))),D(this,Wl)}toJSON(){return this.toString()}getComponents(){return[...D(this,Mi).map(e=>({...e}))]}encapsulate(e){const t=new Xs(e);return new Xs([...D(this,Mi),...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),r=this.toString(),i=r.lastIndexOf(t);if(i<0)throw new Mce(`Address ${this.toString()} does not contain subaddress: ${t}`);return new Xs(r.slice(0,i),{validate:!1})}decapsulateCode(e){let t;for(let r=D(this,Mi).length-1;r>-1;r--)if(D(this,Mi)[r].code===e){t=r;break}return new Xs(D(this,Mi).slice(0,t),{validate:!1})}equals(e){return Ne(this.bytes,e.bytes)}[(aI=ZO,Rle)](){return`Multiaddr(${this.toString()})`}},Mi=new WeakMap,Wl=new WeakMap,ql=new WeakMap,Xs);function Nle(n){n.getComponents().forEach(e=>{var r;const t=Hu.getProtocol(e.code);e.value!=null&&((r=t.validate)==null||r.call(t,e.value))})}function Ule(n){return!!(n!=null&&n[ZO])}function Xp(n){return new Ole(n)}const Ble="0.1.0",kle="id",$le="1.0.0",Fle=1024*8;var ag;(function(n){let e;n.codec=()=>(e==null&&(e=Nt((t,r,i={})=>{if(i.lengthDelimited!==!1&&r.fork(),t.protocolVersion!=null&&(r.uint32(42),r.string(t.protocolVersion)),t.agentVersion!=null&&(r.uint32(50),r.string(t.agentVersion)),t.publicKey!=null&&(r.uint32(10),r.bytes(t.publicKey)),t.listenAddrs!=null)for(const s of t.listenAddrs)r.uint32(18),r.bytes(s);if(t.observedAddr!=null&&(r.uint32(34),r.bytes(t.observedAddr)),t.protocols!=null)for(const s of t.protocols)r.uint32(26),r.string(s);t.signedPeerRecord!=null&&(r.uint32(66),r.bytes(t.signedPeerRecord)),i.lengthDelimited!==!1&&r.ldelim()},(t,r,i={})=>{var a,c;const s={listenAddrs:[],protocols:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const l=t.uint32();switch(l>>>3){case 5:{s.protocolVersion=t.string();break}case 6:{s.agentVersion=t.string();break}case 1:{s.publicKey=t.bytes();break}case 2:{if(((a=i.limits)==null?void 0:a.listenAddrs)!=null&&s.listenAddrs.length===i.limits.listenAddrs)throw new ls('Decode error - map field "listenAddrs" had too many elements');s.listenAddrs.push(t.bytes());break}case 4:{s.observedAddr=t.bytes();break}case 3:{if(((c=i.limits)==null?void 0:c.protocols)!=null&&s.protocols.length===i.limits.protocols)throw new ls('Decode error - map field "protocols" had too many elements');s.protocols.push(t.string());break}case 8:{s.signedPeerRecord=t.bytes();break}default:{t.skipType(l&7);break}}}return s})),e),n.encode=t=>Ot(t,n.codec()),n.decode=(t,r)=>Lt(t,n.codec(),r)})(ag||(ag={}));const jO=Symbol.for("nodejs.util.inspect.custom"),zle=114;var cI;let DS=class{constructor(e){h(this,"type");h(this,"multihash");h(this,"publicKey");h(this,"string");h(this,cI,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=at.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return ze.createV1(zle,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return Ne(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return Ne(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(cI=qO,jO)](){return`PeerId(${this.toString()})`}},JO=class extends DS{constructor(t){super({...t,type:"RSA"});h(this,"type","RSA");h(this,"publicKey");this.publicKey=t.publicKey}},QO=class extends DS{constructor(t){super({...t,type:"Ed25519"});h(this,"type","Ed25519");h(this,"publicKey");this.publicKey=t.publicKey}},eN=class extends DS{constructor(t){super({...t,type:"secp256k1"});h(this,"type","secp256k1");h(this,"publicKey");this.publicKey=t.publicKey}};const Vle=2336;var lI,uI;let tN=class{constructor(e){h(this,"type","url");h(this,"multihash");h(this,"publicKey");h(this,"url");h(this,lI,!0);this.url=e.toString(),this.multihash=Zt.digest(ge(this.url))}[(uI=jO,lI=qO,uI)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return ze.createV1(Vle,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=ne(e)),e.toString()===this.toString())}};const Hle=114,z2=2336;function Gle(n){if(n.type==="Ed25519")return new QO({multihash:n.toCID().multihash,publicKey:n});if(n.type==="secp256k1")return new eN({multihash:n.toCID().multihash,publicKey:n});if(n.type==="RSA")return new JO({multihash:n.toCID().multihash,publicKey:n});throw new Tce}function Wle(n){if(Kle(n))return new JO({multihash:n});if(qle(n))try{const e=lo(n);if(e.type==="Ed25519")return new QO({multihash:n,publicKey:e});if(e.type==="secp256k1")return new eN({multihash:n,publicKey:e})}catch{const t=ne(n.digest);return new tN(new URL(t))}throw new xce("Supplied PeerID Multihash is invalid")}function nN(n){if((n==null?void 0:n.multihash)==null||n.version==null||n.version===1&&n.code!==Hle&&n.code!==z2)throw new Sce("Supplied PeerID CID is invalid");if(n.code===z2){const e=ne(n.multihash.digest);return new tN(new URL(e))}return Wle(n.multihash)}function qle(n){return n.code===Zt.code}function Kle(n){return n.code===ps.code}const Ps={protocolPrefix:"ipfs",timeout:5e3,maxInboundStreams:1,maxOutboundStreams:1,maxObservedAddresses:10,maxMessageSize:Fle,runOnConnectionOpen:!0,runOnLimitedConnection:!0};function Xle(n){if(n!=null&&n.length>0)try{return Xp(n)}catch{}}async function Yle(n,e,t,r,i){if(t("received identify from %p",r.remotePeer),i==null)throw new zo("message was null or undefined");const s={};if(i.listenAddrs.length>0&&(s.addresses=i.listenAddrs.map(c=>({isCertified:!1,multiaddr:Xp(c)}))),i.protocols.length>0&&(s.protocols=i.protocols),i.publicKey!=null){const c=no(i.publicKey);if(!Gle(c).equals(r.remotePeer))throw new zo("public key did not match remote PeerId");s.publicKey=c}let o;if(i.signedPeerRecord!=null){t.trace("received signedPeerRecord from %p",r.remotePeer);let c=i.signedPeerRecord;const l=await Qa.openAndCertify(c,js.DOMAIN);let u=js.createFromProtobuf(l.payload);const d=nN(l.publicKey.toCID());if(!u.peerId.equals(d))throw new zo("signing key does not match PeerId in the PeerRecord");if(!r.remotePeer.equals(u.peerId))throw new zo("signing key does not match remote PeerId");let f;try{f=await n.get(u.peerId)}catch(p){if(p.name!=="NotFoundError")throw p}if(f!=null&&(s.metadata=f.metadata,f.peerRecordEnvelope!=null)){const p=Qa.createFromProtobuf(f.peerRecordEnvelope),g=js.createFromProtobuf(p.payload);g.seqNumber>=u.seqNumber&&(t("sequence number was lower or equal to existing sequence number - stored: %d received: %d",g.seqNumber,u.seqNumber),u=g,c=f.peerRecordEnvelope)}s.peerRecordEnvelope=c,s.addresses=u.multiaddrs.map(p=>({isCertified:!0,multiaddr:p})),o={seq:u.seqNumber,addresses:u.multiaddrs}}else t("%p did not send a signed peer record",r.remotePeer);if(t.trace("patching %p with",r.remotePeer,s),await n.patch(r.remotePeer,s),i.agentVersion!=null||i.protocolVersion!=null){const c={};i.agentVersion!=null&&(c.AgentVersion=ge(i.agentVersion)),i.protocolVersion!=null&&(c.ProtocolVersion=ge(i.protocolVersion)),t.trace("merging %p metadata",r.remotePeer,c),await n.merge(r.remotePeer,{metadata:c})}const a={peerId:r.remotePeer,protocolVersion:i.protocolVersion,agentVersion:i.agentVersion,publicKey:i.publicKey,listenAddrs:i.listenAddrs.map(c=>Xp(c)),observedAddr:i.observedAddr==null?void 0:Xp(i.observedAddr),protocols:i.protocols,signedPeerRecord:o,connection:r};return e.safeDispatchEvent("peer:identify",{detail:a}),a}class Zle{constructor(e,t){h(this,"host");h(this,"components");h(this,"protocol");h(this,"started");h(this,"timeout");h(this,"maxInboundStreams");h(this,"maxOutboundStreams");h(this,"maxMessageSize");h(this,"maxObservedAddresses");h(this,"runOnLimitedConnection");h(this,"log");this.protocol=t.protocol,this.started=!1,this.components=e,this.log=t.log,this.timeout=t.timeout??Ps.timeout,this.maxInboundStreams=t.maxInboundStreams??Ps.maxInboundStreams,this.maxOutboundStreams=t.maxOutboundStreams??Ps.maxOutboundStreams,this.maxMessageSize=t.maxMessageSize??Ps.maxMessageSize,this.maxObservedAddresses=t.maxObservedAddresses??Ps.maxObservedAddresses,this.runOnLimitedConnection=t.runOnLimitedConnection??Ps.runOnLimitedConnection,this.host={protocolVersion:`${t.protocolPrefix??Ps.protocolPrefix}/${Ble}`,agentVersion:e.nodeInfo.userAgent},this.handleProtocol=this.handleProtocol.bind(this)}isStarted(){return this.started}async start(){this.started||(await this.components.peerStore.merge(this.components.peerId,{metadata:{AgentVersion:ge(this.host.agentVersion),ProtocolVersion:ge(this.host.protocolVersion)}}),await this.components.registrar.handle(this.protocol,this.handleProtocol,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0)}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}}var hI,dI;class jle extends(dI=Zle,hI=Ace,dI){constructor(t,r={}){super(t,{...r,protocol:`/${r.protocolPrefix??Ps.protocolPrefix}/${kle}/${$le}`,log:t.logger.forComponent("libp2p:identify")});h(this,hI,["@libp2p/identify"]);(r.runOnConnectionOpen??Ps.runOnConnectionOpen)&&t.events.addEventListener("connection:open",i=>{const s=i.detail;this.identify(s).catch(()=>{})})}async _identify(t,r={}){let i,s;if(r.signal==null){const o=AbortSignal.timeout(this.timeout);r={...r,signal:o}}this.log("run identify on new connection %a",t.remoteAddr);try{i=await t.newStream(this.protocol,{...r,runOnLimitedConnection:this.runOnLimitedConnection}),s=i.log.newScope("identify");const o=Jo(i,{maxDataLength:this.maxMessageSize}).pb(ag),a=await o.read(r);return await o.unwrap().unwrap().close(r),a}catch(o){throw s==null||s.error("identify failed - %e",o),i==null||i.abort(o),o}}async identify(t,r={}){const i=await this._identify(t,r),{publicKey:s,protocols:o,observedAddr:a}=i;if(s==null)throw new zo("Public key was missing from identify message");const c=no(s),l=nN(c.toCID());if(!t.remotePeer.equals(l))throw new zo("Identified peer does not match the expected peer");if(this.components.peerId.equals(l))throw new zo("Identified peer is our own peer id?");return this.maybeAddObservedAddress(a),this.log("completed for peer %p and protocols %o",l,o),Yle(this.components.peerStore,this.components.events,this.log,t,i)}maybeAddObservedAddress(t){const r=Xle(t);if(r==null||(this.log.trace("our observed address was %a",r),hu(r)))return;const i=r.getComponents();if((i[0].code===A_||i[0].code===KO&&i[1].code===A_)&&!S9(r)){this.log.trace("our observed address was IPv6 but not a global unicast address");return}Im.exactMatch(r)||(this.log.trace("storing the observed address"),this.components.addressManager.addObservedAddr(r))}async handleProtocol(t,r){const i=t.log.newScope("identify");i("responding to identify");const s=AbortSignal.timeout(this.timeout),o=await this.components.peerStore.get(this.components.peerId,{signal:s}),a=this.components.addressManager.getAddresses().map(d=>d.decapsulateCode(XO));let c=o.peerRecordEnvelope;if(a.length>0&&c==null){const d=new js({peerId:this.components.peerId,multiaddrs:a});c=(await Qa.seal(d,this.components.privateKey,{signal:s})).marshal().subarray()}let l=r.remoteAddr.bytes;KX.matches(r.remoteAddr)||(l=void 0);const u=Jo(t).pb(ag);i("send response"),await u.write({protocolVersion:this.host.protocolVersion,agentVersion:this.host.agentVersion,publicKey:as(this.components.privateKey.publicKey),listenAddrs:a.map(d=>d.bytes),signedPeerRecord:c,observedAddr:l,protocols:o.protocols},{signal:s}),i("close write"),await u.unwrap().unwrap().close({signal:s})}}function Jle(n={}){return e=>new jle(e,n)}class rN extends Error{constructor(e="Protocol error"){super(e),this.name="ProtocolError"}}h(rN,"name","ProtocolError");class iN extends Error{constructor(e="Timed out"){super(e),this.name="TimeoutError"}}h(iN,"name","TimeoutError");const Qle=Symbol.for("@libp2p/service-capabilities"),V2=32,eue="1.0.0",tue="ping",nue="ipfs",rue=1e4,iue=2,sue=1;var fI,pI;pI=Symbol.toStringTag,fI=Qle;class oue{constructor(e,t={}){h(this,"protocol");h(this,"components");h(this,"started");h(this,"timeout");h(this,"maxInboundStreams");h(this,"maxOutboundStreams");h(this,"runOnLimitedConnection");h(this,pI,"@libp2p/ping");h(this,fI,["@libp2p/ping"]);this.components=e,this.started=!1,this.protocol=`/${t.protocolPrefix??nue}/${tue}/${eue}`,this.timeout=t.timeout??rue,this.maxInboundStreams=t.maxInboundStreams??iue,this.maxOutboundStreams=t.maxOutboundStreams??sue,this.runOnLimitedConnection=t.runOnLimitedConnection??!0,this.handlePing=this.handlePing.bind(this)}async start(){await this.components.registrar.handle(this.protocol,this.handlePing,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}isStarted(){return this.started}async handlePing(e,t){const r=e.log.newScope("ping");r.trace("ping from %p",t.remotePeer);const i=AbortSignal.timeout(this.timeout);i.addEventListener("abort",()=>{e.abort(new iN("Ping timed out"))});const s=Date.now();for await(const o of e){if(e.status!=="open"){r("stream status changed to %s",e.status);break}e.send(o)||(r("waiting for stream to drain"),await bn(e,"drain",{rejectionEvents:["close"],signal:i}),r("stream drained"))}r("ping from %p complete in %dms",t.remotePeer,Date.now()-s),await e.close({signal:i})}async ping(e,t={}){const r=TE(V2),i=await this.components.connectionManager.openStream(e,this.protocol,{runOnLimitedConnection:this.runOnLimitedConnection,...t}),s=i.log.newScope("ping");try{const o=Date.now(),a=Promise.withResolvers(),c=new ut,l=u=>{if(c.append(u.data),c.byteLength===V2){i.removeEventListener("message",l);const d=Date.now()-o;Promise.all([i.closeRead(t)]).then(()=>{if(Ne(r,c.subarray()))a.resolve(d);else throw new rN(`Received wrong ping ack after ${d}ms`)}).catch(f=>{i.abort(f),a.reject(f)})}};return i.addEventListener("message",l),i.send(r),await i.close(t),await Vi(a.promise,t.signal)}catch(o){throw s.error("error while pinging %o - %e",e,o),i==null||i.abort(o),o}finally{i==null||i.close()}}}function aue(n={}){return e=>new oue(e,n)}var Xw;let cue=(Xw=class extends Error{constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}},h(Xw,"name","InvalidParametersError"),Xw);var Yw;let lue=(Yw=class extends Error{constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}},h(Yw,"name","InvalidCIDError"),Yw);var Zw;let uue=(Zw=class extends Error{constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}},h(Zw,"name","InvalidMultihashError"),Zw);const hue=Symbol.for("@libp2p/peer-discovery"),sN=Symbol.for("@libp2p/peer-id"),due=Symbol.for("@libp2p/service-capabilities"),oN=Symbol.for("nodejs.util.inspect.custom"),fue=114;var mI;let RS=class{constructor(e){h(this,"type");h(this,"multihash");h(this,"publicKey");h(this,"string");h(this,mI,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=at.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return ze.createV1(fue,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return Ne(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return Ne(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(mI=sN,oN)](){return`PeerId(${this.toString()})`}},pue=class extends RS{constructor(t){super({...t,type:"RSA"});h(this,"type","RSA");h(this,"publicKey");this.publicKey=t.publicKey}},mue=class extends RS{constructor(t){super({...t,type:"Ed25519"});h(this,"type","Ed25519");h(this,"publicKey");this.publicKey=t.publicKey}},gue=class extends RS{constructor(t){super({...t,type:"secp256k1"});h(this,"type","secp256k1");h(this,"publicKey");this.publicKey=t.publicKey}};const yue=2336;var gI,yI;let aN=class{constructor(e){h(this,"type","url");h(this,"multihash");h(this,"publicKey");h(this,"url");h(this,gI,!0);this.url=e.toString(),this.multihash=Zt.digest(ge(this.url))}[(yI=oN,gI=sN,yI)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return ze.createV1(yue,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=ne(e)),e.toString()===this.toString())}};const bue=114,H2=2336;function wue(n,e){let t;if(n.charAt(0)==="1"||n.charAt(0)==="Q")t=co(at.decode(`z${n}`));else{if(n.startsWith("k51qzi5uqu5")||n.startsWith("kzwfwjn5ji4")||n.startsWith("k2k4r8")||n.startsWith("bafz"))return vue(ze.parse(n));throw new cue('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return cN(t)}function cN(n){if(Eue(n))return new pue({multihash:n});if(_ue(n))try{const e=lo(n);if(e.type==="Ed25519")return new mue({multihash:n,publicKey:e});if(e.type==="secp256k1")return new gue({multihash:n,publicKey:e})}catch{const t=ne(n.digest);return new aN(new URL(t))}throw new uue("Supplied PeerID Multihash is invalid")}function vue(n){if((n==null?void 0:n.multihash)==null||n.version==null||n.version===1&&n.code!==bue&&n.code!==H2)throw new lue("Supplied PeerID CID is invalid");if(n.code===H2){const e=ne(n.multihash.digest);return new aN(new URL(e))}return cN(n.multihash)}function _ue(n){return n.code===Zt.code}function Eue(n){return n.code===ps.code}var jw;let ai=(jw=class extends Error{constructor(){super(...arguments);h(this,"name","InvalidMultiaddrError")}},h(jw,"name","InvalidMultiaddrError"),jw);var Jw;let Id=(Jw=class extends Error{constructor(){super(...arguments);h(this,"name","ValidationError")}},h(Jw,"name","ValidationError"),Jw);var Qw;let Sue=(Qw=class extends Error{constructor(){super(...arguments);h(this,"name","InvalidParametersError")}},h(Qw,"name","InvalidParametersError"),Qw);var ev;let xue=(ev=class extends Error{constructor(){super(...arguments);h(this,"name","UnknownProtocolError")}},h(ev,"name","UnknownProtocolError"),ev);const Tue=4,Aue=6,Mue=273,Cue=33,Iue=41,Pue=42,Due=43,Rue=53,Lue=54,Oue=55,Nue=56,Uue=132,Bue=301,kue=302,$ue=400,M_=421,Fue=444,zue=445,Vue=446,Hue=447,Gue=448,Wue=449,que=454,Kue=460,Xue=461,Yue=465,Zue=466,jue=480,Jue=481,Que=443,ehe=477,the=478,nhe=479,rhe=277,ihe=275,she=276,ohe=280,ahe=281,che=290,lhe=777;function G2(n){return e=>ne(e,n)}function W2(n){return e=>ge(e,n)}function Rh(n){return new DataView(n.buffer).getUint16(n.byteOffset).toString()}function nl(n){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof n=="string"?parseInt(n):n),new Uint8Array(e)}function uhe(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=ge(e[0],"base32"),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const i=nl(r);return nt([t,i],t.length+i.length)}function hhe(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=yn.decode(`b${e[0]}`),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const i=nl(r);return nt([t,i],t.length+i.length)}function q2(n){const e=n.subarray(0,n.length-2),t=n.subarray(n.length-2),r=ne(e,"base32"),i=Rh(t);return`${r}:${i}`}const lN=function(n){n=n.toString().trim();const e=new Uint8Array(4);return n.split(/\./g).forEach((t,r)=>{const i=parseInt(t,10);if(isNaN(i)||i<0||i>255)throw new ai("Invalid byte value in IP address");e[r]=i}),e},dhe=function(n){let e=0;n=n.toString().trim();const t=n.split(":",8);let r;for(r=0;r<t.length;r++){const s=Pt(t[r]);let o;s&&(o=lN(t[r]),t[r]=ne(o.subarray(0,2),"base16")),o!=null&&++r<8&&t.splice(r,0,ne(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(r=0;r<t.length&&t[r]!=="";r++);const s=[r,1];for(r=9-t.length;r>0;r--)s.push("0");t.splice.apply(t,s)}const i=new Uint8Array(e+16);for(r=0;r<t.length;r++){t[r]===""&&(t[r]="0");const s=parseInt(t[r],16);if(isNaN(s)||s<0||s>65535)throw new ai("Invalid byte value in IP address");i[e++]=s>>8&255,i[e++]=s&255}return i},fhe=function(n){if(n.byteLength!==4)throw new ai("IPv4 address was incorrect length");const e=[];for(let t=0;t<n.byteLength;t++)e.push(n[t]);return e.join(".")},phe=function(n){if(n.byteLength!==16)throw new ai("IPv6 address was incorrect length");const e=[];for(let r=0;r<n.byteLength;r+=2){const i=n[r],s=n[r+1],o=`${i.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const r=new URL(`http://[${t}]`);return r.hostname.substring(1,r.hostname.length-1)}catch{throw new ai(`Invalid IPv6 address "${t}"`)}};function mhe(n){try{const e=new URL(`http://[${n}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new ai(`Invalid IPv6 address "${n}"`)}}const Z0=Object.values(Fr).map(n=>n.decoder),ghe=(function(){let n=Z0[0].or(Z0[1]);return Z0.slice(2).forEach(e=>n=n.or(e)),n})();function yhe(n){return ghe.decode(n)}function bhe(n){return e=>n.encoder.encode(e)}function whe(n){if(parseInt(n).toString()!==n)throw new Id("Value must be an integer")}function vhe(n){if(n<0)throw new Id("Value must be a positive integer, or zero")}function _he(n){return e=>{if(e>n)throw new Id(`Value must be smaller than or equal to ${n}`)}}function Ehe(...n){return e=>{for(const t of n)t(e)}}const Tp=Ehe(whe,vhe,_he(65535)),Gn=-1;let She=class{constructor(){h(this,"protocolsByCode",new Map);h(this,"protocolsByName",new Map)}getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new xue(`Protocol ${e} was unknown`);return t}addProtocol(e){var t;this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),(t=e.aliases)==null||t.forEach(r=>{this.protocolsByName.set(r,e)})}removeProtocol(e){var r;const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),(r=t.aliases)==null||r.forEach(i=>{this.protocolsByName.delete(i)}))}};const Gu=new She,xhe=[{code:Tue,name:"ip4",size:32,valueToBytes:lN,bytesToValue:fhe,validate:n=>{if(!Pt(n))throw new Id(`Invalid IPv4 address "${n}"`)}},{code:Aue,name:"tcp",size:16,valueToBytes:nl,bytesToValue:Rh,validate:Tp},{code:Mue,name:"udp",size:16,valueToBytes:nl,bytesToValue:Rh,validate:Tp},{code:Cue,name:"dccp",size:16,valueToBytes:nl,bytesToValue:Rh,validate:Tp},{code:Iue,name:"ip6",size:128,valueToBytes:dhe,bytesToValue:phe,stringToValue:mhe,validate:n=>{if(!hi(n))throw new Id(`Invalid IPv6 address "${n}"`)}},{code:Pue,name:"ip6zone",size:Gn},{code:Due,name:"ipcidr",size:8,bytesToValue:G2("base10"),valueToBytes:W2("base10")},{code:Rue,name:"dns",size:Gn},{code:Lue,name:"dns4",size:Gn},{code:Oue,name:"dns6",size:Gn},{code:Nue,name:"dnsaddr",size:Gn},{code:Uue,name:"sctp",size:16,valueToBytes:nl,bytesToValue:Rh,validate:Tp},{code:Bue,name:"udt"},{code:kue,name:"utp"},{code:$ue,name:"unix",size:Gn,stringToValue:n=>decodeURIComponent(n),valueToString:n=>encodeURIComponent(n)},{code:M_,name:"p2p",aliases:["ipfs"],size:Gn,bytesToValue:G2("base58btc"),valueToBytes:n=>n.startsWith("Q")||n.startsWith("1")?W2("base58btc")(n):ze.parse(n).multihash.bytes},{code:Fue,name:"onion",size:96,bytesToValue:q2,valueToBytes:uhe},{code:zue,name:"onion3",size:296,bytesToValue:q2,valueToBytes:hhe},{code:Vue,name:"garlic64",size:Gn},{code:Hue,name:"garlic32",size:Gn},{code:Gue,name:"tls"},{code:Wue,name:"sni",size:Gn},{code:que,name:"noise"},{code:Kue,name:"quic"},{code:Xue,name:"quic-v1"},{code:Yue,name:"webtransport"},{code:Zue,name:"certhash",size:Gn,bytesToValue:bhe(ui),valueToBytes:yhe},{code:jue,name:"http"},{code:Jue,name:"http-path",size:Gn,stringToValue:n=>`/${decodeURIComponent(n)}`,valueToString:n=>encodeURIComponent(n.substring(1))},{code:Que,name:"https"},{code:ehe,name:"ws"},{code:the,name:"wss"},{code:nhe,name:"p2p-websocket-star"},{code:rhe,name:"p2p-stardust"},{code:ihe,name:"p2p-webrtc-star"},{code:she,name:"p2p-webrtc-direct"},{code:ohe,name:"webrtc-direct"},{code:ahe,name:"webrtc"},{code:che,name:"p2p-circuit"},{code:lhe,name:"memory",size:Gn}];xhe.forEach(n=>{Gu.addProtocol(n)});function The(n){var r;const e=[];let t=0;for(;t<n.length;){const i=zt(n,t),s=Gu.getProtocol(i),o=Me(i),a=Ihe(s,n,t+o);let c=0;a>0&&s.size===Gn&&(c=Me(a));const l=o+c+a,u={code:i,name:s.name,bytes:n.subarray(t,t+l)};if(a>0){const d=t+o+c,f=n.subarray(d,d+a);u.value=((r=s.bytesToValue)==null?void 0:r.call(s,f))??ne(f)}e.push(u),t+=l}return e}function Ahe(n){var r;let e=0;const t=[];for(const i of n){if(i.bytes==null){const s=Gu.getProtocol(i.code),o=Me(i.code);let a,c=0,l=0;i.value!=null&&(a=((r=s.valueToBytes)==null?void 0:r.call(s,i.value))??ge(i.value),c=a.byteLength,s.size===Gn&&(l=Me(c)));const u=new Uint8Array(o+l+c);let d=0;Xt(i.code,u,d),d+=o,a!=null&&(s.size===Gn&&(Xt(c,u,d),d+=l),u.set(a,d)),i.bytes=u}t.push(i.bytes),e+=i.bytes.byteLength}return nt(t,e)}function Mhe(n){var s;if(n.charAt(0)!=="/")throw new ai('String multiaddr must start with "/"');const e=[];let t="protocol",r="",i="";for(let o=1;o<n.length;o++){const a=n.charAt(o);a!=="/"&&(t==="protocol"?i+=n.charAt(o):r+=n.charAt(o));const c=o===n.length-1;if(a==="/"||c){const l=Gu.getProtocol(i);if(t==="protocol"){if(l.size==null||l.size===0){e.push({code:l.code,name:l.name}),r="",i="",t="protocol";continue}else if(c)throw new ai(`Component ${i} was missing value`);t="value"}else if(t==="value"){const u={code:l.code,name:l.name};if(l.size!=null&&l.size!==0){if(r==="")throw new ai(`Component ${i} was missing value`);u.value=((s=l.stringToValue)==null?void 0:s.call(l,r))??r}e.push(u),r="",i="",t="protocol"}}}if(i!==""&&r!=="")throw new ai("Incomplete multiaddr");return e}function Che(n){return`/${n.flatMap(e=>{var r;if(e.value==null)return e.name;const t=Gu.getProtocol(e.code);if(t==null)throw new ai(`Unknown protocol code ${e.code}`);return[e.name,((r=t.valueToString)==null?void 0:r.call(t,e.value))??e.value]}).join("/")}`}function Ihe(n,e,t){return n.size==null||n.size===0?0:n.size>0?n.size/8:zt(e,t)}const Phe=Symbol.for("nodejs.util.inspect.custom"),uN=Symbol.for("@multiformats/multiaddr");function Dhe(n){if(n==null&&(n="/"),Ohe(n))return n.getComponents();if(n instanceof Uint8Array)return The(n);if(typeof n=="string")return n=n.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),n===""&&(n="/"),Mhe(n);if(Array.isArray(n))return n;throw new ai("Must be a string, Uint8Array, Component[], or another Multiaddr")}var bI,Ci,Kl,Xl,Ys;let Rhe=(Ys=class{constructor(e="/",t={}){h(this,bI,!0);me(this,Ci);me(this,Kl);me(this,Xl);pe(this,Ci,Dhe(e)),t.validate!==!1&&Lhe(this)}get bytes(){return D(this,Xl)==null&&pe(this,Xl,Ahe(D(this,Ci))),D(this,Xl)}toString(){return D(this,Kl)==null&&pe(this,Kl,Che(D(this,Ci))),D(this,Kl)}toJSON(){return this.toString()}getComponents(){return[...D(this,Ci).map(e=>({...e}))]}encapsulate(e){const t=new Ys(e);return new Ys([...D(this,Ci),...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),r=this.toString(),i=r.lastIndexOf(t);if(i<0)throw new Sue(`Address ${this.toString()} does not contain subaddress: ${t}`);return new Ys(r.slice(0,i),{validate:!1})}decapsulateCode(e){let t;for(let r=D(this,Ci).length-1;r>-1;r--)if(D(this,Ci)[r].code===e){t=r;break}return new Ys(D(this,Ci).slice(0,t),{validate:!1})}equals(e){return Ne(this.bytes,e.bytes)}[(bI=uN,Phe)](){return`Multiaddr(${this.toString()})`}},Ci=new WeakMap,Kl=new WeakMap,Xl=new WeakMap,Ys);function Lhe(n){n.getComponents().forEach(e=>{var r;const t=Gu.getProtocol(e.code);e.value!=null&&((r=t.validate)==null||r.call(t,e.value))})}function Ohe(n){return!!(n!=null&&n[uN])}function Nhe(n){return new Rhe(n)}const Uhe="bootstrap",Bhe=50,khe=1e3;var wI,vI,_I,EI;class hN extends(EI=fr,_I=hue,vI=Symbol.toStringTag,wI=due,EI){constructor(t,r={list:[]}){if(r.list==null||r.list.length===0)throw new Error("Bootstrap requires a list of peer addresses");super();h(this,"log");h(this,"timer");h(this,"list");h(this,"timeout");h(this,"components");h(this,"_init");h(this,_I,this);h(this,vI,"@libp2p/bootstrap");h(this,wI,["@libp2p/peer-discovery"]);this.components=t,this.log=t.logger.forComponent("libp2p:bootstrap"),this.timeout=r.timeout??khe,this.list=r.list.map(i=>Nhe(i)).filter(i=>{var o;return tS.matches(i)?((o=i.getComponents().findLast(a=>a.code===M_))==null?void 0:o.value)==null?(this.log.error("invalid bootstrap multiaddr without peer id"),!1):!0:(this.log.error("invalid multiaddr %a",i),!1)}).map(i=>{var s;return{id:wue(((s=i.getComponents().findLast(o=>o.code===M_))==null?void 0:s.value)??""),multiaddrs:[i]}}),this._init=r}isStarted(){return!!this.timer}start(){this.isStarted()||(this.log("Starting bootstrap node discovery, discovering peers after %s ms",this.timeout),this.timer=setTimeout(()=>{this._discoverBootstrapPeers().catch(t=>{this.log.error("failed to discover bootstrap peers - %e",t)})},this.timeout))}async _discoverBootstrapPeers(){if(this.timer!=null)for(const t of this.list){if(await this.components.peerStore.merge(t.id,{tags:{[this._init.tagName??Uhe]:{value:this._init.tagValue??Bhe,ttl:this._init.tagTTL}},multiaddrs:t.multiaddrs}),this.timer==null)return;this.safeDispatchEvent("peer",{detail:t}),this.components.connectionManager.openConnection(t.id).catch(r=>{this.log.error("could not dial bootstrap peer %p - %e",t.id,r)})}}stop(){this.timer!=null&&clearTimeout(this.timer),this.timer=void 0}}h(hN,"tag","bootstrap");function $he(n){return e=>new hN(e,n)}class dN extends Error{constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}}h(dN,"name","UnsupportedKeyTypeError");const Fhe=Symbol.for("@libp2p/peer-discovery"),zhe=Symbol.for("@libp2p/peer-id"),Vhe=Symbol.for("nodejs.util.inspect.custom"),Hhe=114;var SI;let LS=class{constructor(e){h(this,"type");h(this,"multihash");h(this,"publicKey");h(this,"string");h(this,SI,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=at.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return ze.createV1(Hhe,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return Ne(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return Ne(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(SI=zhe,Vhe)](){return`PeerId(${this.toString()})`}},Ghe=class extends LS{constructor(t){super({...t,type:"RSA"});h(this,"type","RSA");h(this,"publicKey");this.publicKey=t.publicKey}},Whe=class extends LS{constructor(t){super({...t,type:"Ed25519"});h(this,"type","Ed25519");h(this,"publicKey");this.publicKey=t.publicKey}},qhe=class extends LS{constructor(t){super({...t,type:"secp256k1"});h(this,"type","secp256k1");h(this,"publicKey");this.publicKey=t.publicKey}};function Khe(n){if(n.type==="Ed25519")return new Whe({multihash:n.toCID().multihash,publicKey:n});if(n.type==="secp256k1")return new qhe({multihash:n.toCID().multihash,publicKey:n});if(n.type==="RSA")return new Ghe({multihash:n.toCID().multihash,publicKey:n});throw new dN}var tv;let ci=(tv=class extends Error{constructor(){super(...arguments);h(this,"name","InvalidMultiaddrError")}},h(tv,"name","InvalidMultiaddrError"),tv);var nv;let Pd=(nv=class extends Error{constructor(){super(...arguments);h(this,"name","ValidationError")}},h(nv,"name","ValidationError"),nv);var rv;let Xhe=(rv=class extends Error{constructor(){super(...arguments);h(this,"name","InvalidParametersError")}},h(rv,"name","InvalidParametersError"),rv);var iv;let Yhe=(iv=class extends Error{constructor(){super(...arguments);h(this,"name","UnknownProtocolError")}},h(iv,"name","UnknownProtocolError"),iv);const Zhe=4,jhe=6,Jhe=273,Qhe=33,ede=41,tde=42,nde=43,rde=53,ide=54,sde=55,ode=56,ade=132,cde=301,lde=302,ude=400,hde=421,dde=444,fde=445,pde=446,mde=447,gde=448,yde=449,bde=454,wde=460,vde=461,_de=465,Ede=466,Sde=480,xde=481,Tde=443,Ade=477,Mde=478,Cde=479,Ide=277,Pde=275,Dde=276,Rde=280,Lde=281,Ode=290,Nde=777;function K2(n){return e=>ne(e,n)}function X2(n){return e=>ge(e,n)}function Lh(n){return new DataView(n.buffer).getUint16(n.byteOffset).toString()}function rl(n){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof n=="string"?parseInt(n):n),new Uint8Array(e)}function Ude(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=ge(e[0],"base32"),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const i=rl(r);return nt([t,i],t.length+i.length)}function Bde(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=yn.decode(`b${e[0]}`),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const i=rl(r);return nt([t,i],t.length+i.length)}function Y2(n){const e=n.subarray(0,n.length-2),t=n.subarray(n.length-2),r=ne(e,"base32"),i=Lh(t);return`${r}:${i}`}const fN=function(n){n=n.toString().trim();const e=new Uint8Array(4);return n.split(/\./g).forEach((t,r)=>{const i=parseInt(t,10);if(isNaN(i)||i<0||i>255)throw new ci("Invalid byte value in IP address");e[r]=i}),e},kde=function(n){let e=0;n=n.toString().trim();const t=n.split(":",8);let r;for(r=0;r<t.length;r++){const s=Pt(t[r]);let o;s&&(o=fN(t[r]),t[r]=ne(o.subarray(0,2),"base16")),o!=null&&++r<8&&t.splice(r,0,ne(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(r=0;r<t.length&&t[r]!=="";r++);const s=[r,1];for(r=9-t.length;r>0;r--)s.push("0");t.splice.apply(t,s)}const i=new Uint8Array(e+16);for(r=0;r<t.length;r++){t[r]===""&&(t[r]="0");const s=parseInt(t[r],16);if(isNaN(s)||s<0||s>65535)throw new ci("Invalid byte value in IP address");i[e++]=s>>8&255,i[e++]=s&255}return i},$de=function(n){if(n.byteLength!==4)throw new ci("IPv4 address was incorrect length");const e=[];for(let t=0;t<n.byteLength;t++)e.push(n[t]);return e.join(".")},Fde=function(n){if(n.byteLength!==16)throw new ci("IPv6 address was incorrect length");const e=[];for(let r=0;r<n.byteLength;r+=2){const i=n[r],s=n[r+1],o=`${i.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const r=new URL(`http://[${t}]`);return r.hostname.substring(1,r.hostname.length-1)}catch{throw new ci(`Invalid IPv6 address "${t}"`)}};function zde(n){try{const e=new URL(`http://[${n}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new ci(`Invalid IPv6 address "${n}"`)}}const j0=Object.values(Fr).map(n=>n.decoder),Vde=(function(){let n=j0[0].or(j0[1]);return j0.slice(2).forEach(e=>n=n.or(e)),n})();function Hde(n){return Vde.decode(n)}function Gde(n){return e=>n.encoder.encode(e)}function Wde(n){if(parseInt(n).toString()!==n)throw new Pd("Value must be an integer")}function qde(n){if(n<0)throw new Pd("Value must be a positive integer, or zero")}function Kde(n){return e=>{if(e>n)throw new Pd(`Value must be smaller than or equal to ${n}`)}}function Xde(...n){return e=>{for(const t of n)t(e)}}const Ap=Xde(Wde,qde,Kde(65535)),Wn=-1;let Yde=class{constructor(){h(this,"protocolsByCode",new Map);h(this,"protocolsByName",new Map)}getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new Yhe(`Protocol ${e} was unknown`);return t}addProtocol(e){var t;this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),(t=e.aliases)==null||t.forEach(r=>{this.protocolsByName.set(r,e)})}removeProtocol(e){var r;const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),(r=t.aliases)==null||r.forEach(i=>{this.protocolsByName.delete(i)}))}};const Wu=new Yde,Zde=[{code:Zhe,name:"ip4",size:32,valueToBytes:fN,bytesToValue:$de,validate:n=>{if(!Pt(n))throw new Pd(`Invalid IPv4 address "${n}"`)}},{code:jhe,name:"tcp",size:16,valueToBytes:rl,bytesToValue:Lh,validate:Ap},{code:Jhe,name:"udp",size:16,valueToBytes:rl,bytesToValue:Lh,validate:Ap},{code:Qhe,name:"dccp",size:16,valueToBytes:rl,bytesToValue:Lh,validate:Ap},{code:ede,name:"ip6",size:128,valueToBytes:kde,bytesToValue:Fde,stringToValue:zde,validate:n=>{if(!hi(n))throw new Pd(`Invalid IPv6 address "${n}"`)}},{code:tde,name:"ip6zone",size:Wn},{code:nde,name:"ipcidr",size:8,bytesToValue:K2("base10"),valueToBytes:X2("base10")},{code:rde,name:"dns",size:Wn},{code:ide,name:"dns4",size:Wn},{code:sde,name:"dns6",size:Wn},{code:ode,name:"dnsaddr",size:Wn},{code:ade,name:"sctp",size:16,valueToBytes:rl,bytesToValue:Lh,validate:Ap},{code:cde,name:"udt"},{code:lde,name:"utp"},{code:ude,name:"unix",size:Wn,stringToValue:n=>decodeURIComponent(n),valueToString:n=>encodeURIComponent(n)},{code:hde,name:"p2p",aliases:["ipfs"],size:Wn,bytesToValue:K2("base58btc"),valueToBytes:n=>n.startsWith("Q")||n.startsWith("1")?X2("base58btc")(n):ze.parse(n).multihash.bytes},{code:dde,name:"onion",size:96,bytesToValue:Y2,valueToBytes:Ude},{code:fde,name:"onion3",size:296,bytesToValue:Y2,valueToBytes:Bde},{code:pde,name:"garlic64",size:Wn},{code:mde,name:"garlic32",size:Wn},{code:gde,name:"tls"},{code:yde,name:"sni",size:Wn},{code:bde,name:"noise"},{code:wde,name:"quic"},{code:vde,name:"quic-v1"},{code:_de,name:"webtransport"},{code:Ede,name:"certhash",size:Wn,bytesToValue:Gde(ui),valueToBytes:Hde},{code:Sde,name:"http"},{code:xde,name:"http-path",size:Wn,stringToValue:n=>`/${decodeURIComponent(n)}`,valueToString:n=>encodeURIComponent(n.substring(1))},{code:Tde,name:"https"},{code:Ade,name:"ws"},{code:Mde,name:"wss"},{code:Cde,name:"p2p-websocket-star"},{code:Ide,name:"p2p-stardust"},{code:Pde,name:"p2p-webrtc-star"},{code:Dde,name:"p2p-webrtc-direct"},{code:Rde,name:"webrtc-direct"},{code:Lde,name:"webrtc"},{code:Ode,name:"p2p-circuit"},{code:Nde,name:"memory",size:Wn}];Zde.forEach(n=>{Wu.addProtocol(n)});function jde(n){var r;const e=[];let t=0;for(;t<n.length;){const i=zt(n,t),s=Wu.getProtocol(i),o=Me(i),a=tfe(s,n,t+o);let c=0;a>0&&s.size===Wn&&(c=Me(a));const l=o+c+a,u={code:i,name:s.name,bytes:n.subarray(t,t+l)};if(a>0){const d=t+o+c,f=n.subarray(d,d+a);u.value=((r=s.bytesToValue)==null?void 0:r.call(s,f))??ne(f)}e.push(u),t+=l}return e}function Jde(n){var r;let e=0;const t=[];for(const i of n){if(i.bytes==null){const s=Wu.getProtocol(i.code),o=Me(i.code);let a,c=0,l=0;i.value!=null&&(a=((r=s.valueToBytes)==null?void 0:r.call(s,i.value))??ge(i.value),c=a.byteLength,s.size===Wn&&(l=Me(c)));const u=new Uint8Array(o+l+c);let d=0;Xt(i.code,u,d),d+=o,a!=null&&(s.size===Wn&&(Xt(c,u,d),d+=l),u.set(a,d)),i.bytes=u}t.push(i.bytes),e+=i.bytes.byteLength}return nt(t,e)}function Qde(n){var s;if(n.charAt(0)!=="/")throw new ci('String multiaddr must start with "/"');const e=[];let t="protocol",r="",i="";for(let o=1;o<n.length;o++){const a=n.charAt(o);a!=="/"&&(t==="protocol"?i+=n.charAt(o):r+=n.charAt(o));const c=o===n.length-1;if(a==="/"||c){const l=Wu.getProtocol(i);if(t==="protocol"){if(l.size==null||l.size===0){e.push({code:l.code,name:l.name}),r="",i="",t="protocol";continue}else if(c)throw new ci(`Component ${i} was missing value`);t="value"}else if(t==="value"){const u={code:l.code,name:l.name};if(l.size!=null&&l.size!==0){if(r==="")throw new ci(`Component ${i} was missing value`);u.value=((s=l.stringToValue)==null?void 0:s.call(l,r))??r}e.push(u),r="",i="",t="protocol"}}}if(i!==""&&r!=="")throw new ci("Incomplete multiaddr");return e}function efe(n){return`/${n.flatMap(e=>{var r;if(e.value==null)return e.name;const t=Wu.getProtocol(e.code);if(t==null)throw new ci(`Unknown protocol code ${e.code}`);return[e.name,((r=t.valueToString)==null?void 0:r.call(t,e.value))??e.value]}).join("/")}`}function tfe(n,e,t){return n.size==null||n.size===0?0:n.size>0?n.size/8:zt(e,t)}const nfe=Symbol.for("nodejs.util.inspect.custom"),pN=Symbol.for("@multiformats/multiaddr");function rfe(n){if(n==null&&(n="/"),ofe(n))return n.getComponents();if(n instanceof Uint8Array)return jde(n);if(typeof n=="string")return n=n.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),n===""&&(n="/"),Qde(n);if(Array.isArray(n))return n;throw new ci("Must be a string, Uint8Array, Component[], or another Multiaddr")}var xI,Ii,Yl,Zl,Zs;let ife=(Zs=class{constructor(e="/",t={}){h(this,xI,!0);me(this,Ii);me(this,Yl);me(this,Zl);pe(this,Ii,rfe(e)),t.validate!==!1&&sfe(this)}get bytes(){return D(this,Zl)==null&&pe(this,Zl,Jde(D(this,Ii))),D(this,Zl)}toString(){return D(this,Yl)==null&&pe(this,Yl,efe(D(this,Ii))),D(this,Yl)}toJSON(){return this.toString()}getComponents(){return[...D(this,Ii).map(e=>({...e}))]}encapsulate(e){const t=new Zs(e);return new Zs([...D(this,Ii),...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),r=this.toString(),i=r.lastIndexOf(t);if(i<0)throw new Xhe(`Address ${this.toString()} does not contain subaddress: ${t}`);return new Zs(r.slice(0,i),{validate:!1})}decapsulateCode(e){let t;for(let r=D(this,Ii).length-1;r>-1;r--)if(D(this,Ii)[r].code===e){t=r;break}return new Zs(D(this,Ii).slice(0,t),{validate:!1})}equals(e){return Ne(this.bytes,e.bytes)}[(xI=pN,nfe)](){return`Multiaddr(${this.toString()})`}},Ii=new WeakMap,Yl=new WeakMap,Zl=new WeakMap,Zs);function sfe(n){n.getComponents().forEach(e=>{var r;const t=Wu.getProtocol(e.code);e.value!=null&&((r=t.validate)==null||r.call(t,e.value))})}function ofe(n){return!!(n!=null&&n[pN])}function afe(n){return new ife(n)}var cg;(function(n){let e;n.codec=()=>(e==null&&(e=Nt((t,r,i={})=>{if(i.lengthDelimited!==!1&&r.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(r.uint32(10),r.bytes(t.publicKey)),t.addrs!=null)for(const s of t.addrs)r.uint32(18),r.bytes(s);i.lengthDelimited!==!1&&r.ldelim()},(t,r,i={})=>{var a;const s={publicKey:ht(0),addrs:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const c=t.uint32();switch(c>>>3){case 1:{s.publicKey=t.bytes();break}case 2:{if(((a=i.limits)==null?void 0:a.addrs)!=null&&s.addrs.length===i.limits.addrs)throw new ls('Decode error - map field "addrs" had too many elements');s.addrs.push(t.bytes());break}default:{t.skipType(c&7);break}}}return s})),e),n.encode=t=>Ot(t,n.codec()),n.decode=(t,r)=>Lt(t,n.codec(),r)})(cg||(cg={}));const cfe="_peer-discovery._p2p._pubsub";var TI,AI,MI;class lfe extends(MI=fr,AI=Fhe,TI=Symbol.toStringTag,MI){constructor(t,r={}){super();h(this,AI,!0);h(this,TI,"@libp2p/pubsub-peer-discovery");h(this,"interval");h(this,"listenOnly");h(this,"topics");h(this,"intervalId");h(this,"components");h(this,"log");const{interval:i,topics:s,listenOnly:o}=r;this.components=t,this.interval=i??1e4,this.listenOnly=o??!1,this.log=t.logger.forComponent("libp2p:discovery:pubsub"),Array.isArray(s)&&s.length>0?this.topics=s:this.topics=[cfe],this._onMessage=this._onMessage.bind(this)}isStarted(){return this.intervalId!=null}start(){}afterStart(){if(this.intervalId!=null)return;const t=this.components.pubsub;if(t==null)throw new Error("PubSub not configured");for(const r of this.topics)t.subscribe(r),t.addEventListener("message",this._onMessage);this.listenOnly||(this._broadcast(),this.intervalId=setInterval(()=>{this._broadcast()},this.interval))}beforeStop(){const t=this.components.pubsub;if(t==null)throw new Error("PubSub not configured");for(const r of this.topics)t.unsubscribe(r),t.removeEventListener("message",this._onMessage)}stop(){this.intervalId!=null&&(clearInterval(this.intervalId),this.intervalId=void 0)}_broadcast(){const t=this.components.peerId;if(t.publicKey==null)throw new Error("PeerId was missing public key");const r={publicKey:as(t.publicKey),addrs:this.components.addressManager.getAddresses().map(o=>o.bytes)},i=cg.encode(r),s=this.components.pubsub;if(s==null)throw new Error("PubSub not configured");for(const o of this.topics){if(s.getSubscribers(o).length===0){this.log("skipping broadcasting our peer data on topic %s because there are no peers present",o);continue}this.log("broadcasting our peer data on topic %s",o),s.publish(o,i)}}_onMessage(t){if(!this.isStarted())return;const r=t.detail;if(this.topics.includes(r.topic))try{const i=cg.decode(r.data),s=no(i.publicKey),o=Khe(s);if(o.equals(this.components.peerId))return;this.log("discovered peer %p on %s",o,r.topic),this.safeDispatchEvent("peer",{detail:{id:o,multiaddrs:i.addrs.map(a=>afe(a))}})}catch(i){this.log.error("error handling incoming message",i)}}}function ufe(n={}){return e=>new lfe(e,n)}const mN=Symbol.for("@libp2p/peer-id");var sv;let hfe=(sv=class extends Error{constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}},h(sv,"name","InvalidParametersError"),sv);class gN extends Error{constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}}h(gN,"name","InvalidCIDError");class yN extends Error{constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}}h(yN,"name","InvalidMultihashError");const bN=Symbol.for("nodejs.util.inspect.custom"),dfe=114;var CI;class OS{constructor(e){h(this,"type");h(this,"multihash");h(this,"publicKey");h(this,"string");h(this,CI,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=at.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return ze.createV1(dfe,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return Ne(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return Ne(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(CI=mN,bN)](){return`PeerId(${this.toString()})`}}class ffe extends OS{constructor(t){super({...t,type:"RSA"});h(this,"type","RSA");h(this,"publicKey");this.publicKey=t.publicKey}}class pfe extends OS{constructor(t){super({...t,type:"Ed25519"});h(this,"type","Ed25519");h(this,"publicKey");this.publicKey=t.publicKey}}class mfe extends OS{constructor(t){super({...t,type:"secp256k1"});h(this,"type","secp256k1");h(this,"publicKey");this.publicKey=t.publicKey}}const gfe=2336;var II,PI;class wN{constructor(e){h(this,"type","url");h(this,"multihash");h(this,"publicKey");h(this,"url");h(this,II,!0);this.url=e.toString(),this.multihash=Zt.digest(ge(this.url))}[(PI=bN,II=mN,PI)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return ze.createV1(gfe,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=ne(e)),e.toString()===this.toString())}}const yfe=114,Z2=2336;function J0(n,e){let t;if(n.charAt(0)==="1"||n.charAt(0)==="Q")t=co(at.decode(`z${n}`));else{if(n.startsWith("k51qzi5uqu5")||n.startsWith("kzwfwjn5ji4")||n.startsWith("k2k4r8")||n.startsWith("bafz"))return bfe(ze.parse(n));throw new hfe('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return vN(t)}function vN(n){if(vfe(n))return new ffe({multihash:n});if(wfe(n))try{const e=lo(n);if(e.type==="Ed25519")return new pfe({multihash:n,publicKey:e});if(e.type==="secp256k1")return new mfe({multihash:n,publicKey:e})}catch{const t=ne(n.digest);return new wN(new URL(t))}throw new yN("Supplied PeerID Multihash is invalid")}function bfe(n){if((n==null?void 0:n.multihash)==null||n.version==null||n.version===1&&n.code!==yfe&&n.code!==Z2)throw new gN("Supplied PeerID CID is invalid");if(n.code===Z2){const e=ne(n.multihash.digest);return new wN(new URL(e))}return vN(n.multihash)}function wfe(n){return n.code===Zt.code}function vfe(n){return n.code===ps.code}class Br extends Error{constructor(){super(...arguments);h(this,"name","InvalidMultiaddrError")}}h(Br,"name","InvalidMultiaddrError");class Eu extends Error{constructor(){super(...arguments);h(this,"name","ValidationError")}}h(Eu,"name","ValidationError");class _N extends Error{constructor(){super(...arguments);h(this,"name","InvalidParametersError")}}h(_N,"name","InvalidParametersError");class EN extends Error{constructor(){super(...arguments);h(this,"name","UnknownProtocolError")}}h(EN,"name","UnknownProtocolError");const C_=4,I_=6,P_=273,_fe=33,Yp=41,SN=42,Efe=43,xN=53,TN=54,NS=55,AN=56,Sfe=132,xfe=301,Tfe=302,Afe=400,MN=421,Mfe=444,Cfe=445,Ife=446,Pfe=447,Dfe=448,Rfe=449,Lfe=454,Ofe=460,Nfe=461,Ufe=465,Bfe=466,kfe=480,$fe=481,Ffe=443,zfe=477,Vfe=478,Hfe=479,Gfe=277,Wfe=275,qfe=276,Kfe=280,Xfe=281,CN=290,Yfe=777;function j2(n){return e=>ne(e,n)}function J2(n){return e=>ge(e,n)}function Oh(n){return new DataView(n.buffer).getUint16(n.byteOffset).toString()}function il(n){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof n=="string"?parseInt(n):n),new Uint8Array(e)}function Zfe(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=ge(e[0],"base32"),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const i=il(r);return nt([t,i],t.length+i.length)}function jfe(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=yn.decode(`b${e[0]}`),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const i=il(r);return nt([t,i],t.length+i.length)}function Q2(n){const e=n.subarray(0,n.length-2),t=n.subarray(n.length-2),r=ne(e,"base32"),i=Oh(t);return`${r}:${i}`}const IN=function(n){n=n.toString().trim();const e=new Uint8Array(4);return n.split(/\./g).forEach((t,r)=>{const i=parseInt(t,10);if(isNaN(i)||i<0||i>255)throw new Br("Invalid byte value in IP address");e[r]=i}),e},Jfe=function(n){let e=0;n=n.toString().trim();const t=n.split(":",8);let r;for(r=0;r<t.length;r++){const s=Pt(t[r]);let o;s&&(o=IN(t[r]),t[r]=ne(o.subarray(0,2),"base16")),o!=null&&++r<8&&t.splice(r,0,ne(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(r=0;r<t.length&&t[r]!=="";r++);const s=[r,1];for(r=9-t.length;r>0;r--)s.push("0");t.splice.apply(t,s)}const i=new Uint8Array(e+16);for(r=0;r<t.length;r++){t[r]===""&&(t[r]="0");const s=parseInt(t[r],16);if(isNaN(s)||s<0||s>65535)throw new Br("Invalid byte value in IP address");i[e++]=s>>8&255,i[e++]=s&255}return i},Qfe=function(n){if(n.byteLength!==4)throw new Br("IPv4 address was incorrect length");const e=[];for(let t=0;t<n.byteLength;t++)e.push(n[t]);return e.join(".")},epe=function(n){if(n.byteLength!==16)throw new Br("IPv6 address was incorrect length");const e=[];for(let r=0;r<n.byteLength;r+=2){const i=n[r],s=n[r+1],o=`${i.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const r=new URL(`http://[${t}]`);return r.hostname.substring(1,r.hostname.length-1)}catch{throw new Br(`Invalid IPv6 address "${t}"`)}};function tpe(n){try{const e=new URL(`http://[${n}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new Br(`Invalid IPv6 address "${n}"`)}}const Q0=Object.values(Fr).map(n=>n.decoder),npe=(function(){let n=Q0[0].or(Q0[1]);return Q0.slice(2).forEach(e=>n=n.or(e)),n})();function rpe(n){return npe.decode(n)}function ipe(n){return e=>n.encoder.encode(e)}function spe(n){if(parseInt(n).toString()!==n)throw new Eu("Value must be an integer")}function ope(n){if(n<0)throw new Eu("Value must be a positive integer, or zero")}function ape(n){return e=>{if(e>n)throw new Eu(`Value must be smaller than or equal to ${n}`)}}function cpe(...n){return e=>{for(const t of n)t(e)}}const Mp=cpe(spe,ope,ape(65535)),qn=-1;class lpe{constructor(){h(this,"protocolsByCode",new Map);h(this,"protocolsByName",new Map)}getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new EN(`Protocol ${e} was unknown`);return t}addProtocol(e){var t;this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),(t=e.aliases)==null||t.forEach(r=>{this.protocolsByName.set(r,e)})}removeProtocol(e){var r;const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),(r=t.aliases)==null||r.forEach(i=>{this.protocolsByName.delete(i)}))}}const Js=new lpe,upe=[{code:C_,name:"ip4",size:32,valueToBytes:IN,bytesToValue:Qfe,validate:n=>{if(!Pt(n))throw new Eu(`Invalid IPv4 address "${n}"`)}},{code:I_,name:"tcp",size:16,valueToBytes:il,bytesToValue:Oh,validate:Mp},{code:P_,name:"udp",size:16,valueToBytes:il,bytesToValue:Oh,validate:Mp},{code:_fe,name:"dccp",size:16,valueToBytes:il,bytesToValue:Oh,validate:Mp},{code:Yp,name:"ip6",size:128,valueToBytes:Jfe,bytesToValue:epe,stringToValue:tpe,validate:n=>{if(!hi(n))throw new Eu(`Invalid IPv6 address "${n}"`)}},{code:SN,name:"ip6zone",size:qn},{code:Efe,name:"ipcidr",size:8,bytesToValue:j2("base10"),valueToBytes:J2("base10")},{code:xN,name:"dns",size:qn,resolvable:!0},{code:TN,name:"dns4",size:qn,resolvable:!0},{code:NS,name:"dns6",size:qn,resolvable:!0},{code:AN,name:"dnsaddr",size:qn,resolvable:!0},{code:Sfe,name:"sctp",size:16,valueToBytes:il,bytesToValue:Oh,validate:Mp},{code:xfe,name:"udt"},{code:Tfe,name:"utp"},{code:Afe,name:"unix",size:qn,path:!0,stringToValue:n=>decodeURIComponent(n),valueToString:n=>encodeURIComponent(n)},{code:MN,name:"p2p",aliases:["ipfs"],size:qn,bytesToValue:j2("base58btc"),valueToBytes:n=>n.startsWith("Q")||n.startsWith("1")?J2("base58btc")(n):ze.parse(n).multihash.bytes},{code:Mfe,name:"onion",size:96,bytesToValue:Q2,valueToBytes:Zfe},{code:Cfe,name:"onion3",size:296,bytesToValue:Q2,valueToBytes:jfe},{code:Ife,name:"garlic64",size:qn},{code:Pfe,name:"garlic32",size:qn},{code:Dfe,name:"tls"},{code:Rfe,name:"sni",size:qn},{code:Lfe,name:"noise"},{code:Ofe,name:"quic"},{code:Nfe,name:"quic-v1"},{code:Ufe,name:"webtransport"},{code:Bfe,name:"certhash",size:qn,bytesToValue:ipe(ui),valueToBytes:rpe},{code:kfe,name:"http"},{code:$fe,name:"http-path",size:qn,stringToValue:n=>`/${decodeURIComponent(n)}`,valueToString:n=>encodeURIComponent(n.substring(1))},{code:Ffe,name:"https"},{code:zfe,name:"ws"},{code:Vfe,name:"wss"},{code:Hfe,name:"p2p-websocket-star"},{code:Gfe,name:"p2p-stardust"},{code:Wfe,name:"p2p-webrtc-star"},{code:qfe,name:"p2p-webrtc-direct"},{code:Kfe,name:"webrtc-direct"},{code:Xfe,name:"webrtc"},{code:CN,name:"p2p-circuit"},{code:Yfe,name:"memory",size:qn}];upe.forEach(n=>{Js.addProtocol(n)});function hpe(n){var r;const e=[];let t=0;for(;t<n.length;){const i=zt(n,t),s=Js.getProtocol(i),o=Me(i),a=mpe(s,n,t+o);let c=0;a>0&&s.size===qn&&(c=Me(a));const l=o+c+a,u={code:i,name:s.name,bytes:n.subarray(t,t+l)};if(a>0){const d=t+o+c,f=n.subarray(d,d+a);u.value=((r=s.bytesToValue)==null?void 0:r.call(s,f))??ne(f)}e.push(u),t+=l}return e}function dpe(n){var r;let e=0;const t=[];for(const i of n){if(i.bytes==null){const s=Js.getProtocol(i.code),o=Me(i.code);let a,c=0,l=0;i.value!=null&&(a=((r=s.valueToBytes)==null?void 0:r.call(s,i.value))??ge(i.value),c=a.byteLength,s.size===qn&&(l=Me(c)));const u=new Uint8Array(o+l+c);let d=0;Xt(i.code,u,d),d+=o,a!=null&&(s.size===qn&&(Xt(c,u,d),d+=l),u.set(a,d)),i.bytes=u}t.push(i.bytes),e+=i.bytes.byteLength}return nt(t,e)}function fpe(n){var s;if(n.charAt(0)!=="/")throw new Br('String multiaddr must start with "/"');const e=[];let t="protocol",r="",i="";for(let o=1;o<n.length;o++){const a=n.charAt(o);a!=="/"&&(t==="protocol"?i+=n.charAt(o):r+=n.charAt(o));const c=o===n.length-1;if(a==="/"||c){const l=Js.getProtocol(i);if(t==="protocol"){if(l.size==null||l.size===0){e.push({code:l.code,name:l.name}),r="",i="",t="protocol";continue}else if(c)throw new Br(`Component ${i} was missing value`);t="value"}else if(t==="value"){const u={code:l.code,name:l.name};if(l.size!=null&&l.size!==0){if(r==="")throw new Br(`Component ${i} was missing value`);u.value=((s=l.stringToValue)==null?void 0:s.call(l,r))??r}e.push(u),r="",i="",t="protocol"}}}if(i!==""&&r!=="")throw new Br("Incomplete multiaddr");return e}function ppe(n){return`/${n.flatMap(e=>{var r;if(e.value==null)return e.name;const t=Js.getProtocol(e.code);if(t==null)throw new Br(`Unknown protocol code ${e.code}`);return[e.name,((r=t.valueToString)==null?void 0:r.call(t,e.value))??e.value]}).join("/")}`}function mpe(n,e,t){return n.size==null||n.size===0?0:n.size>0?n.size/8:zt(e,t)}const gpe=Symbol.for("nodejs.util.inspect.custom"),PN=Symbol.for("@multiformats/multiaddr"),ype=[xN,TN,NS,AN];class bpe extends Error{constructor(e="No available resolver"){super(e),this.name="NoAvailableResolverError"}}function wpe(n){if(n==null&&(n="/"),Epe(n))return n.getComponents();if(n instanceof Uint8Array)return hpe(n);if(typeof n=="string")return n=n.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),n===""&&(n="/"),fpe(n);if(Array.isArray(n))return n;throw new Br("Must be a string, Uint8Array, Component[], or another Multiaddr")}var DI,Bt,jl,Jl;const ol=class ol{constructor(e="/",t={}){h(this,DI,!0);me(this,Bt);me(this,jl);me(this,Jl);pe(this,Bt,wpe(e)),t.validate!==!1&&vpe(this)}get bytes(){return D(this,Jl)==null&&pe(this,Jl,dpe(D(this,Bt))),D(this,Jl)}toString(){return D(this,jl)==null&&pe(this,jl,ppe(D(this,Bt))),D(this,jl)}toJSON(){return this.toString()}toOptions(){let e,t,r,i,s="";for(const{code:a,name:c,value:l}of D(this,Bt))a===SN&&(s=`%${l??""}`),ype.includes(a)&&(t="tcp",i=443,r=`${l??""}${s}`,e=a===NS?6:4),(a===I_||a===P_)&&(t=c==="tcp"?"tcp":"udp",i=parseInt(l??"")),(a===C_||a===Yp)&&(t="tcp",r=`${l??""}${s}`,e=a===Yp?6:4);if(e==null||t==null||r==null||i==null)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:e,host:r,transport:t,port:i}}getComponents(){return[...D(this,Bt)]}protos(){return D(this,Bt).map(({code:e,value:t})=>{const r=Js.getProtocol(e);return{code:e,size:r.size??0,name:r.name,resolvable:!!r.resolvable,path:!!r.path}})}protoCodes(){return D(this,Bt).map(({code:e})=>e)}protoNames(){return D(this,Bt).map(({name:e})=>e)}tuples(){return D(this,Bt).map(({code:e,value:t})=>{var s;if(t==null)return[e];const r=Js.getProtocol(e),i=[e];return t!=null&&i.push(((s=r.valueToBytes)==null?void 0:s.call(r,t))??ge(t)),i})}stringTuples(){return D(this,Bt).map(({code:e,value:t})=>t==null?[e]:[e,t])}encapsulate(e){const t=new ol(e);return new ol([...D(this,Bt),...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),r=this.toString(),i=r.lastIndexOf(t);if(i<0)throw new _N(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`);return new ol(r.slice(0,i),{validate:!1})}decapsulateCode(e){let t;for(let r=D(this,Bt).length-1;r>-1;r--)if(D(this,Bt)[r].code===e){t=r;break}return new ol(D(this,Bt).slice(0,t),{validate:!1})}getPeerId(){try{let e=[];D(this,Bt).forEach(({code:r,value:i})=>{r===MN&&e.push([r,i]),r===CN&&(e=[])});const t=e.pop();if((t==null?void 0:t[1])!=null){const r=t[1];return r[0]==="Q"||r[0]==="1"?ne(at.decode(`z${r}`),"base58btc"):ne(ze.parse(r).multihash.bytes,"base58btc")}return null}catch{return null}}getPath(){for(const e of D(this,Bt))if(Js.getProtocol(e.code).path)return e.value??null;return null}equals(e){return Ne(this.bytes,e.bytes)}async resolve(e){const t=this.protos().find(s=>s.resolvable);if(t==null)return[this];const r=_pe.get(t.name);if(r==null)throw new bpe(`no available resolver for ${t.name}`);return(await r(this,e)).map(s=>US(s))}nodeAddress(){const e=this.toOptions();if(e.transport!=="tcp"&&e.transport!=="udp")throw new Error(`multiaddr must have a valid format - no protocol with name: "${e.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:e.family,address:e.host,port:e.port}}isThinWaistAddress(){return!(D(this,Bt).length!==2||D(this,Bt)[0].code!==C_&&D(this,Bt)[0].code!==Yp||D(this,Bt)[1].code!==I_&&D(this,Bt)[1].code!==P_)}[(DI=PN,gpe)](){return`Multiaddr(${this.toString()})`}};Bt=new WeakMap,jl=new WeakMap,Jl=new WeakMap;let D_=ol;function vpe(n){n.getComponents().forEach(e=>{var r;const t=Js.getProtocol(e.code);e.value!=null&&((r=t.validate)==null||r.call(t,e.value))})}const _pe=new Map;function Epe(n){return!!(n!=null&&n[PN])}function US(n){return new D_(n)}const eM=(n,e)=>typeof n!="number"||!Number.isFinite(n)?e:Math.max(1,Math.min(60,n)),wa={snapshotHz:20,commandHz:30,keepaliveMs:1e3,maxEventsPerTick:20,eventRetryMs:500,eventRetryMax:5,reliableEventTypes:[],reconnectStallMs:8e3,reconnectBackoffMs:5e3,snapshotsRequireAuthority:!1,snapshotTopic:null,commandTopic:null,eventTopic:null};class Spe{constructor(e,t={}){this.adapter=e,this.stateProviders=new Map,this.commandProviders=new Map,this.eventQueue=[],this.pendingReliableEvents=new Map,this.reliabilityStats={sent:0,acked:0,dropped:0},this.snapshotHandlers=[],this.commandHandlers=[],this.eventHandlers=[],this.seq={snapshot:0,command:0,event:0},this.lastSnapshotAt=-1/0,this.lastCommandAt=-1/0,this.lastEventAt=-1/0,this.lastRxAt=0,this.lastTxAt=0,this.lastReconnectAt=-1/0,this.stateDirty=!0,this.authorityId=null,this.configure(t)}configure(e={}){const t=Number.isFinite(e.eventRetryMs)?e.eventRetryMs:wa.eventRetryMs,r=Number.isFinite(e.eventRetryMax)?e.eventRetryMax:wa.eventRetryMax;this.profile={...wa,...e,snapshotHz:eM(e.snapshotHz,wa.snapshotHz),commandHz:eM(e.commandHz,wa.commandHz),eventRetryMs:Math.max(0,t),eventRetryMax:Math.max(1,r),reliableEventTypes:Array.isArray(e.reliableEventTypes)?e.reliableEventTypes:wa.reliableEventTypes},this.snapshotIntervalMs=Math.round(1e3/this.profile.snapshotHz),this.commandIntervalMs=Math.round(1e3/this.profile.commandHz);const i=Math.max(this.profile.snapshotHz,this.profile.commandHz);this.tickIntervalMs=Math.max(10,Math.round(1e3/i))}getProfile(){return{...this.profile}}getTickIntervalMs(){return this.tickIntervalMs}setAuthority(e){this.authorityId=e||null}getAuthority(){return this.authorityId}registerStateProvider(e,t={}){const r=t.id||`state-${Math.random().toString(36).slice(2)}`;return this.stateProviders.set(r,{fn:e,options:t}),r}registerCommandProvider(e,t={}){const r=t.id||`cmd-${Math.random().toString(36).slice(2)}`;return this.commandProviders.set(r,{fn:e,options:t}),r}unregisterStateProvider(e){this.stateProviders.delete(e)}unregisterCommandProvider(e){this.commandProviders.delete(e)}addSnapshotHandler(e){this.snapshotHandlers.push(e)}addCommandHandler(e){this.commandHandlers.push(e)}addEventHandler(e){this.eventHandlers.push(e)}markStateDirty(){this.stateDirty=!0}queueEvent(e,t={}){const r=Date.now(),i=t.reliable||t.critical,s=t.id||`evt-${r}-${Math.random().toString(36).slice(2,8)}`;return i?(this.pendingReliableEvents.has(s)||this.pendingReliableEvents.set(s,{id:s,payload:e,options:t,createdAt:r,lastSentAt:0,attempts:0,nextSendAt:0}),s):(this.eventQueue.push({id:s,payload:e,options:t,reliable:!1}),s)}recordRx(e=Date.now()){this.lastRxAt=e}recordTx(e=Date.now()){this.lastTxAt=e}handleMessage(e,t){var r,i,s,o;if(!e||typeof e.type!="string"||!e.type.startsWith("pc-"))return!1;if((r=this.adapter)!=null&&r.isInScope&&!this.adapter.isInScope(e)||e.target&&((i=this.adapter)!=null&&i.getPeerId)&&e.target!==this.adapter.getPeerId())return!0;if(this.recordRx(((s=e.header)==null?void 0:s.ts)||Date.now()),e.type==="pc-snapshot")return this.snapshotHandlers.forEach(a=>a(t,e)),!0;if(e.type==="pc-command")return this.commandHandlers.forEach(a=>a(t,e)),!0;if(e.type==="pc-ack"){const a=(o=e==null?void 0:e.payload)==null?void 0:o.eventIds;if(Array.isArray(a)){let c=0;a.forEach(l=>{this.pendingReliableEvents.delete(l)&&(c+=1)}),this.reliabilityStats.acked+=c}return!0}return e.type==="pc-event"&&(this.eventHandlers.forEach(a=>a(t,e)),this._ackReliableEvents(e,t)),!0}tick(e=Date.now()){this._flushCommands(e),this._flushSnapshots(e),this._flushEvents(e),this._checkReconnect(e)}_buildHeader(e,t){var r,i,s,o;return{type:e,seq:this.seq[e]++,ts:t,peerId:((i=(r=this.adapter)==null?void 0:r.getPeerId)==null?void 0:i.call(r))||null,authorityId:this.authorityId||((o=(s=this.adapter)==null?void 0:s.getAuthority)==null?void 0:o.call(s))||null}}_collectStatePayload(){const e=[];for(const[t,r]of this.stateProviders.entries())try{const i=r.fn();if(i==null)continue;e.push({id:t,data:i})}catch{}return e}_collectCommandPayload(){const e=[];for(const[t,r]of this.commandProviders.entries())try{const i=r.fn();if(i==null)continue;Array.isArray(i)?i.forEach(s=>e.push({id:t,data:s})):e.push({id:t,data:i})}catch{}return e}_flushSnapshots(e){var s,o,a,c,l,u;if(this.stateProviders.size===0||e-this.lastSnapshotAt<this.snapshotIntervalMs)return;const t=e-this.lastSnapshotAt>=this.profile.keepaliveMs;if(!this.stateDirty&&!t)return;const r=this._collectStatePayload();if(r.length===0&&!t)return;const i={type:"pc-snapshot",header:this._buildHeader("snapshot",e),gameId:((o=(s=this.adapter)==null?void 0:s.getGameId)==null?void 0:o.call(s))||null,roomId:((c=(a=this.adapter)==null?void 0:a.getRoomId)==null?void 0:c.call(a))||null,payload:r,keepalive:t};this.lastSnapshotAt=e,this.stateDirty=!1,(u=(l=this.adapter)==null?void 0:l.sendSnapshot)==null||u.call(l,i),this.recordTx(e)}_flushCommands(e){var i,s,o,a,c,l;if(this.commandProviders.size===0||e-this.lastCommandAt<this.commandIntervalMs)return;const t=this._collectCommandPayload();if(t.length===0)return;const r={type:"pc-command",header:this._buildHeader("command",e),gameId:((s=(i=this.adapter)==null?void 0:i.getGameId)==null?void 0:s.call(i))||null,roomId:((a=(o=this.adapter)==null?void 0:o.getRoomId)==null?void 0:a.call(o))||null,payload:t};this.lastCommandAt=e,(l=(c=this.adapter)==null?void 0:c.sendCommand)==null||l.call(c,r),this.recordTx(e)}_flushEvents(e){var a,c,l,u,d,f,p;if(this.eventQueue.length===0&&this.pendingReliableEvents.size===0)return;const t=this.profile.maxEventsPerTick,r=[],i=[];for(const g of this.pendingReliableEvents.values()){if(g.attempts>=this.profile.eventRetryMax){this.reliabilityStats.dropped+=1,this.pendingReliableEvents.delete(g.id);continue}e>=g.nextSendAt&&i.push(g)}const s=g=>r.length>=t?!1:(r.push(g),!0);for(const g of i){if(!s({id:g.id,payload:g.payload,reliable:!0,ts:e}))break;g.attempts+=1,g.lastSentAt=e,this.reliabilityStats.sent+=1;const m=(((a=g.options)==null?void 0:a.retryMs)??this.profile.eventRetryMs)*Math.pow(2,Math.max(0,g.attempts-1));g.nextSendAt=e+m}for(;r.length<t&&this.eventQueue.length>0;){const g=this.eventQueue.shift();if(!g)break;r.push({id:g.id,payload:g.payload,reliable:!1,ts:e})}if(r.length===0)return;const o={type:"pc-event",header:this._buildHeader("event",e),gameId:((l=(c=this.adapter)==null?void 0:c.getGameId)==null?void 0:l.call(c))||null,roomId:((d=(u=this.adapter)==null?void 0:u.getRoomId)==null?void 0:d.call(u))||null,payload:r};this.lastEventAt=e,(p=(f=this.adapter)==null?void 0:f.sendEvent)==null||p.call(f,o),this.recordTx(e)}getReliabilityStats(){return{sent:this.reliabilityStats.sent,acked:this.reliabilityStats.acked,dropped:this.reliabilityStats.dropped,pending:this.pendingReliableEvents.size,retryMs:this.profile.eventRetryMs,retryMax:this.profile.eventRetryMax}}_checkReconnect(e){var r;if(!((r=this.adapter)!=null&&r.reconnect)||this.profile.reconnectStallMs<=0)return;const t=this.lastRxAt||0;e-t<this.profile.reconnectStallMs||e-this.lastReconnectAt<this.profile.reconnectBackoffMs||(this.lastReconnectAt=e,this.adapter.reconnect())}_ackReliableEvents(e,t){var a,c,l,u,d,f;const i=(Array.isArray(e==null?void 0:e.payload)?e.payload:[]).filter(p=>(p==null?void 0:p.reliable)&&(p==null?void 0:p.id)).map(p=>p.id);if(i.length===0)return;const s=Date.now(),o={type:"pc-ack",header:this._buildHeader("event",s),gameId:((c=(a=this.adapter)==null?void 0:a.getGameId)==null?void 0:c.call(a))||null,roomId:((u=(l=this.adapter)==null?void 0:l.getRoomId)==null?void 0:u.call(l))||null,target:t||null,payload:{eventIds:i}};(f=(d=this.adapter)==null?void 0:d.sendEvent)==null||f.call(d,o)}}const xpe="peercompute-state-sync",Tpe="peercompute-direct",Ape="peercompute-presence",Mpe=5e3,Cpe=new TextEncoder,Ipe=new TextDecoder,BS=typeof __PC_DEBUG__<"u"&&__PC_DEBUG__===!0,eb=(...n)=>{BS&&console.log(...n)},Ki=(...n)=>{BS&&console.warn(...n)},Ppe=n=>typeof n!="string"?!1:n.includes("/dns4/localhost")||n.includes("/dns/localhost")||n.includes("/ip6/::1")||n.includes("/ip4/127.")||n.includes("/ip4/10.")||n.includes("/ip4/192.168.")?!0:/\/ip4\/172\.(1[6-9]|2\d|3[01])\./.test(n),DN=n=>{if(typeof n!="string")return n;const e=n.split("/p2p/");if(e.length<=2)return n;const t=e[e.length-1];return`${e[0]}/p2p/${t}`},tM=n=>{if(typeof n!="string")return null;const e=n.split("/p2p/");return e.length<2?null:e[e.length-1]||null},nM=n=>{if(!n)return null;if(typeof n.getComponents=="function")return n;if(typeof n!="string")return null;try{return US(n)}catch(e){return Ki("[NetworkManager] Invalid peer multiaddr",n,(e==null?void 0:e.message)||e),null}},Dpe=n=>{if(!n)return null;if(typeof n.getComponents=="function")return n;if(typeof n!="string")return null;const e=DN(n);try{return US(e)}catch(t){return Ki("[NetworkManager] Invalid bootstrap multiaddr",e,(t==null?void 0:t.message)||t),null}},Rpe=(n,e)=>{if(!e||typeof n!="string")return n;const t=`/p2p/${e}`;return n.includes(t)?n:`${n}${t}`};class Lpe{constructor(e={}){const t={topology:e.topology||"distributed",pubsubTopic:e.pubsubTopic||xpe,directTopic:e.directTopic||Tpe,presenceTopic:e.presenceTopic||Ape,discoveryTopic:e.discoveryTopic||"peercompute._peer-discovery._p2p._pubsub",bootstrapPeers:Array.isArray(e.bootstrapPeers)?e.bootstrapPeers:[],gameId:e.gameId||"default-game",roomId:e.roomId||"default-room",enforceRoomIsolation:e.enforceRoomIsolation!==!1},r=t.bootstrapPeers.map(s=>typeof s=="string"?DN(s):s),i=e.allowLocalDial??r.some(Ppe);this.config={...t,...e,bootstrapPeers:r,allowLocalDial:i},this.bootstrapPeerIds=new Set(r.map(tM).filter(Boolean)),this.libp2p=null,this.peerId=null,this.isConnected=!1,this.presenceInterval=null,this.publishErrorAt=new Map,this.peers=new Map,this.recentDialAttempts=new Map,this.onMessage=e.onMessage||(()=>{}),this.onPeerConnect=e.onPeerConnect||(()=>{}),this.onPeerDisconnect=e.onPeerDisconnect||(()=>{}),this.messageHandlers=[],this.scheduler=null,this.schedulerTimer=null,this.schedulerEnabled=e.enableScheduler||!1,this.schedulerClock=e.schedulerClock||"internal",this.schedulerProfile={...wa,...e.schedulerProfile||{}},this.authorityId=e.authorityId||null,this.lastRxAt=0,this.lastTxAt=0,this.allowedTopics=new Set([this.config.pubsubTopic,this.config.directTopic,this.config.presenceTopic]),[this.schedulerProfile.snapshotTopic,this.schedulerProfile.commandTopic,this.schedulerProfile.eventTopic].filter(Boolean).forEach(s=>this.allowedTopics.add(s))}addMessageHandler(e){this.messageHandlers.push(e)}configureScheduler(e={}){this.schedulerProfile={...this.schedulerProfile,...e},[this.schedulerProfile.snapshotTopic,this.schedulerProfile.commandTopic,this.schedulerProfile.eventTopic].filter(Boolean).forEach(t=>this.allowedTopics.add(t)),this.schedulerEnabled=!0,this._ensureScheduler(),this.scheduler.configure(this.schedulerProfile),this._startScheduler()}setSchedulerClock(e="internal"){const t=e==="external"?"external":"internal";if(this.schedulerClock!==t){if(this.schedulerClock=t,t==="external"){this._stopScheduler();return}this.schedulerEnabled&&this.isConnected&&this._startScheduler()}}getSchedulerClock(){return this.schedulerClock}tickScheduler(e=Date.now()){!this.scheduler||!this.schedulerEnabled||this.scheduler.tick(e)}getSchedulerProfile(){return this.scheduler?this.scheduler.getProfile():{...this.schedulerProfile}}registerStateProvider(e,t={}){return this._ensureScheduler(),this.schedulerEnabled=!0,this._startScheduler(),this.scheduler.registerStateProvider(e,t)}registerWarmDeltaProvider(e,t={}){const r=t.id||"warm-deltas";return this.registerStateProvider(()=>e(),{...t,id:r})}registerCommandProvider(e,t={}){return this._ensureScheduler(),this.schedulerEnabled=!0,this._startScheduler(),this.scheduler.registerCommandProvider(e,t)}unregisterStateProvider(e){var t;(t=this.scheduler)==null||t.unregisterStateProvider(e)}unregisterCommandProvider(e){var t;(t=this.scheduler)==null||t.unregisterCommandProvider(e)}markStateDirty(){var e;(e=this.scheduler)==null||e.markStateDirty()}queueEvent(e,t={}){var s,o;this._ensureScheduler(),this.schedulerEnabled=!0,this._startScheduler();const r=Object.prototype.hasOwnProperty.call(t,"reliable")||Object.prototype.hasOwnProperty.call(t,"critical");let i=t;if(!r&&(e!=null&&e.type)){const a=((o=(s=this.scheduler)==null?void 0:s.getProfile)==null?void 0:o.call(s))||this.schedulerProfile;Array.isArray(a.reliableEventTypes)&&a.reliableEventTypes.includes(e.type)&&(i={...t,reliable:!0})}this.scheduler.queueEvent(e,i)}addSnapshotHandler(e){this._ensureScheduler(),this.scheduler.addSnapshotHandler(e)}addCommandHandler(e){this._ensureScheduler(),this.scheduler.addCommandHandler(e)}addEventHandler(e){this._ensureScheduler(),this.scheduler.addEventHandler(e)}setAuthority(e){this.authorityId=e||null,this.scheduler&&this.scheduler.setAuthority(this.authorityId)}getAuthority(){return this.authorityId}getHealth(){var t,r,i,s,o,a;const e=(r=(t=this.scheduler)==null?void 0:t.getReliabilityStats)==null?void 0:r.call(t);return{lastRxAt:this.lastRxAt,lastTxAt:this.lastTxAt,peerCount:this.getConnectedPeers().length,pubsubPeers:((a=(o=(s=(i=this.libp2p)==null?void 0:i.services)==null?void 0:s.pubsub)==null?void 0:o.getPeers)==null?void 0:a.call(o))||[],reliability:e}}async initialize(){var i;const t=typeof window<"u"?["/p2p-circuit","/webrtc"]:["/ip4/0.0.0.0/tcp/0"],r=[ufe({interval:1e3,topics:[this.config.discoveryTopic]})];return(i=this.config.bootstrapPeers)!=null&&i.length&&r.unshift($he({list:this.config.bootstrapPeers})),this.libp2p=await ZZ({transports:[mJ(),Yee(),Vne()],connectionEncrypters:[mre(),Mre()],streamMuxers:[$re()],peerDiscovery:r,services:{identify:Jle(),ping:aue({interval:1e4}),pubsub:Ece()},connectionManager:{minConnections:0,maxConnections:200,inboundConnectionThreshold:1/0,maxIncomingPendingConnections:100},connectionMonitor:{abortConnectionOnPingFailure:!1},addresses:{listen:t},...this.config.allowLocalDial?{connectionGater:{denyDialMultiaddr:()=>!1}}:{}}),this._wireLibp2pEvents(),this.libp2p}async connect(){if(!this.isConnected){if(!this.libp2p)throw new Error("NetworkManager not initialized");await this.libp2p.start(),this.peerId=this.libp2p.peerId.toString(),this.libp2p.services.pubsub.subscribe(this.config.pubsubTopic),this.libp2p.services.pubsub.subscribe(this.config.directTopic),this.libp2p.services.pubsub.subscribe(this.config.presenceTopic),await this._dialBootstrapPeers(),this._startPresence(),this._logPubsubStatus("connected"),this.isConnected=!0,this.schedulerEnabled&&(this._ensureScheduler(),this._startScheduler())}}async redialBootstrapPeers(){this.libp2p&&await this._dialBootstrapPeers()}async disconnect(){this.isConnected=!1,this._stopScheduler(),this._clearPresenceTimer(),this.libp2p&&await this.libp2p.stop(),this.peers.clear(),this.peerId=null}async sendToPeer(e,t){const r=this._wrapPayload(t,{target:e});await this._publish(this.config.directTopic,r)}async broadcast(e,t={}){const r=t.topic||this.config.pubsubTopic,i=this._wrapPayload(e);await this._publish(r,i)}getConnectedPeers(){const e=this._getConnectionPeers(),t=this._getScopedPeers(),r=new Map;return e.forEach(i=>r.set(i.peerId,i)),t.forEach(i=>{const s=r.get(i.peerId)||{};r.set(i.peerId,{...s,...i})}),Array.from(r.values())}getNetworkStats(){var i,s;const e=this._getConnectionPeers(),t=((s=(i=this.libp2p)==null?void 0:i.getConnections)==null?void 0:s.call(i))||[],r=Array.isArray(t)?t.length:typeof t.size=="number"?t.size:0;return{peerId:this.peerId,peerCount:e.length,isConnected:this.isConnected,topology:this.config.topology,connections:r}}getLibp2pNode(){return this.libp2p}_wireLibp2pEvents(){this.libp2p&&(this.libp2p.addEventListener("peer:discovery",e=>{var r,i,s,o,a,c;const t=((s=(i=(r=e.detail)==null?void 0:r.id)==null?void 0:i.toString)==null?void 0:s.call(i))||((c=(a=(o=e.detail)==null?void 0:o.id)==null?void 0:a.toString)==null?void 0:c.call(a));!t||t===this.peerId||this._shouldDialDiscoveredPeer(t)&&this._maybeDialPeer(t,"discovery").catch(()=>{})}),this.libp2p.addEventListener("peer:connect",e=>{var i,s,o,a,c;const t=((o=(s=(i=e.detail)==null?void 0:i.remotePeer)==null?void 0:s.toString)==null?void 0:o.call(s))||((c=(a=e.detail)==null?void 0:a.toString)==null?void 0:c.call(a));if(!t)return;const r=!this.peers.has(t);this._touchPeer(t,{connectedAt:Date.now(),via:"connection"}),r&&this.onPeerConnect(t)}),this.libp2p.addEventListener("peer:disconnect",e=>{var r,i,s,o,a;const t=((s=(i=(r=e.detail)==null?void 0:r.remotePeer)==null?void 0:i.toString)==null?void 0:s.call(i))||((a=(o=e.detail)==null?void 0:o.toString)==null?void 0:a.call(o));t&&(this.peers.delete(t),this.onPeerDisconnect(t))}),this.libp2p.services.pubsub.addEventListener("message",e=>{var l,u,d;const{topic:t,data:r}=e.detail||{};if(!t||!r||!this.allowedTopics.has(t))return;let i=null;try{i=JSON.parse(Ipe.decode(r))}catch(f){Ki("[NetworkManager] Failed to parse pubsub payload",f);return}const s=Date.now();this.lastRxAt=s,(l=this.scheduler)==null||l.recordRx(s);const o=((u=i==null?void 0:i.header)==null?void 0:u.peerId)||(i==null?void 0:i.from)||"unknown";if((d=this.scheduler)!=null&&d.handleMessage(i,o))return;if(t===this.config.presenceTopic){this._handlePresence(i);return}if(t===this.config.directTopic&&i!=null&&i.target&&i.target!==this.peerId||!this._matchesScope(i))return;const a=(i==null?void 0:i.payload)??i,c=i==null?void 0:i.from;c&&c!==this.peerId&&this._touchPeer(c,{lastMessageTime:Date.now()}),this._dispatchMessage(c||"unknown",a)}))}_dispatchMessage(e,t){this.messageHandlers.forEach(r=>{try{r(e,t)}catch(i){console.error("[NetworkManager] Message handler failed",i)}}),this.onMessage(e,t)}_wrapPayload(e,t={}){return{type:"peercompute-message",from:this.peerId,gameId:this.config.gameId,roomId:this.config.roomId,payload:e,...t}}_matchesScope(e){return e?!(e.gameId&&e.gameId!==this.config.gameId||e.roomId&&e.roomId!==this.config.roomId):!0}_handlePresence(e){if(!e||!this._matchesScope(e)||!e.from||e.from===this.peerId)return;const t=!this.peers.has(e.from);this._touchPeer(e.from,{gameId:e.gameId,roomId:e.roomId,lastSeen:Date.now(),via:"presence"}),t&&this.onPeerConnect(e.from),Array.isArray(e.multiaddrs)&&e.multiaddrs.length>0&&this._rememberPeerAddresses(e.from,e.multiaddrs),this._maybeDialPeer(e.from,"presence",e.multiaddrs).catch(()=>{})}_getScopedPeers(){return Array.from(this.peers.entries()).filter(([,e])=>(e==null?void 0:e.gameId)===this.config.gameId&&(e==null?void 0:e.roomId)===this.config.roomId).map(([e,t])=>({peerId:e,...t}))}_getConnectionPeers(){var i,s,o,a,c;if(!((i=this.libp2p)!=null&&i.getConnections))return[];const e=new Map,t=this.libp2p.getConnections(),r=Array.isArray(t)?t:typeof(t==null?void 0:t.values)=="function"?Array.from(t.values()).reduce((l,u)=>l.concat(u),[]):[];for(const l of r){const u=((o=(s=l==null?void 0:l.remotePeer)==null?void 0:s.toString)==null?void 0:o.call(s))||((c=(a=l==null?void 0:l.remotePeer)==null?void 0:a.toString)==null?void 0:c.call(a));if(!u)continue;const d=this.peers.get(u)||{};e.set(u,{peerId:u,...d,via:d.via||"connection"})}return Array.from(e.values())}_shouldDialDiscoveredPeer(e){return e?!this.config.enforceRoomIsolation||this.bootstrapPeerIds.has(e)?!0:this.peers.has(e):!1}_touchPeer(e,t){const r=this.peers.get(e)||{};this.peers.set(e,{...r,...t})}_startPresence(){this._clearPresenceTimer();const e=async()=>{if(!this.peerId)return;const t={type:"presence",from:this.peerId,gameId:this.config.gameId,roomId:this.config.roomId,multiaddrs:this._getAnnounceAddrs()};await this._publish(this.config.presenceTopic,t)};e().catch(()=>{}),this.presenceInterval=setInterval(()=>{e().catch(()=>{})},3e3)}_clearPresenceTimer(){this.presenceInterval&&(clearInterval(this.presenceInterval),this.presenceInterval=null)}_ensureScheduler(){this.scheduler||(this.scheduler=new Spe(this._buildSchedulerAdapter(),this.schedulerProfile),this.authorityId&&this.scheduler.setAuthority(this.authorityId))}_startScheduler(){if(!this.schedulerEnabled||!this.isConnected||this.schedulerClock==="external"||!this.scheduler||this.schedulerTimer)return;const e=()=>{this.scheduler&&(this.scheduler.tick(Date.now()),this.schedulerTimer=setTimeout(e,this.scheduler.getTickIntervalMs()))};this.schedulerTimer=setTimeout(e,this.scheduler.getTickIntervalMs())}_stopScheduler(){this.schedulerTimer&&(clearTimeout(this.schedulerTimer),this.schedulerTimer=null)}_buildSchedulerAdapter(){return{sendSnapshot:e=>this._sendScheduledSnapshot(e),sendCommand:e=>this._sendScheduledCommand(e),sendEvent:e=>this._sendScheduledEvent(e),reconnect:()=>this._schedulerReconnect(),getPeerId:()=>this.peerId,getAuthority:()=>this.authorityId,getGameId:()=>this.config.gameId,getRoomId:()=>this.config.roomId,isInScope:e=>this._matchesScope(e)}}async _sendScheduledSnapshot(e){var r,i;if(!this.isConnected||this.schedulerProfile.snapshotsRequireAuthority&&this.authorityId&&this.authorityId!==this.peerId)return;const t=((i=(r=this.scheduler)==null?void 0:r.getProfile())==null?void 0:i.snapshotTopic)||this.config.pubsubTopic;await this._publish(t,e)}async _sendScheduledCommand(e){var s,o;if(!this.isConnected)return;const t=((o=(s=this.scheduler)==null?void 0:s.getProfile())==null?void 0:o.commandTopic)||this.config.directTopic,r=this.authorityId&&this.authorityId!==this.peerId?this.authorityId:null,i=r?{...e,target:r}:e;await this._publish(t,i)}async _sendScheduledEvent(e){var r,i;if(!this.isConnected)return;const t=((i=(r=this.scheduler)==null?void 0:r.getProfile())==null?void 0:i.eventTopic)||this.config.pubsubTopic;await this._publish(t,e)}async _schedulerReconnect(){await this.redialBootstrapPeers(),this._resubscribeTopics(),this._startPresence()}_resubscribeTopics(){var e,t;(t=(e=this.libp2p)==null?void 0:e.services)!=null&&t.pubsub&&(this.libp2p.services.pubsub.subscribe(this.config.pubsubTopic),this.libp2p.services.pubsub.subscribe(this.config.directTopic),this.libp2p.services.pubsub.subscribe(this.config.presenceTopic))}async _publish(e,t){var i,s,o;if(!((s=(i=this.libp2p)==null?void 0:i.services)!=null&&s.pubsub))return;const r=Cpe.encode(JSON.stringify(t));try{await this.libp2p.services.pubsub.publish(e,r);const a=Date.now();this.lastTxAt=a,(o=this.scheduler)==null||o.recordTx(a)}catch(a){const c=Date.now(),l=this.publishErrorAt.get(e)||0;c-l>5e3&&(this.publishErrorAt.set(e,c),Ki("[NetworkManager] Publish failed",e,(a==null?void 0:a.message)||a))}}async _dialBootstrapPeers(){const e=(this.config.bootstrapPeers||[]).map(Dpe).filter(Boolean);await Promise.all(e.map(async t=>{var r,i;try{const s=t.toString(),o=tM(s);if(o)try{const a=J0(o);if((((i=(r=this.libp2p)==null?void 0:r.getConnections)==null?void 0:i.call(r,a))||[]).length>0)return}catch{}await this.libp2p.dial(t),eb("[NetworkManager] Dialed bootstrap peer",t.toString())}catch(s){Ki("[NetworkManager] Failed to dial bootstrap peer",t.toString(),(s==null?void 0:s.message)||s)}}))}async _maybeDialPeer(e,t,r=null){var l,u;if(!this.libp2p||!e||e===this.peerId||this.bootstrapPeerIds.has(e)||(((u=(l=this.libp2p).getConnections)==null?void 0:u.call(l,e))||[]).length>0)return;const s=Date.now(),o=this.recentDialAttempts.get(e)||0;if(s-o<Mpe)return;this.recentDialAttempts.set(e,s);const a=Array.isArray(r)&&r.length>0?r.map(nM).filter(Boolean):[];if(a.length>0)for(const d of a)try{await this.libp2p.dial(d),eb("[NetworkManager] Dialed discovered peer",e,t?`(${t})`:"",d.toString());return}catch(f){Ki("[NetworkManager] Failed to dial discovered peer",e,d.toString(),(f==null?void 0:f.message)||f)}let c=e;try{c=J0(e)}catch{return}try{await this.libp2p.dial(c),eb("[NetworkManager] Dialed discovered peer",e,t?`(${t})`:"")}catch(d){Ki("[NetworkManager] Failed to dial discovered peer",e,(d==null?void 0:d.message)||d)}}_getAnnounceAddrs(){var o;if(!((o=this.libp2p)!=null&&o.getMultiaddrs))return[];const e=this.libp2p.getMultiaddrs().map(a=>a.toString()),t=e.filter(a=>a.includes("/p2p-circuit")||a.includes("/webrtc")),r=t.length>0?t:e,i=this.peerId,s=r.map(a=>Rpe(a,i));return Array.from(new Set(s))}_logPubsubStatus(e){var o,a;if(!((a=(o=this.libp2p)==null?void 0:o.services)!=null&&a.pubsub)||!BS)return;const t=this.libp2p.services.pubsub,r=typeof t.getPeers=="function"?t.getPeers():[],i=typeof t.getSubscribers=="function"?t.getSubscribers(this.config.presenceTopic):[];Array.isArray(r)&&r.length===0&&Ki(`[NetworkManager] Pubsub has no peers (${e})`),Array.isArray(i)&&i.length===0&&Ki(`[NetworkManager] No subscribers on presence topic (${e})`),this._getAnnounceAddrs().length===0&&Ki(`[NetworkManager] No announce addrs available (${e})`)}_rememberPeerAddresses(e,t){var s,o;if(!((o=(s=this.libp2p)==null?void 0:s.peerStore)!=null&&o.merge)||!Array.isArray(t)||t.length===0)return;let r;try{r=J0(e)}catch{return}const i=t.map(nM).filter(Boolean);i.length!==0&&this.libp2p.peerStore.merge(r,{multiaddrs:i}).catch(()=>{})}}const $i=()=>new Map,R_=n=>{const e=$i();return n.forEach((t,r)=>{e.set(r,t)}),e},sa=(n,e,t)=>{let r=n.get(e);return r===void 0&&n.set(e,r=t()),r},Ope=(n,e)=>{const t=[];for(const[r,i]of n)t.push(e(i,r));return t},Npe=(n,e)=>{for(const[t,r]of n)if(e(r,t))return!0;return!1},Su=()=>new Set,tb=n=>n[n.length-1],Upe=(n,e)=>{for(let t=0;t<e.length;t++)n.push(e[t])},sc=Array.from,Bpe=Array.isArray;class kS{constructor(){this._observers=$i()}on(e,t){sa(this._observers,e,Su).add(t)}once(e,t){const r=(...i)=>{this.off(e,r),t(...i)};this.on(e,r)}off(e,t){const r=this._observers.get(e);r!==void 0&&(r.delete(t),r.size===0&&this._observers.delete(e))}emit(e,t){return sc((this._observers.get(e)||$i()).values()).forEach(r=>r(...t))}destroy(){this._observers=$i()}}const ta=Math.floor,Zp=Math.abs,RN=(n,e)=>n<e?n:e,fc=(n,e)=>n>e?n:e,LN=n=>n!==0?n<0:1/n<0,rM=1,iM=2,nb=4,rb=8,Dd=32,Qs=64,kr=128,Qg=31,L_=63,Ha=127,kpe=2147483647,ON=Number.MAX_SAFE_INTEGER,$pe=Number.isInteger||(n=>typeof n=="number"&&isFinite(n)&&ta(n)===n),Fpe=n=>n.toLowerCase(),zpe=/^\s*/g,Vpe=n=>n.replace(zpe,""),Hpe=/([A-Z])/g,sM=(n,e)=>Vpe(n.replace(Hpe,t=>`${e}${Fpe(t)}`)),Gpe=n=>{const e=unescape(encodeURIComponent(n)),t=e.length,r=new Uint8Array(t);for(let i=0;i<t;i++)r[i]=e.codePointAt(i);return r},Rd=typeof TextEncoder<"u"?new TextEncoder:null,Wpe=n=>Rd.encode(n),qpe=Rd?Wpe:Gpe;let Xh=typeof TextDecoder>"u"?null:new TextDecoder("utf-8",{fatal:!0,ignoreBOM:!0});Xh&&Xh.decode(new Uint8Array).length===1&&(Xh=null);class lf{constructor(){this.cpos=0,this.cbuf=new Uint8Array(100),this.bufs=[]}}const ey=()=>new lf,Kpe=n=>{let e=n.cpos;for(let t=0;t<n.bufs.length;t++)e+=n.bufs[t].length;return e},ss=n=>{const e=new Uint8Array(Kpe(n));let t=0;for(let r=0;r<n.bufs.length;r++){const i=n.bufs[r];e.set(i,t),t+=i.length}return e.set(new Uint8Array(n.cbuf.buffer,0,n.cpos),t),e},Xpe=(n,e)=>{const t=n.cbuf.length;t-n.cpos<e&&(n.bufs.push(new Uint8Array(n.cbuf.buffer,0,n.cpos)),n.cbuf=new Uint8Array(fc(t,e)*2),n.cpos=0)},pn=(n,e)=>{const t=n.cbuf.length;n.cpos===t&&(n.bufs.push(n.cbuf),n.cbuf=new Uint8Array(t*2),n.cpos=0),n.cbuf[n.cpos++]=e},O_=pn,ot=(n,e)=>{for(;e>Ha;)pn(n,kr|Ha&e),e=ta(e/128);pn(n,Ha&e)},$S=(n,e)=>{const t=LN(e);for(t&&(e=-e),pn(n,(e>L_?kr:0)|(t?Qs:0)|L_&e),e=ta(e/64);e>0;)pn(n,(e>Ha?kr:0)|Ha&e),e=ta(e/128)},N_=new Uint8Array(3e4),Ype=N_.length/3,Zpe=(n,e)=>{if(e.length<Ype){const t=Rd.encodeInto(e,N_).written||0;ot(n,t);for(let r=0;r<t;r++)pn(n,N_[r])}else Ir(n,qpe(e))},jpe=(n,e)=>{const t=unescape(encodeURIComponent(e)),r=t.length;ot(n,r);for(let i=0;i<r;i++)pn(n,t.codePointAt(i))},gl=Rd&&Rd.encodeInto?Zpe:jpe,ty=(n,e)=>{const t=n.cbuf.length,r=n.cpos,i=RN(t-r,e.length),s=e.length-i;n.cbuf.set(e.subarray(0,i),r),n.cpos+=i,s>0&&(n.bufs.push(n.cbuf),n.cbuf=new Uint8Array(fc(t*2,s)),n.cbuf.set(e.subarray(i)),n.cpos=s)},Ir=(n,e)=>{ot(n,e.byteLength),ty(n,e)},FS=(n,e)=>{Xpe(n,e);const t=new DataView(n.cbuf.buffer,n.cpos,e);return n.cpos+=e,t},Jpe=(n,e)=>FS(n,4).setFloat32(0,e,!1),Qpe=(n,e)=>FS(n,8).setFloat64(0,e,!1),eme=(n,e)=>FS(n,8).setBigInt64(0,e,!1),oM=new DataView(new ArrayBuffer(4)),tme=n=>(oM.setFloat32(0,n),oM.getFloat32(0)===n),Ld=(n,e)=>{switch(typeof e){case"string":pn(n,119),gl(n,e);break;case"number":$pe(e)&&Zp(e)<=kpe?(pn(n,125),$S(n,e)):tme(e)?(pn(n,124),Jpe(n,e)):(pn(n,123),Qpe(n,e));break;case"bigint":pn(n,122),eme(n,e);break;case"object":if(e===null)pn(n,126);else if(Bpe(e)){pn(n,117),ot(n,e.length);for(let t=0;t<e.length;t++)Ld(n,e[t])}else if(e instanceof Uint8Array)pn(n,116),Ir(n,e);else{pn(n,118);const t=Object.keys(e);ot(n,t.length);for(let r=0;r<t.length;r++){const i=t[r];gl(n,i),Ld(n,e[i])}}break;case"boolean":pn(n,e?120:121);break;default:pn(n,127)}};class aM extends lf{constructor(e){super(),this.w=e,this.s=null,this.count=0}write(e){this.s===e?this.count++:(this.count>0&&ot(this,this.count-1),this.count=1,this.w(this,e),this.s=e)}}const cM=n=>{n.count>0&&($S(n.encoder,n.count===1?n.s:-n.s),n.count>1&&ot(n.encoder,n.count-2))};class jp{constructor(){this.encoder=new lf,this.s=0,this.count=0}write(e){this.s===e?this.count++:(cM(this),this.count=1,this.s=e)}toUint8Array(){return cM(this),ss(this.encoder)}}const lM=n=>{if(n.count>0){const e=n.diff*2+(n.count===1?0:1);$S(n.encoder,e),n.count>1&&ot(n.encoder,n.count-2)}};class ib{constructor(){this.encoder=new lf,this.s=0,this.count=0,this.diff=0}write(e){this.diff===e-this.s?(this.s=e,this.count++):(lM(this),this.count=1,this.diff=e-this.s,this.s=e)}toUint8Array(){return lM(this),ss(this.encoder)}}class nme{constructor(){this.sarr=[],this.s="",this.lensE=new jp}write(e){this.s+=e,this.s.length>19&&(this.sarr.push(this.s),this.s=""),this.lensE.write(e.length)}toUint8Array(){const e=new lf;return this.sarr.push(this.s),this.s="",gl(e,this.sarr.join("")),ty(e,this.lensE.toUint8Array()),ss(e)}}const pc=n=>new Error(n),cs=()=>{throw pc("Method unimplemented")},hs=()=>{throw pc("Unexpected case")},NN=pc("Unexpected end of array"),UN=pc("Integer out of Range");class ny{constructor(e){this.arr=e,this.pos=0}}const qu=n=>new ny(n),rme=n=>n.pos!==n.arr.length,ime=(n,e)=>{const t=new Uint8Array(n.arr.buffer,n.pos+n.arr.byteOffset,e);return n.pos+=e,t},Pr=n=>ime(n,Qe(n)),xu=n=>n.arr[n.pos++],Qe=n=>{let e=0,t=1;const r=n.arr.length;for(;n.pos<r;){const i=n.arr[n.pos++];if(e=e+(i&Ha)*t,t*=128,i<kr)return e;if(e>ON)throw UN}throw NN},zS=n=>{let e=n.arr[n.pos++],t=e&L_,r=64;const i=(e&Qs)>0?-1:1;if((e&kr)===0)return i*t;const s=n.arr.length;for(;n.pos<s;){if(e=n.arr[n.pos++],t=t+(e&Ha)*r,r*=128,e<kr)return i*t;if(t>ON)throw UN}throw NN},sme=n=>{let e=Qe(n);if(e===0)return"";{let t=String.fromCodePoint(xu(n));if(--e<100)for(;e--;)t+=String.fromCodePoint(xu(n));else for(;e>0;){const r=e<1e4?e:1e4,i=n.arr.subarray(n.pos,n.pos+r);n.pos+=r,t+=String.fromCodePoint.apply(null,i),e-=r}return decodeURIComponent(escape(t))}},ome=n=>Xh.decode(Pr(n)),yl=Xh?ome:sme,VS=(n,e)=>{const t=new DataView(n.arr.buffer,n.arr.byteOffset+n.pos,e);return n.pos+=e,t},ame=n=>VS(n,4).getFloat32(0,!1),cme=n=>VS(n,8).getFloat64(0,!1),lme=n=>VS(n,8).getBigInt64(0,!1),ume=[n=>{},n=>null,zS,ame,cme,lme,n=>!1,n=>!0,yl,n=>{const e=Qe(n),t={};for(let r=0;r<e;r++){const i=yl(n);t[i]=Od(n)}return t},n=>{const e=Qe(n),t=[];for(let r=0;r<e;r++)t.push(Od(n));return t},Pr],Od=n=>ume[127-xu(n)](n);class uM extends ny{constructor(e,t){super(e),this.reader=t,this.s=null,this.count=0}read(){return this.count===0&&(this.s=this.reader(this),rme(this)?this.count=Qe(this)+1:this.count=-1),this.count--,this.s}}class Jp extends ny{constructor(e){super(e),this.s=0,this.count=0}read(){if(this.count===0){this.s=zS(this);const e=LN(this.s);this.count=1,e&&(this.s=-this.s,this.count=Qe(this)+2)}return this.count--,this.s}}class sb extends ny{constructor(e){super(e),this.s=0,this.count=0,this.diff=0}read(){if(this.count===0){const e=zS(this),t=e&1;this.diff=ta(e/2),this.count=1,t&&(this.count=Qe(this)+2)}return this.s+=this.diff,this.count--,this.s}}class hme{constructor(e){this.decoder=new Jp(e),this.str=yl(this.decoder),this.spos=0}read(){const e=this.spos+this.decoder.read(),t=this.str.slice(this.spos,e);return this.spos=e,t}}const dme=crypto.getRandomValues.bind(crypto),BN=()=>dme(new Uint32Array(1))[0],fme="10000000-1000-4000-8000"+-1e11,pme=()=>fme.replace(/[018]/g,n=>(n^BN()&15>>n/4).toString(16)),Tu=n=>new Promise(n);Promise.all.bind(Promise);const hM=n=>n===void 0?null:n;class mme{constructor(){this.map=new Map}setItem(e,t){this.map.set(e,t)}getItem(e){return this.map.get(e)}}let kN=new mme,gme=!0;try{typeof localStorage<"u"&&localStorage&&(kN=localStorage,gme=!1)}catch{}const yme=kN,bme=Object.assign,wme=Object.keys,dM=n=>wme(n).length,vme=n=>{for(const e in n)return!1;return!0},_me=(n,e)=>{for(const t in n)if(!e(n[t],t))return!1;return!0},Eme=(n,e)=>Object.prototype.hasOwnProperty.call(n,e),Sme=(n,e)=>n===e||dM(n)===dM(e)&&_me(n,(t,r)=>(t!==void 0||Eme(e,r))&&e[r]===t),HS=(n,e,t=0)=>{try{for(;t<n.length;t++)n[t](...e)}finally{t<n.length&&HS(n,e,t+1)}},xme=(n,e)=>e.includes(n);var $N={};const Nd=typeof process<"u"&&process.release&&/node|io\.js/.test(process.release.name)&&Object.prototype.toString.call(typeof process<"u"?process:0)==="[object process]";let qi;const Tme=()=>{if(qi===void 0)if(Nd){qi=$i();const n=process.argv;let e=null;for(let t=0;t<n.length;t++){const r=n[t];r[0]==="-"?(e!==null&&qi.set(e,""),e=r):e!==null&&(qi.set(e,r),e=null)}e!==null&&qi.set(e,"")}else typeof location=="object"?(qi=$i(),(location.search||"?").slice(1).split("&").forEach(n=>{if(n.length!==0){const[e,t]=n.split("=");qi.set(`--${sM(e,"-")}`,t),qi.set(`-${sM(e,"-")}`,t)}})):qi=$i();return qi},U_=n=>Tme().has(n),B_=n=>hM(Nd?$N[n.toUpperCase().replaceAll("-","_")]:yme.getItem(n)),FN=n=>U_("--"+n)||B_(n)!==null;FN("production");const Ame=Nd&&xme($N.FORCE_COLOR,["true","1","2"]),Mme=Ame||!U_("--no-colors")&&!FN("no-color")&&(!Nd||process.stdout.isTTY)&&(!Nd||U_("--color")||B_("COLORTERM")!==null||(B_("TERM")||"").includes("color")),Cme=n=>new Uint8Array(n),Ime=n=>{const e=Cme(n.byteLength);return e.set(n),e};class Pme{constructor(e,t){this.left=e,this.right=t}}const Ts=(n,e)=>new Pme(n,e);typeof DOMParser<"u"&&new DOMParser;const Dme=n=>Ope(n,(e,t)=>`${t}:${e};`).join(""),uo=Symbol,zN=uo(),VN=uo(),Rme=uo(),Lme=uo(),Ome=uo(),HN=uo(),Nme=uo(),GN=uo(),Ume=uo(),Bme=n=>{var i;n.length===1&&((i=n[0])==null?void 0:i.constructor)===Function&&(n=n[0]());const e=[],t=[];let r=0;for(;r<n.length;r++){const s=n[r];if(s===void 0)break;if(s.constructor===String||s.constructor===Number)e.push(s);else if(s.constructor===Object)break}for(r>0&&t.push(e.join(""));r<n.length;r++){const s=n[r];s instanceof Symbol||t.push(s)}return t},kme={[zN]:Ts("font-weight","bold"),[VN]:Ts("font-weight","normal"),[Rme]:Ts("color","blue"),[Ome]:Ts("color","green"),[Lme]:Ts("color","grey"),[HN]:Ts("color","red"),[Nme]:Ts("color","purple"),[GN]:Ts("color","orange"),[Ume]:Ts("color","black")},$me=n=>{var o;n.length===1&&((o=n[0])==null?void 0:o.constructor)===Function&&(n=n[0]());const e=[],t=[],r=$i();let i=[],s=0;for(;s<n.length;s++){const a=n[s],c=kme[a];if(c!==void 0)r.set(c.left,c.right);else{if(a===void 0)break;if(a.constructor===String||a.constructor===Number){const l=Dme(r);s>0||l.length>0?(e.push("%c"+a),t.push(l)):e.push(a)}else break}}for(s>0&&(i=t,i.unshift(e.join("")));s<n.length;s++){const a=n[s];a instanceof Symbol||i.push(a)}return i},Fme=Mme?$me:Bme,zme=(...n)=>{console.log(...Fme(n)),Vme.forEach(e=>e.print(n))},Vme=Su(),WN=n=>({[Symbol.iterator](){return this},next:n}),Hme=(n,e)=>WN(()=>{let t;do t=n.next();while(!t.done&&!e(t.value));return t}),ob=(n,e)=>WN(()=>{const{done:t,value:r}=n.next();return{done:t,value:t?void 0:e(r)}});class GS{constructor(e,t){this.clock=e,this.len=t}}class uf{constructor(){this.clients=new Map}}const k_=(n,e,t)=>e.clients.forEach((r,i)=>{const s=n.doc.store.clients.get(i);for(let o=0;o<r.length;o++){const a=r[o];nU(n,s,a.clock,a.len,t)}}),Gme=(n,e)=>{let t=0,r=n.length-1;for(;t<=r;){const i=ta((t+r)/2),s=n[i],o=s.clock;if(o<=e){if(e<o+s.len)return i;t=i+1}else r=i-1}return null},qN=(n,e)=>{const t=n.clients.get(e.client);return t!==void 0&&Gme(t,e.clock)!==null},WS=n=>{n.clients.forEach(e=>{e.sort((i,s)=>i.clock-s.clock);let t,r;for(t=1,r=1;t<e.length;t++){const i=e[r-1],s=e[t];i.clock+i.len>=s.clock?i.len=fc(i.len,s.clock+s.len-i.clock):(r<t&&(e[r]=s),r++)}e.length=r})},Wme=n=>{const e=new uf;for(let t=0;t<n.length;t++)n[t].clients.forEach((r,i)=>{if(!e.clients.has(i)){const s=r.slice();for(let o=t+1;o<n.length;o++)Upe(s,n[o].clients.get(i)||[]);e.clients.set(i,s)}});return WS(e),e},lg=(n,e,t,r)=>{sa(n.clients,e,()=>[]).push(new GS(t,r))},qme=()=>new uf,Kme=n=>{const e=qme();return n.clients.forEach((t,r)=>{const i=[];for(let s=0;s<t.length;s++){const o=t[s];if(o.deleted){const a=o.id.clock;let c=o.length;if(s+1<t.length)for(let l=t[s+1];s+1<t.length&&l.deleted;l=t[++s+1])c+=l.length;i.push(new GS(a,c))}}i.length>0&&e.clients.set(r,i)}),e},Ku=(n,e)=>{ot(n.restEncoder,e.clients.size),sc(e.clients.entries()).sort((t,r)=>r[0]-t[0]).forEach(([t,r])=>{n.resetDsCurVal(),ot(n.restEncoder,t);const i=r.length;ot(n.restEncoder,i);for(let s=0;s<i;s++){const o=r[s];n.writeDsClock(o.clock),n.writeDsLen(o.len)}})},qS=n=>{const e=new uf,t=Qe(n.restDecoder);for(let r=0;r<t;r++){n.resetDsCurVal();const i=Qe(n.restDecoder),s=Qe(n.restDecoder);if(s>0){const o=sa(e.clients,i,()=>[]);for(let a=0;a<s;a++)o.push(new GS(n.readDsClock(),n.readDsLen()))}}return e},fM=(n,e,t)=>{const r=new uf,i=Qe(n.restDecoder);for(let s=0;s<i;s++){n.resetDsCurVal();const o=Qe(n.restDecoder),a=Qe(n.restDecoder),c=t.clients.get(o)||[],l=gn(t,o);for(let u=0;u<a;u++){const d=n.readDsClock(),f=d+n.readDsLen();if(d<l){l<f&&lg(r,o,l,f-l);let p=ds(c,d),g=c[p];for(!g.deleted&&g.id.clock<d&&(c.splice(p+1,0,gg(e,g,d-g.id.clock)),p++);p<c.length&&(g=c[p++],g.id.clock<f);)g.deleted||(f<g.id.clock+g.length&&c.splice(p,0,gg(e,g,f-g.id.clock)),g.delete(e))}else lg(r,o,d,f-d)}}if(r.clients.size>0){const s=new oc;return ot(s.restEncoder,0),Ku(s,r),s.toUint8Array()}return null},KN=BN;class Xu extends kS{constructor({guid:e=pme(),collectionid:t=null,gc:r=!0,gcFilter:i=()=>!0,meta:s=null,autoLoad:o=!1,shouldLoad:a=!0}={}){super(),this.gc=r,this.gcFilter=i,this.clientID=KN(),this.guid=e,this.collectionid=t,this.share=new Map,this.store=new eU,this._transaction=null,this._transactionCleanups=[],this.subdocs=new Set,this._item=null,this.shouldLoad=a,this.autoLoad=o,this.meta=s,this.isLoaded=!1,this.isSynced=!1,this.whenLoaded=Tu(l=>{this.on("load",()=>{this.isLoaded=!0,l(this)})});const c=()=>Tu(l=>{const u=d=>{(d===void 0||d===!0)&&(this.off("sync",u),l())};this.on("sync",u)});this.on("sync",l=>{l===!1&&this.isSynced&&(this.whenSynced=c()),this.isSynced=l===void 0||l===!0,this.isLoaded||this.emit("load",[])}),this.whenSynced=c()}load(){const e=this._item;e!==null&&!this.shouldLoad&&St(e.parent.doc,t=>{t.subdocsLoaded.add(this)},null,!0),this.shouldLoad=!0}getSubdocs(){return this.subdocs}getSubdocGuids(){return new Set(sc(this.subdocs).map(e=>e.guid))}transact(e,t=null){return St(this,e,t)}get(e,t=Mn){const r=sa(this.share,e,()=>{const s=new t;return s._integrate(this,null),s}),i=r.constructor;if(t!==Mn&&i!==t)if(i===Mn){const s=new t;s._map=r._map,r._map.forEach(o=>{for(;o!==null;o=o.left)o.parent=s}),s._start=r._start;for(let o=s._start;o!==null;o=o.right)o.parent=s;return s._length=r._length,this.share.set(e,s),s._integrate(this,null),s}else throw new Error(`Type with the name ${e} has already been defined with a different constructor`);return r}getArray(e=""){return this.get(e,wl)}getText(e=""){return this.get(e,Mu)}getMap(e=""){return this.get(e,ra)}getXmlFragment(e=""){return this.get(e,ac)}toJSON(){const e={};return this.share.forEach((t,r)=>{e[r]=t.toJSON()}),e}destroy(){sc(this.subdocs).forEach(t=>t.destroy());const e=this._item;if(e!==null){this._item=null;const t=e.content;t.doc=new Xu({guid:this.guid,...t.opts,shouldLoad:!1}),t.doc._item=e,St(e.parent.doc,r=>{const i=t.doc;e.deleted||r.subdocsAdded.add(i),r.subdocsRemoved.add(this)},null,!0)}this.emit("destroyed",[!0]),this.emit("destroy",[this]),super.destroy()}on(e,t){super.on(e,t)}off(e,t){super.off(e,t)}}class XN{constructor(e){this.restDecoder=e}resetDsCurVal(){}readDsClock(){return Qe(this.restDecoder)}readDsLen(){return Qe(this.restDecoder)}}class YN extends XN{readLeftID(){return it(Qe(this.restDecoder),Qe(this.restDecoder))}readRightID(){return it(Qe(this.restDecoder),Qe(this.restDecoder))}readClient(){return Qe(this.restDecoder)}readInfo(){return xu(this.restDecoder)}readString(){return yl(this.restDecoder)}readParentInfo(){return Qe(this.restDecoder)===1}readTypeRef(){return Qe(this.restDecoder)}readLen(){return Qe(this.restDecoder)}readAny(){return Od(this.restDecoder)}readBuf(){return Ime(Pr(this.restDecoder))}readJSON(){return JSON.parse(yl(this.restDecoder))}readKey(){return yl(this.restDecoder)}}class Xme{constructor(e){this.dsCurrVal=0,this.restDecoder=e}resetDsCurVal(){this.dsCurrVal=0}readDsClock(){return this.dsCurrVal+=Qe(this.restDecoder),this.dsCurrVal}readDsLen(){const e=Qe(this.restDecoder)+1;return this.dsCurrVal+=e,e}}class Au extends Xme{constructor(e){super(e),this.keys=[],Qe(e),this.keyClockDecoder=new sb(Pr(e)),this.clientDecoder=new Jp(Pr(e)),this.leftClockDecoder=new sb(Pr(e)),this.rightClockDecoder=new sb(Pr(e)),this.infoDecoder=new uM(Pr(e),xu),this.stringDecoder=new hme(Pr(e)),this.parentInfoDecoder=new uM(Pr(e),xu),this.typeRefDecoder=new Jp(Pr(e)),this.lenDecoder=new Jp(Pr(e))}readLeftID(){return new bl(this.clientDecoder.read(),this.leftClockDecoder.read())}readRightID(){return new bl(this.clientDecoder.read(),this.rightClockDecoder.read())}readClient(){return this.clientDecoder.read()}readInfo(){return this.infoDecoder.read()}readString(){return this.stringDecoder.read()}readParentInfo(){return this.parentInfoDecoder.read()===1}readTypeRef(){return this.typeRefDecoder.read()}readLen(){return this.lenDecoder.read()}readAny(){return Od(this.restDecoder)}readBuf(){return Pr(this.restDecoder)}readJSON(){return Od(this.restDecoder)}readKey(){const e=this.keyClockDecoder.read();if(e<this.keys.length)return this.keys[e];{const t=this.stringDecoder.read();return this.keys.push(t),t}}}class Yme{constructor(){this.restEncoder=ey()}toUint8Array(){return ss(this.restEncoder)}resetDsCurVal(){}writeDsClock(e){ot(this.restEncoder,e)}writeDsLen(e){ot(this.restEncoder,e)}}class hf extends Yme{writeLeftID(e){ot(this.restEncoder,e.client),ot(this.restEncoder,e.clock)}writeRightID(e){ot(this.restEncoder,e.client),ot(this.restEncoder,e.clock)}writeClient(e){ot(this.restEncoder,e)}writeInfo(e){O_(this.restEncoder,e)}writeString(e){gl(this.restEncoder,e)}writeParentInfo(e){ot(this.restEncoder,e?1:0)}writeTypeRef(e){ot(this.restEncoder,e)}writeLen(e){ot(this.restEncoder,e)}writeAny(e){Ld(this.restEncoder,e)}writeBuf(e){Ir(this.restEncoder,e)}writeJSON(e){gl(this.restEncoder,JSON.stringify(e))}writeKey(e){gl(this.restEncoder,e)}}class Zme{constructor(){this.restEncoder=ey(),this.dsCurrVal=0}toUint8Array(){return ss(this.restEncoder)}resetDsCurVal(){this.dsCurrVal=0}writeDsClock(e){const t=e-this.dsCurrVal;this.dsCurrVal=e,ot(this.restEncoder,t)}writeDsLen(e){e===0&&hs(),ot(this.restEncoder,e-1),this.dsCurrVal+=e}}class oc extends Zme{constructor(){super(),this.keyMap=new Map,this.keyClock=0,this.keyClockEncoder=new ib,this.clientEncoder=new jp,this.leftClockEncoder=new ib,this.rightClockEncoder=new ib,this.infoEncoder=new aM(O_),this.stringEncoder=new nme,this.parentInfoEncoder=new aM(O_),this.typeRefEncoder=new jp,this.lenEncoder=new jp}toUint8Array(){const e=ey();return ot(e,0),Ir(e,this.keyClockEncoder.toUint8Array()),Ir(e,this.clientEncoder.toUint8Array()),Ir(e,this.leftClockEncoder.toUint8Array()),Ir(e,this.rightClockEncoder.toUint8Array()),Ir(e,ss(this.infoEncoder)),Ir(e,this.stringEncoder.toUint8Array()),Ir(e,ss(this.parentInfoEncoder)),Ir(e,this.typeRefEncoder.toUint8Array()),Ir(e,this.lenEncoder.toUint8Array()),ty(e,ss(this.restEncoder)),ss(e)}writeLeftID(e){this.clientEncoder.write(e.client),this.leftClockEncoder.write(e.clock)}writeRightID(e){this.clientEncoder.write(e.client),this.rightClockEncoder.write(e.clock)}writeClient(e){this.clientEncoder.write(e)}writeInfo(e){this.infoEncoder.write(e)}writeString(e){this.stringEncoder.write(e)}writeParentInfo(e){this.parentInfoEncoder.write(e?1:0)}writeTypeRef(e){this.typeRefEncoder.write(e)}writeLen(e){this.lenEncoder.write(e)}writeAny(e){Ld(this.restEncoder,e)}writeBuf(e){Ir(this.restEncoder,e)}writeJSON(e){Ld(this.restEncoder,e)}writeKey(e){const t=this.keyMap.get(e);t===void 0?(this.keyClockEncoder.write(this.keyClock++),this.stringEncoder.write(e)):this.keyClockEncoder.write(t)}}const jme=(n,e,t,r)=>{r=fc(r,e[0].id.clock);const i=ds(e,r);ot(n.restEncoder,e.length-i),n.writeClient(t),ot(n.restEncoder,r);const s=e[i];s.write(n,r-s.id.clock);for(let o=i+1;o<e.length;o++)e[o].write(n,0)},KS=(n,e,t)=>{const r=new Map;t.forEach((i,s)=>{gn(e,s)>i&&r.set(s,i)}),YS(e).forEach((i,s)=>{t.has(s)||r.set(s,0)}),ot(n.restEncoder,r.size),sc(r.entries()).sort((i,s)=>s[0]-i[0]).forEach(([i,s])=>{jme(n,e.clients.get(i),i,s)})},Jme=(n,e)=>{const t=$i(),r=Qe(n.restDecoder);for(let i=0;i<r;i++){const s=Qe(n.restDecoder),o=new Array(s),a=n.readClient();let c=Qe(n.restDecoder);t.set(a,{i:0,refs:o});for(let l=0;l<s;l++){const u=n.readInfo();switch(Qg&u){case 0:{const d=n.readLen();o[l]=new jr(it(a,c),d),c+=d;break}case 10:{const d=Qe(n.restDecoder);o[l]=new Jr(it(a,c),d),c+=d;break}default:{const d=(u&(Qs|kr))===0,f=new rn(it(a,c),null,(u&kr)===kr?n.readLeftID():null,null,(u&Qs)===Qs?n.readRightID():null,d?n.readParentInfo()?e.get(n.readString()):n.readLeftID():null,d&&(u&Dd)===Dd?n.readString():null,_U(n,u));o[l]=f,c+=f.length}}}}return t},Qme=(n,e,t)=>{const r=[];let i=sc(t.keys()).sort((p,g)=>p-g);if(i.length===0)return null;const s=()=>{if(i.length===0)return null;let p=t.get(i[i.length-1]);for(;p.refs.length===p.i;)if(i.pop(),i.length>0)p=t.get(i[i.length-1]);else return null;return p};let o=s();if(o===null&&r.length===0)return null;const a=new eU,c=new Map,l=(p,g)=>{const b=c.get(p);(b==null||b>g)&&c.set(p,g)};let u=o.refs[o.i++];const d=new Map,f=()=>{for(const p of r){const g=p.id.client,b=t.get(g);b?(b.i--,a.clients.set(g,b.refs.slice(b.i)),t.delete(g),b.i=0,b.refs=[]):a.clients.set(g,[p]),i=i.filter(m=>m!==g)}r.length=0};for(;;){if(u.constructor!==Jr){const g=sa(d,u.id.client,()=>gn(e,u.id.client))-u.id.clock;if(g<0)r.push(u),l(u.id.client,u.id.clock-1),f();else{const b=u.getMissing(n,e);if(b!==null){r.push(u);const m=t.get(b)||{refs:[],i:0};if(m.refs.length===m.i)l(b,gn(e,b)),f();else{u=m.refs[m.i++];continue}}else(g===0||g<u.length)&&(u.integrate(n,g),d.set(u.id.client,u.id.clock+u.length))}}if(r.length>0)u=r.pop();else if(o!==null&&o.i<o.refs.length)u=o.refs[o.i++];else{if(o=s(),o===null)break;u=o.refs[o.i++]}}if(a.clients.size>0){const p=new oc;return KS(p,a,new Map),ot(p.restEncoder,0),{missing:c,update:p.toUint8Array()}}return null},ege=(n,e)=>KS(n,e.doc.store,e.beforeState),tge=(n,e,t,r=new Au(n))=>St(e,i=>{i.local=!1;let s=!1;const o=i.doc,a=o.store,c=Jme(r,o),l=Qme(i,a,c),u=a.pendingStructs;if(u){for(const[f,p]of u.missing)if(p<gn(a,f)){s=!0;break}if(l){for(const[f,p]of l.missing){const g=u.missing.get(f);(g==null||g>p)&&u.missing.set(f,p)}u.update=ug([u.update,l.update])}}else a.pendingStructs=l;const d=fM(r,i,a);if(a.pendingDs){const f=new Au(qu(a.pendingDs));Qe(f.restDecoder);const p=fM(f,i,a);d&&p?a.pendingDs=ug([d,p]):a.pendingDs=d||p}else a.pendingDs=d;if(s){const f=a.pendingStructs.update;a.pendingStructs=null,ZN(i.doc,f)}},t,!1),ZN=(n,e,t,r=Au)=>{const i=qu(e);tge(i,n,t,new r(i))},XS=(n,e,t)=>ZN(n,e,t,YN),nge=(n,e,t=new Map)=>{KS(n,e.store,t),Ku(n,Kme(e.store))},rge=(n,e=new Uint8Array([0]),t=new oc)=>{const r=JN(e);nge(t,n,r);const i=[t.toUint8Array()];if(n.store.pendingDs&&i.push(n.store.pendingDs),n.store.pendingStructs&&i.push(mge(n.store.pendingStructs.update,e)),i.length>1){if(t.constructor===hf)return fge(i.map((s,o)=>o===0?s:yge(s)));if(t.constructor===oc)return ug(i)}return i[0]},jN=(n,e)=>rge(n,e,new hf),ige=n=>{const e=new Map,t=Qe(n.restDecoder);for(let r=0;r<t;r++){const i=Qe(n.restDecoder),s=Qe(n.restDecoder);e.set(i,s)}return e},JN=n=>ige(new XN(qu(n)));class sge{constructor(){this.l=[]}}const pM=()=>new sge,mM=(n,e)=>n.l.push(e),gM=(n,e)=>{const t=n.l,r=t.length;n.l=t.filter(i=>e!==i),r===n.l.length&&console.error("[yjs] Tried to remove event handler that doesn't exist.")},QN=(n,e,t)=>HS(n.l,[e,t]);class bl{constructor(e,t){this.client=e,this.clock=t}}const Cp=(n,e)=>n===e||n!==null&&e!==null&&n.client===e.client&&n.clock===e.clock,it=(n,e)=>new bl(n,e),oge=n=>{for(const[e,t]of n.doc.share.entries())if(t===n)return e;throw hs()},ph=(n,e)=>e===void 0?!n.deleted:e.sv.has(n.id.client)&&(e.sv.get(n.id.client)||0)>n.id.clock&&!qN(e.ds,n.id),$_=(n,e)=>{const t=sa(n.meta,$_,Su),r=n.doc.store;t.has(e)||(e.sv.forEach((i,s)=>{i<gn(r,s)&&na(n,it(s,i))}),k_(n,e.ds,i=>{}),t.add(e))};class eU{constructor(){this.clients=new Map,this.pendingStructs=null,this.pendingDs=null}}const YS=n=>{const e=new Map;return n.clients.forEach((t,r)=>{const i=t[t.length-1];e.set(r,i.id.clock+i.length)}),e},gn=(n,e)=>{const t=n.clients.get(e);if(t===void 0)return 0;const r=t[t.length-1];return r.id.clock+r.length},tU=(n,e)=>{let t=n.clients.get(e.id.client);if(t===void 0)t=[],n.clients.set(e.id.client,t);else{const r=t[t.length-1];if(r.id.clock+r.length!==e.id.clock)throw hs()}t.push(e)},ds=(n,e)=>{let t=0,r=n.length-1,i=n[r],s=i.id.clock;if(s===e)return r;let o=ta(e/(s+i.length-1)*r);for(;t<=r;){if(i=n[o],s=i.id.clock,s<=e){if(e<s+i.length)return o;t=o+1}else r=o-1;o=ta((t+r)/2)}throw hs()},age=(n,e)=>{const t=n.clients.get(e.client);return t[ds(t,e.clock)]},ab=age,F_=(n,e,t)=>{const r=ds(e,t),i=e[r];return i.id.clock<t&&i instanceof rn?(e.splice(r+1,0,gg(n,i,t-i.id.clock)),r+1):r},na=(n,e)=>{const t=n.doc.store.clients.get(e.client);return t[F_(n,t,e.clock)]},yM=(n,e,t)=>{const r=e.clients.get(t.client),i=ds(r,t.clock),s=r[i];return t.clock!==s.id.clock+s.length-1&&s.constructor!==jr&&r.splice(i+1,0,gg(n,s,t.clock-s.id.clock+1)),s},cge=(n,e,t)=>{const r=n.clients.get(e.id.client);r[ds(r,e.id.clock)]=t},nU=(n,e,t,r,i)=>{if(r===0)return;const s=t+r;let o=F_(n,e,t),a;do a=e[o++],s<a.id.clock+a.length&&F_(n,e,s),i(a);while(o<e.length&&e[o].id.clock<s)};class lge{constructor(e,t,r){this.doc=e,this.deleteSet=new uf,this.beforeState=YS(e.store),this.afterState=new Map,this.changed=new Map,this.changedParentTypes=new Map,this._mergeStructs=[],this.origin=t,this.meta=new Map,this.local=r,this.subdocsAdded=new Set,this.subdocsRemoved=new Set,this.subdocsLoaded=new Set}}const bM=(n,e)=>e.deleteSet.clients.size===0&&!Npe(e.afterState,(t,r)=>e.beforeState.get(r)!==t)?!1:(WS(e.deleteSet),ege(n,e),Ku(n,e.deleteSet),!0),wM=(n,e,t)=>{const r=e._item;(r===null||r.id.clock<(n.beforeState.get(r.id.client)||0)&&!r.deleted)&&sa(n.changed,e,Su).add(t)},Qp=(n,e)=>{const t=n[e-1],r=n[e];t.deleted===r.deleted&&t.constructor===r.constructor&&t.mergeWith(r)&&(n.splice(e,1),r instanceof rn&&r.parentSub!==null&&r.parent._map.get(r.parentSub)===r&&r.parent._map.set(r.parentSub,t))},uge=(n,e,t)=>{for(const[r,i]of n.clients.entries()){const s=e.clients.get(r);for(let o=i.length-1;o>=0;o--){const a=i[o],c=a.clock+a.len;for(let l=ds(s,a.clock),u=s[l];l<s.length&&u.id.clock<c;u=s[++l]){const d=s[l];if(a.clock+a.len<=d.id.clock)break;d instanceof rn&&d.deleted&&!d.keep&&t(d)&&d.gc(e,!1)}}}},hge=(n,e)=>{n.clients.forEach((t,r)=>{const i=e.clients.get(r);for(let s=t.length-1;s>=0;s--){const o=t[s],a=RN(i.length-1,1+ds(i,o.clock+o.len-1));for(let c=a,l=i[c];c>0&&l.id.clock>=o.clock;l=i[--c])Qp(i,c)}})},rU=(n,e)=>{if(e<n.length){const t=n[e],r=t.doc,i=r.store,s=t.deleteSet,o=t._mergeStructs;try{WS(s),t.afterState=YS(t.doc.store),r.emit("beforeObserverCalls",[t,r]);const a=[];t.changed.forEach((c,l)=>a.push(()=>{(l._item===null||!l._item.deleted)&&l._callObserver(t,c)})),a.push(()=>{t.changedParentTypes.forEach((c,l)=>a.push(()=>{(l._item===null||!l._item.deleted)&&(c=c.filter(u=>u.target._item===null||!u.target._item.deleted),c.forEach(u=>{u.currentTarget=l}),c.sort((u,d)=>u.path.length-d.path.length),QN(l._dEH,c,t))})),a.push(()=>r.emit("afterTransaction",[t,r]))}),HS(a,[])}finally{r.gc&&uge(s,i,r.gcFilter),hge(s,i),t.afterState.forEach((u,d)=>{const f=t.beforeState.get(d)||0;if(f!==u){const p=i.clients.get(d),g=fc(ds(p,f),1);for(let b=p.length-1;b>=g;b--)Qp(p,b)}});for(let u=0;u<o.length;u++){const{client:d,clock:f}=o[u].id,p=i.clients.get(d),g=ds(p,f);g+1<p.length&&Qp(p,g+1),g>0&&Qp(p,g)}if(!t.local&&t.afterState.get(r.clientID)!==t.beforeState.get(r.clientID)&&(zme(GN,zN,"[yjs] ",VN,HN,"Changed the client-id because another client seems to be using it."),r.clientID=KN()),r.emit("afterTransactionCleanup",[t,r]),r._observers.has("update")){const u=new hf;bM(u,t)&&r.emit("update",[u.toUint8Array(),t.origin,r,t])}if(r._observers.has("updateV2")){const u=new oc;bM(u,t)&&r.emit("updateV2",[u.toUint8Array(),t.origin,r,t])}const{subdocsAdded:a,subdocsLoaded:c,subdocsRemoved:l}=t;(a.size>0||l.size>0||c.size>0)&&(a.forEach(u=>{u.clientID=r.clientID,u.collectionid==null&&(u.collectionid=r.collectionid),r.subdocs.add(u)}),l.forEach(u=>r.subdocs.delete(u)),r.emit("subdocs",[{loaded:c,added:a,removed:l},r,t]),l.forEach(u=>u.destroy())),n.length<=e+1?(r._transactionCleanups=[],r.emit("afterAllTransactions",[r,n])):rU(n,e+1)}}},St=(n,e,t=null,r=!0)=>{const i=n._transactionCleanups;let s=!1,o=null;n._transaction===null&&(s=!0,n._transaction=new lge(n,t,r),i.push(n._transaction),i.length===1&&n.emit("beforeAllTransactions",[n]),n.emit("beforeTransaction",[n._transaction,n]));try{o=e(n._transaction)}finally{if(s){const a=n._transaction===i[0];n._transaction=null,a&&rU(i,0)}}return o};function*dge(n){const e=Qe(n.restDecoder);for(let t=0;t<e;t++){const r=Qe(n.restDecoder),i=n.readClient();let s=Qe(n.restDecoder);for(let o=0;o<r;o++){const a=n.readInfo();if(a===10){const c=Qe(n.restDecoder);yield new Jr(it(i,s),c),s+=c}else if((Qg&a)!==0){const c=(a&(Qs|kr))===0,l=new rn(it(i,s),null,(a&kr)===kr?n.readLeftID():null,null,(a&Qs)===Qs?n.readRightID():null,c?n.readParentInfo()?n.readString():n.readLeftID():null,c&&(a&Dd)===Dd?n.readString():null,_U(n,a));yield l,s+=l.length}else{const c=n.readLen();yield new jr(it(i,s),c),s+=c}}}}class ZS{constructor(e,t){this.gen=dge(e),this.curr=null,this.done=!1,this.filterSkips=t,this.next()}next(){do this.curr=this.gen.next().value||null;while(this.filterSkips&&this.curr!==null&&this.curr.constructor===Jr);return this.curr}}class jS{constructor(e){this.currClient=0,this.startClock=0,this.written=0,this.encoder=e,this.clientStructs=[]}}const fge=n=>ug(n,YN,hf),pge=(n,e)=>{if(n.constructor===jr){const{client:t,clock:r}=n.id;return new jr(it(t,r+e),n.length-e)}else if(n.constructor===Jr){const{client:t,clock:r}=n.id;return new Jr(it(t,r+e),n.length-e)}else{const t=n,{client:r,clock:i}=t.id;return new rn(it(r,i+e),null,it(r,i+e-1),null,t.rightOrigin,t.parent,t.parentSub,t.content.splice(e))}},ug=(n,e=Au,t=oc)=>{if(n.length===1)return n[0];const r=n.map(u=>new e(qu(u)));let i=r.map(u=>new ZS(u,!0)),s=null;const o=new t,a=new jS(o);for(;i=i.filter(f=>f.curr!==null),i.sort((f,p)=>{if(f.curr.id.client===p.curr.id.client){const g=f.curr.id.clock-p.curr.id.clock;return g===0?f.curr.constructor===p.curr.constructor?0:f.curr.constructor===Jr?1:-1:g}else return p.curr.id.client-f.curr.id.client}),i.length!==0;){const u=i[0],d=u.curr.id.client;if(s!==null){let f=u.curr,p=!1;for(;f!==null&&f.id.clock+f.length<=s.struct.id.clock+s.struct.length&&f.id.client>=s.struct.id.client;)f=u.next(),p=!0;if(f===null||f.id.client!==d||p&&f.id.clock>s.struct.id.clock+s.struct.length)continue;if(d!==s.struct.id.client)Ro(a,s.struct,s.offset),s={struct:f,offset:0},u.next();else if(s.struct.id.clock+s.struct.length<f.id.clock)if(s.struct.constructor===Jr)s.struct.length=f.id.clock+f.length-s.struct.id.clock;else{Ro(a,s.struct,s.offset);const g=f.id.clock-s.struct.id.clock-s.struct.length;s={struct:new Jr(it(d,s.struct.id.clock+s.struct.length),g),offset:0}}else{const g=s.struct.id.clock+s.struct.length-f.id.clock;g>0&&(s.struct.constructor===Jr?s.struct.length-=g:f=pge(f,g)),s.struct.mergeWith(f)||(Ro(a,s.struct,s.offset),s={struct:f,offset:0},u.next())}}else s={struct:u.curr,offset:0},u.next();for(let f=u.curr;f!==null&&f.id.client===d&&f.id.clock===s.struct.id.clock+s.struct.length&&f.constructor!==Jr;f=u.next())Ro(a,s.struct,s.offset),s={struct:f,offset:0}}s!==null&&(Ro(a,s.struct,s.offset),s=null),JS(a);const c=r.map(u=>qS(u)),l=Wme(c);return Ku(o,l),o.toUint8Array()},mge=(n,e,t=Au,r=oc)=>{const i=JN(e),s=new r,o=new jS(s),a=new t(qu(n)),c=new ZS(a,!1);for(;c.curr;){const u=c.curr,d=u.id.client,f=i.get(d)||0;if(c.curr.constructor===Jr){c.next();continue}if(u.id.clock+u.length>f)for(Ro(o,u,fc(f-u.id.clock,0)),c.next();c.curr&&c.curr.id.client===d;)Ro(o,c.curr,0),c.next();else for(;c.curr&&c.curr.id.client===d&&c.curr.id.clock+c.curr.length<=f;)c.next()}JS(o);const l=qS(a);return Ku(s,l),s.toUint8Array()},iU=n=>{n.written>0&&(n.clientStructs.push({written:n.written,restEncoder:ss(n.encoder.restEncoder)}),n.encoder.restEncoder=ey(),n.written=0)},Ro=(n,e,t)=>{n.written>0&&n.currClient!==e.id.client&&iU(n),n.written===0&&(n.currClient=e.id.client,n.encoder.writeClient(e.id.client),ot(n.encoder.restEncoder,e.id.clock+t)),e.write(n.encoder,t),n.written++},JS=n=>{iU(n);const e=n.encoder.restEncoder;ot(e,n.clientStructs.length);for(let t=0;t<n.clientStructs.length;t++){const r=n.clientStructs[t];ot(e,r.written),ty(e,r.restEncoder)}},gge=(n,e,t)=>{const r=new e(qu(n)),i=new ZS(r,!1),s=new t,o=new jS(s);for(let c=i.curr;c!==null;c=i.next())Ro(o,c,0);JS(o);const a=qS(r);return Ku(s,a),s.toUint8Array()},yge=n=>gge(n,Au,hf);class ry{constructor(e,t){this.target=e,this.currentTarget=e,this.transaction=t,this._changes=null,this._keys=null,this._delta=null}get path(){return bge(this.currentTarget,this.target)}deletes(e){return qN(this.transaction.deleteSet,e.id)}get keys(){if(this._keys===null){const e=new Map,t=this.target;this.transaction.changed.get(t).forEach(i=>{if(i!==null){const s=t._map.get(i);let o,a;if(this.adds(s)){let c=s.left;for(;c!==null&&this.adds(c);)c=c.left;if(this.deletes(s))if(c!==null&&this.deletes(c))o="delete",a=tb(c.content.getContent());else return;else c!==null&&this.deletes(c)?(o="update",a=tb(c.content.getContent())):(o="add",a=void 0)}else if(this.deletes(s))o="delete",a=tb(s.content.getContent());else return;e.set(i,{action:o,oldValue:a})}}),this._keys=e}return this._keys}get delta(){return this.changes.delta}adds(e){return e.id.clock>=(this.transaction.beforeState.get(e.id.client)||0)}get changes(){let e=this._changes;if(e===null){const t=this.target,r=Su(),i=Su(),s=[];if(e={added:r,deleted:i,delta:s,keys:this.keys},this.transaction.changed.get(t).has(null)){let a=null;const c=()=>{a&&s.push(a)};for(let l=t._start;l!==null;l=l.right)l.deleted?this.deletes(l)&&!this.adds(l)&&((a===null||a.delete===void 0)&&(c(),a={delete:0}),a.delete+=l.length,i.add(l)):this.adds(l)?((a===null||a.insert===void 0)&&(c(),a={insert:[]}),a.insert=a.insert.concat(l.content.getContent()),r.add(l)):((a===null||a.retain===void 0)&&(c(),a={retain:0}),a.retain+=l.length);a!==null&&a.retain===void 0&&c()}this._changes=e}return e}}const bge=(n,e)=>{const t=[];for(;e._item!==null&&e!==n;){if(e._item.parentSub!==null)t.unshift(e._item.parentSub);else{let r=0,i=e._item.parent._start;for(;i!==e._item&&i!==null;)i.deleted||r++,i=i.right;t.unshift(r)}e=e._item.parent}return t},sU=80;let QS=0;class wge{constructor(e,t){e.marker=!0,this.p=e,this.index=t,this.timestamp=QS++}}const vge=n=>{n.timestamp=QS++},oU=(n,e,t)=>{n.p.marker=!1,n.p=e,e.marker=!0,n.index=t,n.timestamp=QS++},_ge=(n,e,t)=>{if(n.length>=sU){const r=n.reduce((i,s)=>i.timestamp<s.timestamp?i:s);return oU(r,e,t),r}else{const r=new wge(e,t);return n.push(r),r}},iy=(n,e)=>{if(n._start===null||e===0||n._searchMarker===null)return null;const t=n._searchMarker.length===0?null:n._searchMarker.reduce((s,o)=>Zp(e-s.index)<Zp(e-o.index)?s:o);let r=n._start,i=0;for(t!==null&&(r=t.p,i=t.index,vge(t));r.right!==null&&i<e;){if(!r.deleted&&r.countable){if(e<i+r.length)break;i+=r.length}r=r.right}for(;r.left!==null&&i>e;)r=r.left,!r.deleted&&r.countable&&(i-=r.length);for(;r.left!==null&&r.left.id.client===r.id.client&&r.left.id.clock+r.left.length===r.id.clock;)r=r.left,!r.deleted&&r.countable&&(i-=r.length);return t!==null&&Zp(t.index-i)<r.parent.length/sU?(oU(t,r,i),t):_ge(n._searchMarker,r,i)},Ud=(n,e,t)=>{for(let r=n.length-1;r>=0;r--){const i=n[r];if(t>0){let s=i.p;for(s.marker=!1;s&&(s.deleted||!s.countable);)s=s.left,s&&!s.deleted&&s.countable&&(i.index-=s.length);if(s===null||s.marker===!0){n.splice(r,1);continue}i.p=s,s.marker=!0}(e<i.index||t>0&&e===i.index)&&(i.index=fc(e,i.index+t))}},sy=(n,e,t)=>{const r=n,i=e.changedParentTypes;for(;sa(i,n,()=>[]).push(t),n._item!==null;)n=n._item.parent;QN(r._eH,t,e)};class Mn{constructor(){this._item=null,this._map=new Map,this._start=null,this.doc=null,this._length=0,this._eH=pM(),this._dEH=pM(),this._searchMarker=null}get parent(){return this._item?this._item.parent:null}_integrate(e,t){this.doc=e,this._item=t}_copy(){throw cs()}clone(){throw cs()}_write(e){}get _first(){let e=this._start;for(;e!==null&&e.deleted;)e=e.right;return e}_callObserver(e,t){!e.local&&this._searchMarker&&(this._searchMarker.length=0)}observe(e){mM(this._eH,e)}observeDeep(e){mM(this._dEH,e)}unobserve(e){gM(this._eH,e)}unobserveDeep(e){gM(this._dEH,e)}toJSON(){}}const aU=(n,e,t)=>{e<0&&(e=n._length+e),t<0&&(t=n._length+t);let r=t-e;const i=[];let s=n._start;for(;s!==null&&r>0;){if(s.countable&&!s.deleted){const o=s.content.getContent();if(o.length<=e)e-=o.length;else{for(let a=e;a<o.length&&r>0;a++)i.push(o[a]),r--;e=0}}s=s.right}return i},cU=n=>{const e=[];let t=n._start;for(;t!==null;){if(t.countable&&!t.deleted){const r=t.content.getContent();for(let i=0;i<r.length;i++)e.push(r[i])}t=t.right}return e},Bd=(n,e)=>{let t=0,r=n._start;for(;r!==null;){if(r.countable&&!r.deleted){const i=r.content.getContent();for(let s=0;s<i.length;s++)e(i[s],t++,n)}r=r.right}},lU=(n,e)=>{const t=[];return Bd(n,(r,i)=>{t.push(e(r,i,n))}),t},Ege=n=>{let e=n._start,t=null,r=0;return{[Symbol.iterator](){return this},next:()=>{if(t===null){for(;e!==null&&e.deleted;)e=e.right;if(e===null)return{done:!0,value:void 0};t=e.content.getContent(),r=0,e=e.right}const i=t[r++];return t.length<=r&&(t=null),{done:!1,value:i}}}},uU=(n,e)=>{const t=iy(n,e);let r=n._start;for(t!==null&&(r=t.p,e-=t.index);r!==null;r=r.right)if(!r.deleted&&r.countable){if(e<r.length)return r.content.getContent()[e];e-=r.length}},hg=(n,e,t,r)=>{let i=t;const s=n.doc,o=s.clientID,a=s.store,c=t===null?e._start:t.right;let l=[];const u=()=>{l.length>0&&(i=new rn(it(o,gn(a,o)),i,i&&i.lastId,c,c&&c.id,e,null,new cc(l)),i.integrate(n,0),l=[])};r.forEach(d=>{if(d===null)l.push(d);else switch(d.constructor){case Number:case Object:case Boolean:case Array:case String:l.push(d);break;default:switch(u(),d.constructor){case Uint8Array:case ArrayBuffer:i=new rn(it(o,gn(a,o)),i,i&&i.lastId,c,c&&c.id,e,null,new df(new Uint8Array(d))),i.integrate(n,0);break;case Xu:i=new rn(it(o,gn(a,o)),i,i&&i.lastId,c,c&&c.id,e,null,new ff(d)),i.integrate(n,0);break;default:if(d instanceof Mn)i=new rn(it(o,gn(a,o)),i,i&&i.lastId,c,c&&c.id,e,null,new ho(d)),i.integrate(n,0);else throw new Error("Unexpected content type in insert operation")}}}),u()},hU=pc("Length exceeded!"),dU=(n,e,t,r)=>{if(t>e._length)throw hU;if(t===0)return e._searchMarker&&Ud(e._searchMarker,t,r.length),hg(n,e,null,r);const i=t,s=iy(e,t);let o=e._start;for(s!==null&&(o=s.p,t-=s.index,t===0&&(o=o.prev,t+=o&&o.countable&&!o.deleted?o.length:0));o!==null;o=o.right)if(!o.deleted&&o.countable){if(t<=o.length){t<o.length&&na(n,it(o.id.client,o.id.clock+t));break}t-=o.length}return e._searchMarker&&Ud(e._searchMarker,i,r.length),hg(n,e,o,r)},Sge=(n,e,t)=>{let i=(e._searchMarker||[]).reduce((s,o)=>o.index>s.index?o:s,{index:0,p:e._start}).p;if(i)for(;i.right;)i=i.right;return hg(n,e,i,t)},fU=(n,e,t,r)=>{if(r===0)return;const i=t,s=r,o=iy(e,t);let a=e._start;for(o!==null&&(a=o.p,t-=o.index);a!==null&&t>0;a=a.right)!a.deleted&&a.countable&&(t<a.length&&na(n,it(a.id.client,a.id.clock+t)),t-=a.length);for(;r>0&&a!==null;)a.deleted||(r<a.length&&na(n,it(a.id.client,a.id.clock+r)),a.delete(n),r-=a.length),a=a.right;if(r>0)throw hU;e._searchMarker&&Ud(e._searchMarker,i,-s+r)},dg=(n,e,t)=>{const r=e._map.get(t);r!==void 0&&r.delete(n)},ex=(n,e,t,r)=>{const i=e._map.get(t)||null,s=n.doc,o=s.clientID;let a;if(r==null)a=new cc([r]);else switch(r.constructor){case Number:case Object:case Boolean:case Array:case String:a=new cc([r]);break;case Uint8Array:a=new df(r);break;case Xu:a=new ff(r);break;default:if(r instanceof Mn)a=new ho(r);else throw new Error("Unexpected content type")}new rn(it(o,gn(s.store,o)),i,i&&i.lastId,null,null,e,t,a).integrate(n,0)},tx=(n,e)=>{const t=n._map.get(e);return t!==void 0&&!t.deleted?t.content.getContent()[t.length-1]:void 0},pU=n=>{const e={};return n._map.forEach((t,r)=>{t.deleted||(e[r]=t.content.getContent()[t.length-1])}),e},mU=(n,e)=>{const t=n._map.get(e);return t!==void 0&&!t.deleted},Ip=n=>Hme(n.entries(),e=>!e[1].deleted);class xge extends ry{constructor(e,t){super(e,t),this._transaction=t}}class wl extends Mn{constructor(){super(),this._prelimContent=[],this._searchMarker=[]}static from(e){const t=new wl;return t.push(e),t}_integrate(e,t){super._integrate(e,t),this.insert(0,this._prelimContent),this._prelimContent=null}_copy(){return new wl}clone(){const e=new wl;return e.insert(0,this.toArray().map(t=>t instanceof Mn?t.clone():t)),e}get length(){return this._prelimContent===null?this._length:this._prelimContent.length}_callObserver(e,t){super._callObserver(e,t),sy(this,e,new xge(this,e))}insert(e,t){this.doc!==null?St(this.doc,r=>{dU(r,this,e,t)}):this._prelimContent.splice(e,0,...t)}push(e){this.doc!==null?St(this.doc,t=>{Sge(t,this,e)}):this._prelimContent.push(...e)}unshift(e){this.insert(0,e)}delete(e,t=1){this.doc!==null?St(this.doc,r=>{fU(r,this,e,t)}):this._prelimContent.splice(e,t)}get(e){return uU(this,e)}toArray(){return cU(this)}slice(e=0,t=this.length){return aU(this,e,t)}toJSON(){return this.map(e=>e instanceof Mn?e.toJSON():e)}map(e){return lU(this,e)}forEach(e){Bd(this,e)}[Symbol.iterator](){return Ege(this)}_write(e){e.writeTypeRef(Kge)}}const Tge=n=>new wl;class Age extends ry{constructor(e,t,r){super(e,t),this.keysChanged=r}}class ra extends Mn{constructor(e){super(),this._prelimContent=null,e===void 0?this._prelimContent=new Map:this._prelimContent=new Map(e)}_integrate(e,t){super._integrate(e,t),this._prelimContent.forEach((r,i)=>{this.set(i,r)}),this._prelimContent=null}_copy(){return new ra}clone(){const e=new ra;return this.forEach((t,r)=>{e.set(r,t instanceof Mn?t.clone():t)}),e}_callObserver(e,t){sy(this,e,new Age(this,e,t))}toJSON(){const e={};return this._map.forEach((t,r)=>{if(!t.deleted){const i=t.content.getContent()[t.length-1];e[r]=i instanceof Mn?i.toJSON():i}}),e}get size(){return[...Ip(this._map)].length}keys(){return ob(Ip(this._map),e=>e[0])}values(){return ob(Ip(this._map),e=>e[1].content.getContent()[e[1].length-1])}entries(){return ob(Ip(this._map),e=>[e[0],e[1].content.getContent()[e[1].length-1]])}forEach(e){this._map.forEach((t,r)=>{t.deleted||e(t.content.getContent()[t.length-1],r,this)})}[Symbol.iterator](){return this.entries()}delete(e){this.doc!==null?St(this.doc,t=>{dg(t,this,e)}):this._prelimContent.delete(e)}set(e,t){return this.doc!==null?St(this.doc,r=>{ex(r,this,e,t)}):this._prelimContent.set(e,t),t}get(e){return tx(this,e)}has(e){return mU(this,e)}clear(){this.doc!==null?St(this.doc,e=>{this.forEach(function(t,r,i){dg(e,i,r)})}):this._prelimContent.clear()}_write(e){e.writeTypeRef(Xge)}}const Mge=n=>new ra,Vo=(n,e)=>n===e||typeof n=="object"&&typeof e=="object"&&n&&e&&Sme(n,e);class z_{constructor(e,t,r,i){this.left=e,this.right=t,this.index=r,this.currentAttributes=i}forward(){switch(this.right===null&&hs(),this.right.content.constructor){case on:this.right.deleted||Yu(this.currentAttributes,this.right.content);break;default:this.right.deleted||(this.index+=this.right.length);break}this.left=this.right,this.right=this.right.right}}const vM=(n,e,t)=>{for(;e.right!==null&&t>0;){switch(e.right.content.constructor){case on:e.right.deleted||Yu(e.currentAttributes,e.right.content);break;default:e.right.deleted||(t<e.right.length&&na(n,it(e.right.id.client,e.right.id.clock+t)),e.index+=e.right.length,t-=e.right.length);break}e.left=e.right,e.right=e.right.right}return e},Pp=(n,e,t)=>{const r=new Map,i=iy(e,t);if(i){const s=new z_(i.p.left,i.p,i.index,r);return vM(n,s,t-i.index)}else{const s=new z_(null,e._start,0,r);return vM(n,s,t)}},gU=(n,e,t,r)=>{for(;t.right!==null&&(t.right.deleted===!0||t.right.content.constructor===on&&Vo(r.get(t.right.content.key),t.right.content.value));)t.right.deleted||r.delete(t.right.content.key),t.forward();const i=n.doc,s=i.clientID;r.forEach((o,a)=>{const c=t.left,l=t.right,u=new rn(it(s,gn(i.store,s)),c,c&&c.lastId,l,l&&l.id,e,null,new on(a,o));u.integrate(n,0),t.right=u,t.forward()})},Yu=(n,e)=>{const{key:t,value:r}=e;r===null?n.delete(t):n.set(t,r)},yU=(n,e)=>{for(;n.right!==null;){if(!(n.right.deleted||n.right.content.constructor===on&&Vo(e[n.right.content.key]||null,n.right.content.value)))break;n.forward()}},bU=(n,e,t,r)=>{const i=n.doc,s=i.clientID,o=new Map;for(const a in r){const c=r[a],l=t.currentAttributes.get(a)||null;if(!Vo(l,c)){o.set(a,l);const{left:u,right:d}=t;t.right=new rn(it(s,gn(i.store,s)),u,u&&u.lastId,d,d&&d.id,e,null,new on(a,c)),t.right.integrate(n,0),t.forward()}}return o},cb=(n,e,t,r,i)=>{t.currentAttributes.forEach((f,p)=>{i[p]===void 0&&(i[p]=null)});const s=n.doc,o=s.clientID;yU(t,i);const a=bU(n,e,t,i),c=r.constructor===String?new fs(r):r instanceof Mn?new ho(r):new mc(r);let{left:l,right:u,index:d}=t;e._searchMarker&&Ud(e._searchMarker,t.index,c.getLength()),u=new rn(it(o,gn(s.store,o)),l,l&&l.lastId,u,u&&u.id,e,null,c),u.integrate(n,0),t.right=u,t.index=d,t.forward(),gU(n,e,t,a)},_M=(n,e,t,r,i)=>{const s=n.doc,o=s.clientID;yU(t,i);const a=bU(n,e,t,i);e:for(;t.right!==null&&(r>0||a.size>0&&(t.right.deleted||t.right.content.constructor===on));){if(!t.right.deleted)switch(t.right.content.constructor){case on:{const{key:c,value:l}=t.right.content,u=i[c];if(u!==void 0){if(Vo(u,l))a.delete(c);else{if(r===0)break e;a.set(c,l)}t.right.delete(n)}else t.currentAttributes.set(c,l);break}default:r<t.right.length&&na(n,it(t.right.id.client,t.right.id.clock+r)),r-=t.right.length;break}t.forward()}if(r>0){let c="";for(;r>0;r--)c+=`
`;t.right=new rn(it(o,gn(s.store,o)),t.left,t.left&&t.left.lastId,t.right,t.right&&t.right.id,e,null,new fs(c)),t.right.integrate(n,0),t.forward()}gU(n,e,t,a)},wU=(n,e,t,r,i)=>{let s=e;const o=$i();for(;s&&(!s.countable||s.deleted);){if(!s.deleted&&s.content.constructor===on){const l=s.content;o.set(l.key,l)}s=s.right}let a=0,c=!1;for(;e!==s;){if(t===e&&(c=!0),!e.deleted){const l=e.content;switch(l.constructor){case on:{const{key:u,value:d}=l,f=r.get(u)||null;(o.get(u)!==l||f===d)&&(e.delete(n),a++,!c&&(i.get(u)||null)===d&&f!==d&&(f===null?i.delete(u):i.set(u,f))),!c&&!e.deleted&&Yu(i,l);break}}}e=e.right}return a},Cge=(n,e)=>{for(;e&&e.right&&(e.right.deleted||!e.right.countable);)e=e.right;const t=new Set;for(;e&&(e.deleted||!e.countable);){if(!e.deleted&&e.content.constructor===on){const r=e.content.key;t.has(r)?e.delete(n):t.add(r)}e=e.left}},Ige=n=>{let e=0;return St(n.doc,t=>{let r=n._start,i=n._start,s=$i();const o=R_(s);for(;i;){if(i.deleted===!1)switch(i.content.constructor){case on:Yu(o,i.content);break;default:e+=wU(t,r,i,s,o),s=R_(o),r=i;break}i=i.right}}),e},EM=(n,e,t)=>{const r=t,i=R_(e.currentAttributes),s=e.right;for(;t>0&&e.right!==null;){if(e.right.deleted===!1)switch(e.right.content.constructor){case ho:case mc:case fs:t<e.right.length&&na(n,it(e.right.id.client,e.right.id.clock+t)),t-=e.right.length,e.right.delete(n);break}e.forward()}s&&wU(n,s,e.right,i,e.currentAttributes);const o=(e.left||e.right).parent;return o._searchMarker&&Ud(o._searchMarker,e.index,-r+t),e};class Pge extends ry{constructor(e,t,r){super(e,t),this.childListChanged=!1,this.keysChanged=new Set,r.forEach(i=>{i===null?this.childListChanged=!0:this.keysChanged.add(i)})}get changes(){if(this._changes===null){const e={keys:this.keys,delta:this.delta,added:new Set,deleted:new Set};this._changes=e}return this._changes}get delta(){if(this._delta===null){const e=this.target.doc,t=[];St(e,r=>{const i=new Map,s=new Map;let o=this.target._start,a=null;const c={};let l="",u=0,d=0;const f=()=>{if(a!==null){let p=null;switch(a){case"delete":d>0&&(p={delete:d}),d=0;break;case"insert":(typeof l=="object"||l.length>0)&&(p={insert:l},i.size>0&&(p.attributes={},i.forEach((g,b)=>{g!==null&&(p.attributes[b]=g)}))),l="";break;case"retain":u>0&&(p={retain:u},vme(c)||(p.attributes=bme({},c))),u=0;break}p&&t.push(p),a=null}};for(;o!==null;){switch(o.content.constructor){case ho:case mc:this.adds(o)?this.deletes(o)||(f(),a="insert",l=o.content.getContent()[0],f()):this.deletes(o)?(a!=="delete"&&(f(),a="delete"),d+=1):o.deleted||(a!=="retain"&&(f(),a="retain"),u+=1);break;case fs:this.adds(o)?this.deletes(o)||(a!=="insert"&&(f(),a="insert"),l+=o.content.str):this.deletes(o)?(a!=="delete"&&(f(),a="delete"),d+=o.length):o.deleted||(a!=="retain"&&(f(),a="retain"),u+=o.length);break;case on:{const{key:p,value:g}=o.content;if(this.adds(o)){if(!this.deletes(o)){const b=i.get(p)||null;Vo(b,g)?g!==null&&o.delete(r):(a==="retain"&&f(),Vo(g,s.get(p)||null)?delete c[p]:c[p]=g)}}else if(this.deletes(o)){s.set(p,g);const b=i.get(p)||null;Vo(b,g)||(a==="retain"&&f(),c[p]=b)}else if(!o.deleted){s.set(p,g);const b=c[p];b!==void 0&&(Vo(b,g)?b!==null&&o.delete(r):(a==="retain"&&f(),g===null?delete c[p]:c[p]=g))}o.deleted||(a==="insert"&&f(),Yu(i,o.content));break}}o=o.right}for(f();t.length>0;){const p=t[t.length-1];if(p.retain!==void 0&&p.attributes===void 0)t.pop();else break}}),this._delta=t}return this._delta}}class Mu extends Mn{constructor(e){super(),this._pending=e!==void 0?[()=>this.insert(0,e)]:[],this._searchMarker=[]}get length(){return this._length}_integrate(e,t){super._integrate(e,t);try{this._pending.forEach(r=>r())}catch(r){console.error(r)}this._pending=null}_copy(){return new Mu}clone(){const e=new Mu;return e.applyDelta(this.toDelta()),e}_callObserver(e,t){super._callObserver(e,t);const r=new Pge(this,e,t),i=e.doc;if(sy(this,e,r),!e.local){let s=!1;for(const[o,a]of e.afterState.entries()){const c=e.beforeState.get(o)||0;if(a!==c&&(nU(e,i.store.clients.get(o),c,a,l=>{!l.deleted&&l.content.constructor===on&&(s=!0)}),s))break}s||k_(e,e.deleteSet,o=>{o instanceof jr||s||o.parent===this&&o.content.constructor===on&&(s=!0)}),St(i,o=>{s?Ige(this):k_(o,o.deleteSet,a=>{a instanceof jr||a.parent===this&&Cge(o,a)})})}}toString(){let e="",t=this._start;for(;t!==null;)!t.deleted&&t.countable&&t.content.constructor===fs&&(e+=t.content.str),t=t.right;return e}toJSON(){return this.toString()}applyDelta(e,{sanitize:t=!0}={}){this.doc!==null?St(this.doc,r=>{const i=new z_(null,this._start,0,new Map);for(let s=0;s<e.length;s++){const o=e[s];if(o.insert!==void 0){const a=!t&&typeof o.insert=="string"&&s===e.length-1&&i.right===null&&o.insert.slice(-1)===`
`?o.insert.slice(0,-1):o.insert;(typeof a!="string"||a.length>0)&&cb(r,this,i,a,o.attributes||{})}else o.retain!==void 0?_M(r,this,i,o.retain,o.attributes||{}):o.delete!==void 0&&EM(r,i,o.delete)}}):this._pending.push(()=>this.applyDelta(e))}toDelta(e,t,r){const i=[],s=new Map,o=this.doc;let a="",c=this._start;function l(){if(a.length>0){const d={};let f=!1;s.forEach((g,b)=>{f=!0,d[b]=g});const p={insert:a};f&&(p.attributes=d),i.push(p),a=""}}const u=()=>{for(;c!==null;){if(ph(c,e)||t!==void 0&&ph(c,t))switch(c.content.constructor){case fs:{const d=s.get("ychange");e!==void 0&&!ph(c,e)?(d===void 0||d.user!==c.id.client||d.type!=="removed")&&(l(),s.set("ychange",r?r("removed",c.id):{type:"removed"})):t!==void 0&&!ph(c,t)?(d===void 0||d.user!==c.id.client||d.type!=="added")&&(l(),s.set("ychange",r?r("added",c.id):{type:"added"})):d!==void 0&&(l(),s.delete("ychange")),a+=c.content.str;break}case ho:case mc:{l();const d={insert:c.content.getContent()[0]};if(s.size>0){const f={};d.attributes=f,s.forEach((p,g)=>{f[g]=p})}i.push(d);break}case on:ph(c,e)&&(l(),Yu(s,c.content));break}c=c.right}l()};return e||t?St(o,d=>{e&&$_(d,e),t&&$_(d,t),u()},"cleanup"):u(),i}insert(e,t,r){if(t.length<=0)return;const i=this.doc;i!==null?St(i,s=>{const o=Pp(s,this,e);r||(r={},o.currentAttributes.forEach((a,c)=>{r[c]=a})),cb(s,this,o,t,r)}):this._pending.push(()=>this.insert(e,t,r))}insertEmbed(e,t,r={}){const i=this.doc;i!==null?St(i,s=>{const o=Pp(s,this,e);cb(s,this,o,t,r)}):this._pending.push(()=>this.insertEmbed(e,t,r))}delete(e,t){if(t===0)return;const r=this.doc;r!==null?St(r,i=>{EM(i,Pp(i,this,e),t)}):this._pending.push(()=>this.delete(e,t))}format(e,t,r){if(t===0)return;const i=this.doc;i!==null?St(i,s=>{const o=Pp(s,this,e);o.right!==null&&_M(s,this,o,t,r)}):this._pending.push(()=>this.format(e,t,r))}removeAttribute(e){this.doc!==null?St(this.doc,t=>{dg(t,this,e)}):this._pending.push(()=>this.removeAttribute(e))}setAttribute(e,t){this.doc!==null?St(this.doc,r=>{ex(r,this,e,t)}):this._pending.push(()=>this.setAttribute(e,t))}getAttribute(e){return tx(this,e)}getAttributes(){return pU(this)}_write(e){e.writeTypeRef(Yge)}}const Dge=n=>new Mu;class lb{constructor(e,t=()=>!0){this._filter=t,this._root=e,this._currentNode=e._start,this._firstCall=!0}[Symbol.iterator](){return this}next(){let e=this._currentNode,t=e&&e.content&&e.content.type;if(e!==null&&(!this._firstCall||e.deleted||!this._filter(t)))do if(t=e.content.type,!e.deleted&&(t.constructor===kd||t.constructor===ac)&&t._start!==null)e=t._start;else for(;e!==null;)if(e.right!==null){e=e.right;break}else e.parent===this._root?e=null:e=e.parent._item;while(e!==null&&(e.deleted||!this._filter(e.content.type)));return this._firstCall=!1,e===null?{value:void 0,done:!0}:(this._currentNode=e,{value:e.content.type,done:!1})}}class ac extends Mn{constructor(){super(),this._prelimContent=[]}get firstChild(){const e=this._first;return e?e.content.getContent()[0]:null}_integrate(e,t){super._integrate(e,t),this.insert(0,this._prelimContent),this._prelimContent=null}_copy(){return new ac}clone(){const e=new ac;return e.insert(0,this.toArray().map(t=>t instanceof Mn?t.clone():t)),e}get length(){return this._prelimContent===null?this._length:this._prelimContent.length}createTreeWalker(e){return new lb(this,e)}querySelector(e){e=e.toUpperCase();const r=new lb(this,i=>i.nodeName&&i.nodeName.toUpperCase()===e).next();return r.done?null:r.value}querySelectorAll(e){return e=e.toUpperCase(),sc(new lb(this,t=>t.nodeName&&t.nodeName.toUpperCase()===e))}_callObserver(e,t){sy(this,e,new Oge(this,t,e))}toString(){return lU(this,e=>e.toString()).join("")}toJSON(){return this.toString()}toDOM(e=document,t={},r){const i=e.createDocumentFragment();return r!==void 0&&r._createAssociation(i,this),Bd(this,s=>{i.insertBefore(s.toDOM(e,t,r),null)}),i}insert(e,t){this.doc!==null?St(this.doc,r=>{dU(r,this,e,t)}):this._prelimContent.splice(e,0,...t)}insertAfter(e,t){if(this.doc!==null)St(this.doc,r=>{const i=e&&e instanceof Mn?e._item:e;hg(r,this,i,t)});else{const r=this._prelimContent,i=e===null?0:r.findIndex(s=>s===e)+1;if(i===0&&e!==null)throw pc("Reference item not found");r.splice(i,0,...t)}}delete(e,t=1){this.doc!==null?St(this.doc,r=>{fU(r,this,e,t)}):this._prelimContent.splice(e,t)}toArray(){return cU(this)}push(e){this.insert(this.length,e)}unshift(e){this.insert(0,e)}get(e){return uU(this,e)}slice(e=0,t=this.length){return aU(this,e,t)}forEach(e){Bd(this,e)}_write(e){e.writeTypeRef(jge)}}const Rge=n=>new ac;class kd extends ac{constructor(e="UNDEFINED"){super(),this.nodeName=e,this._prelimAttrs=new Map}get nextSibling(){const e=this._item?this._item.next:null;return e?e.content.type:null}get prevSibling(){const e=this._item?this._item.prev:null;return e?e.content.type:null}_integrate(e,t){super._integrate(e,t),this._prelimAttrs.forEach((r,i)=>{this.setAttribute(i,r)}),this._prelimAttrs=null}_copy(){return new kd(this.nodeName)}clone(){const e=new kd(this.nodeName),t=this.getAttributes();for(const r in t)e.setAttribute(r,t[r]);return e.insert(0,this.toArray().map(r=>r instanceof Mn?r.clone():r)),e}toString(){const e=this.getAttributes(),t=[],r=[];for(const a in e)r.push(a);r.sort();const i=r.length;for(let a=0;a<i;a++){const c=r[a];t.push(c+'="'+e[c]+'"')}const s=this.nodeName.toLocaleLowerCase(),o=t.length>0?" "+t.join(" "):"";return`<${s}${o}>${super.toString()}</${s}>`}removeAttribute(e){this.doc!==null?St(this.doc,t=>{dg(t,this,e)}):this._prelimAttrs.delete(e)}setAttribute(e,t){this.doc!==null?St(this.doc,r=>{ex(r,this,e,t)}):this._prelimAttrs.set(e,t)}getAttribute(e){return tx(this,e)}hasAttribute(e){return mU(this,e)}getAttributes(){return pU(this)}toDOM(e=document,t={},r){const i=e.createElement(this.nodeName),s=this.getAttributes();for(const o in s)i.setAttribute(o,s[o]);return Bd(this,o=>{i.appendChild(o.toDOM(e,t,r))}),r!==void 0&&r._createAssociation(i,this),i}_write(e){e.writeTypeRef(Zge),e.writeKey(this.nodeName)}}const Lge=n=>new kd(n.readKey());class Oge extends ry{constructor(e,t,r){super(e,r),this.childListChanged=!1,this.attributesChanged=new Set,t.forEach(i=>{i===null?this.childListChanged=!0:this.attributesChanged.add(i)})}}class fg extends ra{constructor(e){super(),this.hookName=e}_copy(){return new fg(this.hookName)}clone(){const e=new fg(this.hookName);return this.forEach((t,r)=>{e.set(r,t)}),e}toDOM(e=document,t={},r){const i=t[this.hookName];let s;return i!==void 0?s=i.createDom(this):s=document.createElement(this.hookName),s.setAttribute("data-yjs-hook",this.hookName),r!==void 0&&r._createAssociation(s,this),s}_write(e){e.writeTypeRef(Jge),e.writeKey(this.hookName)}}const Nge=n=>new fg(n.readKey());class pg extends Mu{get nextSibling(){const e=this._item?this._item.next:null;return e?e.content.type:null}get prevSibling(){const e=this._item?this._item.prev:null;return e?e.content.type:null}_copy(){return new pg}clone(){const e=new pg;return e.applyDelta(this.toDelta()),e}toDOM(e=document,t,r){const i=e.createTextNode(this.toString());return r!==void 0&&r._createAssociation(i,this),i}toString(){return this.toDelta().map(e=>{const t=[];for(const i in e.attributes){const s=[];for(const o in e.attributes[i])s.push({key:o,value:e.attributes[i][o]});s.sort((o,a)=>o.key<a.key?-1:1),t.push({nodeName:i,attrs:s})}t.sort((i,s)=>i.nodeName<s.nodeName?-1:1);let r="";for(let i=0;i<t.length;i++){const s=t[i];r+=`<${s.nodeName}`;for(let o=0;o<s.attrs.length;o++){const a=s.attrs[o];r+=` ${a.key}="${a.value}"`}r+=">"}r+=e.insert;for(let i=t.length-1;i>=0;i--)r+=`</${t[i].nodeName}>`;return r}).join("")}toJSON(){return this.toString()}_write(e){e.writeTypeRef(Qge)}}const Uge=n=>new pg;class nx{constructor(e,t){this.id=e,this.length=t}get deleted(){throw cs()}mergeWith(e){return!1}write(e,t,r){throw cs()}integrate(e,t){throw cs()}}const Bge=0;class jr extends nx{get deleted(){return!0}delete(){}mergeWith(e){return this.constructor!==e.constructor?!1:(this.length+=e.length,!0)}integrate(e,t){t>0&&(this.id.clock+=t,this.length-=t),tU(e.doc.store,this)}write(e,t){e.writeInfo(Bge),e.writeLen(this.length-t)}getMissing(e,t){return null}}class df{constructor(e){this.content=e}getLength(){return 1}getContent(){return[this.content]}isCountable(){return!0}copy(){return new df(this.content)}splice(e){throw cs()}mergeWith(e){return!1}integrate(e,t){}delete(e){}gc(e){}write(e,t){e.writeBuf(this.content)}getRef(){return 3}}const kge=n=>new df(n.readBuf());class $d{constructor(e){this.len=e}getLength(){return this.len}getContent(){return[]}isCountable(){return!1}copy(){return new $d(this.len)}splice(e){const t=new $d(this.len-e);return this.len=e,t}mergeWith(e){return this.len+=e.len,!0}integrate(e,t){lg(e.deleteSet,t.id.client,t.id.clock,this.len),t.markDeleted()}delete(e){}gc(e){}write(e,t){e.writeLen(this.len-t)}getRef(){return 1}}const $ge=n=>new $d(n.readLen()),vU=(n,e)=>new Xu({guid:n,...e,shouldLoad:e.shouldLoad||e.autoLoad||!1});class ff{constructor(e){e._item&&console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid."),this.doc=e;const t={};this.opts=t,e.gc||(t.gc=!1),e.autoLoad&&(t.autoLoad=!0),e.meta!==null&&(t.meta=e.meta)}getLength(){return 1}getContent(){return[this.doc]}isCountable(){return!0}copy(){return new ff(vU(this.doc.guid,this.opts))}splice(e){throw cs()}mergeWith(e){return!1}integrate(e,t){this.doc._item=t,e.subdocsAdded.add(this.doc),this.doc.shouldLoad&&e.subdocsLoaded.add(this.doc)}delete(e){e.subdocsAdded.has(this.doc)?e.subdocsAdded.delete(this.doc):e.subdocsRemoved.add(this.doc)}gc(e){}write(e,t){e.writeString(this.doc.guid),e.writeAny(this.opts)}getRef(){return 9}}const Fge=n=>new ff(vU(n.readString(),n.readAny()));class mc{constructor(e){this.embed=e}getLength(){return 1}getContent(){return[this.embed]}isCountable(){return!0}copy(){return new mc(this.embed)}splice(e){throw cs()}mergeWith(e){return!1}integrate(e,t){}delete(e){}gc(e){}write(e,t){e.writeJSON(this.embed)}getRef(){return 5}}const zge=n=>new mc(n.readJSON());class on{constructor(e,t){this.key=e,this.value=t}getLength(){return 1}getContent(){return[]}isCountable(){return!1}copy(){return new on(this.key,this.value)}splice(e){throw cs()}mergeWith(e){return!1}integrate(e,t){t.parent._searchMarker=null}delete(e){}gc(e){}write(e,t){e.writeKey(this.key),e.writeJSON(this.value)}getRef(){return 6}}const Vge=n=>new on(n.readKey(),n.readJSON());class mg{constructor(e){this.arr=e}getLength(){return this.arr.length}getContent(){return this.arr}isCountable(){return!0}copy(){return new mg(this.arr)}splice(e){const t=new mg(this.arr.slice(e));return this.arr=this.arr.slice(0,e),t}mergeWith(e){return this.arr=this.arr.concat(e.arr),!0}integrate(e,t){}delete(e){}gc(e){}write(e,t){const r=this.arr.length;e.writeLen(r-t);for(let i=t;i<r;i++){const s=this.arr[i];e.writeString(s===void 0?"undefined":JSON.stringify(s))}}getRef(){return 2}}const Hge=n=>{const e=n.readLen(),t=[];for(let r=0;r<e;r++){const i=n.readString();i==="undefined"?t.push(void 0):t.push(JSON.parse(i))}return new mg(t)};class cc{constructor(e){this.arr=e}getLength(){return this.arr.length}getContent(){return this.arr}isCountable(){return!0}copy(){return new cc(this.arr)}splice(e){const t=new cc(this.arr.slice(e));return this.arr=this.arr.slice(0,e),t}mergeWith(e){return this.arr=this.arr.concat(e.arr),!0}integrate(e,t){}delete(e){}gc(e){}write(e,t){const r=this.arr.length;e.writeLen(r-t);for(let i=t;i<r;i++){const s=this.arr[i];e.writeAny(s)}}getRef(){return 8}}const Gge=n=>{const e=n.readLen(),t=[];for(let r=0;r<e;r++)t.push(n.readAny());return new cc(t)};class fs{constructor(e){this.str=e}getLength(){return this.str.length}getContent(){return this.str.split("")}isCountable(){return!0}copy(){return new fs(this.str)}splice(e){const t=new fs(this.str.slice(e));this.str=this.str.slice(0,e);const r=this.str.charCodeAt(e-1);return r>=55296&&r<=56319&&(this.str=this.str.slice(0,e-1)+"",t.str=""+t.str.slice(1)),t}mergeWith(e){return this.str+=e.str,!0}integrate(e,t){}delete(e){}gc(e){}write(e,t){e.writeString(t===0?this.str:this.str.slice(t))}getRef(){return 4}}const Wge=n=>new fs(n.readString()),qge=[Tge,Mge,Dge,Lge,Rge,Nge,Uge],Kge=0,Xge=1,Yge=2,Zge=3,jge=4,Jge=5,Qge=6;class ho{constructor(e){this.type=e}getLength(){return 1}getContent(){return[this.type]}isCountable(){return!0}copy(){return new ho(this.type._copy())}splice(e){throw cs()}mergeWith(e){return!1}integrate(e,t){this.type._integrate(e.doc,t)}delete(e){let t=this.type._start;for(;t!==null;)t.deleted?e._mergeStructs.push(t):t.delete(e),t=t.right;this.type._map.forEach(r=>{r.deleted?e._mergeStructs.push(r):r.delete(e)}),e.changed.delete(this.type)}gc(e){let t=this.type._start;for(;t!==null;)t.gc(e,!0),t=t.right;this.type._start=null,this.type._map.forEach(r=>{for(;r!==null;)r.gc(e,!0),r=r.left}),this.type._map=new Map}write(e,t){this.type._write(e)}getRef(){return 7}}const eye=n=>new ho(qge[n.readTypeRef()](n)),gg=(n,e,t)=>{const{client:r,clock:i}=e.id,s=new rn(it(r,i+t),e,it(r,i+t-1),e.right,e.rightOrigin,e.parent,e.parentSub,e.content.splice(t));return e.deleted&&s.markDeleted(),e.keep&&(s.keep=!0),e.redone!==null&&(s.redone=it(e.redone.client,e.redone.clock+t)),e.right=s,s.right!==null&&(s.right.left=s),n._mergeStructs.push(s),s.parentSub!==null&&s.right===null&&s.parent._map.set(s.parentSub,s),e.length=t,s};class rn extends nx{constructor(e,t,r,i,s,o,a,c){super(e,c.getLength()),this.origin=r,this.left=t,this.right=i,this.rightOrigin=s,this.parent=o,this.parentSub=a,this.redone=null,this.content=c,this.info=this.content.isCountable()?iM:0}set marker(e){(this.info&rb)>0!==e&&(this.info^=rb)}get marker(){return(this.info&rb)>0}get keep(){return(this.info&rM)>0}set keep(e){this.keep!==e&&(this.info^=rM)}get countable(){return(this.info&iM)>0}get deleted(){return(this.info&nb)>0}set deleted(e){this.deleted!==e&&(this.info^=nb)}markDeleted(){this.info|=nb}getMissing(e,t){if(this.origin&&this.origin.client!==this.id.client&&this.origin.clock>=gn(t,this.origin.client))return this.origin.client;if(this.rightOrigin&&this.rightOrigin.client!==this.id.client&&this.rightOrigin.clock>=gn(t,this.rightOrigin.client))return this.rightOrigin.client;if(this.parent&&this.parent.constructor===bl&&this.id.client!==this.parent.client&&this.parent.clock>=gn(t,this.parent.client))return this.parent.client;if(this.origin&&(this.left=yM(e,t,this.origin),this.origin=this.left.lastId),this.rightOrigin&&(this.right=na(e,this.rightOrigin),this.rightOrigin=this.right.id),(this.left&&this.left.constructor===jr||this.right&&this.right.constructor===jr)&&(this.parent=null),!this.parent)this.left&&this.left.constructor===rn&&(this.parent=this.left.parent,this.parentSub=this.left.parentSub),this.right&&this.right.constructor===rn&&(this.parent=this.right.parent,this.parentSub=this.right.parentSub);else if(this.parent.constructor===bl){const r=ab(t,this.parent);r.constructor===jr?this.parent=null:this.parent=r.content.type}return null}integrate(e,t){if(t>0&&(this.id.clock+=t,this.left=yM(e,e.doc.store,it(this.id.client,this.id.clock-1)),this.origin=this.left.lastId,this.content=this.content.splice(t),this.length-=t),this.parent){if(!this.left&&(!this.right||this.right.left!==null)||this.left&&this.left.right!==this.right){let r=this.left,i;if(r!==null)i=r.right;else if(this.parentSub!==null)for(i=this.parent._map.get(this.parentSub)||null;i!==null&&i.left!==null;)i=i.left;else i=this.parent._start;const s=new Set,o=new Set;for(;i!==null&&i!==this.right;){if(o.add(i),s.add(i),Cp(this.origin,i.origin)){if(i.id.client<this.id.client)r=i,s.clear();else if(Cp(this.rightOrigin,i.rightOrigin))break}else if(i.origin!==null&&o.has(ab(e.doc.store,i.origin)))s.has(ab(e.doc.store,i.origin))||(r=i,s.clear());else break;i=i.right}this.left=r}if(this.left!==null){const r=this.left.right;this.right=r,this.left.right=this}else{let r;if(this.parentSub!==null)for(r=this.parent._map.get(this.parentSub)||null;r!==null&&r.left!==null;)r=r.left;else r=this.parent._start,this.parent._start=this;this.right=r}this.right!==null?this.right.left=this:this.parentSub!==null&&(this.parent._map.set(this.parentSub,this),this.left!==null&&this.left.delete(e)),this.parentSub===null&&this.countable&&!this.deleted&&(this.parent._length+=this.length),tU(e.doc.store,this),this.content.integrate(e,this),wM(e,this.parent,this.parentSub),(this.parent._item!==null&&this.parent._item.deleted||this.parentSub!==null&&this.right!==null)&&this.delete(e)}else new jr(this.id,this.length).integrate(e,0)}get next(){let e=this.right;for(;e!==null&&e.deleted;)e=e.right;return e}get prev(){let e=this.left;for(;e!==null&&e.deleted;)e=e.left;return e}get lastId(){return this.length===1?this.id:it(this.id.client,this.id.clock+this.length-1)}mergeWith(e){if(this.constructor===e.constructor&&Cp(e.origin,this.lastId)&&this.right===e&&Cp(this.rightOrigin,e.rightOrigin)&&this.id.client===e.id.client&&this.id.clock+this.length===e.id.clock&&this.deleted===e.deleted&&this.redone===null&&e.redone===null&&this.content.constructor===e.content.constructor&&this.content.mergeWith(e.content)){const t=this.parent._searchMarker;return t&&t.forEach(r=>{r.p===e&&(r.p=this,!this.deleted&&this.countable&&(r.index-=this.length))}),e.keep&&(this.keep=!0),this.right=e.right,this.right!==null&&(this.right.left=this),this.length+=e.length,!0}return!1}delete(e){if(!this.deleted){const t=this.parent;this.countable&&this.parentSub===null&&(t._length-=this.length),this.markDeleted(),lg(e.deleteSet,this.id.client,this.id.clock,this.length),wM(e,t,this.parentSub),this.content.delete(e)}}gc(e,t){if(!this.deleted)throw hs();this.content.gc(e),t?cge(e,this,new jr(this.id,this.length)):this.content=new $d(this.length)}write(e,t){const r=t>0?it(this.id.client,this.id.clock+t-1):this.origin,i=this.rightOrigin,s=this.parentSub,o=this.content.getRef()&Qg|(r===null?0:kr)|(i===null?0:Qs)|(s===null?0:Dd);if(e.writeInfo(o),r!==null&&e.writeLeftID(r),i!==null&&e.writeRightID(i),r===null&&i===null){const a=this.parent;if(a._item!==void 0){const c=a._item;if(c===null){const l=oge(a);e.writeParentInfo(!0),e.writeString(l)}else e.writeParentInfo(!1),e.writeLeftID(c.id)}else a.constructor===String?(e.writeParentInfo(!0),e.writeString(a)):a.constructor===bl?(e.writeParentInfo(!1),e.writeLeftID(a)):hs();s!==null&&e.writeString(s)}this.content.write(e,t)}}const _U=(n,e)=>tye[e&Qg](n),tye=[()=>{hs()},$ge,Hge,kge,Wge,zge,Vge,eye,Gge,Fge,()=>{hs()}],nye=10;class Jr extends nx{get deleted(){return!0}delete(){}mergeWith(e){return this.constructor!==e.constructor?!1:(this.length+=e.length,!0)}integrate(e,t){hs()}write(e,t){e.writeInfo(nye),ot(e.restEncoder,this.length-t)}getMissing(e,t){return null}}const EU=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:{},SU="__ $YJS$ __";EU[SU]===!0&&console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");EU[SU]=!0;const gc=n=>Tu((e,t)=>{n.onerror=r=>t(new Error(r.target.error)),n.onsuccess=r=>e(r.target.result)}),rye=(n,e)=>Tu((t,r)=>{const i=indexedDB.open(n);i.onupgradeneeded=s=>e(s.target.result),i.onerror=s=>r(pc(s.target.error)),i.onsuccess=s=>{const o=s.target.result;o.onversionchange=()=>{o.close()},t(o)}}),iye=n=>gc(indexedDB.deleteDatabase(n)),sye=(n,e)=>e.forEach(t=>n.createObjectStore.apply(n,t)),Nh=(n,e,t="readwrite")=>{const r=n.transaction(e,t);return e.map(i=>fye(r,i))},xU=(n,e)=>gc(n.count(e)),oye=(n,e)=>gc(n.get(e)),TU=(n,e)=>gc(n.delete(e)),aye=(n,e,t)=>gc(n.put(e,t)),V_=(n,e)=>gc(n.add(e)),cye=(n,e,t)=>gc(n.getAll(e,t)),lye=(n,e,t)=>{let r=null;return dye(n,e,i=>(r=i,!1),t).then(()=>r)},uye=(n,e=null)=>lye(n,e,"prev"),hye=(n,e)=>Tu((t,r)=>{n.onerror=r,n.onsuccess=async i=>{const s=i.target.result;if(s===null||await e(s)===!1)return t();s.continue()}}),dye=(n,e,t,r="next")=>hye(n.openKeyCursor(e,r),i=>t(i.key)),fye=(n,e)=>n.objectStore(e),pye=(n,e)=>IDBKeyRange.upperBound(n,e),mye=(n,e)=>IDBKeyRange.lowerBound(n,e),ub="custom",AU="updates",MU=500,CU=(n,e=()=>{},t=()=>{})=>{const[r]=Nh(n.db,[AU]);return cye(r,mye(n._dbref,!1)).then(i=>{n._destroyed||(e(r),St(n.doc,()=>{i.forEach(s=>XS(n.doc,s))},n,!1),t(r))}).then(()=>uye(r).then(i=>{n._dbref=i+1})).then(()=>xU(r).then(i=>{n._dbsize=i})).then(()=>r)},gye=(n,e=!0)=>CU(n).then(t=>{(e||n._dbsize>=MU)&&V_(t,jN(n.doc)).then(()=>TU(t,pye(n._dbref,!0))).then(()=>xU(t).then(r=>{n._dbsize=r}))});class yye extends kS{constructor(e,t){super(),this.doc=t,this.name=e,this._dbref=0,this._dbsize=0,this._destroyed=!1,this.db=null,this.synced=!1,this._db=rye(e,r=>sye(r,[["updates",{autoIncrement:!0}],["custom"]])),this.whenSynced=Tu(r=>this.on("synced",()=>r(this))),this._db.then(r=>{this.db=r,CU(this,o=>V_(o,jN(t)),()=>{if(this._destroyed)return this;this.synced=!0,this.emit("synced",[this])})}),this._storeTimeout=1e3,this._storeTimeoutId=null,this._storeUpdate=(r,i)=>{if(this.db&&i!==this){const[s]=Nh(this.db,[AU]);V_(s,r),++this._dbsize>=MU&&(this._storeTimeoutId!==null&&clearTimeout(this._storeTimeoutId),this._storeTimeoutId=setTimeout(()=>{gye(this,!1),this._storeTimeoutId=null},this._storeTimeout))}},t.on("update",this._storeUpdate),this.destroy=this.destroy.bind(this),t.on("destroy",this.destroy)}destroy(){return this._storeTimeoutId&&clearTimeout(this._storeTimeoutId),this.doc.off("update",this._storeUpdate),this.doc.off("destroy",this.destroy),this._destroyed=!0,this._db.then(e=>{e.close()})}clearData(){return this.destroy().then(()=>{iye(this.name)})}get(e){return this._db.then(t=>{const[r]=Nh(t,[ub],"readonly");return oye(r,e)})}set(e,t){return this._db.then(r=>{const[i]=Nh(r,[ub]);return aye(i,t,e)})}del(e){return this._db.then(t=>{const[r]=Nh(t,[ub]);return TU(r,e)})}}class bye extends kS{constructor(e,t,r={}){var i;super(),this.networkManager=e,this.doc=t,this.topic=r.topic||"peercompute-state-sync",this.awareness=null,this._onDocumentUpdate=this._onDocumentUpdate.bind(this),this._onNetworkMessage=this._onNetworkMessage.bind(this),this.doc.on("update",this._onDocumentUpdate),(i=this.networkManager)!=null&&i.addMessageHandler&&this.networkManager.addMessageHandler(this._onNetworkMessage),console.log("[PeerComputeProvider] Initialized")}_onDocumentUpdate(e,t){t!==this&&this.networkManager.broadcast({type:"yjs-update",data:Array.from(e)},{topic:this.topic}).catch(r=>{console.error("[PeerComputeProvider] Broadcast failed",r)})}_onNetworkMessage(e,t){if(t.type==="yjs-update"){const r=new Uint8Array(t.data);XS(this.doc,r,this)}}destroy(){this.doc.off("update",this._onDocumentUpdate),this.networkManager=null}}class wye{constructor({ydoc:e,stateMap:t,hotStore:r,deltaNamespace:i="deltas"}={}){if(!e||!t)throw new Error("[DataState] ydoc and stateMap are required");this.ydoc=e,this.state=t,this.hotStore=r||new Map,this.deltaNamespace=i}_getNamespaceMap(e){let t=this.state.get(e);return t||(t=new ra,this.state.set(e,t)),t}commitDelta(e={}){const t=e.taskId||e.key;if(!t)throw new Error("[DataState] commitDelta requires taskId");const r=e.scope||this.deltaNamespace,i={version:e.version??null,payload:e.payload??null,ts:e.timestamp??Date.now()};this.ydoc.transact(()=>{(r?this._getNamespaceMap(r):this.state).set(t,i)},"commit-delta")}readWarm(e,t){if(t){const r=this.state.get(t);return r?r.get(e):void 0}return this.state.get(e)}writeWarm(e,t,r){this.ydoc.transact(()=>{r?this._getNamespaceMap(r).set(e,t):this.state.set(e,t)},"write-warm")}getWarmDeltas(e=this.deltaNamespace){const t=this.state.get(e);return t?typeof t.entries=="function"?Object.fromEntries(t.entries()):{}:{}}setHotBuffer(e,t){this.hotStore.set(e,t)}getHotBuffer(e){return this.hotStore.get(e)}deleteHotBuffer(e){this.hotStore.delete(e)}listHotBuffers(){return Array.from(this.hotStore.keys())}}class vye{constructor(e,t={}){this.networkManager=e,this.libp2pNode=e?e.getLibp2pNode():null,this.config={docName:t.docName||"peercompute-state",topic:t.topic||"peercompute-state-sync",enablePersistence:t.enablePersistence!==!1,disableNetworkProvider:t.disableNetworkProvider||!1,disableBroadcast:t.disableBroadcast||!1,broadcastNamespaces:Array.isArray(t.broadcastNamespaces)?t.broadcastNamespaces:null,...t},this.ydoc=new Xu,this.state=this.ydoc.getMap("state"),this.dataState=new wye({ydoc:this.ydoc,stateMap:this.state,hotStore:t.hotStore,deltaNamespace:t.deltaNamespace||"deltas"}),this.indexeddbProvider=null,this.libp2pProvider=null,this.subscribers=new Map,this.globalSubscribers=new Set,this.isInitialized=!1,this.persistenceFailed=!1}_getNamespaceMap(e){let t=this.state.get(e);return t||(t=new ra,this.state.set(e,t)),t}applyRemoteUpdate(e){try{const t=(()=>{if(e instanceof Uint8Array)return e;if(Array.isArray(e))return new Uint8Array(e);if(e&&typeof e=="object"){const i=Object.values(e);return new Uint8Array(i)}return new Uint8Array(0)})();if(t.byteLength===0){console.warn("[StateManager] Remote update was empty, skipping");return}const r=t;XS(this.ydoc,r,this)}catch(t){console.error("[StateManager] Failed to apply remote update:",t)}}applyStateSet(e,t,r){try{this.ydoc.transact(()=>{if(r){const i=this._getNamespaceMap(r);t===void 0?i.delete(e):i.set(e,t)}else t===void 0?this.state.delete(e):this.state.set(e,t)},"remote-state-set")}catch(i){console.error("[StateManager] Failed to apply state-set:",i)}}commitDelta(e){if(!this.isInitialized)throw new Error("StateManager not initialized");this.dataState.commitDelta(e)}getDataState(){return this.dataState}getWarmDeltas(e){return this.dataState.getWarmDeltas(e)}setHotBuffer(e,t){this.dataState.setHotBuffer(e,t)}getHotBuffer(e){return this.dataState.getHotBuffer(e)}async initialize(e={}){if(this.isInitialized){console.warn("[StateManager] Already initialized");return}try{if(this.config.enablePersistence&&(this.indexeddbProvider=new yye(this.config.docName,this.ydoc),await new Promise(t=>{this.indexeddbProvider.once("synced",t)}),console.log("[StateManager] IndexedDB persistence loaded")),this.networkManager&&!this.config.disableNetworkProvider)try{this.libp2pProvider=new bye(this.networkManager,this.ydoc,{topic:this.config.topic}),console.log("[StateManager] PeerCompute P2P synchronization enabled")}catch(t){console.error("[StateManager] Failed to enable P2P sync:",t)}Object.keys(e).length>0&&this.ydoc.transact(()=>{for(const[t,r]of Object.entries(e))this.state.set(t,r)}),this._setupObservers(),this.isInitialized=!0,console.log("[StateManager] Initialized")}catch(t){throw console.error("[StateManager] Initialization failed:",t),t}}_setupObservers(){this.state.observe(e=>{e.keysChanged.forEach(t=>{const r=this.state.get(t),i=this.subscribers.get(t);i&&i.forEach(s=>{try{s(r,t)}catch(o){console.error("[StateManager] Subscriber error:",o)}}),this.globalSubscribers.forEach(s=>{try{s(r,t)}catch(o){console.error("[StateManager] Global subscriber error:",o)}})})},{captureTransactions:!1})}_setupFallbackSync(){this.libp2pNode&&console.log("[StateManager] Using fallback P2P sync via NetworkManager")}read(e){if(!this.isInitialized)throw new Error("StateManager not initialized");return this.state.get(e)}write(e,t){var r;if(!this.isInitialized)throw new Error("StateManager not initialized");this._safeSetMap(this.state,e,t),(r=this.networkManager)!=null&&r.broadcast&&!this.config.disableBroadcast&&this.networkManager.broadcast({type:"state-set",data:{key:e,value:t}}).catch(()=>{})}writeScoped(e,t,r){var s;const i=this._getNamespaceMap(e);this._safeSetMap(i,t,r),(s=this.networkManager)!=null&&s.broadcast&&!this.config.disableBroadcast&&(!this.config.broadcastNamespaces||this.config.broadcastNamespaces.includes(e))&&this.networkManager.broadcast({type:"state-set",data:{namespace:e,key:t,value:r}}).catch(()=>{})}readScoped(e,t){const r=this.state.get(e);if(r)return r.get(t)}hasScoped(e,t){const r=this.state.get(e);return r?r.has(t):!1}listNamespaceKeys(e){const t=this.state.get(e);return t?Array.from(t.keys()):[]}clearNamespace(e){var i;const t=this.state.get(e);if(!t)return;const r=Array.from(t.keys());this.ydoc.transact(()=>{r.forEach(s=>t.delete(s))}),(i=this.networkManager)!=null&&i.broadcast&&!this.config.disableBroadcast&&r.forEach(s=>{this.networkManager.broadcast({type:"state-set",data:{namespace:e,key:s,value:void 0}}).catch(()=>{})})}deleteScoped(e,t){var i;const r=this.state.get(e);r&&(r.delete(t),(i=this.networkManager)!=null&&i.broadcast&&!this.config.disableBroadcast&&this.networkManager.broadcast({type:"state-set",data:{namespace:e,key:t,value:void 0}}).catch(()=>{}))}delete(e){if(!this.isInitialized)throw new Error("StateManager not initialized");this.state.delete(e)}has(e){if(!this.isInitialized)throw new Error("StateManager not initialized");return this.state.has(e)}_safeSetMap(e,t,r){var i,s;if(this.persistenceFailed){e.set(t,r);return}try{e.set(t,r)}catch(o){if((o==null?void 0:o.name)==="InvalidStateError")console.warn("[StateManager] Persistence unavailable, disabling IndexedDB provider",o),(s=(i=this.indexeddbProvider)==null?void 0:i.destroy)==null||s.call(i),this.indexeddbProvider=null,this.persistenceFailed=!0,e.set(t,r);else throw o}}batchWrite(e){if(!this.isInitialized)throw new Error("StateManager not initialized");this.ydoc.transact(()=>{for(const[t,r]of Object.entries(e))this.state.set(t,r)})}subscribe(e,t){if(!this.isInitialized)throw new Error("StateManager not initialized");return e==="*"?(this.globalSubscribers.add(t),()=>{this.globalSubscribers.delete(t)}):(this.subscribers.has(e)||this.subscribers.set(e,new Set),this.subscribers.get(e).add(t),()=>{const r=this.subscribers.get(e);r&&(r.delete(t),r.size===0&&this.subscribers.delete(e))})}observeNamespace(e,t){const r=this._getNamespaceMap(e),i=s=>{s.keysChanged.forEach(o=>{t(r.get(o),o)})};return r.observe(i),()=>r.unobserve(i)}keys(){if(!this.isInitialized)throw new Error("StateManager not initialized");return Array.from(this.state.keys())}values(){if(!this.isInitialized)throw new Error("StateManager not initialized");return Array.from(this.state.values())}entries(){if(!this.isInitialized)throw new Error("StateManager not initialized");return Array.from(this.state.entries())}async synchronize(e){console.log("[StateManager] Synchronization is automatic with Yjs CRDT")}snapshot(){if(!this.isInitialized)throw new Error("StateManager not initialized");return{data:Object.fromEntries(this.state.entries()),timestamp:Date.now(),version:this.ydoc.clientID,keyCount:this.state.size}}getYDoc(){return this.ydoc}getYMap(){return this.state}getAwareness(){var e;return((e=this.libp2pProvider)==null?void 0:e.awareness)||null}clear(){if(!this.isInitialized)throw new Error("StateManager not initialized");this.ydoc.transact(()=>{this.state.clear()})}async destroy(){try{this.libp2pProvider&&(this.libp2pProvider.destroy(),this.libp2pProvider=null),this.indexeddbProvider&&(this.indexeddbProvider.destroy(),this.indexeddbProvider=null),this.subscribers.clear(),this.globalSubscribers.clear(),this.ydoc.destroy(),this.isInitialized=!1,console.log("[StateManager] Destroyed")}catch(e){throw console.error("[StateManager] Destroy failed:",e),e}}async clearPersistence(){var e;if((e=this.indexeddbProvider)!=null&&e.clearData)try{await this.indexeddbProvider.clearData(),console.log("[StateManager] IndexedDB persistence cleared")}catch(t){console.error("[StateManager] Failed to clear IndexedDB persistence",t)}}async clearAllPersistenceByPrefix(e,t=[]){if(typeof(indexedDB==null?void 0:indexedDB.databases)=="function")try{const r=await indexedDB.databases();for(const i of r||[])i!=null&&i.name&&i.name.startsWith(e)&&!t.includes(i.name)&&await new Promise((s,o)=>{const a=indexedDB.deleteDatabase(i.name);a.onsuccess=()=>s(),a.onerror=()=>o(a.error),a.onblocked=()=>s()});console.log(`[StateManager] Cleared IndexedDB databases with prefix ${e}`)}catch(r){console.warn("[StateManager] Failed to enumerate/delete IndexedDB databases",r)}}getDocName(){return this.config.docName}getStats(){var e,t;return{isInitialized:this.isInitialized,keyCount:this.state.size,subscriberCount:this.subscribers.size,globalSubscriberCount:this.globalSubscribers.size,hasPersistence:!!this.indexeddbProvider,hasP2PSync:!!this.libp2pProvider,docName:this.config.docName,topic:this.config.topic,hotBufferCount:((t=(e=this.dataState)==null?void 0:e.listHotBuffers)==null?void 0:t.call(e).length)||0}}}const _ye="modulepreload",Eye=function(n,e){return new URL(n,e).href},SM={},Sye=function(e,t,r){let i=Promise.resolve();if(t&&t.length>0){let o=function(u){return Promise.all(u.map(d=>Promise.resolve(d).then(f=>({status:"fulfilled",value:f}),f=>({status:"rejected",reason:f}))))};const a=document.getElementsByTagName("link"),c=document.querySelector("meta[property=csp-nonce]"),l=(c==null?void 0:c.nonce)||(c==null?void 0:c.getAttribute("nonce"));i=o(t.map(u=>{if(u=Eye(u,r),u in SM)return;SM[u]=!0;const d=u.endsWith(".css"),f=d?'[rel="stylesheet"]':"";if(!!r)for(let b=a.length-1;b>=0;b--){const m=a[b];if(m.href===u&&(!d||m.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${u}"]${f}`))return;const g=document.createElement("link");if(g.rel=d?"stylesheet":_ye,d||(g.as="script"),g.crossOrigin="",g.href=u,l&&g.setAttribute("nonce",l),document.head.appendChild(g),d)return new Promise((b,m)=>{g.addEventListener("load",b),g.addEventListener("error",()=>m(new Error(`Unable to preload CSS for ${u}`)))})}))}function s(o){const a=new Event("vite:preloadError",{cancelable:!0});if(a.payload=o,window.dispatchEvent(a),!a.defaultPrevented)throw o}return i.then(o=>{for(const a of o||[])a.status==="rejected"&&s(a.reason);return e().catch(s)})};class xye{constructor(e={}){const t=typeof navigator<"u"&&navigator.hardwareConcurrency?navigator.hardwareConcurrency:4;this.config={enableWebGPU:e.enableWebGPU||!1,enableWorkers:e.enableWorkers!==!1,maxWorkers:e.maxWorkers||t,...e},this.workers=[],this.taskQueue=[],this.activeTasks=new Map,this.commitDeltaHandler=null,this.capabilities={cpu:!0,webgpu:!1},this.initialized=!1}setCommitDeltaHandler(e){this.commitDeltaHandler=e}commitDelta(e){this.commitDeltaHandler&&this.commitDeltaHandler(e)}async initialize(){if(this.initialized)return;if(this.initialized=!0,!(typeof Worker<"u"&&this.config.enableWorkers)){console.warn("[ComputeManager] Web Workers not available; falling back to inline execution");return}const t=new URL("data:text/javascript;base64,LyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovCgpzZWxmLm9ubWVzc2FnZSA9IGFzeW5jIChldmVudCkgPT4gewogIGNvbnN0IG1zZyA9IGV2ZW50LmRhdGE7CiAgaWYgKCFtc2cgfHwgbXNnLnR5cGUgIT09ICdydW4nKSByZXR1cm47CiAgY29uc3QgeyBpZCwgZGF0YSwgZm4sIG1vZHVsZSwgZXhwb3J0TmFtZSB9ID0gbXNnOwogIHRyeSB7CiAgICBsZXQgaGFuZGxlcjsKICAgIGlmIChmbikgewogICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmMKICAgICAgaGFuZGxlciA9IG5ldyBGdW5jdGlvbihgcmV0dXJuICgke2ZufSk7YCkoKTsKICAgIH0gZWxzZSBpZiAobW9kdWxlKSB7CiAgICAgIC8vIFNpbGVuY2Ugd2VicGFjaydzICJkZXBlbmRlbmN5IGlzIGFuIGV4cHJlc3Npb24iIHdhcm5pbmcgYnkgZXhwbGljaXRseSBpZ25vcmluZyBidW5kbGluZyBoZXJlLgogICAgICAvLyBUaGUgd29ya2VyIGV4cGVjdHMgYSByZWFsIFVSTCBzdHJpbmcgcGFzc2VkIGluIGZyb20gdGhlIG1haW4gdGhyZWFkLgogICAgICBjb25zdCBtb2QgPSBhd2FpdCBpbXBvcnQoCiAgICAgICAgLyogd2VicGFja0lnbm9yZTogdHJ1ZSAqLwogICAgICAgIG1vZHVsZQogICAgICApOwogICAgICBoYW5kbGVyID0gbW9kW2V4cG9ydE5hbWUgfHwgJ2RlZmF1bHQnXTsKICAgIH0KICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykgewogICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhbmRsZXIgbm90IGZvdW5kIGZvciB0YXNrJyk7CiAgICB9CiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBoYW5kbGVyKGRhdGEpOwogICAgc2VsZi5wb3N0TWVzc2FnZSh7IHR5cGU6ICdyZXN1bHQnLCBpZCwgcmVzdWx0IH0pOwogIH0gY2F0Y2ggKGVycikgewogICAgc2VsZi5wb3N0TWVzc2FnZSh7IHR5cGU6ICdlcnJvcicsIGlkLCBlcnJvcjogZXJyPy5tZXNzYWdlIHx8IFN0cmluZyhlcnIpIH0pOwogIH0KfTsK",import.meta.url),r=Math.max(1,Math.min(this.config.maxWorkers,128));for(let i=0;i<r;i++){const s=new Worker(t,{type:"module"});s.onmessage=o=>this._handleWorkerMessage(s,o.data),s.onerror=o=>console.error("[ComputeManager] Worker error",o),this.workers.push(s)}}async submitTask(e){if(!e)throw new Error("Task is required");if(!e.fn&&!e.module)throw new Error("Task must provide fn or module");const t=typeof crypto<"u"&&crypto.randomUUID?crypto.randomUUID():`${Date.now()}-${Math.random()}`,r=e.id||t,i={id:r,data:e.data??null,fn:e.fn?e.fn.toString():void 0,module:e.module,exportName:e.exportName||"default"};return this.initialized||await this.initialize(),new Promise((s,o)=>{const a={id:r,payload:i,resolve:s,reject:o};this._dispatchToWorker(a)||(this.taskQueue.push(a),this._scheduleNext())})}async distributeTask(e,t){}async cancelTask(e){}getCapabilities(){return{...this.capabilities,workers:this.workers.length,activeTaskCount:this.activeTasks.size,queuedTaskCount:this.taskQueue.length}}getStats(){return{totalTasksCompleted:0,averageTaskDuration:0,currentLoad:0}}async _executeTask(e){}_scheduleNext(){}_handleTaskComplete(e,t){}_handleTaskError(e,t){}_dispatchToWorker(e){const t=this.workers.find(r=>!Array.from(this.activeTasks.values()).some(i=>i.worker===r));return t?(this.activeTasks.set(e.id,{...e,worker:t}),t.postMessage({type:"run",...e.payload}),!0):!1}async _executeInline(e){try{let t;if(e.payload.fn)t=new Function(`return (${e.payload.fn});`)();else if(e.payload.module){if(typeof e.payload.module!="string")throw new Error("module path must be a string");t=(await Sye(()=>import(`${e.payload.module}`),[],import.meta.url))[e.payload.exportName||"default"]}const r=await t(e.payload.data);if(r&&typeof r=="object"&&Object.prototype.hasOwnProperty.call(r,"commitDelta")){this.commitDelta(r.commitDelta);const i=Object.prototype.hasOwnProperty.call(r,"value")?r.value:r.result;e.resolve(i);return}e.resolve(r)}catch(t){e.reject(t)}}_handleWorkerMessage(e,t){const{id:r,type:i,result:s,error:o}=t||{},a=this.activeTasks.get(r);if(a){if(i==="result"){let c=s;s&&typeof s=="object"&&Object.prototype.hasOwnProperty.call(s,"commitDelta")&&(this.commitDelta(s.commitDelta),c=Object.prototype.hasOwnProperty.call(s,"value")?s.value:s.result),a.resolve(c)}else i==="error"&&a.reject(new Error(o||"Worker task failed"));this.activeTasks.delete(r),this._scheduleNext()}}_scheduleNext(){if(this.taskQueue.length===0)return;const e=this.taskQueue.shift();if(this.workers.length===0){this._executeInline(e);return}this._dispatchToWorker(e)||this.taskQueue.unshift(e)}}class Tye{constructor(e={}){this.frameBudgetMs=e.frameBudgetMs??4,this.hotStore=e.hotStore||new Map,this.device=null,this.tasks=new Map}async initialize(e={}){if(e.device)return this.device=e.device,this.device;if(typeof navigator>"u"||!navigator.gpu)throw new Error("[GPUHubManager] WebGPU not available in this environment");const t=await navigator.gpu.requestAdapter(e.adapterOptions);if(!t)throw new Error("[GPUHubManager] Failed to acquire GPU adapter");return this.device=await t.requestDevice(e.deviceDescriptor),this.device}setDevice(e){this.device=e}getHotStore(){return this.hotStore}registerHotBuffer(e,t){this.hotStore.set(e,t)}registerHotBufferSet(e,t){this.hotStore.set(e,t)}getHotBufferSet(e){return this.hotStore.get(e)}getHotBuffer(e){return this.hotStore.get(e)}createHotBuffer(e,t,r,i){if(!this.device)throw new Error("[GPUHubManager] Device not initialized");const s=this.device.createBuffer({size:t,usage:r,label:i});return this.hotStore.set(e,s),s}removeHotBuffer(e){this.hotStore.delete(e)}registerTask(e,t){this.tasks.set(e,t)}unregisterTask(e){this.tasks.delete(e)}tick(){}}function Aye(){return`${Date.now()}-${Math.random().toString(36).substr(2,9)}`}class IU{constructor(e={}){const t=this._normalizeClockPolicy(e.clockPolicy);this.config={topology:e.topology||"distributed",storageMode:e.storageMode||"local",enableWebGPU:e.enableWebGPU||!1,enableGPUHub:e.enableGPUHub!==!1,enableWarmDeltaProvider:e.enableWarmDeltaProvider||!1,enablePersistence:e.enablePersistence!==!1,disableStateNetworkProvider:e.disableStateNetworkProvider||!1,disableStateBroadcast:e.disableStateBroadcast||!1,bootstrapPeers:Array.isArray(e.bootstrapPeers)?e.bootstrapPeers:[],gameId:e.gameId||"default-game",roomId:e.roomId||"default-room",stateTopic:e.stateTopic||"peercompute-state",docName:e.docName,stateBroadcastNamespaces:e.stateBroadcastNamespaces,deltaNamespace:e.deltaNamespace||"deltas",gpuHubFrameBudgetMs:e.gpuHubFrameBudgetMs,clockPolicy:t,...e},this.stateManager=null,this.networkManager=null,this.computeManager=null,this.gpuHub=null,this.isInitialized=!1,this.isStarted=!1,this.nodeId=null,this.kernelClockTimer=null,this.kernelTickMs=Math.round(1e3/(this.config.clockPolicy.tickHz||30))}async initialize(){var e;if(this.isInitialized){console.warn("[NodeKernel] Already initialized");return}try{console.log("[NodeKernel] Initializing..."),this.nodeId=Aye(),console.log(`[NodeKernel] Node ID: ${this.nodeId}`),this.networkManager=new Lpe({topology:this.config.topology,bootstrapPeers:this.config.bootstrapPeers,gameId:this.config.gameId,roomId:this.config.roomId,pubsubTopic:this.config.stateTopic,schedulerClock:this.config.clockPolicy.mode==="kernel"?"external":"internal",schedulerProfile:this.config.clockPolicy.networkProfile,onMessage:this._handleNetworkMessage.bind(this),onPeerConnect:this._handlePeerConnect.bind(this),onPeerDisconnect:this._handlePeerDisconnect.bind(this)}),await this.networkManager.initialize(),console.log("[NodeKernel] NetworkManager initialized");const t=this.config.docName||`peercompute-${this.config.gameId}-${this.config.roomId}`;this.config.enableGPUHub&&(this.gpuHub=new Tye({frameBudgetMs:this.config.gpuHubFrameBudgetMs})),this.stateManager=new vye(this.networkManager,{docName:t,topic:this.config.stateTopic,enablePersistence:this.config.enablePersistence,disableNetworkProvider:this.config.disableStateNetworkProvider,disableBroadcast:this.config.disableStateBroadcast,broadcastNamespaces:this.config.stateBroadcastNamespaces,deltaNamespace:this.config.deltaNamespace,hotStore:(e=this.gpuHub)==null?void 0:e.getHotStore()}),await this.stateManager.initialize({nodeId:this.nodeId,topology:this.config.topology,createdAt:Date.now()}),console.log("[NodeKernel] StateManager initialized"),this.config.enableWarmDeltaProvider&&this.networkManager.registerWarmDeltaProvider(()=>this.stateManager.getWarmDeltas()),this.computeManager=new xye({enableWebGPU:this.config.enableWebGPU,maxWorkers:this.config.maxWorkers,enableWorkers:this.config.enableWorkers!==!1}),await this.computeManager.initialize(),this.computeManager.setCommitDeltaHandler(r=>{var i,s;(s=(i=this.stateManager)==null?void 0:i.commitDelta)==null||s.call(i,r)}),console.log("[NodeKernel] ComputeManager initialized"),this.isInitialized=!0,console.log("[NodeKernel] Initialization complete")}catch(t){throw console.error("[NodeKernel] Initialization failed:",t),t}}async start(e){if(!this.isInitialized)throw new Error("NodeKernel not initialized. Call initialize() first.");if(this.isStarted){console.warn("[NodeKernel] Already started");return}try{console.log("[NodeKernel] Starting..."),await this.networkManager.connect(),this.config.clockPolicy.networkProfile&&this.networkManager.configureScheduler(this.config.clockPolicy.networkProfile),this.config.clockPolicy.mode==="kernel"&&this._startKernelClock(),this.stateManager.write("status","active"),this.stateManager.write("startedAt",Date.now()),this.isStarted=!0,console.log("[NodeKernel] Node started and connected to P2P network")}catch(t){throw console.error("[NodeKernel] Start failed:",t),t}}async stop(){if(!this.isStarted){console.warn("[NodeKernel] Node not started");return}try{console.log("[NodeKernel] Stopping..."),this._stopKernelClock(),this.stateManager&&this.stateManager.write("status","stopped"),this.networkManager&&await this.networkManager.disconnect(),this.stateManager&&await this.stateManager.destroy(),this.computeManager,this.isStarted=!1,console.log("[NodeKernel] Node stopped")}catch(e){throw console.error("[NodeKernel] Stop failed:",e),e}}setClockPolicy(e={}){const t=this._normalizeClockPolicy(e,this.config.clockPolicy);this.config.clockPolicy=t,this.kernelTickMs=Math.round(1e3/t.tickHz),this.networkManager&&(this.networkManager.setSchedulerClock(t.mode==="kernel"?"external":"internal"),t.networkProfile&&this.networkManager.configureScheduler(t.networkProfile)),this.isStarted&&(t.mode==="kernel"?this._startKernelClock():this._stopKernelClock())}tick(e=Date.now()){var t,r;(r=(t=this.networkManager)==null?void 0:t.tickScheduler)==null||r.call(t,e)}_startKernelClock(){if(this.kernelClockTimer)return;const e=Math.max(10,this.kernelTickMs||33);this.kernelClockTimer=setInterval(()=>{this.tick(Date.now())},e)}_stopKernelClock(){this.kernelClockTimer&&(clearInterval(this.kernelClockTimer),this.kernelClockTimer=null)}_normalizeClockPolicy(e={},t={}){const r=e&&typeof e=="object"?e:{},i=t&&typeof t=="object"?t:{},s=r.mode||i.mode||"independent",o=r.tickHz??i.tickHz??30,a=Number.isFinite(o)&&o>0?o:30,c=r.networkProfile!==void 0?r.networkProfile:i.networkProfile||null;return{mode:s==="kernel"?"kernel":"independent",tickHz:a,networkProfile:c}}async submitTask(e){if(!this.isStarted)throw new Error("Node not started");if(!this.computeManager)throw new Error("ComputeManager not initialized");return this.computeManager.submitTask(e)}getStatus(){var r,i,s,o;const e=((r=this.networkManager)==null?void 0:r.getNetworkStats())||{},t=((i=this.stateManager)==null?void 0:i.getStats())||{};return{nodeId:this.nodeId,isInitialized:this.isInitialized,isStarted:this.isStarted,topology:this.config.topology,clock:{mode:this.config.clockPolicy.mode,tickHz:this.config.clockPolicy.tickHz,schedulerClock:(o=(s=this.networkManager)==null?void 0:s.getSchedulerClock)==null?void 0:o.call(s)},network:{peerId:e.peerId,peerCount:e.peerCount,isConnected:e.isConnected,connections:e.connections},state:{keyCount:t.keyCount,hasPersistence:t.hasPersistence,hasP2PSync:t.hasP2PSync},compute:{enabled:!0,available:!!this.computeManager}}}getStateManager(){return this.stateManager}getNetworkManager(){return this.networkManager}getComputeManager(){return this.computeManager}getGPUHub(){return this.gpuHub}_handleNetworkMessage(e,t){var r,i,s;switch(console.log(`[NodeKernel] Message from ${e}:`,t.type),t.type){case"state-request":this._handleStateRequest(e,t.data);break;case"yjs-update":this.stateManager&&this.stateManager.applyRemoteUpdate(t.data);break;case"state-set":this.stateManager&&this.stateManager.applyStateSet((r=t.data)==null?void 0:r.key,(i=t.data)==null?void 0:i.value,(s=t.data)==null?void 0:s.namespace);break;case"compute-task":this._handleComputeTask(e,t.data);break;case"ping":this._handlePing(e,t.data);break;default:console.warn(`[NodeKernel] Unknown message type: ${t.type}`)}}_handlePeerConnect(e){console.log(`[NodeKernel] Peer connected: ${e}`);const t=this.stateManager.read("connectedPeers")||[];t.includes(e)||(t.push(e),this.stateManager.write("connectedPeers",t))}_handlePeerDisconnect(e){console.log(`[NodeKernel] Peer disconnected: ${e}`);const r=(this.stateManager.read("connectedPeers")||[]).filter(i=>i!==e);this.stateManager.write("connectedPeers",r)}async _handleStateRequest(e,t){const r=this.stateManager.snapshot();await this.networkManager.sendToPeer(e,{type:"state-response",data:r})}async _handleComputeTask(e,t){console.log(`[NodeKernel] Compute task from ${e}: TODO`)}async _handlePing(e,t){await this.networkManager.sendToPeer(e,{type:"pong",data:{timestamp:Date.now(),originalTimestamp:t.timestamp}})}}class xM{constructor(e){this.element=e,this.knob=e.querySelector(".joystick-knob"),this.touchId=null,this.deltaX=0,this.deltaY=0,this.maxDistance=40,this.isActive=!1,this.startX=0,this.startY=0,document.addEventListener("touchstart",this.onTouchStart.bind(this),{passive:!1}),document.addEventListener("touchmove",this.onTouchMove.bind(this),{passive:!1}),document.addEventListener("touchend",this.onTouchEnd.bind(this),{passive:!1}),document.addEventListener("touchcancel",this.onTouchEnd.bind(this),{passive:!1})}onTouchStart(e){if(this.touchId===null)for(let t of e.changedTouches){const r=this.element.getBoundingClientRect(),i=t.clientX-r.left,s=t.clientY-r.top;if(i>=0&&i<=r.width&&s>=0&&s<=r.height){e.preventDefault(),this.touchId=t.identifier,this.isActive=!0,this.startX=i,this.startY=s,this.updatePosition(t);break}}}onTouchMove(e){if(this.touchId!==null){for(let t of e.touches)if(t.identifier===this.touchId){e.preventDefault(),this.updatePosition(t);break}}}onTouchEnd(e){for(let t of e.changedTouches)if(t.identifier===this.touchId){e.preventDefault(),this.touchId=null,this.isActive=!1,this.deltaX=0,this.deltaY=0,this.knob.style.left="50%",this.knob.style.top="50%";break}}updatePosition(e){const t=this.element.getBoundingClientRect(),r=t.width/2,i=t.height/2,s=e.clientX-t.left,o=e.clientY-t.top;let a=s-this.startX,c=o-this.startY;if(Math.sqrt(a*a+c*c)>this.maxDistance){const u=Math.atan2(c,a);a=Math.cos(u)*this.maxDistance,c=Math.sin(u)*this.maxDistance}this.deltaX=a/this.maxDistance,this.deltaY=c/this.maxDistance,this.knob.style.left=`${r+a}px`,this.knob.style.top=`${i+c}px`}getValues(){return{x:this.isActive?this.deltaX:0,y:this.isActive?this.deltaY:0}}}const Kt=1,ar=20,TM=1,Mye=10,AM=.2,MM=.05,Cye=.95,hb=.02,eo=1,Iye=1.5,PU=500,db=5,Ho=5;let Cu=0,wt=new q(0,Kt/2,0),Dr=0,Gr=new q(0,0,0),em=!0,Wc=null,CM=!1;const It={w:!1,a:!1,s:!1,d:!1,arrowup:!1,arrowdown:!1,arrowleft:!1,arrowright:!1,space:!1},oy={pressed:!1};let H_,G_;const W_="ontouchstart"in window&&window.matchMedia("(max-width: 768px)").matches;let br=null,lc=`Player-${Math.floor(Math.random()*999)}`,uc=65280,$r=new Map,so=new Map;const q_=new Map,Fd="sneakywoods";let Lo=null,Li=null,fb=[];const Pye=(...n)=>console.log("[sneakywoods]",...n);let Yh=null,vl=null,pb=null,Nr={name:"global",visibility:"public",roomId:"global"},mh=null,yg=null,zd=new Map,Zh=null;try{const n=localStorage.getItem("sneakywoodsPlayerName");n&&(lc=n);const e=localStorage.getItem("sneakywoodsPlayerColor");e&&(uc=parseInt(e.replace("#","0x"),16))}catch{}const Dye=async()=>{const n=async e=>{try{const t=await fetch(e,{cache:"no-store"});if(t.ok)return await t.json()}catch{}return null};return await n("./relay-config.json")||await n("./.relay-config.json")||await n("/relay-config.json")||await n("/.relay-config.json")||{bootstrapPeers:[]}},Rye=n=>Array.isArray(n)?n.filter(Boolean):[],Lye="__rooms__",DU="rooms",RU="room-",LU=1e4,OU=45e3,Vd=n=>String(n||"").trim().toLowerCase().replace(/[^a-z0-9]+/g,"-").replace(/^-+|-+$/g,"")||"global",Oye=n=>{const e=String(n||"");let t=2166136261;for(let r=0;r<e.length;r+=1)t^=e.charCodeAt(r),t=Math.imul(t,16777619);return(t>>>0).toString(16)},K_=({name:n,visibility:e,password:t})=>{const r=Vd(n);return e==="private"?`priv-${r}-${Oye(t)}`:r},Iu=n=>{const e=document.getElementById("roomStatus");e&&(e.textContent=n)},Nye=()=>{const n=Date.now();for(const[e,t]of zd.entries())(!t||!t.updatedAt||n-t.updatedAt>OU)&&zd.delete(e)};async function Uye(n){mh||(mh=new IU({bootstrapPeers:n,enablePersistence:!1,gameId:"sneakywoods",roomId:Lye}),await mh.initialize(),await mh.start(),yg=mh.getStateManager(),yg.observeNamespace(DU,(e,t)=>{if(!(!t||!t.startsWith(RU))){if(!e){zd.delete(t);return}zd.set(t,e)}}),setInterval(Nye,LU))}const IM=()=>{if(!yg||!Nr)return;const n=Vd(Nr.name),e={name:Nr.name,slug:n,visibility:Nr.visibility,updatedAt:Date.now(),roomId:Nr.visibility==="public"?Nr.roomId:null};yg.writeScoped(DU,`${RU}${n}`,e)},Bye=()=>{IM(),!Zh&&(Zh=setInterval(IM,LU))},kye=()=>{Zh&&(clearInterval(Zh),Zh=null)},NU=()=>{const n=document.getElementById("roomListItems");if(!n)return;n.innerHTML="";const e=Array.from(zd.values()).filter(t=>t&&(!t.updatedAt||Date.now()-t.updatedAt<=OU)).sort((t,r)=>(r.updatedAt||0)-(t.updatedAt||0));if(!e.length){const t=document.createElement("p");t.textContent="No rooms announced yet.",n.appendChild(t);return}e.forEach(t=>{const r=document.createElement("div");r.className="room-entry";const i=document.createElement("h4");i.textContent=t.name||t.slug||"Unnamed room";const s=document.createElement("p");s.textContent=t.visibility==="private"?"Private room":"Public room";const o=document.createElement("button");o.textContent=t.visibility==="private"?"Join (password)":"Join",o.addEventListener("click",async()=>{const a=t.name||t.slug||"global",c=t.visibility==="private"?"private":"public";let l="";if(c==="private"){const g=document.getElementById("roomPassword");if(l=(g==null?void 0:g.value)||"",l||(l=window.prompt("Password for this room?")||""),!l){Iu("Password required for private rooms.");return}}const u=c==="private"?K_({name:Vd(a),visibility:c,password:l}):t.roomId||K_({name:Vd(a),visibility:c});await GU({name:a,visibility:c,roomId:u});const d=document.getElementById("room-list");d&&(d.style.display="none");const f=document.getElementById("roomName"),p=document.getElementById("roomPrivacy");f&&(f.value=a),p&&(p.value=c),localStorage.setItem("sneakywoodsRoomName",a),localStorage.setItem("sneakywoodsRoomPrivacy",c)}),r.appendChild(i),r.appendChild(s),r.appendChild(o),n.appendChild(r)})},Cn=new c5;Cn.background=new rt(1118481);const _l=new Lr(75,window.innerWidth/window.innerHeight,.1,1e3);_l.position.set(0,Kt*1.6,0);const li=new lP({antialias:!0});li.setSize(window.innerWidth,window.innerHeight);li.shadowMap.enabled=!0;li.shadowMap.type=LI;li.gammaOutput=!0;li.gammaFactor=2.2;li.physicallyCorrectLights=!0;document.body.appendChild(li.domElement);const $ye=new p5(1118481,.2);Cn.add($ye);const tr=new fP(16777215,25,75,Math.PI/6,.3,1);tr.position.set(0,8,0);tr.castShadow=!0;tr.shadow.mapSize.width=1024;tr.shadow.mapSize.height=1024;tr.shadow.camera.near=.5;tr.shadow.camera.far=100;tr.shadow.bias=-1e-4;tr.visible=!1;Cn.add(tr);const jh=new sn;Cn.add(jh);tr.target=jh;const Fye=new ao(Kt,Kt,Kt),zye=new rd({color:65280,emissive:13056,shininess:30,specular:16777215}),ia=new dr(Fye,zye);ia.castShadow=!0;ia.receiveShadow=!0;ay(ia,uc);Cn.add(ia);const UU=new ao(eo,eo,eo),BU=new eE({color:16711680,transparent:!0,opacity:.8,wireframe:!0});Cn.fog=new rE(0,.01);const PM=new Map,kU=new Map;function ay(n,e){!n||!n.material||(n.material.color.setHex(e),n.material.emissive.setHex(e),n.material.emissiveIntensity=.25)}function Vye(n){return function(){n|=0,n=n+1831565813|0;let e=Math.imul(n^n>>>15,1|n);return e=e+Math.imul(e^e>>>7,61|e)^e,((e^e>>>14)>>>0)/4294967296}}const Hye=1337,Gye=(n,e)=>Vye((Hye^n*73856093^e*19349663)>>>0);function Wye(n){const e=document.createElement("canvas"),t=e.getContext("2d"),r=28,i=10;t.font=`${r}px Arial`;const s=t.measureText(n);e.width=s.width+i*2,e.height=r+i*2,t.font=`${r}px Arial`,t.fillStyle="white",t.textBaseline="middle",t.textAlign="center",t.fillText(n,e.width/2,e.height/2);const o=new h5(e);o.needsUpdate=!0;const a=new uP({map:o,transparent:!0,depthWrite:!1}),c=new u5(a),l=.012;return c.scale.set(e.width*l,e.height*l,1),c.userData={text:n},c}function qye(n,e){const t=e||Math.random;if((t()>.9?"building":"tree")==="tree"){const i=n*2,s=n/2,o=new sE(s,i,8),a=new rd({color:2263842,shininess:5,specular:3355443}),c=new dr(o,a);return c.position.y=i/2,{mesh:c,type:"tree"}}else{const i=n*2,s=n*(2+t()*3),o=n*2,a=new ao(i,s,o),c=[8421504,11119017,9127187,13808780,6908265],l=c[Math.floor(t()*c.length)],u=new rd({color:l,shininess:30,specular:5592405}),d=new dr(a,u);return d.position.y=s/2,{mesh:d,type:"building"}}}function Kye(n,e,t){const r=t||Math.random,i=TM+r()*(Mye-TM),{mesh:s,type:o}=qye(i,r);s.position.x=n,s.position.z=e,o==="tree"&&(s.rotation.y=r()*Math.PI*2),s.castShadow=!0,s.receiveShadow=!0,Cn.add(s);const a=new Fi().setFromObject(s);return kU.set(s.id,{mesh:s,boundingBox:a,type:o}),s}function $U(n,e){const t=Gye(n,e),r=`${n},${e}`;if(PM.has(r))return;PM.set(r,!0);const i=new Tg(ar,ar),s=new rd({color:16777215,side:ns,shininess:10,reflectivity:.5}),o=new dr(i,s);o.rotation.x=Math.PI/2,o.position.set(n*ar+ar/2,0,e*ar+ar/2),o.receiveShadow=!0,Cn.add(o);const a=Math.floor(t()*2)+1;for(let c=0;c<a;c++)Kye(n*ar+t()*ar,e*ar+t()*ar,t)}function Xye(){for(let n=-Ho;n<=Ho;n++)for(let e=-Ho;e<=Ho;e++)$U(n,e)}function rx(){const n=Math.floor(wt.x/ar),e=Math.floor(wt.z/ar);for(let t=n-Ho;t<=n+Ho;t++)for(let r=e-Ho;r<=e+Ho;r++)$U(t,r)}function ix(n){const e=new Fi().setFromCenterAndSize(n,new q(Kt,Kt,Kt));for(const[t,r]of kU.entries())if(r.type==="building"&&e.intersectsBox(r.boundingBox))return!0;return!1}function FU(){const n=[...Array.from($r.values()).map(a=>a.position)];wt&&n.push(wt.clone());const e=n.length?n[Math.floor(Math.random()*n.length)]:null,t=Math.random()*Math.PI*2,r=3*ar,i=e?e.clone():new q(0,Kt/2,0);i.x+=Math.cos(t)*r,i.z+=Math.sin(t)*r,i.y=Kt/2;let s=0;const o=20;for(;ix(i)&&s<o;){const a=t+Math.PI/4*s;i.x=(e?e.x:0)+Math.cos(a)*r,i.z=(e?e.z:0)+Math.sin(a)*r,s++}return i}function Yye(){const n=FU();wt.copy(n),rx()}function sx(){if(!em)return;const n=new q(0,0,-1).applyAxisAngle(new q(0,1,0),Dr).normalize(),e=new q().copy(wt).add(n.multiplyScalar(Iye));Wc=new dr(UU,BU),Wc.position.copy(e),Wc.rotation.y=Dr,Cn.add(Wc),tr.visible=!0,em=!1,o0e(e),Zye(e)&&console.log("You hit someone! Score increased to",Cu),setTimeout(()=>{Cn.remove(Wc),Wc=null,em=!0,!It.w&&!It.a&&!It.s&&!It.d&&!It.arrowleft&&!It.arrowright&&!It.space&&!oy.pressed&&(tr.visible=!1)},PU)}function Zye(n){const e=new Fi().setFromCenterAndSize(n,new q(eo,eo,eo));let t=!1;for(const[r,i]of $r.entries()){const s=new Fi().setFromCenterAndSize(i.position,new q(Kt,Kt,Kt));if(e.intersectsBox(s)){t=!0,Cu++,yc(),oa();const o=so.get(r);if(o){const l=o.material.color.clone();o.material.color.set(16711680),setTimeout(()=>{o.material.color.copy(l)},500)}const a=Math.random()*Math.PI*2,c=3*ar;i.position.set(Math.cos(a)*c,Kt/2,Math.sin(a)*c),o&&o.position.copy(i.position)}}return t}function yc(){document.getElementById("score").textContent=`Score: ${Cu}`;const e=[{name:lc,score:Cu},...Array.from($r.entries()).map(([r,i])=>({name:i.name||r,score:i.score||0}))].reduce((r,i)=>i.score>((r==null?void 0:r.score)??-1/0)?i:r,null);document.getElementById("highscore").textContent=e?`High Score: ${e.score} (${e.name})`:"High Score: 0",document.getElementById("position").textContent=`Position: ${wt.x.toFixed(1)}, ${wt.y.toFixed(1)}, ${wt.z.toFixed(1)}`;const t=[lc,...Array.from($r.values()).map(r=>r.name)].filter(Boolean);document.getElementById("players").textContent=`Players: ${$r.size+1} | Speed: ${Gr.length().toFixed(2)} | ${t.join(", ")}`}document.addEventListener("keydown",n=>{const e=n.key.toLowerCase();e in It&&(It[e]=!0)});document.addEventListener("keyup",n=>{const e=n.key.toLowerCase();e in It&&(It[e]=!1)});document.addEventListener("mousemove",n=>{document.pointerLockElement===li.domElement&&(Dr-=n.movementX*.002)});document.addEventListener("mousedown",n=>{n.button===0&&(oy.pressed=!0,sx())});document.addEventListener("mouseup",n=>{n.button===0&&(oy.pressed=!1)});document.addEventListener("keydown",n=>{n.code==="Space"&&em&&sx()});li.domElement.addEventListener("click",()=>{li.domElement.requestPointerLock()});const jye=document.getElementById("attack-button");jye.addEventListener("touchstart",function(n){n.preventDefault(),sx()});const DM=document.getElementById("settings-button"),Jh=document.getElementById("settings-menu"),RM=document.getElementById("settings-close"),Ga=document.getElementById("nameInput"),LM=document.getElementById("nameBtn"),bg=document.getElementById("colorPicker"),Qh=document.getElementById("roomName"),ed=document.getElementById("roomPrivacy"),mb=document.getElementById("roomPassword"),OM=document.getElementById("roomCreate"),NM=document.getElementById("roomJoin"),UM=document.getElementById("roomListOpen"),wg=document.getElementById("room-list"),BM=document.getElementById("roomListClose"),kM=document.getElementById("roomListRefresh");DM&&Jh&&DM.addEventListener("click",()=>{const n=Jh.style.display!=="none";Jh.style.display=n?"none":"block",!n&&document.pointerLockElement&&document.exitPointerLock()});RM&&Jh&&RM.addEventListener("click",()=>{Jh.style.display="none"});Ga&&(Ga.value=lc);if(bg){const n=`#${Math.floor(uc).toString(16).padStart(6,"0")}`;bg.value=n,ay(ia,uc)}function zU(){var e;const n=(e=Ga==null?void 0:Ga.value)==null?void 0:e.trim();if(n){lc=n;try{localStorage.setItem("sneakywoodsPlayerName",lc)}catch{}oa(),yc()}}LM&&LM.addEventListener("click",zU);Ga&&Ga.addEventListener("keydown",n=>{n.key==="Enter"&&zU()});bg&&bg.addEventListener("input",n=>{const e=n.target.value||"#00ff00";uc=parseInt(e.replace("#","0x"),16),ay(ia,uc);try{localStorage.setItem("sneakywoodsPlayerColor",e)}catch{}oa()});const Jye=localStorage.getItem("sneakywoodsRoomName")||Nr.name,Qye=localStorage.getItem("sneakywoodsRoomPrivacy")||Nr.visibility;Qh&&(Qh.value=Jye);ed&&(ed.value=Qye);Iu(`Current room: ${Nr.name} (${Nr.visibility})`);const VU=async()=>{var s;const n=((s=Qh==null?void 0:Qh.value)==null?void 0:s.trim())||"global",e=(ed==null?void 0:ed.value)||"public",t=(mb==null?void 0:mb.value)||"";if(e==="private"&&!t){Iu("Password required for private rooms.");return}const r=Vd(n),i=K_({name:r,visibility:e,password:t});Iu("Switching rooms..."),await GU({name:n,visibility:e,roomId:i});try{localStorage.setItem("sneakywoodsRoomName",n),localStorage.setItem("sneakywoodsRoomPrivacy",e)}catch{}};OM&&OM.addEventListener("click",()=>{VU()});NM&&NM.addEventListener("click",()=>{VU()});UM&&wg&&UM.addEventListener("click",()=>{wg.style.display="block",NU()});BM&&wg&&BM.addEventListener("click",()=>{wg.style.display="none"});kM&&kM.addEventListener("click",()=>{NU()});document.addEventListener("visibilitychange",()=>{document.hidden?i0e():(qU(),oa())});function X_(){if(document.hidden){requestAnimationFrame(X_);return}let n=new q(0,0,0);if(W_&&H_){const i=H_.getValues();(Math.abs(i.x)>.1||Math.abs(i.y)>.1)&&(n.z+=i.y,n.x+=i.x)}else(It.w||It.arrowup)&&(n.z-=1),(It.s||It.arrowdown)&&(n.z+=1),It.a&&(n.x-=1),It.d&&(n.x+=1);n.length()>0&&(n.normalize(),n.applyAxisAngle(new q(0,1,0),Dr),Gr.x+=n.x*MM,Gr.z+=n.z*MM),Gr.multiplyScalar(Cye);const e=Gr.length();if(e>AM&&Gr.normalize().multiplyScalar(AM),e<.001&&Gr.set(0,0,0),W_&&G_){const i=G_.getValues();Math.abs(i.x)>.1&&(Dr-=i.x*hb*2)}else It.arrowleft&&(Dr+=hb),It.arrowright&&(Dr-=hb);if(Gr.length()>0){const i=new q(wt.x+Gr.x,wt.y,wt.z+Gr.z);ix(i)?Gr.multiplyScalar(-.5):wt.copy(i)}ia.position.copy(wt),ia.rotation.y=Dr,tr.position.copy(wt),tr.position.y+=8;const t=new q(0,0,-20);t.applyAxisAngle(new q(0,1,0),Dr),jh.position.copy(wt).add(t),jh.position.y=0,jh.updateMatrixWorld(),tr.target.updateMatrixWorld();const r=new q(Math.sin(Dr)*db,db*.6,Math.cos(Dr)*db);_l.position.copy(wt).add(r),_l.lookAt(wt),rx(),CM=It.w||It.a||It.s||It.d||It.arrowleft||It.arrowright||It.space||oy.pressed||Gr.length()>.01,tr.visible=CM,yc();for(const[i,s]of so.entries()){const o=$r.get(i);if(o){const a=o.renderPosition||o.position.clone();a.lerp(o.position,.12),s.position.copy(a),o.renderPosition=a;const c=o.rotation,l=o.renderRotation||c,u=(c-l+Math.PI)%(Math.PI*2)-Math.PI,d=l+u*.15;s.rotation.y=d,o.renderRotation=d}}li.render(Cn,_l),requestAnimationFrame(X_)}window.addEventListener("resize",()=>{_l.aspect=window.innerWidth/window.innerHeight,_l.updateProjectionMatrix(),li.setSize(window.innerWidth,window.innerHeight),document.getElementById("left-joystick")&&(document.getElementById("left-joystick").style.left="calc(25% - 60px)"),document.getElementById("right-joystick")&&(document.getElementById("right-joystick").style.right="calc(25% - 60px)")});function e0e(n,e){const t=FU();$r.set(n,{position:t,rotation:Math.random()*Math.PI*2,score:0,name:`Peer-${n.slice(0,4)}`,lastSeen:Date.now(),lastPos:t.clone(),lastRot:0,attackFlashUntil:0,renderPosition:t.clone(),renderRotation:0});const r=new ao(Kt,Kt,Kt),i=new rd({color:e||255,emissive:51,shininess:30,specular:16777215}),s=new dr(r,i);s.position.copy(t),s.castShadow=!0,s.receiveShadow=!0;const o=new sn;Cn.add(o);const a=new fP(16777215,6,60,Math.PI/6,.35,1);a.position.set(0,3,0),a.castShadow=!0,a.shadow.mapSize.width=512,a.shadow.mapSize.height=512,a.shadow.bias=-5e-4,a.target=o,s.add(a),s.userData.spot=a,s.userData.spotTarget=o,a.visible=!1,Cn.add(s),so.set(n,s),yc()}function ox(n){var t;const e=so.get(n);e&&((t=e.userData)!=null&&t.spotTarget&&Cn.remove(e.userData.spotTarget),Cn.remove(e),so.delete(n)),$r.delete(n),yc()}function t0e(){for(const n of Array.from(so.keys()))ox(n);so.clear(),$r.clear()}async function HU(n=Nr.roomId){try{const e=await Dye();fb=Rye(e.bootstrapPeers||[]),Lo=new IU({bootstrapPeers:fb,enablePersistence:!1,gameId:"sneakywoods",roomId:n||"global"}),await Lo.initialize(),await Lo.start(),Li=Lo.getStateManager(),br=Lo.getStatus().network.peerId,Pye(`Connected as ${br}`),Li.observeNamespace(Fd,(t,r)=>{if(r.startsWith("player-")){const i=r.replace("player-","");if(i===br)return;a0e(i,t);return}if(r.startsWith("attack-")){const i=r.replace("attack-","");KU(i,t);return}}),vl&&clearInterval(vl),vl=setInterval(()=>{const t=Date.now();for(const[r,i]of $r.entries())t-(i.lastSeen||0)>1e4&&ox(r)},5e3),oa(),WU(),pb||(pb=()=>{Li&&br&&Li.deleteScoped(Fd,`player-${br}`)},window.addEventListener("beforeunload",pb)),await Uye(fb),Bye()}catch(e){console.error("P2P setup error:",e)}}async function n0e(){if(kye(),qU(),vl&&(clearInterval(vl),vl=null),Li&&br&&Li.deleteScoped(Fd,`player-${br}`),Lo)try{await Lo.stop()}catch(n){console.warn("P2P shutdown error:",n)}Lo=null,Li=null,br=null,t0e(),q_.clear()}async function GU({name:n,visibility:e,roomId:t}){!t||t===Nr.roomId||(Iu("Switching rooms..."),await n0e(),Nr={name:n,visibility:e,roomId:t},await HU(t),Iu(`Current room: ${n} (${e})`))}const r0e=250;let $M=0;function oa(){if(!Li||!br)return;const n={name:lc,position:{x:wt.x,y:wt.y,z:wt.z},rotation:Dr,ts:Date.now(),color:uc,score:Cu};Li.writeScoped(Fd,`player-${br}`,n)}function WU(){const n=performance.now();n-$M>=r0e&&($M=n,oa()),requestAnimationFrame(WU)}function i0e(){Yh||(Yh=setInterval(()=>{oa()},1e3))}function qU(){Yh&&(clearInterval(Yh),Yh=null)}function s0e(){console.log("YOU WERE HIT");const n=document.createElement("div");n.style.position="fixed",n.style.top="0",n.style.left="0",n.style.width="100%",n.style.height="100%",n.style.backgroundColor="rgba(255,0,0,0.35)",n.style.pointerEvents="none",n.style.zIndex="1000",document.body.appendChild(n),setTimeout(()=>n.remove(),300);const e=Math.random()*Math.PI*2,t=3*ar;wt.x=Math.cos(e)*t,wt.z=Math.sin(e)*t,wt.y=Kt/2;let r=0;const i=20;for(;ix(wt)&&r<i;){const s=e+Math.PI/4*r;wt.x=Math.cos(s)*t,wt.z=Math.sin(s)*t,r++}rx(),Cu=0,oa(),yc()}function o0e(n){if(!Li||!br)return;const e={position:{x:n.x,y:n.y,z:n.z},rotation:Dr,ts:Date.now()};Li.writeScoped(Fd,`attack-${br}`,e),KU(br,e)}function KU(n,e){var c,l;if(!e)return;const t=q_.get(n);if(t&&t===e.ts)return;q_.set(n,e.ts);const r=new q(e.position.x,e.position.y,e.position.z),i=new dr(UU,BU.clone());i.position.copy(r),i.rotation.y=e.rotation||0,Cn.add(i),setTimeout(()=>Cn.remove(i),PU);const s=so.get(n),o=new q(0,0,-1).applyAxisAngle(new q(0,1,0),e.rotation||0);if((c=s==null?void 0:s.userData)!=null&&c.spotTarget){const u=o.clone().multiplyScalar(15);s.userData.spotTarget.position.copy(r).add(u)}(l=s==null?void 0:s.userData)!=null&&l.spot&&(s.userData.spot.visible=!0);const a=$r.get(n);if(a&&(a.attackFlashUntil=performance.now()+800),n!==br){const u=new Fi().setFromCenterAndSize(r,new q(eo,eo,eo)),d=new Fi().setFromCenterAndSize(wt,new q(Kt,Kt,Kt));u.intersectsBox(d)&&s0e()}}function a0e(n,e){if(!e){ox(n);return}$r.has(n)||e0e(n,e.color);const t=$r.get(n),r=t.lastPos||t.position.clone(),i=t.lastRot||0;t.position.set(e.position.x,e.position.y,e.position.z),t.rotation=e.rotation||0,t.name=e.name,t.lastSeen=Date.now(),t.lastPos=t.position.clone(),t.lastRot=t.rotation,t.score=e.score||0,t.renderPosition||(t.renderPosition=t.position.clone()),t.renderPosition.distanceTo(t.position)>20&&t.renderPosition.copy(t.position);const s=so.get(n);if(s){s.position.copy(t.position),s.rotation.y=t.rotation,e.color&&ay(s,e.color);const o=s.userData.spot,a=s.userData.spotTarget;if(o&&a){const c=r.distanceTo(t.position)>.02,l=Math.abs(i-t.rotation)>.05,u=performance.now(),d=c||l||(t.attackFlashUntil||0)>u,f=new q(0,0,-15).applyAxisAngle(new q(0,1,0),t.renderRotation||t.rotation);a.position.copy(t.renderPosition||t.position).add(f),a.position.y=0,o.visible=d}c0e(s,t.name||n)}yc()}function c0e(n,e){var i,s;if(!n||((s=(i=n.userData.nameLabel)==null?void 0:i.userData)==null?void 0:s.text)===e)return;n.userData.nameLabel&&n.remove(n.userData.nameLabel);const r=Wye(e);r.userData={text:e},r.position.set(0,Kt*.9,0),n.add(r),n.userData.nameLabel=r}if(W_){H_=new xM(document.getElementById("left-joystick")),G_=new xM(document.getElementById("right-joystick"));const n=document.getElementById("attack-button");n&&(n.style.display="block")}Xye();Yye();HU();X_();
