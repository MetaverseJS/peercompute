import { serviceCapabilities, serviceDependencies } from '@libp2p/interface';
import { PeerMap, PeerSet } from '@libp2p/peer-collections';
import { TypedEventEmitter } from 'main-event';
import Queue from 'p-queue';
import { SimpleTimeCache } from './cache.js';
import { pubSubSymbol } from './constants.ts';
import { PeerStreams } from './peer-streams.js';
import { StrictNoSign, StrictSign } from './index.js';
import type { FloodSubComponents, FloodSubEvents, FloodSubInit, FloodSub as FloodSubInterface, Message, PublishResult, TopicValidatorFn } from './index.js';
import type { Logger, Connection, PeerId, Stream } from '@libp2p/interface';
export interface PubSubRPCMessage {
    from?: Uint8Array;
    topic?: string;
    data?: Uint8Array;
    sequenceNumber?: Uint8Array;
    signature?: Uint8Array;
    key?: Uint8Array;
}
export interface PubSubRPCSubscription {
    subscribe?: boolean;
    topic?: string;
}
export interface PubSubRPC {
    subscriptions: PubSubRPCSubscription[];
    messages: PubSubRPCMessage[];
}
/**
 * PubSubBaseProtocol handles the peers and connections logic for pubsub routers
 * and specifies the API that pubsub routers should have.
 */
export declare class FloodSub extends TypedEventEmitter<FloodSubEvents> implements FloodSubInterface {
    protected log: Logger;
    started: boolean;
    /**
     * Map of topics to which peers are subscribed to
     */
    topics: Map<string, PeerSet>;
    /**
     * List of our subscriptions
     */
    subscriptions: Set<string>;
    /**
     * Map of peer streams
     */
    peers: PeerMap<PeerStreams>;
    /**
     * The signature policy to follow by default
     */
    globalSignaturePolicy: typeof StrictNoSign | typeof StrictSign;
    /**
     * If router can relay received messages, even if not subscribed
     */
    canRelayMessage: boolean;
    /**
     * if publish should emit to self, if subscribed
     */
    emitSelf: boolean;
    /**
     * Topic validator map
     *
     * Keyed by topic
     * Topic validators are functions with the following input:
     */
    topicValidators: Map<string, TopicValidatorFn>;
    queue: Queue;
    protocol: string;
    components: FloodSubComponents;
    private _registrarTopologyId;
    private readonly maxInboundStreams;
    private readonly maxOutboundStreams;
    seenCache: SimpleTimeCache<boolean>;
    constructor(components: FloodSubComponents, init: FloodSubInit);
    readonly [pubSubSymbol] = true;
    readonly [Symbol.toStringTag] = "@libp2p/floodsub";
    readonly [serviceCapabilities]: string[];
    readonly [serviceDependencies]: string[];
    /**
     * Register the pubsub protocol onto the libp2p node.
     */
    start(): Promise<void>;
    /**
     * Unregister the pubsub protocol and the streams with other peers will be closed.
     */
    stop(): Promise<void>;
    isStarted(): boolean;
    /**
     * On an inbound stream opened
     */
    protected _onIncomingStream(stream: Stream, connection: Connection): void;
    /**
     * Registrar notifies an established connection with pubsub protocol
     */
    protected _onPeerConnected(peerId: PeerId, conn: Connection): Promise<void>;
    /**
     * Registrar notifies a closing connection with pubsub protocol
     */
    protected _onPeerDisconnected(peerId: PeerId, conn?: Connection): void;
    /**
     * Notifies the router that a peer has been connected
     */
    addPeer(peerId: PeerId, stream: Stream): PeerStreams;
    /**
     * Notifies the router that a peer has been disconnected
     */
    protected _removePeer(peerId: PeerId): void;
    /**
     * Handles an rpc request from a peer
     */
    processRpc(peerStream: PeerStreams, rpc: PubSubRPC): Promise<boolean>;
    /**
     * Handles a subscription change from a peer
     */
    processRpcSubOpt(id: PeerId, subOpt: PubSubRPCSubscription): void;
    /**
     * Handles a message from a peer
     */
    processMessage(from: PeerId, msg: Message): Promise<void>;
    /**
     * The default msgID implementation
     * Child class can override this.
     */
    getMsgId(msg: Message): Promise<Uint8Array> | Uint8Array;
    /**
     * Encode RPC object into a Uint8Array.
     * This can be override to use a custom router protobuf.
     */
    encodeMessage(rpc: PubSubRPCMessage): Uint8Array;
    /**
     * Send an rpc object to a peer
     */
    send(peer: PeerId, data: {
        messages?: Message[];
        subscriptions?: string[];
        subscribe?: boolean;
    }): void;
    /**
     * Send an rpc object to a peer
     */
    sendRpc(peer: PeerId, rpc: PubSubRPC): void;
    /**
     * Validates the given message. The signature will be checked for authenticity.
     * Throws an error on invalid messages
     */
    validate(from: PeerId, message: Message): Promise<void>;
    /**
     * Normalizes the message and signs it, if signing is enabled.
     * Should be used by the routers to create the message to send.
     */
    buildMessage(message: {
        from: PeerId;
        topic: string;
        data: Uint8Array;
        sequenceNumber: bigint;
    }): Promise<Message>;
    /**
     * Get a list of the peer-ids that are subscribed to one topic.
     */
    getSubscribers(topic: string): PeerId[];
    /**
     * Publishes messages to all subscribed peers
     */
    publish(topic: string, data?: Uint8Array): Promise<PublishResult>;
    /**
     * Overriding the implementation of publish should handle the appropriate algorithms for the publish/subscriber implementation.
     * For example, a Floodsub implementation might simply publish each message to each topic for every peer.
     *
     * `sender` might be this peer, or we might be forwarding a message on behalf of another peer, in which case sender
     * is the peer we received the message from, which may not be the peer the message was created by.
     */
    publishMessage(from: PeerId, message: Message): Promise<PublishResult>;
    /**
     * Subscribes to a given topic.
     */
    subscribe(topic: string): void;
    /**
     * Unsubscribe from the given topic
     */
    unsubscribe(topic: string): void;
    /**
     * Get the list of topics which the peer is subscribed to.
     */
    getTopics(): string[];
    getPeers(): PeerId[];
}
//# sourceMappingURL=floodsub.d.ts.map