/**
 * @packageDocumentation
 *
 * > Don't use this module
 *
 * This module is a naive implementation of pubsub. It broadcasts all messages to all network peers, cannot provide older messages and has no protection against bad actors.
 *
 * It exists for academic purposes only, you should not use it in production.
 *
 * Instead please use [gossipsub](https://www.npmjs.com/package/@chainsafe/libp2p-gossipsub) - a more complete implementation which is also compatible with floodsub.
 *
 * @example Configuring libp2p to use floodsub
 *
 * ```TypeScript
 * import { createLibp2p } from 'libp2p'
 * import { floodsub } from '@libp2p/floodsub'
 *
 * const node = await createLibp2p({
 *   services: {
 *     pubsub: floodsub()
 *   }
 *   //... other options
 * })
 * await node.start()
 *
 * node.services.pubsub.subscribe('fruit')
 * node.services.pubsub.addEventListener('message', (evt) => {
 *   console.log(evt)
 * })
 *
 * node.services.pubsub.publish('fruit', new TextEncoder().encode('banana'))
 * ```
 */
import { pubSubSymbol } from "./constants.js";
import { FloodSub as FloodSubClass } from './floodsub.js';
export const protocol = '/floodsub/1.0.0';
/**
 * On the producing side:
 * - Build messages with the signature, key (from may be enough for certain inlineable public key types), from and seqno fields.
 *
 * On the consuming side:
 * - Enforce the fields to be present, reject otherwise.
 * - Propagate only if the fields are valid and signature can be verified, reject otherwise.
 */
export const StrictSign = 'StrictSign';
/**
 * On the producing side:
 * - Build messages without the signature, key, from and seqno fields.
 * - The corresponding protobuf key-value pairs are absent from the marshaled message, not just empty.
 *
 * On the consuming side:
 * - Enforce the fields to be absent, reject otherwise.
 * - Propagate only if the fields are absent, reject otherwise.
 * - A message_id function will not be able to use the above fields, and should instead rely on the data field. A commonplace strategy is to calculate a hash.
 */
export const StrictNoSign = 'StrictNoSign';
export var TopicValidatorResult;
(function (TopicValidatorResult) {
    /**
     * The message is considered valid, and it should be delivered and forwarded to the network
     */
    TopicValidatorResult["Accept"] = "accept";
    /**
     * The message is neither delivered nor forwarded to the network
     */
    TopicValidatorResult["Ignore"] = "ignore";
    /**
     * The message is considered invalid, and it should be rejected
     */
    TopicValidatorResult["Reject"] = "reject";
})(TopicValidatorResult || (TopicValidatorResult = {}));
export { pubSubSymbol };
/**
 * Returns true if the passed argument is a PubSub implementation
 */
export function isPubSub(obj) {
    return Boolean(obj?.[pubSubSymbol]);
}
export function floodsub(init = {}) {
    return (components) => new FloodSubClass(components, init);
}
//# sourceMappingURL=index.js.map