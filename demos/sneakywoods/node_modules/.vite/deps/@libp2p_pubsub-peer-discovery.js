import {
  multiaddr
} from "./chunk-SAZZGDH5.js";
import {
  peerIdFromPublicKey
} from "./chunk-RA2DG4WK.js";
import {
  MaxLengthError,
  TypedEventEmitter,
  decodeMessage,
  encodeMessage,
  message,
  peerDiscoverySymbol,
  publicKeyFromProtobuf,
  publicKeyToProtobuf
} from "./chunk-HXWYJQY6.js";
import {
  alloc
} from "./chunk-PS3LPXH2.js";
import {
  __publicField
} from "./chunk-WOOG5QLI.js";

// ../../node_modules/@libp2p/pubsub-peer-discovery/dist/src/peer.js
var Peer;
(function(Peer2) {
  let _codec;
  Peer2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.publicKey != null && obj.publicKey.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (obj.addrs != null) {
          for (const value of obj.addrs) {
            w.uint32(18);
            w.bytes(value);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        var _a2;
        const obj = {
          publicKey: alloc(0),
          addrs: []
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 2: {
              if (((_a2 = opts.limits) == null ? void 0 : _a2.addrs) != null && obj.addrs.length === opts.limits.addrs) {
                throw new MaxLengthError('Decode error - map field "addrs" had too many elements');
              }
              obj.addrs.push(reader.bytes());
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Peer2.encode = (obj) => {
    return encodeMessage(obj, Peer2.codec());
  };
  Peer2.decode = (buf, opts) => {
    return decodeMessage(buf, Peer2.codec(), opts);
  };
})(Peer || (Peer = {}));

// ../../node_modules/@libp2p/pubsub-peer-discovery/dist/src/index.js
var TOPIC = "_peer-discovery._p2p._pubsub";
var _a, _b, _c;
var PubSubPeerDiscovery = class extends (_c = TypedEventEmitter, _b = peerDiscoverySymbol, _a = Symbol.toStringTag, _c) {
  constructor(components, init = {}) {
    super();
    __publicField(this, _b, true);
    __publicField(this, _a, "@libp2p/pubsub-peer-discovery");
    __publicField(this, "interval");
    __publicField(this, "listenOnly");
    __publicField(this, "topics");
    __publicField(this, "intervalId");
    __publicField(this, "components");
    __publicField(this, "log");
    const { interval, topics, listenOnly } = init;
    this.components = components;
    this.interval = interval ?? 1e4;
    this.listenOnly = listenOnly ?? false;
    this.log = components.logger.forComponent("libp2p:discovery:pubsub");
    if (Array.isArray(topics) && topics.length > 0) {
      this.topics = topics;
    } else {
      this.topics = [TOPIC];
    }
    this._onMessage = this._onMessage.bind(this);
  }
  isStarted() {
    return this.intervalId != null;
  }
  start() {
  }
  /**
   * Subscribes to the discovery topic on `libp2p.pubsub` and performs a broadcast
   * immediately, and every `this.interval`
   */
  afterStart() {
    if (this.intervalId != null) {
      return;
    }
    const pubsub = this.components.pubsub;
    if (pubsub == null) {
      throw new Error("PubSub not configured");
    }
    for (const topic of this.topics) {
      pubsub.subscribe(topic);
      pubsub.addEventListener("message", this._onMessage);
    }
    if (this.listenOnly) {
      return;
    }
    this._broadcast();
    this.intervalId = setInterval(() => {
      this._broadcast();
    }, this.interval);
  }
  beforeStop() {
    const pubsub = this.components.pubsub;
    if (pubsub == null) {
      throw new Error("PubSub not configured");
    }
    for (const topic of this.topics) {
      pubsub.unsubscribe(topic);
      pubsub.removeEventListener("message", this._onMessage);
    }
  }
  /**
   * Unsubscribes from the discovery topic
   */
  stop() {
    if (this.intervalId != null) {
      clearInterval(this.intervalId);
      this.intervalId = void 0;
    }
  }
  /**
   * Performs a broadcast via Pubsub publish
   */
  _broadcast() {
    const peerId = this.components.peerId;
    if (peerId.publicKey == null) {
      throw new Error("PeerId was missing public key");
    }
    const peer = {
      publicKey: publicKeyToProtobuf(peerId.publicKey),
      addrs: this.components.addressManager.getAddresses().map((ma) => ma.bytes)
    };
    const encodedPeer = Peer.encode(peer);
    const pubsub = this.components.pubsub;
    if (pubsub == null) {
      throw new Error("PubSub not configured");
    }
    for (const topic of this.topics) {
      if (pubsub.getSubscribers(topic).length === 0) {
        this.log("skipping broadcasting our peer data on topic %s because there are no peers present", topic);
        continue;
      }
      this.log("broadcasting our peer data on topic %s", topic);
      void pubsub.publish(topic, encodedPeer);
    }
  }
  /**
   * Handles incoming pubsub messages for our discovery topic
   */
  _onMessage(event) {
    if (!this.isStarted()) {
      return;
    }
    const message2 = event.detail;
    if (!this.topics.includes(message2.topic)) {
      return;
    }
    try {
      const peer = Peer.decode(message2.data);
      const publicKey = publicKeyFromProtobuf(peer.publicKey);
      const peerId = peerIdFromPublicKey(publicKey);
      if (peerId.equals(this.components.peerId)) {
        return;
      }
      this.log("discovered peer %p on %s", peerId, message2.topic);
      this.safeDispatchEvent("peer", {
        detail: {
          id: peerId,
          multiaddrs: peer.addrs.map((b) => multiaddr(b))
        }
      });
    } catch (err) {
      this.log.error("error handling incoming message", err);
    }
  }
};
function pubsubPeerDiscovery(init = {}) {
  return (components) => new PubSubPeerDiscovery(components, init);
}
export {
  PubSubPeerDiscovery,
  TOPIC,
  pubsubPeerDiscovery
};
//# sourceMappingURL=@libp2p_pubsub-peer-discovery.js.map
