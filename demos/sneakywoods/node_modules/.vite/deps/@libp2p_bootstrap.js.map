{
  "version": 3,
  "sources": ["../../../../../node_modules/@libp2p/bootstrap/src/index.ts"],
  "sourcesContent": ["/**\n * @packageDocumentation\n *\n * The configured bootstrap peers will be discovered after the configured timeout. This will ensure there are some peers in the peer store for the node to use to discover other peers.\n *\n * They will be tagged with a tag with the name `'bootstrap'` tag, the value `50` and it will expire after two minutes which means the nodes connections may be closed if the maximum number of connections is reached.\n *\n * Clients that need constant connections to bootstrap nodes (e.g. browsers) can set the TTL to `Infinity`.\n *\n * @example Configuring a list of bootstrap nodes\n *\n * ```TypeScript\n * import { createLibp2p } from 'libp2p'\n * import { bootstrap } from '@libp2p/bootstrap'\n *\n * const libp2p = await createLibp2p({\n *   peerDiscovery: [\n *     bootstrap({\n *       list: [\n *         // a list of bootstrap peer multiaddrs to connect to on node startup\n *         '/ip4/104.131.131.82/tcp/4001/ipfs/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ',\n *         '/dnsaddr/bootstrap.libp2p.io/ipfs/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN',\n *         '/dnsaddr/bootstrap.libp2p.io/ipfs/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa'\n *       ]\n *     })\n *   ]\n * })\n *\n * libp2p.addEventListener('peer:discovery', (evt) => {\n *   console.log('found peer: ', evt.detail.toString())\n * })\n * ```\n */\n\nimport { peerDiscoverySymbol, serviceCapabilities } from '@libp2p/interface'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { CODE_P2P, multiaddr } from '@multiformats/multiaddr'\nimport { P2P } from '@multiformats/multiaddr-matcher'\nimport { TypedEventEmitter } from 'main-event'\nimport type { ComponentLogger, Logger, PeerDiscovery, PeerDiscoveryEvents, PeerInfo, PeerStore, Startable } from '@libp2p/interface'\nimport type { ConnectionManager } from '@libp2p/interface-internal'\n\nconst DEFAULT_BOOTSTRAP_TAG_NAME = 'bootstrap'\nconst DEFAULT_BOOTSTRAP_TAG_VALUE = 50\nconst DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT = 1000\n\nexport interface BootstrapInit {\n  /**\n   * The list of peer addresses in multi-address format\n   */\n  list: string[]\n\n  /**\n   * How long to wait before discovering bootstrap nodes\n   */\n  timeout?: number\n\n  /**\n   * Tag a bootstrap peer with this name before \"discovering\" it\n   *\n   * @default 'bootstrap'\n   */\n  tagName?: string\n\n  /**\n   * The bootstrap peer tag will have this value\n   *\n   * @default 50\n   */\n  tagValue?: number\n\n  /**\n   * Cause the bootstrap peer tag to be removed after this number of ms\n   */\n  tagTTL?: number\n}\n\nexport interface BootstrapComponents {\n  peerStore: PeerStore\n  logger: ComponentLogger\n  connectionManager: ConnectionManager\n}\n\n/**\n * Emits 'peer' events on a regular interval for each peer in the provided list.\n */\nclass Bootstrap extends TypedEventEmitter<PeerDiscoveryEvents> implements PeerDiscovery, Startable {\n  static tag = 'bootstrap'\n\n  private readonly log: Logger\n  private timer?: ReturnType<typeof setTimeout>\n  private readonly list: PeerInfo[]\n  private readonly timeout: number\n  private readonly components: BootstrapComponents\n  private readonly _init: BootstrapInit\n\n  constructor (components: BootstrapComponents, options: BootstrapInit = { list: [] }) {\n    if (options.list == null || options.list.length === 0) {\n      throw new Error('Bootstrap requires a list of peer addresses')\n    }\n    super()\n\n    this.components = components\n    this.log = components.logger.forComponent('libp2p:bootstrap')\n    this.timeout = options.timeout ?? DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT\n    this.list = options.list\n      .map(str => multiaddr(str))\n      .filter(ma => {\n        if (!P2P.matches(ma)) {\n          this.log.error('invalid multiaddr %a', ma)\n          return false\n        }\n\n        const peerIdStr = ma.getComponents().findLast(c => c.code === CODE_P2P)?.value\n\n        if (peerIdStr == null) {\n          this.log.error('invalid bootstrap multiaddr without peer id')\n          return false\n        }\n\n        return true\n      })\n      .map(ma => {\n        return {\n          id: peerIdFromString(ma.getComponents().findLast(c => c.code === CODE_P2P)?.value ?? ''),\n          multiaddrs: [ma]\n        }\n      })\n\n    this._init = options\n  }\n\n  readonly [peerDiscoverySymbol] = this\n\n  readonly [Symbol.toStringTag] = '@libp2p/bootstrap'\n\n  readonly [serviceCapabilities]: string[] = [\n    '@libp2p/peer-discovery'\n  ]\n\n  isStarted (): boolean {\n    return Boolean(this.timer)\n  }\n\n  /**\n   * Start emitting events\n   */\n  start (): void {\n    if (this.isStarted()) {\n      return\n    }\n\n    this.log('Starting bootstrap node discovery, discovering peers after %s ms', this.timeout)\n    this.timer = setTimeout(() => {\n      void this._discoverBootstrapPeers()\n        .catch(err => {\n          this.log.error('failed to discover bootstrap peers - %e', err)\n        })\n    }, this.timeout)\n  }\n\n  /**\n   * Emit each address in the list as a PeerInfo\n   */\n  async _discoverBootstrapPeers (): Promise<void> {\n    if (this.timer == null) {\n      return\n    }\n\n    for (const peerData of this.list) {\n      await this.components.peerStore.merge(peerData.id, {\n        tags: {\n          [this._init.tagName ?? DEFAULT_BOOTSTRAP_TAG_NAME]: {\n            value: this._init.tagValue ?? DEFAULT_BOOTSTRAP_TAG_VALUE,\n            ttl: this._init.tagTTL\n          }\n        },\n        multiaddrs: peerData.multiaddrs\n      })\n\n      // check we are still running\n      if (this.timer == null) {\n        return\n      }\n\n      this.safeDispatchEvent('peer', { detail: peerData })\n      this.components.connectionManager.openConnection(peerData.id)\n        .catch(err => {\n          this.log.error('could not dial bootstrap peer %p - %e', peerData.id, err)\n        })\n    }\n  }\n\n  /**\n   * Stop emitting events\n   */\n  stop (): void {\n    if (this.timer != null) {\n      clearTimeout(this.timer)\n    }\n\n    this.timer = undefined\n  }\n}\n\nexport function bootstrap (init: BootstrapInit): (components: BootstrapComponents) => PeerDiscovery {\n  return (components: BootstrapComponents) => new Bootstrap(components, init)\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;AA0CA,IAAM,6BAA6B;AACnC,IAAM,8BAA8B;AACpC,IAAM,sCAAsC;AA5C5C;AAsFA,IAAM,YAAN,eAAwB,wBA8CZ,0BAEA,YAAO,aAEP,0BAlDY,IAAsC;EAU5D,YAAa,YAAiC,UAAyB,EAAE,MAAM,CAAA,EAAE,GAAE;AACjF,QAAI,QAAQ,QAAQ,QAAQ,QAAQ,KAAK,WAAW,GAAG;AACrD,YAAM,IAAI,MAAM,6CAA6C;IAC/D;AACA,UAAK;AAXU;AACT;AACS;AACA;AACA;AACA;AAsCR,wBAAC,IAAuB;AAExB,wBAAC,IAAsB;AAEvB,wBAAC,IAAiC;MACzC;;AAnCA,SAAK,aAAa;AAClB,SAAK,MAAM,WAAW,OAAO,aAAa,kBAAkB;AAC5D,SAAK,UAAU,QAAQ,WAAW;AAClC,SAAK,OAAO,QAAQ,KACjB,IAAI,SAAO,UAAU,GAAG,CAAC,EACzB,OAAO,QAAK;AA3GnB,UAAAA;AA4GQ,UAAI,CAAC,IAAI,QAAQ,EAAE,GAAG;AACpB,aAAK,IAAI,MAAM,wBAAwB,EAAE;AACzC,eAAO;MACT;AAEA,YAAM,aAAYA,MAAA,GAAG,cAAa,EAAG,SAAS,OAAK,EAAE,SAAS,QAAQ,MAApD,gBAAAA,IAAuD;AAEzE,UAAI,aAAa,MAAM;AACrB,aAAK,IAAI,MAAM,6CAA6C;AAC5D,eAAO;MACT;AAEA,aAAO;IACT,CAAC,EACA,IAAI,QAAK;AA1HhB,UAAAA;AA2HQ,aAAO;QACL,IAAI,mBAAiBA,MAAA,GAAG,cAAa,EAAG,SAAS,OAAK,EAAE,SAAS,QAAQ,MAApD,gBAAAA,IAAuD,UAAS,EAAE;QACvF,YAAY,CAAC,EAAE;;IAEnB,CAAC;AAEH,SAAK,QAAQ;EACf;EAUA,YAAS;AACP,WAAO,QAAQ,KAAK,KAAK;EAC3B;;;;EAKA,QAAK;AACH,QAAI,KAAK,UAAS,GAAI;AACpB;IACF;AAEA,SAAK,IAAI,oEAAoE,KAAK,OAAO;AACzF,SAAK,QAAQ,WAAW,MAAK;AAC3B,WAAK,KAAK,wBAAuB,EAC9B,MAAM,SAAM;AACX,aAAK,IAAI,MAAM,2CAA2C,GAAG;MAC/D,CAAC;IACL,GAAG,KAAK,OAAO;EACjB;;;;EAKA,MAAM,0BAAuB;AAC3B,QAAI,KAAK,SAAS,MAAM;AACtB;IACF;AAEA,eAAW,YAAY,KAAK,MAAM;AAChC,YAAM,KAAK,WAAW,UAAU,MAAM,SAAS,IAAI;QACjD,MAAM;UACJ,CAAC,KAAK,MAAM,WAAW,0BAA0B,GAAG;YAClD,OAAO,KAAK,MAAM,YAAY;YAC9B,KAAK,KAAK,MAAM;;;QAGpB,YAAY,SAAS;OACtB;AAGD,UAAI,KAAK,SAAS,MAAM;AACtB;MACF;AAEA,WAAK,kBAAkB,QAAQ,EAAE,QAAQ,SAAQ,CAAE;AACnD,WAAK,WAAW,kBAAkB,eAAe,SAAS,EAAE,EACzD,MAAM,SAAM;AACX,aAAK,IAAI,MAAM,yCAAyC,SAAS,IAAI,GAAG;MAC1E,CAAC;IACL;EACF;;;;EAKA,OAAI;AACF,QAAI,KAAK,SAAS,MAAM;AACtB,mBAAa,KAAK,KAAK;IACzB;AAEA,SAAK,QAAQ;EACf;;AAnHA,cADI,WACG,OAAM;AAsHT,SAAU,UAAW,MAAmB;AAC5C,SAAO,CAAC,eAAoC,IAAI,UAAU,YAAY,IAAI;AAC5E;",
  "names": ["_a"]
}
