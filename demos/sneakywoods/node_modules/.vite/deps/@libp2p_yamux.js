import {
  AbstractStream,
  AbstractStreamMuxer,
  repeatingTask
} from "./chunk-WWTG3YU6.js";
import "./chunk-SAZZGDH5.js";
import {
  raceSignal
} from "./chunk-MXJRKQ3V.js";
import {
  InvalidParametersError,
  MuxerClosedError,
  TooManyOutboundProtocolStreamsError,
  Uint8ArrayList,
  serviceCapabilities
} from "./chunk-HXWYJQY6.js";
import "./chunk-PS3LPXH2.js";
import {
  __publicField
} from "./chunk-WOOG5QLI.js";

// ../../node_modules/@libp2p/yamux/dist/src/frame.js
var FrameType;
(function(FrameType2) {
  FrameType2[FrameType2["Data"] = 0] = "Data";
  FrameType2[FrameType2["WindowUpdate"] = 1] = "WindowUpdate";
  FrameType2[FrameType2["Ping"] = 2] = "Ping";
  FrameType2[FrameType2["GoAway"] = 3] = "GoAway";
})(FrameType || (FrameType = {}));
var Flag;
(function(Flag2) {
  Flag2[Flag2["SYN"] = 1] = "SYN";
  Flag2[Flag2["ACK"] = 2] = "ACK";
  Flag2[Flag2["FIN"] = 4] = "FIN";
  Flag2[Flag2["RST"] = 8] = "RST";
})(Flag || (Flag = {}));
var flagCodes = Object.values(Flag).filter((x) => typeof x !== "string");
var YAMUX_VERSION = 0;
var GoAwayCode;
(function(GoAwayCode2) {
  GoAwayCode2[GoAwayCode2["NormalTermination"] = 0] = "NormalTermination";
  GoAwayCode2[GoAwayCode2["ProtocolError"] = 1] = "ProtocolError";
  GoAwayCode2[GoAwayCode2["InternalError"] = 2] = "InternalError";
})(GoAwayCode || (GoAwayCode = {}));
var HEADER_LENGTH = 12;

// ../../node_modules/@libp2p/yamux/dist/src/errors.js
var ProtocolError = class extends Error {
  constructor(message, reason) {
    super(message);
    __publicField(this, "reason");
    this.name = "ProtocolError";
    this.reason = reason;
  }
};
__publicField(ProtocolError, "name", "ProtocolError");
function isProtocolError(err) {
  return (err == null ? void 0 : err.reason) !== null;
}
var InvalidFrameError = class extends ProtocolError {
  constructor(message = "The frame was invalid") {
    super(message, GoAwayCode.ProtocolError);
    this.name = "InvalidFrameError";
  }
};
__publicField(InvalidFrameError, "name", "InvalidFrameError");
var UnRequestedPingError = class extends ProtocolError {
  constructor(message = "Un-requested ping error") {
    super(message, GoAwayCode.ProtocolError);
    this.name = "UnRequestedPingError";
  }
};
__publicField(UnRequestedPingError, "name", "UnRequestedPingError");
var NotMatchingPingError = class extends ProtocolError {
  constructor(message = "Not matching ping error") {
    super(message, GoAwayCode.ProtocolError);
    this.name = "NotMatchingPingError";
  }
};
__publicField(NotMatchingPingError, "name", "NotMatchingPingError");
var StreamAlreadyExistsError = class extends ProtocolError {
  constructor(message = "Stream already exists") {
    super(message, GoAwayCode.ProtocolError);
    this.name = "StreamAlreadyExistsError";
  }
};
__publicField(StreamAlreadyExistsError, "name", "StreamAlreadyExistsError");
var DecodeInvalidVersionError = class extends ProtocolError {
  constructor(message = "Decode invalid version") {
    super(message, GoAwayCode.ProtocolError);
    this.name = "DecodeInvalidVersionError";
  }
};
__publicField(DecodeInvalidVersionError, "name", "DecodeInvalidVersionError");
var BothClientsError = class extends ProtocolError {
  constructor(message = "Both clients") {
    super(message, GoAwayCode.ProtocolError);
    this.name = "BothClientsError";
  }
};
__publicField(BothClientsError, "name", "BothClientsError");
var ReceiveWindowExceededError = class extends ProtocolError {
  constructor(message = "Receive window exceeded") {
    super(message, GoAwayCode.ProtocolError);
    this.name = "ReceiveWindowExceededError";
  }
};
__publicField(ReceiveWindowExceededError, "name", "ReceiveWindowExceededError");

// ../../node_modules/@libp2p/yamux/dist/src/constants.js
var PROTOCOL_ERRORS = /* @__PURE__ */ new Set([
  InvalidFrameError.name,
  UnRequestedPingError.name,
  NotMatchingPingError.name,
  StreamAlreadyExistsError.name,
  DecodeInvalidVersionError.name,
  BothClientsError.name,
  ReceiveWindowExceededError.name
]);
var INITIAL_STREAM_WINDOW = 256 * 1024;
var MAX_STREAM_WINDOW = 16 * 1024 * 1024;

// ../../node_modules/@libp2p/yamux/dist/src/config.js
var defaultConfig = {
  enableKeepAlive: true,
  keepAliveInterval: 3e4,
  maxInboundStreams: 1e3,
  maxOutboundStreams: 1e3,
  maxMessageSize: 64 * 1024,
  maxEarlyStreams: 10,
  streamOptions: {
    initialStreamWindowSize: INITIAL_STREAM_WINDOW,
    maxStreamWindowSize: MAX_STREAM_WINDOW,
    inactivityTimeout: 12e4,
    maxReadBufferLength: 4194304,
    maxWriteBufferLength: Infinity
  }
};
function verifyConfig(config) {
  var _a2, _b2, _c, _d, _e, _f, _g, _h;
  if (config.keepAliveInterval != null && config.keepAliveInterval <= 0) {
    throw new InvalidParametersError("keep-alive interval must be positive");
  }
  if (config.maxInboundStreams != null && config.maxInboundStreams < 0) {
    throw new InvalidParametersError("max inbound streams must be larger or equal 0");
  }
  if (config.maxOutboundStreams != null && config.maxOutboundStreams < 0) {
    throw new InvalidParametersError("max outbound streams must be larger or equal 0");
  }
  if (config.maxMessageSize != null && config.maxMessageSize < 1024) {
    throw new InvalidParametersError("MaxMessageSize must be greater than a kilobyte");
  }
  if (((_a2 = config.streamOptions) == null ? void 0 : _a2.initialStreamWindowSize) != null && ((_b2 = config.streamOptions) == null ? void 0 : _b2.initialStreamWindowSize) < INITIAL_STREAM_WINDOW) {
    throw new InvalidParametersError("InitialStreamWindowSize must be larger or equal 256 kB");
  }
  if (((_c = config.streamOptions) == null ? void 0 : _c.maxStreamWindowSize) != null && ((_d = config.streamOptions) == null ? void 0 : _d.initialStreamWindowSize) != null && ((_e = config.streamOptions) == null ? void 0 : _e.maxStreamWindowSize) < ((_f = config.streamOptions) == null ? void 0 : _f.initialStreamWindowSize)) {
    throw new InvalidParametersError("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");
  }
  if (((_g = config.streamOptions) == null ? void 0 : _g.maxStreamWindowSize) != null && ((_h = config.streamOptions) == null ? void 0 : _h.maxStreamWindowSize) > 2 ** 32 - 1) {
    throw new InvalidParametersError("MaxStreamWindowSize must be less than equal MAX_UINT32");
  }
}

// ../../node_modules/@libp2p/yamux/dist/src/decode.js
function isDataFrame(frame) {
  return frame.header.type === FrameType.Data && frame.data !== null;
}
var twoPow24 = 2 ** 24;
function decodeHeader(data) {
  if (data[0] !== YAMUX_VERSION) {
    throw new InvalidFrameError("Invalid frame version");
  }
  return {
    type: data[1],
    flag: (data[2] << 8) + data[3],
    streamID: data[4] * twoPow24 + (data[5] << 16) + (data[6] << 8) + data[7],
    length: data[8] * twoPow24 + (data[9] << 16) + (data[10] << 8) + data[11]
  };
}
var Decoder = class {
  constructor() {
    /** Buffer for in-progress frames */
    __publicField(this, "buffer");
    this.buffer = new Uint8ArrayList();
  }
  /**
   * Emits frames from the decoder source.
   *
   * Note: If `readData` is emitted, it _must_ be called before the next iteration
   * Otherwise an error is thrown
   */
  *emitFrames(buf) {
    this.buffer.append(buf);
    while (true) {
      const frame = this.readFrame();
      if (frame === void 0) {
        break;
      }
      yield frame;
    }
  }
  readFrame() {
    let frameSize = HEADER_LENGTH;
    if (this.buffer.byteLength < HEADER_LENGTH) {
      return;
    }
    const header = decodeHeader(this.buffer.subarray(0, HEADER_LENGTH));
    if (header.type === FrameType.Data) {
      frameSize += header.length;
      if (this.buffer.byteLength < frameSize) {
        return;
      }
      const data = this.buffer.sublist(HEADER_LENGTH, frameSize);
      this.buffer.consume(frameSize);
      return { header, data };
    }
    this.buffer.consume(frameSize);
    return { header };
  }
};

// ../../node_modules/@libp2p/yamux/dist/src/encode.js
function encodeHeader(header) {
  const frame = new Uint8Array(HEADER_LENGTH);
  frame[1] = header.type;
  frame[2] = header.flag >>> 8;
  frame[3] = header.flag;
  frame[4] = header.streamID >>> 24;
  frame[5] = header.streamID >>> 16;
  frame[6] = header.streamID >>> 8;
  frame[7] = header.streamID;
  frame[8] = header.length >>> 24;
  frame[9] = header.length >>> 16;
  frame[10] = header.length >>> 8;
  frame[11] = header.length;
  return frame;
}

// ../../node_modules/@libp2p/yamux/dist/src/stream.js
var StreamState;
(function(StreamState2) {
  StreamState2[StreamState2["Init"] = 0] = "Init";
  StreamState2[StreamState2["SYNSent"] = 1] = "SYNSent";
  StreamState2[StreamState2["SYNReceived"] = 2] = "SYNReceived";
  StreamState2[StreamState2["Established"] = 3] = "Established";
  StreamState2[StreamState2["Finished"] = 4] = "Finished";
  StreamState2[StreamState2["Paused"] = 5] = "Paused";
})(StreamState || (StreamState = {}));
var YamuxStream = class extends AbstractStream {
  constructor(init) {
    const initialWindowSize = init.initialStreamWindowSize ?? INITIAL_STREAM_WINDOW;
    super({
      ...init,
      maxMessageSize: initialWindowSize - HEADER_LENGTH
    });
    __publicField(this, "streamId");
    __publicField(this, "state");
    /** The number of available bytes to send */
    __publicField(this, "sendWindowCapacity");
    /** The number of bytes available to receive in a full window */
    __publicField(this, "recvWindow");
    /** The number of available bytes to receive */
    __publicField(this, "recvWindowCapacity");
    __publicField(this, "maxStreamWindowSize");
    /**
     * An 'epoch' is the time it takes to process and read data
     *
     * Used in conjunction with RTT to determine whether to increase the recvWindow
     */
    __publicField(this, "epochStart");
    __publicField(this, "getRTT");
    __publicField(this, "sendFrame");
    this.streamId = init.streamId;
    this.state = init.state;
    this.sendWindowCapacity = initialWindowSize;
    this.recvWindow = initialWindowSize;
    this.recvWindowCapacity = this.recvWindow;
    this.maxStreamWindowSize = init.maxStreamWindowSize ?? MAX_STREAM_WINDOW;
    this.epochStart = Date.now();
    this.getRTT = init.getRTT;
    this.sendFrame = init.sendFrame;
    const setStateToFinishedOnCloseListener = () => {
      this.state = StreamState.Finished;
    };
    this.addEventListener("close", setStateToFinishedOnCloseListener);
  }
  /**
   * Send a data message to the remote muxer
   */
  sendData(buf) {
    var _a2, _b2;
    const totalBytes = buf.byteLength;
    let sentBytes = 0;
    let canSendMore = true;
    (_a2 = this.log) == null ? void 0 : _a2.trace("send window capacity is %d bytes", this.sendWindowCapacity);
    while (buf.byteLength > 0) {
      if (this.sendWindowCapacity === 0) {
        canSendMore = false;
        (_b2 = this.log) == null ? void 0 : _b2.trace("sent %d/%d bytes, exhausted send window, waiting for window update", sentBytes, totalBytes);
        break;
      }
      const toSend = Math.min(this.sendWindowCapacity, buf.byteLength);
      const flags = this.getSendFlags();
      const data = buf.sublist(0, toSend);
      buf.consume(toSend);
      const muxerSendMore = this.sendFrame({
        type: FrameType.Data,
        flag: flags,
        streamID: this.streamId,
        length: toSend
      }, data);
      this.sendWindowCapacity -= toSend;
      sentBytes += toSend;
      if (!muxerSendMore) {
        canSendMore = muxerSendMore;
        this.log.trace("sent %d/%d bytes, wait for muxer to have more send capacity", sentBytes, totalBytes);
        break;
      }
    }
    return {
      sentBytes,
      canSendMore
    };
  }
  /**
   * Send a reset message to the remote muxer
   */
  async sendReset() {
    this.sendFrame({
      type: FrameType.WindowUpdate,
      flag: Flag.RST,
      streamID: this.streamId,
      length: 0
    });
  }
  /**
   * Send a message to the remote muxer, informing them no more data messages
   * will be sent by this end of the stream
   */
  async sendCloseWrite() {
    const flags = this.getSendFlags() | Flag.FIN;
    this.sendFrame({
      type: FrameType.WindowUpdate,
      flag: flags,
      streamID: this.streamId,
      length: 0
    });
  }
  /**
   * Send a message to the remote muxer, informing them no more data messages
   * will be read by this end of the stream - this is a no-op on Yamux streams
   */
  async sendCloseRead(options) {
    var _a2;
    (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
  }
  /**
   * Stop sending window updates temporarily - in the interim the the remote
   * send window will exhaust and the remote will stop sending data
   */
  sendPause() {
    this.state = StreamState.Paused;
  }
  /**
   * Start sending window updates as normal
   */
  sendResume() {
    this.state = StreamState.Established;
    this.sendWindowUpdate();
  }
  /**
   * handleWindowUpdate is called when the stream receives a window update frame
   */
  handleWindowUpdate(frame) {
    var _a2;
    this.processFlags(frame.header.flag);
    this.sendWindowCapacity += frame.header.length;
    this.maxMessageSize = this.sendWindowCapacity - HEADER_LENGTH;
    if (this.maxMessageSize < 0) {
      this.maxMessageSize = 0;
    }
    if (this.maxMessageSize === 0) {
      return;
    }
    if (this.writeBuffer.byteLength > 0) {
      (_a2 = this.log) == null ? void 0 : _a2.trace("window update of %d bytes allows more data to be sent, have %d bytes queued, sending data %s", frame.header.length, this.writeBuffer.byteLength, this.sendingData);
      this.safeDispatchEvent("drain");
    }
  }
  /**
   * handleData is called when the stream receives a data frame
   */
  handleData(frame) {
    if (!isDataFrame(frame)) {
      throw new InvalidFrameError("Frame was not data frame");
    }
    this.processFlags(frame.header.flag);
    if (this.recvWindowCapacity < frame.header.length) {
      throw new ReceiveWindowExceededError("Receive window exceeded");
    }
    this.recvWindowCapacity -= frame.header.length;
    this.onData(frame.data);
    this.sendWindowUpdate();
  }
  /**
   * processFlags is used to update the state of the stream based on set flags, if any.
   */
  processFlags(flags) {
    if ((flags & Flag.ACK) === Flag.ACK) {
      if (this.state === StreamState.SYNSent) {
        this.state = StreamState.Established;
      }
    }
    if ((flags & Flag.FIN) === Flag.FIN) {
      this.onRemoteCloseWrite();
    }
    if ((flags & Flag.RST) === Flag.RST) {
      this.onRemoteReset();
    }
  }
  /**
   * getSendFlags determines any flags that are appropriate
   * based on the current stream state.
   *
   * The state is updated as a side-effect.
   */
  getSendFlags() {
    switch (this.state) {
      case StreamState.Init:
        this.state = StreamState.SYNSent;
        return Flag.SYN;
      case StreamState.SYNReceived:
        this.state = StreamState.Established;
        return Flag.ACK;
      default:
        return 0;
    }
  }
  /**
   * Potentially sends a window update enabling further remote writes to take
   * place.
   */
  sendWindowUpdate() {
    if (this.state === StreamState.Paused) {
      this.epochStart = Date.now();
      return;
    }
    const flags = this.getSendFlags();
    const now = Date.now();
    const rtt = this.getRTT();
    if (flags === 0 && rtt > -1 && now - this.epochStart <= rtt * 4) {
      this.recvWindow = Math.min(this.recvWindow * 2, this.maxStreamWindowSize);
    }
    if (this.recvWindowCapacity >= this.recvWindow && flags === 0) {
      return;
    }
    const delta = this.recvWindow - this.recvWindowCapacity;
    this.recvWindowCapacity = this.recvWindow;
    this.epochStart = now;
    this.sendFrame({
      type: FrameType.WindowUpdate,
      flag: flags,
      streamID: this.streamId,
      length: delta
    });
  }
};

// ../../node_modules/@libp2p/yamux/dist/src/muxer.js
function debugFrame(header) {
  return {
    type: FrameType[header.type],
    flags: [
      (header.flag & Flag.SYN) === Flag.SYN ? "SYN" : void 0,
      (header.flag & Flag.ACK) === Flag.ACK ? "ACK" : void 0,
      (header.flag & Flag.FIN) === Flag.FIN ? "FIN" : void 0,
      (header.flag & Flag.RST) === Flag.RST ? "RST" : void 0
    ].filter(Boolean),
    streamID: header.streamID,
    length: header.length
  };
}
var YAMUX_PROTOCOL_ID = "/yamux/1.0.0";
var _a, _b;
_b = Symbol.toStringTag, _a = serviceCapabilities;
var Yamux = class {
  constructor(init = {}) {
    __publicField(this, "protocol", YAMUX_PROTOCOL_ID);
    __publicField(this, "_init");
    __publicField(this, _b, "@libp2p/yamux");
    __publicField(this, _a, [
      "@libp2p/stream-multiplexing"
    ]);
    this._init = init;
  }
  createStreamMuxer(maConn) {
    return new YamuxMuxer(maConn, {
      ...this._init
    });
  }
};
var YamuxMuxer = class extends AbstractStreamMuxer {
  constructor(maConn, init = {}) {
    super(maConn, {
      ...init,
      protocol: YAMUX_PROTOCOL_ID,
      name: "yamux"
    });
    /** The next stream id to be used when initiating a new stream */
    __publicField(this, "nextStreamID");
    /** The next ping id to be used when pinging */
    __publicField(this, "nextPingID");
    /** Tracking info for the currently active ping */
    __publicField(this, "activePing");
    /** Round trip time */
    __publicField(this, "rtt");
    /** True if client, false if server */
    __publicField(this, "client");
    __publicField(this, "localGoAway");
    __publicField(this, "remoteGoAway");
    /** Number of tracked inbound streams */
    __publicField(this, "numInboundStreams");
    /** Number of tracked outbound streams */
    __publicField(this, "numOutboundStreams");
    __publicField(this, "decoder");
    __publicField(this, "keepAlive");
    __publicField(this, "enableKeepAlive");
    __publicField(this, "keepAliveInterval");
    __publicField(this, "maxInboundStreams");
    __publicField(this, "maxOutboundStreams");
    this.client = maConn.direction === "outbound";
    verifyConfig(init);
    this.enableKeepAlive = init.enableKeepAlive ?? defaultConfig.enableKeepAlive;
    this.keepAliveInterval = init.keepAliveInterval ?? defaultConfig.keepAliveInterval;
    this.maxInboundStreams = init.maxInboundStreams ?? defaultConfig.maxInboundStreams;
    this.maxOutboundStreams = init.maxOutboundStreams ?? defaultConfig.maxOutboundStreams;
    this.decoder = new Decoder();
    this.numInboundStreams = 0;
    this.numOutboundStreams = 0;
    this.nextStreamID = this.client ? 1 : 2;
    this.nextPingID = 0;
    this.rtt = -1;
    this.log.trace("muxer created");
    if (this.enableKeepAlive) {
      this.log.trace("muxer keepalive enabled interval=%s", this.keepAliveInterval);
      this.keepAlive = repeatingTask(async (options) => {
        try {
          await this.ping(options);
        } catch (err) {
          this.log.error("ping error: %s", err);
        }
      }, this.keepAliveInterval, {
        // send an initial ping to establish RTT
        runImmediately: true
      });
      this.keepAlive.start();
    }
  }
  onData(buf) {
    for (const frame of this.decoder.emitFrames(buf)) {
      this.handleFrame(frame);
    }
  }
  onCreateStream() {
    if (this.remoteGoAway !== void 0) {
      throw new MuxerClosedError("Muxer closed remotely");
    }
    if (this.localGoAway !== void 0) {
      throw new MuxerClosedError("Muxer closed locally");
    }
    const id = this.nextStreamID;
    this.nextStreamID += 2;
    if (this.numOutboundStreams >= this.maxOutboundStreams) {
      throw new TooManyOutboundProtocolStreamsError("max outbound streams exceeded");
    }
    this.log.trace("new outgoing stream id=%s", id);
    const stream = this._newStream(id, StreamState.Init, "outbound");
    this.numOutboundStreams++;
    queueMicrotask(() => {
      stream.sendWindowUpdate();
    });
    return stream;
  }
  /**
   * Initiate a ping and wait for a response
   *
   * Note: only a single ping will be initiated at a time.
   * If a ping is already in progress, a new ping will not be initiated.
   *
   * @returns the round-trip-time in milliseconds
   */
  async ping(options) {
    if (this.remoteGoAway !== void 0) {
      throw new MuxerClosedError("Muxer closed remotely");
    }
    if (this.localGoAway !== void 0) {
      throw new MuxerClosedError("Muxer closed locally");
    }
    if (this.activePing != null) {
      return raceSignal(this.activePing.promise, options == null ? void 0 : options.signal);
    }
    this.activePing = Object.assign(Promise.withResolvers(), {
      id: this.nextPingID++,
      start: Date.now()
    });
    this.sendPing(this.activePing.id);
    try {
      this.rtt = await raceSignal(this.activePing.promise, options == null ? void 0 : options.signal);
    } finally {
      this.activePing = void 0;
    }
    return this.rtt;
  }
  /**
   * Get the ping round trip time
   *
   * Note: Will return 0 if no successful ping has yet been completed
   *
   * @returns the round-trip-time in milliseconds
   */
  getRTT() {
    return this.rtt;
  }
  /**
   * Close the muxer
   */
  async close(options = {}) {
    var _a2;
    if (this.status !== "open") {
      return;
    }
    try {
      const reason = (options == null ? void 0 : options.reason) ?? GoAwayCode.NormalTermination;
      this.log.trace("muxer close reason=%s", GoAwayCode[reason]);
      await super.close(options);
      this.sendGoAway(reason);
    } finally {
      (_a2 = this.keepAlive) == null ? void 0 : _a2.stop();
    }
  }
  abort(err) {
    var _a2;
    if (this.status !== "open") {
      return;
    }
    try {
      super.abort(err);
      let reason = GoAwayCode.InternalError;
      if (isProtocolError(err)) {
        reason = err.reason;
      }
      this.log.error("muxer abort reason=%s error=%s", reason, err);
      this.sendGoAway(reason);
    } finally {
      (_a2 = this.keepAlive) == null ? void 0 : _a2.stop();
    }
  }
  onTransportClosed() {
    var _a2;
    try {
      super.onTransportClosed();
    } finally {
      (_a2 = this.keepAlive) == null ? void 0 : _a2.stop();
    }
  }
  /** Create a new stream */
  _newStream(streamId, state, direction) {
    if (this.streams.find((s) => s.streamId === streamId) != null) {
      throw new InvalidParametersError("Stream already exists with that id");
    }
    const stream = new YamuxStream({
      ...this.streamOptions,
      id: `${streamId}`,
      streamId,
      state,
      direction,
      sendFrame: this.sendFrame.bind(this),
      log: this.log.newScope(`${direction}:${streamId}`),
      getRTT: this.getRTT.bind(this)
    });
    stream.addEventListener("close", () => {
      this.closeStream(streamId);
    }, {
      once: true
    });
    return stream;
  }
  /**
   * closeStream is used to close a stream once both sides have
   * issued a close.
   */
  closeStream(id) {
    if (this.client === (id % 2 === 0)) {
      this.numInboundStreams--;
    } else {
      this.numOutboundStreams--;
    }
  }
  handleFrame(frame) {
    const { streamID, type, length } = frame.header;
    this.log.trace("received frame %o", debugFrame(frame.header));
    if (streamID === 0) {
      switch (type) {
        case FrameType.Ping: {
          this.handlePing(frame.header);
          return;
        }
        case FrameType.GoAway: {
          this.handleGoAway(length);
          return;
        }
        default:
          throw new InvalidFrameError("Invalid frame type");
      }
    } else {
      switch (frame.header.type) {
        case FrameType.Data:
        case FrameType.WindowUpdate: {
          this.handleStreamMessage(frame);
          return;
        }
        default:
          throw new InvalidFrameError("Invalid frame type");
      }
    }
  }
  handlePing(header) {
    if (header.flag === Flag.SYN) {
      this.log.trace("received ping request pingId=%s", header.length);
      this.sendPing(header.length, Flag.ACK);
    } else if (header.flag === Flag.ACK) {
      this.log.trace("received ping response pingId=%s", header.length);
      this.handlePingResponse(header.length);
    } else {
      throw new InvalidFrameError("Invalid frame flag");
    }
  }
  handlePingResponse(pingId) {
    if (this.activePing === void 0) {
      throw new UnRequestedPingError("ping not requested");
    }
    if (this.activePing.id !== pingId) {
      throw new NotMatchingPingError("ping doesn't match our id");
    }
    this.activePing.resolve(Date.now() - this.activePing.start);
  }
  handleGoAway(reason) {
    this.log.trace("received GoAway reason=%s", GoAwayCode[reason] ?? "unknown");
    this.remoteGoAway = reason;
    if (reason === GoAwayCode.NormalTermination) {
      this.onTransportClosed();
    } else {
      this.abort(new Error("Remote sent GoAway"));
    }
  }
  handleStreamMessage(frame) {
    const { streamID, flag, type } = frame.header;
    if ((flag & Flag.SYN) === Flag.SYN) {
      this.incomingStream(streamID);
    }
    const stream = this.streams.find((s) => s.streamId === streamID);
    if (stream === void 0) {
      this.log.trace("frame for missing stream id=%s", streamID);
      return;
    }
    switch (type) {
      case FrameType.WindowUpdate: {
        stream.handleWindowUpdate(frame);
        return;
      }
      case FrameType.Data: {
        stream.handleData(frame);
        return;
      }
      default:
        throw new Error("unreachable");
    }
  }
  incomingStream(id) {
    if (this.client !== (id % 2 === 0)) {
      throw new InvalidParametersError("Both endpoints are clients");
    }
    if (this.streams.find((s) => s.streamId === id)) {
      return;
    }
    this.log.trace("new incoming stream id=%s", id);
    if (this.localGoAway !== void 0) {
      this.sendFrame({
        type: FrameType.WindowUpdate,
        flag: Flag.RST,
        streamID: id,
        length: 0
      });
      return;
    }
    if (this.numInboundStreams >= this.maxInboundStreams) {
      this.log("maxIncomingStreams exceeded, forcing stream reset");
      this.sendFrame({
        type: FrameType.WindowUpdate,
        flag: Flag.RST,
        streamID: id,
        length: 0
      });
      return;
    }
    const stream = this._newStream(id, StreamState.SYNReceived, "inbound");
    this.numInboundStreams++;
    this.onRemoteStream(stream);
  }
  sendFrame(header, data) {
    let encoded;
    if (header.type === FrameType.Data) {
      if (data == null) {
        throw new InvalidFrameError("Invalid frame");
      }
      encoded = new Uint8ArrayList(encodeHeader(header), data);
    } else {
      encoded = encodeHeader(header);
    }
    this.log.trace("sending frame %o", debugFrame(header));
    return this.send(encoded);
  }
  sendPing(pingId, flag = Flag.SYN) {
    if (flag === Flag.SYN) {
      this.log.trace("sending ping request pingId=%s", pingId);
    } else {
      this.log.trace("sending ping response pingId=%s", pingId);
    }
    this.sendFrame({
      type: FrameType.Ping,
      flag,
      streamID: 0,
      length: pingId
    });
  }
  sendGoAway(reason = GoAwayCode.NormalTermination) {
    this.log("sending GoAway reason=%s", GoAwayCode[reason]);
    this.localGoAway = reason;
    this.sendFrame({
      type: FrameType.GoAway,
      flag: 0,
      streamID: 0,
      length: reason
    });
  }
};

// ../../node_modules/@libp2p/yamux/dist/src/index.js
function yamux(init = {}) {
  return () => new Yamux(init);
}
export {
  GoAwayCode,
  yamux
};
//# sourceMappingURL=@libp2p_yamux.js.map
