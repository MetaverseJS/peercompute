import {
  pbStream
} from "./chunk-FAMYN5K7.js";
import "./chunk-MXJRKQ3V.js";
import "./chunk-SAZZGDH5.js";
import {
  peerIdFromPublicKey
} from "./chunk-RA2DG4WK.js";
import {
  InvalidCryptoExchangeError,
  ProtocolError,
  UnexpectedPeerError,
  decodeMessage,
  encodeMessage,
  enumeration,
  message,
  publicKeyFromRaw,
  serviceCapabilities
} from "./chunk-HXWYJQY6.js";
import {
  alloc,
  equals
} from "./chunk-PS3LPXH2.js";
import {
  __publicField
} from "./chunk-WOOG5QLI.js";

// ../../node_modules/@libp2p/plaintext/dist/src/pb/proto.js
var Exchange;
(function(Exchange2) {
  let _codec;
  Exchange2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.id != null) {
          w.uint32(10);
          w.bytes(obj.id);
        }
        if (obj.pubkey != null) {
          w.uint32(18);
          PublicKey.codec().encode(obj.pubkey, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        var _a2;
        const obj = {};
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.id = reader.bytes();
              break;
            }
            case 2: {
              obj.pubkey = PublicKey.codec().decode(reader, reader.uint32(), {
                limits: (_a2 = opts.limits) == null ? void 0 : _a2.pubkey
              });
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Exchange2.encode = (obj) => {
    return encodeMessage(obj, Exchange2.codec());
  };
  Exchange2.decode = (buf, opts) => {
    return decodeMessage(buf, Exchange2.codec(), opts);
  };
})(Exchange || (Exchange = {}));
var KeyType;
(function(KeyType2) {
  KeyType2["RSA"] = "RSA";
  KeyType2["Ed25519"] = "Ed25519";
  KeyType2["secp256k1"] = "secp256k1";
  KeyType2["ECDSA"] = "ECDSA";
})(KeyType || (KeyType = {}));
var __KeyTypeValues;
(function(__KeyTypeValues2) {
  __KeyTypeValues2[__KeyTypeValues2["RSA"] = 0] = "RSA";
  __KeyTypeValues2[__KeyTypeValues2["Ed25519"] = 1] = "Ed25519";
  __KeyTypeValues2[__KeyTypeValues2["secp256k1"] = 2] = "secp256k1";
  __KeyTypeValues2[__KeyTypeValues2["ECDSA"] = 3] = "ECDSA";
})(__KeyTypeValues || (__KeyTypeValues = {}));
(function(KeyType2) {
  KeyType2.codec = () => {
    return enumeration(__KeyTypeValues);
  };
})(KeyType || (KeyType = {}));
var PublicKey;
(function(PublicKey2) {
  let _codec;
  PublicKey2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.Type != null) {
          w.uint32(8);
          KeyType.codec().encode(obj.Type, w);
        }
        if (obj.Data != null && obj.Data.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        const obj = {
          Data: alloc(0)
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.Type = KeyType.codec().decode(reader);
              break;
            }
            case 2: {
              obj.Data = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PublicKey2.encode = (obj) => {
    return encodeMessage(obj, PublicKey2.codec());
  };
  PublicKey2.decode = (buf, opts) => {
    return decodeMessage(buf, PublicKey2.codec(), opts);
  };
})(PublicKey || (PublicKey = {}));

// ../../node_modules/@libp2p/plaintext/dist/src/index.js
var PROTOCOL = "/plaintext/2.0.0";
var _a, _b;
_b = Symbol.toStringTag, _a = serviceCapabilities;
var Plaintext = class {
  constructor(components) {
    __publicField(this, "protocol", PROTOCOL);
    __publicField(this, "privateKey");
    __publicField(this, "log");
    __publicField(this, _b, "@libp2p/plaintext");
    __publicField(this, _a, [
      "@libp2p/connection-encryption"
    ]);
    this.privateKey = components.privateKey;
    this.log = components.logger.forComponent("libp2p:plaintext");
  }
  async secureInbound(connection, options) {
    return this._encrypt(connection, options);
  }
  async secureOutbound(connection, options) {
    return this._encrypt(connection, options);
  }
  /**
   * Encrypt connection
   */
  async _encrypt(connection, options) {
    var _a2;
    const log = ((_a2 = connection.log) == null ? void 0 : _a2.newScope("plaintext")) ?? this.log;
    const pb = pbStream(connection).pb(Exchange);
    log("write pubkey exchange to peer %p", options == null ? void 0 : options.remotePeer);
    const publicKey = this.privateKey.publicKey;
    await pb.write({
      id: publicKey.toMultihash().bytes,
      pubkey: {
        Type: KeyType[publicKey.type],
        Data: publicKey.raw
      }
    }, options);
    const response = await pb.read(options);
    let peerId;
    try {
      if (response.pubkey == null) {
        throw new ProtocolError("Public key missing");
      }
      if (response.pubkey.Data.byteLength === 0) {
        throw new ProtocolError("Public key data too short");
      }
      if (response.id == null) {
        throw new ProtocolError("Remote id missing");
      }
      const pubKey = publicKeyFromRaw(response.pubkey.Data);
      peerId = peerIdFromPublicKey(pubKey);
      if (!equals(peerId.toMultihash().bytes, response.id)) {
        throw new InvalidCryptoExchangeError("Public key did not match id");
      }
    } catch (err) {
      log.error("invalid public key - %e", err);
      throw new InvalidCryptoExchangeError(`Invalid public key - ${err.message}`);
    }
    if ((options == null ? void 0 : options.remotePeer) != null && !peerId.equals(options == null ? void 0 : options.remotePeer)) {
      throw new UnexpectedPeerError();
    }
    log("plaintext key exchange completed successfully with peer %p", peerId);
    return {
      connection: pb.unwrap().unwrap(),
      remotePeer: peerId
    };
  }
};
function plaintext() {
  return (components) => new Plaintext(components);
}
export {
  plaintext
};
//# sourceMappingURL=@libp2p_plaintext.js.map
