{
  "version": 3,
  "sources": ["../../../../../node_modules/@libp2p/identify/src/consts.ts", "../../../../../node_modules/@libp2p/identify/src/pb/message.ts", "../../../../../node_modules/@libp2p/identify/src/utils.ts", "../../../../../node_modules/@libp2p/identify/src/identify-push.ts", "../../../../../node_modules/@libp2p/identify/src/identify.ts", "../../../../../node_modules/@libp2p/identify/src/index.ts"],
  "sourcesContent": ["export const PROTOCOL_VERSION = 'ipfs/0.1.0' // deprecated\nexport const MULTICODEC_IDENTIFY = '/ipfs/id/1.0.0' // deprecated\nexport const MULTICODEC_IDENTIFY_PUSH = '/ipfs/id/push/1.0.0' // deprecated\n\nexport const IDENTIFY_PROTOCOL_VERSION = '0.1.0'\nexport const MULTICODEC_IDENTIFY_PROTOCOL_NAME = 'id'\nexport const MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = 'id/push'\nexport const MULTICODEC_IDENTIFY_PROTOCOL_VERSION = '1.0.0'\nexport const MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = '1.0.0'\n\n// https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/identify/id.go#L52\nexport const MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8\n\n// https://github.com/libp2p/go-libp2p/blob/0385ec924bad172f74a74db09939e97c079b1420/p2p/protocol/identify/id.go#L47C7-L47C25\nexport const MAX_PUSH_CONCURRENCY = 32\n\nexport const PUSH_DEBOUNCE_MS = 1_000\n", "import { decodeMessage, encodeMessage, MaxLengthError, message } from 'protons-runtime'\nimport type { Codec, DecodeOptions } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Identify {\n  protocolVersion?: string\n  agentVersion?: string\n  publicKey?: Uint8Array\n  listenAddrs: Uint8Array[]\n  observedAddr?: Uint8Array\n  protocols: string[]\n  signedPeerRecord?: Uint8Array\n}\n\nexport namespace Identify {\n  let _codec: Codec<Identify>\n\n  export const codec = (): Codec<Identify> => {\n    if (_codec == null) {\n      _codec = message<Identify>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.protocolVersion != null) {\n          w.uint32(42)\n          w.string(obj.protocolVersion)\n        }\n\n        if (obj.agentVersion != null) {\n          w.uint32(50)\n          w.string(obj.agentVersion)\n        }\n\n        if (obj.publicKey != null) {\n          w.uint32(10)\n          w.bytes(obj.publicKey)\n        }\n\n        if (obj.listenAddrs != null) {\n          for (const value of obj.listenAddrs) {\n            w.uint32(18)\n            w.bytes(value)\n          }\n        }\n\n        if (obj.observedAddr != null) {\n          w.uint32(34)\n          w.bytes(obj.observedAddr)\n        }\n\n        if (obj.protocols != null) {\n          for (const value of obj.protocols) {\n            w.uint32(26)\n            w.string(value)\n          }\n        }\n\n        if (obj.signedPeerRecord != null) {\n          w.uint32(66)\n          w.bytes(obj.signedPeerRecord)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          listenAddrs: [],\n          protocols: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 5: {\n              obj.protocolVersion = reader.string()\n              break\n            }\n            case 6: {\n              obj.agentVersion = reader.string()\n              break\n            }\n            case 1: {\n              obj.publicKey = reader.bytes()\n              break\n            }\n            case 2: {\n              if (opts.limits?.listenAddrs != null && obj.listenAddrs.length === opts.limits.listenAddrs) {\n                throw new MaxLengthError('Decode error - map field \"listenAddrs\" had too many elements')\n              }\n\n              obj.listenAddrs.push(reader.bytes())\n              break\n            }\n            case 4: {\n              obj.observedAddr = reader.bytes()\n              break\n            }\n            case 3: {\n              if (opts.limits?.protocols != null && obj.protocols.length === opts.limits.protocols) {\n                throw new MaxLengthError('Decode error - map field \"protocols\" had too many elements')\n              }\n\n              obj.protocols.push(reader.string())\n              break\n            }\n            case 8: {\n              obj.signedPeerRecord = reader.bytes()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Identify>): Uint8Array => {\n    return encodeMessage(obj, Identify.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Identify>): Identify => {\n    return decodeMessage(buf, Identify.codec(), opts)\n  }\n}\n", "import { publicKeyFromProtobuf } from '@libp2p/crypto/keys'\nimport { InvalidMessageError } from '@libp2p/interface'\nimport { peerIdFromCID, peerIdFromPublicKey } from '@libp2p/peer-id'\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { IDENTIFY_PROTOCOL_VERSION, MAX_IDENTIFY_MESSAGE_SIZE, MAX_PUSH_CONCURRENCY } from './consts.js'\nimport type { IdentifyComponents, IdentifyInit } from './index.js'\nimport type { Identify as IdentifyMessage } from './pb/message.js'\nimport type { Libp2pEvents, IdentifyResult, SignedPeerRecord, Logger, Connection, Peer, PeerData, PeerStore, Startable, Stream } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { TypedEventTarget } from 'main-event'\n\nexport const defaultValues = {\n  protocolPrefix: 'ipfs',\n  timeout: 5000,\n  maxInboundStreams: 1,\n  maxOutboundStreams: 1,\n  maxObservedAddresses: 10,\n  maxMessageSize: MAX_IDENTIFY_MESSAGE_SIZE,\n  runOnConnectionOpen: true,\n  runOnSelfUpdate: true,\n  runOnLimitedConnection: true,\n  concurrency: MAX_PUSH_CONCURRENCY\n}\n\n/**\n * Takes the `addr` and converts it to a Multiaddr if possible\n */\nexport function getCleanMultiaddr (addr: Uint8Array | string | null | undefined): Multiaddr | undefined {\n  if (addr != null && addr.length > 0) {\n    try {\n      return multiaddr(addr)\n    } catch {\n\n    }\n  }\n}\n\nexport async function consumeIdentifyMessage (peerStore: PeerStore, events: TypedEventTarget<Libp2pEvents>, log: Logger, connection: Connection, message: IdentifyMessage): Promise<IdentifyResult> {\n  log('received identify from %p', connection.remotePeer)\n\n  if (message == null) {\n    throw new InvalidMessageError('message was null or undefined')\n  }\n\n  const peer: PeerData = {}\n\n  if (message.listenAddrs.length > 0) {\n    peer.addresses = message.listenAddrs.map(buf => ({\n      isCertified: false,\n      multiaddr: multiaddr(buf)\n    }))\n  }\n\n  if (message.protocols.length > 0) {\n    peer.protocols = message.protocols\n  }\n\n  if (message.publicKey != null) {\n    const publicKey = publicKeyFromProtobuf(message.publicKey)\n    const peerId = peerIdFromPublicKey(publicKey)\n\n    if (!peerId.equals(connection.remotePeer)) {\n      throw new InvalidMessageError('public key did not match remote PeerId')\n    }\n\n    peer.publicKey = publicKey\n  }\n\n  let output: SignedPeerRecord | undefined\n\n  // if the peer record has been sent, prefer the addresses in the record as they are signed by the remote peer\n  if (message.signedPeerRecord != null) {\n    log.trace('received signedPeerRecord from %p', connection.remotePeer)\n\n    let peerRecordEnvelope = message.signedPeerRecord\n    const envelope = await RecordEnvelope.openAndCertify(peerRecordEnvelope, PeerRecord.DOMAIN)\n    let peerRecord = PeerRecord.createFromProtobuf(envelope.payload)\n    const envelopePeer = peerIdFromCID(envelope.publicKey.toCID())\n\n    // Verify peerId\n    if (!peerRecord.peerId.equals(envelopePeer)) {\n      throw new InvalidMessageError('signing key does not match PeerId in the PeerRecord')\n    }\n\n    // Make sure remote peer is the one sending the record\n    if (!connection.remotePeer.equals(peerRecord.peerId)) {\n      throw new InvalidMessageError('signing key does not match remote PeerId')\n    }\n\n    let existingPeer: Peer | undefined\n\n    try {\n      existingPeer = await peerStore.get(peerRecord.peerId)\n    } catch (err: any) {\n      if (err.name !== 'NotFoundError') {\n        throw err\n      }\n    }\n\n    if (existingPeer != null) {\n      // don't lose any existing metadata\n      peer.metadata = existingPeer.metadata\n\n      // if we have previously received a signed record for this peer, compare it to the incoming one\n      if (existingPeer.peerRecordEnvelope != null) {\n        const storedEnvelope = RecordEnvelope.createFromProtobuf(existingPeer.peerRecordEnvelope)\n        const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload)\n\n        // ensure seq is greater than, or equal to, the last received\n        if (storedRecord.seqNumber >= peerRecord.seqNumber) {\n          log('sequence number was lower or equal to existing sequence number - stored: %d received: %d', storedRecord.seqNumber, peerRecord.seqNumber)\n          peerRecord = storedRecord\n          peerRecordEnvelope = existingPeer.peerRecordEnvelope\n        }\n      }\n    }\n\n    // store the signed record for next time\n    peer.peerRecordEnvelope = peerRecordEnvelope\n\n    // override the stored addresses with the signed multiaddrs\n    peer.addresses = peerRecord.multiaddrs.map(multiaddr => ({\n      isCertified: true,\n      multiaddr\n    }))\n\n    output = {\n      seq: peerRecord.seqNumber,\n      addresses: peerRecord.multiaddrs\n    }\n  } else {\n    log('%p did not send a signed peer record', connection.remotePeer)\n  }\n\n  log.trace('patching %p with', connection.remotePeer, peer)\n  await peerStore.patch(connection.remotePeer, peer)\n\n  if (message.agentVersion != null || message.protocolVersion != null) {\n    const metadata: Record<string, Uint8Array> = {}\n\n    if (message.agentVersion != null) {\n      metadata.AgentVersion = uint8ArrayFromString(message.agentVersion)\n    }\n\n    if (message.protocolVersion != null) {\n      metadata.ProtocolVersion = uint8ArrayFromString(message.protocolVersion)\n    }\n\n    log.trace('merging %p metadata', connection.remotePeer, metadata)\n    await peerStore.merge(connection.remotePeer, {\n      metadata\n    })\n  }\n\n  const result: IdentifyResult = {\n    peerId: connection.remotePeer,\n    protocolVersion: message.protocolVersion,\n    agentVersion: message.agentVersion,\n    publicKey: message.publicKey,\n    listenAddrs: message.listenAddrs.map(buf => multiaddr(buf)),\n    observedAddr: message.observedAddr == null ? undefined : multiaddr(message.observedAddr),\n    protocols: message.protocols,\n    signedPeerRecord: output,\n    connection\n  }\n\n  events.safeDispatchEvent('peer:identify', { detail: result })\n\n  return result\n}\n\nexport interface AbstractIdentifyInit extends IdentifyInit {\n  protocol: string\n  log: Logger\n}\n\nexport abstract class AbstractIdentify implements Startable {\n  public readonly host: {\n    protocolVersion: string\n    agentVersion: string\n  }\n\n  protected components: IdentifyComponents\n  protected protocol: string\n  protected started: boolean\n  protected readonly timeout: number\n  private readonly maxInboundStreams: number\n  private readonly maxOutboundStreams: number\n  protected readonly maxMessageSize: number\n  protected readonly maxObservedAddresses: number\n  protected readonly runOnLimitedConnection: boolean\n  protected readonly log: Logger\n\n  constructor (components: IdentifyComponents, init: AbstractIdentifyInit) {\n    this.protocol = init.protocol\n    this.started = false\n    this.components = components\n    this.log = init.log\n\n    this.timeout = init.timeout ?? defaultValues.timeout\n    this.maxInboundStreams = init.maxInboundStreams ?? defaultValues.maxInboundStreams\n    this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues.maxOutboundStreams\n    this.maxMessageSize = init.maxMessageSize ?? defaultValues.maxMessageSize\n    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues.maxObservedAddresses\n    this.runOnLimitedConnection = init.runOnLimitedConnection ?? defaultValues.runOnLimitedConnection\n\n    // Store self host metadata\n    this.host = {\n      protocolVersion: `${init.protocolPrefix ?? defaultValues.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,\n      agentVersion: components.nodeInfo.userAgent\n    }\n\n    this.handleProtocol = this.handleProtocol.bind(this)\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  async start (): Promise<void> {\n    if (this.started) {\n      return\n    }\n\n    await this.components.peerStore.merge(this.components.peerId, {\n      metadata: {\n        AgentVersion: uint8ArrayFromString(this.host.agentVersion),\n        ProtocolVersion: uint8ArrayFromString(this.host.protocolVersion)\n      }\n    })\n\n    await this.components.registrar.handle(this.protocol, this.handleProtocol, {\n      maxInboundStreams: this.maxInboundStreams,\n      maxOutboundStreams: this.maxOutboundStreams,\n      runOnLimitedConnection: this.runOnLimitedConnection\n    })\n\n    this.started = true\n  }\n\n  async stop (): Promise<void> {\n    await this.components.registrar.unhandle(this.protocol)\n\n    this.started = false\n  }\n\n  protected abstract handleProtocol (stream: Stream, connection: Connection): Promise<void>\n}\n", "import { serviceCapabilities } from '@libp2p/interface'\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record'\nimport { debounce, pbStream } from '@libp2p/utils'\nimport { CODE_P2P } from '@multiformats/multiaddr'\nimport drain from 'it-drain'\nimport parallel from 'it-parallel'\nimport { setMaxListeners } from 'main-event'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport {\n  MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME,\n  MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION,\n  PUSH_DEBOUNCE_MS\n} from './consts.js'\nimport { Identify as IdentifyMessage } from './pb/message.js'\nimport { AbstractIdentify, consumeIdentifyMessage, defaultValues } from './utils.js'\nimport type { IdentifyPush as IdentifyPushInterface, IdentifyPushComponents, IdentifyPushInit } from './index.js'\nimport type { Stream, Startable, Connection } from '@libp2p/interface'\nimport type { ConnectionManager } from '@libp2p/interface-internal'\n\nexport class IdentifyPush extends AbstractIdentify implements Startable, IdentifyPushInterface {\n  private readonly connectionManager: ConnectionManager\n  private readonly concurrency: number\n  private _push: () => void\n\n  constructor (components: IdentifyPushComponents, init: IdentifyPushInit = {}) {\n    super(components, {\n      ...init,\n      protocol: `/${init.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`,\n      log: components.logger.forComponent('libp2p:identify-push')\n    })\n\n    this.connectionManager = components.connectionManager\n    this.concurrency = init.concurrency ?? defaultValues.concurrency\n\n    this._push = debounce(this.sendPushMessage.bind(this), init.debounce ?? PUSH_DEBOUNCE_MS)\n\n    if ((init.runOnSelfUpdate ?? defaultValues.runOnSelfUpdate)) {\n      // When self peer record changes, trigger identify-push\n      components.events.addEventListener('self:peer:update', (evt) => {\n        this.push().catch(err => {\n          this.log.error('error pushing updates to peers - %e', err)\n        })\n      })\n    }\n  }\n\n  [serviceCapabilities]: string[] = [\n    '@libp2p/identify-push'\n  ]\n\n  /**\n   * Calls `push` on all peer connections\n   */\n  async push (): Promise<void> {\n    this._push()\n  }\n\n  private async sendPushMessage (): Promise<void> {\n    // Do not try to push if we are not running\n    if (!this.isStarted()) {\n      return\n    }\n\n    try {\n      const listenAddresses = this.components.addressManager.getAddresses().map(ma => ma.decapsulateCode(CODE_P2P))\n      const peerRecord = new PeerRecord({\n        peerId: this.components.peerId,\n        multiaddrs: listenAddresses\n      })\n      const signedPeerRecord = await RecordEnvelope.seal(peerRecord, this.components.privateKey)\n      const supportedProtocols = this.components.registrar.getProtocols()\n      const peer = await this.components.peerStore.get(this.components.peerId)\n      const agentVersion = uint8ArrayToString(peer.metadata.get('AgentVersion') ?? uint8ArrayFromString(this.host.agentVersion))\n      const protocolVersion = uint8ArrayToString(peer.metadata.get('ProtocolVersion') ?? uint8ArrayFromString(this.host.protocolVersion))\n      const self = this\n\n      async function * pushToConnections (): AsyncGenerator<() => Promise<void>> {\n        for (const connection of self.connectionManager.getConnections()) {\n          const peer = await self.components.peerStore.get(connection.remotePeer)\n\n          if (!peer.protocols.includes(self.protocol)) {\n            continue\n          }\n\n          yield async () => {\n            let stream: Stream | undefined\n            const signal = AbortSignal.timeout(self.timeout)\n\n            setMaxListeners(Infinity, signal)\n\n            try {\n              stream = await connection.newStream(self.protocol, {\n                signal,\n                runOnLimitedConnection: self.runOnLimitedConnection\n              })\n\n              const pb = pbStream(stream, {\n                maxDataLength: self.maxMessageSize\n              }).pb(IdentifyMessage)\n\n              await pb.write({\n                listenAddrs: listenAddresses.map(ma => ma.bytes),\n                signedPeerRecord: signedPeerRecord.marshal(),\n                protocols: supportedProtocols,\n                agentVersion,\n                protocolVersion\n              }, {\n                signal\n              })\n\n              await stream.close({\n                signal\n              })\n            } catch (err: any) {\n              // Just log errors if the stream was opened\n              const log = stream?.log.newScope('identify-push')\n              log?.error('could not push identify update to peer', err)\n              stream?.abort(err)\n            }\n          }\n        }\n      }\n\n      await drain(parallel(pushToConnections(), {\n        concurrency: this.concurrency\n      }))\n    } catch (err: any) {\n      this.log.error('error pushing updates to peers - %e', err)\n    }\n  }\n\n  /**\n   * Reads the Identify Push message from the given `connection`\n   */\n  async handleProtocol (stream: Stream, connection: Connection): Promise<void> {\n    const log = stream.log.newScope('identify-push')\n\n    if (this.components.peerId.equals(connection.remotePeer)) {\n      throw new Error('received push from ourselves?')\n    }\n\n    const options = {\n      signal: AbortSignal.timeout(this.timeout)\n    }\n\n    const pb = pbStream(stream, {\n      maxDataLength: this.maxMessageSize\n    }).pb(IdentifyMessage)\n\n    const message = await pb.read(options)\n    await stream.close(options)\n\n    await consumeIdentifyMessage(this.components.peerStore, this.components.events, log, connection, message)\n\n    log.trace('handled push from %p', connection.remotePeer)\n  }\n}\n", "import { publicKeyFromProtobuf, publicKeyToProtobuf } from '@libp2p/crypto/keys'\nimport { InvalidMessageError, serviceCapabilities } from '@libp2p/interface'\nimport { peerIdFromCID } from '@libp2p/peer-id'\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record'\nimport { isGlobalUnicast, isPrivate, pbStream } from '@libp2p/utils'\nimport { CODE_IP6, CODE_IP6ZONE, CODE_P2P } from '@multiformats/multiaddr'\nimport { IP_OR_DOMAIN, TCP } from '@multiformats/multiaddr-matcher'\nimport { setMaxListeners } from 'main-event'\nimport {\n  MULTICODEC_IDENTIFY_PROTOCOL_NAME,\n  MULTICODEC_IDENTIFY_PROTOCOL_VERSION\n} from './consts.js'\nimport { Identify as IdentifyMessage } from './pb/message.js'\nimport { AbstractIdentify, consumeIdentifyMessage, defaultValues, getCleanMultiaddr } from './utils.js'\nimport type { Identify as IdentifyInterface, IdentifyComponents, IdentifyInit } from './index.js'\nimport type { IdentifyResult, AbortOptions, Connection, Stream, Startable, Logger } from '@libp2p/interface'\n\nexport class Identify extends AbstractIdentify implements Startable, IdentifyInterface {\n  constructor (components: IdentifyComponents, init: IdentifyInit = {}) {\n    super(components, {\n      ...init,\n      protocol: `/${init.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`,\n      log: components.logger.forComponent('libp2p:identify')\n    })\n\n    if (init.runOnConnectionOpen ?? defaultValues.runOnConnectionOpen) {\n      // When a new connection happens, trigger identify\n      components.events.addEventListener('connection:open', (evt) => {\n        const connection = evt.detail\n        this.identify(connection)\n          .catch(() => {})\n      })\n    }\n  }\n\n  [serviceCapabilities]: string[] = [\n    '@libp2p/identify'\n  ]\n\n  async _identify (connection: Connection, options: AbortOptions = {}): Promise<IdentifyMessage> {\n    let stream: Stream | undefined\n    let log: Logger | undefined\n\n    if (options.signal == null) {\n      const signal = AbortSignal.timeout(this.timeout)\n      setMaxListeners(Infinity, signal)\n\n      options = {\n        ...options,\n        signal\n      }\n    }\n\n    this.log('run identify on new connection %a', connection.remoteAddr)\n\n    try {\n      stream = await connection.newStream(this.protocol, {\n        ...options,\n        runOnLimitedConnection: this.runOnLimitedConnection\n      })\n      log = stream.log.newScope('identify')\n\n      const pb = pbStream(stream, {\n        maxDataLength: this.maxMessageSize\n      }).pb(IdentifyMessage)\n\n      const message = await pb.read(options)\n      await pb.unwrap().unwrap().close(options)\n\n      return message\n    } catch (err: any) {\n      log?.error('identify failed - %e', err)\n      stream?.abort(err)\n      throw err\n    }\n  }\n\n  async identify (connection: Connection, options: AbortOptions = {}): Promise<IdentifyResult> {\n    const message = await this._identify(connection, options)\n    const {\n      publicKey,\n      protocols,\n      observedAddr\n    } = message\n\n    if (publicKey == null) {\n      throw new InvalidMessageError('Public key was missing from identify message')\n    }\n\n    const key = publicKeyFromProtobuf(publicKey)\n    const id = peerIdFromCID(key.toCID())\n\n    if (!connection.remotePeer.equals(id)) {\n      throw new InvalidMessageError('Identified peer does not match the expected peer')\n    }\n\n    if (this.components.peerId.equals(id)) {\n      throw new InvalidMessageError('Identified peer is our own peer id?')\n    }\n\n    // if the observed address is publicly routable, add it to the address\n    // manager for verification via AutoNAT\n    this.maybeAddObservedAddress(observedAddr)\n\n    this.log('completed for peer %p and protocols %o', id, protocols)\n\n    return consumeIdentifyMessage(this.components.peerStore, this.components.events, this.log, connection, message)\n  }\n\n  private maybeAddObservedAddress (observedAddr: Uint8Array | undefined): void {\n    const cleanObservedAddr = getCleanMultiaddr(observedAddr)\n\n    if (cleanObservedAddr == null) {\n      return\n    }\n\n    this.log.trace('our observed address was %a', cleanObservedAddr)\n\n    if (isPrivate(cleanObservedAddr)) {\n      return\n    }\n\n    const tuples = cleanObservedAddr.getComponents()\n\n    if (((tuples[0].code === CODE_IP6) || (tuples[0].code === CODE_IP6ZONE && tuples[1].code === CODE_IP6)) && !isGlobalUnicast(cleanObservedAddr)) {\n      this.log.trace('our observed address was IPv6 but not a global unicast address')\n      return\n    }\n\n    if (TCP.exactMatch(cleanObservedAddr)) {\n      // TODO: because socket dials can't use the same local port as the TCP\n      // listener, many unique observed addresses are reported so ignore all\n      // TCP addresses until https://github.com/libp2p/js-libp2p/issues/2620\n      // is resolved\n      return\n    }\n\n    this.log.trace('storing the observed address')\n    this.components.addressManager.addObservedAddr(cleanObservedAddr)\n  }\n\n  /**\n   * Sends the `Identify` response with the Signed Peer Record\n   * to the requesting peer over the given `connection`\n   */\n  async handleProtocol (stream: Stream, connection: Connection): Promise<void> {\n    const log = stream.log.newScope('identify')\n\n    log('responding to identify')\n\n    const signal = AbortSignal.timeout(this.timeout)\n    setMaxListeners(Infinity, signal)\n\n    const peerData = await this.components.peerStore.get(this.components.peerId, {\n      signal\n    })\n    const multiaddrs = this.components.addressManager.getAddresses().map(ma => ma.decapsulateCode(CODE_P2P))\n    let signedPeerRecord = peerData.peerRecordEnvelope\n\n    if (multiaddrs.length > 0 && signedPeerRecord == null) {\n      const peerRecord = new PeerRecord({\n        peerId: this.components.peerId,\n        multiaddrs\n      })\n\n      const envelope = await RecordEnvelope.seal(peerRecord, this.components.privateKey, {\n        signal\n      })\n      signedPeerRecord = envelope.marshal().subarray()\n    }\n\n    let observedAddr: Uint8Array | undefined = connection.remoteAddr.bytes\n\n    if (!IP_OR_DOMAIN.matches(connection.remoteAddr)) {\n      observedAddr = undefined\n    }\n\n    const pb = pbStream(stream).pb(IdentifyMessage)\n\n    log('send response')\n    await pb.write({\n      protocolVersion: this.host.protocolVersion,\n      agentVersion: this.host.agentVersion,\n      publicKey: publicKeyToProtobuf(this.components.privateKey.publicKey),\n      listenAddrs: multiaddrs.map(addr => addr.bytes),\n      signedPeerRecord,\n      observedAddr,\n      protocols: peerData.protocols\n    }, {\n      signal\n    })\n\n    log('close write')\n    await pb.unwrap().unwrap().close({\n      signal\n    })\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Use the `identify` function to add support for the [Identify protocol](https://github.com/libp2p/specs/blob/master/identify/README.md) to libp2p.\n *\n * This protocol allows network peers to discover the multiaddrs the current node listens on, and the protocols it supports.\n *\n * A second function, `identifyPush` is also exported to add support for [identify/push](https://github.com/libp2p/specs/blob/master/identify/README.md#identifypush).\n *\n * This protocol will send updates to all connected peers when the multiaddrs or protocols of the current node change.\n *\n * > [!TIP]\n * > For maximum network compatibility you should configure both protocols\n *\n * @example Enabling identify\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n * import { identify } from '@libp2p/identify'\n *\n * const node = await createLibp2p({\n *   // ...other options\n *   services: {\n *     identify: identify()\n *   }\n * })\n * ```\n *\n * @example Enabling identify push\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n * import { identifyPush } from '@libp2p/identify'\n *\n * const node = await createLibp2p({\n *   // ...other options\n *   services: {\n *     identifyPush: identifyPush()\n *   }\n * })\n * ```\n */\n\nimport { IdentifyPush as IdentifyPushClass } from './identify-push.js'\nimport { Identify as IdentifyClass } from './identify.js'\nimport type { AbortOptions, IdentifyResult, Libp2pEvents, ComponentLogger, NodeInfo, PeerId, PeerStore, Connection, PrivateKey } from '@libp2p/interface'\nimport type { AddressManager, ConnectionManager, Registrar } from '@libp2p/interface-internal'\nimport type { TypedEventTarget } from 'main-event'\n\nexport interface IdentifyInit {\n  /**\n   * The prefix to use for the protocol\n   *\n   * @default 'ipfs'\n   */\n  protocolPrefix?: string\n\n  /**\n   * How long we should wait for a remote peer to send their identify response\n   *\n   * @default 5000\n   */\n  timeout?: number\n\n  /**\n   * Identify responses larger than this in bytes will be rejected\n   *\n   * @default 8192\n   */\n  maxMessageSize?: number\n\n  /**\n   * The maximum number of inbound streams that may be open on a single\n   * connection for this protocol\n   *\n   * @default 1\n   */\n  maxInboundStreams?: number\n\n  /**\n   * The maximum number of outbound streams that may be open on a single\n   * connection for this protocol\n   *\n   * @default 1\n   */\n  maxOutboundStreams?: number\n\n  /**\n   * The maximum number of observed addresses to send in an Identify message\n   */\n  maxObservedAddresses?: number\n\n  /**\n   * Whether to run on connections with data or duration limits\n   *\n   * @default true\n   */\n  runOnLimitedConnection?: boolean\n\n  /**\n   * Whether to automatically run identify on newly opened connections\n   *\n   * @default true\n   */\n  runOnConnectionOpen?: boolean\n}\n\nexport interface IdentifyPushInit extends Omit<IdentifyInit, 'runOnConnectionOpen'> {\n  /**\n   * Whether to automatically dial identify-push on self updates\n   *\n   * @default true\n   */\n  runOnSelfUpdate?: boolean\n\n  /**\n   * Push to this many connections in parallel\n   *\n   * @default 32\n   */\n  concurrency?: number\n\n  /**\n   * To prevent rapid flurries of network activity when addresses/protocols\n   * change rapidly in succession, debounce the sending of push message by this\n   * amount in ms\n   *\n   * @default 1_000\n   */\n  debounce?: number\n}\n\nexport interface IdentifyComponents {\n  peerId: PeerId\n  privateKey: PrivateKey\n  peerStore: PeerStore\n  registrar: Registrar\n  addressManager: AddressManager\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n  nodeInfo: NodeInfo\n}\n\nexport interface IdentifyPushComponents extends IdentifyComponents {\n  connectionManager: ConnectionManager\n}\n\nexport interface Identify {\n  /**\n   * Please use with caution.\n   *\n   * Due to the default limits on inbound/outbound streams for this protocol,\n   * invoking this method when runOnConnectionOpen is true can lead to\n   * unpredictable results as streams may be closed by the local or the remote\n   * node.\n   *\n   * If you find yourself needing to call this method to discover other peers\n   * that support your protocol, you may be better off configuring a topology to\n   * be notified instead.\n   *\n   * Alternatively the libp2p node itself will emit `peer:identify` events after\n   * identify has taken place which can be used to passively detect new peers.\n   */\n  identify(connection: Connection, options?: AbortOptions): Promise<IdentifyResult>\n}\n\nexport interface IdentifyPush {\n  push(): Promise<void>\n}\n\nexport function identify (init: IdentifyInit = {}): (components: IdentifyComponents) => Identify {\n  return (components) => new IdentifyClass(components, init)\n}\n\nexport function identifyPush (init: IdentifyPushInit = {}): (components: IdentifyPushComponents) => IdentifyPush {\n  return (components) => new IdentifyPushClass(components, init)\n}\n"],
  "mappings": "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",
  "names": ["Identify", "_a", "_b", "message", "multiaddr", "peer", "message", "_a", "_b", "Identify", "message", "Identify"]
}
