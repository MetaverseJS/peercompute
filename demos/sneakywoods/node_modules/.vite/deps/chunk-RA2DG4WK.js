import {
  InvalidCIDError,
  InvalidMultihashError,
  InvalidParametersError,
  UnsupportedKeyTypeError,
  peerIdSymbol,
  publicKeyFromMultihash
} from "./chunk-HXWYJQY6.js";
import {
  CID,
  base58btc,
  decode,
  equals,
  fromString,
  identity,
  sha256,
  toString
} from "./chunk-PS3LPXH2.js";
import {
  __publicField
} from "./chunk-WOOG5QLI.js";

// ../../node_modules/@libp2p/peer-id/dist/src/peer-id.js
var inspect = Symbol.for("nodejs.util.inspect.custom");
var LIBP2P_KEY_CODE = 114;
var _a;
var PeerIdImpl = class {
  constructor(init) {
    __publicField(this, "type");
    __publicField(this, "multihash");
    __publicField(this, "publicKey");
    __publicField(this, "string");
    __publicField(this, _a, true);
    this.type = init.type;
    this.multihash = init.multihash;
    Object.defineProperty(this, "string", {
      enumerable: false,
      writable: true
    });
  }
  get [Symbol.toStringTag]() {
    return `PeerId(${this.toString()})`;
  }
  toString() {
    if (this.string == null) {
      this.string = base58btc.encode(this.multihash.bytes).slice(1);
    }
    return this.string;
  }
  toMultihash() {
    return this.multihash;
  }
  // return self-describing String representation
  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209
  toCID() {
    return CID.createV1(LIBP2P_KEY_CODE, this.multihash);
  }
  toJSON() {
    return this.toString();
  }
  /**
   * Checks the equality of `this` peer against a given PeerId
   */
  equals(id) {
    var _a3;
    if (id == null) {
      return false;
    }
    if (id instanceof Uint8Array) {
      return equals(this.multihash.bytes, id);
    } else if (typeof id === "string") {
      return this.toString() === id;
    } else if (((_a3 = id == null ? void 0 : id.toMultihash()) == null ? void 0 : _a3.bytes) != null) {
      return equals(this.multihash.bytes, id.toMultihash().bytes);
    } else {
      throw new Error("not valid Id");
    }
  }
  /**
   * Returns PeerId as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```TypeScript
   * import { peerIdFromString } from '@libp2p/peer-id'
   *
   * console.info(peerIdFromString('QmFoo'))
   * // 'PeerId(QmFoo)'
   * ```
   */
  [(_a = peerIdSymbol, inspect)]() {
    return `PeerId(${this.toString()})`;
  }
};
var RSAPeerId = class extends PeerIdImpl {
  constructor(init) {
    super({ ...init, type: "RSA" });
    __publicField(this, "type", "RSA");
    __publicField(this, "publicKey");
    this.publicKey = init.publicKey;
  }
};
var Ed25519PeerId = class extends PeerIdImpl {
  constructor(init) {
    super({ ...init, type: "Ed25519" });
    __publicField(this, "type", "Ed25519");
    __publicField(this, "publicKey");
    this.publicKey = init.publicKey;
  }
};
var Secp256k1PeerId = class extends PeerIdImpl {
  constructor(init) {
    super({ ...init, type: "secp256k1" });
    __publicField(this, "type", "secp256k1");
    __publicField(this, "publicKey");
    this.publicKey = init.publicKey;
  }
};
var TRANSPORT_IPFS_GATEWAY_HTTP_CODE = 2336;
var _a2, _b;
var URLPeerId = class {
  constructor(url) {
    __publicField(this, "type", "url");
    __publicField(this, "multihash");
    __publicField(this, "publicKey");
    __publicField(this, "url");
    __publicField(this, _a2, true);
    this.url = url.toString();
    this.multihash = identity.digest(fromString(this.url));
  }
  [(_b = inspect, _a2 = peerIdSymbol, _b)]() {
    return `PeerId(${this.url})`;
  }
  toString() {
    return this.toCID().toString();
  }
  toMultihash() {
    return this.multihash;
  }
  toCID() {
    return CID.createV1(TRANSPORT_IPFS_GATEWAY_HTTP_CODE, this.toMultihash());
  }
  toJSON() {
    return this.toString();
  }
  equals(other) {
    if (other == null) {
      return false;
    }
    if (other instanceof Uint8Array) {
      other = toString(other);
    }
    return other.toString() === this.toString();
  }
};

// ../../node_modules/@libp2p/peer-id/dist/src/index.js
var LIBP2P_KEY_CODE2 = 114;
var TRANSPORT_IPFS_GATEWAY_HTTP_CODE2 = 2336;
function peerIdFromString(str, decoder) {
  let multihash;
  if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
    multihash = decode(base58btc.decode(`z${str}`));
  } else if (str.startsWith("k51qzi5uqu5") || str.startsWith("kzwfwjn5ji4") || str.startsWith("k2k4r8") || str.startsWith("bafz")) {
    return peerIdFromCID(CID.parse(str));
  } else {
    if (decoder == null) {
      throw new InvalidParametersError('Please pass a multibase decoder for strings that do not start with "1" or "Q"');
    }
    multihash = decode(decoder.decode(str));
  }
  return peerIdFromMultihash(multihash);
}
function peerIdFromPublicKey(publicKey) {
  if (publicKey.type === "Ed25519") {
    return new Ed25519PeerId({
      multihash: publicKey.toCID().multihash,
      publicKey
    });
  } else if (publicKey.type === "secp256k1") {
    return new Secp256k1PeerId({
      multihash: publicKey.toCID().multihash,
      publicKey
    });
  } else if (publicKey.type === "RSA") {
    return new RSAPeerId({
      multihash: publicKey.toCID().multihash,
      publicKey
    });
  }
  throw new UnsupportedKeyTypeError();
}
function peerIdFromPrivateKey(privateKey) {
  return peerIdFromPublicKey(privateKey.publicKey);
}
function peerIdFromMultihash(multihash) {
  if (isSha256Multihash(multihash)) {
    return new RSAPeerId({ multihash });
  } else if (isIdentityMultihash(multihash)) {
    try {
      const publicKey = publicKeyFromMultihash(multihash);
      if (publicKey.type === "Ed25519") {
        return new Ed25519PeerId({ multihash, publicKey });
      } else if (publicKey.type === "secp256k1") {
        return new Secp256k1PeerId({ multihash, publicKey });
      }
    } catch (err) {
      const url = toString(multihash.digest);
      return new URLPeerId(new URL(url));
    }
  }
  throw new InvalidMultihashError("Supplied PeerID Multihash is invalid");
}
function peerIdFromCID(cid) {
  if ((cid == null ? void 0 : cid.multihash) == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE2 && cid.code !== TRANSPORT_IPFS_GATEWAY_HTTP_CODE2) {
    throw new InvalidCIDError("Supplied PeerID CID is invalid");
  }
  if (cid.code === TRANSPORT_IPFS_GATEWAY_HTTP_CODE2) {
    const url = toString(cid.multihash.digest);
    return new URLPeerId(new URL(url));
  }
  return peerIdFromMultihash(cid.multihash);
}
function isIdentityMultihash(multihash) {
  return multihash.code === identity.code;
}
function isSha256Multihash(multihash) {
  return multihash.code === sha256.code;
}

export {
  peerIdFromString,
  peerIdFromPublicKey,
  peerIdFromPrivateKey,
  peerIdFromMultihash,
  peerIdFromCID
};
//# sourceMappingURL=chunk-RA2DG4WK.js.map
