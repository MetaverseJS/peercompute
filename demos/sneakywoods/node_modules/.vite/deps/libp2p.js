import {
  Key
} from "./chunk-OZFWLDIN.js";
import {
  CustomProgressEvent
} from "./chunk-L4KE4EKF.js";
import {
  PQueue
} from "./chunk-Z6RSUQAM.js";
import "./chunk-23IKEZWA.js";
import {
  PeerMap,
  PeerSet,
  trackedPeerMap
} from "./chunk-QLQH5CV4.js";
import {
  parallel,
  src_default as src_default2
} from "./chunk-H4CW4VU3.js";
import {
  PeerRecord,
  RecordEnvelope
} from "./chunk-H65XI27X.js";
import {
  Circuit,
  IP4,
  IP6,
  PEER_ID,
  QUIC_V1,
  TCP,
  WebRTC,
  WebRTCDirect,
  WebSockets,
  WebSocketsSecure,
  WebTransport
} from "./chunk-7DMLAAL4.js";
import {
  AdaptiveTimeout,
  IpNet,
  PeerQueue,
  PriorityQueue,
  RateLimiter,
  anySignal,
  byteStream,
  createScalableCuckooFilter,
  debounce,
  defaultLogger,
  encode,
  getNetConfig,
  isLinkLocal,
  isLoopback,
  isNetworkAddress,
  isPrivate,
  isPrivateIp,
  lpStream,
  pDefer,
  pushable,
  src_default,
  trackedMap
} from "./chunk-FAMYN5K7.js";
import {
  pEvent,
  raceSignal
} from "./chunk-MXJRKQ3V.js";
import {
  CODE_IP4,
  CODE_IP6,
  CODE_P2P,
  CODE_SNI,
  CODE_TLS,
  isIPv4,
  isMultiaddr,
  multiaddr
} from "./chunk-SAZZGDH5.js";
import {
  peerIdFromCID,
  peerIdFromPrivateKey,
  peerIdFromPublicKey,
  peerIdFromString
} from "./chunk-RA2DG4WK.js";
import {
  AbortError,
  ConnectionClosedError,
  DialError,
  FaultTolerance,
  InvalidMessageError,
  InvalidMultiaddrError,
  InvalidParametersError,
  InvalidPeerIdError,
  KEEP_ALIVE,
  LimitedConnectionError,
  MaxLengthError,
  MaxSizeError,
  NotFoundError,
  NotStartedError,
  StreamCloseEvent,
  TimeoutError,
  TooManyInboundProtocolStreamsError,
  TooManyOutboundProtocolStreamsError,
  TypedEventEmitter,
  Uint8ArrayList,
  UnsupportedProtocolError,
  connectionSymbol,
  contentRoutingSymbol,
  decodeMessage,
  encodeMessage,
  generateKeyPair,
  isPeerId,
  isStartable,
  message,
  peerDiscoverySymbol,
  peerRoutingSymbol,
  publicKeyFromProtobuf,
  publicKeyToProtobuf,
  randomBytes,
  serviceCapabilities,
  serviceDependencies,
  setMaxListeners,
  start,
  stop
} from "./chunk-HXWYJQY6.js";
import {
  CID,
  alloc,
  base32,
  concat,
  equals,
  fromString,
  toString
} from "./chunk-PS3LPXH2.js";
import {
  __commonJS,
  __privateAdd,
  __privateMethod,
  __publicField,
  __toESM
} from "./chunk-WOOG5QLI.js";

// ../../node_modules/hashlru/index.js
var require_hashlru = __commonJS({
  "../../node_modules/hashlru/index.js"(exports, module) {
    module.exports = function(max) {
      if (!max) throw Error("hashlru must have a max value, of type number, greater than 0");
      var size = 0, cache2 = /* @__PURE__ */ Object.create(null), _cache = /* @__PURE__ */ Object.create(null);
      function update(key, value) {
        cache2[key] = value;
        size++;
        if (size >= max) {
          size = 0;
          _cache = cache2;
          cache2 = /* @__PURE__ */ Object.create(null);
        }
      }
      return {
        has: function(key) {
          return cache2[key] !== void 0 || _cache[key] !== void 0;
        },
        remove: function(key) {
          if (cache2[key] !== void 0)
            cache2[key] = void 0;
          if (_cache[key] !== void 0)
            _cache[key] = void 0;
        },
        get: function(key) {
          var v = cache2[key];
          if (v !== void 0) return v;
          if ((v = _cache[key]) !== void 0) {
            update(key, v);
            return v;
          }
        },
        set: function(key, value) {
          if (cache2[key] !== void 0) cache2[key] = value;
          else update(key, value);
        },
        clear: function() {
          cache2 = /* @__PURE__ */ Object.create(null);
          _cache = /* @__PURE__ */ Object.create(null);
        }
      };
    };
  }
});

// ../../node_modules/libp2p/dist/src/config.js
async function validateConfig(opts) {
  var _a12, _b4;
  if (opts.connectionProtector === null && ((_b4 = (_a12 = globalThis.process) == null ? void 0 : _a12.env) == null ? void 0 : _b4.LIBP2P_FORCE_PNET) != null) {
    throw new InvalidParametersError("Private network is enforced, but no protector was provided");
  }
  return opts;
}

// ../../node_modules/it-all/dist/src/index.js
function isAsyncIterable(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function all(source) {
  if (isAsyncIterable(source)) {
    return (async () => {
      const arr2 = [];
      for await (const entry of source) {
        arr2.push(entry);
      }
      return arr2;
    })();
  }
  const arr = [];
  for (const entry of source) {
    arr.push(entry);
  }
  return arr;
}
var src_default3 = all;

// ../../node_modules/abort-error/dist/src/index.js
var AbortError2 = class extends Error {
  constructor(message2 = "The operation was aborted", ...rest) {
    super(message2, ...rest);
    __publicField(this, "name", "AbortError");
  }
};
__publicField(AbortError2, "name", "AbortError");

// ../../node_modules/race-event/dist/src/index.js
async function raceEvent(emitter, eventName, signal, opts) {
  const error = new AbortError2(opts == null ? void 0 : opts.errorMessage);
  if ((opts == null ? void 0 : opts.errorCode) != null) {
    error.code = opts.errorCode;
  }
  const errorEvent = (opts == null ? void 0 : opts.errorEvent) ?? "error";
  if ((signal == null ? void 0 : signal.aborted) === true) {
    return Promise.reject(error);
  }
  return new Promise((resolve, reject) => {
    function removeListeners() {
      removeListener(signal, "abort", abortListener);
      removeListener(emitter, eventName, eventListener);
      removeListener(emitter, errorEvent, errorEventListener);
    }
    const eventListener = (evt) => {
      var _a12;
      try {
        if (((_a12 = opts == null ? void 0 : opts.filter) == null ? void 0 : _a12.call(opts, evt)) === false) {
          return;
        }
      } catch (err) {
        removeListeners();
        reject(err);
        return;
      }
      removeListeners();
      resolve(evt);
    };
    const errorEventListener = (evt) => {
      removeListeners();
      if (evt instanceof Error) {
        reject(evt);
        return;
      }
      reject(evt.detail ?? (opts == null ? void 0 : opts.error) ?? new Error(`The "${opts == null ? void 0 : opts.errorEvent}" event was emitted but the event had no '.detail' field. Pass an 'error' option to race-event to change this message.`));
    };
    const abortListener = () => {
      removeListeners();
      reject(error);
    };
    addListener(signal, "abort", abortListener);
    addListener(emitter, eventName, eventListener);
    addListener(emitter, errorEvent, errorEventListener);
  });
}
function addListener(emitter, event, listener) {
  if (emitter == null) {
    return;
  }
  if (isEventTarget(emitter)) {
    emitter.addEventListener(event, listener);
  } else {
    emitter.addListener(event, listener);
  }
}
function removeListener(emitter, event, listener) {
  if (emitter == null) {
    return;
  }
  if (isEventTarget(emitter)) {
    emitter.removeEventListener(event, listener);
  } else {
    emitter.removeListener(event, listener);
  }
}
function isEventTarget(emitter) {
  return typeof emitter.addEventListener === "function" && typeof emitter.removeEventListener === "function";
}

// ../../node_modules/it-queue/dist/src/errors.js
var QueueFullError = class extends Error {
  constructor(message2 = "The queue was full") {
    super(message2);
    this.name = "QueueFullError";
  }
};
__publicField(QueueFullError, "name", "QueueFullError");

// ../../node_modules/it-queue/dist/src/recipient.js
var JobRecipient = class {
  constructor(signal) {
    __publicField(this, "deferred");
    __publicField(this, "signal");
    var _a12;
    this.signal = signal;
    this.deferred = Promise.withResolvers();
    this.onAbort = this.onAbort.bind(this);
    (_a12 = this.signal) == null ? void 0 : _a12.addEventListener("abort", this.onAbort);
  }
  onAbort() {
    var _a12;
    this.deferred.reject(((_a12 = this.signal) == null ? void 0 : _a12.reason) ?? new AbortError2());
  }
  cleanup() {
    var _a12;
    (_a12 = this.signal) == null ? void 0 : _a12.removeEventListener("abort", this.onAbort);
  }
};

// ../../node_modules/it-queue/dist/src/job.js
function randomId() {
  return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
}
var Job = class {
  constructor(fn, options) {
    __publicField(this, "id");
    __publicField(this, "fn");
    __publicField(this, "options");
    __publicField(this, "recipients");
    __publicField(this, "status");
    __publicField(this, "timeline");
    __publicField(this, "controller");
    this.id = randomId();
    this.status = "queued";
    this.fn = fn;
    this.options = options;
    this.recipients = [];
    this.timeline = {
      created: Date.now()
    };
    this.controller = new AbortController();
    setMaxListeners(Infinity, this.controller.signal);
    this.onAbort = this.onAbort.bind(this);
  }
  abort(err) {
    this.controller.abort(err);
  }
  onAbort() {
    const allAborted = this.recipients.reduce((acc, curr) => {
      var _a12;
      return acc && ((_a12 = curr.signal) == null ? void 0 : _a12.aborted) === true;
    }, true);
    if (allAborted) {
      this.controller.abort(new AbortError2());
      this.cleanup();
    }
  }
  async join(options = {}) {
    var _a12;
    const recipient = new JobRecipient(options.signal);
    this.recipients.push(recipient);
    (_a12 = options.signal) == null ? void 0 : _a12.addEventListener("abort", this.onAbort);
    return recipient.deferred.promise;
  }
  async run() {
    this.status = "running";
    this.timeline.started = Date.now();
    try {
      this.controller.signal.throwIfAborted();
      const result = await raceSignal(this.fn({
        ...this.options ?? {},
        signal: this.controller.signal
      }), this.controller.signal);
      this.recipients.forEach((recipient) => {
        recipient.deferred.resolve(result);
      });
      this.status = "complete";
    } catch (err) {
      this.recipients.forEach((recipient) => {
        recipient.deferred.reject(err);
      });
      this.status = "errored";
    } finally {
      this.timeline.finished = Date.now();
      this.cleanup();
    }
  }
  cleanup() {
    this.recipients.forEach((recipient) => {
      var _a12;
      recipient.cleanup();
      (_a12 = recipient.signal) == null ? void 0 : _a12.removeEventListener("abort", this.onAbort);
    });
  }
};

// ../../node_modules/it-queue/dist/src/utils.js
function debounce2(func, wait) {
  let timeout;
  const output = function() {
    const later = function() {
      timeout = void 0;
      void func();
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
  output.start = () => {
  };
  output.stop = () => {
    clearTimeout(timeout);
  };
  return output;
}

// ../../node_modules/it-queue/dist/src/index.js
var Queue = class extends TypedEventEmitter {
  constructor(init = {}) {
    super();
    __publicField(this, "concurrency");
    __publicField(this, "maxSize");
    __publicField(this, "queue");
    __publicField(this, "pending");
    __publicField(this, "sort");
    __publicField(this, "autoStart");
    this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY;
    this.maxSize = init.maxSize ?? Number.POSITIVE_INFINITY;
    this.pending = 0;
    this.autoStart = init.autoStart ?? true;
    this.sort = init.sort;
    this.queue = [];
    this.emitEmpty = debounce2(this.emitEmpty.bind(this), 1);
    this.emitIdle = debounce2(this.emitIdle.bind(this), 1);
  }
  [Symbol.asyncIterator]() {
    return this.toGenerator();
  }
  emitEmpty() {
    if (this.size !== 0) {
      return;
    }
    this.safeDispatchEvent("empty");
  }
  emitIdle() {
    if (this.running !== 0) {
      return;
    }
    this.safeDispatchEvent("idle");
  }
  tryToStartAnother() {
    if (this.size === 0) {
      this.emitEmpty();
      if (this.running === 0) {
        this.emitIdle();
      }
      return false;
    }
    if (this.pending < this.concurrency) {
      let job;
      for (const j of this.queue) {
        if (j.status === "queued") {
          job = j;
          break;
        }
      }
      if (job == null) {
        return false;
      }
      this.safeDispatchEvent("active");
      this.pending++;
      void job.run().finally(() => {
        for (let i = 0; i < this.queue.length; i++) {
          if (this.queue[i] === job) {
            this.queue.splice(i, 1);
            break;
          }
        }
        this.pending--;
        this.safeDispatchEvent("next");
        if (this.autoStart) {
          this.tryToStartAnother();
        }
      });
      return true;
    }
    return false;
  }
  enqueue(job) {
    this.queue.push(job);
    if (this.sort != null) {
      this.queue.sort(this.sort);
    }
  }
  /**
   * Start the queue. If the `autoStart` parameter passed to the constructor was
   * not `false` this is a no-op
   */
  start() {
    if (this.autoStart !== false) {
      return;
    }
    this.autoStart = true;
    this.tryToStartAnother();
  }
  /**
   * Prevent further jobs from running - call `.start` to start the queue again
   */
  pause() {
    this.autoStart = false;
  }
  /**
   * Adds a sync or async task to the queue. Always returns a promise.
   */
  async add(fn, options) {
    var _a12;
    (_a12 = options == null ? void 0 : options.signal) == null ? void 0 : _a12.throwIfAborted();
    if (this.size === this.maxSize) {
      throw new QueueFullError();
    }
    const job = new Job(fn, options);
    this.enqueue(job);
    this.safeDispatchEvent("add");
    if (this.autoStart) {
      this.tryToStartAnother();
    }
    return job.join(options).then((result) => {
      this.safeDispatchEvent("success", { detail: { job, result } });
      return result;
    }).catch((err) => {
      if (job.status === "queued") {
        for (let i = 0; i < this.queue.length; i++) {
          if (this.queue[i] === job) {
            this.queue.splice(i, 1);
            break;
          }
        }
      }
      this.safeDispatchEvent("failure", { detail: { job, error: err } });
      throw err;
    });
  }
  /**
   * Clear the queue
   */
  clear() {
    this.queue.splice(0, this.queue.length);
  }
  /**
   * Abort all jobs in the queue and clear it
   */
  abort() {
    this.queue.forEach((job) => {
      job.abort(new AbortError2());
    });
    this.clear();
  }
  /**
   * Can be called multiple times. Useful if you for example add additional items at a later time.
   *
   * @returns A promise that settles when the queue becomes empty.
   */
  async onEmpty(options) {
    if (this.size === 0) {
      return;
    }
    await raceEvent(this, "empty", options == null ? void 0 : options.signal);
  }
  /**
   * @returns A promise that settles when the queue size is less than the given
   * limit: `queue.size < limit`.
   *
   * If you want to avoid having the queue grow beyond a certain size you can
   * `await queue.onSizeLessThan()` before adding a new item.
   *
   * Note that this only limits the number of items waiting to start. There
   * could still be up to `concurrency` jobs already running that this call does
   * not include in its calculation.
   */
  async onSizeLessThan(limit, options) {
    if (this.size < limit) {
      return;
    }
    await raceEvent(this, "next", options == null ? void 0 : options.signal, {
      filter: () => this.size < limit
    });
  }
  /**
   * The difference with `.onEmpty` is that `.onIdle` guarantees that all work
   * from the queue has finished. `.onEmpty` merely signals that the queue is
   * empty, but it could mean that some promises haven't completed yet.
   *
   * @returns A promise that settles when the queue becomes empty, and all
   * promises have completed; `queue.size === 0 && queue.pending === 0`.
   */
  async onIdle(options) {
    if (this.pending === 0 && this.size === 0) {
      return;
    }
    await raceEvent(this, "idle", options == null ? void 0 : options.signal);
  }
  /**
   * Size of the queue including running items
   */
  get size() {
    return this.queue.length;
  }
  /**
   * The number of queued items waiting to run.
   */
  get queued() {
    return this.queue.length - this.pending;
  }
  /**
   * The number of items currently running.
   */
  get running() {
    return this.pending;
  }
  /**
   * Returns an async generator that makes it easy to iterate over the results
   * of jobs added to the queue.
   *
   * The generator will end when the queue becomes idle, that is there are no
   * jobs running and no jobs that have yet to run.
   *
   * If you need to keep the queue open indefinitely, consider using it-pushable
   * instead.
   */
  async *toGenerator(options) {
    var _a12, _b4, _c2;
    (_a12 = options == null ? void 0 : options.signal) == null ? void 0 : _a12.throwIfAborted();
    const stream = pushable({
      objectMode: true
    });
    const cleanup = (err) => {
      if (err != null) {
        this.abort();
      } else {
        this.clear();
      }
      stream.end(err);
    };
    const onQueueJobComplete = (evt) => {
      if (evt.detail != null) {
        stream.push(evt.detail.result);
      }
    };
    const onQueueError = (evt) => {
      cleanup(evt.detail.error);
    };
    const onQueueIdle = () => {
      cleanup();
    };
    const onSignalAbort = () => {
      cleanup(new AbortError2("Queue aborted"));
    };
    this.addEventListener("success", onQueueJobComplete);
    this.addEventListener("failure", onQueueError);
    this.addEventListener("idle", onQueueIdle);
    (_b4 = options == null ? void 0 : options.signal) == null ? void 0 : _b4.addEventListener("abort", onSignalAbort);
    try {
      yield* stream;
    } finally {
      this.removeEventListener("success", onQueueJobComplete);
      this.removeEventListener("failure", onQueueError);
      this.removeEventListener("idle", onQueueIdle);
      (_c2 = options == null ? void 0 : options.signal) == null ? void 0 : _c2.removeEventListener("abort", onSignalAbort);
      cleanup();
    }
  }
};

// ../../node_modules/mortice/dist/src/constants.js
var WORKER_REQUEST_READ_LOCK = "lock:worker:request-read";
var WORKER_ABORT_READ_LOCK_REQUEST = "lock:worker:abort-read-request";
var WORKER_RELEASE_READ_LOCK = "lock:worker:release-read";
var MASTER_GRANT_READ_LOCK = "lock:master:grant-read";
var MASTER_READ_LOCK_ERROR = "lock:master:error-read";
var WORKER_REQUEST_WRITE_LOCK = "lock:worker:request-write";
var WORKER_ABORT_WRITE_LOCK_REQUEST = "lock:worker:abort-write-request";
var WORKER_RELEASE_WRITE_LOCK = "lock:worker:release-write";
var MASTER_GRANT_WRITE_LOCK = "lock:master:grant-write";
var MASTER_WRITE_LOCK_ERROR = "lock:master:error-write";
var WORKER_FINALIZE = "lock:worker:finalize";
var BROADCAST_CHANNEL_NAME = "mortice";
var defaultOptions = {
  singleProcess: false
};

// ../../node_modules/mortice/dist/src/main/channel.js
var handleChannelWorkerLockRequest = (emitter, channel, masterEvent, abortMasterEvent, requestType, abortType, errorType, releaseType, grantType) => {
  return (event) => {
    if (event.data == null) {
      return;
    }
    const requestEvent = {
      type: event.data.type,
      name: event.data.name,
      identifier: event.data.identifier
    };
    if (requestEvent.type === requestType) {
      emitter.safeDispatchEvent(masterEvent, {
        detail: {
          name: requestEvent.name,
          identifier: requestEvent.identifier,
          handler: async () => {
            channel.postMessage({
              type: grantType,
              name: requestEvent.name,
              identifier: requestEvent.identifier
            });
            await new Promise((resolve) => {
              const releaseEventListener = (event2) => {
                if ((event2 == null ? void 0 : event2.data) == null) {
                  return;
                }
                const releaseEvent = {
                  type: event2.data.type,
                  name: event2.data.name,
                  identifier: event2.data.identifier
                };
                if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                  channel.removeEventListener("message", releaseEventListener);
                  resolve();
                }
              };
              channel.addEventListener("message", releaseEventListener);
            });
          },
          onError: (err) => {
            channel.postMessage({
              type: errorType,
              name: requestEvent.name,
              identifier: requestEvent.identifier,
              error: {
                message: err.message,
                name: err.name,
                stack: err.stack
              }
            });
          }
        }
      });
    }
    if (requestEvent.type === abortType) {
      emitter.safeDispatchEvent(abortMasterEvent, {
        detail: {
          name: requestEvent.name,
          identifier: requestEvent.identifier
        }
      });
    }
    if (requestEvent.type === WORKER_FINALIZE) {
      emitter.safeDispatchEvent("finalizeRequest", {
        detail: {
          name: requestEvent.name
        }
      });
    }
  };
};

// ../../node_modules/mortice/dist/src/utils.js
var nanoid = (size = 10) => {
  return Math.random().toString().substring(2, size + 2);
};

// ../../node_modules/mortice/dist/src/workers/channel.js
var MorticeChannelWorker = class {
  constructor(name2) {
    __publicField(this, "name");
    __publicField(this, "channel");
    this.name = name2;
    this.channel = new BroadcastChannel(BROADCAST_CHANNEL_NAME);
  }
  readLock(options) {
    return this.sendRequest(WORKER_REQUEST_READ_LOCK, WORKER_ABORT_READ_LOCK_REQUEST, MASTER_GRANT_READ_LOCK, MASTER_READ_LOCK_ERROR, WORKER_RELEASE_READ_LOCK, options);
  }
  writeLock(options) {
    return this.sendRequest(WORKER_REQUEST_WRITE_LOCK, WORKER_ABORT_WRITE_LOCK_REQUEST, MASTER_GRANT_WRITE_LOCK, MASTER_WRITE_LOCK_ERROR, WORKER_RELEASE_WRITE_LOCK, options);
  }
  finalize() {
    this.channel.postMessage({
      type: WORKER_FINALIZE,
      name: this.name
    });
    this.channel.close();
  }
  async sendRequest(requestType, abortType, grantType, errorType, releaseType, options) {
    var _a12;
    (_a12 = options == null ? void 0 : options.signal) == null ? void 0 : _a12.throwIfAborted();
    const id = nanoid();
    this.channel.postMessage({
      type: requestType,
      identifier: id,
      name: this.name
    });
    return new Promise((resolve, reject) => {
      var _a13;
      const abortListener = () => {
        this.channel.postMessage({
          type: abortType,
          identifier: id,
          name: this.name
        });
      };
      (_a13 = options == null ? void 0 : options.signal) == null ? void 0 : _a13.addEventListener("abort", abortListener, {
        once: true
      });
      const listener = (event) => {
        var _a14, _b4, _c2, _d;
        if (((_a14 = event.data) == null ? void 0 : _a14.identifier) !== id) {
          return;
        }
        if (((_b4 = event.data) == null ? void 0 : _b4.type) === grantType) {
          this.channel.removeEventListener("message", listener);
          (_c2 = options == null ? void 0 : options.signal) == null ? void 0 : _c2.removeEventListener("abort", abortListener);
          resolve(() => {
            this.channel.postMessage({
              type: releaseType,
              identifier: id,
              name: this.name
            });
          });
        }
        if (event.data.type === errorType) {
          this.channel.removeEventListener("message", listener);
          (_d = options == null ? void 0 : options.signal) == null ? void 0 : _d.removeEventListener("abort", abortListener);
          const err = new Error();
          if (event.data.error != null) {
            err.message = event.data.error.message;
            err.name = event.data.error.name;
            err.stack = event.data.error.stack;
          }
          reject(err);
        }
      };
      this.channel.addEventListener("message", listener);
    });
  }
};

// ../../node_modules/mortice/dist/src/browser.js
var browser_default = (options) => {
  options = Object.assign({}, defaultOptions, options);
  const isPrimary = Boolean(globalThis.document) || options.singleProcess;
  if (isPrimary) {
    const channel = new BroadcastChannel(BROADCAST_CHANNEL_NAME);
    const emitter = new TypedEventEmitter();
    channel.addEventListener("message", handleChannelWorkerLockRequest(emitter, channel, "requestReadLock", "abortReadLockRequest", WORKER_REQUEST_READ_LOCK, WORKER_ABORT_READ_LOCK_REQUEST, MASTER_READ_LOCK_ERROR, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
    channel.addEventListener("message", handleChannelWorkerLockRequest(emitter, channel, "requestWriteLock", "abortWriteLockRequest", WORKER_REQUEST_WRITE_LOCK, WORKER_ABORT_WRITE_LOCK_REQUEST, MASTER_WRITE_LOCK_ERROR, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
    return emitter;
  }
  return new MorticeChannelWorker(options.name);
};

// ../../node_modules/mortice/dist/src/mortice.js
var mutexes = /* @__PURE__ */ new Map();
var implementation;
function isMortice(obj) {
  return typeof (obj == null ? void 0 : obj.readLock) === "function" && typeof (obj == null ? void 0 : obj.writeLock) === "function";
}
function getImplementation(opts) {
  if (implementation == null) {
    implementation = browser_default(opts);
    if (!isMortice(implementation)) {
      const emitter = implementation;
      emitter.addEventListener("requestReadLock", (event) => {
        const mutexName = event.detail.name;
        const identifier = event.detail.identifier;
        const mutex = mutexes.get(mutexName);
        if (mutex == null) {
          return;
        }
        const abortController = new AbortController();
        const abortListener = (event2) => {
          if (event2.detail.name !== mutexName || event2.detail.identifier !== identifier) {
            return;
          }
          abortController.abort();
        };
        emitter.addEventListener("abortReadLockRequest", abortListener);
        void mutex.readLock({
          signal: abortController.signal
        }).then(async (release) => {
          await event.detail.handler().finally(() => {
            release();
          });
        }).catch((err) => {
          event.detail.onError(err);
        }).finally(() => {
          emitter.removeEventListener("abortReadLockRequest", abortListener);
        });
      });
      emitter.addEventListener("requestWriteLock", (event) => {
        const mutexName = event.detail.name;
        const identifier = event.detail.identifier;
        const mutex = mutexes.get(mutexName);
        if (mutex == null) {
          return;
        }
        const abortController = new AbortController();
        const abortListener = (event2) => {
          if (event2.detail.name !== mutexName || event2.detail.identifier !== identifier) {
            return;
          }
          abortController.abort();
        };
        emitter.addEventListener("abortWriteLockRequest", abortListener);
        void mutex.writeLock({
          signal: abortController.signal
        }).then(async (release) => {
          await event.detail.handler().finally(() => {
            release();
          });
        }).catch((err) => {
          event.detail.onError(err);
        }).finally(() => {
          emitter.removeEventListener("abortWriteLockRequest", abortListener);
        });
      });
      emitter.addEventListener("finalizeRequest", (event) => {
        const mutexName = event.detail.name;
        const mutex = mutexes.get(mutexName);
        if (mutex == null) {
          return;
        }
        mutex.finalize();
      });
    }
  }
  return implementation;
}
async function createReleasable(queue, options) {
  var _a12;
  let res;
  let rej;
  const p = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  const listener = () => {
    rej(new AbortError2());
  };
  (_a12 = options == null ? void 0 : options.signal) == null ? void 0 : _a12.addEventListener("abort", listener, {
    once: true
  });
  queue.add(async () => {
    await new Promise((resolve) => {
      res(() => {
        var _a13;
        (_a13 = options == null ? void 0 : options.signal) == null ? void 0 : _a13.removeEventListener("abort", listener);
        resolve();
      });
    });
  }, {
    signal: options == null ? void 0 : options.signal
  }).catch((err) => {
    rej(err);
  });
  return p;
}
var createMutex = (name2, options) => {
  let mutex = mutexes.get(name2);
  if (mutex != null) {
    return mutex;
  }
  const implementation2 = getImplementation(options);
  if (isMortice(implementation2)) {
    mutex = implementation2;
    mutexes.set(name2, mutex);
    return mutex;
  }
  const masterQueue = new Queue({
    concurrency: 1
  });
  let readQueue;
  mutex = {
    async readLock(opts) {
      if (readQueue != null) {
        return createReleasable(readQueue, opts);
      }
      readQueue = new Queue({
        concurrency: options.concurrency,
        autoStart: false
      });
      const localReadQueue = readQueue;
      const readPromise = createReleasable(readQueue, opts);
      void masterQueue.add(async () => {
        localReadQueue.start();
        await localReadQueue.onIdle().then(() => {
          if (readQueue === localReadQueue) {
            readQueue = null;
          }
        });
      });
      return readPromise;
    },
    async writeLock(opts) {
      readQueue = null;
      return createReleasable(masterQueue, opts);
    },
    finalize: () => {
      mutexes.delete(name2);
    },
    queue: masterQueue
  };
  mutexes.set(name2, mutex);
  if (options.autoFinalize === true) {
    masterQueue.addEventListener("idle", () => {
      mutex.finalize();
    }, {
      once: true
    });
  }
  return mutex;
};

// ../../node_modules/mortice/dist/src/index.js
var defaultOptions2 = {
  name: "lock",
  concurrency: Infinity,
  singleProcess: false,
  autoFinalize: false
};
function createMortice(options) {
  const opts = Object.assign({}, defaultOptions2, options);
  return createMutex(opts.name, opts);
}

// ../../node_modules/@libp2p/peer-store/dist/src/constants.js
var MAX_ADDRESS_AGE = 36e5;
var MAX_PEER_AGE = 216e5;

// ../../node_modules/@libp2p/peer-store/dist/src/pb/peer.js
var Peer;
(function(Peer2) {
  let Peer$metadataEntry;
  (function(Peer$metadataEntry2) {
    let _codec2;
    Peer$metadataEntry2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.key != null && obj.key !== "") {
            w.uint32(10);
            w.string(obj.key);
          }
          if (obj.value != null && obj.value.byteLength > 0) {
            w.uint32(18);
            w.bytes(obj.value);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length, opts = {}) => {
          const obj = {
            key: "",
            value: alloc(0)
          };
          const end = length == null ? reader.len : reader.pos + length;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.key = reader.string();
                break;
              }
              case 2: {
                obj.value = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer$metadataEntry2.encode = (obj) => {
      return encodeMessage(obj, Peer$metadataEntry2.codec());
    };
    Peer$metadataEntry2.decode = (buf, opts) => {
      return decodeMessage(buf, Peer$metadataEntry2.codec(), opts);
    };
  })(Peer$metadataEntry = Peer2.Peer$metadataEntry || (Peer2.Peer$metadataEntry = {}));
  let Peer$tagsEntry;
  (function(Peer$tagsEntry2) {
    let _codec2;
    Peer$tagsEntry2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.key != null && obj.key !== "") {
            w.uint32(10);
            w.string(obj.key);
          }
          if (obj.value != null) {
            w.uint32(18);
            Tag.codec().encode(obj.value, w);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length, opts = {}) => {
          var _a12;
          const obj = {
            key: ""
          };
          const end = length == null ? reader.len : reader.pos + length;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.key = reader.string();
                break;
              }
              case 2: {
                obj.value = Tag.codec().decode(reader, reader.uint32(), {
                  limits: (_a12 = opts.limits) == null ? void 0 : _a12.value
                });
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer$tagsEntry2.encode = (obj) => {
      return encodeMessage(obj, Peer$tagsEntry2.codec());
    };
    Peer$tagsEntry2.decode = (buf, opts) => {
      return decodeMessage(buf, Peer$tagsEntry2.codec(), opts);
    };
  })(Peer$tagsEntry = Peer2.Peer$tagsEntry || (Peer2.Peer$tagsEntry = {}));
  let _codec;
  Peer2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.addresses != null) {
          for (const value of obj.addresses) {
            w.uint32(10);
            Address.codec().encode(value, w);
          }
        }
        if (obj.protocols != null) {
          for (const value of obj.protocols) {
            w.uint32(18);
            w.string(value);
          }
        }
        if (obj.publicKey != null) {
          w.uint32(34);
          w.bytes(obj.publicKey);
        }
        if (obj.peerRecordEnvelope != null) {
          w.uint32(42);
          w.bytes(obj.peerRecordEnvelope);
        }
        if (obj.metadata != null && obj.metadata.size !== 0) {
          for (const [key, value] of obj.metadata.entries()) {
            w.uint32(50);
            Peer2.Peer$metadataEntry.codec().encode({ key, value }, w);
          }
        }
        if (obj.tags != null && obj.tags.size !== 0) {
          for (const [key, value] of obj.tags.entries()) {
            w.uint32(58);
            Peer2.Peer$tagsEntry.codec().encode({ key, value }, w);
          }
        }
        if (obj.updated != null) {
          w.uint32(64);
          w.uint64Number(obj.updated);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        var _a12, _b4, _c2, _d, _e, _f;
        const obj = {
          addresses: [],
          protocols: [],
          metadata: /* @__PURE__ */ new Map(),
          tags: /* @__PURE__ */ new Map()
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (((_a12 = opts.limits) == null ? void 0 : _a12.addresses) != null && obj.addresses.length === opts.limits.addresses) {
                throw new MaxLengthError('Decode error - map field "addresses" had too many elements');
              }
              obj.addresses.push(Address.codec().decode(reader, reader.uint32(), {
                limits: (_b4 = opts.limits) == null ? void 0 : _b4.addresses$
              }));
              break;
            }
            case 2: {
              if (((_c2 = opts.limits) == null ? void 0 : _c2.protocols) != null && obj.protocols.length === opts.limits.protocols) {
                throw new MaxLengthError('Decode error - map field "protocols" had too many elements');
              }
              obj.protocols.push(reader.string());
              break;
            }
            case 4: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 5: {
              obj.peerRecordEnvelope = reader.bytes();
              break;
            }
            case 6: {
              if (((_d = opts.limits) == null ? void 0 : _d.metadata) != null && obj.metadata.size === opts.limits.metadata) {
                throw new MaxSizeError('Decode error - map field "metadata" had too many elements');
              }
              const entry = Peer2.Peer$metadataEntry.codec().decode(reader, reader.uint32());
              obj.metadata.set(entry.key, entry.value);
              break;
            }
            case 7: {
              if (((_e = opts.limits) == null ? void 0 : _e.tags) != null && obj.tags.size === opts.limits.tags) {
                throw new MaxSizeError('Decode error - map field "tags" had too many elements');
              }
              const entry = Peer2.Peer$tagsEntry.codec().decode(reader, reader.uint32(), {
                limits: {
                  value: (_f = opts.limits) == null ? void 0 : _f.tags$value
                }
              });
              obj.tags.set(entry.key, entry.value);
              break;
            }
            case 8: {
              obj.updated = reader.uint64Number();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Peer2.encode = (obj) => {
    return encodeMessage(obj, Peer2.codec());
  };
  Peer2.decode = (buf, opts) => {
    return decodeMessage(buf, Peer2.codec(), opts);
  };
})(Peer || (Peer = {}));
var Address;
(function(Address2) {
  let _codec;
  Address2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.multiaddr);
        }
        if (obj.isCertified != null) {
          w.uint32(16);
          w.bool(obj.isCertified);
        }
        if (obj.observed != null) {
          w.uint32(24);
          w.uint64Number(obj.observed);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        const obj = {
          multiaddr: alloc(0)
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.multiaddr = reader.bytes();
              break;
            }
            case 2: {
              obj.isCertified = reader.bool();
              break;
            }
            case 3: {
              obj.observed = reader.uint64Number();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Address2.encode = (obj) => {
    return encodeMessage(obj, Address2.codec());
  };
  Address2.decode = (buf, opts) => {
    return decodeMessage(buf, Address2.codec(), opts);
  };
})(Address || (Address = {}));
var Tag;
(function(Tag2) {
  let _codec;
  Tag2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.value != null && obj.value !== 0) {
          w.uint32(8);
          w.uint32(obj.value);
        }
        if (obj.expiry != null) {
          w.uint32(16);
          w.uint64(obj.expiry);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        const obj = {
          value: 0
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.value = reader.uint32();
              break;
            }
            case 2: {
              obj.expiry = reader.uint64();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Tag2.encode = (obj) => {
    return encodeMessage(obj, Tag2.codec());
  };
  Tag2.decode = (buf, opts) => {
    return decodeMessage(buf, Tag2.codec(), opts);
  };
})(Tag || (Tag = {}));

// ../../node_modules/@libp2p/peer-store/dist/src/utils/bytes-to-peer.js
function populatePublicKey(peerId, protobuf) {
  if (peerId.publicKey != null || protobuf.publicKey == null) {
    return peerId;
  }
  let digest;
  if (peerId.type === "RSA") {
    digest = peerId.toMultihash();
  }
  const publicKey = publicKeyFromProtobuf(protobuf.publicKey, digest);
  return peerIdFromPublicKey(publicKey);
}
function bytesToPeer(peerId, buf, maxAddressAge) {
  const peer = Peer.decode(buf);
  return pbToPeer(peerId, peer, maxAddressAge);
}
function pbToPeer(peerId, peer, maxAddressAge) {
  const tags = /* @__PURE__ */ new Map();
  const now = BigInt(Date.now());
  for (const [key, tag] of peer.tags.entries()) {
    if (tag.expiry != null && tag.expiry < now) {
      continue;
    }
    tags.set(key, tag);
  }
  return {
    ...peer,
    id: populatePublicKey(peerId, peer),
    addresses: peer.addresses.filter(({ observed }) => observed != null && observed > Date.now() - maxAddressAge).map(({ multiaddr: ma, isCertified }) => {
      return {
        multiaddr: multiaddr(ma),
        isCertified: isCertified ?? false
      };
    }),
    metadata: peer.metadata,
    peerRecordEnvelope: peer.peerRecordEnvelope ?? void 0,
    tags
  };
}

// ../../node_modules/@libp2p/peer-store/dist/src/utils/peer-equals.js
function peerEquals(peerA, peerB) {
  return addressesEqual(peerA.addresses, peerB.addresses) && protocolsEqual(peerA.protocols, peerB.protocols) && publicKeyEqual(peerA.publicKey, peerB.publicKey) && peerRecordEnvelope(peerA.peerRecordEnvelope, peerB.peerRecordEnvelope) && metadataEqual(peerA.metadata, peerB.metadata) && tagsEqual(peerA.tags, peerB.tags);
}
function addressesEqual(addressesA, addressesB) {
  return compareArrays(addressesA, addressesB, (a, b) => {
    if (a.isCertified !== b.isCertified) {
      return false;
    }
    if (!equals(a.multiaddr, b.multiaddr)) {
      return false;
    }
    return true;
  });
}
function protocolsEqual(protocolsA, protocolsB) {
  return compareArrays(protocolsA, protocolsB, (a, b) => a === b);
}
function publicKeyEqual(publicKeyA, publicKeyB) {
  return compareOptionalUint8Arrays(publicKeyA, publicKeyB);
}
function peerRecordEnvelope(envelopeA, envelopeB) {
  return compareOptionalUint8Arrays(envelopeA, envelopeB);
}
function metadataEqual(metadataA, metadataB) {
  return compareMaps(metadataA, metadataB, (a, b) => equals(a, b));
}
function tagsEqual(metadataA, metadataB) {
  return compareMaps(metadataA, metadataB, (a, b) => a.value === b.value && a.expiry === b.expiry);
}
function compareOptionalUint8Arrays(arrA, arrB) {
  if (arrA == null && arrB == null) {
    return true;
  }
  if (arrA != null && arrB != null) {
    return equals(arrA, arrB);
  }
  return false;
}
function compareArrays(arrA, arrB, compare) {
  if (arrA.length !== arrB.length) {
    return false;
  }
  for (let i = 0; i < arrA.length; i++) {
    if (!compare(arrA[i], arrB[i])) {
      return false;
    }
  }
  return true;
}
function compareMaps(mapA, mapB, compare) {
  if (mapA.size !== mapB.size) {
    return false;
  }
  for (const [key, value] of mapA.entries()) {
    const valueB = mapB.get(key);
    if (valueB == null) {
      return false;
    }
    if (!compare(value, valueB)) {
      return false;
    }
  }
  return true;
}

// ../../node_modules/@libp2p/peer-store/dist/src/utils/peer-id-to-datastore-key.js
var NAMESPACE_COMMON = "/peers/";
function peerIdToDatastoreKey(peerId) {
  if (!isPeerId(peerId) || peerId.type == null) {
    throw new InvalidParametersError("Invalid PeerId");
  }
  const b32key = peerId.toCID().toString();
  return new Key(`${NAMESPACE_COMMON}${b32key}`);
}

// ../../node_modules/@libp2p/peer-store/dist/src/utils/dedupe-addresses.js
async function dedupeFilterAndSortAddresses(peerId, filter2, addresses, existingAddresses, options) {
  const addressMap = /* @__PURE__ */ new Map();
  for (const addr of addresses) {
    if (addr == null) {
      continue;
    }
    if (addr.multiaddr instanceof Uint8Array) {
      addr.multiaddr = multiaddr(addr.multiaddr);
    }
    if (!isMultiaddr(addr.multiaddr)) {
      throw new InvalidParametersError("Multiaddr was invalid");
    }
    if (!await filter2(peerId, addr.multiaddr, options)) {
      continue;
    }
    const isCertified = addr.isCertified ?? false;
    const maStr = addr.multiaddr.toString();
    const existingAddr = addressMap.get(maStr);
    if (existingAddr != null) {
      addr.isCertified = existingAddr.isCertified || isCertified;
    } else {
      addressMap.set(maStr, {
        multiaddr: addr.multiaddr,
        isCertified
      });
    }
  }
  return [...addressMap.values()].sort((a, b) => {
    return a.multiaddr.toString().localeCompare(b.multiaddr.toString());
  }).map(({ isCertified, multiaddr: ma }) => {
    var _a12;
    const addrPeer = (_a12 = ma.getComponents().find((c) => c.code === CODE_P2P)) == null ? void 0 : _a12.value;
    if (peerId.equals(addrPeer)) {
      ma = ma.decapsulate(multiaddr(`/p2p/${peerId}`));
    }
    return {
      isCertified,
      multiaddr: ma.bytes
    };
  });
}

// ../../node_modules/@libp2p/peer-store/dist/src/utils/to-peer-pb.js
async function toPeerPB(peerId, data, strategy, options) {
  var _a12, _b4;
  if (data == null) {
    throw new InvalidParametersError("Invalid PeerData");
  }
  if (data.publicKey != null && peerId.publicKey != null && !data.publicKey.equals(peerId.publicKey)) {
    throw new InvalidParametersError("publicKey bytes do not match peer id publicKey bytes");
  }
  const existingPeer = (_a12 = options.existingPeer) == null ? void 0 : _a12.peer;
  if (existingPeer != null && !peerId.equals(existingPeer.id)) {
    throw new InvalidParametersError("peer id did not match existing peer id");
  }
  let addresses = (existingPeer == null ? void 0 : existingPeer.addresses) ?? [];
  let protocols = new Set((existingPeer == null ? void 0 : existingPeer.protocols) ?? []);
  let metadata = (existingPeer == null ? void 0 : existingPeer.metadata) ?? /* @__PURE__ */ new Map();
  let tags = (existingPeer == null ? void 0 : existingPeer.tags) ?? /* @__PURE__ */ new Map();
  let peerRecordEnvelope2 = existingPeer == null ? void 0 : existingPeer.peerRecordEnvelope;
  if (strategy === "patch") {
    if (data.multiaddrs != null || data.addresses != null) {
      addresses = [];
      if (data.multiaddrs != null) {
        addresses.push(...data.multiaddrs.map((multiaddr2) => ({
          isCertified: false,
          multiaddr: multiaddr2
        })));
      }
      if (data.addresses != null) {
        addresses.push(...data.addresses);
      }
    }
    if (data.protocols != null) {
      protocols = new Set(data.protocols);
    }
    if (data.metadata != null) {
      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
      metadata = createSortedMap(metadataEntries, {
        validate: validateMetadata
      });
    }
    if (data.tags != null) {
      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
      tags = createSortedMap(tagsEntries, {
        validate: validateTag,
        map: mapTag
      });
    }
    if (data.peerRecordEnvelope != null) {
      peerRecordEnvelope2 = data.peerRecordEnvelope;
    }
  }
  if (strategy === "merge") {
    if (data.multiaddrs != null) {
      addresses.push(...data.multiaddrs.map((multiaddr2) => ({
        isCertified: false,
        multiaddr: multiaddr2
      })));
    }
    if (data.addresses != null) {
      addresses.push(...data.addresses);
    }
    if (data.protocols != null) {
      protocols = /* @__PURE__ */ new Set([...protocols, ...data.protocols]);
    }
    if (data.metadata != null) {
      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
      for (const [key, value] of metadataEntries) {
        if (value == null) {
          metadata.delete(key);
        } else {
          metadata.set(key, value);
        }
      }
      metadata = createSortedMap([...metadata.entries()], {
        validate: validateMetadata
      });
    }
    if (data.tags != null) {
      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
      const mergedTags = new Map(tags);
      for (const [key, value] of tagsEntries) {
        if (value == null) {
          mergedTags.delete(key);
        } else {
          mergedTags.set(key, value);
        }
      }
      tags = createSortedMap([...mergedTags.entries()], {
        validate: validateTag,
        map: mapTag
      });
    }
    if (data.peerRecordEnvelope != null) {
      peerRecordEnvelope2 = data.peerRecordEnvelope;
    }
  }
  let publicKey;
  if ((existingPeer == null ? void 0 : existingPeer.id.publicKey) != null) {
    publicKey = publicKeyToProtobuf(existingPeer.id.publicKey);
  } else if (data.publicKey != null) {
    publicKey = publicKeyToProtobuf(data.publicKey);
  } else if (peerId.publicKey != null) {
    publicKey = publicKeyToProtobuf(peerId.publicKey);
  }
  const output = {
    addresses: await dedupeFilterAndSortAddresses(peerId, options.addressFilter ?? (async () => true), addresses, (_b4 = options.existingPeer) == null ? void 0 : _b4.peerPB.addresses, options),
    protocols: [...protocols.values()].sort((a, b) => {
      return a.localeCompare(b);
    }),
    metadata,
    tags,
    publicKey,
    peerRecordEnvelope: peerRecordEnvelope2
  };
  output.addresses.forEach((addr) => {
    var _a13, _b5, _c2;
    addr.observed = ((_c2 = (_b5 = (_a13 = options.existingPeer) == null ? void 0 : _a13.peerPB.addresses) == null ? void 0 : _b5.find((addr2) => equals(addr2.multiaddr, addr2.multiaddr))) == null ? void 0 : _c2.observed) ?? Date.now();
  });
  if (peerId.type !== "RSA") {
    delete output.publicKey;
  }
  return output;
}
function createSortedMap(entries, options) {
  var _a12;
  const output = /* @__PURE__ */ new Map();
  for (const [key, value] of entries) {
    if (value == null) {
      continue;
    }
    options.validate(key, value);
  }
  for (const [key, value] of entries.sort(([a], [b]) => {
    return a.localeCompare(b);
  })) {
    if (value != null) {
      output.set(key, ((_a12 = options.map) == null ? void 0 : _a12.call(options, key, value)) ?? value);
    }
  }
  return output;
}
function validateMetadata(key, value) {
  if (typeof key !== "string") {
    throw new InvalidParametersError("Metadata key must be a string");
  }
  if (!(value instanceof Uint8Array)) {
    throw new InvalidParametersError("Metadata value must be a Uint8Array");
  }
}
function validateTag(key, tag) {
  if (typeof key !== "string") {
    throw new InvalidParametersError("Tag name must be a string");
  }
  if (tag.value != null) {
    if (parseInt(`${tag.value}`, 10) !== tag.value) {
      throw new InvalidParametersError("Tag value must be an integer");
    }
    if (tag.value < 0 || tag.value > 100) {
      throw new InvalidParametersError("Tag value must be between 0-100");
    }
  }
  if (tag.ttl != null) {
    if (parseInt(`${tag.ttl}`, 10) !== tag.ttl) {
      throw new InvalidParametersError("Tag ttl must be an integer");
    }
    if (tag.ttl < 0) {
      throw new InvalidParametersError("Tag ttl must be between greater than 0");
    }
  }
}
function mapTag(key, tag) {
  let expiry;
  if (tag.expiry != null) {
    expiry = tag.expiry;
  }
  if (tag.ttl != null) {
    expiry = BigInt(Date.now() + Number(tag.ttl));
  }
  const output = {
    value: tag.value ?? 0
  };
  if (expiry != null) {
    output.expiry = expiry;
  }
  return output;
}

// ../../node_modules/@libp2p/peer-store/dist/src/store.js
function keyToPeerId(key) {
  const base32Str = key.toString().split("/")[2];
  const buf = CID.parse(base32Str, base32);
  return peerIdFromCID(buf);
}
function decodePeer(key, value, maxAddressAge) {
  const peerId = keyToPeerId(key);
  return bytesToPeer(peerId, value, maxAddressAge);
}
function mapQuery(query, maxAddressAge) {
  return {
    prefix: NAMESPACE_COMMON,
    filters: (query.filters ?? []).map((fn) => ({ key, value }) => {
      return fn(decodePeer(key, value, maxAddressAge));
    }),
    orders: (query.orders ?? []).map((fn) => (a, b) => {
      return fn(decodePeer(a.key, a.value, maxAddressAge), decodePeer(b.key, b.value, maxAddressAge));
    })
  };
}
var _PersistentStore_instances, findExistingPeer_fn, saveIfDifferent_fn, peerIsExpired_fn;
var PersistentStore = class {
  constructor(components, init = {}) {
    __privateAdd(this, _PersistentStore_instances);
    __publicField(this, "peerId");
    __publicField(this, "datastore");
    __publicField(this, "locks");
    __publicField(this, "addressFilter");
    __publicField(this, "log");
    __publicField(this, "maxAddressAge");
    __publicField(this, "maxPeerAge");
    this.log = components.logger.forComponent("libp2p:peer-store");
    this.peerId = components.peerId;
    this.datastore = components.datastore;
    this.addressFilter = init.addressFilter;
    this.locks = trackedPeerMap({
      name: "libp2p_peer_store_locks",
      metrics: components.metrics
    });
    this.maxAddressAge = init.maxAddressAge ?? MAX_ADDRESS_AGE;
    this.maxPeerAge = init.maxPeerAge ?? MAX_PEER_AGE;
  }
  getLock(peerId) {
    let lock = this.locks.get(peerId);
    if (lock == null) {
      lock = {
        refs: 0,
        lock: createMortice({
          name: peerId.toString(),
          singleProcess: true
        })
      };
      this.locks.set(peerId, lock);
    }
    lock.refs++;
    return lock;
  }
  maybeRemoveLock(peerId, lock) {
    lock.refs--;
    if (lock.refs === 0) {
      lock.lock.finalize();
      this.locks.delete(peerId);
    }
  }
  async getReadLock(peerId, options) {
    const lock = this.getLock(peerId);
    try {
      const release = await lock.lock.readLock(options);
      return () => {
        release();
        this.maybeRemoveLock(peerId, lock);
      };
    } catch (err) {
      this.maybeRemoveLock(peerId, lock);
      throw err;
    }
  }
  async getWriteLock(peerId, options) {
    const lock = this.getLock(peerId);
    try {
      const release = await lock.lock.writeLock(options);
      return () => {
        release();
        this.maybeRemoveLock(peerId, lock);
      };
    } catch (err) {
      this.maybeRemoveLock(peerId, lock);
      throw err;
    }
  }
  async has(peerId, options) {
    try {
      await this.load(peerId, options);
      return true;
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
    }
    return false;
  }
  async delete(peerId, options) {
    if (this.peerId.equals(peerId)) {
      return;
    }
    await this.datastore.delete(peerIdToDatastoreKey(peerId), options);
  }
  async load(peerId, options) {
    const key = peerIdToDatastoreKey(peerId);
    const buf = await this.datastore.get(key, options);
    const peer = Peer.decode(buf);
    if (__privateMethod(this, _PersistentStore_instances, peerIsExpired_fn).call(this, peerId, peer)) {
      await this.datastore.delete(key, options);
      throw new NotFoundError();
    }
    return pbToPeer(peerId, peer, this.peerId.equals(peerId) ? Infinity : this.maxAddressAge);
  }
  async save(peerId, data, options) {
    const existingPeer = await __privateMethod(this, _PersistentStore_instances, findExistingPeer_fn).call(this, peerId, options);
    const peerPb = await toPeerPB(peerId, data, "patch", {
      ...options,
      addressFilter: this.addressFilter
    });
    return __privateMethod(this, _PersistentStore_instances, saveIfDifferent_fn).call(this, peerId, peerPb, existingPeer);
  }
  async patch(peerId, data, options) {
    const existingPeer = await __privateMethod(this, _PersistentStore_instances, findExistingPeer_fn).call(this, peerId, options);
    const peerPb = await toPeerPB(peerId, data, "patch", {
      ...options,
      addressFilter: this.addressFilter,
      existingPeer
    });
    return __privateMethod(this, _PersistentStore_instances, saveIfDifferent_fn).call(this, peerId, peerPb, existingPeer);
  }
  async merge(peerId, data, options) {
    const existingPeer = await __privateMethod(this, _PersistentStore_instances, findExistingPeer_fn).call(this, peerId, options);
    const peerPb = await toPeerPB(peerId, data, "merge", {
      addressFilter: this.addressFilter,
      existingPeer
    });
    return __privateMethod(this, _PersistentStore_instances, saveIfDifferent_fn).call(this, peerId, peerPb, existingPeer);
  }
  async *all(options) {
    for await (const { key, value } of this.datastore.query(mapQuery(options ?? {}, this.maxAddressAge), options)) {
      const peerId = keyToPeerId(key);
      if (peerId.equals(this.peerId)) {
        continue;
      }
      const peer = Peer.decode(value);
      if (__privateMethod(this, _PersistentStore_instances, peerIsExpired_fn).call(this, peerId, peer)) {
        await this.datastore.delete(key, options);
        continue;
      }
      yield pbToPeer(peerId, peer, this.peerId.equals(peerId) ? Infinity : this.maxAddressAge);
    }
  }
};
_PersistentStore_instances = new WeakSet();
findExistingPeer_fn = async function(peerId, options) {
  try {
    const key = peerIdToDatastoreKey(peerId);
    const buf = await this.datastore.get(key, options);
    const peerPB = Peer.decode(buf);
    if (__privateMethod(this, _PersistentStore_instances, peerIsExpired_fn).call(this, peerId, peerPB)) {
      await this.datastore.delete(key, options);
      throw new NotFoundError();
    }
    return {
      peerPB,
      peer: pbToPeer(peerId, peerPB, this.maxAddressAge)
    };
  } catch (err) {
    if (err.name !== "NotFoundError") {
      this.log.error("invalid peer data found in peer store - %e", err);
    }
  }
};
saveIfDifferent_fn = async function(peerId, peer, existingPeer, options) {
  peer.updated = Date.now();
  const buf = Peer.encode(peer);
  await this.datastore.put(peerIdToDatastoreKey(peerId), buf, options);
  return {
    peer: pbToPeer(peerId, peer, this.maxAddressAge),
    previous: existingPeer == null ? void 0 : existingPeer.peer,
    updated: existingPeer == null || !peerEquals(peer, existingPeer.peerPB)
  };
};
peerIsExpired_fn = function(peerId, peer) {
  if (peer.updated == null) {
    return true;
  }
  if (this.peerId.equals(peerId)) {
    return false;
  }
  const expired = peer.updated < Date.now() - this.maxPeerAge;
  const minAddressObserved = Date.now() - this.maxAddressAge;
  const addrs = peer.addresses.filter((addr) => {
    return addr.observed != null && addr.observed > minAddressObserved;
  });
  return expired && addrs.length === 0;
};

// ../../node_modules/@libp2p/peer-store/dist/src/index.js
var _a, _PersistentPeerStore_instances, emitIfUpdated_fn;
_a = Symbol.toStringTag;
var PersistentPeerStore = class {
  constructor(components, init = {}) {
    __privateAdd(this, _PersistentPeerStore_instances);
    __publicField(this, "store");
    __publicField(this, "events");
    __publicField(this, "peerId");
    __publicField(this, "log");
    __publicField(this, _a, "@libp2p/peer-store");
    this.log = components.logger.forComponent("libp2p:peer-store");
    this.events = components.events;
    this.peerId = components.peerId;
    this.store = new PersistentStore(components, init);
  }
  async forEach(fn, query) {
    for await (const peer of this.store.all(query)) {
      fn(peer);
    }
  }
  async all(query) {
    return src_default3(this.store.all(query));
  }
  async delete(peerId, options) {
    const release = await this.store.getReadLock(peerId, options);
    try {
      await this.store.delete(peerId, options);
    } finally {
      release();
    }
  }
  async has(peerId, options) {
    const release = await this.store.getReadLock(peerId, options);
    try {
      return await this.store.has(peerId, options);
    } finally {
      this.log.trace("has release read lock");
      release == null ? void 0 : release();
    }
  }
  async get(peerId, options) {
    const release = await this.store.getReadLock(peerId, options);
    try {
      return await this.store.load(peerId, options);
    } finally {
      release == null ? void 0 : release();
    }
  }
  async getInfo(peerId, options) {
    const peer = await this.get(peerId, options);
    return {
      id: peer.id,
      multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
    };
  }
  async save(id, data, options) {
    const release = await this.store.getWriteLock(id, options);
    try {
      const result = await this.store.save(id, data, options);
      __privateMethod(this, _PersistentPeerStore_instances, emitIfUpdated_fn).call(this, id, result);
      return result.peer;
    } finally {
      release == null ? void 0 : release();
    }
  }
  async patch(id, data, options) {
    const release = await this.store.getWriteLock(id, options);
    try {
      const result = await this.store.patch(id, data, options);
      __privateMethod(this, _PersistentPeerStore_instances, emitIfUpdated_fn).call(this, id, result);
      return result.peer;
    } finally {
      release == null ? void 0 : release();
    }
  }
  async merge(id, data, options) {
    const release = await this.store.getWriteLock(id, options);
    try {
      const result = await this.store.merge(id, data, options);
      __privateMethod(this, _PersistentPeerStore_instances, emitIfUpdated_fn).call(this, id, result);
      return result.peer;
    } finally {
      release == null ? void 0 : release();
    }
  }
  async consumePeerRecord(buf, arg1, arg2) {
    const expectedPeer = isPeerId(arg1) ? arg1 : isPeerId(arg1 == null ? void 0 : arg1.expectedPeer) ? arg1.expectedPeer : void 0;
    const options = isPeerId(arg1) ? arg2 : arg1 === void 0 ? arg2 : arg1;
    const envelope = await RecordEnvelope.openAndCertify(buf, PeerRecord.DOMAIN, options);
    const peerId = peerIdFromCID(envelope.publicKey.toCID());
    if ((expectedPeer == null ? void 0 : expectedPeer.equals(peerId)) === false) {
      this.log("envelope peer id was not the expected peer id - expected: %p received: %p", expectedPeer, peerId);
      return false;
    }
    const peerRecord = PeerRecord.createFromProtobuf(envelope.payload);
    let peer;
    try {
      peer = await this.get(peerId, options);
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
    }
    if ((peer == null ? void 0 : peer.peerRecordEnvelope) != null) {
      const storedEnvelope = RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope);
      const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload);
      if (storedRecord.seqNumber >= peerRecord.seqNumber) {
        this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
        return false;
      }
    }
    await this.patch(peerRecord.peerId, {
      peerRecordEnvelope: buf,
      addresses: peerRecord.multiaddrs.map((multiaddr2) => ({
        isCertified: true,
        multiaddr: multiaddr2
      }))
    }, options);
    return true;
  }
};
_PersistentPeerStore_instances = new WeakSet();
emitIfUpdated_fn = function(id, result) {
  if (!result.updated) {
    return;
  }
  if (this.peerId.equals(id)) {
    this.events.safeDispatchEvent("self:peer:update", { detail: result });
  } else {
    this.events.safeDispatchEvent("peer:update", { detail: result });
  }
};
function persistentPeerStore(components, init = {}) {
  return new PersistentPeerStore(components, init);
}

// ../../node_modules/interface-store/dist/src/errors.js
var _NotFoundError = class _NotFoundError extends Error {
  constructor(message2 = "Not Found") {
    super(message2);
    __publicField(this, "name", _NotFoundError.name);
    __publicField(this, "code", _NotFoundError.code);
  }
};
__publicField(_NotFoundError, "name", "NotFoundError");
__publicField(_NotFoundError, "code", "ERR_NOT_FOUND");
var NotFoundError2 = _NotFoundError;

// ../../node_modules/it-peekable/dist/src/index.js
function peekable(iterable) {
  const [iterator, symbol] = iterable[Symbol.asyncIterator] != null ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
  const queue = [];
  return {
    peek: () => {
      return iterator.next();
    },
    push: (value) => {
      queue.push(value);
    },
    next: () => {
      if (queue.length > 0) {
        return {
          done: false,
          value: queue.shift()
        };
      }
      return iterator.next();
    },
    [symbol]() {
      return this;
    }
  };
}
var src_default4 = peekable;

// ../../node_modules/it-filter/dist/src/index.js
function isAsyncIterable2(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function filter(source, fn) {
  let index = 0;
  if (isAsyncIterable2(source)) {
    return (async function* () {
      for await (const entry of source) {
        if (await fn(entry, index++)) {
          yield entry;
        }
      }
    })();
  }
  const peekable2 = src_default4(source);
  const { value, done } = peekable2.next();
  if (done === true) {
    return (function* () {
    })();
  }
  const res = fn(value, index++);
  if (typeof res.then === "function") {
    return (async function* () {
      if (await res) {
        yield value;
      }
      for (const entry of peekable2) {
        if (await fn(entry, index++)) {
          yield entry;
        }
      }
    })();
  }
  const func = fn;
  return (function* () {
    if (res === true) {
      yield value;
    }
    for (const entry of peekable2) {
      if (func(entry, index++)) {
        yield entry;
      }
    }
  })();
}
var src_default5 = filter;

// ../../node_modules/it-sort/dist/src/index.js
function isAsyncIterable3(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function sort(source, sorter) {
  if (isAsyncIterable3(source)) {
    return (async function* () {
      const arr = await src_default3(source);
      yield* arr.sort(sorter);
    })();
  }
  return (function* () {
    const arr = src_default3(source);
    yield* arr.sort(sorter);
  })();
}
var src_default6 = sort;

// ../../node_modules/it-take/dist/src/index.js
function isAsyncIterable4(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function take(source, limit) {
  if (isAsyncIterable4(source)) {
    return (async function* () {
      let items = 0;
      if (limit < 1) {
        return;
      }
      for await (const entry of source) {
        yield entry;
        items++;
        if (items === limit) {
          return;
        }
      }
    })();
  }
  return (function* () {
    let items = 0;
    if (limit < 1) {
      return;
    }
    for (const entry of source) {
      yield entry;
      items++;
      if (items === limit) {
        return;
      }
    }
  })();
}
var src_default7 = take;

// ../../node_modules/datastore-core/dist/src/base.js
var BaseDatastore = class {
  put(key, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(key, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(key, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(key, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(source, options = {}) {
    for await (const { key, value } of source) {
      await this.put(key, value, options);
      yield key;
    }
  }
  async *getMany(source, options = {}) {
    for await (const key of source) {
      yield {
        key,
        value: await this.get(key, options)
      };
    }
  }
  async *deleteMany(source, options = {}) {
    for await (const key of source) {
      await this.delete(key, options);
      yield key;
    }
  }
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value) {
        puts.push({ key, value });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options) => {
        await src_default2(this.putMany(puts, options));
        puts = [];
        await src_default2(this.deleteMany(dels, options));
        dels = [];
      }
    };
  }
  /**
   * Extending classes should override `query` or implement this method
   */
  // eslint-disable-next-line require-yield
  async *_all(q, options) {
    throw new Error("._all is not implemented");
  }
  /**
   * Extending classes should override `queryKeys` or implement this method
   */
  // eslint-disable-next-line require-yield
  async *_allKeys(q, options) {
    throw new Error("._allKeys is not implemented");
  }
  query(q, options) {
    let it = this._all(q, options);
    if (q.prefix != null) {
      const prefix = q.prefix;
      it = src_default5(it, (e) => e.key.toString().startsWith(prefix));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => src_default5(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => src_default6(it2, f), it);
    }
    if (q.offset != null) {
      let i = 0;
      const offset = q.offset;
      it = src_default5(it, () => i++ >= offset);
    }
    if (q.limit != null) {
      it = src_default7(it, q.limit);
    }
    return it;
  }
  queryKeys(q, options) {
    let it = this._allKeys(q, options);
    if (q.prefix != null) {
      const prefix = q.prefix;
      it = src_default5(it, (key) => key.toString().startsWith(prefix));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => src_default5(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => src_default6(it2, f), it);
    }
    if (q.offset != null) {
      const offset = q.offset;
      let i = 0;
      it = src_default5(it, () => i++ >= offset);
    }
    if (q.limit != null) {
      it = src_default7(it, q.limit);
    }
    return it;
  }
};

// ../../node_modules/datastore-core/dist/src/memory.js
var MemoryDatastore = class extends BaseDatastore {
  constructor() {
    super();
    __publicField(this, "data");
    this.data = /* @__PURE__ */ new Map();
  }
  put(key, val, options) {
    var _a12;
    (_a12 = options == null ? void 0 : options.signal) == null ? void 0 : _a12.throwIfAborted();
    this.data.set(key.toString(), val);
    return key;
  }
  get(key, options) {
    var _a12;
    (_a12 = options == null ? void 0 : options.signal) == null ? void 0 : _a12.throwIfAborted();
    const result = this.data.get(key.toString());
    if (result == null) {
      throw new NotFoundError2();
    }
    return result;
  }
  has(key, options) {
    var _a12;
    (_a12 = options == null ? void 0 : options.signal) == null ? void 0 : _a12.throwIfAborted();
    return this.data.has(key.toString());
  }
  delete(key, options) {
    var _a12;
    (_a12 = options == null ? void 0 : options.signal) == null ? void 0 : _a12.throwIfAborted();
    this.data.delete(key.toString());
  }
  *_all(q, options) {
    var _a12, _b4;
    (_a12 = options == null ? void 0 : options.signal) == null ? void 0 : _a12.throwIfAborted();
    for (const [key, value] of this.data.entries()) {
      yield { key: new Key(key), value };
      (_b4 = options == null ? void 0 : options.signal) == null ? void 0 : _b4.throwIfAborted();
    }
  }
  *_allKeys(q, options) {
    var _a12, _b4;
    (_a12 = options == null ? void 0 : options.signal) == null ? void 0 : _a12.throwIfAborted();
    for (const key of this.data.keys()) {
      yield new Key(key);
      (_b4 = options == null ? void 0 : options.signal) == null ? void 0 : _b4.throwIfAborted();
    }
  }
};

// ../../node_modules/libp2p/dist/src/address-manager/dns-mappings.js
var MAX_DATE = 864e13;
var DNSMappings = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "mappings");
    this.log = components.logger.forComponent("libp2p:address-manager:dns-mappings");
    this.mappings = trackedMap({
      name: "libp2p_address_manager_dns_mappings",
      metrics: components.metrics
    });
  }
  has(ma) {
    const config = getNetConfig(ma);
    let host = config.host;
    if ((config.type === "ip4" || config.type === "ip6") && config.sni != null) {
      host = config.sni;
    }
    for (const mapping of this.mappings.values()) {
      if (mapping.domain === host) {
        return true;
      }
    }
    return false;
  }
  add(domain, addresses) {
    addresses.forEach((ip) => {
      this.log("add DNS mapping %s to %s", ip, domain);
      const verified = isPrivateIp(ip) === true;
      this.mappings.set(ip, {
        domain,
        verified,
        expires: verified ? MAX_DATE - Date.now() : 0,
        lastVerified: verified ? MAX_DATE - Date.now() : void 0
      });
    });
  }
  remove(ma) {
    const config = getNetConfig(ma);
    if (config.type !== "ip4" && config.type !== "ip6") {
      return false;
    }
    let wasConfident = false;
    for (const [ip, mapping] of this.mappings.entries()) {
      if (mapping.domain === config.sni) {
        this.log("removing %s to %s DNS mapping %e", ip, mapping.domain);
        this.mappings.delete(ip);
        wasConfident = wasConfident || mapping.verified;
      }
    }
    return wasConfident;
  }
  getAll(addresses) {
    const dnsMappedAddresses = [];
    for (let i = 0; i < addresses.length; i++) {
      const address = addresses[i].multiaddr;
      if (!isNetworkAddress(address)) {
        continue;
      }
      const config = getNetConfig(address);
      for (const [ip, mapping] of this.mappings.entries()) {
        if (config.host !== ip) {
          continue;
        }
        const maWithSni = this.maybeAddSNIComponent(address, mapping.domain);
        if (maWithSni != null) {
          addresses.splice(i, 1);
          i--;
          dnsMappedAddresses.push({
            multiaddr: maWithSni,
            verified: mapping.verified,
            type: "dns-mapping",
            expires: mapping.expires,
            lastVerified: mapping.lastVerified
          });
        }
      }
    }
    return dnsMappedAddresses;
  }
  maybeAddSNIComponent(ma, domain) {
    var _a12;
    const components = ma.getComponents();
    for (let j = 0; j < components.length; j++) {
      if (components[j].code === CODE_TLS && ((_a12 = components[j + 1]) == null ? void 0 : _a12.code) !== CODE_SNI) {
        components.splice(j + 1, 0, {
          name: "sni",
          code: CODE_SNI,
          value: domain
        });
        return multiaddr(components);
      }
    }
  }
  confirm(ma, ttl) {
    const config = getNetConfig(ma);
    let host = config.host;
    if ((config.type === "ip4" || config.type === "ip6") && config.sni != null) {
      host = config.sni;
    }
    let startingConfidence = false;
    for (const [ip, mapping] of this.mappings.entries()) {
      if (mapping.domain === host) {
        this.log("marking %s to %s DNS mapping as verified", ip, mapping.domain);
        startingConfidence = mapping.verified;
        mapping.verified = true;
        mapping.expires = Date.now() + ttl;
        mapping.lastVerified = Date.now();
      }
    }
    return startingConfidence;
  }
  unconfirm(ma, ttl) {
    const config = getNetConfig(ma);
    if (config.type !== "ip4" && config.type !== "ip6") {
      return false;
    }
    const host = config.sni ?? config.host;
    let wasConfident = false;
    for (const [ip, mapping] of this.mappings.entries()) {
      if (mapping.domain === host) {
        this.log("removing verification of %s to %s DNS mapping", ip, mapping.domain);
        wasConfident = wasConfident || mapping.verified;
        mapping.verified = false;
        mapping.expires = Date.now() + ttl;
      }
    }
    return wasConfident;
  }
};

// ../../node_modules/libp2p/dist/src/address-manager/ip-mappings.js
var IPMappings = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "mappings");
    this.log = components.logger.forComponent("libp2p:address-manager:ip-mappings");
    this.mappings = trackedMap({
      name: "libp2p_address_manager_ip_mappings",
      metrics: components.metrics
    });
  }
  has(ma) {
    const config = getNetConfig(ma);
    if (config.type !== "ip4" && config.type !== "ip6") {
      return false;
    }
    for (const mappings of this.mappings.values()) {
      for (const mapping of mappings) {
        if (mapping.externalIp === config.host) {
          return true;
        }
      }
    }
    return false;
  }
  add(internalIp, internalPort, externalIp, externalPort = internalPort, protocol = "tcp") {
    const key = `${internalIp}-${internalPort}-${protocol}`;
    const mappings = this.mappings.get(key) ?? [];
    const mapping = {
      internalIp,
      internalPort,
      externalIp,
      externalPort,
      externalFamily: isIPv4(externalIp) ? 4 : 6,
      protocol,
      verified: false,
      expires: 0
    };
    mappings.push(mapping);
    this.mappings.set(key, mappings);
  }
  remove(ma) {
    const config = getNetConfig(ma);
    if (config.type !== "ip4" && config.type !== "ip6") {
      return false;
    }
    let wasConfident = false;
    for (const [key, mappings] of this.mappings.entries()) {
      for (let i = 0; i < mappings.length; i++) {
        const mapping = mappings[i];
        if (mapping.externalIp === config.host && mapping.externalPort === config.port && mapping.protocol === config.protocol) {
          this.log("removing %s:%s to %s:%s %s IP mapping", mapping.externalIp, mapping.externalPort, config.host, config.port, config.protocol);
          wasConfident = wasConfident || mapping.verified;
          mappings.splice(i, 1);
          i--;
        }
      }
      if (mappings.length === 0) {
        this.mappings.delete(key);
      }
    }
    return wasConfident;
  }
  getAll(addresses) {
    const ipMappedAddresses = [];
    for (const { multiaddr: ma } of addresses) {
      if (!isNetworkAddress(ma)) {
        continue;
      }
      const config = getNetConfig(ma);
      if (config.type !== "ip4" && config.type !== "ip6") {
        continue;
      }
      let key;
      if (config.protocol === "tcp") {
        key = `${config.host}-${config.port}-tcp`;
      } else if (config.protocol === "udp") {
        key = `${config.host}-${config.port}-udp`;
      }
      if (key == null) {
        continue;
      }
      const mappings = this.mappings.get(key);
      if (mappings == null) {
        continue;
      }
      for (const mapping of mappings) {
        ipMappedAddresses.push({
          multiaddr: this.maybeOverrideIp(ma, mapping.externalIp, mapping.externalFamily, mapping.protocol, mapping.externalPort),
          verified: mapping.verified,
          type: "ip-mapping",
          expires: mapping.expires,
          lastVerified: mapping.lastVerified
        });
      }
    }
    return ipMappedAddresses;
  }
  maybeOverrideIp(ma, externalIp, externalFamily, protocol, externalPort) {
    const components = ma.getComponents();
    const ipIndex = components.findIndex((c) => c.code === CODE_IP4 || c.code === CODE_IP6);
    const portIndex = components.findIndex((c) => c.name === protocol);
    if (ipIndex > -1 && portIndex > -1) {
      components[ipIndex].value = externalIp;
      components[ipIndex].code = externalFamily === 4 ? CODE_IP4 : CODE_IP6;
      components[portIndex].value = `${externalPort}`;
      return multiaddr(components);
    }
    return ma;
  }
  confirm(ma, ttl) {
    if (!isNetworkAddress(ma)) {
      return false;
    }
    const config = getNetConfig(ma);
    let startingConfidence = false;
    for (const mappings of this.mappings.values()) {
      for (const mapping of mappings) {
        if (mapping.externalIp === config.host) {
          this.log("marking %s to %s IP mapping as verified", mapping.internalIp, mapping.externalIp);
          startingConfidence = mapping.verified;
          mapping.verified = true;
          mapping.expires = Date.now() + ttl;
          mapping.lastVerified = Date.now();
        }
      }
    }
    return startingConfidence;
  }
  unconfirm(ma, ttl) {
    if (!isNetworkAddress(ma)) {
      return false;
    }
    const config = getNetConfig(ma);
    let wasConfident = false;
    for (const mappings of this.mappings.values()) {
      for (let i = 0; i < mappings.length; i++) {
        const mapping = mappings[i];
        if (mapping.externalIp === config.host && mapping.externalPort === config.port && mapping.protocol === config.protocol) {
          this.log("removing verification of %s:%s to %s:%s %s IP mapping", mapping.externalIp, mapping.externalPort, config.host, config.port, config.protocol);
          wasConfident = wasConfident || mapping.verified;
          mapping.verified = false;
          mapping.expires = Date.now() + ttl;
        }
      }
    }
    return wasConfident;
  }
};

// ../../node_modules/libp2p/dist/src/address-manager/observed-addresses.js
var defaultValues = {
  maxObservedAddresses: 10
};
var ObservedAddresses = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "addresses");
    __publicField(this, "maxObservedAddresses");
    this.log = components.logger.forComponent("libp2p:address-manager:observed-addresses");
    this.addresses = trackedMap({
      name: "libp2p_address_manager_observed_addresses",
      metrics: components.metrics
    });
    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues.maxObservedAddresses;
  }
  has(ma) {
    return this.addresses.has(ma.toString());
  }
  removePrefixed(prefix) {
    for (const key of this.addresses.keys()) {
      if (key.toString().startsWith(prefix)) {
        this.addresses.delete(key);
      }
    }
  }
  add(ma) {
    if (this.addresses.size === this.maxObservedAddresses) {
      return;
    }
    if (isPrivate(ma) || isLinkLocal(ma)) {
      return;
    }
    this.log("adding observed address %a", ma);
    this.addresses.set(ma.toString(), {
      verified: false,
      expires: 0
    });
  }
  getAll() {
    return Array.from(this.addresses).map(([ma, metadata]) => ({
      multiaddr: multiaddr(ma),
      verified: metadata.verified,
      type: "observed",
      expires: metadata.expires,
      lastVerified: metadata.lastVerified
    }));
  }
  remove(ma) {
    var _a12;
    const startingConfidence = ((_a12 = this.addresses.get(ma.toString())) == null ? void 0 : _a12.verified) ?? false;
    this.log("removing observed address %a", ma);
    this.addresses.delete(ma.toString());
    return startingConfidence;
  }
  confirm(ma, ttl) {
    const addrString = ma.toString();
    const metadata = this.addresses.get(addrString) ?? {
      verified: false,
      expires: Date.now() + ttl,
      lastVerified: Date.now()
    };
    const startingConfidence = metadata.verified;
    metadata.verified = true;
    metadata.expires = Date.now() + ttl;
    metadata.lastVerified = Date.now();
    this.log("marking observed address %a as verified", addrString);
    this.addresses.set(addrString, metadata);
    return startingConfidence;
  }
};

// ../../node_modules/libp2p/dist/src/address-manager/transport-addresses.js
var defaultValues2 = {
  maxObservedAddresses: 10
};
var TransportAddresses = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "addresses");
    __publicField(this, "maxObservedAddresses");
    this.log = components.logger.forComponent("libp2p:address-manager:observed-addresses");
    this.addresses = trackedMap({
      name: "libp2p_address_manager_transport_addresses",
      metrics: components.metrics
    });
    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues2.maxObservedAddresses;
  }
  get(multiaddr2, ttl) {
    if (isPrivate(multiaddr2)) {
      return {
        multiaddr: multiaddr2,
        verified: true,
        type: "transport",
        expires: Date.now() + ttl,
        lastVerified: Date.now()
      };
    }
    const key = this.toKey(multiaddr2);
    let metadata = this.addresses.get(key);
    if (metadata == null) {
      metadata = {
        verified: !isNetworkAddress(multiaddr2),
        expires: 0
      };
      this.addresses.set(key, metadata);
    }
    return {
      multiaddr: multiaddr2,
      verified: metadata.verified,
      type: "transport",
      expires: metadata.expires,
      lastVerified: metadata.lastVerified
    };
  }
  has(ma) {
    const key = this.toKey(ma);
    return this.addresses.has(key);
  }
  remove(ma) {
    var _a12;
    const key = this.toKey(ma);
    const startingConfidence = ((_a12 = this.addresses.get(key)) == null ? void 0 : _a12.verified) ?? false;
    this.log("removing observed address %a", ma);
    this.addresses.delete(key);
    return startingConfidence;
  }
  confirm(ma, ttl) {
    const key = this.toKey(ma);
    const metadata = this.addresses.get(key) ?? {
      verified: false,
      expires: 0,
      lastVerified: 0
    };
    const startingConfidence = metadata.verified;
    metadata.verified = true;
    metadata.expires = Date.now() + ttl;
    metadata.lastVerified = Date.now();
    this.addresses.set(key, metadata);
    return startingConfidence;
  }
  unconfirm(ma, ttl) {
    const key = this.toKey(ma);
    const metadata = this.addresses.get(key) ?? {
      verified: false,
      expires: 0
    };
    const startingConfidence = metadata.verified;
    metadata.verified = false;
    metadata.expires = Date.now() + ttl;
    this.addresses.set(key, metadata);
    return startingConfidence;
  }
  toKey(ma) {
    if (!isNetworkAddress(ma)) {
      return ma.toString();
    }
    const config = getNetConfig(ma);
    return `${config.host}-${config.port}-${config.protocol}`;
  }
};

// ../../node_modules/libp2p/dist/src/address-manager/index.js
var ONE_MINUTE = 6e4;
var defaultValues3 = {
  maxObservedAddresses: 10,
  addressVerificationTTL: ONE_MINUTE * 10,
  addressVerificationRetry: ONE_MINUTE * 5
};
var defaultAddressFilter = (addrs) => addrs;
function stripPeerId(ma, peerId) {
  var _a12;
  const observedPeerIdStr = (_a12 = ma.getComponents().findLast((c) => c.code === CODE_P2P)) == null ? void 0 : _a12.value;
  if (observedPeerIdStr != null) {
    const observedPeerId = peerIdFromString(observedPeerIdStr);
    if (observedPeerId.equals(peerId)) {
      ma = ma.decapsulate(multiaddr(`/p2p/${peerId.toString()}`));
    }
  }
  return ma;
}
var _a2;
_a2 = Symbol.toStringTag;
var AddressManager = class {
  /**
   * Responsible for managing the peer addresses.
   * Peers can specify their listen and announce addresses.
   * The listen addresses will be used by the libp2p transports to listen for new connections,
   * while the announce addresses will be used for the peer addresses' to other peers in the network.
   */
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "components");
    // this is an array to allow for duplicates, e.g. multiples of `/ip4/0.0.0.0/tcp/0`
    __publicField(this, "listen");
    __publicField(this, "announce");
    __publicField(this, "appendAnnounce");
    __publicField(this, "announceFilter");
    __publicField(this, "observed");
    __publicField(this, "dnsMappings");
    __publicField(this, "ipMappings");
    __publicField(this, "transportAddresses");
    __publicField(this, "observedAddressFilter");
    __publicField(this, "addressVerificationTTL");
    __publicField(this, "addressVerificationRetry");
    __publicField(this, _a2, "@libp2p/address-manager");
    const { listen = [], announce = [], appendAnnounce = [] } = init;
    this.components = components;
    this.log = components.logger.forComponent("libp2p:address-manager");
    this.listen = listen.map((ma) => ma.toString());
    this.announce = new Set(announce.map((ma) => ma.toString()));
    this.appendAnnounce = new Set(appendAnnounce.map((ma) => ma.toString()));
    this.observed = new ObservedAddresses(components, init);
    this.dnsMappings = new DNSMappings(components, init);
    this.ipMappings = new IPMappings(components, init);
    this.transportAddresses = new TransportAddresses(components, init);
    this.announceFilter = init.announceFilter ?? defaultAddressFilter;
    this.observedAddressFilter = createScalableCuckooFilter(1024);
    this.addressVerificationTTL = init.addressVerificationTTL ?? defaultValues3.addressVerificationTTL;
    this.addressVerificationRetry = init.addressVerificationRetry ?? defaultValues3.addressVerificationRetry;
    this._updatePeerStoreAddresses = debounce(this._updatePeerStoreAddresses.bind(this), 1e3);
    components.events.addEventListener("transport:listening", () => {
      this._updatePeerStoreAddresses();
    });
    components.events.addEventListener("transport:close", () => {
      this._updatePeerStoreAddresses();
    });
  }
  _updatePeerStoreAddresses() {
    const addrs = this.getAddresses().map((ma) => {
      var _a12;
      if (((_a12 = ma.getComponents().findLast((c) => c.code === CODE_P2P)) == null ? void 0 : _a12.value) === this.components.peerId.toString()) {
        return ma.decapsulate(`/p2p/${this.components.peerId.toString()}`);
      }
      return ma;
    });
    this.components.peerStore.patch(this.components.peerId, {
      multiaddrs: addrs
    }).catch((err) => {
      this.log.error("error updating addresses - %e", err);
    });
  }
  /**
   * Get peer listen multiaddrs
   */
  getListenAddrs() {
    return Array.from(this.listen).map((a) => multiaddr(a));
  }
  /**
   * Get peer announcing multiaddrs
   */
  getAnnounceAddrs() {
    return Array.from(this.announce).map((a) => multiaddr(a));
  }
  /**
   * Get peer announcing multiaddrs
   */
  getAppendAnnounceAddrs() {
    return Array.from(this.appendAnnounce).map((a) => multiaddr(a));
  }
  /**
   * Get observed multiaddrs
   */
  getObservedAddrs() {
    return this.observed.getAll().map((addr) => addr.multiaddr);
  }
  /**
   * Add peer observed addresses
   */
  addObservedAddr(addr) {
    const config = getNetConfig(addr);
    let socketAddress;
    switch (config.type) {
      case "ip4": {
        socketAddress = `${config.host}:${config.port}`;
        break;
      }
      case "ip6": {
        socketAddress = `[${config.host}]:${config.port}`;
        break;
      }
      default: {
        return;
      }
    }
    if (this.observedAddressFilter.has(socketAddress)) {
      return;
    }
    this.observedAddressFilter.add(socketAddress);
    addr = stripPeerId(addr, this.components.peerId);
    if (this.ipMappings.has(addr)) {
      return;
    }
    if (this.dnsMappings.has(addr)) {
      return;
    }
    this.observed.add(addr);
  }
  confirmObservedAddr(addr, options) {
    addr = stripPeerId(addr, this.components.peerId);
    let startingConfidence = true;
    if ((options == null ? void 0 : options.type) === "transport" || this.transportAddresses.has(addr)) {
      const transportStartingConfidence = this.transportAddresses.confirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationTTL);
      if (!transportStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if ((options == null ? void 0 : options.type) === "dns-mapping" || this.dnsMappings.has(addr)) {
      const dnsMappingStartingConfidence = this.dnsMappings.confirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationTTL);
      if (!dnsMappingStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if ((options == null ? void 0 : options.type) === "ip-mapping" || this.ipMappings.has(addr)) {
      const ipMappingStartingConfidence = this.ipMappings.confirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationTTL);
      if (!ipMappingStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if ((options == null ? void 0 : options.type) === "observed" || this.observed.has(addr)) {
      if (this.maybeUpgradeToIPMapping(addr)) {
        this.ipMappings.confirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationTTL);
        startingConfidence = false;
      } else {
        const observedStartingConfidence = this.observed.confirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationTTL);
        if (!observedStartingConfidence && startingConfidence) {
          startingConfidence = false;
        }
      }
    }
    if (!startingConfidence) {
      this._updatePeerStoreAddresses();
    }
  }
  removeObservedAddr(addr, options) {
    addr = stripPeerId(addr, this.components.peerId);
    let startingConfidence = false;
    if (this.observed.has(addr)) {
      const observedStartingConfidence = this.observed.remove(addr);
      if (!observedStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (this.transportAddresses.has(addr)) {
      const transportStartingConfidence = this.transportAddresses.unconfirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationRetry);
      if (!transportStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (this.dnsMappings.has(addr)) {
      const dnsMappingStartingConfidence = this.dnsMappings.unconfirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationRetry);
      if (!dnsMappingStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (this.ipMappings.has(addr)) {
      const ipMappingStartingConfidence = this.ipMappings.unconfirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationRetry);
      if (!ipMappingStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (startingConfidence) {
      this._updatePeerStoreAddresses();
    }
  }
  getAddresses() {
    const addresses = /* @__PURE__ */ new Set();
    const multiaddrs = this.getAddressesWithMetadata().filter((addr) => {
      if (!addr.verified) {
        return false;
      }
      const maStr = addr.multiaddr.toString();
      if (addresses.has(maStr)) {
        return false;
      }
      addresses.add(maStr);
      return true;
    }).map((address) => address.multiaddr);
    return this.announceFilter(multiaddrs.map((str) => {
      const ma = multiaddr(str);
      const lastComponent = ma.getComponents().pop();
      if ((lastComponent == null ? void 0 : lastComponent.value) === this.components.peerId.toString()) {
        return ma;
      }
      return ma.encapsulate(`/p2p/${this.components.peerId.toString()}`);
    }));
  }
  getAddressesWithMetadata() {
    const announceMultiaddrs = this.getAnnounceAddrs();
    if (announceMultiaddrs.length > 0) {
      this.components.transportManager.getListeners().forEach((listener) => {
        listener.updateAnnounceAddrs(announceMultiaddrs);
      });
      return announceMultiaddrs.map((multiaddr2) => ({
        multiaddr: multiaddr2,
        verified: true,
        type: "announce",
        expires: Date.now() + this.addressVerificationTTL,
        lastVerified: Date.now()
      }));
    }
    let addresses = [];
    addresses = addresses.concat(this.components.transportManager.getAddrs().map((multiaddr2) => this.transportAddresses.get(multiaddr2, this.addressVerificationTTL)));
    const appendAnnounceMultiaddrs = this.getAppendAnnounceAddrs();
    if (appendAnnounceMultiaddrs.length > 0) {
      this.components.transportManager.getListeners().forEach((listener) => {
        listener.updateAnnounceAddrs(appendAnnounceMultiaddrs);
      });
      addresses = addresses.concat(appendAnnounceMultiaddrs.map((multiaddr2) => ({
        multiaddr: multiaddr2,
        verified: true,
        type: "announce",
        expires: Date.now() + this.addressVerificationTTL,
        lastVerified: Date.now()
      })));
    }
    addresses = addresses.concat(this.observed.getAll());
    addresses = addresses.concat(this.ipMappings.getAll(addresses));
    addresses = addresses.concat(this.dnsMappings.getAll(addresses));
    return addresses;
  }
  addDNSMapping(domain, addresses) {
    this.dnsMappings.add(domain, addresses);
  }
  removeDNSMapping(domain) {
    if (this.dnsMappings.remove(multiaddr(`/dns/${domain}`))) {
      this._updatePeerStoreAddresses();
    }
  }
  addPublicAddressMapping(internalIp, internalPort, externalIp, externalPort = internalPort, protocol = "tcp") {
    this.ipMappings.add(internalIp, internalPort, externalIp, externalPort, protocol);
    this.observed.removePrefixed(`/ip${isIPv4(externalIp) ? 4 : 6}/${externalIp}/${protocol}/${externalPort}`);
  }
  removePublicAddressMapping(internalIp, internalPort, externalIp, externalPort = internalPort, protocol = "tcp") {
    if (this.ipMappings.remove(multiaddr(`/ip${isIPv4(externalIp) ? 4 : 6}/${externalIp}/${protocol}/${externalPort}`))) {
      this._updatePeerStoreAddresses();
    }
  }
  /**
   * Where an external service (router, gateway, etc) is forwarding traffic to
   * us, attempt to add an IP mapping for the external address - this will
   * include the observed mapping in the address list where we also have a DNS
   * mapping for the external IP.
   *
   * Returns true if we added a new mapping
   */
  maybeUpgradeToIPMapping(ma) {
    if (this.ipMappings.has(ma)) {
      return false;
    }
    if (!isNetworkAddress(ma)) {
      return false;
    }
    const config = getNetConfig(ma);
    if (config.type !== "ip4" || isPrivateIp(config.host) === true) {
      return false;
    }
    const listeners = this.components.transportManager.getListeners();
    const transportMatchers = [
      (ma2) => WebSockets.exactMatch(ma2) || WebSocketsSecure.exactMatch(ma2),
      (ma2) => TCP.exactMatch(ma2),
      (ma2) => QUIC_V1.exactMatch(ma2)
    ];
    for (const matcher of transportMatchers) {
      if (!matcher(ma)) {
        continue;
      }
      const transportListeners = listeners.filter((listener) => {
        return listener.getAddrs().filter((ma2) => {
          return getNetConfig(ma2).type === "ip4" && matcher(ma2);
        }).length > 0;
      });
      if (transportListeners.length !== 1) {
        continue;
      }
      const linkLocalAddr = transportListeners[0].getAddrs().filter((ma2) => {
        return !isLoopback(ma2);
      }).pop();
      if (linkLocalAddr == null) {
        continue;
      }
      const linkLocalOptions = getNetConfig(linkLocalAddr);
      if (linkLocalOptions.port == null) {
        return false;
      }
      this.observed.remove(ma);
      this.ipMappings.add(linkLocalOptions.host, linkLocalOptions.port, config.host, config.port, config.protocol);
      return true;
    }
    return false;
  }
};

// ../../node_modules/libp2p/dist/src/errors.js
var messages;
(function(messages2) {
  messages2["NOT_STARTED_YET"] = "The libp2p node is not started yet";
  messages2["NOT_FOUND"] = "Not found";
})(messages || (messages = {}));
var MissingServiceError = class extends Error {
  constructor(message2 = "Missing service") {
    super(message2);
    this.name = "MissingServiceError";
  }
};
var UnmetServiceDependenciesError = class extends Error {
  constructor(message2 = "Unmet service dependencies") {
    super(message2);
    this.name = "UnmetServiceDependenciesError";
  }
};
var NoContentRoutersError = class extends Error {
  constructor(message2 = "No content routers available") {
    super(message2);
    this.name = "NoContentRoutersError";
  }
};
var NoPeerRoutersError = class extends Error {
  constructor(message2 = "No peer routers available") {
    super(message2);
    this.name = "NoPeerRoutersError";
  }
};
var QueriedForSelfError = class extends Error {
  constructor(message2 = "Should not try to find self") {
    super(message2);
    this.name = "QueriedForSelfError";
  }
};
var UnhandledProtocolError = class extends Error {
  constructor(message2 = "Unhandled protocol error") {
    super(message2);
    this.name = "UnhandledProtocolError";
  }
};
var DuplicateProtocolHandlerError = class extends Error {
  constructor(message2 = "Duplicate protocol handler error") {
    super(message2);
    this.name = "DuplicateProtocolHandlerError";
  }
};
var DialDeniedError = class extends Error {
  constructor(message2 = "Dial denied error") {
    super(message2);
    this.name = "DialDeniedError";
  }
};
var UnsupportedListenAddressError = class extends Error {
  constructor(message2 = "No transport was configured to listen on this address") {
    super(message2);
    this.name = "UnsupportedListenAddressError";
  }
};
var UnsupportedListenAddressesError = class extends Error {
  constructor(message2 = "Configured listen addresses could not be listened on") {
    super(message2);
    this.name = "UnsupportedListenAddressesError";
  }
};
var NoValidAddressesError = class extends Error {
  constructor(message2 = "No valid addresses") {
    super(message2);
    this.name = "NoValidAddressesError";
  }
};
var ConnectionInterceptedError = class extends Error {
  constructor(message2 = "Connection intercepted") {
    super(message2);
    this.name = "ConnectionInterceptedError";
  }
};
var ConnectionDeniedError = class extends Error {
  constructor(message2 = "Connection denied") {
    super(message2);
    this.name = "ConnectionDeniedError";
  }
};
var MuxerUnavailableError = class extends Error {
  constructor(message2 = "Stream is not multiplexed") {
    super(message2);
    this.name = "MuxerUnavailableError";
  }
};
var EncryptionFailedError = class extends Error {
  constructor(message2 = "Encryption failed") {
    super(message2);
    this.name = "EncryptionFailedError";
  }
};
var TransportUnavailableError = class extends Error {
  constructor(message2 = "Transport unavailable") {
    super(message2);
    this.name = "TransportUnavailableError";
  }
};
var RecursionLimitError = class extends Error {
  constructor(message2 = "Max recursive depth reached") {
    super(message2);
    this.name = "RecursionLimitError";
  }
};

// ../../node_modules/libp2p/dist/src/components.js
var DefaultComponents = class {
  constructor(init = {}) {
    __publicField(this, "components", {});
    __publicField(this, "_started", false);
    this.components = {};
    for (const [key, value] of Object.entries(init)) {
      this.components[key] = value;
    }
    if (this.components.logger == null) {
      this.components.logger = defaultLogger();
    }
  }
  isStarted() {
    return this._started;
  }
  async _invokeStartableMethod(methodName) {
    await Promise.all(Object.values(this.components).filter((obj) => isStartable(obj)).map(async (startable) => {
      var _a12;
      await ((_a12 = startable[methodName]) == null ? void 0 : _a12.call(startable));
    }));
  }
  async beforeStart() {
    await this._invokeStartableMethod("beforeStart");
  }
  async start() {
    await this._invokeStartableMethod("start");
    this._started = true;
  }
  async afterStart() {
    await this._invokeStartableMethod("afterStart");
  }
  async beforeStop() {
    await this._invokeStartableMethod("beforeStop");
  }
  async stop() {
    await this._invokeStartableMethod("stop");
    this._started = false;
  }
  async afterStop() {
    await this._invokeStartableMethod("afterStop");
  }
};
var OPTIONAL_SERVICES = [
  "metrics",
  "connectionProtector",
  "dns"
];
var NON_SERVICE_PROPERTIES = [
  "components",
  "isStarted",
  "beforeStart",
  "start",
  "afterStart",
  "beforeStop",
  "stop",
  "afterStop",
  "then",
  "_invokeStartableMethod"
];
function defaultComponents(init = {}) {
  const components = new DefaultComponents(init);
  const proxy = new Proxy(components, {
    get(target, prop, receiver) {
      if (typeof prop === "string" && !NON_SERVICE_PROPERTIES.includes(prop)) {
        const service = components.components[prop];
        if (service == null && !OPTIONAL_SERVICES.includes(prop)) {
          throw new MissingServiceError(`${prop} not set`);
        }
        return service;
      }
      return Reflect.get(target, prop, receiver);
    },
    set(target, prop, value) {
      if (typeof prop === "string") {
        components.components[prop] = value;
      } else {
        Reflect.set(target, prop, value);
      }
      return true;
    }
  });
  return proxy;
}
function checkServiceDependencies(components) {
  const serviceCapabilities2 = {};
  for (const service of Object.values(components.components)) {
    for (const capability of getServiceCapabilities(service)) {
      serviceCapabilities2[capability] = true;
    }
  }
  for (const service of Object.values(components.components)) {
    for (const capability of getServiceDependencies(service)) {
      if (serviceCapabilities2[capability] !== true) {
        throw new UnmetServiceDependenciesError(`Service "${getServiceName(service)}" required capability "${capability}" but it was not provided by any component, you may need to add additional configuration when creating your node.`);
      }
    }
  }
}
function getServiceCapabilities(service) {
  if (Array.isArray(service == null ? void 0 : service[serviceCapabilities])) {
    return service[serviceCapabilities];
  }
  return [];
}
function getServiceDependencies(service) {
  if (Array.isArray(service == null ? void 0 : service[serviceDependencies])) {
    return service[serviceDependencies];
  }
  return [];
}
function getServiceName(service) {
  return (service == null ? void 0 : service[Symbol.toStringTag]) ?? (service == null ? void 0 : service.toString()) ?? "unknown";
}

// ../../node_modules/libp2p/dist/src/config/connection-gater.browser.js
function connectionGater(gater = {}) {
  if (gater.denyDialMultiaddr == null) {
    gater.denyDialMultiaddr = (multiaddr2) => {
      if (WebSockets.matches(multiaddr2)) {
        return true;
      }
      return isPrivate(multiaddr2);
    };
  }
  return gater;
}

// ../../node_modules/libp2p/dist/src/get-peer.js
function getPeerAddress(peer) {
  var _a12;
  if (isPeerId(peer)) {
    return { peerId: peer, multiaddrs: [] };
  }
  let multiaddrs = Array.isArray(peer) ? peer : [peer];
  let peerId;
  if (multiaddrs.length > 0) {
    const peerIdStr = (_a12 = multiaddrs[0].getComponents().findLast((c) => c.code === CODE_P2P)) == null ? void 0 : _a12.value;
    peerId = peerIdStr == null ? void 0 : peerIdFromString(peerIdStr);
    multiaddrs.forEach((ma) => {
      var _a13;
      if (!isMultiaddr(ma)) {
        throw new InvalidMultiaddrError("Invalid multiaddr");
      }
      const maPeerIdStr = (_a13 = ma.getComponents().findLast((c) => c.code === CODE_P2P)) == null ? void 0 : _a13.value;
      if (maPeerIdStr == null) {
        if (peerId != null) {
          throw new InvalidParametersError("Multiaddrs must all have the same peer id or have no peer id");
        }
      } else {
        const maPeerId = peerIdFromString(maPeerIdStr);
        if ((peerId == null ? void 0 : peerId.equals(maPeerId)) !== true) {
          throw new InvalidParametersError("Multiaddrs must all have the same peer id or have no peer id");
        }
      }
    });
  }
  multiaddrs = multiaddrs.filter((ma) => {
    return !PEER_ID.exactMatch(ma);
  });
  return {
    peerId,
    multiaddrs
  };
}

// ../../node_modules/libp2p/dist/src/connection-manager/utils.js
var DEFAULT_CLOSABLE_PROTOCOLS = [
  // identify
  "/ipfs/id/1.0.0",
  // identify-push
  "/ipfs/id/push/1.0.0",
  // autonat
  "/libp2p/autonat/1.0.0",
  // dcutr
  "/libp2p/dcutr"
];
async function safelyCloseConnectionIfUnused(connection, options) {
  var _a12;
  const streamProtocols = ((_a12 = connection == null ? void 0 : connection.streams) == null ? void 0 : _a12.map((stream) => stream.protocol)) ?? [];
  const closableProtocols = (options == null ? void 0 : options.closableProtocols) ?? DEFAULT_CLOSABLE_PROTOCOLS;
  if (streamProtocols.filter((proto) => proto != null && !closableProtocols.includes(proto)).length > 0) {
    return;
  }
  try {
    await (connection == null ? void 0 : connection.close(options));
  } catch (err) {
    connection == null ? void 0 : connection.abort(err);
  }
}
function multiaddrToIpNet(ma) {
  const config = getNetConfig(ma);
  let mask = config.cidr;
  if (config.type !== "ip4" && config.type !== "ip6") {
    throw new InvalidParametersError(`Multiaddr ${ma} was not an IPv4 or IPv6 address`);
  }
  if (mask == null) {
    switch (config.type) {
      case "ip4": {
        mask = 32;
        break;
      }
      case "ip6": {
        mask = 128;
        break;
      }
      default: {
        throw new InvalidParametersError(`Multiaddr ${ma} was not an IPv4 or IPv6 address`);
      }
    }
  }
  return new IpNet(config.host, mask);
}
function isDirect(ma) {
  return !Circuit.exactMatch(ma);
}
function findExistingConnection(peerId, connections, dialAddresses) {
  if (peerId == null || connections == null) {
    return;
  }
  const existingConnection = connections.sort((a, b) => {
    if (a.direct) {
      return -1;
    }
    if (b.direct) {
      return 1;
    }
    return 0;
  }).find((con) => con.limits == null);
  if (existingConnection == null || existingConnection.direct || dialAddresses == null) {
    return existingConnection;
  }
  const wouldUpgradeToDirect = dialAddresses.some((ma) => isDirect(ma));
  if (wouldUpgradeToDirect) {
    return;
  }
  return existingConnection;
}

// ../../node_modules/libp2p/dist/src/connection-manager/connection-pruner.js
var ConnectionPruner = class {
  constructor(components, init = {}) {
    __publicField(this, "connectionManager");
    __publicField(this, "peerStore");
    __publicField(this, "allow");
    __publicField(this, "events");
    __publicField(this, "log");
    this.allow = (init.allow ?? []).map((ma) => multiaddrToIpNet(ma));
    this.connectionManager = components.connectionManager;
    this.peerStore = components.peerStore;
    this.events = components.events;
    this.log = components.logger.forComponent("libp2p:connection-manager:connection-pruner");
    this.maybePruneConnections = this.maybePruneConnections.bind(this);
  }
  start() {
    this.events.addEventListener("connection:open", this.maybePruneConnections);
  }
  stop() {
    this.events.removeEventListener("connection:open", this.maybePruneConnections);
  }
  maybePruneConnections() {
    this._maybePruneConnections().catch((err) => {
      this.log.error("error while pruning connections - %e", err);
    });
  }
  /**
   * If we have more connections than our maximum, select some excess connections
   * to prune based on peer value
   */
  async _maybePruneConnections() {
    const connections = this.connectionManager.getConnections();
    const numConnections = connections.length;
    const maxConnections = this.connectionManager.getMaxConnections();
    this.log("checking max connections limit %d/%d", numConnections, maxConnections);
    if (numConnections <= maxConnections) {
      return;
    }
    const peerValues = new PeerMap();
    for (const connection of connections) {
      const remotePeer = connection.remotePeer;
      if (peerValues.has(remotePeer)) {
        continue;
      }
      peerValues.set(remotePeer, 0);
      try {
        const peer = await this.peerStore.get(remotePeer);
        peerValues.set(remotePeer, [...peer.tags.values()].reduce((acc, curr) => {
          return acc + curr.value;
        }, 0));
      } catch (err) {
        if (err.name !== "NotFoundError") {
          this.log.error("error loading peer tags - %e", err);
        }
      }
    }
    const sortedConnections = this.sortConnections(connections, peerValues);
    const toPrune = Math.max(numConnections - maxConnections, 0);
    const toClose = [];
    for (const connection of sortedConnections) {
      this.log("too many connections open - closing a connection to %p", connection.remotePeer);
      const connectionInAllowList = this.allow.some((ipNet) => {
        if (isNetworkAddress(connection.remoteAddr)) {
          const config = getNetConfig(connection.remoteAddr);
          return ipNet.contains(config.host);
        }
        return true;
      });
      if (!connectionInAllowList) {
        toClose.push(connection);
      }
      if (toClose.length === toPrune) {
        break;
      }
    }
    await Promise.all(toClose.map(async (connection) => {
      await safelyCloseConnectionIfUnused(connection, {
        signal: AbortSignal.timeout(1e3)
      });
    }));
    this.events.safeDispatchEvent("connection:prune", { detail: toClose });
  }
  sortConnections(connections, peerValues) {
    return connections.sort((a, b) => {
      const connectionALifespan = a.timeline.open;
      const connectionBLifespan = b.timeline.open;
      if (connectionALifespan < connectionBLifespan) {
        return 1;
      }
      if (connectionALifespan > connectionBLifespan) {
        return -1;
      }
      return 0;
    }).sort((a, b) => {
      if (a.direction === "outbound" && b.direction === "inbound") {
        return 1;
      }
      if (a.direction === "inbound" && b.direction === "outbound") {
        return -1;
      }
      return 0;
    }).sort((a, b) => {
      if (a.streams.length > b.streams.length) {
        return 1;
      }
      if (a.streams.length < b.streams.length) {
        return -1;
      }
      return 0;
    }).sort((a, b) => {
      const peerAValue = peerValues.get(a.remotePeer) ?? 0;
      const peerBValue = peerValues.get(b.remotePeer) ?? 0;
      if (peerAValue > peerBValue) {
        return 1;
      }
      if (peerAValue < peerBValue) {
        return -1;
      }
      return 0;
    });
  }
};

// ../../node_modules/libp2p/dist/src/connection-manager/constants.defaults.js
var DIAL_TIMEOUT = 1e4;
var CONNECTION_CLOSE_TIMEOUT = 1e3;
var INBOUND_UPGRADE_TIMEOUT = 1e4;
var PROTOCOL_NEGOTIATION_TIMEOUT = 1e4;
var MAX_PEER_ADDRS_TO_DIAL = 25;
var INBOUND_CONNECTION_THRESHOLD = 5;
var MAX_INCOMING_PENDING_CONNECTIONS = 10;
var MAX_PARALLEL_RECONNECTS = 5;
var LAST_DIAL_FAILURE_KEY = "last-dial-failure";
var LAST_DIAL_SUCCESS_KEY = "last-dial-success";
var MAX_DIAL_QUEUE_LENGTH = 500;
var MAX_RECURSIVE_DEPTH = 32;

// ../../node_modules/libp2p/dist/src/connection-manager/constants.browser.js
var MAX_CONNECTIONS = 100;
var MAX_PARALLEL_DIALS = 50;

// ../../node_modules/libp2p/dist/src/connection-manager/address-sorter.js
function reliableTransportsFirst(a, b) {
  const isATcp = TCP.exactMatch(a.multiaddr);
  const isBTcp = TCP.exactMatch(b.multiaddr);
  if (isATcp && !isBTcp) {
    return -1;
  }
  if (!isATcp && isBTcp) {
    return 1;
  }
  const isAWebSocketSecure = WebSocketsSecure.exactMatch(a.multiaddr);
  const isBWebSocketSecure = WebSocketsSecure.exactMatch(b.multiaddr);
  if (isAWebSocketSecure && !isBWebSocketSecure) {
    return -1;
  }
  if (!isAWebSocketSecure && isBWebSocketSecure) {
    return 1;
  }
  const isAWebSocket = WebSockets.exactMatch(a.multiaddr);
  const isBWebSocket = WebSockets.exactMatch(b.multiaddr);
  if (isAWebSocket && !isBWebSocket) {
    return -1;
  }
  if (!isAWebSocket && isBWebSocket) {
    return 1;
  }
  const isAWebRTC = WebRTC.exactMatch(a.multiaddr);
  const isBWebRTC = WebRTC.exactMatch(b.multiaddr);
  if (isAWebRTC && !isBWebRTC) {
    return -1;
  }
  if (!isAWebRTC && isBWebRTC) {
    return 1;
  }
  const isAWebRTCDirect = WebRTCDirect.exactMatch(a.multiaddr);
  const isBWebRTCDirect = WebRTCDirect.exactMatch(b.multiaddr);
  if (isAWebRTCDirect && !isBWebRTCDirect) {
    return -1;
  }
  if (!isAWebRTCDirect && isBWebRTCDirect) {
    return 1;
  }
  const isAWebTransport = WebTransport.exactMatch(a.multiaddr);
  const isBWebTransport = WebTransport.exactMatch(b.multiaddr);
  if (isAWebTransport && !isBWebTransport) {
    return -1;
  }
  if (!isAWebTransport && isBWebTransport) {
    return 1;
  }
  return 0;
}
function loopbackAddressLast(a, b) {
  const isALoopback = isLoopback(a.multiaddr);
  const isBLoopback = isLoopback(b.multiaddr);
  if (isALoopback && !isBLoopback) {
    return 1;
  } else if (!isALoopback && isBLoopback) {
    return -1;
  }
  return 0;
}
function publicAddressesFirst(a, b) {
  const isAPrivate = isPrivate(a.multiaddr);
  const isBPrivate = isPrivate(b.multiaddr);
  if (isAPrivate && !isBPrivate) {
    return 1;
  } else if (!isAPrivate && isBPrivate) {
    return -1;
  }
  return 0;
}
function certifiedAddressesFirst(a, b) {
  if (a.isCertified && !b.isCertified) {
    return -1;
  } else if (!a.isCertified && b.isCertified) {
    return 1;
  }
  return 0;
}
function circuitRelayAddressesLast(a, b) {
  const isACircuit = Circuit.exactMatch(a.multiaddr);
  const isBCircuit = Circuit.exactMatch(b.multiaddr);
  if (isACircuit && !isBCircuit) {
    return 1;
  } else if (!isACircuit && isBCircuit) {
    return -1;
  }
  return 0;
}
function defaultAddressSorter(addresses) {
  return addresses.sort(reliableTransportsFirst).sort(certifiedAddressesFirst).sort(circuitRelayAddressesLast).sort(publicAddressesFirst).sort(loopbackAddressLast);
}

// ../../node_modules/@multiformats/dns/dist/src/errors.js
var DNSQueryFailedError = class extends AggregateError {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "DNSQueryFailedError");
  }
};
__publicField(DNSQueryFailedError, "name", "DNSQueryFailedError");

// ../../node_modules/@multiformats/dns/dist/src/utils/get-types.js
function getTypes(types) {
  const DEFAULT_TYPES = [
    RecordType.A
  ];
  if (types == null) {
    return DEFAULT_TYPES;
  }
  if (Array.isArray(types)) {
    if (types.length === 0) {
      return DEFAULT_TYPES;
    }
    return types;
  }
  return [
    types
  ];
}

// ../../node_modules/@multiformats/dns/dist/src/utils/to-dns-response.js
var DEFAULT_TTL = 60;
function toDNSResponse(obj) {
  return {
    Status: obj.Status ?? 0,
    TC: obj.TC ?? obj.flag_tc ?? false,
    RD: obj.RD ?? obj.flag_rd ?? false,
    RA: obj.RA ?? obj.flag_ra ?? false,
    AD: obj.AD ?? obj.flag_ad ?? false,
    CD: obj.CD ?? obj.flag_cd ?? false,
    Question: (obj.Question ?? obj.questions ?? []).map((question) => {
      return {
        name: question.name,
        type: RecordType[question.type]
      };
    }),
    Answer: (obj.Answer ?? obj.answers ?? []).map((answer) => {
      return {
        name: answer.name,
        type: RecordType[answer.type],
        TTL: answer.TTL ?? answer.ttl ?? DEFAULT_TTL,
        data: answer.data instanceof Uint8Array ? toString(answer.data) : answer.data
      };
    })
  };
}

// ../../node_modules/@multiformats/dns/dist/src/resolvers/dns-json-over-https.js
var DEFAULT_QUERY_CONCURRENCY = 4;
function dnsJsonOverHttps(url, init = {}) {
  const httpQueue = new PQueue({
    concurrency: init.queryConcurrency ?? DEFAULT_QUERY_CONCURRENCY
  });
  return async (fqdn, options = {}) => {
    var _a12;
    const searchParams = new URLSearchParams();
    searchParams.set("name", fqdn);
    getTypes(options.types).forEach((type) => {
      searchParams.append("type", RecordType[type]);
    });
    (_a12 = options.onProgress) == null ? void 0 : _a12.call(options, new CustomProgressEvent("dns:query", fqdn));
    const response = await httpQueue.add(async () => {
      var _a13;
      const res = await fetch(`${url}?${searchParams}`, {
        headers: {
          accept: "application/dns-json"
        },
        signal: options == null ? void 0 : options.signal
      });
      if (res.status !== 200) {
        throw new Error(`Unexpected HTTP status: ${res.status} - ${res.statusText}`);
      }
      const response2 = toDNSResponse(await res.json());
      (_a13 = options.onProgress) == null ? void 0 : _a13.call(options, new CustomProgressEvent("dns:response", response2));
      return response2;
    }, {
      signal: options.signal
    });
    if (response == null) {
      throw new Error("No DNS response received");
    }
    return response;
  };
}

// ../../node_modules/@multiformats/dns/dist/src/resolvers/default.browser.js
function defaultResolver() {
  return [
    dnsJsonOverHttps("https://cloudflare-dns.com/dns-query"),
    dnsJsonOverHttps("https://dns.google/resolve")
  ];
}

// ../../node_modules/@multiformats/dns/dist/src/utils/cache.js
var import_hashlru = __toESM(require_hashlru(), 1);
var CachedAnswers = class {
  constructor(maxSize) {
    __publicField(this, "lru");
    this.lru = (0, import_hashlru.default)(maxSize);
  }
  get(fqdn, types) {
    let foundAllAnswers = true;
    const answers = [];
    for (const type of types) {
      const cached = this.getAnswers(fqdn, type);
      if (cached.length === 0) {
        foundAllAnswers = false;
        break;
      }
      answers.push(...cached);
    }
    if (foundAllAnswers) {
      return toDNSResponse({ answers });
    }
  }
  getAnswers(domain, type) {
    const key = `${domain.toLowerCase()}-${type}`;
    const answers = this.lru.get(key);
    if (answers != null) {
      const cachedAnswers = answers.filter((entry) => {
        return entry.expires > Date.now();
      }).map(({ expires, value }) => ({
        ...value,
        TTL: Math.round((expires - Date.now()) / 1e3),
        type: RecordType[value.type]
      }));
      if (cachedAnswers.length === 0) {
        this.lru.remove(key);
      }
      return cachedAnswers;
    }
    return [];
  }
  add(domain, answer) {
    const key = `${domain.toLowerCase()}-${answer.type}`;
    const answers = this.lru.get(key) ?? [];
    answers.push({
      expires: Date.now() + (answer.TTL ?? DEFAULT_TTL) * 1e3,
      value: answer
    });
    this.lru.set(key, answers);
  }
  remove(domain, type) {
    const key = `${domain.toLowerCase()}-${type}`;
    this.lru.remove(key);
  }
  clear() {
    this.lru.clear();
  }
};
function cache(size) {
  return new CachedAnswers(size);
}

// ../../node_modules/@multiformats/dns/dist/src/dns.js
var DEFAULT_ANSWER_CACHE_SIZE = 1e3;
var DNS = class {
  constructor(init) {
    __publicField(this, "resolvers");
    __publicField(this, "cache");
    this.resolvers = {};
    this.cache = cache(init.cacheSize ?? DEFAULT_ANSWER_CACHE_SIZE);
    Object.entries(init.resolvers ?? {}).forEach(([tld, resolver]) => {
      if (!Array.isArray(resolver)) {
        resolver = [resolver];
      }
      if (!tld.endsWith(".")) {
        tld = `${tld}.`;
      }
      this.resolvers[tld] = resolver;
    });
    if (this.resolvers["."] == null) {
      this.resolvers["."] = defaultResolver();
    }
  }
  /**
   * Queries DNS resolvers for the passed record types for the passed domain.
   *
   * If cached records exist for all desired types they will be returned
   * instead.
   *
   * Any new responses will be added to the cache for subsequent requests.
   */
  async query(domain, options = {}) {
    var _a12, _b4, _c2;
    const types = getTypes(options.types);
    const cached = options.cached !== false ? this.cache.get(domain, types) : void 0;
    if (cached != null) {
      (_a12 = options.onProgress) == null ? void 0 : _a12.call(options, new CustomProgressEvent("dns:cache", cached));
      return cached;
    }
    const tld = `${domain.split(".").pop()}.`;
    const resolvers = (this.resolvers[tld] ?? this.resolvers["."]).sort(() => {
      return Math.random() > 0.5 ? -1 : 1;
    });
    const errors = [];
    for (const resolver of resolvers) {
      if (((_b4 = options.signal) == null ? void 0 : _b4.aborted) === true) {
        break;
      }
      try {
        const result = await resolver(domain, {
          ...options,
          types
        });
        for (const answer of result.Answer) {
          this.cache.add(domain, answer);
        }
        return result;
      } catch (err) {
        errors.push(err);
        (_c2 = options.onProgress) == null ? void 0 : _c2.call(options, new CustomProgressEvent("dns:error", err));
      }
    }
    throw new DNSQueryFailedError(errors, `DNS lookup of ${domain} ${types} failed`);
  }
};

// ../../node_modules/@multiformats/dns/dist/src/index.js
var RecordType;
(function(RecordType2) {
  RecordType2[RecordType2["A"] = 1] = "A";
  RecordType2[RecordType2["CNAME"] = 5] = "CNAME";
  RecordType2[RecordType2["TXT"] = 16] = "TXT";
  RecordType2[RecordType2["AAAA"] = 28] = "AAAA";
})(RecordType || (RecordType = {}));
function dns(init = {}) {
  return new DNS(init);
}

// ../../node_modules/libp2p/dist/src/connection-manager/resolvers/dnsaddr.js
var DNSAddrResolver = class {
  constructor() {
    __publicField(this, "dns");
  }
  canResolve(ma) {
    return ma.getComponents().some(({ name: name2 }) => name2 === "dnsaddr");
  }
  async resolve(ma, options) {
    var _a12, _b4;
    const hostname = (_a12 = ma.getComponents().find((component) => component.name === "dnsaddr")) == null ? void 0 : _a12.value;
    if (hostname == null) {
      return [ma];
    }
    const resolver = this.getDNS(options);
    const result = await resolver.query(`_dnsaddr.${hostname}`, {
      signal: options == null ? void 0 : options.signal,
      types: [
        RecordType.TXT
      ]
    });
    const peerId = (_b4 = ma.getComponents().find((component) => component.name === "p2p")) == null ? void 0 : _b4.value;
    const output = [];
    for (const answer of result.Answer) {
      const addr = answer.data.replace(/["']/g, "").trim().split("=")[1];
      if (addr == null) {
        continue;
      }
      if (peerId != null && !addr.includes(peerId)) {
        continue;
      }
      output.push(multiaddr(addr));
    }
    return output;
  }
  getDNS(options) {
    if (options.dns != null) {
      return options.dns;
    }
    if (this.dns == null) {
      this.dns = dns();
    }
    return this.dns;
  }
};
var dnsaddrResolver = new DNSAddrResolver();

// ../../node_modules/libp2p/dist/src/connection-manager/resolvers/index.js
async function resolveMultiaddr(address, resolvers, options) {
  const depth = options.depth ?? 0;
  if (depth > (options.maxRecursiveDepth ?? MAX_RECURSIVE_DEPTH)) {
    throw new RecursionLimitError("Max recursive depth reached");
  }
  let resolved = false;
  const output = [];
  for (const resolver of Object.values(resolvers)) {
    if (resolver.canResolve(address)) {
      resolved = true;
      const addresses = await resolver.resolve(address, options);
      for (const address2 of addresses) {
        output.push(...await resolveMultiaddr(address2, resolvers, {
          ...options,
          depth: depth + 1
        }));
      }
    }
  }
  if (resolved === false) {
    output.push(address);
  }
  return output;
}

// ../../node_modules/libp2p/dist/src/connection-manager/dial-queue.js
var defaultOptions3 = {
  maxParallelDials: MAX_PARALLEL_DIALS,
  maxDialQueueLength: MAX_DIAL_QUEUE_LENGTH,
  maxPeerAddrsToDial: MAX_PEER_ADDRS_TO_DIAL,
  dialTimeout: DIAL_TIMEOUT,
  resolvers: {
    dnsaddr: dnsaddrResolver
  }
};
var DialQueue = class {
  constructor(components, init = {}) {
    __publicField(this, "queue");
    __publicField(this, "components");
    __publicField(this, "addressSorter");
    __publicField(this, "maxPeerAddrsToDial");
    __publicField(this, "maxDialQueueLength");
    __publicField(this, "dialTimeout");
    __publicField(this, "shutDownController");
    __publicField(this, "connections");
    __publicField(this, "log");
    __publicField(this, "resolvers");
    this.addressSorter = init.addressSorter;
    this.maxPeerAddrsToDial = init.maxPeerAddrsToDial ?? defaultOptions3.maxPeerAddrsToDial;
    this.maxDialQueueLength = init.maxDialQueueLength ?? defaultOptions3.maxDialQueueLength;
    this.dialTimeout = init.dialTimeout ?? defaultOptions3.dialTimeout;
    this.connections = init.connections ?? new PeerMap();
    this.log = components.logger.forComponent("libp2p:connection-manager:dial-queue");
    this.components = components;
    this.resolvers = init.resolvers ?? defaultOptions3.resolvers;
    this.shutDownController = new AbortController();
    setMaxListeners(Infinity, this.shutDownController.signal);
    this.queue = new PriorityQueue({
      concurrency: init.maxParallelDials ?? defaultOptions3.maxParallelDials,
      metricName: "libp2p_dial_queue",
      metrics: components.metrics
    });
    this.queue.addEventListener("failure", (event) => {
      var _a12;
      if (((_a12 = event.detail) == null ? void 0 : _a12.error.name) !== AbortError.name) {
        this.log.error("error in dial queue - %e", event.detail.error);
      }
    });
  }
  start() {
    this.shutDownController = new AbortController();
    setMaxListeners(Infinity, this.shutDownController.signal);
  }
  /**
   * Clears any pending dials
   */
  stop() {
    this.shutDownController.abort();
    this.queue.abort();
  }
  /**
   * Connects to a given peer, multiaddr or list of multiaddrs.
   *
   * If a peer is passed, all known multiaddrs will be tried. If a multiaddr or
   * multiaddrs are passed only those will be dialled.
   *
   * Where a list of multiaddrs is passed, if any contain a peer id then all
   * multiaddrs in the list must contain the same peer id.
   *
   * The dial to the first address that is successfully able to upgrade a
   * connection will be used, all other dials will be aborted when that happens.
   */
  async dial(peerIdOrMultiaddr, options = {}) {
    var _a12, _b4, _c2;
    const { peerId, multiaddrs } = getPeerAddress(peerIdOrMultiaddr);
    if (peerId != null && options.force !== true) {
      const existingConnection = findExistingConnection(peerId, this.connections.get(peerId), multiaddrs);
      if (existingConnection != null) {
        this.log("already connected to %a", existingConnection.remoteAddr);
        (_a12 = options.onProgress) == null ? void 0 : _a12.call(options, new CustomProgressEvent("dial-queue:already-connected"));
        return existingConnection;
      }
    }
    const existingDial = this.queue.queue.find((job) => {
      if ((peerId == null ? void 0 : peerId.equals(job.options.peerId)) === true) {
        return true;
      }
      const addresses = job.options.multiaddrs;
      if (addresses == null) {
        return false;
      }
      for (const multiaddr2 of multiaddrs) {
        if (addresses.has(multiaddr2.toString())) {
          return true;
        }
      }
      return false;
    });
    if (existingDial != null) {
      this.log("joining existing dial target for %p", peerId);
      for (const multiaddr2 of multiaddrs) {
        existingDial.options.multiaddrs.add(multiaddr2.toString());
      }
      (_b4 = options.onProgress) == null ? void 0 : _b4.call(options, new CustomProgressEvent("dial-queue:already-in-dial-queue"));
      return existingDial.join(options);
    }
    if (this.queue.size >= this.maxDialQueueLength) {
      throw new DialError("Dial queue is full");
    }
    this.log("creating dial target for %p", peerId, multiaddrs.map((ma) => ma.toString()));
    (_c2 = options.onProgress) == null ? void 0 : _c2.call(options, new CustomProgressEvent("dial-queue:add-to-dial-queue"));
    return this.queue.add(async (options2) => {
      var _a13;
      (_a13 = options2.onProgress) == null ? void 0 : _a13.call(options2, new CustomProgressEvent("dial-queue:start-dial"));
      const signal = anySignal([
        this.shutDownController.signal,
        options2.signal
      ]);
      setMaxListeners(Infinity, signal);
      try {
        return await this.dialPeer(options2, signal);
      } finally {
        signal.clear();
      }
    }, {
      peerId,
      priority: options.priority ?? DEFAULT_DIAL_PRIORITY,
      multiaddrs: new Set(multiaddrs.map((ma) => ma.toString())),
      signal: options.signal ?? AbortSignal.timeout(this.dialTimeout),
      onProgress: options.onProgress
    });
  }
  async dialPeer(options, signal) {
    var _a12;
    const peerId = options.peerId;
    const multiaddrs = options.multiaddrs;
    const failedMultiaddrs = /* @__PURE__ */ new Set();
    let forcePeerLookup = options.multiaddrs.size === 0;
    let dialed = 0;
    let dialIteration = 0;
    const errors = [];
    this.log("starting dial to %p", peerId);
    while (forcePeerLookup || multiaddrs.size > 0) {
      dialIteration++;
      forcePeerLookup = false;
      const addrsToDial = [];
      const addrs = new Set(options.multiaddrs);
      multiaddrs.clear();
      this.log("calculating addrs to dial %p from %s", peerId, [...addrs]);
      const calculatedAddrs = await this.calculateMultiaddrs(peerId, addrs, {
        ...options,
        signal
      });
      for (const addr of calculatedAddrs) {
        if (failedMultiaddrs.has(addr.multiaddr.toString())) {
          this.log.trace("skipping previously failed multiaddr %a while dialing %p", addr.multiaddr, peerId);
          continue;
        }
        addrsToDial.push(addr);
      }
      this.log("%s dial to %p with %s", dialIteration === 1 ? "starting" : "continuing", peerId, addrsToDial.map((ma) => ma.multiaddr.toString()));
      (_a12 = options == null ? void 0 : options.onProgress) == null ? void 0 : _a12.call(options, new CustomProgressEvent("dial-queue:calculated-addresses", addrsToDial));
      for (const address of addrsToDial) {
        if (dialed === this.maxPeerAddrsToDial) {
          this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others", dialed, options.peerId);
          throw new DialError("Peer had more than maxPeerAddrsToDial");
        }
        dialed++;
        try {
          const conn = await this.components.transportManager.dial(address.multiaddr, {
            ...options,
            signal
          });
          this.log("dial to %a succeeded", address.multiaddr);
          try {
            await this.components.peerStore.merge(conn.remotePeer, {
              multiaddrs: [
                conn.remoteAddr
              ],
              metadata: {
                [LAST_DIAL_SUCCESS_KEY]: fromString(Date.now().toString())
              }
            });
          } catch (err) {
            this.log.error("could not update last dial failure key for %p - %e", peerId, err);
          }
          return conn;
        } catch (err) {
          this.log.error("dial failed to %a - %e", address.multiaddr, err);
          failedMultiaddrs.add(address.multiaddr.toString());
          if (peerId != null) {
            try {
              await this.components.peerStore.merge(peerId, {
                metadata: {
                  [LAST_DIAL_FAILURE_KEY]: fromString(Date.now().toString())
                }
              });
            } catch (err2) {
              this.log.error("could not update last dial failure key for %p - %e", peerId, err2);
            }
          }
          if (signal.aborted) {
            throw new TimeoutError(err.message);
          }
          errors.push(err);
        }
      }
    }
    if (errors.length === 1) {
      throw errors[0];
    }
    throw new AggregateError(errors, "All multiaddr dials failed");
  }
  // eslint-disable-next-line complexity
  async calculateMultiaddrs(peerId, multiaddrs = /* @__PURE__ */ new Set(), options = {}) {
    var _a12, _b4;
    const addrs = [...multiaddrs].map((ma) => ({
      multiaddr: multiaddr(ma),
      isCertified: false
    }));
    if (peerId != null) {
      if (this.components.peerId.equals(peerId)) {
        throw new DialError("Tried to dial self");
      }
      if (await ((_b4 = (_a12 = this.components.connectionGater).denyDialPeer) == null ? void 0 : _b4.call(_a12, peerId)) === true) {
        throw new DialDeniedError("The dial request is blocked by gater.allowDialPeer");
      }
      if (addrs.length === 0) {
        this.log("loading multiaddrs for %p", peerId);
        try {
          const peer = await this.components.peerStore.get(peerId);
          addrs.push(...peer.addresses);
          this.log("loaded multiaddrs for %p", peerId, addrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
        } catch (err) {
          if (err.name !== "NotFoundError") {
            throw err;
          }
        }
      }
      if (addrs.length === 0) {
        this.log("looking up multiaddrs for %p in the peer routing", peerId);
        try {
          const peerInfo = await this.components.peerRouting.findPeer(peerId, options);
          this.log("found multiaddrs for %p in the peer routing", peerId, addrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
          addrs.push(...peerInfo.multiaddrs.map((multiaddr2) => ({
            multiaddr: multiaddr2,
            isCertified: false
          })));
        } catch (err) {
          if (err.name === "NoPeerRoutersError") {
            this.log("no peer routers configured", peerId);
          } else {
            this.log.error("looking up multiaddrs for %p in the peer routing failed - %e", peerId, err);
          }
        }
      }
    }
    let resolvedAddresses = (await Promise.all(addrs.map(async (addr) => {
      const result = await resolveMultiaddr(addr.multiaddr, this.resolvers, {
        dns: this.components.dns,
        log: this.log,
        ...options
      });
      if (result.length === 1 && result[0].equals(addr.multiaddr)) {
        return addr;
      }
      return result.map((multiaddr2) => ({
        multiaddr: multiaddr2,
        isCertified: false
      }));
    }))).flat();
    if (peerId != null) {
      const peerIdMultiaddr = `/p2p/${peerId.toString()}`;
      resolvedAddresses = resolvedAddresses.map((addr) => {
        const lastComponent = addr.multiaddr.getComponents().pop();
        if ((lastComponent == null ? void 0 : lastComponent.name) !== "p2p") {
          return {
            multiaddr: addr.multiaddr.encapsulate(peerIdMultiaddr),
            isCertified: addr.isCertified
          };
        }
        return addr;
      });
    }
    const filteredAddrs = resolvedAddresses.filter((addr) => {
      var _a13;
      if (this.components.transportManager.dialTransportForMultiaddr(addr.multiaddr) == null) {
        return false;
      }
      const addrPeerId = (_a13 = addr.multiaddr.getComponents().findLast((c) => c.code === CODE_P2P)) == null ? void 0 : _a13.value;
      if (peerId != null && addrPeerId != null) {
        return peerId.equals(addrPeerId);
      }
      return true;
    });
    const dedupedAddrs = /* @__PURE__ */ new Map();
    for (const addr of filteredAddrs) {
      const maStr = addr.multiaddr.toString();
      const existing = dedupedAddrs.get(maStr);
      if (existing != null) {
        existing.isCertified = existing.isCertified || addr.isCertified || false;
        continue;
      }
      dedupedAddrs.set(maStr, addr);
    }
    const dedupedMultiaddrs = [...dedupedAddrs.values()];
    if (dedupedMultiaddrs.length === 0) {
      throw new NoValidAddressesError("The dial request has no valid addresses");
    }
    const gatedAddrs = [];
    for (const addr of dedupedMultiaddrs) {
      if (this.components.connectionGater.denyDialMultiaddr != null && await this.components.connectionGater.denyDialMultiaddr(addr.multiaddr)) {
        continue;
      }
      gatedAddrs.push(addr);
    }
    const sortedGatedAddrs = this.addressSorter == null ? defaultAddressSorter(gatedAddrs) : gatedAddrs.sort(this.addressSorter);
    if (sortedGatedAddrs.length === 0) {
      throw new DialDeniedError("The connection gater denied all addresses in the dial request");
    }
    this.log.trace("addresses for %p before filtering", peerId ?? "unknown peer", resolvedAddresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
    this.log.trace("addresses for %p after filtering", peerId ?? "unknown peer", sortedGatedAddrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
    return sortedGatedAddrs;
  }
  async isDialable(multiaddr2, options = {}) {
    if (!Array.isArray(multiaddr2)) {
      multiaddr2 = [multiaddr2];
    }
    try {
      const addresses = await this.calculateMultiaddrs(void 0, new Set(multiaddr2.map((ma) => ma.toString())), options);
      if (options.runOnLimitedConnection === false) {
        return addresses.find((addr) => {
          return !Circuit.matches(addr.multiaddr);
        }) != null;
      }
      return true;
    } catch {
    }
    return false;
  }
};

// ../../node_modules/is-network-error/index.js
var objectToString = Object.prototype.toString;
var isError = (value) => objectToString.call(value) === "[object Error]";
var errorMessages = /* @__PURE__ */ new Set([
  "network error",
  // Chrome
  "Failed to fetch",
  // Chrome
  "NetworkError when attempting to fetch resource.",
  // Firefox
  "The Internet connection appears to be offline.",
  // Safari 16
  "Network request failed",
  // `cross-fetch`
  "fetch failed",
  // Undici (Node.js)
  "terminated",
  // Undici (Node.js)
  " A network error occurred.",
  // Bun (WebKit)
  "Network connection lost"
  // Cloudflare Workers (fetch)
]);
function isNetworkError(error) {
  const isValid = error && isError(error) && error.name === "TypeError" && typeof error.message === "string";
  if (!isValid) {
    return false;
  }
  const { message: message2, stack } = error;
  if (message2 === "Load failed") {
    return stack === void 0 || "__sentry_captured__" in error;
  }
  if (message2.startsWith("error sending request for url")) {
    return true;
  }
  return errorMessages.has(message2);
}

// ../../node_modules/p-retry/index.js
function validateRetries(retries) {
  if (typeof retries === "number") {
    if (retries < 0) {
      throw new TypeError("Expected `retries` to be a non-negative number.");
    }
    if (Number.isNaN(retries)) {
      throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.");
    }
  } else if (retries !== void 0) {
    throw new TypeError("Expected `retries` to be a number or Infinity.");
  }
}
function validateNumberOption(name2, value, { min = 0, allowInfinity = false } = {}) {
  if (value === void 0) {
    return;
  }
  if (typeof value !== "number" || Number.isNaN(value)) {
    throw new TypeError(`Expected \`${name2}\` to be a number${allowInfinity ? " or Infinity" : ""}.`);
  }
  if (!allowInfinity && !Number.isFinite(value)) {
    throw new TypeError(`Expected \`${name2}\` to be a finite number.`);
  }
  if (value < min) {
    throw new TypeError(`Expected \`${name2}\` to be  ${min}.`);
  }
}
var AbortError3 = class extends Error {
  constructor(message2) {
    super();
    if (message2 instanceof Error) {
      this.originalError = message2;
      ({ message: message2 } = message2);
    } else {
      this.originalError = new Error(message2);
      this.originalError.stack = this.stack;
    }
    this.name = "AbortError";
    this.message = message2;
  }
};
function calculateDelay(retriesConsumed, options) {
  const attempt = Math.max(1, retriesConsumed + 1);
  const random = options.randomize ? Math.random() + 1 : 1;
  let timeout = Math.round(random * options.minTimeout * options.factor ** (attempt - 1));
  timeout = Math.min(timeout, options.maxTimeout);
  return timeout;
}
function calculateRemainingTime(start2, max) {
  if (!Number.isFinite(max)) {
    return max;
  }
  return max - (performance.now() - start2);
}
async function onAttemptFailure({ error, attemptNumber, retriesConsumed, startTime, options }) {
  var _a12, _b4, _c2, _d;
  const normalizedError = error instanceof Error ? error : new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`);
  if (normalizedError instanceof AbortError3) {
    throw normalizedError.originalError;
  }
  const retriesLeft = Number.isFinite(options.retries) ? Math.max(0, options.retries - retriesConsumed) : options.retries;
  const maxRetryTime = options.maxRetryTime ?? Number.POSITIVE_INFINITY;
  const context = Object.freeze({
    error: normalizedError,
    attemptNumber,
    retriesLeft,
    retriesConsumed
  });
  await options.onFailedAttempt(context);
  if (calculateRemainingTime(startTime, maxRetryTime) <= 0) {
    throw normalizedError;
  }
  const consumeRetry = await options.shouldConsumeRetry(context);
  const remainingTime = calculateRemainingTime(startTime, maxRetryTime);
  if (remainingTime <= 0 || retriesLeft <= 0) {
    throw normalizedError;
  }
  if (normalizedError instanceof TypeError && !isNetworkError(normalizedError)) {
    if (consumeRetry) {
      throw normalizedError;
    }
    (_a12 = options.signal) == null ? void 0 : _a12.throwIfAborted();
    return false;
  }
  if (!await options.shouldRetry(context)) {
    throw normalizedError;
  }
  if (!consumeRetry) {
    (_b4 = options.signal) == null ? void 0 : _b4.throwIfAborted();
    return false;
  }
  const delayTime = calculateDelay(retriesConsumed, options);
  const finalDelay = Math.min(delayTime, remainingTime);
  (_c2 = options.signal) == null ? void 0 : _c2.throwIfAborted();
  if (finalDelay > 0) {
    await new Promise((resolve, reject) => {
      var _a13, _b5;
      const onAbort = () => {
        var _a14;
        clearTimeout(timeoutToken);
        (_a14 = options.signal) == null ? void 0 : _a14.removeEventListener("abort", onAbort);
        reject(options.signal.reason);
      };
      const timeoutToken = setTimeout(() => {
        var _a14;
        (_a14 = options.signal) == null ? void 0 : _a14.removeEventListener("abort", onAbort);
        resolve();
      }, finalDelay);
      if (options.unref) {
        (_a13 = timeoutToken.unref) == null ? void 0 : _a13.call(timeoutToken);
      }
      (_b5 = options.signal) == null ? void 0 : _b5.addEventListener("abort", onAbort, { once: true });
    });
  }
  (_d = options.signal) == null ? void 0 : _d.throwIfAborted();
  return true;
}
async function pRetry(input, options = {}) {
  var _a12, _b4, _c2;
  options = { ...options };
  validateRetries(options.retries);
  if (Object.hasOwn(options, "forever")) {
    throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");
  }
  options.retries ?? (options.retries = 10);
  options.factor ?? (options.factor = 2);
  options.minTimeout ?? (options.minTimeout = 1e3);
  options.maxTimeout ?? (options.maxTimeout = Number.POSITIVE_INFINITY);
  options.maxRetryTime ?? (options.maxRetryTime = Number.POSITIVE_INFINITY);
  options.randomize ?? (options.randomize = false);
  options.onFailedAttempt ?? (options.onFailedAttempt = () => {
  });
  options.shouldRetry ?? (options.shouldRetry = () => true);
  options.shouldConsumeRetry ?? (options.shouldConsumeRetry = () => true);
  validateNumberOption("factor", options.factor, { min: 0, allowInfinity: false });
  validateNumberOption("minTimeout", options.minTimeout, { min: 0, allowInfinity: false });
  validateNumberOption("maxTimeout", options.maxTimeout, { min: 0, allowInfinity: true });
  validateNumberOption("maxRetryTime", options.maxRetryTime, { min: 0, allowInfinity: true });
  if (!(options.factor > 0)) {
    options.factor = 1;
  }
  (_a12 = options.signal) == null ? void 0 : _a12.throwIfAborted();
  let attemptNumber = 0;
  let retriesConsumed = 0;
  const startTime = performance.now();
  while (Number.isFinite(options.retries) ? retriesConsumed <= options.retries : true) {
    attemptNumber++;
    try {
      (_b4 = options.signal) == null ? void 0 : _b4.throwIfAborted();
      const result = await input(attemptNumber);
      (_c2 = options.signal) == null ? void 0 : _c2.throwIfAborted();
      return result;
    } catch (error) {
      if (await onAttemptFailure({
        error,
        attemptNumber,
        retriesConsumed,
        startTime,
        options
      })) {
        retriesConsumed++;
      }
    }
  }
  throw new Error("Retry attempts exhausted without throwing an error.");
}

// ../../node_modules/libp2p/dist/src/connection-manager/reconnect-queue.js
var ReconnectQueue = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "queue");
    __publicField(this, "started");
    __publicField(this, "peerStore");
    __publicField(this, "retries");
    __publicField(this, "retryInterval");
    __publicField(this, "backoffFactor");
    __publicField(this, "connectionManager");
    __publicField(this, "events");
    this.log = components.logger.forComponent("libp2p:reconnect-queue");
    this.peerStore = components.peerStore;
    this.connectionManager = components.connectionManager;
    this.queue = new PeerQueue({
      concurrency: init.maxParallelReconnects ?? MAX_PARALLEL_RECONNECTS,
      metricName: "libp2p_reconnect_queue",
      metrics: components.metrics
    });
    this.started = false;
    this.retries = init.retries ?? 5;
    this.backoffFactor = init.backoffFactor;
    this.retryInterval = init.retryInterval;
    this.events = components.events;
    components.events.addEventListener("peer:disconnect", (evt) => {
      this.maybeReconnect(evt.detail).catch((err) => {
        this.log.error("failed to maybe reconnect to %p - %e", evt.detail, err);
      });
    });
  }
  async maybeReconnect(peerId) {
    if (!this.started) {
      return;
    }
    const peer = await this.peerStore.get(peerId);
    if (!hasKeepAliveTag(peer)) {
      return;
    }
    if (this.queue.has(peerId)) {
      return;
    }
    this.queue.add(async (options) => {
      await pRetry(async (attempt) => {
        if (!this.started) {
          return;
        }
        try {
          await this.connectionManager.openConnection(peerId, {
            signal: options == null ? void 0 : options.signal
          });
        } catch (err) {
          this.log("reconnecting to %p attempt %d of %d failed - %e", peerId, attempt, this.retries, err);
          throw err;
        }
      }, {
        signal: options == null ? void 0 : options.signal,
        retries: this.retries,
        factor: this.backoffFactor,
        minTimeout: this.retryInterval
      });
    }, {
      peerId
    }).catch(async (err) => {
      this.log.error("failed to reconnect to %p - %e", peerId, err);
      const tags = {};
      [...peer.tags.keys()].forEach((key) => {
        if (key.startsWith(KEEP_ALIVE)) {
          tags[key] = void 0;
        }
      });
      await this.peerStore.merge(peerId, {
        tags
      });
      this.events.safeDispatchEvent("peer:reconnect-failure", {
        detail: peerId
      });
    }).catch(async (err) => {
      this.log.error("failed to remove keep-alive tag from %p - %e", peerId, err);
    });
  }
  start() {
    this.started = true;
  }
  async afterStart() {
    void Promise.resolve().then(async () => {
      const keepAlivePeers = await this.peerStore.all({
        filters: [
          (peer) => hasKeepAliveTag(peer)
        ]
      });
      await Promise.all(keepAlivePeers.map(async (peer) => {
        await this.connectionManager.openConnection(peer.id).catch((err) => {
          this.log.error("could not open connection to keepalive peer - %e", err);
        });
      }));
    }).catch((err) => {
      this.log.error("error reconnect to peers after start - %e", err);
    });
  }
  stop() {
    this.started = false;
    this.queue.abort();
  }
};
function hasKeepAliveTag(peer) {
  for (const tag of peer.tags.keys()) {
    if (tag.startsWith(KEEP_ALIVE)) {
      return true;
    }
  }
  return false;
}

// ../../node_modules/libp2p/dist/src/connection-manager/index.js
var DEFAULT_DIAL_PRIORITY = 50;
var defaultOptions4 = {
  maxConnections: MAX_CONNECTIONS,
  inboundConnectionThreshold: INBOUND_CONNECTION_THRESHOLD,
  maxIncomingPendingConnections: MAX_INCOMING_PENDING_CONNECTIONS
};
var _a3;
_a3 = Symbol.toStringTag;
var DefaultConnectionManager = class {
  constructor(components, init = {}) {
    __publicField(this, "started");
    __publicField(this, "connections");
    __publicField(this, "allow");
    __publicField(this, "deny");
    __publicField(this, "maxIncomingPendingConnections");
    __publicField(this, "incomingPendingConnections");
    __publicField(this, "outboundPendingConnections");
    __publicField(this, "maxConnections");
    __publicField(this, "dialQueue");
    __publicField(this, "reconnectQueue");
    __publicField(this, "connectionPruner");
    __publicField(this, "inboundConnectionRateLimiter");
    __publicField(this, "peerStore");
    __publicField(this, "metrics");
    __publicField(this, "events");
    __publicField(this, "log");
    __publicField(this, "peerId");
    __publicField(this, _a3, "@libp2p/connection-manager");
    var _a12;
    this.maxConnections = init.maxConnections ?? defaultOptions4.maxConnections;
    if (this.maxConnections < 1) {
      throw new InvalidParametersError("Connection Manager maxConnections must be greater than 0");
    }
    this.connections = new PeerMap();
    this.started = false;
    this.peerId = components.peerId;
    this.peerStore = components.peerStore;
    this.metrics = components.metrics;
    this.events = components.events;
    this.log = components.logger.forComponent("libp2p:connection-manager");
    this.onConnect = this.onConnect.bind(this);
    this.onDisconnect = this.onDisconnect.bind(this);
    this.allow = (init.allow ?? []).map((str) => multiaddrToIpNet(multiaddr(str)));
    this.deny = (init.deny ?? []).map((str) => multiaddrToIpNet(multiaddr(str)));
    this.incomingPendingConnections = 0;
    this.maxIncomingPendingConnections = init.maxIncomingPendingConnections ?? defaultOptions4.maxIncomingPendingConnections;
    this.outboundPendingConnections = 0;
    this.inboundConnectionRateLimiter = new RateLimiter({
      points: init.inboundConnectionThreshold ?? defaultOptions4.inboundConnectionThreshold,
      duration: 1
    });
    this.connectionPruner = new ConnectionPruner({
      connectionManager: this,
      peerStore: components.peerStore,
      events: components.events,
      logger: components.logger
    }, {
      allow: (_a12 = init.allow) == null ? void 0 : _a12.map((a) => multiaddr(a))
    });
    this.dialQueue = new DialQueue(components, {
      addressSorter: init.addressSorter,
      maxParallelDials: init.maxParallelDials ?? MAX_PARALLEL_DIALS,
      maxDialQueueLength: init.maxDialQueueLength ?? MAX_DIAL_QUEUE_LENGTH,
      maxPeerAddrsToDial: init.maxPeerAddrsToDial ?? MAX_PEER_ADDRS_TO_DIAL,
      dialTimeout: init.dialTimeout ?? DIAL_TIMEOUT,
      resolvers: init.resolvers ?? {
        dnsaddr: dnsaddrResolver
      },
      connections: this.connections
    });
    this.reconnectQueue = new ReconnectQueue({
      events: components.events,
      peerStore: components.peerStore,
      logger: components.logger,
      connectionManager: this
    }, {
      retries: init.reconnectRetries,
      retryInterval: init.reconnectRetryInterval,
      backoffFactor: init.reconnectBackoffFactor,
      maxParallelReconnects: init.maxParallelReconnects
    });
  }
  /**
   * Starts the Connection Manager. If Metrics are not enabled on libp2p
   * only event loop and connection limits will be monitored.
   */
  async start() {
    var _a12, _b4, _c2;
    (_a12 = this.metrics) == null ? void 0 : _a12.registerMetricGroup("libp2p_connection_manager_connections", {
      calculate: () => {
        const metric = {
          inbound: 0,
          "inbound pending": this.incomingPendingConnections,
          outbound: 0,
          "outbound pending": this.outboundPendingConnections
        };
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            metric[conn.direction]++;
          }
        }
        return metric;
      }
    });
    (_b4 = this.metrics) == null ? void 0 : _b4.registerMetricGroup("libp2p_protocol_streams_total", {
      label: "protocol",
      calculate: () => {
        const metric = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            for (const stream of conn.streams) {
              const key = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
              metric[key] = (metric[key] ?? 0) + 1;
            }
          }
        }
        return metric;
      }
    });
    (_c2 = this.metrics) == null ? void 0 : _c2.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile", {
      label: "protocol",
      calculate: () => {
        const allStreams = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            const streams = {};
            for (const stream of conn.streams) {
              const key = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
              streams[key] = (streams[key] ?? 0) + 1;
            }
            for (const [protocol, count] of Object.entries(streams)) {
              allStreams[protocol] = allStreams[protocol] ?? [];
              allStreams[protocol].push(count);
            }
          }
        }
        const metric = {};
        for (let [protocol, counts] of Object.entries(allStreams)) {
          counts = counts.sort((a, b) => a - b);
          const index = Math.floor(counts.length * 0.9);
          metric[protocol] = counts[index];
        }
        return metric;
      }
    });
    this.events.addEventListener("connection:open", this.onConnect);
    this.events.addEventListener("connection:close", this.onDisconnect);
    await start(this.dialQueue, this.reconnectQueue, this.connectionPruner);
    this.started = true;
    this.log("started");
  }
  /**
   * Stops the Connection Manager
   */
  async stop() {
    this.events.removeEventListener("connection:open", this.onConnect);
    this.events.removeEventListener("connection:close", this.onDisconnect);
    await stop(this.reconnectQueue, this.dialQueue, this.connectionPruner);
    const tasks = [];
    for (const connectionList of this.connections.values()) {
      for (const connection of connectionList) {
        tasks.push(Promise.all([
          pEvent(connection, "close", {
            signal: AbortSignal.timeout(500)
          }),
          connection.close({
            signal: AbortSignal.timeout(500)
          })
        ]).catch((err) => {
          connection.abort(err);
        }));
      }
    }
    this.log("closing %d connections", tasks.length);
    await Promise.all(tasks);
    this.connections.clear();
    this.log("stopped");
  }
  getMaxConnections() {
    return this.maxConnections;
  }
  setMaxConnections(maxConnections) {
    if (this.maxConnections < 1) {
      throw new InvalidParametersError("Connection Manager maxConnections must be greater than 0");
    }
    let needsPrune = false;
    if (maxConnections < this.maxConnections) {
      needsPrune = true;
    }
    this.maxConnections = maxConnections;
    if (needsPrune) {
      this.connectionPruner.maybePruneConnections();
    }
  }
  onConnect(evt) {
    void this._onConnect(evt).catch((err) => {
      this.log.error("could not connect - %e", err);
    });
  }
  /**
   * Tracks the incoming connection and check the connection limit
   */
  async _onConnect(evt) {
    const { detail: connection } = evt;
    if (!this.started) {
      await connection.close();
      return;
    }
    if (connection.status !== "open") {
      return;
    }
    const peerId = connection.remotePeer;
    const isNewPeer = !this.connections.has(peerId);
    const storedConns = this.connections.get(peerId) ?? [];
    storedConns.push(connection);
    this.connections.set(peerId, storedConns);
    if (peerId.publicKey != null && peerId.type === "RSA") {
      await this.peerStore.patch(peerId, {
        publicKey: peerId.publicKey
      });
    }
    if (isNewPeer) {
      this.events.safeDispatchEvent("peer:connect", { detail: connection.remotePeer });
    }
  }
  /**
   * Removes the connection from tracking
   */
  onDisconnect(evt) {
    const { detail: connection } = evt;
    const peerId = connection.remotePeer;
    const peerConns = this.connections.get(peerId) ?? [];
    const filteredPeerConns = peerConns.filter((conn) => conn.id !== connection.id);
    this.connections.set(peerId, filteredPeerConns);
    if (filteredPeerConns.length === 0) {
      this.log.trace("peer %p disconnected, removing connection map entry", peerId);
      this.connections.delete(peerId);
      this.events.safeDispatchEvent("peer:disconnect", { detail: peerId });
    }
  }
  getConnections(peerId) {
    if (peerId != null) {
      return this.connections.get(peerId) ?? [];
    }
    let conns = [];
    for (const c of this.connections.values()) {
      conns = conns.concat(c);
    }
    return conns;
  }
  getConnectionsMap() {
    return this.connections;
  }
  async openConnection(peerIdOrMultiaddr, options = {}) {
    var _a12, _b4;
    if (!this.started) {
      throw new NotStartedError("Not started");
    }
    this.outboundPendingConnections++;
    try {
      (_a12 = options.signal) == null ? void 0 : _a12.throwIfAborted();
      const { peerId, multiaddrs } = getPeerAddress(peerIdOrMultiaddr);
      if (this.peerId.equals(peerId)) {
        throw new InvalidPeerIdError("Can not dial self");
      }
      if (peerId != null && options.force !== true) {
        this.log("dial %p", peerId);
        const existingConnection = findExistingConnection(peerId, this.getConnections(peerId), multiaddrs);
        if (existingConnection != null) {
          this.log("had an existing connection to %p as %a", peerId, existingConnection.remoteAddr);
          (_b4 = options.onProgress) == null ? void 0 : _b4.call(options, new CustomProgressEvent("dial-queue:already-connected"));
          return existingConnection;
        }
      }
      const connection = await this.dialQueue.dial(peerIdOrMultiaddr, {
        ...options,
        priority: options.priority ?? DEFAULT_DIAL_PRIORITY
      });
      if (connection.status !== "open") {
        throw new ConnectionClosedError("Remote closed connection during opening");
      }
      let peerConnections = this.connections.get(connection.remotePeer);
      if (peerConnections == null) {
        peerConnections = [];
        this.connections.set(connection.remotePeer, peerConnections);
      }
      let trackedConnection = false;
      for (const conn of peerConnections) {
        if (conn.id === connection.id) {
          trackedConnection = true;
        }
        if (options.force !== true && conn.id !== connection.id && conn.remoteAddr.equals(connection.remoteAddr)) {
          connection.abort(new InvalidMultiaddrError("Duplicate multiaddr connection"));
          return conn;
        }
      }
      if (!trackedConnection) {
        peerConnections.push(connection);
      }
      return connection;
    } finally {
      this.outboundPendingConnections--;
    }
  }
  async openStream(peerIdOrMultiaddr, protocol, options = {}) {
    const connection = await this.openConnection(peerIdOrMultiaddr, options);
    return connection.newStream(protocol, options);
  }
  async closeConnections(peerId, options = {}) {
    const connections = this.connections.get(peerId) ?? [];
    await Promise.all(connections.map(async (connection) => {
      try {
        await Promise.all([
          pEvent(connection, "close", options),
          connection.close(options)
        ]);
      } catch (err) {
        connection.abort(err);
      }
    }));
  }
  acceptIncomingConnection(maConn) {
    const denyConnection = this.deny.some((ipNet) => {
      if (isNetworkAddress(maConn.remoteAddr)) {
        const config = getNetConfig(maConn.remoteAddr);
        return ipNet.contains(config.host);
      }
      return false;
    });
    if (denyConnection) {
      this.log("connection from %a refused - connection remote address was in deny list", maConn.remoteAddr);
      return false;
    }
    const allowConnection = this.allow.some((ipNet) => {
      if (isNetworkAddress(maConn.remoteAddr)) {
        const config = getNetConfig(maConn.remoteAddr);
        return ipNet.contains(config.host);
      }
      return true;
    });
    if (allowConnection) {
      this.incomingPendingConnections++;
      return true;
    }
    if (this.incomingPendingConnections === this.maxIncomingPendingConnections) {
      this.log("connection from %a refused - incomingPendingConnections exceeded by host", maConn.remoteAddr);
      return false;
    }
    if (isNetworkAddress(maConn.remoteAddr)) {
      const config = getNetConfig(maConn.remoteAddr);
      try {
        this.inboundConnectionRateLimiter.consume(config.host, 1);
      } catch {
        this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s", maConn.remoteAddr, config.host);
        return false;
      }
    }
    if (this.getConnections().length < this.maxConnections) {
      this.incomingPendingConnections++;
      return true;
    }
    this.log("connection from %a refused - maxConnections exceeded", maConn.remoteAddr);
    return false;
  }
  afterUpgradeInbound() {
    this.incomingPendingConnections--;
  }
  getDialQueue() {
    const statusMap = {
      queued: "queued",
      running: "active",
      errored: "error",
      complete: "success"
    };
    return this.dialQueue.queue.queue.map((job) => {
      return {
        id: job.id,
        status: statusMap[job.status],
        peerId: job.options.peerId,
        multiaddrs: [...job.options.multiaddrs].map((ma) => multiaddr(ma))
      };
    });
  }
  async isDialable(multiaddr2, options = {}) {
    return this.dialQueue.isDialable(multiaddr2, options);
  }
};

// ../../node_modules/libp2p/dist/src/connection-monitor.js
var DEFAULT_PING_INTERVAL_MS = 1e4;
var PROTOCOL_VERSION = "1.0.0";
var PROTOCOL_NAME = "ping";
var PROTOCOL_PREFIX = "ipfs";
var PING_LENGTH = 32;
var DEFAULT_ABORT_CONNECTION_ON_PING_FAILURE = true;
var _a4, _b;
_b = Symbol.toStringTag, _a4 = serviceCapabilities;
var ConnectionMonitor = class {
  constructor(components, init = {}) {
    __publicField(this, "protocol");
    __publicField(this, "components");
    __publicField(this, "log");
    __publicField(this, "heartbeatInterval");
    __publicField(this, "pingIntervalMs");
    __publicField(this, "abortController");
    __publicField(this, "timeout");
    __publicField(this, "abortConnectionOnPingFailure");
    __publicField(this, _b, "@libp2p/connection-monitor");
    __publicField(this, _a4, [
      "@libp2p/connection-monitor"
    ]);
    this.components = components;
    this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;
    this.log = components.logger.forComponent("libp2p:connection-monitor");
    this.pingIntervalMs = init.pingInterval ?? DEFAULT_PING_INTERVAL_MS;
    this.abortConnectionOnPingFailure = init.abortConnectionOnPingFailure ?? DEFAULT_ABORT_CONNECTION_ON_PING_FAILURE;
    this.timeout = new AdaptiveTimeout({
      ...init.pingTimeout ?? {},
      metrics: components.metrics,
      metricName: "libp2p_connection_monitor_ping_time_milliseconds"
    });
  }
  start() {
    this.abortController = new AbortController();
    setMaxListeners(Infinity, this.abortController.signal);
    this.heartbeatInterval = setInterval(() => {
      this.components.connectionManager.getConnections().forEach((conn) => {
        Promise.resolve().then(async () => {
          var _a12;
          let start2 = Date.now();
          try {
            const signal = this.timeout.getTimeoutSignal({
              signal: (_a12 = this.abortController) == null ? void 0 : _a12.signal
            });
            const stream = await conn.newStream(this.protocol, {
              signal,
              runOnLimitedConnection: true
            });
            const bs = byteStream(stream);
            start2 = Date.now();
            await Promise.all([
              bs.write(randomBytes(PING_LENGTH), {
                signal
              }),
              bs.read({
                bytes: PING_LENGTH,
                signal
              })
            ]);
            conn.rtt = Date.now() - start2;
            await stream.close({
              signal
            });
          } catch (err) {
            if (err.name !== "UnsupportedProtocolError") {
              throw err;
            }
            conn.rtt = (Date.now() - start2) / 2;
          }
        }).catch((err) => {
          this.log.error("error during heartbeat - %e", err);
          if (this.abortConnectionOnPingFailure) {
            this.log.error("aborting connection due to ping failure");
            conn.abort(err);
          } else {
            this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag");
          }
        });
      });
    }, this.pingIntervalMs);
  }
  stop() {
    var _a12;
    (_a12 = this.abortController) == null ? void 0 : _a12.abort();
    if (this.heartbeatInterval != null) {
      clearInterval(this.heartbeatInterval);
    }
  }
};

// ../../node_modules/libp2p/dist/src/content-routing.js
var _a5;
_a5 = Symbol.toStringTag;
var CompoundContentRouting = class {
  constructor(components, init) {
    __publicField(this, "routers");
    __publicField(this, "started");
    __publicField(this, "components");
    __publicField(this, _a5, "@libp2p/content-routing");
    var _a12, _b4, _c2, _d, _e;
    this.routers = init.routers ?? [];
    this.started = false;
    this.components = components;
    this.findProviders = ((_a12 = components.metrics) == null ? void 0 : _a12.traceFunction("libp2p.contentRouting.findProviders", this.findProviders.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([cid], attrs) => {
        return {
          ...attrs,
          cid: cid.toString()
        };
      },
      getAttributesFromYieldedValue: (value, attrs) => {
        return {
          ...attrs,
          providers: [...Array.isArray(attrs.providers) ? attrs.providers : [], value.id.toString()]
        };
      }
    })) ?? this.findProviders;
    this.provide = ((_b4 = components.metrics) == null ? void 0 : _b4.traceFunction("libp2p.contentRouting.provide", this.provide.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([cid], attrs) => {
        return {
          ...attrs,
          cid: cid.toString()
        };
      }
    })) ?? this.provide;
    this.cancelReprovide = ((_c2 = components.metrics) == null ? void 0 : _c2.traceFunction("libp2p.contentRouting.cancelReprovide", this.cancelReprovide.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([cid], attrs) => {
        return {
          ...attrs,
          cid: cid.toString()
        };
      }
    })) ?? this.cancelReprovide;
    this.put = ((_d = components.metrics) == null ? void 0 : _d.traceFunction("libp2p.contentRouting.put", this.put.bind(this), {
      optionsIndex: 2,
      getAttributesFromArgs: ([key]) => {
        return {
          key: toString(key, "base36")
        };
      }
    })) ?? this.put;
    this.get = ((_e = components.metrics) == null ? void 0 : _e.traceFunction("libp2p.contentRouting.get", this.get.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([key]) => {
        return {
          key: toString(key, "base36")
        };
      }
    })) ?? this.get;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
  }
  async stop() {
    this.started = false;
  }
  /**
   * Iterates over all content routers in parallel to find providers of the given key
   */
  async *findProviders(key, options = {}) {
    if (this.routers.length === 0) {
      throw new NoContentRoutersError("No content routers available");
    }
    const self = this;
    const seen = new PeerSet();
    for await (const peer of src_default(...self.routers.filter((router) => router.findProviders instanceof Function).map((router) => router.findProviders(key, options)))) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length > 0) {
        await this.components.peerStore.merge(peer.id, {
          multiaddrs: peer.multiaddrs
        }, options);
      }
      if (seen.has(peer.id)) {
        continue;
      }
      seen.add(peer.id);
      yield peer;
    }
  }
  /**
   * Iterates over all content routers in parallel to notify it is
   * a provider of the given key
   */
  async provide(key, options = {}) {
    if (this.routers.length === 0) {
      throw new NoContentRoutersError("No content routers available");
    }
    await Promise.all(this.routers.filter((router) => router.provide instanceof Function).map(async (router) => {
      await router.provide(key, options);
    }));
  }
  async cancelReprovide(key, options = {}) {
    if (this.routers.length === 0) {
      throw new NoContentRoutersError("No content routers available");
    }
    await Promise.all(this.routers.filter((router) => router.cancelReprovide instanceof Function).map(async (router) => {
      await router.cancelReprovide(key, options);
    }));
  }
  /**
   * Store the given key/value pair in the available content routings
   */
  async put(key, value, options) {
    if (!this.isStarted()) {
      throw new NotStartedError();
    }
    await Promise.all(this.routers.filter((router) => router.put instanceof Function).map(async (router) => {
      await router.put(key, value, options);
    }));
  }
  /**
   * Get the value to the given key.
   * Times out after 1 minute by default.
   */
  async get(key, options) {
    if (!this.isStarted()) {
      throw new NotStartedError();
    }
    return Promise.any(this.routers.filter((router) => router.get instanceof Function).map(async (router) => {
      return router.get(key, options);
    }));
  }
};

// ../../node_modules/libp2p/dist/src/peer-routing.js
var _a6;
_a6 = Symbol.toStringTag;
var DefaultPeerRouting = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "peerId");
    __publicField(this, "peerStore");
    __publicField(this, "routers");
    __publicField(this, _a6, "@libp2p/peer-routing");
    var _a12, _b4;
    this.log = components.logger.forComponent("libp2p:peer-routing");
    this.peerId = components.peerId;
    this.peerStore = components.peerStore;
    this.routers = init.routers ?? [];
    this.findPeer = ((_a12 = components.metrics) == null ? void 0 : _a12.traceFunction("libp2p.peerRouting.findPeer", this.findPeer.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([peer], attrs) => {
        return {
          ...attrs,
          peer: peer.toString()
        };
      }
    })) ?? this.findPeer;
    this.getClosestPeers = ((_b4 = components.metrics) == null ? void 0 : _b4.traceFunction("libp2p.peerRouting.getClosestPeers", this.getClosestPeers.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([key], attrs) => {
        return {
          ...attrs,
          key: toString(key, "base36")
        };
      },
      getAttributesFromYieldedValue: (value, attrs) => {
        return {
          ...attrs,
          peers: [...Array.isArray(attrs.peers) ? attrs.peers : [], value.id.toString()]
        };
      }
    })) ?? this.getClosestPeers;
  }
  /**
   * Iterates over all peer routers in parallel to find the given peer
   */
  async findPeer(id, options) {
    if (this.routers.length === 0) {
      throw new NoPeerRoutersError("No peer routers available");
    }
    if (id.toString() === this.peerId.toString()) {
      throw new QueriedForSelfError("Should not try to find self");
    }
    const self = this;
    const source = src_default(...this.routers.filter((router) => router.findPeer instanceof Function).map((router) => (async function* () {
      try {
        yield await router.findPeer(id, options);
      } catch (err) {
        self.log.error("router failed to find peer - %e", err);
      }
    })()));
    for await (const peer of source) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length > 0) {
        await this.peerStore.merge(peer.id, {
          multiaddrs: peer.multiaddrs
        }, options);
      }
      return peer;
    }
    throw new NotFoundError();
  }
  /**
   * Attempt to find the closest peers on the network to the given key
   */
  async *getClosestPeers(key, options = {}) {
    if (this.routers.length === 0) {
      throw new NoPeerRoutersError("No peer routers available");
    }
    const self = this;
    const seen = createScalableCuckooFilter(1024);
    for await (const peer of parallel((async function* () {
      const source = src_default(...self.routers.filter((router) => router.getClosestPeers instanceof Function).map((router) => router.getClosestPeers(key, options)));
      for await (let peer2 of source) {
        yield async () => {
          if (peer2.multiaddrs.length === 0) {
            try {
              peer2 = await self.findPeer(peer2.id, {
                ...options,
                useCache: false
              });
            } catch (err) {
              self.log.error("could not find peer multiaddrs - %e", err);
              return;
            }
          }
          return peer2;
        };
      }
    })())) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length > 0) {
        await this.peerStore.merge(peer.id, {
          multiaddrs: peer.multiaddrs
        }, options);
      }
      if (seen.has(peer.id.toMultihash().bytes)) {
        continue;
      }
      seen.add(peer.id.toMultihash().bytes);
      yield peer;
    }
  }
};

// ../../node_modules/libp2p/dist/src/random-walk.js
var _a7, _b2;
var RandomWalk = class extends (_b2 = TypedEventEmitter, _a7 = Symbol.toStringTag, _b2) {
  constructor(components) {
    super();
    __publicField(this, "peerRouting");
    __publicField(this, "log");
    __publicField(this, "walking");
    __publicField(this, "walkers");
    __publicField(this, "shutdownController");
    __publicField(this, "walkController");
    __publicField(this, "needNext");
    __publicField(this, _a7, "@libp2p/random-walk");
    this.log = components.logger.forComponent("libp2p:random-walk");
    this.peerRouting = components.peerRouting;
    this.walkers = 0;
    this.walking = false;
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
  }
  start() {
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
  }
  stop() {
    this.shutdownController.abort();
  }
  async *walk(options) {
    var _a12, _b4;
    if (!this.walking) {
      this.startWalk();
    }
    this.walkers++;
    const signal = anySignal([this.shutdownController.signal, options == null ? void 0 : options.signal]);
    setMaxListeners(Infinity, signal);
    try {
      while (true) {
        (_a12 = this.needNext) == null ? void 0 : _a12.resolve();
        this.needNext = pDefer();
        const event = await pEvent(this, "walk:peer", {
          signal,
          rejectionEvents: [
            "walk:error"
          ]
        });
        yield event.detail;
      }
    } catch (err) {
      if (err.detail != null) {
        throw err.detail;
      }
      throw err;
    } finally {
      signal.clear();
      this.walkers--;
      if (this.walkers === 0) {
        (_b4 = this.walkController) == null ? void 0 : _b4.abort();
        this.walkController = void 0;
      }
    }
  }
  startWalk() {
    this.walking = true;
    this.walkController = new AbortController();
    setMaxListeners(Infinity, this.walkController.signal);
    const signal = anySignal([this.walkController.signal, this.shutdownController.signal]);
    setMaxListeners(Infinity, signal);
    const start2 = Date.now();
    let found = 0;
    Promise.resolve().then(async () => {
      this.log("start walk");
      while (this.walkers > 0) {
        try {
          const data = randomBytes(32);
          let s = Date.now();
          for await (const peer of this.peerRouting.getClosestPeers(data, { signal })) {
            if (signal.aborted) {
              this.log("aborting walk");
            }
            signal.throwIfAborted();
            this.log("found peer %p after %dms for %d walkers", peer.id, Date.now() - s, this.walkers);
            found++;
            this.safeDispatchEvent("walk:peer", {
              detail: peer
            });
            if (this.walkers === 1 && this.needNext != null) {
              this.log("wait for need next");
              await raceSignal(this.needNext.promise, signal);
            }
            s = Date.now();
          }
          this.log("walk iteration for %b and %d walkers finished, found %d peers", data, this.walkers, found);
        } catch (err) {
          this.log.error("random walk errored - %e", err);
          this.safeDispatchEvent("walk:error", {
            detail: err
          });
        }
      }
      this.log("no walkers left, ended walk");
    }).catch((err) => {
      this.log.error("random walk errored - %e", err);
    }).finally(() => {
      this.log("finished walk, found %d peers after %dms", found, Date.now() - start2);
      this.walking = false;
    });
  }
};

// ../../node_modules/libp2p/dist/src/registrar.js
var DEFAULT_MAX_INBOUND_STREAMS = 32;
var DEFAULT_MAX_OUTBOUND_STREAMS = 64;
var _a8;
_a8 = Symbol.toStringTag;
var Registrar = class {
  constructor(components) {
    __publicField(this, "log");
    __publicField(this, "topologies");
    __publicField(this, "handlers");
    __publicField(this, "components");
    __publicField(this, "middleware");
    __publicField(this, _a8, "@libp2p/registrar");
    var _a12;
    this.components = components;
    this.log = components.logger.forComponent("libp2p:registrar");
    this.middleware = /* @__PURE__ */ new Map();
    this.topologies = /* @__PURE__ */ new Map();
    (_a12 = components.metrics) == null ? void 0 : _a12.registerMetricGroup("libp2p_registrar_topologies", {
      calculate: () => {
        const output = {};
        for (const [key, value] of this.topologies) {
          output[key] = value.size;
        }
        return output;
      }
    });
    this.handlers = trackedMap({
      name: "libp2p_registrar_protocol_handlers",
      metrics: components.metrics
    });
    this._onDisconnect = this._onDisconnect.bind(this);
    this._onPeerUpdate = this._onPeerUpdate.bind(this);
    this._onPeerIdentify = this._onPeerIdentify.bind(this);
    this.components.events.addEventListener("peer:disconnect", this._onDisconnect);
    this.components.events.addEventListener("peer:update", this._onPeerUpdate);
    this.components.events.addEventListener("peer:identify", this._onPeerIdentify);
  }
  getProtocols() {
    return Array.from(/* @__PURE__ */ new Set([
      ...this.handlers.keys()
    ])).sort();
  }
  getHandler(protocol) {
    const handler = this.handlers.get(protocol);
    if (handler == null) {
      throw new UnhandledProtocolError(`No handler registered for protocol ${protocol}`);
    }
    return handler;
  }
  getTopologies(protocol) {
    const topologies = this.topologies.get(protocol);
    if (topologies == null) {
      return [];
    }
    return [
      ...topologies.values()
    ];
  }
  /**
   * Registers the `handler` for each protocol
   */
  async handle(protocol, handler, opts) {
    if (this.handlers.has(protocol) && (opts == null ? void 0 : opts.force) !== true) {
      throw new DuplicateProtocolHandlerError(`Handler already registered for protocol ${protocol}`);
    }
    this.handlers.set(protocol, {
      handler,
      options: {
        maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS,
        maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS,
        ...opts
      }
    });
    await this.components.peerStore.merge(this.components.peerId, {
      protocols: [protocol]
    }, opts);
  }
  /**
   * Removes the handler for each protocol. The protocol
   * will no longer be supported on streams.
   */
  async unhandle(protocols, options) {
    const protocolList = Array.isArray(protocols) ? protocols : [protocols];
    protocolList.forEach((protocol) => {
      this.handlers.delete(protocol);
    });
    await this.components.peerStore.patch(this.components.peerId, {
      protocols: this.getProtocols()
    }, options);
  }
  /**
   * Register handlers for a set of multicodecs given
   */
  async register(protocol, topology) {
    if (topology == null) {
      throw new InvalidParametersError("invalid topology");
    }
    const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
    let topologies = this.topologies.get(protocol);
    if (topologies == null) {
      topologies = /* @__PURE__ */ new Map();
      this.topologies.set(protocol, topologies);
    }
    topologies.set(id, topology);
    return id;
  }
  /**
   * Unregister topology
   */
  unregister(id) {
    for (const [protocol, topologies] of this.topologies.entries()) {
      if (topologies.has(id)) {
        topologies.delete(id);
        if (topologies.size === 0) {
          this.topologies.delete(protocol);
        }
      }
    }
  }
  use(protocol, middleware) {
    this.middleware.set(protocol, middleware);
  }
  unuse(protocol) {
    this.middleware.delete(protocol);
  }
  getMiddleware(protocol) {
    return this.middleware.get(protocol) ?? [];
  }
  /**
   * Remove a disconnected peer from the record
   */
  async _onDisconnect(evt) {
    const remotePeer = evt.detail;
    const options = {
      signal: AbortSignal.timeout(5e3)
    };
    try {
      const peer = await this.components.peerStore.get(remotePeer, options);
      for (const protocol of peer.protocols) {
        const topologies = this.topologies.get(protocol);
        if (topologies == null) {
          continue;
        }
        await Promise.all([...topologies.values()].map(async (topology) => {
          var _a12, _b4, _c2;
          if (((_a12 = topology.filter) == null ? void 0 : _a12.has(remotePeer)) === false) {
            return;
          }
          (_b4 = topology.filter) == null ? void 0 : _b4.remove(remotePeer);
          await ((_c2 = topology.onDisconnect) == null ? void 0 : _c2.call(topology, remotePeer));
        }));
      }
    } catch (err) {
      if (err.name === "NotFoundError") {
        return;
      }
      this.log.error("could not inform topologies of disconnecting peer %p - %e", remotePeer, err);
    }
  }
  /**
   * When a peer is updated, if they have removed supported protocols notify any
   * topologies interested in the removed protocols.
   */
  async _onPeerUpdate(evt) {
    const { peer, previous } = evt.detail;
    const removed = ((previous == null ? void 0 : previous.protocols) ?? []).filter((protocol) => !peer.protocols.includes(protocol));
    try {
      for (const protocol of removed) {
        const topologies = this.topologies.get(protocol);
        if (topologies == null) {
          continue;
        }
        await Promise.all([...topologies.values()].map(async (topology) => {
          var _a12, _b4, _c2;
          if (((_a12 = topology.filter) == null ? void 0 : _a12.has(peer.id)) === false) {
            return;
          }
          (_b4 = topology.filter) == null ? void 0 : _b4.remove(peer.id);
          await ((_c2 = topology.onDisconnect) == null ? void 0 : _c2.call(topology, peer.id));
        }));
      }
    } catch (err) {
      this.log.error("could not inform topologies of updated peer %p - %e", peer.id, err);
    }
  }
  /**
   * After identify has completed and we have received the list of supported
   * protocols, notify any topologies interested in those protocols.
   */
  async _onPeerIdentify(evt) {
    const protocols = evt.detail.protocols;
    const connection = evt.detail.connection;
    const peerId = evt.detail.peerId;
    try {
      for (const protocol of protocols) {
        const topologies = this.topologies.get(protocol);
        if (topologies == null) {
          continue;
        }
        await Promise.all([...topologies.values()].map(async (topology) => {
          var _a12, _b4, _c2;
          if (connection.limits != null && topology.notifyOnLimitedConnection !== true) {
            return;
          }
          if (((_a12 = topology.filter) == null ? void 0 : _a12.has(peerId)) === true) {
            return;
          }
          (_b4 = topology.filter) == null ? void 0 : _b4.add(peerId);
          await ((_c2 = topology.onConnect) == null ? void 0 : _c2.call(topology, peerId, connection));
        }));
      }
    } catch (err) {
      this.log.error("could not inform topologies of updated peer after identify %p - %e", peerId, err);
    }
  }
};

// ../../node_modules/libp2p/dist/src/transport-manager.js
var _a9;
_a9 = Symbol.toStringTag;
var DefaultTransportManager = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "components");
    __publicField(this, "transports");
    __publicField(this, "listeners");
    __publicField(this, "faultTolerance");
    __publicField(this, "started");
    __publicField(this, _a9, "@libp2p/transport-manager");
    this.log = components.logger.forComponent("libp2p:transports");
    this.components = components;
    this.started = false;
    this.transports = trackedMap({
      name: "libp2p_transport_manager_transports",
      metrics: this.components.metrics
    });
    this.listeners = trackedMap({
      name: "libp2p_transport_manager_listeners",
      metrics: this.components.metrics
    });
    this.faultTolerance = init.faultTolerance ?? FaultTolerance.FATAL_ALL;
  }
  /**
   * Adds a `Transport` to the manager
   */
  add(transport) {
    const tag = transport[Symbol.toStringTag];
    if (tag == null) {
      throw new InvalidParametersError("Transport must have a valid tag");
    }
    if (this.transports.has(tag)) {
      throw new InvalidParametersError(`There is already a transport with the tag ${tag}`);
    }
    this.log("adding transport %s", tag);
    this.transports.set(tag, transport);
    if (!this.listeners.has(tag)) {
      this.listeners.set(tag, []);
    }
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  async afterStart() {
    const addrs = this.components.addressManager.getListenAddrs();
    await this.listen(addrs);
  }
  /**
   * Stops all listeners
   */
  async stop() {
    const tasks = [];
    for (const [key, listeners] of this.listeners) {
      this.log("closing listeners for %s", key);
      while (listeners.length > 0) {
        const listener = listeners.pop();
        if (listener == null) {
          continue;
        }
        tasks.push(listener.close());
      }
    }
    await Promise.all(tasks);
    this.log("all listeners closed");
    for (const key of this.listeners.keys()) {
      this.listeners.set(key, []);
    }
    this.started = false;
  }
  /**
   * Dials the given Multiaddr over it's supported transport
   */
  async dial(ma, options) {
    var _a12;
    const transport = this.dialTransportForMultiaddr(ma);
    if (transport == null) {
      throw new TransportUnavailableError(`No transport available for address ${String(ma)}`);
    }
    (_a12 = options == null ? void 0 : options.onProgress) == null ? void 0 : _a12.call(options, new CustomProgressEvent("transport-manager:selected-transport", transport[Symbol.toStringTag]));
    return transport.dial(ma, {
      ...options,
      upgrader: this.components.upgrader
    });
  }
  /**
   * Returns all Multiaddr's the listeners are using
   */
  getAddrs() {
    let addrs = [];
    for (const listeners of this.listeners.values()) {
      for (const listener of listeners) {
        addrs = [...addrs, ...listener.getAddrs()];
      }
    }
    return addrs;
  }
  /**
   * Returns all the transports instances
   */
  getTransports() {
    return Array.of(...this.transports.values());
  }
  /**
   * Returns all the listener instances
   */
  getListeners() {
    return Array.of(...this.listeners.values()).flat();
  }
  /**
   * Finds a transport that matches the given Multiaddr
   */
  dialTransportForMultiaddr(ma) {
    for (const transport of this.transports.values()) {
      const addrs = transport.dialFilter([ma]);
      if (addrs.length > 0) {
        return transport;
      }
    }
  }
  /**
   * Finds a transport that matches the given Multiaddr
   */
  listenTransportForMultiaddr(ma) {
    for (const transport of this.transports.values()) {
      const addrs = transport.listenFilter([ma]);
      if (addrs.length > 0) {
        return transport;
      }
    }
  }
  /**
   * Starts listeners for each listen Multiaddr
   */
  async listen(addrs) {
    if (!this.isStarted()) {
      throw new NotStartedError("Not started");
    }
    if (addrs == null || addrs.length === 0) {
      this.log("no addresses were provided for listening, this node is dial only");
      return;
    }
    const listenStats = {
      errors: /* @__PURE__ */ new Map(),
      ipv4: {
        success: 0,
        attempts: 0
      },
      ipv6: {
        success: 0,
        attempts: 0
      }
    };
    addrs.forEach((ma) => {
      listenStats.errors.set(ma.toString(), new UnsupportedListenAddressError());
    });
    const tasks = [];
    for (const [key, transport] of this.transports.entries()) {
      const supportedAddrs = transport.listenFilter(addrs);
      for (const addr of supportedAddrs) {
        this.log("creating listener for %s on %a", key, addr);
        const listener = transport.createListener({
          upgrader: this.components.upgrader
        });
        let listeners = this.listeners.get(key) ?? [];
        if (listeners == null) {
          listeners = [];
          this.listeners.set(key, listeners);
        }
        listeners.push(listener);
        listener.addEventListener("listening", () => {
          this.components.events.safeDispatchEvent("transport:listening", {
            detail: listener
          });
        });
        listener.addEventListener("close", () => {
          const index = listeners.findIndex((l) => l === listener);
          listeners.splice(index, 1);
          this.components.events.safeDispatchEvent("transport:close", {
            detail: listener
          });
        });
        if (IP4.matches(addr)) {
          listenStats.ipv4.attempts++;
        } else if (IP6.matches(addr)) {
          listenStats.ipv6.attempts++;
        }
        tasks.push(listener.listen(addr).then(() => {
          listenStats.errors.delete(addr.toString());
          if (IP4.matches(addr)) {
            listenStats.ipv4.success++;
          }
          if (IP6.matches(addr)) {
            listenStats.ipv6.success++;
          }
        }, (err) => {
          this.log.error("transport %s could not listen on address %a - %e", key, addr, err);
          listenStats.errors.set(addr.toString(), err);
          throw err;
        }));
      }
    }
    const results = await Promise.allSettled(tasks);
    if (results.length > 0 && results.every((res) => res.status === "fulfilled")) {
      return;
    }
    if (this.ipv6Unsupported(listenStats)) {
      this.log("all IPv4 addresses succeed but all IPv6 failed");
      return;
    }
    if (this.faultTolerance === FaultTolerance.NO_FATAL) {
      this.log("failed to listen on any address but fault tolerance allows this");
      return;
    }
    throw new UnsupportedListenAddressesError(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[...listenStats.errors.entries()].map(([addr, err]) => {
      return `
  ${addr}: ${`${getErrorMessage(err)}`.split("\n").join("\n  ")}
`;
    }).join("")}`);
  }
  ipv6Unsupported(listenStats) {
    if (listenStats.ipv4.attempts === 0 || listenStats.ipv6.attempts === 0) {
      return false;
    }
    const allIpv4Succeeded = listenStats.ipv4.attempts === listenStats.ipv4.success;
    const allIpv6Failed = listenStats.ipv6.success === 0;
    return allIpv4Succeeded && allIpv6Failed;
  }
  /**
   * Removes the given transport from the manager.
   * If a transport has any running listeners, they will be closed.
   */
  async remove(key) {
    const listeners = this.listeners.get(key) ?? [];
    this.log.trace("removing transport %s", key);
    const tasks = [];
    this.log.trace("closing listeners for %s", key);
    while (listeners.length > 0) {
      const listener = listeners.pop();
      if (listener == null) {
        continue;
      }
      tasks.push(listener.close());
    }
    await Promise.all(tasks);
    this.transports.delete(key);
    this.listeners.delete(key);
  }
  /**
   * Removes all transports from the manager.
   * If any listeners are running, they will be closed.
   *
   * @async
   */
  async removeAll() {
    const tasks = [];
    for (const key of this.transports.keys()) {
      tasks.push(this.remove(key));
    }
    await Promise.all(tasks);
  }
};
function getErrorMessage(err) {
  if (err.stack != null && err.stack.trim() !== "") {
    return err.stack;
  }
  if (err.message != null) {
    return err.message;
  }
  return err.toString();
}

// ../../node_modules/@libp2p/multistream-select/dist/src/constants.js
var PROTOCOL_ID = "/multistream/1.0.0";
var MAX_PROTOCOL_LENGTH = 1024;

// ../../node_modules/@libp2p/multistream-select/dist/src/multistream.js
var NewLine = fromString("\n");
async function readString(reader, options) {
  const buf = await reader.read(options);
  const arr = buf.subarray();
  if (arr.byteLength === 0 || arr[arr.length - 1] !== NewLine[0]) {
    throw new InvalidMessageError("Missing newline");
  }
  return toString(arr).trimEnd();
}

// ../../node_modules/@libp2p/multistream-select/dist/src/select.js
async function select(stream, protocols, options = {}) {
  protocols = Array.isArray(protocols) ? [...protocols] : [protocols];
  if (protocols.length === 0) {
    throw new Error("At least one protocol must be specified");
  }
  const log = stream.log.newScope("mss:select");
  const lp = lpStream(stream, {
    ...options,
    maxDataLength: MAX_PROTOCOL_LENGTH
  });
  for (let i = 0; i < protocols.length; i++) {
    const protocol = protocols[i];
    let response;
    if (i === 0) {
      log.trace('write ["%s", "%s"]', PROTOCOL_ID, protocol);
      const p1 = fromString(`${PROTOCOL_ID}
`);
      const p2 = fromString(`${protocol}
`);
      await lp.writeV([p1, p2], options);
      log.trace("reading multistream-select header");
      response = await readString(lp, options);
      log.trace('read "%s"', response);
      if (response !== PROTOCOL_ID) {
        log.error("did not read multistream-select header from response");
        break;
      }
    } else {
      log.trace('write "%s"', protocol);
      await lp.write(fromString(`${protocol}
`), options);
    }
    log.trace("reading protocol response");
    response = await readString(lp, options);
    log.trace('read "%s"', response);
    if (response === protocol) {
      log.trace('selected "%s" after negotiation', response);
      lp.unwrap();
      return protocol;
    }
  }
  throw new UnsupportedProtocolError(`Protocol selection failed - could not negotiate ${protocols}`);
}

// ../../node_modules/@libp2p/multistream-select/dist/src/handle.js
async function handle(stream, protocols, options = {}) {
  protocols = Array.isArray(protocols) ? protocols : [protocols];
  const log = stream.log.newScope("mss:handle");
  const lp = lpStream(stream, {
    ...options,
    maxDataLength: MAX_PROTOCOL_LENGTH,
    maxLengthLength: 2
    // 2 bytes is enough to length-prefix MAX_PROTOCOL_LENGTH
  });
  while (true) {
    log.trace("reading incoming string");
    const protocol = await readString(lp, options);
    log.trace('read "%s"', protocol);
    if (protocol === PROTOCOL_ID) {
      log.trace('respond with "%s" for "%s"', PROTOCOL_ID, protocol);
      await lp.write(fromString(`${PROTOCOL_ID}
`), options);
      log.trace('responded with "%s" for "%s"', PROTOCOL_ID, protocol);
      continue;
    }
    if (protocols.includes(protocol)) {
      log.trace('respond with "%s" for "%s"', protocol, protocol);
      await lp.write(fromString(`${protocol}
`), options);
      log.trace('responded with "%s" for "%s"', protocol, protocol);
      lp.unwrap();
      return protocol;
    }
    if (protocol === "ls") {
      const protos = new Uint8ArrayList(...protocols.map((p) => encode.single(fromString(`${p}
`))), fromString("\n"));
      log.trace('respond with "%s" for %s', protocols, protocol);
      await lp.write(protos, options);
      log.trace('responded with "%s" for %s', protocols, protocol);
      continue;
    }
    log.trace('respond with "na" for "%s"', protocol);
    await lp.write(fromString("na\n"), options);
    log('responded with "na" for "%s"', protocol);
  }
}

// ../../node_modules/libp2p/dist/src/connection.js
var _a10, _b3, _c;
var Connection = class extends (_c = TypedEventEmitter, _b3 = Symbol.toStringTag, _a10 = connectionSymbol, _c) {
  constructor(components, init) {
    super();
    __publicField(this, "id");
    __publicField(this, "remoteAddr");
    __publicField(this, "remotePeer");
    __publicField(this, "direction");
    __publicField(this, "timeline");
    __publicField(this, "direct");
    __publicField(this, "multiplexer");
    __publicField(this, "encryption");
    __publicField(this, "limits");
    __publicField(this, "log");
    __publicField(this, "maConn");
    __publicField(this, "muxer");
    __publicField(this, "components");
    __publicField(this, "outboundStreamProtocolNegotiationTimeout");
    __publicField(this, "inboundStreamProtocolNegotiationTimeout");
    __publicField(this, "closeTimeout");
    __publicField(this, _b3, "Connection");
    __publicField(this, _a10, true);
    /**
     * Create a new stream over this connection
     */
    __publicField(this, "newStream", async (protocols, options = {}) => {
      var _a12;
      if (this.muxer == null) {
        throw new MuxerUnavailableError("Connection is not multiplexed");
      }
      if (this.muxer.status !== "open") {
        throw new ConnectionClosedError(`The connection muxer is "${this.muxer.status}" and not "open"`);
      }
      if (this.maConn.status !== "open") {
        throw new ConnectionClosedError(`The connection is "${this.status}" and not "open"`);
      }
      if (this.limits != null && (options == null ? void 0 : options.runOnLimitedConnection) !== true) {
        throw new LimitedConnectionError("Cannot open protocol stream on limited connection");
      }
      if (!Array.isArray(protocols)) {
        protocols = [protocols];
      }
      this.log.trace("starting new stream for protocols %s", protocols);
      const muxedStream = await this.muxer.createStream({
        ...options,
        // most underlying transports only support negotiating a single protocol
        // so only pass the early protocol if a single protocol has been requested
        // otherwise fall back to mss
        protocol: protocols.length === 1 ? protocols[0] : void 0
      });
      this.log.trace("started new stream %s for protocols %s", muxedStream.id, protocols);
      try {
        if (options.signal == null) {
          muxedStream.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout", protocols);
          const signal = AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);
          setMaxListeners(Infinity, signal);
          options = {
            ...options,
            signal
          };
        }
        if (muxedStream.protocol === "") {
          muxedStream.log.trace("selecting protocol from protocols %s", protocols);
          muxedStream.protocol = await select(muxedStream, protocols, options);
          muxedStream.log("negotiated protocol %s", muxedStream.protocol);
        } else {
          muxedStream.log("pre-negotiated protocol %s", muxedStream.protocol);
        }
        const outgoingLimit = findOutgoingStreamLimit(muxedStream.protocol, this.components.registrar, options);
        const streamCount = countStreams(muxedStream.protocol, "outbound", this);
        if (streamCount > outgoingLimit) {
          const err = new TooManyOutboundProtocolStreamsError(`Too many outbound protocol streams for protocol "${muxedStream.protocol}" - ${streamCount}/${outgoingLimit}`);
          muxedStream.abort(err);
          throw err;
        }
        await this.components.peerStore.merge(this.remotePeer, {
          protocols: [muxedStream.protocol]
        });
        (_a12 = this.components.metrics) == null ? void 0 : _a12.trackProtocolStream(muxedStream);
        const middleware = this.components.registrar.getMiddleware(muxedStream.protocol);
        return await this.runMiddlewareChain(muxedStream, this, middleware);
      } catch (err) {
        if (muxedStream.status === "open") {
          muxedStream.abort(err);
        } else {
          this.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e", this.direction === "inbound" ? "from" : "to", this.remoteAddr, protocols, err);
        }
        throw err;
      }
    });
    this.components = components;
    this.id = init.id;
    this.remoteAddr = init.maConn.remoteAddr;
    this.remotePeer = init.remotePeer;
    this.direction = init.direction ?? "outbound";
    this.timeline = init.maConn.timeline;
    this.encryption = init.cryptoProtocol;
    this.limits = init.limits;
    this.maConn = init.maConn;
    this.log = init.maConn.log;
    this.outboundStreamProtocolNegotiationTimeout = init.outboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
    this.inboundStreamProtocolNegotiationTimeout = init.inboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
    this.closeTimeout = init.closeTimeout ?? CONNECTION_CLOSE_TIMEOUT;
    this.direct = isDirect(init.maConn.remoteAddr);
    this.onIncomingStream = this.onIncomingStream.bind(this);
    if (this.remoteAddr.getComponents().find((component) => component.code === CODE_P2P) == null) {
      this.remoteAddr = this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`);
    }
    if (init.muxer != null) {
      this.multiplexer = init.muxer.protocol;
      this.muxer = init.muxer;
      this.muxer.addEventListener("stream", this.onIncomingStream);
    }
    this.maConn.addEventListener("close", (evt) => {
      this.dispatchEvent(new StreamCloseEvent(evt.local, evt.error));
    });
  }
  get streams() {
    var _a12;
    return ((_a12 = this.muxer) == null ? void 0 : _a12.streams) ?? [];
  }
  get status() {
    return this.maConn.status;
  }
  async onIncomingStream(evt) {
    var _a12;
    const muxedStream = evt.detail;
    const signal = AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout);
    setMaxListeners(Infinity, signal);
    muxedStream.log("start protocol negotiation, timing out after %dms", this.inboundStreamProtocolNegotiationTimeout);
    try {
      if (muxedStream.protocol === "") {
        const protocols = this.components.registrar.getProtocols();
        muxedStream.log.trace("selecting protocol from protocols %s", protocols);
        muxedStream.protocol = await handle(muxedStream, protocols, {
          signal
        });
        muxedStream.log("negotiated protocol %s", muxedStream.protocol);
      } else {
        muxedStream.log("pre-negotiated protocol %s", muxedStream.protocol);
      }
      const incomingLimit = findIncomingStreamLimit(muxedStream.protocol, this.components.registrar);
      const streamCount = countStreams(muxedStream.protocol, "inbound", this);
      if (streamCount > incomingLimit) {
        throw new TooManyInboundProtocolStreamsError(`Too many inbound protocol streams for protocol "${muxedStream.protocol}" - limit ${incomingLimit}`);
      }
      await this.components.peerStore.merge(this.remotePeer, {
        protocols: [muxedStream.protocol]
      }, {
        signal
      });
      (_a12 = this.components.metrics) == null ? void 0 : _a12.trackProtocolStream(muxedStream);
      const { handler, options } = this.components.registrar.getHandler(muxedStream.protocol);
      if (this.limits != null && options.runOnLimitedConnection !== true) {
        throw new LimitedConnectionError("Cannot open protocol stream on limited connection");
      }
      const middleware = this.components.registrar.getMiddleware(muxedStream.protocol);
      middleware.push(async (stream, connection, next) => {
        await handler(stream, connection);
        next(stream, connection);
      });
      await this.runMiddlewareChain(muxedStream, this, middleware);
    } catch (err) {
      muxedStream.abort(err);
    }
  }
  async runMiddlewareChain(stream, connection, middleware) {
    for (let i = 0; i < middleware.length; i++) {
      const mw = middleware[i];
      stream.log.trace("running middleware", i, mw);
      await new Promise((resolve, reject) => {
        try {
          const result = mw(stream, connection, (s, c) => {
            stream = s;
            connection = c;
            resolve();
          });
          if (result instanceof Promise) {
            result.catch(reject);
          }
        } catch (err) {
          reject(err);
        }
      });
      stream.log.trace("ran middleware", i, mw);
    }
    return stream;
  }
  /**
   * Close the connection
   */
  async close(options = {}) {
    var _a12;
    this.log("closing connection to %a", this.remoteAddr);
    if (options.signal == null) {
      const signal = AbortSignal.timeout(this.closeTimeout);
      setMaxListeners(Infinity, signal);
      options = {
        ...options,
        signal
      };
    }
    await ((_a12 = this.muxer) == null ? void 0 : _a12.close(options));
    await this.maConn.close(options);
  }
  abort(err) {
    var _a12;
    (_a12 = this.muxer) == null ? void 0 : _a12.abort(err);
    this.maConn.abort(err);
  }
};
function createConnection(components, init) {
  return new Connection(components, init);
}
function findIncomingStreamLimit(protocol, registrar) {
  try {
    const { options } = registrar.getHandler(protocol);
    if (options.maxInboundStreams != null) {
      return options.maxInboundStreams;
    }
  } catch (err) {
    if (err.name !== "UnhandledProtocolError") {
      throw err;
    }
  }
  return DEFAULT_MAX_INBOUND_STREAMS;
}
function findOutgoingStreamLimit(protocol, registrar, options = {}) {
  try {
    const { options: options2 } = registrar.getHandler(protocol);
    if (options2.maxOutboundStreams != null) {
      return options2.maxOutboundStreams;
    }
  } catch (err) {
    if (err.name !== "UnhandledProtocolError") {
      throw err;
    }
  }
  return options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS;
}
function countStreams(protocol, direction, connection) {
  let streamCount = 0;
  connection.streams.forEach((stream) => {
    if (stream.direction === direction && stream.protocol === protocol) {
      streamCount++;
    }
  });
  return streamCount;
}

// ../../node_modules/libp2p/dist/src/upgrader.js
var _a11;
_a11 = Symbol.toStringTag;
var Upgrader = class {
  constructor(components, init) {
    __publicField(this, "components");
    __publicField(this, "connectionEncrypters");
    __publicField(this, "streamMuxers");
    __publicField(this, "inboundUpgradeTimeout");
    __publicField(this, "inboundStreamProtocolNegotiationTimeout");
    __publicField(this, "outboundStreamProtocolNegotiationTimeout");
    __publicField(this, "events");
    __publicField(this, "metrics");
    __publicField(this, "connectionCloseTimeout");
    __publicField(this, _a11, "@libp2p/upgrader");
    var _a12, _b4, _c2, _d;
    this.components = components;
    this.connectionEncrypters = trackedMap({
      name: "libp2p_upgrader_connection_encrypters",
      metrics: this.components.metrics
    });
    init.connectionEncrypters.forEach((encrypter) => {
      this.connectionEncrypters.set(encrypter.protocol, encrypter);
    });
    this.streamMuxers = trackedMap({
      name: "libp2p_upgrader_stream_multiplexers",
      metrics: this.components.metrics
    });
    init.streamMuxers.forEach((muxer) => {
      this.streamMuxers.set(muxer.protocol, muxer);
    });
    this.inboundUpgradeTimeout = init.inboundUpgradeTimeout ?? INBOUND_UPGRADE_TIMEOUT;
    this.inboundStreamProtocolNegotiationTimeout = init.inboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
    this.outboundStreamProtocolNegotiationTimeout = init.outboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
    this.connectionCloseTimeout = init.connectionCloseTimeout ?? CONNECTION_CLOSE_TIMEOUT;
    this.events = components.events;
    this.metrics = {
      dials: (_a12 = components.metrics) == null ? void 0 : _a12.registerCounterGroup("libp2p_connection_manager_dials_total"),
      errors: (_b4 = components.metrics) == null ? void 0 : _b4.registerCounterGroup("libp2p_connection_manager_dial_errors_total"),
      inboundErrors: (_c2 = components.metrics) == null ? void 0 : _c2.registerCounterGroup("libp2p_connection_manager_dials_inbound_errors_total"),
      outboundErrors: (_d = components.metrics) == null ? void 0 : _d.registerCounterGroup("libp2p_connection_manager_dials_outbound_errors_total")
    };
  }
  async shouldBlockConnection(method, ...args) {
    const denyOperation = this.components.connectionGater[method];
    if (denyOperation == null) {
      return;
    }
    const result = await denyOperation.apply(this.components.connectionGater, args);
    if (result === true) {
      throw new ConnectionInterceptedError(`The multiaddr connection is blocked by gater.${method}`);
    }
  }
  createInboundAbortSignal(signal) {
    const output = anySignal([
      AbortSignal.timeout(this.inboundUpgradeTimeout),
      signal
    ]);
    setMaxListeners(Infinity, output);
    return output;
  }
  async upgradeInbound(maConn, opts) {
    var _a12, _b4, _c2;
    let accepted = false;
    const signal = this.createInboundAbortSignal(opts.signal);
    try {
      (_a12 = this.metrics.dials) == null ? void 0 : _a12.increment({
        inbound: true
      });
      accepted = this.components.connectionManager.acceptIncomingConnection(maConn);
      if (!accepted) {
        throw new ConnectionDeniedError("Connection denied");
      }
      await raceSignal(this.shouldBlockConnection("denyInboundConnection", maConn), signal);
      await this._performUpgrade(maConn, "inbound", {
        ...opts,
        signal
      });
    } catch (err) {
      (_b4 = this.metrics.errors) == null ? void 0 : _b4.increment({
        inbound: true
      });
      (_c2 = this.metrics.inboundErrors) == null ? void 0 : _c2.increment({
        [err.name ?? "Error"]: true
      });
      throw err;
    } finally {
      signal.clear();
      if (accepted) {
        this.components.connectionManager.afterUpgradeInbound();
      }
    }
  }
  async upgradeOutbound(maConn, opts) {
    var _a12, _b4, _c2, _d;
    try {
      (_a12 = this.metrics.dials) == null ? void 0 : _a12.increment({
        outbound: true
      });
      const idStr = (_b4 = maConn.remoteAddr.getComponents().findLast((c) => c.code === CODE_P2P)) == null ? void 0 : _b4.value;
      let remotePeerId;
      if (idStr != null) {
        remotePeerId = peerIdFromString(idStr);
        await raceSignal(this.shouldBlockConnection("denyOutboundConnection", remotePeerId, maConn), opts.signal);
      }
      let direction = "outbound";
      if (opts.initiator === false) {
        direction = "inbound";
      }
      return await this._performUpgrade(maConn, direction, opts);
    } catch (err) {
      (_c2 = this.metrics.errors) == null ? void 0 : _c2.increment({
        outbound: true
      });
      (_d = this.metrics.outboundErrors) == null ? void 0 : _d.increment({
        [err.name ?? "Error"]: true
      });
      throw err;
    }
  }
  async _performUpgrade(maConn, direction, opts) {
    var _a12, _b4, _c2, _d;
    let stream = maConn;
    let remotePeer;
    let muxerFactory;
    let muxer;
    let cryptoProtocol;
    const id = `${parseInt(String(Math.random() * 1e9)).toString(36)}${Date.now()}`;
    maConn.log = maConn.log.newScope(`${direction}:${id}`);
    (_a12 = this.components.metrics) == null ? void 0 : _a12.trackMultiaddrConnection(maConn);
    maConn.log.trace("starting the %s connection upgrade", direction);
    if ((opts == null ? void 0 : opts.skipProtection) !== true) {
      const protector = this.components.connectionProtector;
      if (protector != null) {
        maConn.log("protecting the %s connection", direction);
        stream = await protector.protect(stream, opts);
      }
    }
    try {
      if (isEncryptionSkipped(opts)) {
        if (opts.remotePeer == null) {
          throw new InvalidMultiaddrError(`${direction} connection that skipped encryption must have a peer id`);
        }
        cryptoProtocol = "native";
        remotePeer = opts.remotePeer;
      } else {
        const peerIdString = (_b4 = maConn.remoteAddr.getComponents().findLast((c) => c.code === CODE_P2P)) == null ? void 0 : _b4.value;
        let remotePeerFromMultiaddr;
        if (peerIdString != null) {
          remotePeerFromMultiaddr = peerIdFromString(peerIdString);
        }
        (_c2 = opts == null ? void 0 : opts.onProgress) == null ? void 0 : _c2.call(opts, new CustomProgressEvent(`upgrader:encrypt-${direction}-connection`));
        ({
          connection: stream,
          remotePeer,
          protocol: cryptoProtocol,
          streamMuxer: muxerFactory
        } = await (direction === "inbound" ? this._encryptInbound(stream, {
          ...opts,
          remotePeer: remotePeerFromMultiaddr
        }) : this._encryptOutbound(stream, {
          ...opts,
          remotePeer: remotePeerFromMultiaddr
        })));
      }
      if (remotePeer.equals(this.components.peerId)) {
        const err = new InvalidPeerIdError("Can not dial self");
        maConn.abort(err);
        throw err;
      }
      await this.shouldBlockConnection(direction === "inbound" ? "denyInboundEncryptedConnection" : "denyOutboundEncryptedConnection", remotePeer, maConn);
      if ((opts == null ? void 0 : opts.muxerFactory) != null) {
        muxerFactory = opts.muxerFactory;
      } else if (muxerFactory == null && this.streamMuxers.size > 0) {
        (_d = opts == null ? void 0 : opts.onProgress) == null ? void 0 : _d.call(opts, new CustomProgressEvent(`upgrader:multiplex-${direction}-connection`));
        muxerFactory = await (direction === "inbound" ? this._multiplexInbound(stream, this.streamMuxers, opts) : this._multiplexOutbound(stream, this.streamMuxers, opts));
      }
    } catch (err) {
      maConn.log.error("failed to upgrade %s connection %s %a - %e", direction, direction === "inbound" ? "from" : "to", maConn.remoteAddr, err);
      throw err;
    }
    if (muxerFactory != null) {
      maConn.log("create muxer %s", muxerFactory.protocol);
      muxer = muxerFactory.createStreamMuxer(stream);
    }
    await this.shouldBlockConnection(direction === "inbound" ? "denyInboundUpgradedConnection" : "denyOutboundUpgradedConnection", remotePeer, maConn);
    const conn = this._createConnection({
      id,
      cryptoProtocol,
      direction,
      maConn,
      stream,
      muxer,
      remotePeer,
      limits: opts == null ? void 0 : opts.limits,
      closeTimeout: this.connectionCloseTimeout
    });
    conn.log("successfully upgraded connection");
    return conn;
  }
  /**
   * A convenience method for generating a new `Connection`
   */
  _createConnection(opts) {
    const connection = createConnection(this.components, {
      ...opts,
      outboundStreamProtocolNegotiationTimeout: this.outboundStreamProtocolNegotiationTimeout,
      inboundStreamProtocolNegotiationTimeout: this.inboundStreamProtocolNegotiationTimeout
    });
    connection.addEventListener("close", () => {
      this.events.safeDispatchEvent("connection:close", {
        detail: connection
      });
    });
    this.events.safeDispatchEvent("connection:open", {
      detail: connection
    });
    return connection;
  }
  /**
   * Attempts to encrypt the incoming `connection` with the provided `cryptos`
   */
  async _encryptInbound(connection, options) {
    const protocols = Array.from(this.connectionEncrypters.keys());
    try {
      const protocol = await handle(connection, protocols, options);
      const encrypter = this.connectionEncrypters.get(protocol);
      if (encrypter == null) {
        throw new EncryptionFailedError(`no crypto module found for ${protocol}`);
      }
      connection.log("encrypting inbound connection using %s", protocol);
      return {
        ...await encrypter.secureInbound(connection, options),
        protocol
      };
    } catch (err) {
      throw new EncryptionFailedError(err.message);
    }
  }
  /**
   * Attempts to encrypt the given `connection` with the provided connection encrypters.
   * The first `ConnectionEncrypter` module to succeed will be used
   */
  async _encryptOutbound(connection, options) {
    const protocols = Array.from(this.connectionEncrypters.keys());
    try {
      connection.log.trace("selecting encrypter from %s", protocols);
      const protocol = await select(connection, protocols, options);
      const encrypter = this.connectionEncrypters.get(protocol);
      if (encrypter == null) {
        throw new EncryptionFailedError(`no crypto module found for ${protocol}`);
      }
      connection.log("encrypting outbound connection using %s", protocol);
      return {
        ...await encrypter.secureOutbound(connection, options),
        protocol
      };
    } catch (err) {
      throw new EncryptionFailedError(err.message);
    }
  }
  /**
   * Selects one of the given muxers via multistream-select. That
   * muxer will be used for all future streams on the connection.
   */
  async _multiplexOutbound(maConn, muxers, options) {
    const protocols = Array.from(muxers.keys());
    maConn.log("outbound selecting muxer %s", protocols);
    try {
      maConn.log.trace("selecting stream muxer from %s", protocols);
      const protocol = await select(maConn, protocols, options);
      const muxerFactory = muxers.get(protocol);
      if (muxerFactory == null) {
        throw new MuxerUnavailableError(`No muxer configured for protocol "${protocol}"`);
      }
      maConn.log("selected %s as muxer protocol", protocol);
      return muxerFactory;
    } catch (err) {
      maConn.log.error("error multiplexing outbound connection - %e", err);
      throw new MuxerUnavailableError(String(err));
    }
  }
  /**
   * Registers support for one of the given muxers via multistream-select. The
   * selected muxer will be used for all future streams on the connection.
   */
  async _multiplexInbound(maConn, muxers, options) {
    const protocols = Array.from(muxers.keys());
    maConn.log("inbound handling muxers %s", protocols);
    try {
      maConn.log.trace("selecting stream muxer from %s", protocols);
      const protocol = await handle(maConn, protocols, options);
      const muxerFactory = muxers.get(protocol);
      if (muxerFactory == null) {
        throw new MuxerUnavailableError(`No muxer configured for protocol "${protocol}"`);
      }
      maConn.log("selected %s as muxer protocol", protocol);
      return muxerFactory;
    } catch (err) {
      maConn.log.error("error multiplexing inbound connection - %e", err);
      throw err;
    }
  }
  getConnectionEncrypters() {
    return this.connectionEncrypters;
  }
  getStreamMuxers() {
    return this.streamMuxers;
  }
};
function isEncryptionSkipped(opts) {
  return opts.skipEncryption === true;
}

// ../../node_modules/libp2p/dist/src/version.js
var version = "3.1.2";
var name = "js-libp2p";

// ../../node_modules/libp2p/dist/src/user-agent.browser.js
function userAgent(name2, version2) {
  return `${name2 ?? name}/${version2 ?? version} browser/${globalThis.navigator.userAgent}`;
}

// ../../node_modules/libp2p/dist/src/libp2p.js
var _Libp2p_instances, onDiscoveryPeer_fn;
var Libp2p = class extends TypedEventEmitter {
  // eslint-disable-next-line complexity
  constructor(init) {
    var _a12, _b4, _c2, _d, _e, _f, _g, _h, _i, _j, _k;
    super();
    __privateAdd(this, _Libp2p_instances);
    __publicField(this, "peerId");
    __publicField(this, "peerStore");
    __publicField(this, "contentRouting");
    __publicField(this, "peerRouting");
    __publicField(this, "metrics");
    __publicField(this, "services");
    __publicField(this, "logger");
    __publicField(this, "status");
    __publicField(this, "components");
    __publicField(this, "log");
    this.status = "stopped";
    const events = new TypedEventEmitter();
    const originalDispatch = events.dispatchEvent.bind(events);
    events.dispatchEvent = (evt) => {
      const internalResult = originalDispatch(evt);
      const externalResult = this.dispatchEvent(new CustomEvent(evt.type, { detail: evt.detail }));
      return internalResult || externalResult;
    };
    setMaxListeners(Infinity, events);
    this.peerId = init.peerId;
    this.logger = init.logger ?? defaultLogger();
    this.log = this.logger.forComponent("libp2p");
    this.services = {};
    const nodeInfoName = ((_a12 = init.nodeInfo) == null ? void 0 : _a12.name) ?? name;
    const nodeInfoVersion = ((_b4 = init.nodeInfo) == null ? void 0 : _b4.version) ?? version;
    const components = this.components = defaultComponents({
      peerId: init.peerId,
      privateKey: init.privateKey,
      nodeInfo: {
        name: nodeInfoName,
        version: nodeInfoVersion,
        userAgent: ((_c2 = init.nodeInfo) == null ? void 0 : _c2.userAgent) ?? userAgent(nodeInfoName, nodeInfoVersion)
      },
      logger: this.logger,
      events,
      datastore: init.datastore ?? new MemoryDatastore(),
      connectionGater: connectionGater(init.connectionGater),
      dns: init.dns
    });
    if (init.metrics != null) {
      this.metrics = this.configureComponent("metrics", init.metrics(this.components));
    }
    this.peerStore = this.configureComponent("peerStore", persistentPeerStore(components, {
      addressFilter: this.components.connectionGater.filterMultiaddrForPeer,
      ...init.peerStore
    }));
    components.events.addEventListener("peer:update", (evt) => {
      if (evt.detail.previous == null) {
        const peerInfo = {
          id: evt.detail.peer.id,
          multiaddrs: evt.detail.peer.addresses.map((a) => a.multiaddr)
        };
        components.events.safeDispatchEvent("peer:discovery", { detail: peerInfo });
      }
    });
    if (init.connectionProtector != null) {
      this.configureComponent("connectionProtector", init.connectionProtector(components));
    }
    this.components.upgrader = new Upgrader(this.components, {
      connectionEncrypters: (init.connectionEncrypters ?? []).map((fn, index) => this.configureComponent(`connection-encryption-${index}`, fn(this.components))),
      streamMuxers: (init.streamMuxers ?? []).map((fn, index) => this.configureComponent(`stream-muxers-${index}`, fn(this.components))),
      inboundUpgradeTimeout: (_d = init.connectionManager) == null ? void 0 : _d.inboundUpgradeTimeout,
      inboundStreamProtocolNegotiationTimeout: (_e = init.connectionManager) == null ? void 0 : _e.inboundStreamProtocolNegotiationTimeout,
      outboundStreamProtocolNegotiationTimeout: (_f = init.connectionManager) == null ? void 0 : _f.outboundStreamProtocolNegotiationTimeout,
      connectionCloseTimeout: (_g = init.connectionManager) == null ? void 0 : _g.connectionCloseTimeout
    });
    this.configureComponent("transportManager", new DefaultTransportManager(this.components, init.transportManager));
    this.configureComponent("connectionManager", new DefaultConnectionManager(this.components, init.connectionManager));
    if (((_h = init.connectionMonitor) == null ? void 0 : _h.enabled) !== false) {
      this.configureComponent("connectionMonitor", new ConnectionMonitor(this.components, init.connectionMonitor));
    }
    this.configureComponent("registrar", new Registrar(this.components));
    this.configureComponent("addressManager", new AddressManager(this.components, init.addresses));
    const peerRouters = (init.peerRouters ?? []).map((fn, index) => this.configureComponent(`peer-router-${index}`, fn(this.components)));
    this.peerRouting = this.components.peerRouting = this.configureComponent("peerRouting", new DefaultPeerRouting(this.components, {
      routers: peerRouters
    }));
    const contentRouters = (init.contentRouters ?? []).map((fn, index) => this.configureComponent(`content-router-${index}`, fn(this.components)));
    this.contentRouting = this.components.contentRouting = this.configureComponent("contentRouting", new CompoundContentRouting(this.components, {
      routers: contentRouters
    }));
    this.configureComponent("randomWalk", new RandomWalk(this.components));
    (init.peerDiscovery ?? []).forEach((fn, index) => {
      const service = this.configureComponent(`peer-discovery-${index}`, fn(this.components));
      service.addEventListener("peer", (evt) => {
        __privateMethod(this, _Libp2p_instances, onDiscoveryPeer_fn).call(this, evt);
      });
    });
    (_i = init.transports) == null ? void 0 : _i.forEach((fn, index) => {
      this.components.transportManager.add(this.configureComponent(`transport-${index}`, fn(this.components)));
    });
    if (init.services != null) {
      for (const name2 of Object.keys(init.services)) {
        const createService = init.services[name2];
        const service = createService(this.components);
        if (service == null) {
          this.log.error("service factory %s returned null or undefined instance", name2);
          continue;
        }
        this.services[name2] = service;
        this.configureComponent(name2, service);
        if (service[contentRoutingSymbol] != null) {
          this.log("registering service %s for content routing", name2);
          contentRouters.push(service[contentRoutingSymbol]);
        }
        if (service[peerRoutingSymbol] != null) {
          this.log("registering service %s for peer routing", name2);
          peerRouters.push(service[peerRoutingSymbol]);
        }
        if (service[peerDiscoverySymbol] != null) {
          this.log("registering service %s for peer discovery", name2);
          (_k = (_j = service[peerDiscoverySymbol]).addEventListener) == null ? void 0 : _k.call(_j, "peer", (evt) => {
            __privateMethod(this, _Libp2p_instances, onDiscoveryPeer_fn).call(this, evt);
          });
        }
      }
    }
    checkServiceDependencies(components);
  }
  configureComponent(name2, component) {
    if (component == null) {
      this.log.error("component %s was null or undefined", name2);
    }
    this.components[name2] = component;
    return component;
  }
  /**
   * Starts the libp2p node and all its subsystems
   */
  async start() {
    var _a12, _b4, _c2, _d;
    if (this.status !== "stopped") {
      return;
    }
    this.status = "starting";
    this.log("libp2p is starting");
    try {
      await ((_b4 = (_a12 = this.components).beforeStart) == null ? void 0 : _b4.call(_a12));
      await this.components.start();
      await ((_d = (_c2 = this.components).afterStart) == null ? void 0 : _d.call(_c2));
      this.status = "started";
      this.safeDispatchEvent("start", { detail: this });
      this.log("libp2p has started with peer id %p", this.peerId);
    } catch (err) {
      this.log.error("an error occurred starting libp2p - %e", err);
      this.status = "started";
      await this.stop();
      throw err;
    }
  }
  /**
   * Stop the libp2p node by closing its listeners and open connections
   */
  async stop() {
    var _a12, _b4, _c2, _d;
    if (this.status !== "started") {
      return;
    }
    this.log("libp2p is stopping");
    this.status = "stopping";
    await ((_b4 = (_a12 = this.components).beforeStop) == null ? void 0 : _b4.call(_a12));
    await this.components.stop();
    await ((_d = (_c2 = this.components).afterStop) == null ? void 0 : _d.call(_c2));
    this.status = "stopped";
    this.safeDispatchEvent("stop", { detail: this });
    this.log("libp2p has stopped");
  }
  getConnections(peerId) {
    return this.components.connectionManager.getConnections(peerId);
  }
  getDialQueue() {
    return this.components.connectionManager.getDialQueue();
  }
  getPeers() {
    const peerSet = new PeerSet();
    for (const conn of this.components.connectionManager.getConnections()) {
      peerSet.add(conn.remotePeer);
    }
    return Array.from(peerSet);
  }
  async dial(peer, options = {}) {
    return this.components.connectionManager.openConnection(peer, {
      // ensure any userland dials take top priority in the queue
      priority: 75,
      ...options
    });
  }
  async dialProtocol(peer, protocols, options = {}) {
    if (protocols == null) {
      throw new InvalidParametersError("no protocols were provided to open a stream");
    }
    protocols = Array.isArray(protocols) ? protocols : [protocols];
    if (protocols.length === 0) {
      throw new InvalidParametersError("no protocols were provided to open a stream");
    }
    return this.components.connectionManager.openStream(peer, protocols, options);
  }
  getMultiaddrs() {
    return this.components.addressManager.getAddresses();
  }
  getProtocols() {
    return this.components.registrar.getProtocols();
  }
  async hangUp(peer, options = {}) {
    var _a12;
    if (isMultiaddr(peer)) {
      peer = peerIdFromString(((_a12 = peer.getComponents().findLast((c) => c.code === CODE_P2P)) == null ? void 0 : _a12.value) ?? "");
    }
    await this.components.connectionManager.closeConnections(peer, options);
  }
  async getPublicKey(peer, options = {}) {
    this.log("getPublicKey %p", peer);
    if (peer.publicKey != null) {
      return peer.publicKey;
    }
    try {
      const peerInfo = await this.peerStore.get(peer, options);
      if (peerInfo.id.publicKey != null) {
        return peerInfo.id.publicKey;
      }
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
    }
    const peerKey = concat([
      fromString("/pk/"),
      peer.toMultihash().bytes
    ]);
    const bytes = await this.contentRouting.get(peerKey, options);
    const publicKey = publicKeyFromProtobuf(bytes);
    await this.peerStore.patch(peer, {
      publicKey
    }, options);
    return publicKey;
  }
  async handle(protocols, handler, options) {
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    await Promise.all(protocols.map(async (protocol) => {
      await this.components.registrar.handle(protocol, handler, options);
    }));
  }
  async unhandle(protocols, options) {
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    await Promise.all(protocols.map(async (protocol) => {
      await this.components.registrar.unhandle(protocol, options);
    }));
  }
  async register(protocol, topology, options) {
    return this.components.registrar.register(protocol, topology, options);
  }
  unregister(id) {
    this.components.registrar.unregister(id);
  }
  use(protocol, middleware) {
    this.components.registrar.use(protocol, Array.isArray(middleware) ? middleware : [middleware]);
  }
  unuse(protocol) {
    this.components.registrar.unuse(protocol);
  }
  async isDialable(multiaddr2, options = {}) {
    return this.components.connectionManager.isDialable(multiaddr2, options);
  }
};
_Libp2p_instances = new WeakSet();
/**
 * Called whenever peer discovery services emit `peer` events and adds peers
 * to the peer store.
 */
onDiscoveryPeer_fn = function(evt) {
  const { detail: peer } = evt;
  if (peer.id.toString() === this.peerId.toString()) {
    this.log.error("peer discovery mechanism discovered self");
    return;
  }
  void this.components.peerStore.merge(peer.id, {
    multiaddrs: peer.multiaddrs
  }).catch((err) => {
    this.log.error("could not update multiaddrs of discovered peer - %e", err);
  });
};

// ../../node_modules/libp2p/dist/src/index.js
async function createLibp2p(options = {}) {
  options.privateKey ?? (options.privateKey = await generateKeyPair("Ed25519"));
  const node = new Libp2p({
    ...await validateConfig(options),
    peerId: peerIdFromPrivateKey(options.privateKey)
  });
  if (options.start !== false) {
    await node.start();
  }
  return node;
}
var LIBP2P_METHODS = ["dial", "dialProtocol", "hangUp", "handle", "unhandle", "getMultiaddrs", "getProtocols"];
function isLibp2p(obj) {
  if (obj == null) {
    return false;
  }
  if (obj instanceof Libp2p) {
    return true;
  }
  return LIBP2P_METHODS.every((m) => typeof obj[m] === "function");
}
export {
  createLibp2p,
  dnsaddrResolver,
  isLibp2p
};
//# sourceMappingURL=libp2p.js.map
