{
  "version": 3,
  "sources": ["../../../../../node_modules/@multiformats/multiaddr-to-uri/src/index.ts", "../../../../../node_modules/@libp2p/websockets/src/listener.browser.ts", "../../../../../node_modules/@libp2p/websockets/src/websocket-to-conn.ts", "../../../../../node_modules/@libp2p/websockets/src/index.ts"],
  "sourcesContent": ["/**\n * @packageDocumentation\n *\n * This module allows easy conversion of Multiaddrs to string URIs.\n *\n * @example Converting multiaddrs to string URIs\n *\n * ```js\n * import { multiaddrToUri } from '@multiformats/multiaddr-to-uri'\n *\n * console.log(multiaddrToUri('/dnsaddr/protocol.ai/https'))\n * // -> https://protocol.ai\n *\n * console.log(multiaddrToUri('/ip4/127.0.0.1/tcp/8080'))\n * // -> http://127.0.0.1:8080\n *\n * console.log(multiaddrToUri('/ip4/127.0.0.1/tcp/8080', { assumeHttp: false }))\n * // -> tcp://127.0.0.1:8080\n * ```\n *\n * Note:\n *\n * - When `/tcp` is the last (terminating) protocol HTTP is assumed by default (implicit `assumeHttp: true`)\n *   - this means produced URIs will start with `http://` instead of `tcp://`\n *   - passing `{ assumeHttp: false }` disables this behavior\n * - Might be lossy - e.g. a DNSv6 multiaddr\n * - Can throw if the passed multiaddr:\n *   - is not a valid multiaddr\n *   - is not supported as a URI e.g. circuit\n */\n\nimport { CODE_TCP, CODE_DNS, CODE_DNS4, CODE_DNS6, CODE_DNSADDR, multiaddr, CODE_TLS, CODE_IP6 } from '@multiformats/multiaddr'\nimport type { Component, Multiaddr } from '@multiformats/multiaddr'\n\nexport interface MultiaddrToUriOpts {\n  assumeHttp?: boolean\n}\n\nconst ASSUME_HTTP_CODES = [\n  CODE_TCP,\n  CODE_DNS,\n  CODE_DNSADDR,\n  CODE_DNS4,\n  CODE_DNS6\n]\n\ninterface Interpreter {\n  (head: Component, rest: Component[]): string | undefined\n}\n\nfunction extractSNI (ma: Component[]): string | undefined {\n  return extractTuple('sni', ma)?.value\n}\n\nfunction extractPort (ma: Component[]): string {\n  const port = extractTuple('tcp', ma)?.value\n\n  if (port == null) {\n    return ''\n  }\n\n  return `:${port}`\n}\n\nfunction extractTuple (name: string, ma: Component[]): Component | undefined {\n  return ma.find(component => component.name === name)\n}\n\nfunction hasTLS (ma: Component[]): boolean {\n  return ma.some(({ code }) => code === CODE_TLS)\n}\n\nfunction interpretNext (head: Component, rest: Component[]): string | undefined {\n  const interpreter = interpreters[head.name]\n  if (interpreter == null) {\n    throw new Error(`Can't interpret protocol ${head.name}`)\n  }\n  const restVal = interpreter(head, rest)\n  if (head.code === CODE_IP6) {\n    return `[${restVal}]`\n  }\n  return restVal\n}\n\nconst interpreters: Record<string, Interpreter> = {\n  ip4: (head, rest) => head.value,\n  ip6: (head, rest) => {\n    if (rest.length === 0) {\n      return head.value\n    }\n    return `[${head.value}]`\n  },\n  tcp: (head, rest) => {\n    const tail = rest.pop()\n    if (tail == null) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `tcp://${interpretNext(tail, rest)}:${head.value}`\n  },\n  udp: (head, rest) => {\n    const tail = rest.pop()\n    if (tail == null) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `udp://${interpretNext(tail, rest)}:${head.value}`\n  },\n  dnsaddr: (head, rest) => head.value,\n  dns4: (head, rest) => head.value,\n  dns6: (head, rest) => head.value,\n  dns: (head, rest) => head.value,\n  ipfs: (head, rest) => {\n    const tail = rest.pop()\n    if (tail == null) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `${interpretNext(tail, rest)}`\n  },\n  p2p: (head, rest) => {\n    const tail = rest.pop()\n    if (tail == null) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `${interpretNext(tail, rest)}`\n  },\n  http: (head, rest) => {\n    const maHasTLS = hasTLS(rest)\n    const sni = extractSNI(rest)\n    const port = extractPort(rest)\n    if (maHasTLS && sni != null) {\n      return `https://${sni}${port}`\n    }\n    const protocol = maHasTLS ? 'https://' : 'http://'\n    const tail = rest.pop()\n    if (tail == null) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    let baseVal = interpretNext(tail, rest)\n    // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there\n    baseVal = baseVal?.replace('tcp://', '')\n    return `${protocol}${baseVal}`\n  },\n  'http-path': (head, rest) => {\n    const tail = rest.pop()\n    if (tail == null) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    const baseVal = interpretNext(tail, rest)\n    const decodedValue = decodeURIComponent(head.value ?? '')\n    return `${baseVal}${decodedValue}`\n  },\n  tls: (head, rest) => {\n    // Noop, the parent context knows that it's tls. We don't need to do\n    // anything here\n    const tail = rest.pop()\n    if (tail == null) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return interpretNext(tail, rest)\n  },\n  sni: (head, rest) => {\n    // Noop, the parent context uses the sni information, we don't need to do\n    // anything here\n    const tail = rest.pop()\n    if (tail == null) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return interpretNext(tail, rest)\n  },\n  https: (head, rest) => {\n    const tail = rest.pop()\n    if (tail == null) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    let baseVal = interpretNext(tail, rest)\n    // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there\n    baseVal = baseVal?.replace('tcp://', '')\n    return `https://${baseVal}`\n  },\n  ws: (head, rest) => {\n    const maHasTLS = hasTLS(rest)\n    const sni = extractSNI(rest)\n    const port = extractPort(rest)\n    if (maHasTLS && sni != null) {\n      return `wss://${sni}${port}`\n    }\n    const protocol = maHasTLS ? 'wss://' : 'ws://'\n    const tail = rest.pop()\n    if (tail == null) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    let baseVal = interpretNext(tail, rest)\n    // We are reinterpreting the base, so we need to remove the tcp:// if it's there\n    baseVal = baseVal?.replace('tcp://', '')\n    return `${protocol}${baseVal}`\n  },\n  wss: (head, rest) => {\n    const tail = rest.pop()\n    if (tail == null) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    let baseVal = interpretNext(tail, rest)\n    // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there\n    baseVal = baseVal?.replace('tcp://', '')\n    return `wss://${baseVal}`\n  }\n}\n\nexport function multiaddrToUri (input: Multiaddr | string | Uint8Array, opts?: MultiaddrToUriOpts): string {\n  const ma = multiaddr(input)\n  const components = ma.getComponents()\n  const head = components.pop()\n  if (head == null) {\n    throw new Error('Unexpected end of multiaddr')\n  }\n\n  const interpreter = interpreters[head.name]\n\n  if (interpreter == null) {\n    throw new Error(`No interpreter found for ${head.name}`)\n  }\n\n  let uri = interpreter(head, components) ?? ''\n\n  if (opts?.assumeHttp !== false && ASSUME_HTTP_CODES.includes(head.code)) {\n    // strip any declared protocol\n    uri = uri.replace(/^.*:\\/\\//, '')\n\n    if (head.value === '443') {\n      uri = `https://${uri}`\n    } else {\n      uri = `http://${uri}`\n    }\n  }\n\n  if (uri.startsWith('http://') || uri.startsWith('https://') || uri.startsWith('ws://') || uri.startsWith('wss://')) {\n    // this will strip default ports while keeping paths intact\n    uri = new URL(uri).toString()\n\n    // strip trailing slash, e.g. http://127.0.0.1/ -> http://127.0.0.1\n    if (uri.endsWith('/')) {\n      uri = uri.substring(0, uri.length - 1)\n    }\n  }\n\n  return uri\n}\n", "import type { Listener } from '@libp2p/interface'\n\nexport function createListener (): Listener {\n  throw new Error('WebSocket Servers can not be created in the browser!')\n}\n", "import { AbstractMultiaddrConnection, repeatingTask } from '@libp2p/utils'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport type { AbortOptions, MultiaddrConnection } from '@libp2p/interface'\nimport type { AbstractMultiaddrConnectionInit, RepeatingTask, SendResult } from '@libp2p/utils'\n\nconst DEFAULT_MAX_BUFFERED_AMOUNT = 1024 * 1024 * 4\nconst DEFAULT_BUFFERED_AMOUNT_POLL_INTERVAL = 10\n\nexport interface WebSocketMultiaddrConnectionInit extends Omit<AbstractMultiaddrConnectionInit, 'name'> {\n  websocket: WebSocket\n  maxBufferedAmount?: number\n  bufferedAmountPollInterval?: number\n}\n\nclass WebSocketMultiaddrConnection extends AbstractMultiaddrConnection {\n  private websocket: WebSocket\n  private maxBufferedAmount: number\n  private checkBufferedAmountTask: RepeatingTask\n\n  constructor (init: WebSocketMultiaddrConnectionInit) {\n    super(init)\n\n    this.websocket = init.websocket\n    this.maxBufferedAmount = init.maxBufferedAmount ?? DEFAULT_MAX_BUFFERED_AMOUNT\n    this.checkBufferedAmountTask = repeatingTask(this.checkBufferedAmount.bind(this), init.bufferedAmountPollInterval ?? DEFAULT_BUFFERED_AMOUNT_POLL_INTERVAL)\n\n    this.websocket.addEventListener('close', (evt) => {\n      this.log('closed - code %d, reason \"%s\", wasClean %s', evt.code, evt.reason, evt.wasClean)\n      this.checkBufferedAmountTask.stop()\n\n      if (!evt.wasClean) {\n        this.onRemoteReset()\n        return\n      }\n\n      this.onTransportClosed()\n    }, { once: true })\n\n    this.websocket.addEventListener('message', (evt) => {\n      try {\n        let buf: Uint8Array\n\n        if (typeof evt.data === 'string') {\n          buf = uint8ArrayFromString(evt.data)\n        } else if (evt.data instanceof ArrayBuffer) {\n          buf = new Uint8Array(evt.data, 0, evt.data.byteLength)\n        } else {\n          this.abort(new Error('Incorrect binary type'))\n          return\n        }\n\n        this.onData(buf)\n      } catch (err: any) {\n        this.log.error('error receiving data - %e', err)\n      }\n    })\n  }\n\n  sendData (data: Uint8ArrayList): SendResult {\n    for (const buf of data) {\n      this.websocket.send(buf)\n    }\n\n    const canSendMore = this.websocket.bufferedAmount < this.maxBufferedAmount\n\n    if (!canSendMore) {\n      this.checkBufferedAmountTask.start()\n    }\n\n    return {\n      sentBytes: data.byteLength,\n      canSendMore\n    }\n  }\n\n  sendReset (): void {\n    this.websocket.close(1006) // abnormal closure\n  }\n\n  async sendClose (options?: AbortOptions): Promise<void> {\n    this.websocket.close()\n    options?.signal?.throwIfAborted()\n  }\n\n  sendPause (): void {\n    // read backpressure is not supported\n  }\n\n  sendResume (): void {\n    // read backpressure is not supported\n  }\n\n  private checkBufferedAmount (): void {\n    this.log('buffered amount now %d', this.websocket.bufferedAmount)\n\n    if (this.websocket.bufferedAmount === 0) {\n      this.checkBufferedAmountTask.stop()\n      this.safeDispatchEvent('drain')\n    }\n  }\n}\n\n// Convert a stream into a MultiaddrConnection\n// https://github.com/libp2p/interface-transport#multiaddrconnection\nexport function webSocketToMaConn (init: WebSocketMultiaddrConnectionInit): MultiaddrConnection {\n  return new WebSocketMultiaddrConnection(init)\n}\n", "/**\n * @packageDocumentation\n *\n * A [libp2p transport](https://docs.libp2p.io/concepts/transports/overview/) based on [WebSockets](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API).\n *\n * @example\n *\n * ```TypeScript\n * import { createLibp2p } from 'libp2p'\n * import { webSockets } from '@libp2p/websockets'\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const node = await createLibp2p({\n *   transports: [\n *     webSockets()\n *   ]\n * //... other config\n * })\n * await node.start()\n *\n * const ma = multiaddr('/dns4/example.com/tcp/9090/tls/ws')\n * await node.dial(ma)\n * ```\n */\n\nimport { transportSymbol, serviceCapabilities, ConnectionFailedError } from '@libp2p/interface'\nimport { WebSockets as WebSocketsMatcher, WebSocketsSecure } from '@multiformats/multiaddr-matcher'\nimport { multiaddrToUri as toUri } from '@multiformats/multiaddr-to-uri'\nimport { pEvent } from 'p-event'\nimport { CustomProgressEvent } from 'progress-events'\nimport { createListener } from './listener.js'\nimport { webSocketToMaConn } from './websocket-to-conn.js'\nimport type { Transport, CreateListenerOptions, DialTransportOptions, Listener, AbortOptions, ComponentLogger, Logger, Connection, OutboundConnectionUpgradeEvents, Metrics, CounterGroup, Libp2pEvents } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { TypedEventTarget } from 'main-event'\nimport type http from 'node:http'\nimport type https from 'node:https'\nimport type { ProgressEvent } from 'progress-events'\n\nexport interface WebSocketsInit extends AbortOptions {\n  /**\n   * Options used to create the HTTP server\n   */\n  http?: http.ServerOptions\n\n  /**\n   * Options used to create the HTTPs server. `options.http` will be used if\n   * unspecified.\n   */\n  https?: https.ServerOptions\n\n  /**\n   * How large the outgoing [bufferedAmount](https://websockets.spec.whatwg.org/#dom-websocket-bufferedamount)\n   * property of incoming and outgoing websockets is allowed to get in bytes.\n   *\n   * If this limit is exceeded, backpressure will be applied to the writer.\n   *\n   * @default 4_194_304\n   */\n  maxBufferedAmount?: number\n\n  /**\n   * If the [bufferedAmount](https://websockets.spec.whatwg.org/#dom-websocket-bufferedamount)\n   * property of a WebSocket exceeds `maxBufferedAmount`, poll the field every\n   * this number of ms to see if the socket can accept new data.\n   *\n   * @default 500\n   */\n  bufferedAmountPollInterval?: number\n}\n\nexport interface WebSocketsComponents {\n  logger: ComponentLogger\n  events: TypedEventTarget<Libp2pEvents>\n  metrics?: Metrics\n}\n\nexport interface WebSocketsMetrics {\n  dialerEvents: CounterGroup\n}\n\nexport type WebSocketsDialEvents =\n  OutboundConnectionUpgradeEvents |\n  ProgressEvent<'websockets:open-connection'>\n\nclass WebSockets implements Transport<WebSocketsDialEvents> {\n  private readonly log: Logger\n  private readonly init: WebSocketsInit\n  private readonly logger: ComponentLogger\n  private readonly metrics?: WebSocketsMetrics\n  private readonly components: WebSocketsComponents\n\n  constructor (components: WebSocketsComponents, init: WebSocketsInit = {}) {\n    this.log = components.logger.forComponent('libp2p:websockets')\n    this.logger = components.logger\n    this.components = components\n    this.init = init\n\n    if (components.metrics != null) {\n      this.metrics = {\n        dialerEvents: components.metrics.registerCounterGroup('libp2p_websockets_dialer_events_total', {\n          label: 'event',\n          help: 'Total count of WebSockets dialer events by type'\n        })\n      }\n    }\n  }\n\n  readonly [transportSymbol] = true\n\n  readonly [Symbol.toStringTag] = '@libp2p/websockets'\n\n  readonly [serviceCapabilities]: string[] = [\n    '@libp2p/transport'\n  ]\n\n  async dial (ma: Multiaddr, options: DialTransportOptions<WebSocketsDialEvents>): Promise<Connection> {\n    this.log('dialing %s', ma)\n    options = options ?? {}\n\n    const maConn = webSocketToMaConn({\n      websocket: await this._connect(ma, options),\n      remoteAddr: ma,\n      metrics: this.metrics?.dialerEvents,\n      direction: 'outbound',\n      log: this.components.logger.forComponent('libp2p:websockets:connection'),\n      maxBufferedAmount: this.init.maxBufferedAmount,\n      bufferedAmountPollInterval: this.init.bufferedAmountPollInterval\n    })\n    this.log('new outbound connection %s', maConn.remoteAddr)\n\n    const conn = await options.upgrader.upgradeOutbound(maConn, options)\n    this.log('outbound connection %s upgraded', maConn.remoteAddr)\n    return conn\n  }\n\n  async _connect (ma: Multiaddr, options: DialTransportOptions<WebSocketsDialEvents>): Promise<WebSocket> {\n    options?.signal?.throwIfAborted()\n\n    const uri = toUri(ma)\n    this.log('create websocket connection to %s', uri)\n    const websocket = new WebSocket(uri)\n    websocket.binaryType = 'arraybuffer'\n\n    try {\n      options.onProgress?.(new CustomProgressEvent('websockets:open-connection'))\n      await pEvent(websocket, 'open', options)\n    } catch (err: any) {\n      if (options.signal?.aborted) {\n        this.metrics?.dialerEvents.increment({ abort: true })\n        throw new ConnectionFailedError(`Could not connect to ${uri}`)\n      } else {\n        this.metrics?.dialerEvents.increment({ error: true })\n      }\n\n      try {\n        websocket.close()\n      } catch {}\n\n      throw err\n    }\n\n    this.log('connected %s', ma)\n    this.metrics?.dialerEvents.increment({ connect: true })\n    return websocket\n  }\n\n  /**\n   * Creates a WebSockets listener. The provided `handler` function will be called\n   * anytime a new incoming Connection has been successfully upgraded via\n   * `upgrader.upgradeInbound`\n   */\n  createListener (options: CreateListenerOptions): Listener {\n    return createListener({\n      logger: this.logger,\n      events: this.components.events,\n      metrics: this.components.metrics\n    }, {\n      ...this.init,\n      ...options\n    })\n  }\n\n  listenFilter (multiaddrs: Multiaddr[]): Multiaddr[] {\n    return multiaddrs.filter(ma => WebSocketsMatcher.exactMatch(ma) || WebSocketsSecure.exactMatch(ma))\n  }\n\n  dialFilter (multiaddrs: Multiaddr[]): Multiaddr[] {\n    return this.listenFilter(multiaddrs)\n  }\n}\n\nexport function webSockets (init: WebSocketsInit = {}): (components: WebSocketsComponents) => Transport {\n  return (components) => {\n    return new WebSockets(components, init)\n  }\n}\n"],
  "mappings": "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",
  "names": ["_a", "_a", "WebSockets", "_a", "_b", "_c"]
}
