import {
  parallel,
  src_default
} from "./chunk-H4CW4VU3.js";
import {
  PeerRecord,
  RecordEnvelope
} from "./chunk-H65XI27X.js";
import {
  IP_OR_DOMAIN,
  TCP
} from "./chunk-7DMLAAL4.js";
import {
  debounce,
  isGlobalUnicast,
  isPrivate,
  pbStream
} from "./chunk-FAMYN5K7.js";
import "./chunk-MXJRKQ3V.js";
import {
  CODE_IP6,
  CODE_IP6ZONE,
  CODE_P2P,
  multiaddr
} from "./chunk-SAZZGDH5.js";
import {
  peerIdFromCID,
  peerIdFromPublicKey
} from "./chunk-RA2DG4WK.js";
import {
  InvalidMessageError,
  MaxLengthError,
  decodeMessage,
  encodeMessage,
  message,
  publicKeyFromProtobuf,
  publicKeyToProtobuf,
  serviceCapabilities,
  setMaxListeners
} from "./chunk-HXWYJQY6.js";
import {
  fromString,
  toString
} from "./chunk-PS3LPXH2.js";
import {
  __publicField
} from "./chunk-WOOG5QLI.js";

// ../../node_modules/@libp2p/identify/dist/src/consts.js
var IDENTIFY_PROTOCOL_VERSION = "0.1.0";
var MULTICODEC_IDENTIFY_PROTOCOL_NAME = "id";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = "id/push";
var MULTICODEC_IDENTIFY_PROTOCOL_VERSION = "1.0.0";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = "1.0.0";
var MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8;
var MAX_PUSH_CONCURRENCY = 32;
var PUSH_DEBOUNCE_MS = 1e3;

// ../../node_modules/@libp2p/identify/dist/src/pb/message.js
var Identify;
(function(Identify3) {
  let _codec;
  Identify3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.protocolVersion != null) {
          w.uint32(42);
          w.string(obj.protocolVersion);
        }
        if (obj.agentVersion != null) {
          w.uint32(50);
          w.string(obj.agentVersion);
        }
        if (obj.publicKey != null) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (obj.listenAddrs != null) {
          for (const value of obj.listenAddrs) {
            w.uint32(18);
            w.bytes(value);
          }
        }
        if (obj.observedAddr != null) {
          w.uint32(34);
          w.bytes(obj.observedAddr);
        }
        if (obj.protocols != null) {
          for (const value of obj.protocols) {
            w.uint32(26);
            w.string(value);
          }
        }
        if (obj.signedPeerRecord != null) {
          w.uint32(66);
          w.bytes(obj.signedPeerRecord);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        var _a3, _b3;
        const obj = {
          listenAddrs: [],
          protocols: []
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 5: {
              obj.protocolVersion = reader.string();
              break;
            }
            case 6: {
              obj.agentVersion = reader.string();
              break;
            }
            case 1: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 2: {
              if (((_a3 = opts.limits) == null ? void 0 : _a3.listenAddrs) != null && obj.listenAddrs.length === opts.limits.listenAddrs) {
                throw new MaxLengthError('Decode error - map field "listenAddrs" had too many elements');
              }
              obj.listenAddrs.push(reader.bytes());
              break;
            }
            case 4: {
              obj.observedAddr = reader.bytes();
              break;
            }
            case 3: {
              if (((_b3 = opts.limits) == null ? void 0 : _b3.protocols) != null && obj.protocols.length === opts.limits.protocols) {
                throw new MaxLengthError('Decode error - map field "protocols" had too many elements');
              }
              obj.protocols.push(reader.string());
              break;
            }
            case 8: {
              obj.signedPeerRecord = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Identify3.encode = (obj) => {
    return encodeMessage(obj, Identify3.codec());
  };
  Identify3.decode = (buf, opts) => {
    return decodeMessage(buf, Identify3.codec(), opts);
  };
})(Identify || (Identify = {}));

// ../../node_modules/@libp2p/identify/dist/src/utils.js
var defaultValues = {
  protocolPrefix: "ipfs",
  timeout: 5e3,
  maxInboundStreams: 1,
  maxOutboundStreams: 1,
  maxObservedAddresses: 10,
  maxMessageSize: MAX_IDENTIFY_MESSAGE_SIZE,
  runOnConnectionOpen: true,
  runOnSelfUpdate: true,
  runOnLimitedConnection: true,
  concurrency: MAX_PUSH_CONCURRENCY
};
function getCleanMultiaddr(addr) {
  if (addr != null && addr.length > 0) {
    try {
      return multiaddr(addr);
    } catch {
    }
  }
}
async function consumeIdentifyMessage(peerStore, events, log, connection, message2) {
  log("received identify from %p", connection.remotePeer);
  if (message2 == null) {
    throw new InvalidMessageError("message was null or undefined");
  }
  const peer = {};
  if (message2.listenAddrs.length > 0) {
    peer.addresses = message2.listenAddrs.map((buf) => ({
      isCertified: false,
      multiaddr: multiaddr(buf)
    }));
  }
  if (message2.protocols.length > 0) {
    peer.protocols = message2.protocols;
  }
  if (message2.publicKey != null) {
    const publicKey = publicKeyFromProtobuf(message2.publicKey);
    const peerId = peerIdFromPublicKey(publicKey);
    if (!peerId.equals(connection.remotePeer)) {
      throw new InvalidMessageError("public key did not match remote PeerId");
    }
    peer.publicKey = publicKey;
  }
  let output;
  if (message2.signedPeerRecord != null) {
    log.trace("received signedPeerRecord from %p", connection.remotePeer);
    let peerRecordEnvelope = message2.signedPeerRecord;
    const envelope = await RecordEnvelope.openAndCertify(peerRecordEnvelope, PeerRecord.DOMAIN);
    let peerRecord = PeerRecord.createFromProtobuf(envelope.payload);
    const envelopePeer = peerIdFromCID(envelope.publicKey.toCID());
    if (!peerRecord.peerId.equals(envelopePeer)) {
      throw new InvalidMessageError("signing key does not match PeerId in the PeerRecord");
    }
    if (!connection.remotePeer.equals(peerRecord.peerId)) {
      throw new InvalidMessageError("signing key does not match remote PeerId");
    }
    let existingPeer;
    try {
      existingPeer = await peerStore.get(peerRecord.peerId);
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
    }
    if (existingPeer != null) {
      peer.metadata = existingPeer.metadata;
      if (existingPeer.peerRecordEnvelope != null) {
        const storedEnvelope = RecordEnvelope.createFromProtobuf(existingPeer.peerRecordEnvelope);
        const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload);
        if (storedRecord.seqNumber >= peerRecord.seqNumber) {
          log("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
          peerRecord = storedRecord;
          peerRecordEnvelope = existingPeer.peerRecordEnvelope;
        }
      }
    }
    peer.peerRecordEnvelope = peerRecordEnvelope;
    peer.addresses = peerRecord.multiaddrs.map((multiaddr2) => ({
      isCertified: true,
      multiaddr: multiaddr2
    }));
    output = {
      seq: peerRecord.seqNumber,
      addresses: peerRecord.multiaddrs
    };
  } else {
    log("%p did not send a signed peer record", connection.remotePeer);
  }
  log.trace("patching %p with", connection.remotePeer, peer);
  await peerStore.patch(connection.remotePeer, peer);
  if (message2.agentVersion != null || message2.protocolVersion != null) {
    const metadata = {};
    if (message2.agentVersion != null) {
      metadata.AgentVersion = fromString(message2.agentVersion);
    }
    if (message2.protocolVersion != null) {
      metadata.ProtocolVersion = fromString(message2.protocolVersion);
    }
    log.trace("merging %p metadata", connection.remotePeer, metadata);
    await peerStore.merge(connection.remotePeer, {
      metadata
    });
  }
  const result = {
    peerId: connection.remotePeer,
    protocolVersion: message2.protocolVersion,
    agentVersion: message2.agentVersion,
    publicKey: message2.publicKey,
    listenAddrs: message2.listenAddrs.map((buf) => multiaddr(buf)),
    observedAddr: message2.observedAddr == null ? void 0 : multiaddr(message2.observedAddr),
    protocols: message2.protocols,
    signedPeerRecord: output,
    connection
  };
  events.safeDispatchEvent("peer:identify", { detail: result });
  return result;
}
var AbstractIdentify = class {
  constructor(components, init) {
    __publicField(this, "host");
    __publicField(this, "components");
    __publicField(this, "protocol");
    __publicField(this, "started");
    __publicField(this, "timeout");
    __publicField(this, "maxInboundStreams");
    __publicField(this, "maxOutboundStreams");
    __publicField(this, "maxMessageSize");
    __publicField(this, "maxObservedAddresses");
    __publicField(this, "runOnLimitedConnection");
    __publicField(this, "log");
    this.protocol = init.protocol;
    this.started = false;
    this.components = components;
    this.log = init.log;
    this.timeout = init.timeout ?? defaultValues.timeout;
    this.maxInboundStreams = init.maxInboundStreams ?? defaultValues.maxInboundStreams;
    this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues.maxOutboundStreams;
    this.maxMessageSize = init.maxMessageSize ?? defaultValues.maxMessageSize;
    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues.maxObservedAddresses;
    this.runOnLimitedConnection = init.runOnLimitedConnection ?? defaultValues.runOnLimitedConnection;
    this.host = {
      protocolVersion: `${init.protocolPrefix ?? defaultValues.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,
      agentVersion: components.nodeInfo.userAgent
    };
    this.handleProtocol = this.handleProtocol.bind(this);
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    await this.components.peerStore.merge(this.components.peerId, {
      metadata: {
        AgentVersion: fromString(this.host.agentVersion),
        ProtocolVersion: fromString(this.host.protocolVersion)
      }
    });
    await this.components.registrar.handle(this.protocol, this.handleProtocol, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnLimitedConnection: this.runOnLimitedConnection
    });
    this.started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(this.protocol);
    this.started = false;
  }
};

// ../../node_modules/@libp2p/identify/dist/src/identify-push.js
var _a, _b;
var IdentifyPush = class extends (_b = AbstractIdentify, _a = serviceCapabilities, _b) {
  constructor(components, init = {}) {
    super(components, {
      ...init,
      protocol: `/${init.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`,
      log: components.logger.forComponent("libp2p:identify-push")
    });
    __publicField(this, "connectionManager");
    __publicField(this, "concurrency");
    __publicField(this, "_push");
    __publicField(this, _a, [
      "@libp2p/identify-push"
    ]);
    this.connectionManager = components.connectionManager;
    this.concurrency = init.concurrency ?? defaultValues.concurrency;
    this._push = debounce(this.sendPushMessage.bind(this), init.debounce ?? PUSH_DEBOUNCE_MS);
    if (init.runOnSelfUpdate ?? defaultValues.runOnSelfUpdate) {
      components.events.addEventListener("self:peer:update", (evt) => {
        this.push().catch((err) => {
          this.log.error("error pushing updates to peers - %e", err);
        });
      });
    }
  }
  /**
   * Calls `push` on all peer connections
   */
  async push() {
    this._push();
  }
  async sendPushMessage() {
    if (!this.isStarted()) {
      return;
    }
    try {
      const listenAddresses = this.components.addressManager.getAddresses().map((ma) => ma.decapsulateCode(CODE_P2P));
      const peerRecord = new PeerRecord({
        peerId: this.components.peerId,
        multiaddrs: listenAddresses
      });
      const signedPeerRecord = await RecordEnvelope.seal(peerRecord, this.components.privateKey);
      const supportedProtocols = this.components.registrar.getProtocols();
      const peer = await this.components.peerStore.get(this.components.peerId);
      const agentVersion = toString(peer.metadata.get("AgentVersion") ?? fromString(this.host.agentVersion));
      const protocolVersion = toString(peer.metadata.get("ProtocolVersion") ?? fromString(this.host.protocolVersion));
      const self = this;
      async function* pushToConnections() {
        for (const connection of self.connectionManager.getConnections()) {
          const peer2 = await self.components.peerStore.get(connection.remotePeer);
          if (!peer2.protocols.includes(self.protocol)) {
            continue;
          }
          yield async () => {
            let stream;
            const signal = AbortSignal.timeout(self.timeout);
            setMaxListeners(Infinity, signal);
            try {
              stream = await connection.newStream(self.protocol, {
                signal,
                runOnLimitedConnection: self.runOnLimitedConnection
              });
              const pb = pbStream(stream, {
                maxDataLength: self.maxMessageSize
              }).pb(Identify);
              await pb.write({
                listenAddrs: listenAddresses.map((ma) => ma.bytes),
                signedPeerRecord: signedPeerRecord.marshal(),
                protocols: supportedProtocols,
                agentVersion,
                protocolVersion
              }, {
                signal
              });
              await stream.close({
                signal
              });
            } catch (err) {
              const log = stream == null ? void 0 : stream.log.newScope("identify-push");
              log == null ? void 0 : log.error("could not push identify update to peer", err);
              stream == null ? void 0 : stream.abort(err);
            }
          };
        }
      }
      await src_default(parallel(pushToConnections(), {
        concurrency: this.concurrency
      }));
    } catch (err) {
      this.log.error("error pushing updates to peers - %e", err);
    }
  }
  /**
   * Reads the Identify Push message from the given `connection`
   */
  async handleProtocol(stream, connection) {
    const log = stream.log.newScope("identify-push");
    if (this.components.peerId.equals(connection.remotePeer)) {
      throw new Error("received push from ourselves?");
    }
    const options = {
      signal: AbortSignal.timeout(this.timeout)
    };
    const pb = pbStream(stream, {
      maxDataLength: this.maxMessageSize
    }).pb(Identify);
    const message2 = await pb.read(options);
    await stream.close(options);
    await consumeIdentifyMessage(this.components.peerStore, this.components.events, log, connection, message2);
    log.trace("handled push from %p", connection.remotePeer);
  }
};

// ../../node_modules/@libp2p/identify/dist/src/identify.js
var _a2, _b2;
var Identify2 = class extends (_b2 = AbstractIdentify, _a2 = serviceCapabilities, _b2) {
  constructor(components, init = {}) {
    super(components, {
      ...init,
      protocol: `/${init.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`,
      log: components.logger.forComponent("libp2p:identify")
    });
    __publicField(this, _a2, [
      "@libp2p/identify"
    ]);
    if (init.runOnConnectionOpen ?? defaultValues.runOnConnectionOpen) {
      components.events.addEventListener("connection:open", (evt) => {
        const connection = evt.detail;
        this.identify(connection).catch(() => {
        });
      });
    }
  }
  async _identify(connection, options = {}) {
    let stream;
    let log;
    if (options.signal == null) {
      const signal = AbortSignal.timeout(this.timeout);
      setMaxListeners(Infinity, signal);
      options = {
        ...options,
        signal
      };
    }
    this.log("run identify on new connection %a", connection.remoteAddr);
    try {
      stream = await connection.newStream(this.protocol, {
        ...options,
        runOnLimitedConnection: this.runOnLimitedConnection
      });
      log = stream.log.newScope("identify");
      const pb = pbStream(stream, {
        maxDataLength: this.maxMessageSize
      }).pb(Identify);
      const message2 = await pb.read(options);
      await pb.unwrap().unwrap().close(options);
      return message2;
    } catch (err) {
      log == null ? void 0 : log.error("identify failed - %e", err);
      stream == null ? void 0 : stream.abort(err);
      throw err;
    }
  }
  async identify(connection, options = {}) {
    const message2 = await this._identify(connection, options);
    const { publicKey, protocols, observedAddr } = message2;
    if (publicKey == null) {
      throw new InvalidMessageError("Public key was missing from identify message");
    }
    const key = publicKeyFromProtobuf(publicKey);
    const id = peerIdFromCID(key.toCID());
    if (!connection.remotePeer.equals(id)) {
      throw new InvalidMessageError("Identified peer does not match the expected peer");
    }
    if (this.components.peerId.equals(id)) {
      throw new InvalidMessageError("Identified peer is our own peer id?");
    }
    this.maybeAddObservedAddress(observedAddr);
    this.log("completed for peer %p and protocols %o", id, protocols);
    return consumeIdentifyMessage(this.components.peerStore, this.components.events, this.log, connection, message2);
  }
  maybeAddObservedAddress(observedAddr) {
    const cleanObservedAddr = getCleanMultiaddr(observedAddr);
    if (cleanObservedAddr == null) {
      return;
    }
    this.log.trace("our observed address was %a", cleanObservedAddr);
    if (isPrivate(cleanObservedAddr)) {
      return;
    }
    const tuples = cleanObservedAddr.getComponents();
    if ((tuples[0].code === CODE_IP6 || tuples[0].code === CODE_IP6ZONE && tuples[1].code === CODE_IP6) && !isGlobalUnicast(cleanObservedAddr)) {
      this.log.trace("our observed address was IPv6 but not a global unicast address");
      return;
    }
    if (TCP.exactMatch(cleanObservedAddr)) {
      return;
    }
    this.log.trace("storing the observed address");
    this.components.addressManager.addObservedAddr(cleanObservedAddr);
  }
  /**
   * Sends the `Identify` response with the Signed Peer Record
   * to the requesting peer over the given `connection`
   */
  async handleProtocol(stream, connection) {
    const log = stream.log.newScope("identify");
    log("responding to identify");
    const signal = AbortSignal.timeout(this.timeout);
    setMaxListeners(Infinity, signal);
    const peerData = await this.components.peerStore.get(this.components.peerId, {
      signal
    });
    const multiaddrs = this.components.addressManager.getAddresses().map((ma) => ma.decapsulateCode(CODE_P2P));
    let signedPeerRecord = peerData.peerRecordEnvelope;
    if (multiaddrs.length > 0 && signedPeerRecord == null) {
      const peerRecord = new PeerRecord({
        peerId: this.components.peerId,
        multiaddrs
      });
      const envelope = await RecordEnvelope.seal(peerRecord, this.components.privateKey, {
        signal
      });
      signedPeerRecord = envelope.marshal().subarray();
    }
    let observedAddr = connection.remoteAddr.bytes;
    if (!IP_OR_DOMAIN.matches(connection.remoteAddr)) {
      observedAddr = void 0;
    }
    const pb = pbStream(stream).pb(Identify);
    log("send response");
    await pb.write({
      protocolVersion: this.host.protocolVersion,
      agentVersion: this.host.agentVersion,
      publicKey: publicKeyToProtobuf(this.components.privateKey.publicKey),
      listenAddrs: multiaddrs.map((addr) => addr.bytes),
      signedPeerRecord,
      observedAddr,
      protocols: peerData.protocols
    }, {
      signal
    });
    log("close write");
    await pb.unwrap().unwrap().close({
      signal
    });
  }
};

// ../../node_modules/@libp2p/identify/dist/src/index.js
function identify(init = {}) {
  return (components) => new Identify2(components, init);
}
function identifyPush(init = {}) {
  return (components) => new IdentifyPush(components, init);
}
export {
  identify,
  identifyPush
};
//# sourceMappingURL=@libp2p_identify.js.map
