import {
  pEvent,
  raceSignal
} from "./chunk-MXJRKQ3V.js";
import {
  ProtocolError,
  TimeoutError,
  Uint8ArrayList,
  randomBytes,
  serviceCapabilities,
  setMaxListeners
} from "./chunk-HXWYJQY6.js";
import {
  equals
} from "./chunk-PS3LPXH2.js";
import {
  __publicField
} from "./chunk-WOOG5QLI.js";

// ../../node_modules/@libp2p/ping/dist/src/constants.js
var PING_PROTOCOL = "/ipfs/ping/1.0.0";
var PING_LENGTH = 32;
var PROTOCOL_VERSION = "1.0.0";
var PROTOCOL_NAME = "ping";
var PROTOCOL_PREFIX = "ipfs";
var TIMEOUT = 1e4;
var MAX_INBOUND_STREAMS = 2;
var MAX_OUTBOUND_STREAMS = 1;

// ../../node_modules/@libp2p/ping/dist/src/ping.js
var _a, _b;
_b = Symbol.toStringTag, _a = serviceCapabilities;
var Ping = class {
  constructor(components, init = {}) {
    __publicField(this, "protocol");
    __publicField(this, "components");
    __publicField(this, "started");
    __publicField(this, "timeout");
    __publicField(this, "maxInboundStreams");
    __publicField(this, "maxOutboundStreams");
    __publicField(this, "runOnLimitedConnection");
    __publicField(this, _b, "@libp2p/ping");
    __publicField(this, _a, [
      "@libp2p/ping"
    ]);
    this.components = components;
    this.started = false;
    this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;
    this.timeout = init.timeout ?? TIMEOUT;
    this.maxInboundStreams = init.maxInboundStreams ?? MAX_INBOUND_STREAMS;
    this.maxOutboundStreams = init.maxOutboundStreams ?? MAX_OUTBOUND_STREAMS;
    this.runOnLimitedConnection = init.runOnLimitedConnection ?? true;
    this.handlePing = this.handlePing.bind(this);
  }
  async start() {
    await this.components.registrar.handle(this.protocol, this.handlePing, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnLimitedConnection: this.runOnLimitedConnection
    });
    this.started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(this.protocol);
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  /**
   * A handler to register with Libp2p to process ping messages
   */
  async handlePing(stream, connection) {
    const log = stream.log.newScope("ping");
    log.trace("ping from %p", connection.remotePeer);
    const signal = AbortSignal.timeout(this.timeout);
    setMaxListeners(Infinity, signal);
    signal.addEventListener("abort", () => {
      stream.abort(new TimeoutError("Ping timed out"));
    });
    const start = Date.now();
    for await (const buf of stream) {
      if (stream.status !== "open") {
        log("stream status changed to %s", stream.status);
        break;
      }
      if (!stream.send(buf)) {
        log("waiting for stream to drain");
        await pEvent(stream, "drain", {
          rejectionEvents: [
            "close"
          ],
          signal
        });
        log("stream drained");
      }
    }
    log("ping from %p complete in %dms", connection.remotePeer, Date.now() - start);
    await stream.close({
      signal
    });
  }
  /**
   * Ping a given peer and wait for its response, getting the operation latency.
   */
  async ping(peer, options = {}) {
    const data = randomBytes(PING_LENGTH);
    const stream = await this.components.connectionManager.openStream(peer, this.protocol, {
      runOnLimitedConnection: this.runOnLimitedConnection,
      ...options
    });
    const log = stream.log.newScope("ping");
    try {
      const start = Date.now();
      const finished = Promise.withResolvers();
      const received = new Uint8ArrayList();
      const onPong = (evt) => {
        received.append(evt.data);
        if (received.byteLength === PING_LENGTH) {
          stream.removeEventListener("message", onPong);
          const rtt = Date.now() - start;
          Promise.all([
            stream.closeRead(options)
          ]).then(() => {
            if (!equals(data, received.subarray())) {
              throw new ProtocolError(`Received wrong ping ack after ${rtt}ms`);
            } else {
              finished.resolve(rtt);
            }
          }).catch((err) => {
            stream.abort(err);
            finished.reject(err);
          });
        }
      };
      stream.addEventListener("message", onPong);
      stream.send(data);
      await stream.close(options);
      return await raceSignal(finished.promise, options.signal);
    } catch (err) {
      log.error("error while pinging %o - %e", peer, err);
      stream == null ? void 0 : stream.abort(err);
      throw err;
    } finally {
      stream == null ? void 0 : stream.close();
    }
  }
};

// ../../node_modules/@libp2p/ping/dist/src/index.js
function ping(init = {}) {
  return (components) => new Ping(components, init);
}
export {
  PING_PROTOCOL,
  ping
};
//# sourceMappingURL=@libp2p_ping.js.map
