{
  "version": 3,
  "sources": ["../../../../../node_modules/@libp2p/ping/src/constants.ts", "../../../../../node_modules/@libp2p/ping/src/ping.ts", "../../../../../node_modules/@libp2p/ping/src/index.ts"],
  "sourcesContent": ["export const PING_PROTOCOL = '/ipfs/ping/1.0.0'\nexport const PING_LENGTH = 32\nexport const PROTOCOL_VERSION = '1.0.0'\nexport const PROTOCOL_NAME = 'ping'\nexport const PROTOCOL_PREFIX = 'ipfs'\nexport const TIMEOUT = 10000\n\n// See https://github.com/libp2p/specs/blob/d4b5fb0152a6bb86cfd9ea/ping/ping.md?plain=1#L38-L43\n// The dialing peer MUST NOT keep more than one outbound stream for the ping protocol per peer.\n// The listening peer SHOULD accept at most two streams per peer since cross-stream behavior is\n// non-linear and stream writes occur asynchronously. The listening peer may perceive the\n// dialing peer closing and opening the wrong streams (for instance, closing stream B and\n// opening stream A even though the dialing peer is opening stream B and closing stream A).\nexport const MAX_INBOUND_STREAMS = 2\nexport const MAX_OUTBOUND_STREAMS = 1\n", "import { randomBytes } from '@libp2p/crypto'\nimport { ProtocolError, serviceCapabilities, setMaxListeners, TimeoutError } from '@libp2p/interface'\nimport { pEvent } from 'p-event'\nimport { raceSignal } from 'race-signal'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { PROTOCOL_PREFIX, PROTOCOL_NAME, PING_LENGTH, PROTOCOL_VERSION, TIMEOUT, MAX_INBOUND_STREAMS, MAX_OUTBOUND_STREAMS } from './constants.js'\nimport type { PingComponents, PingInit, Ping as PingInterface } from './index.js'\nimport type { AbortOptions, Stream, PeerId, Startable, Connection, StreamMessageEvent } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport class Ping implements Startable, PingInterface {\n  public readonly protocol: string\n  private readonly components: PingComponents\n  private started: boolean\n  private readonly timeout: number\n  private readonly maxInboundStreams: number\n  private readonly maxOutboundStreams: number\n  private readonly runOnLimitedConnection: boolean\n\n  constructor (components: PingComponents, init: PingInit = {}) {\n    this.components = components\n    this.started = false\n    this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`\n    this.timeout = init.timeout ?? TIMEOUT\n    this.maxInboundStreams = init.maxInboundStreams ?? MAX_INBOUND_STREAMS\n    this.maxOutboundStreams = init.maxOutboundStreams ?? MAX_OUTBOUND_STREAMS\n    this.runOnLimitedConnection = init.runOnLimitedConnection ?? true\n\n    this.handlePing = this.handlePing.bind(this)\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/ping'\n\n  readonly [serviceCapabilities]: string[] = [\n    '@libp2p/ping'\n  ]\n\n  async start (): Promise<void> {\n    await this.components.registrar.handle(this.protocol, this.handlePing, {\n      maxInboundStreams: this.maxInboundStreams,\n      maxOutboundStreams: this.maxOutboundStreams,\n      runOnLimitedConnection: this.runOnLimitedConnection\n    })\n    this.started = true\n  }\n\n  async stop (): Promise<void> {\n    await this.components.registrar.unhandle(this.protocol)\n    this.started = false\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  /**\n   * A handler to register with Libp2p to process ping messages\n   */\n  async handlePing (stream: Stream, connection: Connection): Promise<void> {\n    const log = stream.log.newScope('ping')\n    log.trace('ping from %p', connection.remotePeer)\n    const signal = AbortSignal.timeout(this.timeout)\n    setMaxListeners(Infinity, signal)\n    signal.addEventListener('abort', () => {\n      stream.abort(new TimeoutError('Ping timed out'))\n    })\n    const start = Date.now()\n\n    for await (const buf of stream) {\n      if (stream.status !== 'open') {\n        log('stream status changed to %s', stream.status)\n        break\n      }\n\n      if (!stream.send(buf)) {\n        log('waiting for stream to drain')\n        await pEvent(stream, 'drain', {\n          rejectionEvents: [\n            'close'\n          ],\n          signal\n        })\n        log('stream drained')\n      }\n    }\n\n    log('ping from %p complete in %dms', connection.remotePeer, Date.now() - start)\n\n    await stream.close({\n      signal\n    })\n  }\n\n  /**\n   * Ping a given peer and wait for its response, getting the operation latency.\n   */\n  async ping (peer: PeerId | Multiaddr | Multiaddr[], options: AbortOptions = {}): Promise<number> {\n    const data = randomBytes(PING_LENGTH)\n    const stream = await this.components.connectionManager.openStream(peer, this.protocol, {\n      runOnLimitedConnection: this.runOnLimitedConnection,\n      ...options\n    })\n    const log = stream.log.newScope('ping')\n\n    try {\n      const start = Date.now()\n      const finished = Promise.withResolvers<number>()\n      const received = new Uint8ArrayList()\n\n      const onPong = (evt: StreamMessageEvent): void => {\n        received.append(evt.data)\n\n        if (received.byteLength === PING_LENGTH) {\n          stream.removeEventListener('message', onPong)\n\n          const rtt = Date.now() - start\n\n          Promise.all([\n            stream.closeRead(options)\n          ])\n            .then(() => {\n              if (!uint8ArrayEquals(data, received.subarray())) {\n                throw new ProtocolError(`Received wrong ping ack after ${rtt}ms`)\n              } else {\n                finished.resolve(rtt)\n              }\n            })\n            .catch(err => {\n              stream.abort(err)\n              finished.reject(err)\n            })\n        }\n      }\n\n      stream.addEventListener('message', onPong)\n      stream.send(data)\n      await stream.close(options)\n\n      return await raceSignal(finished.promise, options.signal)\n    } catch (err: any) {\n      log.error('error while pinging %o - %e', peer, err)\n\n      stream?.abort(err)\n\n      throw err\n    } finally {\n      stream?.close()\n    }\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * The ping service implements the [libp2p ping spec](https://github.com/libp2p/specs/blob/master/ping/ping.md) allowing you to make a latency measurement to a remote peer.\n *\n * @example\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n * import { ping } from '@libp2p/ping'\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const node = await createLibp2p({\n *   services: {\n *     ping: ping()\n *   }\n * })\n *\n * const rtt = await node.services.ping.ping(multiaddr('/ip4/...'))\n *\n * console.info(rtt)\n * ```\n */\n\nimport { Ping as PingClass } from './ping.js'\nimport type { AbortOptions, PeerId } from '@libp2p/interface'\nimport type { ConnectionManager, Registrar } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport interface Ping {\n  ping(peer: PeerId | Multiaddr | Multiaddr[], options?: AbortOptions): Promise<number>\n}\n\nexport interface PingInit {\n  protocolPrefix?: string\n  maxInboundStreams?: number\n  maxOutboundStreams?: number\n  runOnLimitedConnection?: boolean\n\n  /**\n   * How long we should wait for a ping response\n   */\n  timeout?: number\n}\n\nexport interface PingComponents {\n  registrar: Registrar\n  connectionManager: ConnectionManager\n}\n\nexport function ping (init: PingInit = {}): (components: PingComponents) => Ping {\n  return (components) => new PingClass(components, init)\n}\n\nexport { PING_PROTOCOL } from './constants.js'\n"],
  "mappings": "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",
  "names": []
}
