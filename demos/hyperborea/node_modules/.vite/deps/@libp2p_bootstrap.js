import {
  P2P
} from "./chunk-MFNF3PBW.js";
import {
  CODE_P2P,
  multiaddr
} from "./chunk-DKVXG43P.js";
import {
  peerIdFromString
} from "./chunk-7EPQD6JW.js";
import {
  TypedEventEmitter,
  peerDiscoverySymbol,
  serviceCapabilities
} from "./chunk-NTF5EBGJ.js";
import "./chunk-5QZ7JOES.js";
import {
  __publicField
} from "./chunk-WOOG5QLI.js";

// ../../peercompute/node_modules/@libp2p/bootstrap/dist/src/index.js
var DEFAULT_BOOTSTRAP_TAG_NAME = "bootstrap";
var DEFAULT_BOOTSTRAP_TAG_VALUE = 50;
var DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT = 1e3;
var _a, _b, _c, _d;
var Bootstrap = class extends (_d = TypedEventEmitter, _c = peerDiscoverySymbol, _b = Symbol.toStringTag, _a = serviceCapabilities, _d) {
  constructor(components, options = { list: [] }) {
    if (options.list == null || options.list.length === 0) {
      throw new Error("Bootstrap requires a list of peer addresses");
    }
    super();
    __publicField(this, "log");
    __publicField(this, "timer");
    __publicField(this, "list");
    __publicField(this, "timeout");
    __publicField(this, "components");
    __publicField(this, "_init");
    __publicField(this, _c, this);
    __publicField(this, _b, "@libp2p/bootstrap");
    __publicField(this, _a, [
      "@libp2p/peer-discovery"
    ]);
    this.components = components;
    this.log = components.logger.forComponent("libp2p:bootstrap");
    this.timeout = options.timeout ?? DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT;
    this.list = options.list.map((str) => multiaddr(str)).filter((ma) => {
      var _a2;
      if (!P2P.matches(ma)) {
        this.log.error("invalid multiaddr %a", ma);
        return false;
      }
      const peerIdStr = (_a2 = ma.getComponents().findLast((c) => c.code === CODE_P2P)) == null ? void 0 : _a2.value;
      if (peerIdStr == null) {
        this.log.error("invalid bootstrap multiaddr without peer id");
        return false;
      }
      return true;
    }).map((ma) => {
      var _a2;
      return {
        id: peerIdFromString(((_a2 = ma.getComponents().findLast((c) => c.code === CODE_P2P)) == null ? void 0 : _a2.value) ?? ""),
        multiaddrs: [ma]
      };
    });
    this._init = options;
  }
  isStarted() {
    return Boolean(this.timer);
  }
  /**
   * Start emitting events
   */
  start() {
    if (this.isStarted()) {
      return;
    }
    this.log("Starting bootstrap node discovery, discovering peers after %s ms", this.timeout);
    this.timer = setTimeout(() => {
      void this._discoverBootstrapPeers().catch((err) => {
        this.log.error("failed to discover bootstrap peers - %e", err);
      });
    }, this.timeout);
  }
  /**
   * Emit each address in the list as a PeerInfo
   */
  async _discoverBootstrapPeers() {
    if (this.timer == null) {
      return;
    }
    for (const peerData of this.list) {
      await this.components.peerStore.merge(peerData.id, {
        tags: {
          [this._init.tagName ?? DEFAULT_BOOTSTRAP_TAG_NAME]: {
            value: this._init.tagValue ?? DEFAULT_BOOTSTRAP_TAG_VALUE,
            ttl: this._init.tagTTL
          }
        },
        multiaddrs: peerData.multiaddrs
      });
      if (this.timer == null) {
        return;
      }
      this.safeDispatchEvent("peer", { detail: peerData });
      this.components.connectionManager.openConnection(peerData.id).catch((err) => {
        this.log.error("could not dial bootstrap peer %p - %e", peerData.id, err);
      });
    }
  }
  /**
   * Stop emitting events
   */
  stop() {
    if (this.timer != null) {
      clearTimeout(this.timer);
    }
    this.timer = void 0;
  }
};
__publicField(Bootstrap, "tag", "bootstrap");
function bootstrap(init) {
  return (components) => new Bootstrap(components, init);
}
export {
  bootstrap
};
//# sourceMappingURL=@libp2p_bootstrap.js.map
