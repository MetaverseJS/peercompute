{
  "version": 3,
  "sources": ["../../../../../peercompute/node_modules/@libp2p/noise/src/constants.ts", "../../../../../peercompute/node_modules/@libp2p/noise/src/crypto/js.ts", "../../../../../peercompute/node_modules/@libp2p/noise/src/crypto/index.browser.ts", "../../../../../peercompute/node_modules/@libp2p/noise/src/crypto.ts", "../../../../../peercompute/node_modules/@libp2p/noise/src/encoder.ts", "../../../../../peercompute/node_modules/@libp2p/noise/src/metrics.ts", "../../../../../peercompute/node_modules/@libp2p/noise/src/logger.ts", "../../../../../peercompute/node_modules/@libp2p/noise/src/errors.ts", "../../../../../peercompute/node_modules/@libp2p/noise/src/nonce.ts", "../../../../../peercompute/node_modules/@libp2p/noise/src/protocol.ts", "../../../../../peercompute/node_modules/@libp2p/noise/src/proto/payload.ts", "../../../../../peercompute/node_modules/@libp2p/noise/src/utils.ts", "../../../../../peercompute/node_modules/@libp2p/noise/src/performHandshake.ts", "../../../../../peercompute/node_modules/@libp2p/noise/src/noise.ts", "../../../../../peercompute/node_modules/@libp2p/noise/src/index.ts"],
  "sourcesContent": ["export const NOISE_MSG_MAX_LENGTH_BYTES = 65535\nexport const NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = NOISE_MSG_MAX_LENGTH_BYTES - 16\n\nexport const DUMP_SESSION_KEYS = Boolean(globalThis.process?.env?.DUMP_SESSION_KEYS)\nexport const CHACHA_TAG_LENGTH = 16\n", "import { chacha20poly1305 } from '@noble/ciphers/chacha.js'\nimport { x25519 } from '@noble/curves/ed25519.js'\nimport { extract, expand } from '@noble/hashes/hkdf.js'\nimport { sha256 } from '@noble/hashes/sha2.js'\nimport type { ICryptoInterface } from '../crypto.js'\nimport type { KeyPair } from '../types.js'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport const pureJsCrypto: ICryptoInterface = {\n  hashSHA256 (data: Uint8Array | Uint8ArrayList): Uint8Array {\n    return sha256(data.subarray())\n  },\n\n  getHKDF (ck: Uint8Array, ikm: Uint8Array): [Uint8Array, Uint8Array, Uint8Array] {\n    const prk = extract(sha256, ikm, ck)\n    const okmU8Array = expand(sha256, prk, undefined, 96)\n    const okm = okmU8Array\n\n    const k1 = okm.subarray(0, 32)\n    const k2 = okm.subarray(32, 64)\n    const k3 = okm.subarray(64, 96)\n\n    return [k1, k2, k3]\n  },\n\n  generateX25519KeyPair (): KeyPair {\n    const secretKey = x25519.utils.randomSecretKey()\n    const publicKey = x25519.getPublicKey(secretKey)\n\n    return {\n      publicKey,\n      privateKey: secretKey\n    }\n  },\n\n  generateX25519KeyPairFromSeed (seed: Uint8Array): KeyPair {\n    const publicKey = x25519.getPublicKey(seed)\n\n    return {\n      publicKey,\n      privateKey: seed\n    }\n  },\n\n  generateX25519SharedKey (privateKey: Uint8Array | Uint8ArrayList, publicKey: Uint8Array | Uint8ArrayList): Uint8Array {\n    return x25519.getSharedSecret(privateKey.subarray(), publicKey.subarray())\n  },\n\n  chaCha20Poly1305Encrypt (plaintext: Uint8Array | Uint8ArrayList, nonce: Uint8Array, ad: Uint8Array, k: Uint8Array): Uint8Array {\n    return chacha20poly1305(k, nonce, ad).encrypt(plaintext.subarray())\n  },\n\n  chaCha20Poly1305Decrypt (ciphertext: Uint8Array | Uint8ArrayList, nonce: Uint8Array, ad: Uint8Array, k: Uint8Array, dst?: Uint8Array): Uint8Array {\n    return chacha20poly1305(k, nonce, ad).decrypt(ciphertext.subarray(), dst)\n  }\n}\n", "import { pureJsCrypto } from './js.js'\n\nexport const defaultCrypto = pureJsCrypto\n", "import type { ICrypto, KeyPair } from './types.js'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\n/** Underlying crypto implementation, meant to be overridable */\nexport interface ICryptoInterface {\n  hashSHA256(data: Uint8Array | Uint8ArrayList): Uint8Array\n\n  getHKDF(ck: Uint8Array, ikm: Uint8Array): [Uint8Array, Uint8Array, Uint8Array]\n\n  generateX25519KeyPair(): KeyPair\n  generateX25519KeyPairFromSeed(seed: Uint8Array): KeyPair\n  generateX25519SharedKey(privateKey: Uint8Array | Uint8ArrayList, publicKey: Uint8Array | Uint8ArrayList): Uint8Array\n\n  chaCha20Poly1305Encrypt(plaintext: Uint8Array | Uint8ArrayList, nonce: Uint8Array, ad: Uint8Array, k: Uint8Array): Uint8ArrayList | Uint8Array\n  chaCha20Poly1305Decrypt(ciphertext: Uint8Array | Uint8ArrayList, nonce: Uint8Array, ad: Uint8Array, k: Uint8Array, dst?: Uint8Array): Uint8ArrayList | Uint8Array\n}\n\nexport function wrapCrypto (crypto: ICryptoInterface): ICrypto {\n  return {\n    generateKeypair: crypto.generateX25519KeyPair,\n    dh: (keypair, publicKey) => crypto.generateX25519SharedKey(keypair.privateKey, publicKey).subarray(0, 32),\n    encrypt: crypto.chaCha20Poly1305Encrypt,\n    decrypt: crypto.chaCha20Poly1305Decrypt,\n    hash: crypto.hashSHA256,\n    hkdf: crypto.getHKDF\n  }\n}\n", "import { allocUnsafe as uint8ArrayAllocUnsafe } from 'uint8arrays/alloc'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport const uint16BEEncode = (value: number): Uint8Array => {\n  const target = uint8ArrayAllocUnsafe(2)\n  target[0] = value >> 8\n  target[1] = value\n  return target\n}\nuint16BEEncode.bytes = 2\n\nexport const uint16BEDecode = (data: Uint8Array | Uint8ArrayList): number => {\n  if (data.length < 2) { throw RangeError('Could not decode int16BE') }\n\n  if (data instanceof Uint8Array) {\n    let value = 0\n    value += data[0] << 8\n    value += data[1]\n    return value\n  }\n\n  return data.getUint16(0)\n}\nuint16BEDecode.bytes = 2\n", "import type { Counter, Metrics } from '@libp2p/interface'\n\nexport type MetricsRegistry = Record<string, Counter>\n\nexport function registerMetrics (metrics: Metrics): MetricsRegistry {\n  return {\n    xxHandshakeSuccesses: metrics.registerCounter(\n      'libp2p_noise_xxhandshake_successes_total', {\n        help: 'Total count of noise xxHandshakes successes_'\n      }),\n\n    xxHandshakeErrors: metrics.registerCounter(\n      'libp2p_noise_xxhandshake_error_total', {\n        help: 'Total count of noise xxHandshakes errors'\n      }),\n\n    encryptedPackets: metrics.registerCounter(\n      'libp2p_noise_encrypted_packets_total', {\n        help: 'Total count of noise encrypted packets successfully'\n      }),\n\n    decryptedPackets: metrics.registerCounter(\n      'libp2p_noise_decrypted_packets_total', {\n        help: 'Total count of noise decrypted packets'\n      }),\n\n    decryptErrors: metrics.registerCounter(\n      'libp2p_noise_decrypt_errors_total', {\n        help: 'Total count of noise decrypt errors'\n      })\n  }\n}\n", "import { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { DUMP_SESSION_KEYS } from './constants.js'\nimport type { CipherState } from './protocol.js'\nimport type { KeyPair } from './types.js'\nimport type { Logger } from '@libp2p/interface'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport function logLocalStaticKeys (s: KeyPair | undefined, keyLogger: Logger): void {\n  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {\n    return\n  }\n\n  if (s) {\n    keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${uint8ArrayToString(s.publicKey, 'hex')}`)\n    keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${uint8ArrayToString(s.privateKey, 'hex')}`)\n  } else {\n    keyLogger('Missing local static keys.')\n  }\n}\n\nexport function logLocalEphemeralKeys (e: KeyPair | undefined, keyLogger: Logger): void {\n  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {\n    return\n  }\n\n  if (e) {\n    keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${uint8ArrayToString(e.publicKey, 'hex')}`)\n    keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${uint8ArrayToString(e.privateKey, 'hex')}`)\n  } else {\n    keyLogger('Missing local ephemeral keys.')\n  }\n}\n\nexport function logRemoteStaticKey (rs: Uint8Array | Uint8ArrayList | undefined, keyLogger: Logger): void {\n  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {\n    return\n  }\n\n  if (rs) {\n    keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${uint8ArrayToString(rs.subarray(), 'hex')}`)\n  } else {\n    keyLogger('Missing remote static public key.')\n  }\n}\n\nexport function logRemoteEphemeralKey (re: Uint8Array | Uint8ArrayList | undefined, keyLogger: Logger): void {\n  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {\n    return\n  }\n\n  if (re) {\n    keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${uint8ArrayToString(re.subarray(), 'hex')}`)\n  } else {\n    keyLogger('Missing remote ephemeral keys.')\n  }\n}\n\nexport function logCipherState (cs1: CipherState, cs2: CipherState, keyLogger: Logger): void {\n  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {\n    return\n  }\n\n  keyLogger(`CIPHER_STATE_1 ${cs1.n.getUint64()} ${cs1.k && uint8ArrayToString(cs1.k, 'hex')}`)\n  keyLogger(`CIPHER_STATE_2 ${cs2.n.getUint64()} ${cs2.k && uint8ArrayToString(cs2.k, 'hex')}`)\n}\n", "export class InvalidCryptoExchangeError extends Error {\n  public code: string\n\n  constructor (message = 'Invalid crypto exchange') {\n    super(message)\n    this.code = InvalidCryptoExchangeError.code\n  }\n\n  static readonly code = 'ERR_INVALID_CRYPTO_EXCHANGE'\n}\n", "import { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc'\n\nexport const MIN_NONCE = 0\n// For performance reasons, the nonce is represented as a JS `number`\n// Although JS `number` can safely represent integers up to 2 ** 53 - 1, we choose to only use\n// 4 bytes to store the data for performance reason.\n// This is a slight deviation from the noise spec, which describes the max nonce as 2 ** 64 - 2\n// The effect is that this implementation will need a new handshake to be performed after fewer messages are exchanged than other implementations with full uint64 nonces.\n// this MAX_NONCE is still a large number of messages, so the practical effect of this is negligible.\nexport const MAX_NONCE = 0xffffffff\n\nconst ERR_MAX_NONCE = 'Cipher state has reached maximum n, a new handshake must be performed'\n\n/**\n * The nonce is an uint that's increased over time.\n * Maintaining different representations help improve performance.\n */\nexport class Nonce {\n  private n: number\n  private readonly bytes: Uint8Array\n  private readonly view: DataView\n\n  constructor (n = MIN_NONCE) {\n    this.n = n\n    this.bytes = uint8ArrayAlloc(12)\n    this.view = new DataView(this.bytes.buffer, this.bytes.byteOffset, this.bytes.byteLength)\n    this.view.setUint32(4, n, true)\n  }\n\n  increment (): void {\n    this.n++\n    // Even though we're treating the nonce as 8 bytes, RFC7539 specifies 12 bytes for a nonce.\n    this.view.setUint32(4, this.n, true)\n  }\n\n  getBytes (): Uint8Array {\n    return this.bytes\n  }\n\n  getUint64 (): number {\n    return this.n\n  }\n\n  assertValue (): void {\n    if (this.n > MAX_NONCE) {\n      throw new Error(ERR_MAX_NONCE)\n    }\n  }\n}\n", "import { Uint8ArrayList } from 'uint8arraylist'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays'\nimport { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc'\nimport { InvalidCryptoExchangeError } from './errors.js'\nimport { Nonce } from './nonce.js'\nimport type { ICipherState, ISymmetricState, IHandshakeState, KeyPair, ICrypto } from './types.js'\n\n// Code in this file is a direct translation of a subset of the noise protocol https://noiseprotocol.org/noise.html,\n// agnostic to libp2p's usage of noise\n\nexport const ZEROLEN = uint8ArrayAlloc(0)\n\ninterface ICipherStateWithKey extends ICipherState {\n  k: Uint8Array\n}\n\nexport class CipherState implements ICipherState {\n  public k?: Uint8Array\n  public n: Nonce\n  private readonly crypto: ICrypto\n\n  constructor (crypto: ICrypto, k: Uint8Array | undefined = undefined, n = 0) {\n    this.crypto = crypto\n    this.k = k\n    this.n = new Nonce(n)\n  }\n\n  public hasKey (): this is ICipherStateWithKey {\n    return Boolean(this.k)\n  }\n\n  public encryptWithAd (ad: Uint8Array, plaintext: Uint8Array | Uint8ArrayList): Uint8Array | Uint8ArrayList {\n    if (!this.hasKey()) {\n      return plaintext\n    }\n\n    this.n.assertValue()\n    const e = this.crypto.encrypt(plaintext, this.n.getBytes(), ad, this.k)\n    this.n.increment()\n\n    return e\n  }\n\n  public decryptWithAd (ad: Uint8Array, ciphertext: Uint8Array | Uint8ArrayList, dst?: Uint8Array): Uint8Array | Uint8ArrayList {\n    if (!this.hasKey()) {\n      return ciphertext\n    }\n\n    this.n.assertValue()\n    const plaintext = this.crypto.decrypt(ciphertext, this.n.getBytes(), ad, this.k, dst)\n    this.n.increment()\n\n    return plaintext\n  }\n}\n\nexport class SymmetricState implements ISymmetricState {\n  public cs: CipherState\n  public ck: Uint8Array\n  public h: Uint8Array\n  private readonly crypto: ICrypto\n\n  constructor (crypto: ICrypto, protocolName: string) {\n    this.crypto = crypto\n\n    const protocolNameBytes = uint8ArrayFromString(protocolName, 'utf-8')\n    this.h = hashProtocolName(crypto, protocolNameBytes)\n\n    this.ck = this.h\n    this.cs = new CipherState(crypto)\n  }\n\n  public mixKey (ikm: Uint8Array): void {\n    const [ck, tempK] = this.crypto.hkdf(this.ck, ikm)\n    this.ck = ck\n    this.cs = new CipherState(this.crypto, tempK)\n  }\n\n  public mixHash (data: Uint8Array | Uint8ArrayList): void {\n    this.h = this.crypto.hash(new Uint8ArrayList(this.h, data))\n  }\n\n  public encryptAndHash (plaintext: Uint8Array | Uint8ArrayList): Uint8Array | Uint8ArrayList {\n    const ciphertext = this.cs.encryptWithAd(this.h, plaintext)\n    this.mixHash(ciphertext)\n    return ciphertext\n  }\n\n  public decryptAndHash (ciphertext: Uint8Array | Uint8ArrayList): Uint8Array | Uint8ArrayList {\n    const plaintext = this.cs.decryptWithAd(this.h, ciphertext)\n    this.mixHash(ciphertext)\n    return plaintext\n  }\n\n  public split (): [CipherState, CipherState] {\n    const [tempK1, tempK2] = this.crypto.hkdf(this.ck, ZEROLEN)\n    return [new CipherState(this.crypto, tempK1), new CipherState(this.crypto, tempK2)]\n  }\n}\n\n// const MESSAGE_PATTERNS = ['e', 's', 'ee', 'es', 'se', 'ss'] as const\n// type MessagePattern = Array<typeof MESSAGE_PATTERNS[number]>\n\nexport interface HandshakeStateInit {\n  crypto: ICrypto\n  protocolName: string\n  initiator: boolean\n  prologue: Uint8Array\n  s?: KeyPair\n  e?: KeyPair\n  rs?: Uint8Array | Uint8ArrayList\n  re?: Uint8Array | Uint8ArrayList\n}\n\nexport abstract class AbstractHandshakeState implements IHandshakeState {\n  public ss: SymmetricState\n  public s?: KeyPair\n  public e?: KeyPair\n  public rs?: Uint8Array | Uint8ArrayList\n  public re?: Uint8Array | Uint8ArrayList\n  public initiator: boolean\n  protected readonly crypto: ICrypto\n\n  constructor (init: HandshakeStateInit) {\n    const { crypto, protocolName, prologue, initiator, s, e, rs, re } = init\n    this.crypto = crypto\n    this.ss = new SymmetricState(crypto, protocolName)\n    this.ss.mixHash(prologue)\n    this.initiator = initiator\n    this.s = s\n    this.e = e\n    this.rs = rs\n    this.re = re\n  }\n\n  protected writeE (): Uint8Array {\n    if (this.e) {\n      throw new Error('ephemeral keypair is already set')\n    }\n    const e = this.crypto.generateKeypair()\n    this.ss.mixHash(e.publicKey)\n    this.e = e\n    return e.publicKey\n  }\n\n  protected writeS (): Uint8Array | Uint8ArrayList {\n    if (!this.s) {\n      throw new Error('static keypair is not set')\n    }\n    return this.ss.encryptAndHash(this.s.publicKey)\n  }\n\n  protected writeEE (): void {\n    if (!this.e) {\n      throw new Error('ephemeral keypair is not set')\n    }\n    if (!this.re) {\n      throw new Error('remote ephemeral public key is not set')\n    }\n    this.ss.mixKey(this.crypto.dh(this.e, this.re))\n  }\n\n  protected writeES (): void {\n    if (this.initiator) {\n      if (!this.e) {\n        throw new Error('ephemeral keypair is not set')\n      }\n      if (!this.rs) {\n        throw new Error('remote static public key is not set')\n      }\n      this.ss.mixKey(this.crypto.dh(this.e, this.rs))\n    } else {\n      if (!this.s) {\n        throw new Error('static keypair is not set')\n      }\n      if (!this.re) {\n        throw new Error('remote ephemeral public key is not set')\n      }\n      this.ss.mixKey(this.crypto.dh(this.s, this.re))\n    }\n  }\n\n  protected writeSE (): void {\n    if (this.initiator) {\n      if (!this.s) {\n        throw new Error('static keypair is not set')\n      }\n      if (!this.re) {\n        throw new Error('remote ephemeral public key is not set')\n      }\n      this.ss.mixKey(this.crypto.dh(this.s, this.re))\n    } else {\n      if (!this.e) {\n        throw new Error('ephemeral keypair is not set')\n      }\n      if (!this.rs) {\n        throw new Error('remote static public key is not set')\n      }\n      this.ss.mixKey(this.crypto.dh(this.e, this.rs))\n    }\n  }\n\n  protected readE (message: Uint8ArrayList, offset = 0): void {\n    if (this.re) {\n      throw new Error('remote ephemeral public key is already set')\n    }\n    if (message.byteLength < offset + 32) {\n      throw new Error('message is not long enough')\n    }\n    this.re = message.sublist(offset, offset + 32)\n    this.ss.mixHash(this.re)\n  }\n\n  protected readS (message: Uint8ArrayList, offset = 0): number {\n    if (this.rs) {\n      throw new Error('remote static public key is already set')\n    }\n    const cipherLength = 32 + (this.ss.cs.hasKey() ? 16 : 0)\n    if (message.byteLength < offset + cipherLength) {\n      throw new Error('message is not long enough')\n    }\n    const temp = message.sublist(offset, offset + cipherLength)\n    this.rs = this.ss.decryptAndHash(temp)\n    return cipherLength\n  }\n\n  protected readEE (): void {\n    this.writeEE()\n  }\n\n  protected readES (): void {\n    this.writeES()\n  }\n\n  protected readSE (): void {\n    this.writeSE()\n  }\n}\n\n/**\n * A IHandshakeState that's optimized for the XX pattern\n */\nexport class XXHandshakeState extends AbstractHandshakeState {\n  // e\n  writeMessageA (payload: Uint8Array | Uint8ArrayList): Uint8Array | Uint8ArrayList {\n    return new Uint8ArrayList(this.writeE(), this.ss.encryptAndHash(payload))\n  }\n\n  // e, ee, s, es\n  writeMessageB (payload: Uint8Array | Uint8ArrayList): Uint8Array | Uint8ArrayList {\n    const e = this.writeE()\n    this.writeEE()\n    const encS = this.writeS()\n    this.writeES()\n\n    return new Uint8ArrayList(e, encS, this.ss.encryptAndHash(payload))\n  }\n\n  // s, se\n  writeMessageC (payload: Uint8Array | Uint8ArrayList): Uint8Array | Uint8ArrayList {\n    const encS = this.writeS()\n    this.writeSE()\n\n    return new Uint8ArrayList(encS, this.ss.encryptAndHash(payload))\n  }\n\n  // e\n  readMessageA (message: Uint8ArrayList): Uint8Array | Uint8ArrayList {\n    try {\n      this.readE(message)\n\n      return this.ss.decryptAndHash(message.sublist(32))\n    } catch (e) {\n      throw new InvalidCryptoExchangeError(`handshake stage 0 validation fail: ${(e as Error).message}`)\n    }\n  }\n\n  // e, ee, s, es\n  readMessageB (message: Uint8ArrayList): Uint8Array | Uint8ArrayList {\n    try {\n      this.readE(message)\n      this.readEE()\n      const consumed = this.readS(message, 32)\n      this.readES()\n\n      return this.ss.decryptAndHash(message.sublist(32 + consumed))\n    } catch (e) {\n      throw new InvalidCryptoExchangeError(`handshake stage 1 validation fail: ${(e as Error).message}`)\n    }\n  }\n\n  // s, se\n  readMessageC (message: Uint8ArrayList): Uint8Array | Uint8ArrayList {\n    try {\n      const consumed = this.readS(message)\n      this.readSE()\n\n      return this.ss.decryptAndHash(message.sublist(consumed))\n    } catch (e) {\n      throw new InvalidCryptoExchangeError(`handshake stage 2 validation fail: ${(e as Error).message}`)\n    }\n  }\n}\n\nfunction hashProtocolName (crypto: ICrypto, protocolName: Uint8Array): Uint8Array {\n  if (protocolName.length <= 32) {\n    const h = uint8ArrayAlloc(32)\n    h.set(protocolName)\n    return h\n  } else {\n    return crypto.hash(protocolName)\n  }\n}\n", "import { decodeMessage, encodeMessage, MaxLengthError, message } from 'protons-runtime'\nimport { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc'\nimport type { Codec, DecodeOptions } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface NoiseExtensions {\n  webtransportCerthashes: Uint8Array[]\n  streamMuxers: string[]\n}\n\nexport namespace NoiseExtensions {\n  let _codec: Codec<NoiseExtensions>\n\n  export const codec = (): Codec<NoiseExtensions> => {\n    if (_codec == null) {\n      _codec = message<NoiseExtensions>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.webtransportCerthashes != null) {\n          for (const value of obj.webtransportCerthashes) {\n            w.uint32(10)\n            w.bytes(value)\n          }\n        }\n\n        if (obj.streamMuxers != null) {\n          for (const value of obj.streamMuxers) {\n            w.uint32(18)\n            w.string(value)\n          }\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          webtransportCerthashes: [],\n          streamMuxers: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              if (opts.limits?.webtransportCerthashes != null && obj.webtransportCerthashes.length === opts.limits.webtransportCerthashes) {\n                throw new MaxLengthError('Decode error - map field \"webtransportCerthashes\" had too many elements')\n              }\n\n              obj.webtransportCerthashes.push(reader.bytes())\n              break\n            }\n            case 2: {\n              if (opts.limits?.streamMuxers != null && obj.streamMuxers.length === opts.limits.streamMuxers) {\n                throw new MaxLengthError('Decode error - map field \"streamMuxers\" had too many elements')\n              }\n\n              obj.streamMuxers.push(reader.string())\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<NoiseExtensions>): Uint8Array => {\n    return encodeMessage(obj, NoiseExtensions.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<NoiseExtensions>): NoiseExtensions => {\n    return decodeMessage(buf, NoiseExtensions.codec(), opts)\n  }\n}\n\nexport interface NoiseHandshakePayload {\n  identityKey: Uint8Array\n  identitySig: Uint8Array\n  extensions?: NoiseExtensions\n}\n\nexport namespace NoiseHandshakePayload {\n  let _codec: Codec<NoiseHandshakePayload>\n\n  export const codec = (): Codec<NoiseHandshakePayload> => {\n    if (_codec == null) {\n      _codec = message<NoiseHandshakePayload>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.identityKey != null && obj.identityKey.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.identityKey)\n        }\n\n        if ((obj.identitySig != null && obj.identitySig.byteLength > 0)) {\n          w.uint32(18)\n          w.bytes(obj.identitySig)\n        }\n\n        if (obj.extensions != null) {\n          w.uint32(34)\n          NoiseExtensions.codec().encode(obj.extensions, w)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          identityKey: uint8ArrayAlloc(0),\n          identitySig: uint8ArrayAlloc(0)\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.identityKey = reader.bytes()\n              break\n            }\n            case 2: {\n              obj.identitySig = reader.bytes()\n              break\n            }\n            case 4: {\n              obj.extensions = NoiseExtensions.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.extensions\n              })\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<NoiseHandshakePayload>): Uint8Array => {\n    return encodeMessage(obj, NoiseHandshakePayload.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<NoiseHandshakePayload>): NoiseHandshakePayload => {\n    return decodeMessage(buf, NoiseHandshakePayload.codec(), opts)\n  }\n}\n", "import { publicKeyFromProtobuf, publicKeyToProtobuf } from '@libp2p/crypto/keys'\nimport { StreamMessageEvent, UnexpectedPeerError } from '@libp2p/interface'\nimport { AbstractMessageStream, LengthPrefixedDecoder } from '@libp2p/utils'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { CHACHA_TAG_LENGTH, NOISE_MSG_MAX_LENGTH_BYTES, NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG } from './constants.ts'\nimport { uint16BEEncode, uint16BEDecode } from './encoder.ts'\nimport { NoiseHandshakePayload } from './proto/payload.js'\nimport type { MetricsRegistry } from './metrics.ts'\nimport type { NoiseExtensions } from './proto/payload.js'\nimport type { HandshakeResult } from './types.ts'\nimport type { AbortOptions, MessageStream, PrivateKey, PublicKey, StreamCloseEvent } from '@libp2p/interface'\nimport type { SendResult } from '@libp2p/utils'\n\nexport async function createHandshakePayload (\n  privateKey: PrivateKey,\n  staticPublicKey: Uint8Array | Uint8ArrayList,\n  extensions?: NoiseExtensions\n): Promise<Uint8Array | Uint8ArrayList> {\n  const identitySig = await privateKey.sign(getSignaturePayload(staticPublicKey))\n\n  return NoiseHandshakePayload.encode({\n    identityKey: publicKeyToProtobuf(privateKey.publicKey),\n    identitySig,\n    extensions\n  })\n}\n\nexport async function decodeHandshakePayload (\n  payloadBytes: Uint8Array | Uint8ArrayList,\n  remoteStaticKey?: Uint8Array | Uint8ArrayList,\n  remoteIdentityKey?: PublicKey\n): Promise<NoiseHandshakePayload> {\n  try {\n    const payload = NoiseHandshakePayload.decode(payloadBytes)\n    const publicKey = publicKeyFromProtobuf(payload.identityKey)\n\n    if (remoteIdentityKey?.equals(publicKey) === false) {\n      throw new Error(`Payload identity key ${publicKey} does not match expected remote identity key ${remoteIdentityKey}`)\n    }\n\n    if (!remoteStaticKey) {\n      throw new Error('Remote static does not exist')\n    }\n\n    const signaturePayload = getSignaturePayload(remoteStaticKey)\n\n    if (!(await publicKey.verify(signaturePayload, payload.identitySig))) {\n      throw new Error('Invalid payload signature')\n    }\n\n    return payload\n  } catch (e) {\n    throw new UnexpectedPeerError((e as Error).message)\n  }\n}\n\nexport function getSignaturePayload (publicKey: Uint8Array | Uint8ArrayList): Uint8Array | Uint8ArrayList {\n  const prefix = uint8ArrayFromString('noise-libp2p-static-key:')\n\n  if (publicKey instanceof Uint8Array) {\n    return uint8ArrayConcat([prefix, publicKey], prefix.length + publicKey.length)\n  }\n\n  publicKey.prepend(prefix)\n\n  return publicKey\n}\n\nclass EncryptedMessageStream extends AbstractMessageStream {\n  private stream: MessageStream\n  private handshake: HandshakeResult\n  private metrics?: MetricsRegistry\n  private decoder: LengthPrefixedDecoder\n\n  constructor (stream: MessageStream, handshake: HandshakeResult, metrics?: MetricsRegistry) {\n    super({\n      log: stream.log,\n      inactivityTimeout: stream.inactivityTimeout,\n      maxReadBufferLength: stream.maxReadBufferLength,\n      direction: stream.direction\n    })\n\n    this.stream = stream\n    this.handshake = handshake\n    this.metrics = metrics\n    this.decoder = new LengthPrefixedDecoder({\n      lengthDecoder: uint16BEDecode,\n      maxBufferSize: 16 * 1024 * 1024,\n      encodingLength: () => 2\n    })\n\n    const noiseOnMessageDecrypt = (evt: StreamMessageEvent): void => {\n      try {\n        for (const buf of this.decoder.decode(evt.data)) {\n          this.onData(this.decrypt(buf))\n        }\n      } catch (err: any) {\n        this.abort(err)\n      }\n    }\n    this.stream.addEventListener('message', noiseOnMessageDecrypt)\n\n    const noiseOnClose = (evt: StreamCloseEvent): void => {\n      if (evt.error != null) {\n        if (evt.local === true) {\n          this.abort(evt.error)\n        } else {\n          this.onRemoteReset()\n        }\n      } else {\n        this.onTransportClosed()\n      }\n    }\n    this.stream.addEventListener('close', noiseOnClose)\n\n    const noiseOnDrain = (): void => {\n      this.safeDispatchEvent('drain')\n    }\n    this.stream.addEventListener('drain', noiseOnDrain)\n\n    const noiseOnRemoteCloseWrite = (): void => {\n      this.onRemoteCloseWrite()\n    }\n    this.stream.addEventListener('remoteCloseWrite', noiseOnRemoteCloseWrite)\n  }\n\n  encrypt (chunk: Uint8Array | Uint8ArrayList): Uint8ArrayList {\n    const output = new Uint8ArrayList()\n\n    for (let i = 0; i < chunk.byteLength; i += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {\n      let end = i + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG\n      if (end > chunk.byteLength) {\n        end = chunk.byteLength\n      }\n\n      let data: Uint8Array | Uint8ArrayList\n\n      if (chunk instanceof Uint8Array) {\n        data = this.handshake.encrypt(chunk.subarray(i, end))\n      } else {\n        data = this.handshake.encrypt(chunk.sublist(i, end))\n      }\n\n      this.metrics?.encryptedPackets.increment()\n\n      output.append(uint16BEEncode(data.byteLength))\n      output.append(data)\n    }\n\n    return output\n  }\n\n  decrypt (chunk: Uint8Array | Uint8ArrayList): Uint8ArrayList {\n    const output = new Uint8ArrayList()\n\n    for (let i = 0; i < chunk.byteLength; i += NOISE_MSG_MAX_LENGTH_BYTES) {\n      let end = i + NOISE_MSG_MAX_LENGTH_BYTES\n      if (end > chunk.byteLength) {\n        end = chunk.byteLength\n      }\n\n      if (end - CHACHA_TAG_LENGTH < i) {\n        throw new Error('Invalid chunk')\n      }\n\n      let encrypted: Uint8Array | Uint8ArrayList\n\n      if (chunk instanceof Uint8Array) {\n        encrypted = chunk.subarray(i, end)\n      } else {\n        encrypted = chunk.sublist(i, end)\n      }\n\n      // memory allocation is not cheap so reuse the encrypted Uint8Array\n      // see https://github.com/ChainSafe/js-libp2p-noise/pull/242#issue-1422126164\n      // this is ok because chacha20 reads bytes one by one and don't reread after that\n      // it's also tested in https://github.com/ChainSafe/as-chacha20poly1305/pull/1/files#diff-25252846b58979dcaf4e41d47b3eadd7e4f335e7fb98da6c049b1f9cd011f381R48\n      const dst = chunk.subarray(i, end - CHACHA_TAG_LENGTH)\n      try {\n        const plaintext = this.handshake.decrypt(encrypted, dst)\n        this.metrics?.decryptedPackets.increment()\n\n        output.append(plaintext)\n      } catch (e) {\n        this.metrics?.decryptErrors.increment()\n        throw e\n      }\n    }\n\n    return output\n  }\n\n  close (options?: AbortOptions): Promise<void> {\n    return this.stream.close(options)\n  }\n\n  sendPause (): void {\n    this.stream.pause()\n  }\n\n  sendResume (): void {\n    this.stream.resume()\n  }\n\n  sendReset (err: Error): void {\n    this.stream.abort(err)\n  }\n\n  sendData (data: Uint8ArrayList): SendResult {\n    return {\n      sentBytes: data.byteLength,\n      canSendMore: this.stream.send(this.encrypt(data))\n    }\n  }\n}\n\nexport function toMessageStream (connection: MessageStream, handshake: HandshakeResult, metrics?: MetricsRegistry): MessageStream {\n  return new EncryptedMessageStream(connection, handshake, metrics)\n}\n", "import {\n  logLocalStaticKeys,\n  logLocalEphemeralKeys,\n  logRemoteEphemeralKey,\n  logRemoteStaticKey,\n  logCipherState\n} from './logger.js'\nimport { ZEROLEN, XXHandshakeState } from './protocol.js'\nimport { createHandshakePayload, decodeHandshakePayload } from './utils.js'\nimport type { HandshakeResult, HandshakeParams } from './types.js'\nimport type { AbortOptions } from '@libp2p/interface'\n\nexport async function performHandshakeInitiator (init: HandshakeParams, options?: AbortOptions): Promise<HandshakeResult> {\n  const { log, connection, crypto, privateKey, prologue, s, remoteIdentityKey, extensions } = init\n\n  const payload = await createHandshakePayload(privateKey, s.publicKey, extensions)\n  const xx = new XXHandshakeState({\n    crypto,\n    protocolName: 'Noise_XX_25519_ChaChaPoly_SHA256',\n    initiator: true,\n    prologue,\n    s\n  })\n\n  logLocalStaticKeys(xx.s, log)\n  log.trace('Stage 0 - Initiator starting to send first message.')\n  await connection.write(xx.writeMessageA(ZEROLEN), options)\n  log.trace('Stage 0 - Initiator finished sending first message.')\n  logLocalEphemeralKeys(xx.e, log)\n\n  log.trace('Stage 1 - Initiator waiting to receive first message from responder...')\n  const plaintext = xx.readMessageB(await connection.read(options))\n  log.trace('Stage 1 - Initiator received the message.')\n  logRemoteEphemeralKey(xx.re, log)\n  logRemoteStaticKey(xx.rs, log)\n\n  log.trace(\"Initiator going to check remote's signature...\")\n  const receivedPayload = await decodeHandshakePayload(plaintext, xx.rs, remoteIdentityKey)\n  log.trace('All good with the signature!')\n\n  log.trace('Stage 2 - Initiator sending third handshake message.')\n  await connection.write(xx.writeMessageC(payload), options)\n  log.trace('Stage 2 - Initiator sent message with signed payload.')\n\n  const [cs1, cs2] = xx.ss.split()\n  logCipherState(cs1, cs2, log)\n\n  return {\n    payload: receivedPayload,\n    encrypt: (plaintext) => cs1.encryptWithAd(ZEROLEN, plaintext),\n    decrypt: (ciphertext, dst) => cs2.decryptWithAd(ZEROLEN, ciphertext, dst)\n  }\n}\n\nexport async function performHandshakeResponder (init: HandshakeParams, options?: AbortOptions): Promise<HandshakeResult> {\n  const { log, connection, crypto, privateKey, prologue, s, remoteIdentityKey, extensions } = init\n\n  const payload = await createHandshakePayload(privateKey, s.publicKey, extensions)\n  const xx = new XXHandshakeState({\n    crypto,\n    protocolName: 'Noise_XX_25519_ChaChaPoly_SHA256',\n    initiator: false,\n    prologue,\n    s\n  })\n\n  logLocalStaticKeys(xx.s, log)\n  log.trace('Stage 0 - Responder waiting to receive first message.')\n  xx.readMessageA(await connection.read(options))\n  log.trace('Stage 0 - Responder received first message.')\n  logRemoteEphemeralKey(xx.re, log)\n\n  log.trace('Stage 1 - Responder sending out first message with signed payload and static key.')\n  await connection.write(xx.writeMessageB(payload), options)\n  log.trace('Stage 1 - Responder sent the second handshake message with signed payload.')\n  logLocalEphemeralKeys(xx.e, log)\n\n  log.trace('Stage 2 - Responder waiting for third handshake message...')\n  const plaintext = xx.readMessageC(await connection.read(options))\n  log.trace('Stage 2 - Responder received the message, finished handshake.')\n  const receivedPayload = await decodeHandshakePayload(plaintext, xx.rs, remoteIdentityKey)\n\n  const [cs1, cs2] = xx.ss.split()\n  logCipherState(cs1, cs2, log)\n\n  return {\n    payload: receivedPayload,\n    encrypt: (plaintext) => cs2.encryptWithAd(ZEROLEN, plaintext),\n    decrypt: (ciphertext, dst) => cs1.decryptWithAd(ZEROLEN, ciphertext, dst)\n  }\n}\n", "import { publicKeyFromProtobuf } from '@libp2p/crypto/keys'\nimport { InvalidCryptoExchangeError, serviceCapabilities } from '@libp2p/interface'\nimport { peerIdFromPublicKey } from '@libp2p/peer-id'\nimport { lpStream } from '@libp2p/utils'\nimport { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc'\nimport { NOISE_MSG_MAX_LENGTH_BYTES } from './constants.js'\nimport { defaultCrypto } from './crypto/index.js'\nimport { wrapCrypto } from './crypto.js'\nimport { uint16BEDecode, uint16BEEncode } from './encoder.js'\nimport { registerMetrics } from './metrics.js'\nimport { performHandshakeInitiator, performHandshakeResponder } from './performHandshake.js'\nimport { toMessageStream } from './utils.ts'\nimport type { ICryptoInterface } from './crypto.js'\nimport type { NoiseComponents } from './index.js'\nimport type { MetricsRegistry } from './metrics.js'\nimport type { HandshakeResult, ICrypto, INoiseConnection, INoiseExtensions, KeyPair } from './types.js'\nimport type { SecuredConnection, PrivateKey, PublicKey, StreamMuxerFactory, SecureConnectionOptions, Logger, MessageStream } from '@libp2p/interface'\nimport type { LengthPrefixedStream } from '@libp2p/utils'\n\nexport interface NoiseExtensions {\n  webtransportCerthashes: Uint8Array[]\n}\n\nexport interface NoiseInit {\n  /**\n   * x25519 private key, reuse for faster handshakes\n   */\n  staticNoiseKey?: Uint8Array\n  extensions?: Partial<NoiseExtensions>\n  crypto?: ICryptoInterface\n  prologueBytes?: Uint8Array\n}\n\nexport class Noise implements INoiseConnection {\n  public protocol = '/noise'\n  public crypto: ICrypto\n\n  private readonly prologue: Uint8Array\n  private readonly staticKey: KeyPair\n  private readonly extensions?: NoiseExtensions\n  private readonly metrics?: MetricsRegistry\n  private readonly components: NoiseComponents\n  private readonly log: Logger\n\n  constructor (components: NoiseComponents, init: NoiseInit = {}) {\n    const { staticNoiseKey, extensions, crypto, prologueBytes } = init\n    const { metrics } = components\n\n    this.components = components\n    this.log = components.logger.forComponent('libp2p:noise')\n    const _crypto = crypto ?? defaultCrypto\n    this.crypto = wrapCrypto(_crypto)\n    this.extensions = {\n      webtransportCerthashes: [],\n      ...extensions\n    }\n    this.metrics = metrics ? registerMetrics(metrics) : undefined\n\n    if (staticNoiseKey) {\n      // accepts x25519 private key of length 32\n      this.staticKey = _crypto.generateX25519KeyPairFromSeed(staticNoiseKey)\n    } else {\n      this.staticKey = _crypto.generateX25519KeyPair()\n    }\n    this.prologue = prologueBytes ?? uint8ArrayAlloc(0)\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/noise'\n\n  readonly [serviceCapabilities]: string[] = [\n    '@libp2p/connection-encryption',\n    '@libp2p/noise'\n  ]\n\n  /**\n   * Encrypt outgoing data to the remote party (handshake as initiator)\n   *\n   * @param connection - streaming iterable duplex that will be encrypted\n   * @param options\n   * @param options.remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer\n   * @param options.signal - Used to abort the operation\n   */\n  async secureOutbound (connection: MessageStream, options?: SecureConnectionOptions): Promise<SecuredConnection<INoiseExtensions>> {\n    const log = connection.log?.newScope('noise') ?? this.log\n    const wrappedConnection = lpStream(connection, {\n      lengthEncoder: uint16BEEncode,\n      lengthDecoder: uint16BEDecode,\n      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n    })\n\n    const handshake = await this.performHandshakeInitiator(\n      wrappedConnection,\n      this.components.privateKey,\n      log,\n      options?.remotePeer?.publicKey,\n      options\n    )\n    const publicKey = publicKeyFromProtobuf(handshake.payload.identityKey)\n\n    return {\n      connection: toMessageStream(wrappedConnection.unwrap(), handshake, this.metrics),\n      remoteExtensions: handshake.payload.extensions,\n      remotePeer: peerIdFromPublicKey(publicKey),\n      streamMuxer: options?.skipStreamMuxerNegotiation === true ? undefined : this.getStreamMuxer(handshake.payload.extensions?.streamMuxers)\n    }\n  }\n\n  private getStreamMuxer (protocols?: string[]): StreamMuxerFactory | undefined {\n    if (protocols == null || protocols.length === 0) {\n      return\n    }\n\n    const streamMuxers = this.components.upgrader.getStreamMuxers()\n\n    if (streamMuxers != null) {\n      for (const protocol of protocols) {\n        const streamMuxer = streamMuxers.get(protocol)\n\n        if (streamMuxer != null) {\n          return streamMuxer\n        }\n      }\n    }\n\n    if (protocols.length) {\n      throw new InvalidCryptoExchangeError('Early muxer negotiation was requested but the initiator and responder had no common muxers')\n    }\n  }\n\n  /**\n   * Decrypt incoming data (handshake as responder).\n   *\n   * @param connection - streaming iterable duplex that will be encrypted\n   * @param options\n   * @param options.remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer\n   * @param options.signal - Used to abort the operation\n   */\n  async secureInbound (connection: MessageStream, options?: SecureConnectionOptions): Promise<SecuredConnection<INoiseExtensions>> {\n    const log = connection.log?.newScope('noise') ?? this.log\n    const wrappedConnection = lpStream(connection, {\n      lengthEncoder: uint16BEEncode,\n      lengthDecoder: uint16BEDecode,\n      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n    })\n\n    const handshake = await this.performHandshakeResponder(\n      wrappedConnection,\n      this.components.privateKey,\n      log,\n      options?.remotePeer?.publicKey,\n      options\n    )\n    const publicKey = publicKeyFromProtobuf(handshake.payload.identityKey)\n\n    return {\n      connection: toMessageStream(wrappedConnection.unwrap(), handshake, this.metrics),\n      remoteExtensions: handshake.payload.extensions,\n      remotePeer: peerIdFromPublicKey(publicKey),\n      streamMuxer: options?.skipStreamMuxerNegotiation === true ? undefined : this.getStreamMuxer(handshake.payload.extensions?.streamMuxers)\n    }\n  }\n\n  /**\n   * Perform XX handshake as initiator.\n   */\n  private async performHandshakeInitiator (\n    connection: LengthPrefixedStream,\n    // TODO: pass private key in noise constructor via Components\n    privateKey: PrivateKey,\n    log: Logger,\n    remoteIdentityKey?: PublicKey,\n    options?: SecureConnectionOptions\n  ): Promise<HandshakeResult> {\n    let result: HandshakeResult\n    const streamMuxers = options?.skipStreamMuxerNegotiation === true ? [] : [...this.components.upgrader.getStreamMuxers().keys()]\n\n    try {\n      result = await performHandshakeInitiator({\n        connection,\n        privateKey,\n        remoteIdentityKey,\n        log: log.newScope('xxhandshake'),\n        crypto: this.crypto,\n        prologue: this.prologue,\n        s: this.staticKey,\n        extensions: {\n          streamMuxers,\n          webtransportCerthashes: [],\n          ...this.extensions\n        }\n      }, options)\n      this.metrics?.xxHandshakeSuccesses.increment()\n    } catch (e: unknown) {\n      this.metrics?.xxHandshakeErrors.increment()\n      throw e\n    }\n\n    return result\n  }\n\n  /**\n   * Perform XX handshake as responder.\n   */\n  private async performHandshakeResponder (\n    connection: LengthPrefixedStream,\n    privateKey: PrivateKey,\n    log: Logger,\n    remoteIdentityKey?: PublicKey,\n    options?: SecureConnectionOptions\n  ): Promise<HandshakeResult> {\n    let result: HandshakeResult\n    const streamMuxers = options?.skipStreamMuxerNegotiation === true ? [] : [...this.components.upgrader.getStreamMuxers().keys()]\n\n    try {\n      result = await performHandshakeResponder({\n        connection,\n        privateKey,\n        remoteIdentityKey,\n        log: log.newScope('xxhandshake'),\n        crypto: this.crypto,\n        prologue: this.prologue,\n        s: this.staticKey,\n        extensions: {\n          streamMuxers,\n          webtransportCerthashes: [],\n          ...this.extensions\n        }\n      }, options)\n      this.metrics?.xxHandshakeSuccesses.increment()\n    } catch (e: unknown) {\n      this.metrics?.xxHandshakeErrors.increment()\n      throw e\n    }\n\n    return result\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * This repository contains TypeScript implementation of noise protocol, an encryption protocol used in libp2p.\n *\n * ## Usage\n *\n * Install with `yarn add @libp2p/noise` or `npm i @libp2p/noise`.\n *\n * Example of using default noise configuration and passing it to the libp2p config:\n *\n * ```ts\n * import {createLibp2p} from \"libp2p\"\n * import {noise} from \"@libp2p/noise\"\n *\n * //custom noise configuration, pass it instead of `noise()`\n * //x25519 private key\n * const n = noise({ staticNoiseKey });\n *\n * const libp2p = await createLibp2p({\n *   connectionEncrypters: [noise()],\n *   //... other options\n * })\n * ```\n *\n * See the [NoiseInit](https://github.com/ChainSafe/js-libp2p-noise/blob/master/src/noise.ts#L22-L30) interface for noise configuration options.\n *\n * ## API\n *\n * This module exposes an implementation of the [ConnectionEncrypter](https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.ConnectionEncrypter.html) interface.\n *\n * ## Bring your own crypto\n *\n * You can provide a custom crypto implementation (instead of the default, based on [@noble](https://paulmillr.com/noble/)) by adding a `crypto` field to the init argument passed to the `Noise` factory.\n *\n * The implementation must conform to the `ICryptoInterface`, defined in <https://github.com/ChainSafe/js-libp2p-noise/blob/master/src/crypto.ts>\n */\n\nimport { Noise } from './noise.js'\nimport type { NoiseInit, NoiseExtensions } from './noise.js'\nimport type { KeyPair } from './types.js'\nimport type { ComponentLogger, ConnectionEncrypter, Metrics, PeerId, PrivateKey, Upgrader } from '@libp2p/interface'\n\nexport { pureJsCrypto } from './crypto/js.js'\nexport type { ICryptoInterface } from './crypto.js'\nexport type { NoiseInit, NoiseExtensions, KeyPair }\n\nexport interface NoiseComponents {\n  peerId: PeerId\n  privateKey: PrivateKey\n  logger: ComponentLogger\n  upgrader: Upgrader\n  metrics?: Metrics\n}\n\nexport function noise (init: NoiseInit = {}): (components: NoiseComponents) => ConnectionEncrypter<NoiseExtensions> {\n  return (components: NoiseComponents) => new Noise(components, init)\n}\n"],
  "mappings": "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",
  "names": ["message", "InvalidCryptoExchangeError", "message", "InvalidCryptoExchangeError", "NoiseExtensions", "_a", "_b", "NoiseHandshakePayload", "_a", "_b", "plaintext", "_a", "_b"]
}
