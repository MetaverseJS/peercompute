{
  "version": 3,
  "sources": ["../../../../../peercompute/node_modules/hashlru/index.js", "../../../../../peercompute/node_modules/libp2p/src/config.ts", "../../../../../peercompute/node_modules/it-all/src/index.ts", "../../../../../peercompute/node_modules/abort-error/src/index.ts", "../../../../../peercompute/node_modules/race-event/src/index.ts", "../../../../../peercompute/node_modules/it-queue/src/errors.ts", "../../../../../peercompute/node_modules/it-queue/src/recipient.ts", "../../../../../peercompute/node_modules/it-queue/src/job.ts", "../../../../../peercompute/node_modules/it-queue/src/utils.ts", "../../../../../peercompute/node_modules/it-queue/src/index.ts", "../../../../../peercompute/node_modules/mortice/src/constants.ts", "../../../../../peercompute/node_modules/mortice/src/main/channel.ts", "../../../../../peercompute/node_modules/mortice/src/utils.ts", "../../../../../peercompute/node_modules/mortice/src/workers/channel.ts", "../../../../../peercompute/node_modules/mortice/src/browser.ts", "../../../../../peercompute/node_modules/mortice/src/mortice.ts", "../../../../../peercompute/node_modules/mortice/src/index.ts", "../../../../../peercompute/node_modules/@libp2p/peer-store/src/constants.ts", "../../../../../peercompute/node_modules/@libp2p/peer-store/src/pb/peer.ts", "../../../../../peercompute/node_modules/@libp2p/peer-store/src/utils/bytes-to-peer.ts", "../../../../../peercompute/node_modules/@libp2p/peer-store/src/utils/peer-equals.ts", "../../../../../peercompute/node_modules/@libp2p/peer-store/src/utils/peer-id-to-datastore-key.ts", "../../../../../peercompute/node_modules/@libp2p/peer-store/src/utils/dedupe-addresses.ts", "../../../../../peercompute/node_modules/@libp2p/peer-store/src/utils/to-peer-pb.ts", "../../../../../peercompute/node_modules/@libp2p/peer-store/src/store.ts", "../../../../../peercompute/node_modules/@libp2p/peer-store/src/index.ts", "../../../../../peercompute/node_modules/interface-store/src/errors.ts", "../../../../../peercompute/node_modules/it-peekable/src/index.ts", "../../../../../peercompute/node_modules/it-filter/src/index.ts", "../../../../../peercompute/node_modules/it-sort/src/index.ts", "../../../../../peercompute/node_modules/it-take/src/index.ts", "../../../../../peercompute/node_modules/datastore-core/src/base.ts", "../../../../../peercompute/node_modules/datastore-core/src/memory.ts", "../../../../../peercompute/node_modules/libp2p/src/address-manager/dns-mappings.ts", "../../../../../peercompute/node_modules/libp2p/src/address-manager/ip-mappings.ts", "../../../../../peercompute/node_modules/libp2p/src/address-manager/observed-addresses.ts", "../../../../../peercompute/node_modules/libp2p/src/address-manager/transport-addresses.ts", "../../../../../peercompute/node_modules/libp2p/src/address-manager/index.ts", "../../../../../peercompute/node_modules/libp2p/src/errors.ts", "../../../../../peercompute/node_modules/libp2p/src/components.ts", "../../../../../peercompute/node_modules/libp2p/src/config/connection-gater.browser.ts", "../../../../../peercompute/node_modules/libp2p/src/get-peer.ts", "../../../../../peercompute/node_modules/libp2p/src/connection-manager/utils.ts", "../../../../../peercompute/node_modules/libp2p/src/connection-manager/connection-pruner.ts", "../../../../../peercompute/node_modules/libp2p/src/connection-manager/constants.defaults.ts", "../../../../../peercompute/node_modules/libp2p/src/connection-manager/constants.browser.ts", "../../../../../peercompute/node_modules/libp2p/src/connection-manager/address-sorter.ts", "../../../../../peercompute/node_modules/@multiformats/dns/src/errors.ts", "../../../../../peercompute/node_modules/@multiformats/dns/node_modules/p-queue/dist/lower-bound.js", "../../../../../peercompute/node_modules/@multiformats/dns/node_modules/p-queue/dist/priority-queue.js", "../../../../../peercompute/node_modules/@multiformats/dns/node_modules/p-queue/dist/index.js", "../../../../../peercompute/node_modules/@multiformats/dns/src/utils/get-types.ts", "../../../../../peercompute/node_modules/@multiformats/dns/src/utils/to-dns-response.ts", "../../../../../peercompute/node_modules/@multiformats/dns/src/resolvers/dns-json-over-https.ts", "../../../../../peercompute/node_modules/@multiformats/dns/src/resolvers/default.browser.ts", "../../../../../peercompute/node_modules/@multiformats/dns/src/utils/cache.ts", "../../../../../peercompute/node_modules/@multiformats/dns/src/dns.ts", "../../../../../peercompute/node_modules/@multiformats/dns/src/index.ts", "../../../../../peercompute/node_modules/libp2p/src/connection-manager/resolvers/dnsaddr.ts", "../../../../../peercompute/node_modules/libp2p/src/connection-manager/resolvers/index.ts", "../../../../../peercompute/node_modules/libp2p/src/connection-manager/dial-queue.ts", "../../../../../peercompute/node_modules/is-network-error/index.js", "../../../../../peercompute/node_modules/p-retry/index.js", "../../../../../peercompute/node_modules/libp2p/src/connection-manager/reconnect-queue.ts", "../../../../../peercompute/node_modules/libp2p/src/connection-manager/index.ts", "../../../../../peercompute/node_modules/libp2p/src/connection-monitor.ts", "../../../../../peercompute/node_modules/libp2p/src/content-routing.ts", "../../../../../peercompute/node_modules/libp2p/src/peer-routing.ts", "../../../../../peercompute/node_modules/libp2p/src/random-walk.ts", "../../../../../peercompute/node_modules/libp2p/src/registrar.ts", "../../../../../peercompute/node_modules/libp2p/src/transport-manager.ts", "../../../../../peercompute/node_modules/@libp2p/multistream-select/src/constants.ts", "../../../../../peercompute/node_modules/@libp2p/multistream-select/src/multistream.ts", "../../../../../peercompute/node_modules/@libp2p/multistream-select/src/select.ts", "../../../../../peercompute/node_modules/@libp2p/multistream-select/node_modules/it-length-prefixed/src/constants.ts", "../../../../../peercompute/node_modules/@libp2p/multistream-select/node_modules/it-length-prefixed/src/errors.ts", "../../../../../peercompute/node_modules/@libp2p/multistream-select/node_modules/it-length-prefixed/src/utils.ts", "../../../../../peercompute/node_modules/@libp2p/multistream-select/node_modules/it-length-prefixed/src/encode.ts", "../../../../../peercompute/node_modules/@libp2p/multistream-select/node_modules/it-length-prefixed/src/decode.ts", "../../../../../peercompute/node_modules/@libp2p/multistream-select/src/handle.ts", "../../../../../peercompute/node_modules/libp2p/src/connection.ts", "../../../../../peercompute/node_modules/libp2p/src/upgrader.ts", "../../../../../peercompute/node_modules/libp2p/src/version.ts", "../../../../../peercompute/node_modules/libp2p/src/user-agent.browser.ts", "../../../../../peercompute/node_modules/libp2p/src/libp2p.ts", "../../../../../peercompute/node_modules/libp2p/src/index.ts"],
  "sourcesContent": ["module.exports = function (max) {\n\n  if (!max) throw Error('hashlru must have a max value, of type number, greater than 0')\n\n  var size = 0, cache = Object.create(null), _cache = Object.create(null)\n\n  function update (key, value) {\n    cache[key] = value\n    size ++\n    if(size >= max) {\n      size = 0\n      _cache = cache\n      cache = Object.create(null)\n    }\n  }\n\n  return {\n    has: function (key) {\n      return cache[key] !== undefined || _cache[key] !== undefined\n    },\n    remove: function (key) {\n      if(cache[key] !== undefined)\n        cache[key] = undefined\n      if(_cache[key] !== undefined)\n        _cache[key] = undefined\n    },\n    get: function (key) {\n      var v = cache[key]\n      if(v !== undefined) return v\n      if((v = _cache[key]) !== undefined) {\n        update(key, v)\n        return v\n      }\n    },\n    set: function (key, value) {\n      if(cache[key] !== undefined) cache[key] = value\n      else update(key, value)\n    },\n    clear: function () {\n      cache = Object.create(null)\n      _cache = Object.create(null)\n    }\n  }\n}\n\n\n\n\n\n\n\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport type { Libp2pInit } from './index.js'\nimport type { ServiceMap } from '@libp2p/interface'\n\nexport async function validateConfig <T extends ServiceMap = Record<string, unknown>> (opts: Libp2pInit<T>): Promise<Libp2pInit<T>> {\n  if (opts.connectionProtector === null && globalThis.process?.env?.LIBP2P_FORCE_PNET != null) {\n    throw new InvalidParametersError('Private network is enforced, but no protector was provided')\n  }\n\n  return opts\n}\n", "/**\n * @packageDocumentation\n *\n * For when you need a one-liner to collect iterable values.\n *\n * @example\n *\n * ```javascript\n * import all from 'it-all'\n *\n * // This can also be an iterator, etc\n * const values = function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const arr = all(values)\n *\n * console.info(arr) // 0, 1, 2, 3, 4\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const arr = await all(values())\n *\n * console.info(arr) // 0, 1, 2, 3, 4\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Collects all values from an (async) iterable and returns them as an array\n */\nfunction all <T> (source: Iterable<T>): T[]\nfunction all <T> (source: Iterable<T> | AsyncIterable<T>): Promise<T[]>\nfunction all <T> (source: Iterable<T> | AsyncIterable<T>): Promise<T[]> | T[] {\n  if (isAsyncIterable(source)) {\n    return (async () => {\n      const arr = []\n\n      for await (const entry of source) {\n        arr.push(entry)\n      }\n\n      return arr\n    })()\n  }\n\n  const arr = []\n\n  for (const entry of source) {\n    arr.push(entry)\n  }\n\n  return arr\n}\n\nexport default all\n", "/**\n * @packageDocumentation\n *\n * A simple error class and options interface that seems to get copied from\n * project to project.\n *\n * @example Using `AbortError`\n *\n * ```JavaScript\n * import { AbortError } from 'abort-error'\n *\n * // a promise that will be settled later\n * const deferred = Promise.withResolvers()\n *\n * const signal = AbortSignal.timeout(1000)\n * signal.addEventListener('abort', () => {\n *   deferred.reject(new AbortError())\n * })\n * ```\n *\n * @example Using `AbortOptions`\n *\n * ```TypeScript\n * import type { AbortOptions } from 'abort-error'\n *\n * async function myFunction (options?: AbortOptions) {\n *   return fetch('https://example.com', {\n *     signal: options?.signal\n *   })\n * }\n * ```\n */\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\nexport class AbortError extends Error {\n  static name = 'AbortError'\n  name = 'AbortError'\n\n  constructor (message: string = 'The operation was aborted', ...rest: any[]) {\n    super(message, ...rest)\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Race an event against an AbortSignal, taking care to remove any event\n * listeners that were added.\n *\n * @example Getting started\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * setTimeout(() => {\n *   controller.abort()\n * }, 500)\n *\n * setTimeout(() => {\n *   // too late\n *   emitter.dispatchEvent(new CustomEvent('event'))\n * }, 1000)\n *\n * // throws an AbortError\n * const resolve = await raceEvent(emitter, 'event', controller.signal)\n * ```\n *\n * @example Aborting the promise with an error event\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const emitter = new EventTarget()\n *\n * setTimeout(() => {\n *   emitter.dispatchEvent(new CustomEvent('failure', {\n *     detail: new Error('Oh no!')\n *   }))\n * }, 1000)\n *\n * // throws 'Oh no!' error\n * const resolve = await raceEvent(emitter, 'success', AbortSignal.timeout(5000), {\n *   errorEvent: 'failure'\n * })\n * ```\n *\n * @example Customising the thrown AbortError\n *\n * The error message and `.code` property of the thrown `AbortError` can be\n * specified by passing options:\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * setTimeout(() => {\n *   controller.abort()\n * }, 500)\n *\n * // throws a Error: Oh no!\n * const resolve = await raceEvent(emitter, 'event', controller.signal, {\n *   errorMessage: 'Oh no!',\n *   errorCode: 'ERR_OH_NO'\n * })\n * ```\n *\n * @example Only resolving on specific events\n *\n * Where multiple events with the same type are emitted, a `filter` function can\n * be passed to only resolve on one of them:\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * // throws a Error: Oh no!\n * const resolve = await raceEvent(emitter, 'event', controller.signal, {\n *   filter: (evt: Event) => {\n *     return evt.detail.foo === 'bar'\n *   }\n * })\n * ```\n *\n * @example Terminating early by throwing from the filter\n *\n * You can cause listening for the event to cease and all event listeners to be\n * removed by throwing from the filter:\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * // throws Error: Cannot continue\n * const resolve = await raceEvent(emitter, 'event', controller.signal, {\n *   filter: (evt) => {\n *     if (...reasons) {\n *       throw new Error('Cannot continue')\n *     }\n *\n *     return true\n *   }\n * })\n * ```\n */\n\nimport { AbortError } from 'abort-error'\nimport type { EventEmitter } from 'node:events'\n\nexport interface RaceEventOptions<T> {\n  /**\n   * The message for the error thrown if the signal aborts\n   */\n  errorMessage?: string\n\n  /**\n   * The code for the error thrown if the signal aborts\n   */\n  errorCode?: string\n\n  /**\n   * The name of an event emitted on the emitter that should cause the returned\n   * promise to reject. The rejection reason will be the `.detail` field of the\n   * event.\n   *\n   * @default \"error\"\n   */\n  errorEvent?: string\n\n  /**\n   * If the 'errorEvent' option has been passed, and the emitted event has no\n   * `.detail` field, reject the promise with this error instead.\n   */\n  error?: Error\n\n  /**\n   * When multiple events with the same name may be emitted, pass a filter\n   * function here to allow ignoring ones that should not cause the returned\n   * promise to resolve.\n   */\n  filter?(evt: T): boolean\n}\n\n/**\n * Race a promise against an abort signal\n */\nexport async function raceEvent <T> (emitter: EventTarget | EventEmitter, eventName: string, signal?: AbortSignal, opts?: RaceEventOptions<T>): Promise<T> {\n  // create the error here so we have more context in the stack trace\n  const error = new AbortError(opts?.errorMessage)\n\n  if (opts?.errorCode != null) {\n    // @ts-expect-error not a field of AbortError\n    error.code = opts.errorCode\n  }\n\n  const errorEvent = opts?.errorEvent ?? 'error'\n\n  if (signal?.aborted === true) {\n    return Promise.reject(error)\n  }\n\n  return new Promise((resolve, reject) => {\n    function removeListeners (): void {\n      removeListener(signal, 'abort', abortListener)\n      removeListener(emitter, eventName, eventListener)\n      removeListener(emitter, errorEvent, errorEventListener)\n    }\n\n    const eventListener = (evt: any): void => {\n      try {\n        if (opts?.filter?.(evt) === false) {\n          return\n        }\n      } catch (err: any) {\n        removeListeners()\n        reject(err)\n        return\n      }\n\n      removeListeners()\n      resolve(evt)\n    }\n\n    const errorEventListener = (evt: any): void => {\n      removeListeners()\n\n      if (evt instanceof Error) {\n        reject(evt)\n        return\n      }\n\n      reject(evt.detail ?? opts?.error ?? new Error(`The \"${opts?.errorEvent}\" event was emitted but the event had no '.detail' field. Pass an 'error' option to race-event to change this message.`))\n    }\n\n    const abortListener = (): void => {\n      removeListeners()\n      reject(error)\n    }\n\n    addListener(signal, 'abort', abortListener)\n    addListener(emitter, eventName, eventListener)\n    addListener(emitter, errorEvent, errorEventListener)\n  })\n}\n\nfunction addListener (emitter: EventEmitter | EventTarget | undefined, event: string, listener: any): void {\n  if (emitter == null) {\n    return\n  }\n\n  if (isEventTarget(emitter)) {\n    emitter.addEventListener(event, listener)\n  } else {\n    emitter.addListener(event, listener)\n  }\n}\n\nfunction removeListener (emitter: EventEmitter | EventTarget | undefined, event: string, listener: any): void {\n  if (emitter == null) {\n    return\n  }\n\n  if (isEventTarget(emitter)) {\n    emitter.removeEventListener(event, listener)\n  } else {\n    emitter.removeListener(event, listener)\n  }\n}\n\nfunction isEventTarget (emitter: any): emitter is EventTarget {\n  return typeof emitter.addEventListener === 'function' && typeof emitter.removeEventListener === 'function'\n}\n", "export class QueueFullError extends Error {\n  static name = 'QueueFullError'\n\n  constructor (message: string = 'The queue was full') {\n    super(message)\n    this.name = 'QueueFullError'\n  }\n}\n", "import { AbortError } from 'abort-error'\n\nexport class JobRecipient<JobReturnType> {\n  public deferred: PromiseWithResolvers<JobReturnType>\n  public signal?: AbortSignal\n\n  constructor (signal?: AbortSignal) {\n    this.signal = signal\n    this.deferred = Promise.withResolvers()\n\n    this.onAbort = this.onAbort.bind(this)\n    this.signal?.addEventListener('abort', this.onAbort)\n  }\n\n  onAbort (): void {\n    this.deferred.reject(this.signal?.reason ?? new AbortError())\n  }\n\n  cleanup (): void {\n    this.signal?.removeEventListener('abort', this.onAbort)\n  }\n}\n", "import { AbortError } from 'abort-error'\nimport { setMaxListeners } from 'main-event'\nimport { raceSignal } from 'race-signal'\nimport { JobRecipient } from './recipient.js'\nimport type { JobStatus } from './index.js'\nimport type { AbortOptions } from 'abort-error'\n\n/**\n * Returns a random string\n */\nfunction randomId (): string {\n  return `${(parseInt(String(Math.random() * 1e9), 10)).toString()}${Date.now()}`\n}\n\nexport interface JobTimeline {\n  created: number\n  started?: number\n  finished?: number\n}\n\nexport class Job <JobOptions extends AbortOptions = AbortOptions, JobReturnType = unknown> {\n  public id: string\n  public fn: (options: JobOptions) => Promise<JobReturnType>\n  public options: JobOptions\n  public recipients: Array<JobRecipient<JobReturnType>>\n  public status: JobStatus\n  public readonly timeline: JobTimeline\n  private readonly controller: AbortController\n\n  constructor (fn: (options: JobOptions) => Promise<JobReturnType>, options: any) {\n    this.id = randomId()\n    this.status = 'queued'\n    this.fn = fn\n    this.options = options\n    this.recipients = []\n    this.timeline = {\n      created: Date.now()\n    }\n\n    this.controller = new AbortController()\n    setMaxListeners(Infinity, this.controller.signal)\n\n    this.onAbort = this.onAbort.bind(this)\n  }\n\n  abort (err: Error): void {\n    this.controller.abort(err)\n  }\n\n  onAbort (): void {\n    const allAborted = this.recipients.reduce((acc, curr) => {\n      return acc && (curr.signal?.aborted === true)\n    }, true)\n\n    // if all recipients have aborted the job, actually abort the job\n    if (allAborted) {\n      this.controller.abort(new AbortError())\n      this.cleanup()\n    }\n  }\n\n  async join (options: AbortOptions = {}): Promise<JobReturnType> {\n    const recipient = new JobRecipient<JobReturnType>(options.signal)\n    this.recipients.push(recipient)\n\n    options.signal?.addEventListener('abort', this.onAbort)\n\n    return recipient.deferred.promise\n  }\n\n  async run (): Promise<void> {\n    this.status = 'running'\n    this.timeline.started = Date.now()\n\n    try {\n      this.controller.signal.throwIfAborted()\n\n      const result = await raceSignal(this.fn({\n        ...(this.options ?? {}),\n        signal: this.controller.signal\n      }), this.controller.signal)\n\n      this.recipients.forEach(recipient => {\n        recipient.deferred.resolve(result)\n      })\n\n      this.status = 'complete'\n    } catch (err) {\n      this.recipients.forEach(recipient => {\n        recipient.deferred.reject(err)\n      })\n\n      this.status = 'errored'\n    } finally {\n      this.timeline.finished = Date.now()\n      this.cleanup()\n    }\n  }\n\n  cleanup (): void {\n    this.recipients.forEach(recipient => {\n      recipient.cleanup()\n      recipient.signal?.removeEventListener('abort', this.onAbort)\n    })\n  }\n}\n", "/**\n * A function with additional start/stop methods\n */\nexport interface DebouncedFunction {\n  (): void\n\n  start(): void\n  stop(): void\n}\n\n/**\n * Returns a function wrapper that will only call the passed function once\n *\n * Important - the passed function should not throw or reject\n */\nexport function debounce (func: () => void | Promise<void>, wait: number): DebouncedFunction {\n  let timeout: ReturnType<typeof setTimeout> | undefined\n\n  const output = function (): void {\n    const later = function (): void {\n      timeout = undefined\n      void func()\n    }\n\n    clearTimeout(timeout)\n    timeout = setTimeout(later, wait)\n  }\n  output.start = (): void => {}\n  output.stop = (): void => {\n    clearTimeout(timeout)\n  }\n\n  return output\n}\n", "/**\n * @packageDocumentation\n *\n * Based on `p-queue` but with access to the underlying queue, aborting a task\n * removes it from the queue and you can iterate over the queue results.\n *\n * @example\n *\n * ```ts\n * import all from 'it-all'\n * import { Queue } from 'it-queue'\n *\n * const queue = new Queue({\n *   concurrency: Infinity\n * })\n * void queue.add(async () => {\n *   return 'hello'\n * })\n * void queue.add(async () => {\n *   return 'world'\n * })\n *\n * const results = await all(queue)\n * // ['hello', 'world']\n *\n * // how many items are in the queue (includes running items)\n * console.info(queue.size)\n *\n * // how many items are running\n * console.info(queue.running)\n *\n * // how many items have not started running yet\n * console.info(queue.queued)\n * ```\n */\n\nimport { AbortError } from 'abort-error'\nimport { pushable } from 'it-pushable'\nimport { TypedEventEmitter } from 'main-event'\nimport { raceEvent } from 'race-event'\nimport { QueueFullError } from './errors.js'\nimport { Job } from './job.js'\nimport { debounce } from './utils.js'\nimport type { AbortOptions } from 'abort-error'\nexport type { Job, JobTimeline } from './job.js'\nexport type { JobRecipient } from './recipient.js'\n\nexport interface Comparator<T> {\n  (a: T, b: T): -1 | 0 | 1\n}\n\nexport interface QueueInit<JobReturnType, JobOptions extends AbortOptions = AbortOptions> {\n  /**\n   * Concurrency limit.\n   *\n   * Minimum: `1`.\n   *\n   * @default Infinity\n   */\n  concurrency?: number\n\n  /**\n   * If the queue size grows to larger than this number the promise returned\n   * from the add function will reject\n   *\n   * @default Infinity\n   */\n  maxSize?: number\n\n  /**\n   * An optional function that will sort the queue after a job has been added\n   */\n  sort?: Comparator<Job<JobOptions, JobReturnType>>\n\n  /**\n   * If false, `.start` will need to be called to start processing jobs\n   *\n   * @default true\n   */\n  autoStart?: boolean\n}\n\nexport type JobStatus = 'queued' | 'running' | 'errored' | 'complete'\n\nexport interface RunFunction<Options extends AbortOptions = AbortOptions, ReturnType = void> {\n  (options: Options): Promise<ReturnType>\n}\n\nexport interface JobMatcher<JobOptions extends AbortOptions = AbortOptions> {\n  (options?: Partial<JobOptions>): boolean\n}\n\nexport interface QueueJobSuccess<JobReturnType, JobOptions extends AbortOptions = AbortOptions> {\n  job: Job<JobOptions, JobReturnType>\n  result: JobReturnType\n}\n\nexport interface QueueJobFailure<JobReturnType, JobOptions extends AbortOptions = AbortOptions> {\n  job: Job<JobOptions, JobReturnType>\n  error: Error\n}\n\nexport interface QueueEvents<JobReturnType, JobOptions extends AbortOptions = AbortOptions> {\n  /**\n   * A job is about to start running\n   */\n  active: CustomEvent\n\n  /**\n   * All jobs have finished and the queue is empty\n   */\n  idle: CustomEvent\n\n  /**\n   * The queue is empty, jobs may be running\n   */\n  empty: CustomEvent\n\n  /**\n   * A job was added to the queue\n   */\n  add: CustomEvent\n\n  /**\n   * A job has finished or failed\n   */\n  next: CustomEvent\n\n  /**\n   * Emitted just after `\"completed\", a job has finished successfully - this\n   * event gives access to the job and it's result\n   */\n  success: CustomEvent<QueueJobSuccess<JobReturnType, JobOptions>>\n\n  /**\n   * A job has failed - this event gives access to the job and the thrown error\n   */\n  failure: CustomEvent<QueueJobFailure<JobReturnType, JobOptions>>\n}\n\n/**\n * Heavily influence by `p-queue` with the following differences:\n *\n * 1. Items remain at the head of the queue while they are running so `queue.size` includes `queue.pending` items - this is so interested parties can join the results of a queue item while it is running\n * 2. The options for a job are stored separately to the job in order for them to be modified while they are still in the queue\n * 3. If a job's abort signal fires before execution begins, it is removed from the queue immediately\n * 4. 'success'/'failure' events are emitted instead of 'error'/'complete'\n */\nexport class Queue<JobReturnType = unknown, JobOptions extends AbortOptions = AbortOptions> extends TypedEventEmitter<QueueEvents<JobReturnType, JobOptions>> {\n  public concurrency: number\n  public maxSize: number\n  public queue: Array<Job<JobOptions, JobReturnType>>\n  private pending: number\n  private readonly sort?: Comparator<Job<JobOptions, JobReturnType>>\n  private autoStart: boolean\n\n  constructor (init: QueueInit<JobReturnType, JobOptions> = {}) {\n    super()\n\n    this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY\n    this.maxSize = init.maxSize ?? Number.POSITIVE_INFINITY\n    this.pending = 0\n    this.autoStart = init.autoStart ?? true\n\n    this.sort = init.sort\n    this.queue = []\n\n    this.emitEmpty = debounce(this.emitEmpty.bind(this), 1)\n    this.emitIdle = debounce(this.emitIdle.bind(this), 1)\n  }\n\n  [Symbol.asyncIterator] (): AsyncGenerator<JobReturnType, void, unknown> {\n    return this.toGenerator()\n  }\n\n  emitEmpty (): void {\n    if (this.size !== 0) {\n      return\n    }\n\n    this.safeDispatchEvent('empty')\n  }\n\n  emitIdle (): void {\n    if (this.running !== 0) {\n      return\n    }\n\n    this.safeDispatchEvent('idle')\n  }\n\n  private tryToStartAnother (): boolean {\n    if (this.size === 0) {\n      this.emitEmpty()\n\n      if (this.running === 0) {\n        this.emitIdle()\n      }\n\n      return false\n    }\n\n    if (this.pending < this.concurrency) {\n      let job: Job<JobOptions, JobReturnType> | undefined\n\n      for (const j of this.queue) {\n        if (j.status === 'queued') {\n          job = j\n          break\n        }\n      }\n\n      if (job == null) {\n        return false\n      }\n\n      this.safeDispatchEvent('active')\n\n      this.pending++\n\n      void job.run()\n        .finally(() => {\n          // remove the job from the queue\n          for (let i = 0; i < this.queue.length; i++) {\n            if (this.queue[i] === job) {\n              this.queue.splice(i, 1)\n              break\n            }\n          }\n\n          this.pending--\n          this.safeDispatchEvent('next')\n          if (this.autoStart) {\n            this.tryToStartAnother()\n          }\n        })\n\n      return true\n    }\n\n    return false\n  }\n\n  private enqueue (job: Job<JobOptions, JobReturnType>): void {\n    this.queue.push(job)\n\n    if (this.sort != null) {\n      this.queue.sort(this.sort)\n    }\n  }\n\n  /**\n   * Start the queue. If the `autoStart` parameter passed to the constructor was\n   * not `false` this is a no-op\n   */\n  start (): void {\n    if (this.autoStart !== false) {\n      return\n    }\n\n    this.autoStart = true\n    this.tryToStartAnother()\n  }\n\n  /**\n   * Prevent further jobs from running - call `.start` to start the queue again\n   */\n  pause (): void {\n    this.autoStart = false\n  }\n\n  /**\n   * Adds a sync or async task to the queue. Always returns a promise.\n   */\n  async add (fn: RunFunction<JobOptions, JobReturnType>, options?: JobOptions): Promise<JobReturnType> {\n    options?.signal?.throwIfAborted()\n\n    if (this.size === this.maxSize) {\n      throw new QueueFullError()\n    }\n\n    const job = new Job<JobOptions, JobReturnType>(fn, options)\n    this.enqueue(job)\n    this.safeDispatchEvent('add')\n\n    if (this.autoStart) {\n      this.tryToStartAnother()\n    }\n\n    return job.join(options)\n      .then(result => {\n        this.safeDispatchEvent('success', { detail: { job, result } })\n\n        return result\n      })\n      .catch(err => {\n        if (job.status === 'queued') {\n          // job was aborted before it started - remove the job from the queue\n          for (let i = 0; i < this.queue.length; i++) {\n            if (this.queue[i] === job) {\n              this.queue.splice(i, 1)\n              break\n            }\n          }\n        }\n\n        this.safeDispatchEvent('failure', { detail: { job, error: err } })\n\n        throw err\n      })\n  }\n\n  /**\n   * Clear the queue\n   */\n  clear (): void {\n    this.queue.splice(0, this.queue.length)\n  }\n\n  /**\n   * Abort all jobs in the queue and clear it\n   */\n  abort (): void {\n    this.queue.forEach(job => {\n      job.abort(new AbortError())\n    })\n\n    this.clear()\n  }\n\n  /**\n   * Can be called multiple times. Useful if you for example add additional items at a later time.\n   *\n   * @returns A promise that settles when the queue becomes empty.\n   */\n  async onEmpty (options?: AbortOptions): Promise<void> {\n    // Instantly resolve if the queue is empty\n    if (this.size === 0) {\n      return\n    }\n\n    await raceEvent(this, 'empty', options?.signal)\n  }\n\n  /**\n   * @returns A promise that settles when the queue size is less than the given\n   * limit: `queue.size < limit`.\n   *\n   * If you want to avoid having the queue grow beyond a certain size you can\n   * `await queue.onSizeLessThan()` before adding a new item.\n   *\n   * Note that this only limits the number of items waiting to start. There\n   * could still be up to `concurrency` jobs already running that this call does\n   * not include in its calculation.\n   */\n  async onSizeLessThan (limit: number, options?: AbortOptions): Promise<void> {\n    // Instantly resolve if the queue is empty.\n    if (this.size < limit) {\n      return\n    }\n\n    await raceEvent(this, 'next', options?.signal, {\n      filter: () => this.size < limit\n    })\n  }\n\n  /**\n   * The difference with `.onEmpty` is that `.onIdle` guarantees that all work\n   * from the queue has finished. `.onEmpty` merely signals that the queue is\n   * empty, but it could mean that some promises haven't completed yet.\n   *\n   * @returns A promise that settles when the queue becomes empty, and all\n   * promises have completed; `queue.size === 0 && queue.pending === 0`.\n   */\n  async onIdle (options?: AbortOptions): Promise<void> {\n    // Instantly resolve if none pending and if nothing else is queued\n    if (this.pending === 0 && this.size === 0) {\n      return\n    }\n\n    await raceEvent(this, 'idle', options?.signal)\n  }\n\n  /**\n   * Size of the queue including running items\n   */\n  get size (): number {\n    return this.queue.length\n  }\n\n  /**\n   * The number of queued items waiting to run.\n   */\n  get queued (): number {\n    return this.queue.length - this.pending\n  }\n\n  /**\n   * The number of items currently running.\n   */\n  get running (): number {\n    return this.pending\n  }\n\n  /**\n   * Returns an async generator that makes it easy to iterate over the results\n   * of jobs added to the queue.\n   *\n   * The generator will end when the queue becomes idle, that is there are no\n   * jobs running and no jobs that have yet to run.\n   *\n   * If you need to keep the queue open indefinitely, consider using it-pushable\n   * instead.\n   */\n  async * toGenerator (options?: AbortOptions): AsyncGenerator<JobReturnType, void, unknown> {\n    options?.signal?.throwIfAborted()\n\n    const stream = pushable<JobReturnType>({\n      objectMode: true\n    })\n\n    const cleanup = (err?: Error): void => {\n      if (err != null) {\n        this.abort()\n      } else {\n        this.clear()\n      }\n\n      stream.end(err)\n    }\n\n    const onQueueJobComplete = (evt: CustomEvent<QueueJobSuccess<JobReturnType, JobOptions>>): void => {\n      if (evt.detail != null) {\n        stream.push(evt.detail.result)\n      }\n    }\n\n    const onQueueError = (evt: CustomEvent<QueueJobFailure<JobReturnType, JobOptions>>): void => {\n      cleanup(evt.detail.error)\n    }\n\n    const onQueueIdle = (): void => {\n      cleanup()\n    }\n\n    // clear the queue and throw if the query is aborted\n    const onSignalAbort = (): void => {\n      cleanup(new AbortError('Queue aborted'))\n    }\n\n    // add listeners\n    this.addEventListener('success', onQueueJobComplete)\n    this.addEventListener('failure', onQueueError)\n    this.addEventListener('idle', onQueueIdle)\n    options?.signal?.addEventListener('abort', onSignalAbort)\n\n    try {\n      yield * stream\n    } finally {\n      // remove listeners\n      this.removeEventListener('success', onQueueJobComplete)\n      this.removeEventListener('failure', onQueueError)\n      this.removeEventListener('idle', onQueueIdle)\n      options?.signal?.removeEventListener('abort', onSignalAbort)\n\n      // empty the queue for when the user has broken out of a loop early\n      cleanup()\n    }\n  }\n}\n", "export const WORKER_REQUEST_READ_LOCK = 'lock:worker:request-read'\nexport const WORKER_ABORT_READ_LOCK_REQUEST = 'lock:worker:abort-read-request'\nexport const WORKER_RELEASE_READ_LOCK = 'lock:worker:release-read'\nexport const MASTER_GRANT_READ_LOCK = 'lock:master:grant-read'\nexport const MASTER_READ_LOCK_ERROR = 'lock:master:error-read'\n\nexport const WORKER_REQUEST_WRITE_LOCK = 'lock:worker:request-write'\nexport const WORKER_ABORT_WRITE_LOCK_REQUEST = 'lock:worker:abort-write-request'\nexport const WORKER_RELEASE_WRITE_LOCK = 'lock:worker:release-write'\nexport const MASTER_GRANT_WRITE_LOCK = 'lock:master:grant-write'\nexport const MASTER_WRITE_LOCK_ERROR = 'lock:master:error-write'\n\nexport const WORKER_FINALIZE = 'lock:worker:finalize'\n\nexport const BROADCAST_CHANNEL_NAME = 'mortice'\n\nexport const defaultOptions = {\n  singleProcess: false\n}\n", "import {\n  WORKER_FINALIZE\n} from '../constants.js'\nimport type { AbortEventData, AbortRequestType, FinalizeEventData, MorticeEvents, RequestType } from '../mortice.js'\nimport type { TypedEventTarget } from 'main-event'\n\nexport const handleChannelWorkerLockRequest = (emitter: TypedEventTarget<MorticeEvents>, channel: BroadcastChannel, masterEvent: RequestType, abortMasterEvent: AbortRequestType, requestType: string, abortType: string, errorType: string, releaseType: string, grantType: string) => {\n  return (event: MessageEvent) => {\n    if (event.data == null) {\n      return\n    }\n\n    const requestEvent = {\n      type: event.data.type,\n      name: event.data.name,\n      identifier: event.data.identifier\n    }\n\n    // worker is requesting lock\n    if (requestEvent.type === requestType) {\n      emitter.safeDispatchEvent(masterEvent, {\n        detail: {\n          name: requestEvent.name,\n          identifier: requestEvent.identifier,\n          handler: async (): Promise<void> => {\n            // grant lock to worker\n            channel.postMessage({\n              type: grantType,\n              name: requestEvent.name,\n              identifier: requestEvent.identifier\n            })\n\n            // wait for worker to finish\n            await new Promise<void>((resolve) => {\n              const releaseEventListener = (event: MessageEvent): void => {\n                if (event?.data == null) {\n                  return\n                }\n\n                const releaseEvent = {\n                  type: event.data.type,\n                  name: event.data.name,\n                  identifier: event.data.identifier\n                }\n\n                if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {\n                  channel.removeEventListener('message', releaseEventListener)\n                  resolve()\n                }\n              }\n\n              channel.addEventListener('message', releaseEventListener)\n            })\n          },\n          onError: (err: Error) => {\n            // send error to worker\n            channel.postMessage({\n              type: errorType,\n              name: requestEvent.name,\n              identifier: requestEvent.identifier,\n              error: {\n                message: err.message,\n                name: err.name,\n                stack: err.stack\n              }\n            })\n          }\n        }\n      })\n    }\n\n    // worker is no longer interested in requesting the lock\n    if (requestEvent.type === abortType) {\n      emitter.safeDispatchEvent<AbortEventData>(abortMasterEvent, {\n        detail: {\n          name: requestEvent.name,\n          identifier: requestEvent.identifier\n        }\n      })\n    }\n\n    // worker is done with lock\n    if (requestEvent.type === WORKER_FINALIZE) {\n      emitter.safeDispatchEvent<FinalizeEventData>('finalizeRequest', {\n        detail: {\n          name: requestEvent.name\n        }\n      })\n    }\n  }\n}\n", "export const nanoid = (size: number = 10): string => {\n  return Math.random().toString().substring(2, size + 2)\n}\n", "import {\n  WORKER_REQUEST_READ_LOCK,\n  WORKER_RELEASE_READ_LOCK,\n  MASTER_GRANT_READ_LOCK,\n  WORKER_REQUEST_WRITE_LOCK,\n  WORKER_RELEASE_WRITE_LOCK,\n  MASTER_GRANT_WRITE_LOCK,\n  WORKER_ABORT_READ_LOCK_REQUEST,\n  WORKER_ABORT_WRITE_LOCK_REQUEST,\n  MASTER_READ_LOCK_ERROR,\n  MASTER_WRITE_LOCK_ERROR,\n  WORKER_FINALIZE,\n  BROADCAST_CHANNEL_NAME\n} from '../constants.js'\nimport { nanoid } from '../utils.js'\nimport type { Mortice, Release } from '../index.js'\nimport type { AbortOptions } from 'abort-error'\n\nexport class MorticeChannelWorker implements Mortice {\n  private name: string\n  private channel: BroadcastChannel\n\n  constructor (name: string) {\n    this.name = name\n    this.channel = new BroadcastChannel(BROADCAST_CHANNEL_NAME)\n  }\n\n  readLock (options?: AbortOptions): Promise<Release> {\n    return this.sendRequest(\n      WORKER_REQUEST_READ_LOCK,\n      WORKER_ABORT_READ_LOCK_REQUEST,\n      MASTER_GRANT_READ_LOCK,\n      MASTER_READ_LOCK_ERROR,\n      WORKER_RELEASE_READ_LOCK,\n      options\n    )\n  }\n\n  writeLock (options?: AbortOptions): Promise<Release> {\n    return this.sendRequest(\n      WORKER_REQUEST_WRITE_LOCK,\n      WORKER_ABORT_WRITE_LOCK_REQUEST,\n      MASTER_GRANT_WRITE_LOCK,\n      MASTER_WRITE_LOCK_ERROR,\n      WORKER_RELEASE_WRITE_LOCK,\n      options\n    )\n  }\n\n  finalize (): void {\n    this.channel.postMessage({\n      type: WORKER_FINALIZE,\n      name: this.name\n    })\n\n    this.channel.close()\n  }\n\n  private async sendRequest (requestType: string, abortType: string, grantType: string, errorType: string, releaseType: string, options?: AbortOptions): Promise<Release> {\n    options?.signal?.throwIfAborted()\n    const id = nanoid()\n\n    this.channel.postMessage({\n      type: requestType,\n      identifier: id,\n      name: this.name\n    })\n\n    return new Promise<Release>((resolve, reject) => {\n      const abortListener = (): void => {\n        this.channel.postMessage({\n          type: abortType,\n          identifier: id,\n          name: this.name\n        })\n      }\n\n      options?.signal?.addEventListener('abort', abortListener, {\n        once: true\n      })\n\n      const listener = (event: MessageEvent): void => {\n        if (event.data?.identifier !== id) {\n          return\n        }\n\n        if (event.data?.type === grantType) {\n          this.channel.removeEventListener('message', listener)\n          options?.signal?.removeEventListener('abort', abortListener)\n\n          // lock granted\n          resolve(() => {\n            // release lock\n            this.channel.postMessage({\n              type: releaseType,\n              identifier: id,\n              name: this.name\n            })\n          })\n        }\n\n        if (event.data.type === errorType) {\n          this.channel.removeEventListener('message', listener)\n          options?.signal?.removeEventListener('abort', abortListener)\n\n          // error while waiting for grant of lock\n          const err = new Error()\n\n          if (event.data.error != null) {\n            err.message = event.data.error.message\n            err.name = event.data.error.name\n            err.stack = event.data.error.stack\n          }\n\n          reject(err)\n        }\n      }\n\n      this.channel.addEventListener('message', listener)\n    })\n  }\n}\n", "import { TypedEventEmitter } from 'main-event'\nimport {\n  WORKER_REQUEST_READ_LOCK,\n  WORKER_RELEASE_READ_LOCK,\n  MASTER_GRANT_READ_LOCK,\n  WORKER_REQUEST_WRITE_LOCK,\n  WORKER_RELEASE_WRITE_LOCK,\n  MASTER_GRANT_WRITE_LOCK,\n  WORKER_ABORT_READ_LOCK_REQUEST,\n  WORKER_ABORT_WRITE_LOCK_REQUEST,\n  MASTER_READ_LOCK_ERROR,\n  MASTER_WRITE_LOCK_ERROR,\n  BROADCAST_CHANNEL_NAME,\n  defaultOptions\n} from './constants.js'\nimport { handleChannelWorkerLockRequest } from './main/channel.ts'\nimport { MorticeChannelWorker } from './workers/channel.ts'\nimport type { Mortice, MorticeOptions } from './index.js'\nimport type { MorticeEvents } from './mortice.js'\nimport type { TypedEventTarget } from 'main-event'\n\nexport default (options: Required<MorticeOptions>): Mortice | TypedEventTarget<MorticeEvents> => {\n  options = Object.assign({}, defaultOptions, options)\n  const isPrimary = Boolean(globalThis.document) || options.singleProcess\n\n  if (isPrimary) {\n    const channel = new BroadcastChannel(BROADCAST_CHANNEL_NAME)\n    const emitter = new TypedEventEmitter<MorticeEvents>()\n\n    channel.addEventListener('message', handleChannelWorkerLockRequest(\n      emitter,\n      channel,\n      'requestReadLock',\n      'abortReadLockRequest',\n      WORKER_REQUEST_READ_LOCK,\n      WORKER_ABORT_READ_LOCK_REQUEST,\n      MASTER_READ_LOCK_ERROR,\n      WORKER_RELEASE_READ_LOCK,\n      MASTER_GRANT_READ_LOCK\n    ))\n    channel.addEventListener('message', handleChannelWorkerLockRequest(\n      emitter,\n      channel,\n      'requestWriteLock',\n      'abortWriteLockRequest',\n      WORKER_REQUEST_WRITE_LOCK,\n      WORKER_ABORT_WRITE_LOCK_REQUEST,\n      MASTER_WRITE_LOCK_ERROR,\n      WORKER_RELEASE_WRITE_LOCK,\n      MASTER_GRANT_WRITE_LOCK\n    ))\n\n    return emitter\n  }\n\n  return new MorticeChannelWorker(options.name)\n}\n", "import { AbortError } from 'abort-error'\nimport { Queue } from 'it-queue'\nimport impl from './node.js'\nimport type { Mortice, MorticeOptions, Release } from './index.js'\nimport type { AbortOptions } from 'abort-error'\nimport type { TypedEventTarget } from 'main-event'\n\nexport type RequestType = 'requestReadLock' | 'requestWriteLock'\nexport type AbortRequestType = 'abortReadLockRequest' | 'abortWriteLockRequest'\nexport type FinalizeRequestType = 'finalizeRequest'\n\nexport interface RequestEventData {\n  name: string\n  identifier: string\n  handler(): Promise<void>\n  onError(err: Error): void\n}\n\nexport interface RequestEvent {\n  type: string\n  identifier: string\n  name: string,\n  error?: {\n    name: string\n    message: string\n    stack: string\n  }\n}\n\nexport interface AbortEventData {\n  name: string\n  identifier: string\n}\n\nexport interface FinalizeEventData {\n  name: string\n}\n\nexport interface MorticeEvents {\n  requestReadLock: CustomEvent<RequestEventData>\n  abortReadLockRequest: CustomEvent<AbortEventData>\n  requestWriteLock: CustomEvent<RequestEventData>\n  abortWriteLockRequest: CustomEvent<AbortEventData>\n  finalizeRequest: CustomEvent<FinalizeEventData>\n}\n\nconst mutexes: Map<string, Mortice> = new Map()\nlet implementation: Mortice | TypedEventTarget<MorticeEvents>\n\nexport function isMortice (obj?: any): obj is Mortice {\n  return typeof obj?.readLock === 'function' && typeof obj?.writeLock === 'function'\n}\n\nexport function getImplementation (opts: Required<MorticeOptions>): Mortice | TypedEventTarget<MorticeEvents> {\n  if (implementation == null) {\n    implementation = impl(opts)\n\n    if (!isMortice(implementation)) {\n      const emitter = implementation\n\n      // we are master, set up worker requests\n      emitter.addEventListener('requestReadLock', (event: CustomEvent<RequestEventData>) => {\n        const mutexName = event.detail.name\n        const identifier = event.detail.identifier\n        const mutex = mutexes.get(mutexName)\n\n        if (mutex == null) {\n          return\n        }\n\n        const abortController = new AbortController()\n\n        const abortListener = (event: CustomEvent<AbortEventData>): void => {\n          if (event.detail.name !== mutexName || event.detail.identifier !== identifier) {\n            return\n          }\n\n          abortController.abort()\n        }\n\n        emitter.addEventListener('abortReadLockRequest', abortListener)\n\n        void mutex.readLock({\n          signal: abortController.signal\n        })\n          .then(async release => {\n            await event.detail.handler()\n              .finally(() => {\n                release()\n              })\n          })\n          .catch(err => {\n            event.detail.onError(err)\n          })\n          .finally(() => {\n            emitter.removeEventListener('abortReadLockRequest', abortListener)\n          })\n      })\n\n      emitter.addEventListener('requestWriteLock', (event: CustomEvent<RequestEventData>) => {\n        const mutexName = event.detail.name\n        const identifier = event.detail.identifier\n        const mutex = mutexes.get(mutexName)\n\n        if (mutex == null) {\n          return\n        }\n\n        const abortController = new AbortController()\n\n        const abortListener = (event: CustomEvent<AbortEventData>): void => {\n          if (event.detail.name !== mutexName || event.detail.identifier !== identifier) {\n            return\n          }\n\n          abortController.abort()\n        }\n\n        emitter.addEventListener('abortWriteLockRequest', abortListener)\n\n        void mutex.writeLock({\n          signal: abortController.signal\n        })\n          .then(async release => {\n            await event.detail.handler()\n              .finally(() => {\n                release()\n              })\n          })\n          .catch(err => {\n            event.detail.onError(err)\n          })\n          .finally(() => {\n            emitter.removeEventListener('abortWriteLockRequest', abortListener)\n          })\n      })\n\n      emitter.addEventListener('finalizeRequest', (event: CustomEvent<FinalizeEventData>): void => {\n        const mutexName = event.detail.name\n        const mutex = mutexes.get(mutexName)\n\n        if (mutex == null) {\n          return\n        }\n\n        mutex.finalize()\n      })\n    }\n  }\n\n  return implementation\n}\n\nasync function createReleasable (queue: Queue, options?: AbortOptions): Promise<Release> {\n  let res: (release: Release) => void\n  let rej: (err: Error) => void\n\n  const p = new Promise<Release>((resolve, reject) => {\n    res = resolve\n    rej = reject\n  })\n\n  const listener = (): void => {\n    rej(new AbortError())\n  }\n\n  options?.signal?.addEventListener('abort', listener, {\n    once: true\n  })\n\n  queue.add(async () => {\n    await new Promise<void>((resolve) => {\n      res(() => {\n        options?.signal?.removeEventListener('abort', listener)\n        resolve()\n      })\n    })\n  }, {\n    signal: options?.signal\n  })\n    .catch((err) => {\n      rej(err)\n    })\n\n  return p\n}\n\nexport const createMutex = (name: string, options: Required<MorticeOptions>): Mortice => {\n  let mutex = mutexes.get(name)\n\n  if (mutex != null) {\n    return mutex\n  }\n\n  const implementation = getImplementation(options)\n\n  // a Mortice instance will be returned if we are a worker, otherwise if we are\n  // primary an event target will be returned that fires events when workers\n  // request a lock\n  if (isMortice(implementation)) {\n    mutex = implementation\n\n    mutexes.set(name, mutex)\n\n    return mutex\n  }\n\n  const masterQueue = new Queue({\n    concurrency: 1\n  })\n  let readQueue: Queue | null\n\n  mutex = {\n    async readLock (opts?: AbortOptions) {\n      // If there's already a read queue, just add the task to it\n      if (readQueue != null) {\n        return createReleasable(readQueue, opts)\n      }\n\n      // Create a new read queue\n      readQueue = new Queue({\n        concurrency: options.concurrency,\n        autoStart: false\n      })\n      const localReadQueue = readQueue\n\n      // Add the task to the read queue\n      const readPromise = createReleasable(readQueue, opts)\n\n      void masterQueue.add(async () => {\n        // Start the task only once the master queue has completed processing\n        // any previous tasks\n        localReadQueue.start()\n\n        // Once all the tasks in the read queue have completed, remove it so\n        // that the next read lock will occur after any write locks that were\n        // started in the interim\n        await localReadQueue.onIdle()\n          .then(() => {\n            if (readQueue === localReadQueue) {\n              readQueue = null\n            }\n          })\n      })\n\n      return readPromise\n    },\n    async writeLock (opts?: AbortOptions) {\n      // Remove the read queue reference, so that any later read locks will be\n      // added to a new queue that starts after this write lock has been\n      // released\n      readQueue = null\n\n      return createReleasable(masterQueue, opts)\n    },\n    finalize: () => {\n      mutexes.delete(name)\n    },\n    queue: masterQueue\n  }\n\n  mutexes.set(name, mutex)\n\n  // if requested, finalize the lock once the last lock holder has released it\n  if (options.autoFinalize === true) {\n    masterQueue.addEventListener('idle', () => {\n      mutex.finalize()\n    }, {\n      once: true\n    })\n  }\n\n  return mutex\n}\n", "/**\n * @packageDocumentation\n *\n * - Reads occur concurrently\n * - Writes occur one at a time\n * - No reads occur while a write operation is in progress\n * - Locks can be created with different names\n * - Reads/writes can time out\n *\n * @example\n *\n * ```ts\n * import mortice from 'mortice'\n * import delay from 'delay'\n *\n * // the lock name & options objects are both optional\n * const mutex = mortice()\n *\n * Promise.all([\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 1')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 2')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.writeLock()\n *\n *     try {\n *       await delay(1000)\n *\n *       console.info('write 1')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 3')\n *     } finally {\n *       release()\n *     }\n *   })()\n * ])\n * ```\n *\n *     read 1\n *     read 2\n *     <small pause>\n *     write 1\n *     read 3\n *\n * ## Clean up\n *\n * Mutexes are stored globally reference by name, this is so you can obtain the\n * same lock from different contexts, including workers.\n *\n * When a mutex is no longer required, the `.finalize` function should be called\n * to remove any internal references to it.\n *\n * ```ts\n * import mortice from 'mortice'\n *\n * const mutex = mortice()\n *\n * // ...some time later\n *\n * mutex.finalize()\n * ```\n *\n * ## Auto clean up\n *\n * If your app generates a lot of short-lived mutexes and you want to clean them\n * up after the last lock has been released, pass the `autoFinalize` option to\n * mortice in the owning context:\n *\n ```ts\n * import mortice from 'mortice'\n *\n * const mutex = mortice({\n *   autoFinalize: true\n * })\n *\n * const release = await mutex.readLock()\n * // ...some time later\n *\n * release()\n *\n * // mutex will be freed soon after\n * ```\n *\n * ## React native support\n *\n * This module should run on react native but it only supports single-process\n * concurrency as it's not clear to the author (disclaimer - not a react native\n * dev) what the officially supported process concurrency model is.\n *\n * Please open an issue if this is a feature you would like to see added.\n */\n\nimport { Queue } from 'it-queue'\nimport { createMutex } from './mortice.ts'\nimport type { AbortOptions } from 'abort-error'\n\nexport interface MorticeOptions {\n  /**\n   * An optional name for the lock\n   */\n  name?: string\n\n  /**\n   * How many read operations are executed concurrently\n   *\n   * @default Infinity\n   */\n  concurrency?: number\n\n  /**\n   * By default the the lock will be held on the main thread and child/worker\n   * processes will coordinate to share the lock.\n   *\n   * Set this to true if each main/child/worker thread should maintain it's own\n   * lock with no coordination between them.\n   *\n   * @default false\n   */\n  singleProcess?: boolean\n\n  /**\n   * If true, the lock will be finalized after the last reader/writer releases\n   * it.\n   *\n   * @default false\n   */\n  autoFinalize?: boolean\n}\n\nexport interface Mortice {\n  /**\n   * Acquire a read lock. Multiple reads will occur simultaneously up to the\n   * concurrency limit passed to the constructor.\n   */\n  readLock(options?: AbortOptions): Promise<Release>\n\n  /**\n   * Acquire a write lock. The write lock will wait for any in-flight reads to\n   * complete, then prevent any further reads or writes until the lock is\n   * released.\n   */\n  writeLock(options?: AbortOptions): Promise<Release>\n\n  /**\n   * Removes this mutex from the global state, after invoking this method it\n   * cannot be used any more.\n   */\n  finalize(): void\n\n  /**\n   * If this is the main thread, the state of the read/write queue may be\n   * inspected here\n   */\n  queue?: Queue\n}\n\nexport interface Release {\n  (): void\n}\n\nconst defaultOptions = {\n  name: 'lock',\n  concurrency: Infinity,\n  singleProcess: false,\n  autoFinalize: false\n}\n\nexport default function createMortice (options?: MorticeOptions): Mortice {\n  const opts: Required<MorticeOptions> = Object.assign({}, defaultOptions, options)\n\n  return createMutex(opts.name, opts)\n}\n", "export const MAX_ADDRESS_AGE = 3_600_000\nexport const MAX_PEER_AGE = 21_600_000\n", "/* eslint-disable complexity */\n\nimport { decodeMessage, encodeMessage, MaxLengthError, MaxSizeError, message } from 'protons-runtime'\nimport { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc'\nimport type { Codec, DecodeOptions } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Peer {\n  addresses: Address[]\n  protocols: string[]\n  publicKey?: Uint8Array\n  peerRecordEnvelope?: Uint8Array\n  metadata: Map<string, Uint8Array>\n  tags: Map<string, Tag>\n  updated?: number\n}\n\nexport namespace Peer {\n  export interface Peer$metadataEntry {\n    key: string\n    value: Uint8Array\n  }\n\n  export namespace Peer$metadataEntry {\n    let _codec: Codec<Peer$metadataEntry>\n\n    export const codec = (): Codec<Peer$metadataEntry> => {\n      if (_codec == null) {\n        _codec = message<Peer$metadataEntry>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if ((obj.key != null && obj.key !== '')) {\n            w.uint32(10)\n            w.string(obj.key)\n          }\n\n          if ((obj.value != null && obj.value.byteLength > 0)) {\n            w.uint32(18)\n            w.bytes(obj.value)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {\n            key: '',\n            value: uint8ArrayAlloc(0)\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                obj.key = reader.string()\n                break\n              }\n              case 2: {\n                obj.value = reader.bytes()\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<Peer$metadataEntry>): Uint8Array => {\n      return encodeMessage(obj, Peer$metadataEntry.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Peer$metadataEntry>): Peer$metadataEntry => {\n      return decodeMessage(buf, Peer$metadataEntry.codec(), opts)\n    }\n  }\n\n  export interface Peer$tagsEntry {\n    key: string\n    value?: Tag\n  }\n\n  export namespace Peer$tagsEntry {\n    let _codec: Codec<Peer$tagsEntry>\n\n    export const codec = (): Codec<Peer$tagsEntry> => {\n      if (_codec == null) {\n        _codec = message<Peer$tagsEntry>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if ((obj.key != null && obj.key !== '')) {\n            w.uint32(10)\n            w.string(obj.key)\n          }\n\n          if (obj.value != null) {\n            w.uint32(18)\n            Tag.codec().encode(obj.value, w)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {\n            key: ''\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                obj.key = reader.string()\n                break\n              }\n              case 2: {\n                obj.value = Tag.codec().decode(reader, reader.uint32(), {\n                  limits: opts.limits?.value\n                })\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<Peer$tagsEntry>): Uint8Array => {\n      return encodeMessage(obj, Peer$tagsEntry.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Peer$tagsEntry>): Peer$tagsEntry => {\n      return decodeMessage(buf, Peer$tagsEntry.codec(), opts)\n    }\n  }\n\n  let _codec: Codec<Peer>\n\n  export const codec = (): Codec<Peer> => {\n    if (_codec == null) {\n      _codec = message<Peer>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.addresses != null) {\n          for (const value of obj.addresses) {\n            w.uint32(10)\n            Address.codec().encode(value, w)\n          }\n        }\n\n        if (obj.protocols != null) {\n          for (const value of obj.protocols) {\n            w.uint32(18)\n            w.string(value)\n          }\n        }\n\n        if (obj.publicKey != null) {\n          w.uint32(34)\n          w.bytes(obj.publicKey)\n        }\n\n        if (obj.peerRecordEnvelope != null) {\n          w.uint32(42)\n          w.bytes(obj.peerRecordEnvelope)\n        }\n\n        if (obj.metadata != null && obj.metadata.size !== 0) {\n          for (const [key, value] of obj.metadata.entries()) {\n            w.uint32(50)\n            Peer.Peer$metadataEntry.codec().encode({ key, value }, w)\n          }\n        }\n\n        if (obj.tags != null && obj.tags.size !== 0) {\n          for (const [key, value] of obj.tags.entries()) {\n            w.uint32(58)\n            Peer.Peer$tagsEntry.codec().encode({ key, value }, w)\n          }\n        }\n\n        if (obj.updated != null) {\n          w.uint32(64)\n          w.uint64Number(obj.updated)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          addresses: [],\n          protocols: [],\n          metadata: new Map<string, Uint8Array>(),\n          tags: new Map<string, undefined>()\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              if (opts.limits?.addresses != null && obj.addresses.length === opts.limits.addresses) {\n                throw new MaxLengthError('Decode error - map field \"addresses\" had too many elements')\n              }\n\n              obj.addresses.push(Address.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.addresses$\n              }))\n              break\n            }\n            case 2: {\n              if (opts.limits?.protocols != null && obj.protocols.length === opts.limits.protocols) {\n                throw new MaxLengthError('Decode error - map field \"protocols\" had too many elements')\n              }\n\n              obj.protocols.push(reader.string())\n              break\n            }\n            case 4: {\n              obj.publicKey = reader.bytes()\n              break\n            }\n            case 5: {\n              obj.peerRecordEnvelope = reader.bytes()\n              break\n            }\n            case 6: {\n              if (opts.limits?.metadata != null && obj.metadata.size === opts.limits.metadata) {\n                throw new MaxSizeError('Decode error - map field \"metadata\" had too many elements')\n              }\n\n              const entry = Peer.Peer$metadataEntry.codec().decode(reader, reader.uint32())\n              obj.metadata.set(entry.key, entry.value)\n              break\n            }\n            case 7: {\n              if (opts.limits?.tags != null && obj.tags.size === opts.limits.tags) {\n                throw new MaxSizeError('Decode error - map field \"tags\" had too many elements')\n              }\n\n              const entry = Peer.Peer$tagsEntry.codec().decode(reader, reader.uint32(), {\n                limits: {\n                  value: opts.limits?.tags$value\n                }\n              })\n              obj.tags.set(entry.key, entry.value)\n              break\n            }\n            case 8: {\n              obj.updated = reader.uint64Number()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Peer>): Uint8Array => {\n    return encodeMessage(obj, Peer.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Peer>): Peer => {\n    return decodeMessage(buf, Peer.codec(), opts)\n  }\n}\n\nexport interface Address {\n  multiaddr: Uint8Array\n  isCertified?: boolean\n  observed?: number\n}\n\nexport namespace Address {\n  let _codec: Codec<Address>\n\n  export const codec = (): Codec<Address> => {\n    if (_codec == null) {\n      _codec = message<Address>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.multiaddr != null && obj.multiaddr.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.multiaddr)\n        }\n\n        if (obj.isCertified != null) {\n          w.uint32(16)\n          w.bool(obj.isCertified)\n        }\n\n        if (obj.observed != null) {\n          w.uint32(24)\n          w.uint64Number(obj.observed)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          multiaddr: uint8ArrayAlloc(0)\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.multiaddr = reader.bytes()\n              break\n            }\n            case 2: {\n              obj.isCertified = reader.bool()\n              break\n            }\n            case 3: {\n              obj.observed = reader.uint64Number()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Address>): Uint8Array => {\n    return encodeMessage(obj, Address.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Address>): Address => {\n    return decodeMessage(buf, Address.codec(), opts)\n  }\n}\n\nexport interface Tag {\n  value: number\n  expiry?: bigint\n}\n\nexport namespace Tag {\n  let _codec: Codec<Tag>\n\n  export const codec = (): Codec<Tag> => {\n    if (_codec == null) {\n      _codec = message<Tag>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.value != null && obj.value !== 0)) {\n          w.uint32(8)\n          w.uint32(obj.value)\n        }\n\n        if (obj.expiry != null) {\n          w.uint32(16)\n          w.uint64(obj.expiry)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          value: 0\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.value = reader.uint32()\n              break\n            }\n            case 2: {\n              obj.expiry = reader.uint64()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Tag>): Uint8Array => {\n    return encodeMessage(obj, Tag.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Tag>): Tag => {\n    return decodeMessage(buf, Tag.codec(), opts)\n  }\n}\n", "import { publicKeyFromProtobuf } from '@libp2p/crypto/keys'\nimport { peerIdFromPublicKey } from '@libp2p/peer-id'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { Peer as PeerPB } from '../pb/peer.js'\nimport type { PeerId, Peer, Tag } from '@libp2p/interface'\nimport type { Digest } from 'multiformats/hashes/digest'\n\nfunction populatePublicKey (peerId: PeerId, protobuf: PeerPB): PeerId {\n  if (peerId.publicKey != null || protobuf.publicKey == null) {\n    return peerId\n  }\n\n  let digest: Digest<18, number> | undefined\n\n  if (peerId.type === 'RSA') {\n    // avoid hashing public key\n    digest = peerId.toMultihash()\n  }\n\n  const publicKey = publicKeyFromProtobuf(protobuf.publicKey, digest)\n  return peerIdFromPublicKey(publicKey)\n}\n\nexport function bytesToPeer (peerId: PeerId, buf: Uint8Array, maxAddressAge: number): Peer {\n  const peer = PeerPB.decode(buf)\n\n  return pbToPeer(peerId, peer, maxAddressAge)\n}\n\nexport function pbToPeer (peerId: PeerId, peer: PeerPB, maxAddressAge: number): Peer {\n  const tags = new Map<string, Tag>()\n\n  // remove any expired tags\n  const now = BigInt(Date.now())\n\n  for (const [key, tag] of peer.tags.entries()) {\n    if (tag.expiry != null && tag.expiry < now) {\n      continue\n    }\n\n    tags.set(key, tag)\n  }\n\n  return {\n    ...peer,\n    id: populatePublicKey(peerId, peer),\n    addresses: peer.addresses\n      // remove any expired multiaddrs\n      .filter(({ observed }) => observed != null && observed > (Date.now() - maxAddressAge))\n      .map(({ multiaddr: ma, isCertified }) => {\n        return {\n          multiaddr: multiaddr(ma),\n          isCertified: isCertified ?? false\n        }\n      }),\n    metadata: peer.metadata,\n    peerRecordEnvelope: peer.peerRecordEnvelope ?? undefined,\n    tags\n  }\n}\n", "import { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport type { Peer, Address, Tag } from '../pb/peer.js'\n\nexport function peerEquals (peerA: Peer, peerB: Peer): boolean {\n  return addressesEqual(peerA.addresses, peerB.addresses) &&\n    protocolsEqual(peerA.protocols, peerB.protocols) &&\n    publicKeyEqual(peerA.publicKey, peerB.publicKey) &&\n    peerRecordEnvelope(peerA.peerRecordEnvelope, peerB.peerRecordEnvelope) &&\n    metadataEqual(peerA.metadata, peerB.metadata) &&\n    tagsEqual(peerA.tags, peerB.tags)\n}\n\nfunction addressesEqual (addressesA: Address[], addressesB: Address[]): boolean {\n  return compareArrays(addressesA, addressesB, (a, b) => {\n    if (a.isCertified !== b.isCertified) {\n      return false\n    }\n\n    if (!uint8ArrayEquals(a.multiaddr, b.multiaddr)) {\n      return false\n    }\n\n    return true\n  })\n}\n\nfunction protocolsEqual (protocolsA: string[], protocolsB: string[]): boolean {\n  return compareArrays(protocolsA, protocolsB, (a, b) => a === b)\n}\n\nfunction publicKeyEqual (publicKeyA?: Uint8Array, publicKeyB?: Uint8Array): boolean {\n  return compareOptionalUint8Arrays(publicKeyA, publicKeyB)\n}\n\nfunction peerRecordEnvelope (envelopeA?: Uint8Array, envelopeB?: Uint8Array): boolean {\n  return compareOptionalUint8Arrays(envelopeA, envelopeB)\n}\n\nfunction metadataEqual (metadataA: Map<string, Uint8Array>, metadataB: Map<string, Uint8Array>): boolean {\n  return compareMaps(metadataA, metadataB, (a, b) => uint8ArrayEquals(a, b))\n}\n\nfunction tagsEqual (metadataA: Map<string, Tag>, metadataB: Map<string, Tag>): boolean {\n  return compareMaps(metadataA, metadataB, (a, b) => a.value === b.value && a.expiry === b.expiry)\n}\n\nfunction compareOptionalUint8Arrays (arrA?: Uint8Array, arrB?: Uint8Array): boolean {\n  if (arrA == null && arrB == null) {\n    return true\n  }\n\n  if (arrA != null && arrB != null) {\n    return uint8ArrayEquals(arrA, arrB)\n  }\n\n  return false\n}\n\nfunction compareArrays <T> (arrA: T[], arrB: T[], compare: (a: T, b: T) => boolean): boolean {\n  if (arrA.length !== arrB.length) {\n    return false\n  }\n\n  for (let i = 0; i < arrA.length; i++) {\n    if (!compare(arrA[i], arrB[i])) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction compareMaps <K, V> (mapA: Map<K, V>, mapB: Map<K, V>, compare: (a: V, b: V) => boolean): boolean {\n  if (mapA.size !== mapB.size) {\n    return false\n  }\n\n  for (const [key, value] of mapA.entries()) {\n    const valueB = mapB.get(key)\n\n    if (valueB == null) {\n      return false\n    }\n\n    if (!compare(value, valueB)) {\n      return false\n    }\n  }\n\n  return true\n}\n", "import { InvalidParametersError, isPeerId } from '@libp2p/interface'\nimport { Key } from 'interface-datastore/key'\nimport type { PeerId } from '@libp2p/interface'\n\nexport const NAMESPACE_COMMON = '/peers/'\n\nexport function peerIdToDatastoreKey (peerId: PeerId): Key {\n  if (!isPeerId(peerId) || peerId.type == null) {\n    throw new InvalidParametersError('Invalid PeerId')\n  }\n\n  const b32key = peerId.toCID().toString()\n  return new Key(`${NAMESPACE_COMMON}${b32key}`)\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { CODE_P2P, isMultiaddr, multiaddr } from '@multiformats/multiaddr'\nimport type { AddressFilter } from '../index.js'\nimport type { Address as AddressPB } from '../pb/peer.js'\nimport type { PeerId, Address, AbortOptions } from '@libp2p/interface'\n\nexport async function dedupeFilterAndSortAddresses (peerId: PeerId, filter: AddressFilter, addresses: Array<Address | AddressPB | undefined>, existingAddresses?: AddressPB[], options?: AbortOptions): Promise<AddressPB[]> {\n  const addressMap = new Map<string, Address>()\n\n  for (const addr of addresses) {\n    if (addr == null) {\n      continue\n    }\n\n    if (addr.multiaddr instanceof Uint8Array) {\n      addr.multiaddr = multiaddr(addr.multiaddr)\n    }\n\n    if (!isMultiaddr(addr.multiaddr)) {\n      throw new InvalidParametersError('Multiaddr was invalid')\n    }\n\n    if (!(await filter(peerId, addr.multiaddr, options))) {\n      continue\n    }\n\n    const isCertified = addr.isCertified ?? false\n    const maStr = addr.multiaddr.toString()\n    const existingAddr = addressMap.get(maStr)\n\n    if (existingAddr != null) {\n      addr.isCertified = existingAddr.isCertified || isCertified\n    } else {\n      addressMap.set(maStr, {\n        multiaddr: addr.multiaddr,\n        isCertified\n      })\n    }\n  }\n\n  return [...addressMap.values()]\n    .sort((a, b) => {\n      return a.multiaddr.toString().localeCompare(b.multiaddr.toString())\n    })\n    .map(({ isCertified, multiaddr: ma }) => {\n      // strip the trailing peerId if it is present\n      const addrPeer = ma.getComponents().find(c => c.code === CODE_P2P)?.value\n\n      if (peerId.equals(addrPeer)) {\n        ma = ma.decapsulate(multiaddr(`/p2p/${peerId}`))\n      }\n\n      return {\n        isCertified,\n        multiaddr: ma.bytes\n      }\n    })\n}\n", "/* eslint-disable complexity */\nimport { publicKeyToProtobuf } from '@libp2p/crypto/keys'\nimport { InvalidParametersError } from '@libp2p/interface'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { dedupeFilterAndSortAddresses } from './dedupe-addresses.js'\nimport type { AddressFilter } from '../index.js'\nimport type { Tag, Peer as PeerPB } from '../pb/peer.js'\nimport type { ExistingPeer } from '../store.js'\nimport type { PeerId, Address, PeerData, TagOptions, AbortOptions } from '@libp2p/interface'\n\nexport interface ToPBPeerOptions extends AbortOptions {\n  addressFilter?: AddressFilter\n  existingPeer?: ExistingPeer\n}\n\nexport async function toPeerPB (peerId: PeerId, data: Partial<PeerData>, strategy: 'merge' | 'patch', options: ToPBPeerOptions): Promise<PeerPB> {\n  if (data == null) {\n    throw new InvalidParametersError('Invalid PeerData')\n  }\n\n  if (data.publicKey != null && peerId.publicKey != null && !data.publicKey.equals(peerId.publicKey)) {\n    throw new InvalidParametersError('publicKey bytes do not match peer id publicKey bytes')\n  }\n\n  const existingPeer = options.existingPeer?.peer\n\n  if (existingPeer != null && !peerId.equals(existingPeer.id)) {\n    throw new InvalidParametersError('peer id did not match existing peer id')\n  }\n\n  let addresses: Address[] = existingPeer?.addresses ?? []\n  let protocols = new Set<string>(existingPeer?.protocols ?? [])\n  let metadata: Map<string, Uint8Array> = existingPeer?.metadata ?? new Map()\n  let tags: Map<string, Tag> = existingPeer?.tags ?? new Map()\n  let peerRecordEnvelope: Uint8Array | undefined = existingPeer?.peerRecordEnvelope\n\n  // when patching, we replace the original fields with passed values\n  if (strategy === 'patch') {\n    if (data.multiaddrs != null || data.addresses != null) {\n      addresses = []\n\n      if (data.multiaddrs != null) {\n        addresses.push(...data.multiaddrs.map(multiaddr => ({\n          isCertified: false,\n          multiaddr\n        })))\n      }\n\n      if (data.addresses != null) {\n        addresses.push(...data.addresses)\n      }\n    }\n\n    if (data.protocols != null) {\n      protocols = new Set(data.protocols)\n    }\n\n    if (data.metadata != null) {\n      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata)\n\n      metadata = createSortedMap(metadataEntries, {\n        validate: validateMetadata\n      })\n    }\n\n    if (data.tags != null) {\n      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags)\n\n      tags = createSortedMap(tagsEntries, {\n        validate: validateTag,\n        map: mapTag\n      })\n    }\n\n    if (data.peerRecordEnvelope != null) {\n      peerRecordEnvelope = data.peerRecordEnvelope\n    }\n  }\n\n  // when merging, we join the original fields with passed values\n  if (strategy === 'merge') {\n    if (data.multiaddrs != null) {\n      addresses.push(...data.multiaddrs.map(multiaddr => ({\n        isCertified: false,\n        multiaddr\n      })))\n    }\n\n    if (data.addresses != null) {\n      addresses.push(...data.addresses)\n    }\n\n    if (data.protocols != null) {\n      protocols = new Set([...protocols, ...data.protocols])\n    }\n\n    if (data.metadata != null) {\n      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata)\n\n      for (const [key, value] of metadataEntries) {\n        if (value == null) {\n          metadata.delete(key)\n        } else {\n          metadata.set(key, value)\n        }\n      }\n\n      metadata = createSortedMap([...metadata.entries()], {\n        validate: validateMetadata\n      })\n    }\n\n    if (data.tags != null) {\n      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags)\n      const mergedTags = new Map<string, Tag | TagOptions>(tags)\n\n      for (const [key, value] of tagsEntries) {\n        if (value == null) {\n          mergedTags.delete(key)\n        } else {\n          mergedTags.set(key, value)\n        }\n      }\n\n      tags = createSortedMap([...mergedTags.entries()], {\n        validate: validateTag,\n        map: mapTag\n      })\n    }\n\n    if (data.peerRecordEnvelope != null) {\n      peerRecordEnvelope = data.peerRecordEnvelope\n    }\n  }\n\n  let publicKey: Uint8Array | undefined\n\n  if (existingPeer?.id.publicKey != null) {\n    publicKey = publicKeyToProtobuf(existingPeer.id.publicKey)\n  } else if (data.publicKey != null) {\n    publicKey = publicKeyToProtobuf(data.publicKey)\n  } else if (peerId.publicKey != null) {\n    publicKey = publicKeyToProtobuf(peerId.publicKey)\n  }\n\n  const output: PeerPB = {\n    addresses: await dedupeFilterAndSortAddresses(\n      peerId,\n      options.addressFilter ?? (async () => true),\n      addresses,\n      options.existingPeer?.peerPB.addresses,\n      options\n    ),\n    protocols: [...protocols.values()].sort((a, b) => {\n      return a.localeCompare(b)\n    }),\n    metadata,\n    tags,\n    publicKey,\n    peerRecordEnvelope\n  }\n\n  // add observed addresses to multiaddrs\n  output.addresses.forEach(addr => {\n    addr.observed = options.existingPeer?.peerPB.addresses?.find(addr => uint8ArrayEquals(addr.multiaddr, addr.multiaddr))?.observed ?? Date.now()\n  })\n\n  // Ed25519 and secp256k1 have their public key embedded in them so no need to duplicate it\n  if (peerId.type !== 'RSA') {\n    delete output.publicKey\n  }\n\n  return output\n}\n\ninterface CreateSortedMapOptions <V, R = V> {\n  validate(key: string, value: V): void\n  map?(key: string, value: V): R\n}\n\n/**\n * In JS maps are ordered by insertion order so create a new map with the\n * keys inserted in alphabetical order.\n */\nfunction createSortedMap <V, R = V> (entries: Array<[string, V | undefined]>, options: CreateSortedMapOptions<V, R>): Map<string, R> {\n  const output = new Map()\n\n  for (const [key, value] of entries) {\n    if (value == null) {\n      continue\n    }\n\n    options.validate(key, value)\n  }\n\n  for (const [key, value] of entries.sort(([a], [b]) => {\n    return a.localeCompare(b)\n  })) {\n    if (value != null) {\n      output.set(key, options.map?.(key, value) ?? value)\n    }\n  }\n\n  return output\n}\n\nfunction validateMetadata (key: string, value: Uint8Array): void {\n  if (typeof key !== 'string') {\n    throw new InvalidParametersError('Metadata key must be a string')\n  }\n\n  if (!(value instanceof Uint8Array)) {\n    throw new InvalidParametersError('Metadata value must be a Uint8Array')\n  }\n}\n\nfunction validateTag (key: string, tag: TagOptions): void {\n  if (typeof key !== 'string') {\n    throw new InvalidParametersError('Tag name must be a string')\n  }\n\n  if (tag.value != null) {\n    if (parseInt(`${tag.value}`, 10) !== tag.value) {\n      throw new InvalidParametersError('Tag value must be an integer')\n    }\n\n    if (tag.value < 0 || tag.value > 100) {\n      throw new InvalidParametersError('Tag value must be between 0-100')\n    }\n  }\n\n  if (tag.ttl != null) {\n    if (parseInt(`${tag.ttl}`, 10) !== tag.ttl) {\n      throw new InvalidParametersError('Tag ttl must be an integer')\n    }\n\n    if (tag.ttl < 0) {\n      throw new InvalidParametersError('Tag ttl must be between greater than 0')\n    }\n  }\n}\n\nfunction mapTag (key: string, tag: any): Tag {\n  let expiry: bigint | undefined\n\n  if (tag.expiry != null) {\n    expiry = tag.expiry\n  }\n\n  if (tag.ttl != null) {\n    expiry = BigInt(Date.now() + Number(tag.ttl))\n  }\n\n  const output: Tag = {\n    value: tag.value ?? 0\n  }\n\n  if (expiry != null) {\n    output.expiry = expiry\n  }\n\n  return output\n}\n", "import { NotFoundError } from '@libp2p/interface'\nimport { PeerMap, trackedPeerMap } from '@libp2p/peer-collections'\nimport { peerIdFromCID } from '@libp2p/peer-id'\nimport mortice from 'mortice'\nimport { base32 } from 'multiformats/bases/base32'\nimport { CID } from 'multiformats/cid'\nimport { MAX_ADDRESS_AGE, MAX_PEER_AGE } from './constants.js'\nimport { Peer as PeerPB } from './pb/peer.js'\nimport { bytesToPeer, pbToPeer } from './utils/bytes-to-peer.js'\nimport { peerEquals } from './utils/peer-equals.js'\nimport { NAMESPACE_COMMON, peerIdToDatastoreKey } from './utils/peer-id-to-datastore-key.js'\nimport { toPeerPB } from './utils/to-peer-pb.js'\nimport type { AddressFilter, PersistentPeerStoreComponents, PersistentPeerStoreInit } from './index.js'\nimport type { PeerUpdate as PeerUpdateExternal, PeerId, Peer, PeerData, PeerQuery, Logger, AbortOptions } from '@libp2p/interface'\nimport type { Datastore, Key, Query } from 'interface-datastore'\nimport type { Mortice, Release } from 'mortice'\n\n/**\n * Event detail emitted when peer data changes\n */\nexport interface PeerUpdate extends PeerUpdateExternal {\n  updated: boolean\n}\n\nexport interface ExistingPeer {\n  peerPB: PeerPB\n  peer: Peer\n}\n\nfunction keyToPeerId (key: Key): PeerId {\n  // /peers/${peer-id-as-libp2p-key-cid-string-in-base-32}\n  const base32Str = key.toString().split('/')[2]\n  const buf = CID.parse(base32Str, base32)\n\n  return peerIdFromCID(buf)\n}\n\nfunction decodePeer (key: Key, value: Uint8Array, maxAddressAge: number): Peer {\n  const peerId = keyToPeerId(key)\n\n  return bytesToPeer(peerId, value, maxAddressAge)\n}\n\nfunction mapQuery (query: PeerQuery, maxAddressAge: number): Query {\n  return {\n    prefix: NAMESPACE_COMMON,\n    filters: (query.filters ?? []).map(fn => ({ key, value }) => {\n      return fn(decodePeer(key, value, maxAddressAge))\n    }),\n    orders: (query.orders ?? []).map(fn => (a, b) => {\n      return fn(decodePeer(a.key, a.value, maxAddressAge), decodePeer(b.key, b.value, maxAddressAge))\n    })\n  }\n}\n\nexport interface Lock {\n  refs: number\n  lock: Mortice\n}\n\nexport class PersistentStore {\n  private readonly peerId: PeerId\n  private readonly datastore: Datastore\n  private locks: PeerMap<Lock>\n  private readonly addressFilter?: AddressFilter\n  private readonly log: Logger\n  private readonly maxAddressAge: number\n  private readonly maxPeerAge: number\n\n  constructor (components: PersistentPeerStoreComponents, init: PersistentPeerStoreInit = {}) {\n    this.log = components.logger.forComponent('libp2p:peer-store')\n    this.peerId = components.peerId\n    this.datastore = components.datastore\n    this.addressFilter = init.addressFilter\n    this.locks = trackedPeerMap({\n      name: 'libp2p_peer_store_locks',\n      metrics: components.metrics\n    })\n    this.maxAddressAge = init.maxAddressAge ?? MAX_ADDRESS_AGE\n    this.maxPeerAge = init.maxPeerAge ?? MAX_PEER_AGE\n  }\n\n  getLock (peerId: PeerId): Lock {\n    let lock = this.locks.get(peerId)\n\n    if (lock == null) {\n      lock = {\n        refs: 0,\n        lock: mortice({\n          name: peerId.toString(),\n          singleProcess: true\n        })\n      }\n\n      this.locks.set(peerId, lock)\n    }\n\n    lock.refs++\n\n    return lock\n  }\n\n  private maybeRemoveLock (peerId: PeerId, lock: Lock): void {\n    lock.refs--\n\n    if (lock.refs === 0) {\n      lock.lock.finalize()\n      this.locks.delete(peerId)\n    }\n  }\n\n  async getReadLock (peerId: PeerId, options?: AbortOptions): Promise<Release> {\n    const lock = this.getLock(peerId)\n\n    try {\n      const release = await lock.lock.readLock(options)\n\n      return () => {\n        release()\n        this.maybeRemoveLock(peerId, lock)\n      }\n    } catch (err) {\n      this.maybeRemoveLock(peerId, lock)\n\n      throw err\n    }\n  }\n\n  async getWriteLock (peerId: PeerId, options?: AbortOptions): Promise<Release> {\n    const lock = this.getLock(peerId)\n\n    try {\n      const release = await lock.lock.writeLock(options)\n\n      return () => {\n        release()\n        this.maybeRemoveLock(peerId, lock)\n      }\n    } catch (err) {\n      this.maybeRemoveLock(peerId, lock)\n\n      throw err\n    }\n  }\n\n  async has (peerId: PeerId, options?: AbortOptions): Promise<boolean> {\n    try {\n      await this.load(peerId, options)\n\n      return true\n    } catch (err: any) {\n      if (err.name !== 'NotFoundError') {\n        throw err\n      }\n    }\n\n    return false\n  }\n\n  async delete (peerId: PeerId, options?: AbortOptions): Promise<void> {\n    if (this.peerId.equals(peerId)) {\n      return\n    }\n\n    await this.datastore.delete(peerIdToDatastoreKey(peerId), options)\n  }\n\n  async load (peerId: PeerId, options?: AbortOptions): Promise<Peer> {\n    const key = peerIdToDatastoreKey(peerId)\n    const buf = await this.datastore.get(key, options)\n    const peer = PeerPB.decode(buf)\n\n    if (this.#peerIsExpired(peerId, peer)) {\n      await this.datastore.delete(key, options)\n      throw new NotFoundError()\n    }\n\n    return pbToPeer(peerId, peer, this.peerId.equals(peerId) ? Infinity : this.maxAddressAge)\n  }\n\n  async save (peerId: PeerId, data: PeerData, options?: AbortOptions): Promise<PeerUpdate> {\n    const existingPeer = await this.#findExistingPeer(peerId, options)\n\n    const peerPb: PeerPB = await toPeerPB(peerId, data, 'patch', {\n      ...options,\n      addressFilter: this.addressFilter\n    })\n\n    return this.#saveIfDifferent(peerId, peerPb, existingPeer)\n  }\n\n  async patch (peerId: PeerId, data: Partial<PeerData>, options?: AbortOptions): Promise<PeerUpdate> {\n    const existingPeer = await this.#findExistingPeer(peerId, options)\n\n    const peerPb: PeerPB = await toPeerPB(peerId, data, 'patch', {\n      ...options,\n      addressFilter: this.addressFilter,\n      existingPeer\n    })\n\n    return this.#saveIfDifferent(peerId, peerPb, existingPeer)\n  }\n\n  async merge (peerId: PeerId, data: PeerData, options?: AbortOptions): Promise<PeerUpdate> {\n    const existingPeer = await this.#findExistingPeer(peerId, options)\n\n    const peerPb: PeerPB = await toPeerPB(peerId, data, 'merge', {\n      addressFilter: this.addressFilter,\n      existingPeer\n    })\n\n    return this.#saveIfDifferent(peerId, peerPb, existingPeer)\n  }\n\n  async * all (options?: PeerQuery): AsyncGenerator<Peer, void, unknown> {\n    for await (const { key, value } of this.datastore.query(mapQuery(options ?? {}, this.maxAddressAge), options)) {\n      const peerId = keyToPeerId(key)\n\n      // skip self peer if present\n      if (peerId.equals(this.peerId)) {\n        continue\n      }\n\n      const peer = PeerPB.decode(value)\n\n      // remove expired peer\n      if (this.#peerIsExpired(peerId, peer)) {\n        await this.datastore.delete(key, options)\n        continue\n      }\n\n      yield pbToPeer(peerId, peer, this.peerId.equals(peerId) ? Infinity : this.maxAddressAge)\n    }\n  }\n\n  async #findExistingPeer (peerId: PeerId, options?: AbortOptions): Promise<ExistingPeer | undefined> {\n    try {\n      const key = peerIdToDatastoreKey(peerId)\n      const buf = await this.datastore.get(key, options)\n      const peerPB = PeerPB.decode(buf)\n\n      // remove expired peer\n      if (this.#peerIsExpired(peerId, peerPB)) {\n        await this.datastore.delete(key, options)\n        throw new NotFoundError()\n      }\n\n      return {\n        peerPB,\n        peer: pbToPeer(peerId, peerPB, this.maxAddressAge)\n      }\n    } catch (err: any) {\n      if (err.name !== 'NotFoundError') {\n        this.log.error('invalid peer data found in peer store - %e', err)\n      }\n    }\n  }\n\n  async #saveIfDifferent (peerId: PeerId, peer: PeerPB, existingPeer?: ExistingPeer, options?: AbortOptions): Promise<PeerUpdate> {\n    // record last update\n    peer.updated = Date.now()\n    const buf = PeerPB.encode(peer)\n\n    await this.datastore.put(peerIdToDatastoreKey(peerId), buf, options)\n\n    return {\n      peer: pbToPeer(peerId, peer, this.maxAddressAge),\n      previous: existingPeer?.peer,\n      updated: existingPeer == null || !peerEquals(peer, existingPeer.peerPB)\n    }\n  }\n\n  #peerIsExpired (peerId: PeerId, peer: PeerPB): boolean {\n    if (peer.updated == null) {\n      return true\n    }\n\n    if (this.peerId.equals(peerId)) {\n      return false\n    }\n\n    const expired = peer.updated < (Date.now() - this.maxPeerAge)\n    const minAddressObserved = Date.now() - this.maxAddressAge\n    const addrs = peer.addresses.filter(addr => {\n      return addr.observed != null && addr.observed > minAddressObserved\n    })\n\n    return expired && addrs.length === 0\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * The peer store is where libp2p stores data about the peers it has encountered on the network.\n */\n\nimport { isPeerId } from '@libp2p/interface'\nimport { peerIdFromCID } from '@libp2p/peer-id'\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record'\nimport all from 'it-all'\nimport { PersistentStore } from './store.js'\nimport type { PeerUpdate } from './store.js'\nimport type { ComponentLogger, Libp2pEvents, Logger, PeerId, PeerStore, Peer, PeerData, PeerQuery, PeerInfo, AbortOptions, ConsumePeerRecordOptions, Metrics } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Datastore } from 'interface-datastore'\nimport type { TypedEventTarget } from 'main-event'\n\nexport interface PersistentPeerStoreComponents {\n  peerId: PeerId\n  datastore: Datastore\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n  metrics?: Metrics\n}\n\n/**\n * Return true to allow storing the passed multiaddr for the passed peer\n */\nexport interface AddressFilter {\n  (peerId: PeerId, multiaddr: Multiaddr, options?: AbortOptions): Promise<boolean> | boolean\n}\n\nexport interface PersistentPeerStoreInit {\n  /**\n   * Used to remove multiaddrs of peers before storing them. The default is to\n   * store all addresses\n   */\n  addressFilter?: AddressFilter\n\n  /**\n   * The multiaddrs for a given peer will expire after this number of ms after\n   * which they must be re-fetched using the peer routing.\n   *\n   * Defaults to one hour.\n   *\n   * @default 3_600_000\n   */\n  maxAddressAge?: number\n\n  /**\n   * Any peer without multiaddrs that has not been updated after this number of\n   * ms will be evicted from the peer store.\n   *\n   * Defaults to six hours.\n   *\n   * @default 21_600_000\n   */\n  maxPeerAge?: number\n}\n\n/**\n * An implementation of PeerStore that stores data in a Datastore\n */\nclass PersistentPeerStore implements PeerStore {\n  private readonly store: PersistentStore\n  private readonly events: TypedEventTarget<Libp2pEvents>\n  private readonly peerId: PeerId\n  private readonly log: Logger\n\n  constructor (components: PersistentPeerStoreComponents, init: PersistentPeerStoreInit = {}) {\n    this.log = components.logger.forComponent('libp2p:peer-store')\n    this.events = components.events\n    this.peerId = components.peerId\n    this.store = new PersistentStore(components, init)\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/peer-store'\n\n  async forEach (fn: (peer: Peer,) => void, query?: PeerQuery): Promise<void> {\n    for await (const peer of this.store.all(query)) {\n      fn(peer)\n    }\n  }\n\n  async all (query?: PeerQuery): Promise<Peer[]> {\n    return all(this.store.all(query))\n  }\n\n  async delete (peerId: PeerId, options?: AbortOptions): Promise<void> {\n    const release = await this.store.getReadLock(peerId, options)\n\n    try {\n      await this.store.delete(peerId, options)\n    } finally {\n      release()\n    }\n  }\n\n  async has (peerId: PeerId, options?: AbortOptions): Promise<boolean> {\n    const release = await this.store.getReadLock(peerId, options)\n\n    try {\n      return await this.store.has(peerId, options)\n    } finally {\n      this.log.trace('has release read lock')\n      release?.()\n    }\n  }\n\n  async get (peerId: PeerId, options?: AbortOptions): Promise<Peer> {\n    const release = await this.store.getReadLock(peerId, options)\n\n    try {\n      return await this.store.load(peerId, options)\n    } finally {\n      release?.()\n    }\n  }\n\n  async getInfo (peerId: PeerId, options?: AbortOptions): Promise<PeerInfo> {\n    const peer = await this.get(peerId, options)\n\n    return {\n      id: peer.id,\n      multiaddrs: peer.addresses.map(({ multiaddr }) => multiaddr)\n    }\n  }\n\n  async save (id: PeerId, data: PeerData, options?: AbortOptions): Promise<Peer> {\n    const release = await this.store.getWriteLock(id, options)\n\n    try {\n      const result = await this.store.save(id, data, options)\n\n      this.#emitIfUpdated(id, result)\n\n      return result.peer\n    } finally {\n      release?.()\n    }\n  }\n\n  async patch (id: PeerId, data: PeerData, options?: AbortOptions): Promise<Peer> {\n    const release = await this.store.getWriteLock(id, options)\n\n    try {\n      const result = await this.store.patch(id, data, options)\n\n      this.#emitIfUpdated(id, result)\n\n      return result.peer\n    } finally {\n      release?.()\n    }\n  }\n\n  async merge (id: PeerId, data: PeerData, options?: AbortOptions): Promise<Peer> {\n    const release = await this.store.getWriteLock(id, options)\n\n    try {\n      const result = await this.store.merge(id, data, options)\n\n      this.#emitIfUpdated(id, result)\n\n      return result.peer\n    } finally {\n      release?.()\n    }\n  }\n\n  async consumePeerRecord (buf: Uint8Array, options?: ConsumePeerRecordOptions): Promise<boolean>\n  async consumePeerRecord (buf: Uint8Array, expectedPeer?: PeerId, options?: AbortOptions): Promise<boolean>\n  async consumePeerRecord (buf: Uint8Array, arg1?: any, arg2?: any): Promise<boolean> {\n    const expectedPeer: PeerId | undefined = isPeerId(arg1) ? arg1 : isPeerId(arg1?.expectedPeer) ? arg1.expectedPeer : undefined\n    const options: AbortOptions | undefined = isPeerId(arg1) ? arg2 : arg1 === undefined ? arg2 : arg1\n\n    const envelope = await RecordEnvelope.openAndCertify(buf, PeerRecord.DOMAIN, options)\n    const peerId = peerIdFromCID(envelope.publicKey.toCID())\n\n    if (expectedPeer?.equals(peerId) === false) {\n      this.log('envelope peer id was not the expected peer id - expected: %p received: %p', expectedPeer, peerId)\n      return false\n    }\n\n    const peerRecord = PeerRecord.createFromProtobuf(envelope.payload)\n    let peer: Peer | undefined\n\n    try {\n      peer = await this.get(peerId, options)\n    } catch (err: any) {\n      if (err.name !== 'NotFoundError') {\n        throw err\n      }\n    }\n\n    // ensure seq is greater than, or equal to, the last received\n    if (peer?.peerRecordEnvelope != null) {\n      const storedEnvelope = RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope)\n      const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload)\n\n      if (storedRecord.seqNumber >= peerRecord.seqNumber) {\n        this.log('sequence number was lower or equal to existing sequence number - stored: %d received: %d', storedRecord.seqNumber, peerRecord.seqNumber)\n        return false\n      }\n    }\n\n    await this.patch(peerRecord.peerId, {\n      peerRecordEnvelope: buf,\n      addresses: peerRecord.multiaddrs.map(multiaddr => ({\n        isCertified: true,\n        multiaddr\n      }))\n    }, options)\n\n    return true\n  }\n\n  #emitIfUpdated (id: PeerId, result: PeerUpdate): void {\n    if (!result.updated) {\n      return\n    }\n\n    if (this.peerId.equals(id)) {\n      this.events.safeDispatchEvent('self:peer:update', { detail: result })\n    } else {\n      this.events.safeDispatchEvent('peer:update', { detail: result })\n    }\n  }\n}\n\nexport function persistentPeerStore (components: PersistentPeerStoreComponents, init: PersistentPeerStoreInit = {}): PeerStore {\n  return new PersistentPeerStore(components, init)\n}\n", "export class OpenFailedError extends Error {\n  static name = 'OpenFailedError'\n  static code = 'ERR_OPEN_FAILED'\n  name = OpenFailedError.name\n  code = OpenFailedError.code\n\n  constructor (message = 'Open failed') {\n    super(message)\n  }\n}\n\nexport class CloseFailedError extends Error {\n  static name = 'CloseFailedError'\n  static code = 'ERR_CLOSE_FAILED'\n  name = CloseFailedError.name\n  code = CloseFailedError.code\n\n  constructor (message = 'Close failed') {\n    super(message)\n  }\n}\n\nexport class PutFailedError extends Error {\n  static name = 'PutFailedError'\n  static code = 'ERR_PUT_FAILED'\n  name = PutFailedError.name\n  code = PutFailedError.code\n\n  constructor (message = 'Put failed') {\n    super(message)\n  }\n}\n\nexport class GetFailedError extends Error {\n  static name = 'GetFailedError'\n  static code = 'ERR_GET_FAILED'\n  name = GetFailedError.name\n  code = GetFailedError.code\n\n  constructor (message = 'Get failed') {\n    super(message)\n  }\n}\n\nexport class DeleteFailedError extends Error {\n  static name = 'DeleteFailedError'\n  static code = 'ERR_DELETE_FAILED'\n  name = DeleteFailedError.name\n  code = DeleteFailedError.code\n\n  constructor (message = 'Delete failed') {\n    super(message)\n  }\n}\n\nexport class HasFailedError extends Error {\n  static name = 'HasFailedError'\n  static code = 'ERR_HAS_FAILED'\n  name = HasFailedError.name\n  code = HasFailedError.code\n\n  constructor (message = 'Has failed') {\n    super(message)\n  }\n}\n\nexport class NotFoundError extends Error {\n  static name = 'NotFoundError'\n  static code = 'ERR_NOT_FOUND'\n  name = NotFoundError.name\n  code = NotFoundError.code\n\n  constructor (message = 'Not Found') {\n    super(message)\n  }\n}\n\nexport class AbortError extends Error {\n  static name = 'AbortError'\n  static code = 'ERR_ABORTED'\n  name = AbortError.name\n  code = AbortError.code\n\n  constructor (message = 'Aborted') {\n    super(message)\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Lets you look at the contents of an async iterator and decide what to do\n *\n * @example\n *\n * ```javascript\n * import peekable from 'it-peekable'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const it = peekable(value)\n *\n * const first = it.peek()\n *\n * console.info(first) // 0\n *\n * it.push(first)\n *\n * console.info([...it])\n * // [ 0, 1, 2, 3, 4 ]\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import peekable from 'it-peekable'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const it = peekable(values())\n *\n * const first = await it.peek()\n *\n * console.info(first) // 0\n *\n * it.push(first)\n *\n * console.info(await all(it))\n * // [ 0, 1, 2, 3, 4 ]\n * ```\n */\n\nexport interface Peek <T> {\n  peek(): IteratorResult<T, undefined>\n}\n\nexport interface AsyncPeek <T> {\n  peek(): Promise<IteratorResult<T, undefined>>\n}\n\nexport interface Push <T> {\n  push(value: T): void\n}\n\nexport type Peekable <T> = Iterable<T> & Peek<T> & Push<T> & Iterator<T>\n\nexport type AsyncPeekable <T> = AsyncIterable<T> & AsyncPeek<T> & Push<T> & AsyncIterator<T>\n\nfunction peekable <T> (iterable: Iterable<T>): Peekable<T>\nfunction peekable <T> (iterable: AsyncIterable<T>): AsyncPeekable<T>\nfunction peekable <T> (iterable: Iterable<T> | AsyncIterable<T>): Peekable<T> | AsyncPeekable<T> {\n  // @ts-expect-error can't use Symbol.asyncIterator to index iterable since it might be Iterable\n  const [iterator, symbol] = iterable[Symbol.asyncIterator] != null\n    // @ts-expect-error can't use Symbol.asyncIterator to index iterable since it might be Iterable\n    ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator]\n    // @ts-expect-error can't use Symbol.iterator to index iterable since it might be AsyncIterable\n    : [iterable[Symbol.iterator](), Symbol.iterator]\n\n  const queue: any[] = []\n\n  // @ts-expect-error can't use symbol to index peekable\n  return {\n    peek: () => {\n      return iterator.next()\n    },\n    push: (value: any) => {\n      queue.push(value)\n    },\n    next: () => {\n      if (queue.length > 0) {\n        return {\n          done: false,\n          value: queue.shift()\n        }\n      }\n\n      return iterator.next()\n    },\n    [symbol] () {\n      return this\n    }\n  }\n}\n\nexport default peekable\n", "/**\n * @packageDocumentation\n *\n * Filter values out of an (async)iterable\n *\n * @example\n *\n * ```javascript\n * import all from 'it-all'\n * import filter from 'it-filter'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const fn = (val, index) => val > 2 // Return boolean to keep item\n *\n * const arr = all(filter(values, fn))\n *\n * console.info(arr) // 3, 4\n * ```\n *\n * Async sources and filter functions must be awaited:\n *\n * ```javascript\n * import all from 'it-all'\n * import filter from 'it-filter'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const fn = async val => (val, index) > 2 // Return boolean or promise of boolean to keep item\n *\n * const arr = await all(filter(values, fn))\n *\n * console.info(arr) // 3, 4\n * ```\n */\n\nimport peek from 'it-peekable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Filters the passed (async) iterable by using the filter function\n */\nfunction filter <T> (source: Iterable<T>, fn: (val: T, index: number) => Promise<boolean>): AsyncGenerator<T, void, undefined>\nfunction filter <T> (source: Iterable<T>, fn: (val: T, index: number) => boolean): Generator<T, void, undefined>\nfunction filter <T> (source: Iterable<T> | AsyncIterable<T>, fn: (val: T, index: number) => boolean | Promise<boolean>): AsyncGenerator<T, void, undefined>\nfunction filter <T> (source: Iterable<T> | AsyncIterable<T>, fn: (val: T, index: number) => boolean | Promise<boolean>): Generator<T, void, undefined> | AsyncGenerator<T, void, undefined> {\n  let index = 0\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const entry of source) {\n        if (await fn(entry, index++)) {\n          yield entry\n        }\n      }\n    })()\n  }\n\n  // if mapping function returns a promise we have to return an async generator\n  const peekable = peek(source)\n  const { value, done } = peekable.next()\n\n  if (done === true) {\n    return (function * () {}())\n  }\n\n  const res = fn(value, index++)\n\n  // @ts-expect-error .then is not present on O\n  if (typeof res.then === 'function') {\n    return (async function * () {\n      if (await res) {\n        yield value\n      }\n\n      for (const entry of peekable) {\n        if (await fn(entry, index++)) {\n          yield entry\n        }\n      }\n    })()\n  }\n\n  const func = fn as (val: T, index: number) => boolean\n\n  return (function * () {\n    if (res === true) {\n      yield value\n    }\n\n    for (const entry of peekable) {\n      if (func(entry, index++)) {\n        yield entry\n      }\n    }\n  })()\n}\n\nexport default filter\n", "/**\n * @packageDocumentation\n *\n * Consumes all values from an (async)iterable and returns them sorted by the passed sort function.\n *\n * @example\n *\n * ```javascript\n * import sort from 'it-sort'\n * import all from 'it-all'\n *\n * const sorter = (a, b) => {\n *   return a.localeCompare(b)\n * }\n *\n * // This can also be an iterator, generator, etc\n * const values = ['foo', 'bar']\n *\n * const arr = all(sort(values, sorter))\n *\n * console.info(arr) // 'bar', 'foo'\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import sort from 'it-sort'\n * import all from 'it-all'\n *\n * const sorter = (a, b) => {\n *   return a.localeCompare(b)\n * }\n *\n * const values = async function * () {\n *   yield * ['foo', 'bar']\n * }\n *\n * const arr = await all(sort(values, sorter))\n *\n * console.info(arr) // 'bar', 'foo'\n * ```\n */\n\nimport all from 'it-all'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\nexport interface CompareFunction<T> {\n  (a: T, b: T): number\n}\n\n/**\n * Collects all values from an async iterator, sorts them\n * using the passed function and yields them\n */\nfunction sort <T> (source: Iterable<T>, sorter: CompareFunction<T>): Generator<T, void, undefined>\nfunction sort <T> (source: Iterable<T> | AsyncIterable<T>, sorter: CompareFunction<T>): AsyncGenerator<T, void, undefined>\nfunction sort <T> (source: Iterable<T> | AsyncIterable<T>, sorter: CompareFunction<T>): AsyncGenerator<T, void, undefined> | Generator<T, void, undefined> {\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      const arr = await all(source)\n\n      yield * arr.sort(sorter)\n    })()\n  }\n\n  return (function * () {\n    const arr = all(source)\n\n    yield * arr.sort(sorter)\n  })()\n}\n\nexport default sort\n", "/**\n * @packageDocumentation\n *\n * For when you only want a few values out of an (async)iterable.\n *\n * @example\n *\n * ```javascript\n * import take from 'it-take'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const arr = all(take(values, 2))\n *\n * console.info(arr) // 0, 1\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import take from 'it-take'\n * import all from 'it-all'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const arr = await all(take(values(), 2))\n *\n * console.info(arr) // 0, 1\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Stop iteration after n items have been received\n */\nfunction take <T> (source: Iterable<T>, limit: number): Generator<T, void, undefined>\nfunction take <T> (source: Iterable<T> | AsyncIterable<T>, limit: number): AsyncGenerator<T, void, undefined>\nfunction take <T> (source: Iterable<T> | AsyncIterable<T>, limit: number): AsyncGenerator<T, void, undefined> | Generator<T, void, undefined> {\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      let items = 0\n\n      if (limit < 1) {\n        return\n      }\n\n      for await (const entry of source) {\n        yield entry\n\n        items++\n\n        if (items === limit) {\n          return\n        }\n      }\n    })()\n  }\n\n  return (function * () {\n    let items = 0\n\n    if (limit < 1) {\n      return\n    }\n\n    for (const entry of source) {\n      yield entry\n\n      items++\n\n      if (items === limit) {\n        return\n      }\n    }\n  })()\n}\n\nexport default take\n", "import drain from 'it-drain'\nimport filter from 'it-filter'\nimport sort from 'it-sort'\nimport take from 'it-take'\nimport type { Batch, Datastore, Key, KeyQuery, Pair, Query } from 'interface-datastore'\nimport type { AbortOptions, Await, AwaitGenerator, AwaitIterable } from 'interface-store'\n\nexport class BaseDatastore implements Datastore {\n  put (key: Key, val: Uint8Array, options?: AbortOptions): Await<Key> {\n    return Promise.reject(new Error('.put is not implemented'))\n  }\n\n  get (key: Key, options?: AbortOptions): Await<Uint8Array> {\n    return Promise.reject(new Error('.get is not implemented'))\n  }\n\n  has (key: Key, options?: AbortOptions): Await<boolean> {\n    return Promise.reject(new Error('.has is not implemented'))\n  }\n\n  delete (key: Key, options?: AbortOptions): Await<void> {\n    return Promise.reject(new Error('.delete is not implemented'))\n  }\n\n  async * putMany (source: AwaitIterable<Pair>, options: AbortOptions = {}): AwaitGenerator<Key> {\n    for await (const { key, value } of source) {\n      await this.put(key, value, options)\n      yield key\n    }\n  }\n\n  async * getMany (source: AwaitIterable<Key>, options: AbortOptions = {}): AwaitGenerator<Pair> {\n    for await (const key of source) {\n      yield {\n        key,\n        value: await this.get(key, options)\n      }\n    }\n  }\n\n  async * deleteMany (source: AwaitIterable<Key>, options: AbortOptions = {}): AwaitGenerator<Key> {\n    for await (const key of source) {\n      await this.delete(key, options)\n      yield key\n    }\n  }\n\n  batch (): Batch {\n    let puts: Pair[] = []\n    let dels: Key[] = []\n\n    return {\n      put (key, value) {\n        puts.push({ key, value })\n      },\n\n      delete (key) {\n        dels.push(key)\n      },\n      commit: async (options) => {\n        await drain(this.putMany(puts, options))\n        puts = []\n        await drain(this.deleteMany(dels, options))\n        dels = []\n      }\n    }\n  }\n\n  /**\n   * Extending classes should override `query` or implement this method\n   */\n  // eslint-disable-next-line require-yield\n  async * _all (q: Query, options?: AbortOptions): AwaitGenerator<Pair> {\n    throw new Error('._all is not implemented')\n  }\n\n  /**\n   * Extending classes should override `queryKeys` or implement this method\n   */\n  // eslint-disable-next-line require-yield\n  async * _allKeys (q: KeyQuery, options?: AbortOptions): AwaitGenerator<Key> {\n    throw new Error('._allKeys is not implemented')\n  }\n\n  query (q: Query, options?: AbortOptions): AwaitGenerator<Pair> {\n    let it = this._all(q, options)\n\n    if (q.prefix != null) {\n      const prefix = q.prefix\n      it = filter(it, (e) => e.key.toString().startsWith(prefix))\n    }\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it)\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sort(it, f), it)\n    }\n\n    if (q.offset != null) {\n      let i = 0\n      const offset = q.offset\n      it = filter(it, () => i++ >= offset)\n    }\n\n    if (q.limit != null) {\n      it = take(it, q.limit)\n    }\n\n    return it\n  }\n\n  queryKeys (q: KeyQuery, options?: AbortOptions): AwaitGenerator<Key> {\n    let it = this._allKeys(q, options)\n\n    if (q.prefix != null) {\n      const prefix = q.prefix\n      it = filter(it, (key) =>\n        key.toString().startsWith(prefix)\n      )\n    }\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it)\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sort(it, f), it)\n    }\n\n    if (q.offset != null) {\n      const offset = q.offset\n      let i = 0\n      it = filter(it, () => i++ >= offset)\n    }\n\n    if (q.limit != null) {\n      it = take(it, q.limit)\n    }\n\n    return it\n  }\n}\n", "import { Key } from 'interface-datastore/key'\nimport { NotFoundError } from 'interface-store'\nimport { BaseDatastore } from './base.js'\nimport type { KeyQuery, Pair, Query } from 'interface-datastore'\nimport type { AbortOptions, Await, AwaitGenerator } from 'interface-store'\n\nexport class MemoryDatastore extends BaseDatastore {\n  private readonly data: Map<string, Uint8Array>\n\n  constructor () {\n    super()\n\n    this.data = new Map()\n  }\n\n  put (key: Key, val: Uint8Array, options?: AbortOptions): Await<Key> {\n    options?.signal?.throwIfAborted()\n\n    this.data.set(key.toString(), val)\n\n    return key\n  }\n\n  get (key: Key, options?: AbortOptions): Await<Uint8Array> {\n    options?.signal?.throwIfAborted()\n\n    const result = this.data.get(key.toString())\n\n    if (result == null) {\n      throw new NotFoundError()\n    }\n\n    return result\n  }\n\n  has (key: Key, options?: AbortOptions): Await<boolean> {\n    options?.signal?.throwIfAborted()\n    return this.data.has(key.toString())\n  }\n\n  delete (key: Key, options?: AbortOptions): Await<void> {\n    options?.signal?.throwIfAborted()\n    this.data.delete(key.toString())\n  }\n\n  * _all (q: Query, options?: AbortOptions): AwaitGenerator<Pair> {\n    options?.signal?.throwIfAborted()\n    for (const [key, value] of this.data.entries()) {\n      yield { key: new Key(key), value }\n      options?.signal?.throwIfAborted()\n    }\n  }\n\n  * _allKeys (q: KeyQuery, options?: AbortOptions): AwaitGenerator<Key> {\n    options?.signal?.throwIfAborted()\n    for (const key of this.data.keys()) {\n      yield new Key(key)\n      options?.signal?.throwIfAborted()\n    }\n  }\n}\n", "import { getNetConfig, isNetworkAddress, isPrivateIp, trackedMap } from '@libp2p/utils'\nimport { CODE_SNI, CODE_TLS, multiaddr } from '@multiformats/multiaddr'\nimport type { AddressManagerComponents, AddressManagerInit } from './index.js'\nimport type { Logger } from '@libp2p/interface'\nimport type { NodeAddress } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nconst MAX_DATE = 8_640_000_000_000_000\n\nexport const defaultValues = {\n  maxObservedAddresses: 10\n}\n\ninterface DNSMapping {\n  domain: string\n  verified: boolean\n  expires: number\n  lastVerified?: number\n}\n\nexport class DNSMappings {\n  private readonly log: Logger\n  private readonly mappings: Map<string, DNSMapping>\n\n  constructor (components: AddressManagerComponents, init: AddressManagerInit = {}) {\n    this.log = components.logger.forComponent('libp2p:address-manager:dns-mappings')\n    this.mappings = trackedMap({\n      name: 'libp2p_address_manager_dns_mappings',\n      metrics: components.metrics\n    })\n  }\n\n  has (ma: Multiaddr): boolean {\n    const config = getNetConfig(ma)\n    let host = config.host\n\n    if ((config.type === 'ip4' || config.type === 'ip6') && config.sni != null) {\n      host = config.sni\n    }\n\n    for (const mapping of this.mappings.values()) {\n      if (mapping.domain === host) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  add (domain: string, addresses: string[]): void {\n    addresses.forEach(ip => {\n      this.log('add DNS mapping %s to %s', ip, domain)\n      // we are only confident if this is an local domain mapping, otherwise\n      // we will require external validation\n      const verified = isPrivateIp(ip) === true\n\n      this.mappings.set(ip, {\n        domain,\n        verified,\n        expires: verified ? MAX_DATE - Date.now() : 0,\n        lastVerified: verified ? MAX_DATE - Date.now() : undefined\n      })\n    })\n  }\n\n  remove (ma: Multiaddr): boolean {\n    const config = getNetConfig(ma)\n\n    if (config.type !== 'ip4' && config.type !== 'ip6') {\n      return false\n    }\n\n    let wasConfident = false\n\n    for (const [ip, mapping] of this.mappings.entries()) {\n      if (mapping.domain === config.sni) {\n        this.log('removing %s to %s DNS mapping %e', ip, mapping.domain)\n        this.mappings.delete(ip)\n        wasConfident = wasConfident || mapping.verified\n      }\n    }\n\n    return wasConfident\n  }\n\n  getAll (addresses: NodeAddress[]): NodeAddress[] {\n    const dnsMappedAddresses: NodeAddress[] = []\n\n    for (let i = 0; i < addresses.length; i++) {\n      const address = addresses[i].multiaddr\n\n      if (!isNetworkAddress(address)) {\n        continue\n      }\n\n      const config = getNetConfig(address)\n\n      for (const [ip, mapping] of this.mappings.entries()) {\n        if (config.host !== ip) {\n          continue\n        }\n\n        // insert SNI tuple after TLS tuple, if one is present\n        const maWithSni = this.maybeAddSNIComponent(address, mapping.domain)\n\n        if (maWithSni != null) {\n          // remove the address and replace it with the version that includes\n          // the SNI tuple\n          addresses.splice(i, 1)\n          i--\n\n          dnsMappedAddresses.push({\n            multiaddr: maWithSni,\n            verified: mapping.verified,\n            type: 'dns-mapping',\n            expires: mapping.expires,\n            lastVerified: mapping.lastVerified\n          })\n        }\n      }\n    }\n\n    return dnsMappedAddresses\n  }\n\n  private maybeAddSNIComponent (ma: Multiaddr, domain: string): Multiaddr | undefined {\n    const components = ma.getComponents()\n\n    for (let j = 0; j < components.length; j++) {\n      if (components[j].code === CODE_TLS && components[j + 1]?.code !== CODE_SNI) {\n        components.splice(j + 1, 0, {\n          name: 'sni',\n          code: CODE_SNI,\n          value: domain\n        })\n\n        return multiaddr(components)\n      }\n    }\n  }\n\n  confirm (ma: Multiaddr, ttl: number): boolean {\n    const config = getNetConfig(ma)\n    let host = config.host\n\n    if ((config.type === 'ip4' || config.type === 'ip6') && config.sni != null) {\n      host = config.sni\n    }\n\n    let startingConfidence = false\n\n    for (const [ip, mapping] of this.mappings.entries()) {\n      if (mapping.domain === host) {\n        this.log('marking %s to %s DNS mapping as verified', ip, mapping.domain)\n        startingConfidence = mapping.verified\n        mapping.verified = true\n        mapping.expires = Date.now() + ttl\n        mapping.lastVerified = Date.now()\n      }\n    }\n\n    return startingConfidence\n  }\n\n  unconfirm (ma: Multiaddr, ttl: number): boolean {\n    const config = getNetConfig(ma)\n\n    if (config.type !== 'ip4' && config.type !== 'ip6') {\n      return false\n    }\n\n    const host = config.sni ?? config.host\n    let wasConfident = false\n\n    for (const [ip, mapping] of this.mappings.entries()) {\n      if (mapping.domain === host) {\n        this.log('removing verification of %s to %s DNS mapping', ip, mapping.domain)\n        wasConfident = wasConfident || mapping.verified\n        mapping.verified = false\n        mapping.expires = Date.now() + ttl\n      }\n    }\n\n    return wasConfident\n  }\n}\n", "import { isIPv4 } from '@chainsafe/is-ip'\nimport { getNetConfig, isNetworkAddress, trackedMap } from '@libp2p/utils'\nimport { CODE_IP4, CODE_IP6, multiaddr } from '@multiformats/multiaddr'\nimport type { AddressManagerComponents, AddressManagerInit } from './index.js'\nimport type { Logger } from '@libp2p/interface'\nimport type { NodeAddress } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport const defaultValues = {\n  maxObservedAddresses: 10\n}\n\ninterface PublicAddressMapping {\n  internalIp: string\n  internalPort: number\n  externalIp: string\n  externalPort: number\n  externalFamily: 4 | 6\n  protocol: 'tcp' | 'udp'\n  verified: boolean\n  expires: number\n  lastVerified?: number\n}\n\nexport class IPMappings {\n  private readonly log: Logger\n  private readonly mappings: Map<string, PublicAddressMapping[]>\n\n  constructor (components: AddressManagerComponents, init: AddressManagerInit = {}) {\n    this.log = components.logger.forComponent('libp2p:address-manager:ip-mappings')\n    this.mappings = trackedMap({\n      name: 'libp2p_address_manager_ip_mappings',\n      metrics: components.metrics\n    })\n  }\n\n  has (ma: Multiaddr): boolean {\n    const config = getNetConfig(ma)\n\n    if (config.type !== 'ip4' && config.type !== 'ip6') {\n      return false\n    }\n\n    for (const mappings of this.mappings.values()) {\n      for (const mapping of mappings) {\n        if (mapping.externalIp === config.host) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n\n  add (internalIp: string, internalPort: number, externalIp: string, externalPort: number = internalPort, protocol: 'tcp' | 'udp' = 'tcp'): void {\n    const key = `${internalIp}-${internalPort}-${protocol}`\n    const mappings = this.mappings.get(key) ?? []\n    const mapping: PublicAddressMapping = {\n      internalIp,\n      internalPort,\n      externalIp,\n      externalPort,\n      externalFamily: isIPv4(externalIp) ? 4 : 6,\n      protocol,\n      verified: false,\n      expires: 0\n    }\n    mappings.push(mapping)\n\n    this.mappings.set(key, mappings)\n  }\n\n  remove (ma: Multiaddr): boolean {\n    const config = getNetConfig(ma)\n\n    if (config.type !== 'ip4' && config.type !== 'ip6') {\n      return false\n    }\n\n    let wasConfident = false\n\n    for (const [key, mappings] of this.mappings.entries()) {\n      for (let i = 0; i < mappings.length; i++) {\n        const mapping = mappings[i]\n\n        if (mapping.externalIp === config.host && mapping.externalPort === config.port && mapping.protocol === config.protocol) {\n          this.log('removing %s:%s to %s:%s %s IP mapping', mapping.externalIp, mapping.externalPort, config.host, config.port, config.protocol)\n\n          wasConfident = wasConfident || mapping.verified\n          mappings.splice(i, 1)\n          i--\n        }\n      }\n\n      if (mappings.length === 0) {\n        this.mappings.delete(key)\n      }\n    }\n\n    return wasConfident\n  }\n\n  getAll (addresses: NodeAddress[]): NodeAddress[] {\n    const ipMappedAddresses: NodeAddress[] = []\n\n    for (const { multiaddr: ma } of addresses) {\n      if (!isNetworkAddress(ma)) {\n        continue\n      }\n\n      const config = getNetConfig(ma)\n\n      if (config.type !== 'ip4' && config.type !== 'ip6') {\n        continue\n      }\n\n      let key: string | undefined\n\n      // see if the internal host/port/protocol tuple has been mapped externally\n      if (config.protocol === 'tcp') {\n        key = `${config.host}-${config.port}-tcp`\n      } else if (config.protocol === 'udp') {\n        key = `${config.host}-${config.port}-udp`\n      }\n\n      if (key == null) {\n        continue\n      }\n\n      const mappings = this.mappings.get(key)\n\n      if (mappings == null) {\n        continue\n      }\n\n      for (const mapping of mappings) {\n        ipMappedAddresses.push({\n          multiaddr: this.maybeOverrideIp(ma, mapping.externalIp, mapping.externalFamily, mapping.protocol, mapping.externalPort),\n          verified: mapping.verified,\n          type: 'ip-mapping',\n          expires: mapping.expires,\n          lastVerified: mapping.lastVerified\n        })\n      }\n    }\n\n    return ipMappedAddresses\n  }\n\n  private maybeOverrideIp (ma: Multiaddr, externalIp: string, externalFamily: number, protocol: 'tcp' | 'udp', externalPort: number): Multiaddr {\n    const components = ma.getComponents()\n\n    const ipIndex = components.findIndex(c => c.code === CODE_IP4 || c.code === CODE_IP6)\n    const portIndex = components.findIndex(c => c.name === protocol)\n\n    if (ipIndex > -1 && portIndex > -1) {\n      components[ipIndex].value = externalIp\n      components[ipIndex].code = externalFamily === 4 ? CODE_IP4 : CODE_IP6\n      components[portIndex].value = `${externalPort}`\n\n      return multiaddr(components)\n    }\n\n    return ma\n  }\n\n  confirm (ma: Multiaddr, ttl: number): boolean {\n    if (!isNetworkAddress(ma)) {\n      return false\n    }\n\n    const config = getNetConfig(ma)\n    let startingConfidence = false\n\n    for (const mappings of this.mappings.values()) {\n      for (const mapping of mappings) {\n        if (mapping.externalIp === config.host) {\n          this.log('marking %s to %s IP mapping as verified', mapping.internalIp, mapping.externalIp)\n          startingConfidence = mapping.verified\n          mapping.verified = true\n          mapping.expires = Date.now() + ttl\n          mapping.lastVerified = Date.now()\n        }\n      }\n    }\n\n    return startingConfidence\n  }\n\n  unconfirm (ma: Multiaddr, ttl: number): boolean {\n    if (!isNetworkAddress(ma)) {\n      return false\n    }\n\n    const config = getNetConfig(ma)\n    let wasConfident = false\n\n    for (const mappings of this.mappings.values()) {\n      for (let i = 0; i < mappings.length; i++) {\n        const mapping = mappings[i]\n\n        if (mapping.externalIp === config.host && mapping.externalPort === config.port && mapping.protocol === config.protocol) {\n          this.log('removing verification of %s:%s to %s:%s %s IP mapping', mapping.externalIp, mapping.externalPort, config.host, config.port, config.protocol)\n\n          wasConfident = wasConfident || mapping.verified\n          mapping.verified = false\n          mapping.expires = Date.now() + ttl\n        }\n      }\n    }\n\n    return wasConfident\n  }\n}\n", "import { isLinkLocal, isPrivate, trackedMap } from '@libp2p/utils'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport type { AddressManagerComponents, AddressManagerInit } from './index.js'\nimport type { Logger } from '@libp2p/interface'\nimport type { NodeAddress } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport const defaultValues = {\n  maxObservedAddresses: 10\n}\n\ninterface ObservedAddressMetadata {\n  verified: boolean\n  expires: number\n  lastVerified?: number\n}\n\nexport class ObservedAddresses {\n  private readonly log: Logger\n  private readonly addresses: Map<string, ObservedAddressMetadata>\n  private readonly maxObservedAddresses: number\n\n  constructor (components: AddressManagerComponents, init: AddressManagerInit = {}) {\n    this.log = components.logger.forComponent('libp2p:address-manager:observed-addresses')\n    this.addresses = trackedMap({\n      name: 'libp2p_address_manager_observed_addresses',\n      metrics: components.metrics\n    })\n    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues.maxObservedAddresses\n  }\n\n  has (ma: Multiaddr): boolean {\n    return this.addresses.has(ma.toString())\n  }\n\n  removePrefixed (prefix: string): void {\n    for (const key of this.addresses.keys()) {\n      if (key.toString().startsWith(prefix)) {\n        this.addresses.delete(key)\n      }\n    }\n  }\n\n  add (ma: Multiaddr): void {\n    if (this.addresses.size === this.maxObservedAddresses) {\n      return\n    }\n\n    if (isPrivate(ma) || isLinkLocal(ma)) {\n      return\n    }\n\n    this.log('adding observed address %a', ma)\n    this.addresses.set(ma.toString(), {\n      verified: false,\n      expires: 0\n    })\n  }\n\n  getAll (): NodeAddress[] {\n    return Array.from(this.addresses)\n      .map(([ma, metadata]) => ({\n        multiaddr: multiaddr(ma),\n        verified: metadata.verified,\n        type: 'observed',\n        expires: metadata.expires,\n        lastVerified: metadata.lastVerified\n      }))\n  }\n\n  remove (ma: Multiaddr): boolean {\n    const startingConfidence = this.addresses.get(ma.toString())?.verified ?? false\n\n    this.log('removing observed address %a', ma)\n    this.addresses.delete(ma.toString())\n\n    return startingConfidence\n  }\n\n  confirm (ma: Multiaddr, ttl: number): boolean {\n    const addrString = ma.toString()\n    const metadata = this.addresses.get(addrString) ?? {\n      verified: false,\n      expires: Date.now() + ttl,\n      lastVerified: Date.now()\n    }\n    const startingConfidence = metadata.verified\n    metadata.verified = true\n    metadata.expires = Date.now() + ttl\n    metadata.lastVerified = Date.now()\n\n    this.log('marking observed address %a as verified', addrString)\n    this.addresses.set(addrString, metadata)\n\n    return startingConfidence\n  }\n}\n", "import { getNetConfig, isNetworkAddress, isPrivate, trackedMap } from '@libp2p/utils'\nimport type { AddressManagerComponents, AddressManagerInit } from './index.js'\nimport type { Logger } from '@libp2p/interface'\nimport type { NodeAddress } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport const defaultValues = {\n  maxObservedAddresses: 10\n}\n\ninterface TransportAddressMetadata {\n  verified: boolean\n  expires: number\n  lastVerified?: number\n}\n\nexport class TransportAddresses {\n  private readonly log: Logger\n  private readonly addresses: Map<string, TransportAddressMetadata>\n  private readonly maxObservedAddresses: number\n\n  constructor (components: AddressManagerComponents, init: AddressManagerInit = {}) {\n    this.log = components.logger.forComponent('libp2p:address-manager:observed-addresses')\n    this.addresses = trackedMap({\n      name: 'libp2p_address_manager_transport_addresses',\n      metrics: components.metrics\n    })\n    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues.maxObservedAddresses\n  }\n\n  get (multiaddr: Multiaddr, ttl: number): NodeAddress {\n    if (isPrivate(multiaddr)) {\n      return {\n        multiaddr,\n        verified: true,\n        type: 'transport',\n        expires: Date.now() + ttl,\n        lastVerified: Date.now()\n      }\n    }\n\n    const key = this.toKey(multiaddr)\n    let metadata = this.addresses.get(key)\n\n    if (metadata == null) {\n      metadata = {\n        verified: !isNetworkAddress(multiaddr),\n        expires: 0\n      }\n\n      this.addresses.set(key, metadata)\n    }\n\n    return {\n      multiaddr,\n      verified: metadata.verified,\n      type: 'transport',\n      expires: metadata.expires,\n      lastVerified: metadata.lastVerified\n    }\n  }\n\n  has (ma: Multiaddr): boolean {\n    const key = this.toKey(ma)\n    return this.addresses.has(key)\n  }\n\n  remove (ma: Multiaddr): boolean {\n    const key = this.toKey(ma)\n    const startingConfidence = this.addresses.get(key)?.verified ?? false\n\n    this.log('removing observed address %a', ma)\n    this.addresses.delete(key)\n\n    return startingConfidence\n  }\n\n  confirm (ma: Multiaddr, ttl: number): boolean {\n    const key = this.toKey(ma)\n    const metadata = this.addresses.get(key) ?? {\n      verified: false,\n      expires: 0,\n      lastVerified: 0\n    }\n\n    const startingConfidence = metadata.verified\n\n    metadata.verified = true\n    metadata.expires = Date.now() + ttl\n    metadata.lastVerified = Date.now()\n\n    this.addresses.set(key, metadata)\n\n    return startingConfidence\n  }\n\n  unconfirm (ma: Multiaddr, ttl: number): boolean {\n    const key = this.toKey(ma)\n    const metadata = this.addresses.get(key) ?? {\n      verified: false,\n      expires: 0\n    }\n\n    const startingConfidence = metadata.verified\n\n    metadata.verified = false\n    metadata.expires = Date.now() + ttl\n\n    this.addresses.set(key, metadata)\n\n    return startingConfidence\n  }\n\n  private toKey (ma: Multiaddr): string {\n    if (!isNetworkAddress(ma)) {\n      return ma.toString()\n    }\n\n    // only works for dns/ip based addresses\n    const config = getNetConfig(ma)\n\n    return `${config.host}-${config.port}-${config.protocol}`\n  }\n}\n", "/* eslint-disable complexity */\nimport { isIPv4 } from '@chainsafe/is-ip'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { debounce, createScalableCuckooFilter, isPrivateIp, getNetConfig, isNetworkAddress, isLoopback } from '@libp2p/utils'\nimport { CODE_P2P, multiaddr } from '@multiformats/multiaddr'\nimport { QUIC_V1, TCP, WebSockets, WebSocketsSecure } from '@multiformats/multiaddr-matcher'\nimport { DNSMappings } from './dns-mappings.js'\nimport { IPMappings } from './ip-mappings.js'\nimport { ObservedAddresses } from './observed-addresses.js'\nimport { TransportAddresses } from './transport-addresses.js'\nimport type { ComponentLogger, Libp2pEvents, Logger, PeerId, PeerStore, Metrics } from '@libp2p/interface'\nimport type { AddressManager as AddressManagerInterface, TransportManager, NodeAddress, ConfirmAddressOptions } from '@libp2p/interface-internal'\nimport type { Filter } from '@libp2p/utils'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { TypedEventTarget } from 'main-event'\n\nconst ONE_MINUTE = 60_000\n\nexport const defaultValues = {\n  maxObservedAddresses: 10,\n  addressVerificationTTL: ONE_MINUTE * 10,\n  addressVerificationRetry: ONE_MINUTE * 5\n}\n\nexport interface AddressManagerInit {\n  /**\n   * Pass an function in this field to override the list of addresses\n   * that are announced to the network\n   */\n  announceFilter?: AddressFilter\n\n  /**\n   * A list of string multiaddrs to listen on\n   */\n  listen?: string[]\n\n  /**\n   * A list of string multiaddrs to use instead of those reported by transports\n   */\n  announce?: string[]\n\n  /**\n   * A list of string multiaddrs string to never announce\n   */\n  noAnnounce?: string[]\n\n  /**\n   * A list of string multiaddrs to add to the list of announced addresses\n   */\n  appendAnnounce?: string[]\n\n  /**\n   * Limits the number of observed addresses we will store\n   */\n  maxObservedAddresses?: number\n\n  /**\n   * How long before each public address should be reverified in ms.\n   *\n   * Requires `@libp2p/autonat` or some other verification method to be\n   * configured.\n   *\n   * @default 600_000\n   */\n  addressVerificationTTL?: number\n\n  /**\n   * After a transport or mapped address has failed to verify, how long to wait\n   * before retrying it in ms\n   *\n   * Requires `@libp2p/autonat` or some other verification method to be\n   * configured.\n   *\n   * @default 300_000\n   */\n  addressVerificationRetry?: number\n}\n\nexport interface AddressManagerComponents {\n  peerId: PeerId\n  transportManager: TransportManager\n  peerStore: PeerStore\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n  metrics?: Metrics\n}\n\n/**\n * A function that takes a list of multiaddrs and returns a list\n * to announce\n */\nexport interface AddressFilter {\n  (addrs: Multiaddr[]): Multiaddr[]\n}\n\nconst defaultAddressFilter = (addrs: Multiaddr[]): Multiaddr[] => addrs\n\n/**\n * If the passed multiaddr contains the passed peer id, remove it\n */\nfunction stripPeerId (ma: Multiaddr, peerId: PeerId): Multiaddr {\n  const observedPeerIdStr = ma.getComponents().findLast(c => c.code === CODE_P2P)?.value\n\n  // strip our peer id if it has been passed\n  if (observedPeerIdStr != null) {\n    const observedPeerId = peerIdFromString(observedPeerIdStr)\n\n    // use same encoding for comparison\n    if (observedPeerId.equals(peerId)) {\n      ma = ma.decapsulate(multiaddr(`/p2p/${peerId.toString()}`))\n    }\n  }\n\n  return ma\n}\n\nexport class AddressManager implements AddressManagerInterface {\n  private readonly log: Logger\n  private readonly components: AddressManagerComponents\n  // this is an array to allow for duplicates, e.g. multiples of `/ip4/0.0.0.0/tcp/0`\n  private readonly listen: string[]\n  private readonly announce: Set<string>\n  private readonly appendAnnounce: Set<string>\n  private readonly announceFilter: AddressFilter\n  private readonly observed: ObservedAddresses\n  private readonly dnsMappings: DNSMappings\n  private readonly ipMappings: IPMappings\n  private readonly transportAddresses: TransportAddresses\n  private readonly observedAddressFilter: Filter\n  private readonly addressVerificationTTL: number\n  private readonly addressVerificationRetry: number\n\n  /**\n   * Responsible for managing the peer addresses.\n   * Peers can specify their listen and announce addresses.\n   * The listen addresses will be used by the libp2p transports to listen for new connections,\n   * while the announce addresses will be used for the peer addresses' to other peers in the network.\n   */\n  constructor (components: AddressManagerComponents, init: AddressManagerInit = {}) {\n    const { listen = [], announce = [], appendAnnounce = [] } = init\n\n    this.components = components\n    this.log = components.logger.forComponent('libp2p:address-manager')\n    this.listen = listen.map(ma => ma.toString())\n    this.announce = new Set(announce.map(ma => ma.toString()))\n    this.appendAnnounce = new Set(appendAnnounce.map(ma => ma.toString()))\n    this.observed = new ObservedAddresses(components, init)\n    this.dnsMappings = new DNSMappings(components, init)\n    this.ipMappings = new IPMappings(components, init)\n    this.transportAddresses = new TransportAddresses(components, init)\n    this.announceFilter = init.announceFilter ?? defaultAddressFilter\n    this.observedAddressFilter = createScalableCuckooFilter(1024)\n    this.addressVerificationTTL = init.addressVerificationTTL ?? defaultValues.addressVerificationTTL\n    this.addressVerificationRetry = init.addressVerificationRetry ?? defaultValues.addressVerificationRetry\n\n    // this method gets called repeatedly on startup when transports start listening so\n    // debounce it so we don't cause multiple self:peer:update events to be emitted\n    this._updatePeerStoreAddresses = debounce(this._updatePeerStoreAddresses.bind(this), 1000)\n\n    // update our stored addresses when new transports listen\n    components.events.addEventListener('transport:listening', () => {\n      this._updatePeerStoreAddresses()\n    })\n    // update our stored addresses when existing transports stop listening\n    components.events.addEventListener('transport:close', () => {\n      this._updatePeerStoreAddresses()\n    })\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/address-manager'\n\n  _updatePeerStoreAddresses (): void {\n    // if announce addresses have been configured, ensure they make it into our peer\n    // record for things like identify\n    const addrs = this.getAddresses()\n      .map(ma => {\n        // strip our peer id if it is present\n        if (ma.getComponents().findLast(c => c.code === CODE_P2P)?.value === this.components.peerId.toString()) {\n          return ma.decapsulate(`/p2p/${this.components.peerId.toString()}`)\n        }\n\n        return ma\n      })\n\n    this.components.peerStore.patch(this.components.peerId, {\n      multiaddrs: addrs\n    })\n      .catch(err => {\n        this.log.error('error updating addresses - %e', err)\n      })\n  }\n\n  /**\n   * Get peer listen multiaddrs\n   */\n  getListenAddrs (): Multiaddr[] {\n    return Array.from(this.listen).map((a) => multiaddr(a))\n  }\n\n  /**\n   * Get peer announcing multiaddrs\n   */\n  getAnnounceAddrs (): Multiaddr[] {\n    return Array.from(this.announce).map((a) => multiaddr(a))\n  }\n\n  /**\n   * Get peer announcing multiaddrs\n   */\n  getAppendAnnounceAddrs (): Multiaddr[] {\n    return Array.from(this.appendAnnounce).map((a) => multiaddr(a))\n  }\n\n  /**\n   * Get observed multiaddrs\n   */\n  getObservedAddrs (): Multiaddr[] {\n    return this.observed.getAll().map(addr => addr.multiaddr)\n  }\n\n  /**\n   * Add peer observed addresses\n   */\n  addObservedAddr (addr: Multiaddr): void {\n    const config = getNetConfig(addr)\n    let socketAddress: string\n\n    switch (config.type) {\n      case 'ip4': {\n        socketAddress = `${config.host}:${config.port}`\n        break\n      }\n      case 'ip6': {\n        socketAddress = `[${config.host}]:${config.port}`\n        break\n      }\n      default: {\n        return\n      }\n    }\n\n    // ignore if this address if it's been observed before\n    if (this.observedAddressFilter.has(socketAddress)) {\n      return\n    }\n\n    this.observedAddressFilter.add(socketAddress)\n\n    addr = stripPeerId(addr, this.components.peerId)\n\n    // ignore observed address if it is an IP mapping\n    if (this.ipMappings.has(addr)) {\n      return\n    }\n\n    // ignore observed address if it is a DNS mapping\n    if (this.dnsMappings.has(addr)) {\n      return\n    }\n\n    this.observed.add(addr)\n  }\n\n  confirmObservedAddr (addr: Multiaddr, options?: ConfirmAddressOptions): void {\n    addr = stripPeerId(addr, this.components.peerId)\n    let startingConfidence = true\n\n    if (options?.type === 'transport' || this.transportAddresses.has(addr)) {\n      const transportStartingConfidence = this.transportAddresses.confirm(addr, options?.ttl ?? this.addressVerificationTTL)\n\n      if (!transportStartingConfidence && startingConfidence) {\n        startingConfidence = false\n      }\n    }\n\n    if (options?.type === 'dns-mapping' || this.dnsMappings.has(addr)) {\n      const dnsMappingStartingConfidence = this.dnsMappings.confirm(addr, options?.ttl ?? this.addressVerificationTTL)\n\n      if (!dnsMappingStartingConfidence && startingConfidence) {\n        startingConfidence = false\n      }\n    }\n\n    if (options?.type === 'ip-mapping' || this.ipMappings.has(addr)) {\n      const ipMappingStartingConfidence = this.ipMappings.confirm(addr, options?.ttl ?? this.addressVerificationTTL)\n\n      if (!ipMappingStartingConfidence && startingConfidence) {\n        startingConfidence = false\n      }\n    }\n\n    if (options?.type === 'observed' || this.observed.has(addr)) {\n      // try to match up observed address with local transport listener\n      if (this.maybeUpgradeToIPMapping(addr)) {\n        this.ipMappings.confirm(addr, options?.ttl ?? this.addressVerificationTTL)\n        startingConfidence = false\n      } else {\n        const observedStartingConfidence = this.observed.confirm(addr, options?.ttl ?? this.addressVerificationTTL)\n\n        if (!observedStartingConfidence && startingConfidence) {\n          startingConfidence = false\n        }\n      }\n    }\n\n    // only trigger the 'self:peer:update' event if our confidence in an address has changed\n    if (!startingConfidence) {\n      this._updatePeerStoreAddresses()\n    }\n  }\n\n  removeObservedAddr (addr: Multiaddr, options?: ConfirmAddressOptions): void {\n    addr = stripPeerId(addr, this.components.peerId)\n\n    let startingConfidence = false\n\n    if (this.observed.has(addr)) {\n      const observedStartingConfidence = this.observed.remove(addr)\n\n      if (!observedStartingConfidence && startingConfidence) {\n        startingConfidence = false\n      }\n    }\n\n    if (this.transportAddresses.has(addr)) {\n      const transportStartingConfidence = this.transportAddresses.unconfirm(addr, options?.ttl ?? this.addressVerificationRetry)\n\n      if (!transportStartingConfidence && startingConfidence) {\n        startingConfidence = false\n      }\n    }\n\n    if (this.dnsMappings.has(addr)) {\n      const dnsMappingStartingConfidence = this.dnsMappings.unconfirm(addr, options?.ttl ?? this.addressVerificationRetry)\n\n      if (!dnsMappingStartingConfidence && startingConfidence) {\n        startingConfidence = false\n      }\n    }\n\n    if (this.ipMappings.has(addr)) {\n      const ipMappingStartingConfidence = this.ipMappings.unconfirm(addr, options?.ttl ?? this.addressVerificationRetry)\n\n      if (!ipMappingStartingConfidence && startingConfidence) {\n        startingConfidence = false\n      }\n    }\n\n    // only trigger the 'self:peer:update' event if our confidence in an address has changed\n    if (startingConfidence) {\n      this._updatePeerStoreAddresses()\n    }\n  }\n\n  getAddresses (): Multiaddr[] {\n    const addresses = new Set<string>()\n\n    const multiaddrs = this.getAddressesWithMetadata()\n      .filter(addr => {\n        if (!addr.verified) {\n          return false\n        }\n\n        const maStr = addr.multiaddr.toString()\n\n        if (addresses.has(maStr)) {\n          return false\n        }\n\n        addresses.add(maStr)\n\n        return true\n      })\n      .map(address => address.multiaddr)\n\n    // filter addressees before returning\n    return this.announceFilter(\n      multiaddrs.map(str => {\n        const ma = multiaddr(str)\n        const lastComponent = ma.getComponents().pop()\n\n        if (lastComponent?.value === this.components.peerId.toString()) {\n          return ma\n        }\n\n        return ma.encapsulate(`/p2p/${this.components.peerId.toString()}`)\n      })\n    )\n  }\n\n  getAddressesWithMetadata (): NodeAddress[] {\n    const announceMultiaddrs = this.getAnnounceAddrs()\n\n    if (announceMultiaddrs.length > 0) {\n      // allow transports to add certhashes and other runtime information\n      this.components.transportManager.getListeners().forEach(listener => {\n        listener.updateAnnounceAddrs(announceMultiaddrs)\n      })\n\n      return announceMultiaddrs.map(multiaddr => ({\n        multiaddr,\n        verified: true,\n        type: 'announce',\n        expires: Date.now() + this.addressVerificationTTL,\n        lastVerified: Date.now()\n      }))\n    }\n\n    let addresses: NodeAddress[] = []\n\n    // add transport addresses\n    addresses = addresses.concat(\n      this.components.transportManager.getAddrs()\n        .map(multiaddr => this.transportAddresses.get(multiaddr, this.addressVerificationTTL))\n    )\n\n    const appendAnnounceMultiaddrs = this.getAppendAnnounceAddrs()\n\n    // add append announce addresses\n    if (appendAnnounceMultiaddrs.length > 0) {\n      // allow transports to add certhashes and other runtime information\n      this.components.transportManager.getListeners().forEach(listener => {\n        listener.updateAnnounceAddrs(appendAnnounceMultiaddrs)\n      })\n\n      addresses = addresses.concat(\n        appendAnnounceMultiaddrs.map(multiaddr => ({\n          multiaddr,\n          verified: true,\n          type: 'announce',\n          expires: Date.now() + this.addressVerificationTTL,\n          lastVerified: Date.now()\n        }))\n      )\n    }\n\n    // add observed addresses\n    addresses = addresses.concat(\n      this.observed.getAll()\n    )\n\n    // add ip mapped addresses\n    addresses = addresses.concat(\n      this.ipMappings.getAll(addresses)\n    )\n\n    // add ip->domain mappings, must be done after IP mappings\n    addresses = addresses.concat(\n      this.dnsMappings.getAll(addresses)\n    )\n\n    return addresses\n  }\n\n  addDNSMapping (domain: string, addresses: string[]): void {\n    this.dnsMappings.add(domain, addresses)\n  }\n\n  removeDNSMapping (domain: string): void {\n    if (this.dnsMappings.remove(multiaddr(`/dns/${domain}`))) {\n      this._updatePeerStoreAddresses()\n    }\n  }\n\n  addPublicAddressMapping (internalIp: string, internalPort: number, externalIp: string, externalPort: number = internalPort, protocol: 'tcp' | 'udp' = 'tcp'): void {\n    this.ipMappings.add(internalIp, internalPort, externalIp, externalPort, protocol)\n\n    // remove duplicate observed addresses\n    this.observed.removePrefixed(`/ip${isIPv4(externalIp) ? 4 : 6}/${externalIp}/${protocol}/${externalPort}`)\n  }\n\n  removePublicAddressMapping (internalIp: string, internalPort: number, externalIp: string, externalPort: number = internalPort, protocol: 'tcp' | 'udp' = 'tcp'): void {\n    if (this.ipMappings.remove(multiaddr(`/ip${isIPv4(externalIp) ? 4 : 6}/${externalIp}/${protocol}/${externalPort}`))) {\n      this._updatePeerStoreAddresses()\n    }\n  }\n\n  /**\n   * Where an external service (router, gateway, etc) is forwarding traffic to\n   * us, attempt to add an IP mapping for the external address - this will\n   * include the observed mapping in the address list where we also have a DNS\n   * mapping for the external IP.\n   *\n   * Returns true if we added a new mapping\n   */\n  private maybeUpgradeToIPMapping (ma: Multiaddr): boolean {\n    // this address is already mapped\n    if (this.ipMappings.has(ma)) {\n      return false\n    }\n\n    if (!isNetworkAddress(ma)) {\n      return false\n    }\n\n    const config = getNetConfig(ma)\n\n    // only public IPv4 addresses\n    if (config.type !== 'ip4' || isPrivateIp(config.host) === true) {\n      return false\n    }\n\n    const listeners = this.components.transportManager.getListeners()\n\n    const transportMatchers: Array<(ma: Multiaddr) => boolean> = [\n      (ma: Multiaddr) => WebSockets.exactMatch(ma) || WebSocketsSecure.exactMatch(ma),\n      (ma: Multiaddr) => TCP.exactMatch(ma),\n      (ma: Multiaddr) => QUIC_V1.exactMatch(ma)\n    ]\n\n    for (const matcher of transportMatchers) {\n      // is the incoming address the same type as the matcher\n      if (!matcher(ma)) {\n        continue\n      }\n\n      // get the listeners for this transport\n      const transportListeners = listeners.filter(listener => {\n        return listener.getAddrs().filter(ma => {\n          // only IPv4 addresses of the matcher type\n          return getNetConfig(ma).type === 'ip4' && matcher(ma)\n        }).length > 0\n      })\n\n      // because the NAT mapping could be forwarding different external ports to\n      // internal ones, we can only be sure enough to add a mapping if there is\n      // a single listener\n      if (transportListeners.length !== 1) {\n        continue\n      }\n\n      // we have one listener which listens on one port so whatever the external\n      // NAT port mapping is, it should be for this listener\n      const linkLocalAddr = transportListeners[0].getAddrs().filter(ma => {\n        return !isLoopback(ma)\n      }).pop()\n\n      if (linkLocalAddr == null) {\n        continue\n      }\n\n      const linkLocalOptions = getNetConfig(linkLocalAddr)\n\n      if (linkLocalOptions.port == null) {\n        return false\n      }\n\n      // upgrade observed address to IP mapping\n      this.observed.remove(ma)\n      this.ipMappings.add(\n        linkLocalOptions.host,\n        linkLocalOptions.port,\n        config.host,\n        config.port,\n        config.protocol\n      )\n\n      return true\n    }\n\n    return false\n  }\n}\n", "export enum messages {\n  NOT_STARTED_YET = 'The libp2p node is not started yet',\n  NOT_FOUND = 'Not found'\n}\n\nexport class MissingServiceError extends Error {\n  constructor (message = 'Missing service') {\n    super(message)\n    this.name = 'MissingServiceError'\n  }\n}\n\nexport class UnmetServiceDependenciesError extends Error {\n  constructor (message = 'Unmet service dependencies') {\n    super(message)\n    this.name = 'UnmetServiceDependenciesError'\n  }\n}\n\nexport class NoContentRoutersError extends Error {\n  constructor (message = 'No content routers available') {\n    super(message)\n    this.name = 'NoContentRoutersError'\n  }\n}\n\nexport class NoPeerRoutersError extends Error {\n  constructor (message = 'No peer routers available') {\n    super(message)\n    this.name = 'NoPeerRoutersError'\n  }\n}\n\nexport class QueriedForSelfError extends Error {\n  constructor (message = 'Should not try to find self') {\n    super(message)\n    this.name = 'QueriedForSelfError'\n  }\n}\n\nexport class UnhandledProtocolError extends Error {\n  constructor (message = 'Unhandled protocol error') {\n    super(message)\n    this.name = 'UnhandledProtocolError'\n  }\n}\n\nexport class DuplicateProtocolHandlerError extends Error {\n  constructor (message = 'Duplicate protocol handler error') {\n    super(message)\n    this.name = 'DuplicateProtocolHandlerError'\n  }\n}\n\nexport class DialDeniedError extends Error {\n  constructor (message = 'Dial denied error') {\n    super(message)\n    this.name = 'DialDeniedError'\n  }\n}\n\nexport class UnsupportedListenAddressError extends Error {\n  constructor (message = 'No transport was configured to listen on this address') {\n    super(message)\n    this.name = 'UnsupportedListenAddressError'\n  }\n}\n\nexport class UnsupportedListenAddressesError extends Error {\n  constructor (message = 'Configured listen addresses could not be listened on') {\n    super(message)\n    this.name = 'UnsupportedListenAddressesError'\n  }\n}\n\nexport class NoValidAddressesError extends Error {\n  constructor (message = 'No valid addresses') {\n    super(message)\n    this.name = 'NoValidAddressesError'\n  }\n}\n\nexport class ConnectionInterceptedError extends Error {\n  constructor (message = 'Connection intercepted') {\n    super(message)\n    this.name = 'ConnectionInterceptedError'\n  }\n}\n\nexport class ConnectionDeniedError extends Error {\n  constructor (message = 'Connection denied') {\n    super(message)\n    this.name = 'ConnectionDeniedError'\n  }\n}\n\nexport class MuxerUnavailableError extends Error {\n  constructor (message = 'Stream is not multiplexed') {\n    super(message)\n    this.name = 'MuxerUnavailableError'\n  }\n}\n\nexport class EncryptionFailedError extends Error {\n  constructor (message = 'Encryption failed') {\n    super(message)\n    this.name = 'EncryptionFailedError'\n  }\n}\n\nexport class TransportUnavailableError extends Error {\n  constructor (message = 'Transport unavailable') {\n    super(message)\n    this.name = 'TransportUnavailableError'\n  }\n}\n\nexport class RecursionLimitError extends Error {\n  constructor (message = 'Max recursive depth reached') {\n    super(message)\n    this.name = 'RecursionLimitError'\n  }\n}\n", "import { serviceCapabilities, serviceDependencies, isStartable } from '@libp2p/interface'\nimport { defaultLogger } from '@libp2p/logger'\nimport { MissingServiceError, UnmetServiceDependenciesError } from './errors.js'\nimport type { Startable, Libp2pEvents, ComponentLogger, NodeInfo, ConnectionProtector, ConnectionGater, ContentRouting, Metrics, PeerId, PeerRouting, PeerStore, PrivateKey, Upgrader } from '@libp2p/interface'\nimport type { AddressManager, ConnectionManager, RandomWalk, Registrar, TransportManager } from '@libp2p/interface-internal'\nimport type { DNS } from '@multiformats/dns'\nimport type { Datastore } from 'interface-datastore'\nimport type { TypedEventTarget } from 'main-event'\n\nexport interface Components extends Record<string, any>, Startable {\n  peerId: PeerId\n  privateKey: PrivateKey\n  nodeInfo: NodeInfo\n  logger: ComponentLogger\n  events: TypedEventTarget<Libp2pEvents>\n  addressManager: AddressManager\n  peerStore: PeerStore\n  upgrader: Upgrader\n  randomWalk: RandomWalk\n  registrar: Registrar\n  connectionManager: ConnectionManager\n  transportManager: TransportManager\n  connectionGater: ConnectionGater\n  contentRouting: ContentRouting\n  peerRouting: PeerRouting\n  datastore: Datastore\n  connectionProtector?: ConnectionProtector\n  metrics?: Metrics\n  dns?: DNS\n}\n\nexport interface ComponentsInit {\n  peerId?: PeerId\n  privateKey?: PrivateKey\n  nodeInfo?: NodeInfo\n  logger?: ComponentLogger\n  events?: TypedEventTarget<Libp2pEvents>\n  addressManager?: AddressManager\n  peerStore?: PeerStore\n  upgrader?: Upgrader\n  randomWalk?: RandomWalk\n  metrics?: Metrics\n  registrar?: Registrar\n  connectionManager?: ConnectionManager\n  transportManager?: TransportManager\n  connectionGater?: ConnectionGater\n  contentRouting?: ContentRouting\n  peerRouting?: PeerRouting\n  datastore?: Datastore\n  connectionProtector?: ConnectionProtector\n  dns?: DNS\n}\n\nclass DefaultComponents implements Startable {\n  public components: Record<string, any> = {}\n  private _started = false\n\n  constructor (init: ComponentsInit = {}) {\n    this.components = {}\n\n    for (const [key, value] of Object.entries(init)) {\n      this.components[key] = value\n    }\n\n    if (this.components.logger == null) {\n      this.components.logger = defaultLogger()\n    }\n  }\n\n  isStarted (): boolean {\n    return this._started\n  }\n\n  private async _invokeStartableMethod (methodName: 'beforeStart' | 'start' | 'afterStart' | 'beforeStop' | 'stop' | 'afterStop'): Promise<void> {\n    await Promise.all(\n      Object.values(this.components)\n        .filter(obj => isStartable(obj))\n        .map(async (startable: Startable) => {\n          await startable[methodName]?.()\n        })\n    )\n  }\n\n  async beforeStart (): Promise<void> {\n    await this._invokeStartableMethod('beforeStart')\n  }\n\n  async start (): Promise<void> {\n    await this._invokeStartableMethod('start')\n    this._started = true\n  }\n\n  async afterStart (): Promise<void> {\n    await this._invokeStartableMethod('afterStart')\n  }\n\n  async beforeStop (): Promise<void> {\n    await this._invokeStartableMethod('beforeStop')\n  }\n\n  async stop (): Promise<void> {\n    await this._invokeStartableMethod('stop')\n    this._started = false\n  }\n\n  async afterStop (): Promise<void> {\n    await this._invokeStartableMethod('afterStop')\n  }\n}\n\nconst OPTIONAL_SERVICES = [\n  'metrics',\n  'connectionProtector',\n  'dns'\n]\n\nconst NON_SERVICE_PROPERTIES = [\n  'components',\n  'isStarted',\n  'beforeStart',\n  'start',\n  'afterStart',\n  'beforeStop',\n  'stop',\n  'afterStop',\n  'then',\n  '_invokeStartableMethod'\n]\n\nexport function defaultComponents (init: ComponentsInit = {}): Components {\n  const components = new DefaultComponents(init)\n\n  const proxy = new Proxy(components, {\n    get (target, prop, receiver) {\n      if (typeof prop === 'string' && !NON_SERVICE_PROPERTIES.includes(prop)) {\n        const service = components.components[prop]\n\n        if (service == null && !OPTIONAL_SERVICES.includes(prop)) {\n          throw new MissingServiceError(`${prop} not set`)\n        }\n\n        return service\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n\n    set (target, prop, value) {\n      if (typeof prop === 'string') {\n        components.components[prop] = value\n      } else {\n        Reflect.set(target, prop, value)\n      }\n\n      return true\n    }\n  })\n\n  // @ts-expect-error component keys are proxied\n  return proxy\n}\n\nexport function checkServiceDependencies (components: Components): void {\n  const serviceCapabilities: Record<string, ConstrainBoolean> = {}\n\n  for (const service of Object.values(components.components)) {\n    for (const capability of getServiceCapabilities(service)) {\n      serviceCapabilities[capability] = true\n    }\n  }\n\n  for (const service of Object.values(components.components)) {\n    for (const capability of getServiceDependencies(service)) {\n      if (serviceCapabilities[capability] !== true) {\n        throw new UnmetServiceDependenciesError(`Service \"${getServiceName(service)}\" required capability \"${capability}\" but it was not provided by any component, you may need to add additional configuration when creating your node.`)\n      }\n    }\n  }\n}\n\nfunction getServiceCapabilities (service: any): string[] {\n  if (Array.isArray(service?.[serviceCapabilities])) {\n    return service[serviceCapabilities]\n  }\n\n  return []\n}\n\nfunction getServiceDependencies (service: any): string[] {\n  if (Array.isArray(service?.[serviceDependencies])) {\n    return service[serviceDependencies]\n  }\n\n  return []\n}\n\nfunction getServiceName (service: any): string {\n  return service?.[Symbol.toStringTag] ?? service?.toString() ?? 'unknown'\n}\n", "import { isPrivate } from '@libp2p/utils'\nimport { WebSockets } from '@multiformats/multiaddr-matcher'\nimport type { ConnectionGater } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\n/**\n * Returns a connection gater that disallows dialling private addresses or\n * insecure websockets by default.\n *\n * Browsers are severely limited in their resource usage so don't waste time\n * trying to dial undialable addresses, and they also print verbose error\n * messages when making connections over insecure transports which causes\n * confusion.\n */\nexport function connectionGater (gater: ConnectionGater = {}): ConnectionGater {\n  if (gater.denyDialMultiaddr == null) {\n    gater.denyDialMultiaddr = (multiaddr: Multiaddr) => {\n      // do not connect to insecure websockets by default\n      if (WebSockets.matches(multiaddr)) {\n        return true\n      }\n\n      // do not connect to private addresses by default\n      return isPrivate(multiaddr)\n    }\n  }\n\n  return gater\n}\n", "import { InvalidMultiaddrError, InvalidParametersError, isPeerId } from '@libp2p/interface'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { CODE_P2P, isMultiaddr } from '@multiformats/multiaddr'\nimport { PEER_ID } from '@multiformats/multiaddr-matcher'\nimport type { PeerId } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport interface PeerAddress {\n  peerId?: PeerId\n  multiaddrs: Multiaddr[]\n}\n\n/**\n * Extracts a PeerId and/or multiaddr from the passed PeerId or Multiaddr or an\n * array of Multiaddrs\n */\nexport function getPeerAddress (peer: PeerId | Multiaddr | Multiaddr[]): PeerAddress {\n  if (isPeerId(peer)) {\n    return { peerId: peer, multiaddrs: [] }\n  }\n\n  let multiaddrs = Array.isArray(peer) ? peer : [peer]\n\n  let peerId: PeerId | undefined\n\n  if (multiaddrs.length > 0) {\n    const peerIdStr = multiaddrs[0].getComponents().findLast(c => c.code === CODE_P2P)?.value\n    peerId = peerIdStr == null ? undefined : peerIdFromString(peerIdStr)\n\n    // ensure PeerId is either not set or is consistent\n    multiaddrs.forEach(ma => {\n      if (!isMultiaddr(ma)) {\n        throw new InvalidMultiaddrError('Invalid multiaddr')\n      }\n\n      const maPeerIdStr = ma.getComponents().findLast(c => c.code === CODE_P2P)?.value\n\n      if (maPeerIdStr == null) {\n        if (peerId != null) {\n          throw new InvalidParametersError('Multiaddrs must all have the same peer id or have no peer id')\n        }\n      } else {\n        const maPeerId = peerIdFromString(maPeerIdStr)\n\n        if (peerId?.equals(maPeerId) !== true) {\n          throw new InvalidParametersError('Multiaddrs must all have the same peer id or have no peer id')\n        }\n      }\n    })\n  }\n\n  // ignore any `/p2p/Qmfoo`-style addresses as we will include the peer id in\n  // the returned value of this function\n  multiaddrs = multiaddrs.filter(ma => {\n    return !PEER_ID.exactMatch(ma)\n  })\n\n  return {\n    peerId,\n    multiaddrs\n  }\n}\n", "import { IpNet } from '@chainsafe/netmask'\nimport { InvalidParametersError } from '@libp2p/interface'\nimport { getNetConfig } from '@libp2p/utils'\nimport { Circuit } from '@multiformats/multiaddr-matcher'\nimport type { Connection, AbortOptions, PeerId } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\n/**\n * These are speculative protocols that are run automatically on connection open\n * so are usually not the reason the connection was opened.\n *\n * Consequently when requested it should be safe to close connections that only\n * have these protocol streams open.\n */\nconst DEFAULT_CLOSABLE_PROTOCOLS = [\n  // identify\n  '/ipfs/id/1.0.0',\n\n  // identify-push\n  '/ipfs/id/push/1.0.0',\n\n  // autonat\n  '/libp2p/autonat/1.0.0',\n\n  // dcutr\n  '/libp2p/dcutr'\n]\n\nexport interface SafelyCloseConnectionOptions extends AbortOptions {\n  /**\n   * Only close the stream if it either has no protocol streams open or only\n   * ones in this list.\n   *\n   * @default ['/ipfs/id/1.0.0']\n   */\n  closableProtocols?: string[]\n}\n\n/**\n * Close the passed connection if it has no streams, or only closable protocol\n * streams, falling back to aborting the connection if closing it cleanly fails.\n */\nexport async function safelyCloseConnectionIfUnused (connection?: Connection, options?: SafelyCloseConnectionOptions): Promise<void> {\n  const streamProtocols = connection?.streams?.map(stream => stream.protocol) ?? []\n  const closableProtocols = options?.closableProtocols ?? DEFAULT_CLOSABLE_PROTOCOLS\n\n  // if the connection has protocols not in the closable protocols list, do not\n  // close the connection\n  if (streamProtocols.filter(proto => proto != null && !closableProtocols.includes(proto)).length > 0) {\n    return\n  }\n\n  try {\n    await connection?.close(options)\n  } catch (err: any) {\n    connection?.abort(err)\n  }\n}\n\n/**\n * Converts a multiaddr string or object to an IpNet object.\n * If the multiaddr doesn't include /ipcidr, it will encapsulate with the appropriate CIDR:\n * - /ipcidr/32 for IPv4\n * - /ipcidr/128 for IPv6\n *\n * @param {string | Multiaddr} ma - The multiaddr object to convert.\n * @returns {IpNet} The converted IpNet object.\n * @throws {Error} Throws an error if the multiaddr is not valid.\n */\nexport function multiaddrToIpNet (ma: Multiaddr): IpNet {\n  const config = getNetConfig(ma)\n  let mask = config.cidr\n\n  if (config.type !== 'ip4' && config.type !== 'ip6') {\n    throw new InvalidParametersError(`Multiaddr ${ma} was not an IPv4 or IPv6 address`)\n  }\n\n  // Check if /ipcidr is already present\n  if (mask == null) {\n    switch (config.type) {\n      case 'ip4': {\n        mask = 32\n        break\n      }\n      case 'ip6': {\n        mask = 128\n        break\n      }\n      default: {\n        throw new InvalidParametersError(`Multiaddr ${ma} was not an IPv4 or IPv6 address`)\n      }\n    }\n  }\n\n  return new IpNet(config.host, mask)\n}\n\n/**\n * Returns true if the passed multiaddr would result in a direct connection to\n * the peer.\n *\n * Currently only circuit relay addresses are supported as indirect connections.\n */\nexport function isDirect (ma: Multiaddr): boolean {\n  return !Circuit.exactMatch(ma)\n}\n\n/**\n * If there is an existing non-limited connection to the remote peer return it,\n * unless it is indirect and at least one of the passed dial addresses would\n * result in a direct connection\n */\nexport function findExistingConnection (peerId?: PeerId, connections?: Connection[], dialAddresses?: Multiaddr[]): Connection | undefined {\n  if (peerId == null || connections == null) {\n    return\n  }\n\n  const existingConnection = connections\n    .sort((a, b) => {\n      if (a.direct) {\n        return -1\n      }\n\n      if (b.direct) {\n        return 1\n      }\n\n      return 0\n    })\n    .find(con => con.limits == null)\n\n  if (existingConnection == null || existingConnection.direct || dialAddresses == null) {\n    return existingConnection\n  }\n\n  // we have an indirect, but unlimited connection - test the dial addresses to\n  // see if any of them would result in a direct connection, in which case allow\n  // the attempt to upgrade to a direct connection\n  const wouldUpgradeToDirect = dialAddresses.some(ma => isDirect(ma))\n\n  if (wouldUpgradeToDirect) {\n    return\n  }\n\n  return existingConnection\n}\n", "import { PeerMap } from '@libp2p/peer-collections'\nimport { getNetConfig, isNetworkAddress } from '@libp2p/utils'\nimport { multiaddrToIpNet, safelyCloseConnectionIfUnused } from './utils.js'\nimport type { IpNet } from '@chainsafe/netmask'\nimport type { Libp2pEvents, Logger, ComponentLogger, PeerStore, Connection } from '@libp2p/interface'\nimport type { ConnectionManager } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { TypedEventTarget } from 'main-event'\n\ninterface ConnectionPrunerInit {\n  allow?: Multiaddr[]\n}\n\ninterface ConnectionPrunerComponents {\n  connectionManager: ConnectionManager\n  peerStore: PeerStore\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\n/**\n * If we go over the max connections limit, choose some connections to close\n */\nexport class ConnectionPruner {\n  private readonly connectionManager: ConnectionManager\n  private readonly peerStore: PeerStore\n  private readonly allow: IpNet[]\n  private readonly events: TypedEventTarget<Libp2pEvents>\n  private readonly log: Logger\n\n  constructor (components: ConnectionPrunerComponents, init: ConnectionPrunerInit = {}) {\n    this.allow = (init.allow ?? []).map(ma => multiaddrToIpNet(ma))\n    this.connectionManager = components.connectionManager\n    this.peerStore = components.peerStore\n    this.events = components.events\n    this.log = components.logger.forComponent('libp2p:connection-manager:connection-pruner')\n    this.maybePruneConnections = this.maybePruneConnections.bind(this)\n  }\n\n  start (): void {\n    this.events.addEventListener('connection:open', this.maybePruneConnections)\n  }\n\n  stop (): void {\n    this.events.removeEventListener('connection:open', this.maybePruneConnections)\n  }\n\n  maybePruneConnections (): void {\n    this._maybePruneConnections()\n      .catch(err => {\n        this.log.error('error while pruning connections - %e', err)\n      })\n  }\n\n  /**\n   * If we have more connections than our maximum, select some excess connections\n   * to prune based on peer value\n   */\n  private async _maybePruneConnections (): Promise<void> {\n    const connections = this.connectionManager.getConnections()\n    const numConnections = connections.length\n    const maxConnections = this.connectionManager.getMaxConnections()\n\n    this.log('checking max connections limit %d/%d', numConnections, maxConnections)\n\n    if (numConnections <= maxConnections) {\n      return\n    }\n\n    const peerValues = new PeerMap<number>()\n\n    // work out peer values\n    for (const connection of connections) {\n      const remotePeer = connection.remotePeer\n\n      if (peerValues.has(remotePeer)) {\n        continue\n      }\n\n      peerValues.set(remotePeer, 0)\n\n      try {\n        const peer = await this.peerStore.get(remotePeer)\n\n        // sum all tag values\n        peerValues.set(remotePeer, [...peer.tags.values()].reduce((acc, curr) => {\n          return acc + curr.value\n        }, 0))\n      } catch (err: any) {\n        if (err.name !== 'NotFoundError') {\n          this.log.error('error loading peer tags - %e', err)\n        }\n      }\n    }\n\n    const sortedConnections = this.sortConnections(connections, peerValues)\n\n    // close some connections\n    const toPrune = Math.max(numConnections - maxConnections, 0)\n    const toClose = []\n\n    for (const connection of sortedConnections) {\n      this.log('too many connections open - closing a connection to %p', connection.remotePeer)\n      // check allow list\n      const connectionInAllowList = this.allow.some((ipNet) => {\n        if (isNetworkAddress(connection.remoteAddr)) {\n          const config = getNetConfig(connection.remoteAddr)\n          return ipNet.contains(config.host)\n        }\n\n        return true\n      })\n\n      // Connections in the allow list should be excluded from pruning\n      if (!connectionInAllowList) {\n        toClose.push(connection)\n      }\n\n      if (toClose.length === toPrune) {\n        break\n      }\n    }\n\n    // close connections\n    await Promise.all(\n      toClose.map(async connection => {\n        await safelyCloseConnectionIfUnused(connection, {\n          signal: AbortSignal.timeout(1000)\n        })\n      })\n    )\n\n    // despatch prune event\n    this.events.safeDispatchEvent('connection:prune', { detail: toClose })\n  }\n\n  sortConnections (connections: Connection[], peerValues: PeerMap<number>): Connection[] {\n    return connections\n      // sort by connection age, newest to oldest\n      .sort((a, b) => {\n        const connectionALifespan = a.timeline.open\n        const connectionBLifespan = b.timeline.open\n\n        if (connectionALifespan < connectionBLifespan) {\n          return 1\n        }\n\n        if (connectionALifespan > connectionBLifespan) {\n          return -1\n        }\n\n        return 0\n      })\n      // sort by direction, incoming first then outgoing\n      .sort((a, b) => {\n        if (a.direction === 'outbound' && b.direction === 'inbound') {\n          return 1\n        }\n\n        if (a.direction === 'inbound' && b.direction === 'outbound') {\n          return -1\n        }\n\n        return 0\n      })\n      // sort by number of streams, lowest to highest\n      .sort((a, b) => {\n        if (a.streams.length > b.streams.length) {\n          return 1\n        }\n\n        if (a.streams.length < b.streams.length) {\n          return -1\n        }\n\n        return 0\n      })\n      // sort by tag value, lowest to highest\n      .sort((a, b) => {\n        const peerAValue = peerValues.get(a.remotePeer) ?? 0\n        const peerBValue = peerValues.get(b.remotePeer) ?? 0\n\n        if (peerAValue > peerBValue) {\n          return 1\n        }\n\n        if (peerAValue < peerBValue) {\n          return -1\n        }\n\n        return 0\n      })\n  }\n}\n", "/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#dialTimeout\n */\nexport const DIAL_TIMEOUT = 10_000\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#connectionCloseTimeout\n */\nexport const CONNECTION_CLOSE_TIMEOUT = 1_000\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#inboundUpgradeTimeout\n */\nexport const INBOUND_UPGRADE_TIMEOUT = 10_000\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#protocolNegotiationTimeout\n */\nexport const PROTOCOL_NEGOTIATION_TIMEOUT = 10_000\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxPeerAddrsToDial\n */\nexport const MAX_PEER_ADDRS_TO_DIAL = 25\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#inboundConnectionThreshold\n */\nexport const INBOUND_CONNECTION_THRESHOLD = 5\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxIncomingPendingConnections\n */\nexport const MAX_INCOMING_PENDING_CONNECTIONS = 10\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxParallelReconnects\n */\nexport const MAX_PARALLEL_RECONNECTS = 5\n\n/**\n * Store as part of the peer store metadata for a given peer, the value for this\n * key is a timestamp of the last time a dial attempt failed with the timestamp\n * stored as a string.\n *\n * Used to insure we do not endlessly try to auto dial peers we have recently\n * failed to dial.\n */\nexport const LAST_DIAL_FAILURE_KEY = 'last-dial-failure'\n\n/**\n * Store as part of the peer store metadata for a given peer, the value for this\n * key is a timestamp of the last time a dial attempt succeeded with the\n * timestamp stored as a string.\n */\nexport const LAST_DIAL_SUCCESS_KEY = 'last-dial-success'\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxDialQueueLength\n */\nexport const MAX_DIAL_QUEUE_LENGTH = 500\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxRecursiveDepth\n */\nexport const MAX_RECURSIVE_DEPTH = 32\n", "export * from './constants.defaults.js'\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxConnections\n */\nexport const MAX_CONNECTIONS = 100\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxParallelDials\n */\nexport const MAX_PARALLEL_DIALS = 50\n", "import { isLoopback, isPrivate } from '@libp2p/utils'\nimport { Circuit, WebSockets, WebSocketsSecure, WebRTC, WebRTCDirect, WebTransport, TCP } from '@multiformats/multiaddr-matcher'\nimport type { Address } from '@libp2p/interface'\n\n/**\n * Sorts addresses by order of reliability, where they have presented the fewest\n * problems:\n *\n * TCP -> WebSockets/Secure -> WebRTC -> WebRTCDirect -> WebTransport\n */\n// eslint-disable-next-line complexity\nexport function reliableTransportsFirst (a: Address, b: Address): -1 | 0 | 1 {\n  const isATcp = TCP.exactMatch(a.multiaddr)\n  const isBTcp = TCP.exactMatch(b.multiaddr)\n\n  if (isATcp && !isBTcp) {\n    return -1\n  }\n\n  if (!isATcp && isBTcp) {\n    return 1\n  }\n\n  const isAWebSocketSecure = WebSocketsSecure.exactMatch(a.multiaddr)\n  const isBWebSocketSecure = WebSocketsSecure.exactMatch(b.multiaddr)\n\n  if (isAWebSocketSecure && !isBWebSocketSecure) {\n    return -1\n  }\n\n  if (!isAWebSocketSecure && isBWebSocketSecure) {\n    return 1\n  }\n\n  const isAWebSocket = WebSockets.exactMatch(a.multiaddr)\n  const isBWebSocket = WebSockets.exactMatch(b.multiaddr)\n\n  if (isAWebSocket && !isBWebSocket) {\n    return -1\n  }\n\n  if (!isAWebSocket && isBWebSocket) {\n    return 1\n  }\n\n  const isAWebRTC = WebRTC.exactMatch(a.multiaddr)\n  const isBWebRTC = WebRTC.exactMatch(b.multiaddr)\n\n  if (isAWebRTC && !isBWebRTC) {\n    return -1\n  }\n\n  if (!isAWebRTC && isBWebRTC) {\n    return 1\n  }\n\n  const isAWebRTCDirect = WebRTCDirect.exactMatch(a.multiaddr)\n  const isBWebRTCDirect = WebRTCDirect.exactMatch(b.multiaddr)\n\n  if (isAWebRTCDirect && !isBWebRTCDirect) {\n    return -1\n  }\n\n  if (!isAWebRTCDirect && isBWebRTCDirect) {\n    return 1\n  }\n\n  const isAWebTransport = WebTransport.exactMatch(a.multiaddr)\n  const isBWebTransport = WebTransport.exactMatch(b.multiaddr)\n\n  if (isAWebTransport && !isBWebTransport) {\n    return -1\n  }\n\n  if (!isAWebTransport && isBWebTransport) {\n    return 1\n  }\n\n  // ... everything else\n  return 0\n}\n\n/**\n * Compare function for array.sort() that moves loopback addresses to the end\n * of the array.\n */\nexport function loopbackAddressLast (a: Address, b: Address): -1 | 0 | 1 {\n  const isALoopback = isLoopback(a.multiaddr)\n  const isBLoopback = isLoopback(b.multiaddr)\n\n  if (isALoopback && !isBLoopback) {\n    return 1\n  } else if (!isALoopback && isBLoopback) {\n    return -1\n  }\n\n  return 0\n}\n\n/**\n * Compare function for array.sort() that moves public addresses to the start\n * of the array.\n */\nexport function publicAddressesFirst (a: Address, b: Address): -1 | 0 | 1 {\n  const isAPrivate = isPrivate(a.multiaddr)\n  const isBPrivate = isPrivate(b.multiaddr)\n\n  if (isAPrivate && !isBPrivate) {\n    return 1\n  } else if (!isAPrivate && isBPrivate) {\n    return -1\n  }\n\n  return 0\n}\n\n/**\n * Compare function for array.sort() that moves certified addresses to the start\n * of the array.\n */\nexport function certifiedAddressesFirst (a: Address, b: Address): -1 | 0 | 1 {\n  if (a.isCertified && !b.isCertified) {\n    return -1\n  } else if (!a.isCertified && b.isCertified) {\n    return 1\n  }\n\n  return 0\n}\n\n/**\n * Compare function for array.sort() that moves circuit relay addresses to the\n * end of the array.\n */\nexport function circuitRelayAddressesLast (a: Address, b: Address): -1 | 0 | 1 {\n  const isACircuit = Circuit.exactMatch(a.multiaddr)\n  const isBCircuit = Circuit.exactMatch(b.multiaddr)\n\n  if (isACircuit && !isBCircuit) {\n    return 1\n  } else if (!isACircuit && isBCircuit) {\n    return -1\n  }\n\n  return 0\n}\n\nexport function defaultAddressSorter (addresses: Address[]): Address[] {\n  return addresses\n    .sort(reliableTransportsFirst)\n    .sort(certifiedAddressesFirst)\n    .sort(circuitRelayAddressesLast)\n    .sort(publicAddressesFirst)\n    .sort(loopbackAddressLast)\n}\n", "export class DNSQueryFailedError extends AggregateError {\n  static name = 'DNSQueryFailedError'\n  name = 'DNSQueryFailedError'\n}\n", "// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\nexport default function lowerBound(array, value, comparator) {\n    let first = 0;\n    let count = array.length;\n    while (count > 0) {\n        const step = Math.trunc(count / 2);\n        let it = first + step;\n        if (comparator(array[it], value) <= 0) {\n            first = ++it;\n            count -= step + 1;\n        }\n        else {\n            count = step;\n        }\n    }\n    return first;\n}\n", "import lowerBound from './lower-bound.js';\nexport default class PriorityQueue {\n    #queue = [];\n    enqueue(run, options) {\n        const { priority = 0, id, } = options ?? {};\n        const element = {\n            priority,\n            id,\n            run,\n        };\n        if (this.size === 0 || this.#queue[this.size - 1].priority >= priority) {\n            this.#queue.push(element);\n            return;\n        }\n        const index = lowerBound(this.#queue, element, (a, b) => b.priority - a.priority);\n        this.#queue.splice(index, 0, element);\n    }\n    setPriority(id, priority) {\n        const index = this.#queue.findIndex((element) => element.id === id);\n        if (index === -1) {\n            throw new ReferenceError(`No promise function with the id \"${id}\" exists in the queue.`);\n        }\n        const [item] = this.#queue.splice(index, 1);\n        this.enqueue(item.run, { priority, id });\n    }\n    dequeue() {\n        const item = this.#queue.shift();\n        return item?.run;\n    }\n    filter(options) {\n        return this.#queue.filter((element) => element.priority === options.priority).map((element) => element.run);\n    }\n    get size() {\n        return this.#queue.length;\n    }\n}\n", "import { EventEmitter } from 'eventemitter3';\nimport pTimeout from 'p-timeout';\nimport PriorityQueue from './priority-queue.js';\n/**\nPromise queue with concurrency control.\n*/\nexport default class PQueue extends EventEmitter {\n    #carryoverIntervalCount;\n    #isIntervalIgnored;\n    #intervalCount = 0;\n    #intervalCap;\n    #rateLimitedInInterval = false;\n    #rateLimitFlushScheduled = false;\n    #interval;\n    #intervalEnd = 0;\n    #lastExecutionTime = 0;\n    #intervalId;\n    #timeoutId;\n    #queue;\n    #queueClass;\n    #pending = 0;\n    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194\n    #concurrency;\n    #isPaused;\n    // Use to assign a unique identifier to a promise function, if not explicitly specified\n    #idAssigner = 1n;\n    // Track currently running tasks for debugging\n    #runningTasks = new Map();\n    /**\n    Get or set the default timeout for all tasks. Can be changed at runtime.\n\n    Operations will throw a `TimeoutError` if they don't complete within the specified time.\n\n    The timeout begins when the operation is dequeued and starts execution, not while it's waiting in the queue.\n\n    @example\n    ```\n    const queue = new PQueue({timeout: 5000});\n\n    // Change timeout for all future tasks\n    queue.timeout = 10000;\n    ```\n    */\n    timeout;\n    constructor(options) {\n        super();\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = {\n            carryoverIntervalCount: false,\n            intervalCap: Number.POSITIVE_INFINITY,\n            interval: 0,\n            concurrency: Number.POSITIVE_INFINITY,\n            autoStart: true,\n            queueClass: PriorityQueue,\n            ...options,\n        };\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${options.intervalCap?.toString() ?? ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${options.interval?.toString() ?? ''}\\` (${typeof options.interval})`);\n        }\n        // TODO: Remove this fallback in the next major version\n        // eslint-disable-next-line @typescript-eslint/no-deprecated\n        this.#carryoverIntervalCount = options.carryoverIntervalCount ?? options.carryoverConcurrencyCount ?? false;\n        this.#isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;\n        this.#intervalCap = options.intervalCap;\n        this.#interval = options.interval;\n        this.#queue = new options.queueClass();\n        this.#queueClass = options.queueClass;\n        this.concurrency = options.concurrency;\n        if (options.timeout !== undefined && !(Number.isFinite(options.timeout) && options.timeout > 0)) {\n            throw new TypeError(`Expected \\`timeout\\` to be a positive finite number, got \\`${options.timeout}\\` (${typeof options.timeout})`);\n        }\n        this.timeout = options.timeout;\n        this.#isPaused = options.autoStart === false;\n        this.#setupRateLimitTracking();\n    }\n    get #doesIntervalAllowAnother() {\n        return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;\n    }\n    get #doesConcurrentAllowAnother() {\n        return this.#pending < this.#concurrency;\n    }\n    #next() {\n        this.#pending--;\n        if (this.#pending === 0) {\n            this.emit('pendingZero');\n        }\n        this.#tryToStartAnother();\n        this.emit('next');\n    }\n    #onResumeInterval() {\n        this.#onInterval(); // Already schedules update\n        this.#initializeIntervalIfNeeded();\n        this.#timeoutId = undefined;\n    }\n    get #isIntervalPaused() {\n        const now = Date.now();\n        if (this.#intervalId === undefined) {\n            const delay = this.#intervalEnd - now;\n            if (delay < 0) {\n                // If the interval has expired while idle, check if we should enforce the interval\n                // from the last task execution. This ensures proper spacing between tasks even\n                // when the queue becomes empty and then new tasks are added.\n                if (this.#lastExecutionTime > 0) {\n                    const timeSinceLastExecution = now - this.#lastExecutionTime;\n                    if (timeSinceLastExecution < this.#interval) {\n                        // Not enough time has passed since the last task execution\n                        this.#createIntervalTimeout(this.#interval - timeSinceLastExecution);\n                        return true;\n                    }\n                }\n                // Enough time has passed or no previous execution, allow execution\n                this.#intervalCount = (this.#carryoverIntervalCount) ? this.#pending : 0;\n            }\n            else {\n                // Act as the interval is pending\n                this.#createIntervalTimeout(delay);\n                return true;\n            }\n        }\n        return false;\n    }\n    #createIntervalTimeout(delay) {\n        if (this.#timeoutId !== undefined) {\n            return;\n        }\n        this.#timeoutId = setTimeout(() => {\n            this.#onResumeInterval();\n        }, delay);\n    }\n    #clearIntervalTimer() {\n        if (this.#intervalId) {\n            clearInterval(this.#intervalId);\n            this.#intervalId = undefined;\n        }\n    }\n    #clearTimeoutTimer() {\n        if (this.#timeoutId) {\n            clearTimeout(this.#timeoutId);\n            this.#timeoutId = undefined;\n        }\n    }\n    #tryToStartAnother() {\n        if (this.#queue.size === 0) {\n            // We can clear the interval (\"pause\")\n            // Because we can redo it later (\"resume\")\n            this.#clearIntervalTimer();\n            this.emit('empty');\n            if (this.#pending === 0) {\n                // Clear timeout as well when completely idle\n                this.#clearTimeoutTimer();\n                this.emit('idle');\n            }\n            return false;\n        }\n        let taskStarted = false;\n        if (!this.#isPaused) {\n            const canInitializeInterval = !this.#isIntervalPaused;\n            if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {\n                const job = this.#queue.dequeue();\n                // Increment interval count immediately to prevent race conditions\n                if (!this.#isIntervalIgnored) {\n                    this.#intervalCount++;\n                    this.#scheduleRateLimitUpdate();\n                }\n                this.emit('active');\n                this.#lastExecutionTime = Date.now();\n                job();\n                if (canInitializeInterval) {\n                    this.#initializeIntervalIfNeeded();\n                }\n                taskStarted = true;\n            }\n        }\n        return taskStarted;\n    }\n    #initializeIntervalIfNeeded() {\n        if (this.#isIntervalIgnored || this.#intervalId !== undefined) {\n            return;\n        }\n        this.#intervalId = setInterval(() => {\n            this.#onInterval();\n        }, this.#interval);\n        this.#intervalEnd = Date.now() + this.#interval;\n    }\n    #onInterval() {\n        if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {\n            this.#clearIntervalTimer();\n        }\n        this.#intervalCount = this.#carryoverIntervalCount ? this.#pending : 0;\n        this.#processQueue();\n        this.#scheduleRateLimitUpdate();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n    #processQueue() {\n        // eslint-disable-next-line no-empty\n        while (this.#tryToStartAnother()) { }\n    }\n    get concurrency() {\n        return this.#concurrency;\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        this.#concurrency = newConcurrency;\n        this.#processQueue();\n    }\n    /**\n    Updates the priority of a promise function by its id, affecting its execution order. Requires a defined concurrency limit to take effect.\n\n    For example, this can be used to prioritize a promise function to run earlier.\n\n    ```js\n    import PQueue from 'p-queue';\n\n    const queue = new PQueue({concurrency: 1});\n\n    queue.add(async () => '', {priority: 1});\n    queue.add(async () => '', {priority: 0, id: ''});\n    queue.add(async () => '', {priority: 1});\n    queue.add(async () => '', {priority: 1});\n\n    queue.setPriority('', 2);\n    ```\n\n    In this case, the promise function with `id: ''` runs second.\n\n    You can also deprioritize a promise function to delay its execution:\n\n    ```js\n    import PQueue from 'p-queue';\n\n    const queue = new PQueue({concurrency: 1});\n\n    queue.add(async () => '', {priority: 1});\n    queue.add(async () => '', {priority: 1, id: ''});\n    queue.add(async () => '');\n    queue.add(async () => '', {priority: 0});\n\n    queue.setPriority('', -1);\n    ```\n    Here, the promise function with `id: ''` executes last.\n    */\n    setPriority(id, priority) {\n        if (typeof priority !== 'number' || !Number.isFinite(priority)) {\n            throw new TypeError(`Expected \\`priority\\` to be a finite number, got \\`${priority}\\` (${typeof priority})`);\n        }\n        this.#queue.setPriority(id, priority);\n    }\n    async add(function_, options = {}) {\n        // In case `id` is not defined.\n        options.id ??= (this.#idAssigner++).toString();\n        options = {\n            timeout: this.timeout,\n            ...options,\n        };\n        return new Promise((resolve, reject) => {\n            // Create a unique symbol for tracking this task\n            const taskSymbol = Symbol(`task-${options.id}`);\n            this.#queue.enqueue(async () => {\n                this.#pending++;\n                // Track this running task\n                this.#runningTasks.set(taskSymbol, {\n                    id: options.id,\n                    priority: options.priority ?? 0, // Match priority-queue default\n                    startTime: Date.now(),\n                    timeout: options.timeout,\n                });\n                let eventListener;\n                try {\n                    // Check abort signal - if aborted, need to decrement the counter\n                    // that was incremented in tryToStartAnother\n                    try {\n                        options.signal?.throwIfAborted();\n                    }\n                    catch (error) {\n                        // Decrement the counter that was already incremented\n                        if (!this.#isIntervalIgnored) {\n                            this.#intervalCount--;\n                        }\n                        // Clean up tracking before throwing\n                        this.#runningTasks.delete(taskSymbol);\n                        throw error;\n                    }\n                    let operation = function_({ signal: options.signal });\n                    if (options.timeout) {\n                        operation = pTimeout(Promise.resolve(operation), {\n                            milliseconds: options.timeout,\n                            message: `Task timed out after ${options.timeout}ms (queue has ${this.#pending} running, ${this.#queue.size} waiting)`,\n                        });\n                    }\n                    if (options.signal) {\n                        const { signal } = options;\n                        operation = Promise.race([operation, new Promise((_resolve, reject) => {\n                                eventListener = () => {\n                                    reject(signal.reason);\n                                };\n                                signal.addEventListener('abort', eventListener, { once: true });\n                            })]);\n                    }\n                    const result = await operation;\n                    resolve(result);\n                    this.emit('completed', result);\n                }\n                catch (error) {\n                    reject(error);\n                    this.emit('error', error);\n                }\n                finally {\n                    // Clean up abort event listener\n                    if (eventListener) {\n                        options.signal?.removeEventListener('abort', eventListener);\n                    }\n                    // Remove from running tasks\n                    this.#runningTasks.delete(taskSymbol);\n                    // Use queueMicrotask to prevent deep recursion while maintaining timing\n                    queueMicrotask(() => {\n                        this.#next();\n                    });\n                }\n            }, options);\n            this.emit('add');\n            this.#tryToStartAnother();\n        });\n    }\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!this.#isPaused) {\n            return this;\n        }\n        this.#isPaused = false;\n        this.#processQueue();\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        this.#isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        this.#queue = new this.#queueClass();\n        // Note: We don't clear #runningTasks as those tasks are still running\n        // They will be removed when they complete in the finally block\n        // Force synchronous update since clear() should have immediate effect\n        this.#updateRateLimitState();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (this.#queue.size === 0) {\n            return;\n        }\n        await this.#onEvent('empty');\n    }\n    /**\n    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.\n\n    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.\n\n    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.\n    */\n    async onSizeLessThan(limit) {\n        // Instantly resolve if the queue is empty.\n        if (this.#queue.size < limit) {\n            return;\n        }\n        await this.#onEvent('next', () => this.#queue.size < limit);\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this.#pending === 0 && this.#queue.size === 0) {\n            return;\n        }\n        await this.#onEvent('idle');\n    }\n    /**\n    The difference with `.onIdle` is that `.onPendingZero` only waits for currently running tasks to finish, ignoring queued tasks.\n\n    @returns A promise that settles when all currently running tasks have completed; `queue.pending === 0`.\n    */\n    async onPendingZero() {\n        if (this.#pending === 0) {\n            return;\n        }\n        await this.#onEvent('pendingZero');\n    }\n    /**\n    @returns A promise that settles when the queue becomes rate-limited due to intervalCap.\n    */\n    async onRateLimit() {\n        if (this.isRateLimited) {\n            return;\n        }\n        await this.#onEvent('rateLimit');\n    }\n    /**\n    @returns A promise that settles when the queue is no longer rate-limited.\n    */\n    async onRateLimitCleared() {\n        if (!this.isRateLimited) {\n            return;\n        }\n        await this.#onEvent('rateLimitCleared');\n    }\n    /**\n    @returns A promise that rejects when any task in the queue errors.\n\n    Use with `Promise.race([queue.onError(), queue.onIdle()])` to fail fast on the first error while still resolving normally when the queue goes idle.\n\n    Important: The promise returned by `add()` still rejects. You must handle each `add()` promise (for example, `.catch(() => {})`) to avoid unhandled rejections.\n\n    @example\n    ```\n    import PQueue from 'p-queue';\n\n    const queue = new PQueue({concurrency: 2});\n\n    queue.add(() => fetchData(1)).catch(() => {});\n    queue.add(() => fetchData(2)).catch(() => {});\n    queue.add(() => fetchData(3)).catch(() => {});\n\n    // Stop processing on first error\n    try {\n        await Promise.race([\n            queue.onError(),\n            queue.onIdle()\n        ]);\n    } catch (error) {\n        queue.pause(); // Stop processing remaining tasks\n        console.error('Queue failed:', error);\n    }\n    ```\n    */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async\n    async onError() {\n        return new Promise((_resolve, reject) => {\n            const handleError = (error) => {\n                this.off('error', handleError);\n                reject(error);\n            };\n            this.on('error', handleError);\n        });\n    }\n    async #onEvent(event, filter) {\n        return new Promise(resolve => {\n            const listener = () => {\n                if (filter && !filter()) {\n                    return;\n                }\n                this.off(event, listener);\n                resolve();\n            };\n            this.on(event, listener);\n        });\n    }\n    /**\n    Size of the queue, the number of queued items waiting to run.\n    */\n    get size() {\n        return this.#queue.size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-array-callback-reference\n        return this.#queue.filter(options).length;\n    }\n    /**\n    Number of running items (no longer in the queue).\n    */\n    get pending() {\n        return this.#pending;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return this.#isPaused;\n    }\n    #setupRateLimitTracking() {\n        // Only schedule updates when rate limiting is enabled\n        if (this.#isIntervalIgnored) {\n            return;\n        }\n        // Wire up to lifecycle events that affect rate limit state\n        // Only 'add' and 'next' can actually change rate limit state\n        this.on('add', () => {\n            if (this.#queue.size > 0) {\n                this.#scheduleRateLimitUpdate();\n            }\n        });\n        this.on('next', () => {\n            this.#scheduleRateLimitUpdate();\n        });\n    }\n    #scheduleRateLimitUpdate() {\n        // Skip if rate limiting is not enabled or already scheduled\n        if (this.#isIntervalIgnored || this.#rateLimitFlushScheduled) {\n            return;\n        }\n        this.#rateLimitFlushScheduled = true;\n        queueMicrotask(() => {\n            this.#rateLimitFlushScheduled = false;\n            this.#updateRateLimitState();\n        });\n    }\n    #updateRateLimitState() {\n        const previous = this.#rateLimitedInInterval;\n        const shouldBeRateLimited = !this.#isIntervalIgnored\n            && this.#intervalCount >= this.#intervalCap\n            && this.#queue.size > 0;\n        if (shouldBeRateLimited !== previous) {\n            this.#rateLimitedInInterval = shouldBeRateLimited;\n            this.emit(shouldBeRateLimited ? 'rateLimit' : 'rateLimitCleared');\n        }\n    }\n    /**\n    Whether the queue is currently rate-limited due to intervalCap.\n    */\n    get isRateLimited() {\n        return this.#rateLimitedInInterval;\n    }\n    /**\n    Whether the queue is saturated. Returns `true` when:\n    - All concurrency slots are occupied and tasks are waiting, OR\n    - The queue is rate-limited and tasks are waiting\n\n    Useful for detecting backpressure and potential hanging tasks.\n\n    ```js\n    import PQueue from 'p-queue';\n\n    const queue = new PQueue({concurrency: 2});\n\n    // Backpressure handling\n    if (queue.isSaturated) {\n        console.log('Queue is saturated, waiting for capacity...');\n        await queue.onSizeLessThan(queue.concurrency);\n    }\n\n    // Monitoring for stuck tasks\n    setInterval(() => {\n        if (queue.isSaturated) {\n            console.warn(`Queue saturated: ${queue.pending} running, ${queue.size} waiting`);\n        }\n    }, 60000);\n    ```\n    */\n    get isSaturated() {\n        return (this.#pending === this.#concurrency && this.#queue.size > 0)\n            || (this.isRateLimited && this.#queue.size > 0);\n    }\n    /**\n    The tasks currently being executed. Each task includes its `id`, `priority`, `startTime`, and `timeout` (if set).\n\n    Returns an array of task info objects.\n\n    ```js\n    import PQueue from 'p-queue';\n\n    const queue = new PQueue({concurrency: 2});\n\n    // Add tasks with IDs for better debugging\n    queue.add(() => fetchUser(123), {id: 'user-123'});\n    queue.add(() => fetchPosts(456), {id: 'posts-456', priority: 1});\n\n    // Check what's running\n    console.log(queue.runningTasks);\n    // => [{\n    //   id: 'user-123',\n    //   priority: 0,\n    //   startTime: 1759253001716,\n    //   timeout: undefined\n    // }, {\n    //   id: 'posts-456',\n    //   priority: 1,\n    //   startTime: 1759253001916,\n    //   timeout: undefined\n    // }]\n    ```\n    */\n    get runningTasks() {\n        // Return fresh array with fresh objects to prevent mutations\n        return [...this.#runningTasks.values()].map(task => ({ ...task }));\n    }\n}\n/**\nError thrown when a task times out.\n\n@example\n```\nimport PQueue, {TimeoutError} from 'p-queue';\n\nconst queue = new PQueue({timeout: 1000});\n\ntry {\n    await queue.add(() => someTask());\n} catch (error) {\n    if (error instanceof TimeoutError) {\n        console.log('Task timed out');\n    }\n}\n```\n*/\nexport { TimeoutError } from 'p-timeout';\n", "import { RecordType } from '../index.js'\n\nexport function getTypes (types?: RecordType | RecordType[]): RecordType[] {\n  const DEFAULT_TYPES = [\n    RecordType.A\n  ]\n\n  if (types == null) {\n    return DEFAULT_TYPES\n  }\n\n  if (Array.isArray(types)) {\n    if (types.length === 0) {\n      return DEFAULT_TYPES\n    }\n\n    return types\n  }\n\n  return [\n    types\n  ]\n}\n", "import { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { RecordType } from '../index.js'\nimport type { DNSResponse } from '../index.js'\n\n/**\n * This TTL will be used if the remote service does not return one\n */\nexport const DEFAULT_TTL = 60\n\nexport function toDNSResponse (obj: any): DNSResponse {\n  return {\n    Status: obj.Status ?? 0,\n    TC: obj.TC ?? obj.flag_tc ?? false,\n    RD: obj.RD ?? obj.flag_rd ?? false,\n    RA: obj.RA ?? obj.flag_ra ?? false,\n    AD: obj.AD ?? obj.flag_ad ?? false,\n    CD: obj.CD ?? obj.flag_cd ?? false,\n    Question: (obj.Question ?? obj.questions ?? []).map((question: any) => {\n      return {\n        name: question.name,\n        type: RecordType[question.type]\n      }\n    }),\n    Answer: (obj.Answer ?? obj.answers ?? []).map((answer: any) => {\n      return {\n        name: answer.name,\n        type: RecordType[answer.type],\n        TTL: (answer.TTL ?? answer.ttl ?? DEFAULT_TTL),\n        data: answer.data instanceof Uint8Array ? uint8ArrayToString(answer.data) : answer.data\n      }\n    })\n  }\n}\n", "/* eslint-env browser */\n\nimport PQueue from 'p-queue'\nimport { CustomProgressEvent } from 'progress-events'\nimport { RecordType } from '../index.js'\nimport { getTypes } from '../utils/get-types.js'\nimport { toDNSResponse } from '../utils/to-dns-response.js'\nimport type { DNSResponse } from '../index.js'\nimport type { DNSResolver } from './index.js'\n\n/**\n * Browsers limit concurrent connections per host (~6), we don't want to exhaust\n * the limit so this value controls how many DNS queries can be in flight at\n * once.\n */\nexport const DEFAULT_QUERY_CONCURRENCY = 4\n\nexport interface DNSJSONOverHTTPSOptions {\n  queryConcurrency?: number\n}\n\n/**\n * Uses the RFC 8427 'application/dns-json' content-type to resolve DNS queries.\n *\n * Supports and server that uses the same schema as Google's DNS over HTTPS\n * resolver.\n *\n * This resolver needs fewer dependencies than the regular DNS-over-HTTPS\n * resolver so can result in a smaller bundle size and consequently is preferred\n * for browser use.\n *\n * @see https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/make-api-requests/dns-json/\n * @see https://github.com/curl/curl/wiki/DNS-over-HTTPS#publicly-available-servers\n * @see https://dnsprivacy.org/public_resolvers/\n * @see https://datatracker.ietf.org/doc/html/rfc8427\n */\nexport function dnsJsonOverHttps (url: string, init: DNSJSONOverHTTPSOptions = {}): DNSResolver {\n  const httpQueue = new PQueue({\n    concurrency: init.queryConcurrency ?? DEFAULT_QUERY_CONCURRENCY\n  })\n\n  return async (fqdn, options = {}) => {\n    const searchParams = new URLSearchParams()\n    searchParams.set('name', fqdn)\n\n    getTypes(options.types).forEach(type => {\n      // We pass record type as a string to the server because cloudflare DNS bug. see https://github.com/ipfs/helia/issues/474\n      searchParams.append('type', RecordType[type])\n    })\n\n    options.onProgress?.(new CustomProgressEvent<string>('dns:query', fqdn))\n\n    // query DNS-JSON over HTTPS server\n    const response = await httpQueue.add(async () => {\n      const res = await fetch(`${url}?${searchParams}`, {\n        headers: {\n          accept: 'application/dns-json'\n        },\n        signal: options?.signal\n      })\n\n      if (res.status !== 200) {\n        throw new Error(`Unexpected HTTP status: ${res.status} - ${res.statusText}`)\n      }\n\n      const response = toDNSResponse(await res.json())\n\n      options.onProgress?.(new CustomProgressEvent<DNSResponse>('dns:response', response))\n\n      return response\n    }, {\n      signal: options.signal\n    })\n\n    if (response == null) {\n      throw new Error('No DNS response received')\n    }\n\n    return response\n  }\n}\n", "import { dnsJsonOverHttps } from './dns-json-over-https.js'\nimport type { DNSResolver } from './index.js'\n\nexport function defaultResolver (): DNSResolver[] {\n  return [\n    dnsJsonOverHttps('https://cloudflare-dns.com/dns-query'),\n    dnsJsonOverHttps('https://dns.google/resolve')\n  ]\n}\n", "import hashlru from 'hashlru'\nimport { RecordType } from '../index.js'\nimport { DEFAULT_TTL, toDNSResponse } from './to-dns-response.js'\nimport type { Answer, DNSResponse } from '../index.js'\n\ninterface CachedAnswer {\n  expires: number\n  value: Answer\n}\n\nexport interface AnswerCache {\n  get (fqdn: string, types: RecordType[]): DNSResponse | undefined\n  add (domain: string, answer: Answer): void\n  remove (domain: string, type: ResponseType): void\n  clear (): void\n}\n\n/**\n * Time Aware Least Recent Used Cache\n *\n * @see https://arxiv.org/pdf/1801.00390\n */\nclass CachedAnswers {\n  private readonly lru: any\n\n  constructor (maxSize: number) {\n    // @ts-expect-error types are broken - https://github.com/dominictarr/hashlru/pull/24\n    this.lru = hashlru(maxSize)\n  }\n\n  get (fqdn: string, types: RecordType[]): DNSResponse | undefined {\n    let foundAllAnswers = true\n    const answers: Answer[] = []\n\n    for (const type of types) {\n      const cached = this.getAnswers(fqdn, type)\n\n      if (cached.length === 0) {\n        foundAllAnswers = false\n        break\n      }\n\n      answers.push(...cached)\n    }\n\n    if (foundAllAnswers) {\n      return toDNSResponse({ answers })\n    }\n  }\n\n  private getAnswers (domain: string, type: RecordType): Answer[] {\n    const key = `${domain.toLowerCase()}-${type}`\n    const answers: CachedAnswer[] = this.lru.get(key)\n\n    if (answers != null) {\n      const cachedAnswers = answers\n        .filter((entry) => {\n          return entry.expires > Date.now()\n        })\n        .map(({ expires, value }) => ({\n          ...value,\n          TTL: Math.round((expires - Date.now()) / 1000),\n          type: RecordType[value.type]\n        }))\n\n      if (cachedAnswers.length === 0) {\n        this.lru.remove(key)\n      }\n\n      // @ts-expect-error hashlru stringifies stored types which turns enums\n      // into strings, we convert back into enums above but tsc doesn't know\n      return cachedAnswers\n    }\n\n    return []\n  }\n\n  add (domain: string, answer: Answer): void {\n    const key = `${domain.toLowerCase()}-${answer.type}`\n\n    const answers: CachedAnswer[] = this.lru.get(key) ?? []\n    answers.push({\n      expires: Date.now() + ((answer.TTL ?? DEFAULT_TTL) * 1000),\n      value: answer\n    })\n\n    this.lru.set(key, answers)\n  }\n\n  remove (domain: string, type: ResponseType): void {\n    const key = `${domain.toLowerCase()}-${type}`\n\n    this.lru.remove(key)\n  }\n\n  clear (): void {\n    this.lru.clear()\n  }\n}\n\n/**\n * Avoid sending multiple queries for the same hostname by caching results\n */\nexport function cache (size: number): AnswerCache {\n  return new CachedAnswers(size)\n}\n", "import { CustomProgressEvent } from 'progress-events'\nimport { DNSQueryFailedError } from './errors.ts'\nimport { defaultResolver } from './resolvers/default.js'\nimport { cache } from './utils/cache.js'\nimport { getTypes } from './utils/get-types.js'\nimport type { DNS as DNSInterface, DNSInit, DNSResponse, QueryOptions } from './index.js'\nimport type { DNSResolver } from './resolvers/index.js'\nimport type { AnswerCache } from './utils/cache.js'\n\nconst DEFAULT_ANSWER_CACHE_SIZE = 1000\n\nexport class DNS implements DNSInterface {\n  private readonly resolvers: Record<string, DNSResolver[]>\n  private readonly cache: AnswerCache\n\n  constructor (init: DNSInit) {\n    this.resolvers = {}\n    this.cache = cache(init.cacheSize ?? DEFAULT_ANSWER_CACHE_SIZE)\n\n    Object.entries(init.resolvers ?? {}).forEach(([tld, resolver]) => {\n      if (!Array.isArray(resolver)) {\n        resolver = [resolver]\n      }\n\n      // convert `com` -> `com.`\n      if (!tld.endsWith('.')) {\n        tld = `${tld}.`\n      }\n\n      this.resolvers[tld] = resolver\n    })\n\n    // configure default resolver if none specified\n    if (this.resolvers['.'] == null) {\n      this.resolvers['.'] = defaultResolver()\n    }\n  }\n\n  /**\n   * Queries DNS resolvers for the passed record types for the passed domain.\n   *\n   * If cached records exist for all desired types they will be returned\n   * instead.\n   *\n   * Any new responses will be added to the cache for subsequent requests.\n   */\n  async query (domain: string, options: QueryOptions = {}): Promise<DNSResponse> {\n    const types = getTypes(options.types)\n    const cached = options.cached !== false ? this.cache.get(domain, types) : undefined\n\n    if (cached != null) {\n      options.onProgress?.(new CustomProgressEvent<DNSResponse>('dns:cache', cached))\n\n      return cached\n    }\n\n    const tld = `${domain.split('.').pop()}.`\n    const resolvers = (this.resolvers[tld] ?? this.resolvers['.']).sort(() => {\n      return (Math.random() > 0.5) ? -1 : 1\n    })\n\n    const errors: Error[] = []\n\n    for (const resolver of resolvers) {\n      // skip further resolutions if the user aborted the signal\n      if (options.signal?.aborted === true) {\n        break\n      }\n\n      try {\n        const result = await resolver(domain, {\n          ...options,\n          types\n        })\n\n        for (const answer of result.Answer) {\n          this.cache.add(domain, answer)\n        }\n\n        return result\n      } catch (err: any) {\n        errors.push(err)\n        options.onProgress?.(new CustomProgressEvent<Error>('dns:error', err))\n      }\n    }\n\n    throw new DNSQueryFailedError(errors, `DNS lookup of ${domain} ${types} failed`)\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Query DNS records using `node:dns`, DNS over HTTP and/or DNSJSON over HTTP.\n *\n * A list of publicly accessible servers can be found [here](https://github.com/curl/curl/wiki/DNS-over-HTTPS#publicly-available-servers).\n *\n * @example Using the default resolver\n *\n * ```TypeScript\n * import { dns } from '@multiformats/dns'\n *\n * const resolver = dns()\n *\n * // resolve A records with a 5s timeout\n * const result = await dns.query('google.com', {\n *   signal: AbortSignal.timeout(5000)\n * })\n * ```\n *\n * @example Using per-TLD resolvers\n *\n * ```TypeScript\n * import { dns } from '@multiformats/dns'\n * import { dnsJsonOverHttps } from '@multiformats/dns/resolvers'\n *\n * const resolver = dns({\n *   resolvers: {\n *     // will only be used to resolve `.com` addresses\n *     'com.': dnsJsonOverHttps('https://cloudflare-dns.com/dns-query'),\n *\n *     // this can also be an array, resolvers will be shuffled and tried in\n *     // series\n *     'net.': [\n *       dnsJsonOverHttps('https://dns.google/resolve'),\n *       dnsJsonOverHttps('https://dns.pub/dns-query')\n *     ],\n *\n *     // will only be used to resolve all other addresses\n *     '.': dnsJsonOverHttps('https://dnsforge.de/dns-query'),\n *   }\n * })\n * ```\n *\n * @example Query for specific record types\n *\n * ```TypeScript\n * import { dns, RecordType } from '@multiformats/dns'\n *\n * const resolver = dns()\n *\n * // resolve only TXT records\n * const result = await dns.query('google.com', {\n *   types: [\n *     RecordType.TXT\n *   ]\n * })\n * ```\n *\n * ## Caching\n *\n * Individual Aanswers are cached so. If you make a request, for which all\n * record types are cached, all values will be pulled from the cache.\n *\n * If any of the record types are not cached, a new request will be resolved as\n * if none of the records were cached, and the cache will be updated to include\n * the new results.\n *\n * @example Ignoring the cache\n *\n * ```TypeScript\n * import { dns, RecordType } from '@multiformats/dns'\n *\n * const resolver = dns()\n *\n * // do not used cached results, always resolve a new query\n * const result = await dns.query('google.com', {\n *   cached: false\n * })\n * ```\n */\n\nimport { DNS as DNSClass } from './dns.js'\nimport type { DNSResolver } from './resolvers/index.js'\nimport type { ProgressEvent, ProgressOptions } from 'progress-events'\n\n/**\n * A subset of DNS Record Types\n *\n * @see https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4.\n */\nexport enum RecordType {\n  A = 1,\n  CNAME = 5,\n  TXT = 16,\n  AAAA = 28\n}\n\nexport interface Question {\n  /**\n   * The record name requested.\n   */\n  name: string\n\n  /**\n   * The type of DNS record requested.\n   *\n   * @see https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4.\n   */\n  type: RecordType\n}\n\nexport interface Answer {\n  /**\n   * The record owner.\n   */\n  name: string\n\n  /**\n   * The type of DNS record.\n   *\n   * @see https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4\n   */\n  type: RecordType\n\n  /**\n   * The number of seconds the answer can be stored in cache before it is\n   * considered stale.\n   */\n  TTL: number\n\n  /**\n   * The value of the DNS record for the given name and type. The data will be\n   * in text for standardized record types and in hex for unknown types.\n   */\n  data: string\n}\n\nexport interface DNSResponse {\n  /**\n   * The Response Code of the DNS Query.\n   *\n   * @see https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-6\n   */\n  Status: number\n\n  /**\n   * If true, it means the truncated bit was set. This happens when the DNS\n   * answer is larger than a single UDP or TCP packet.\n   */\n  TC: boolean\n\n  /**\n   * If true, it means the Recursive Desired bit was set.\n   */\n  RD: boolean\n\n  /**\n   * If true, it means the Recursion Available bit was set.\n   */\n  RA: boolean\n\n  /**\n   * If true, it means that every record in the answer was verified with DNSSEC.\n   */\n  AD: boolean\n\n  /**\n   * If true, the client asked to disable DNSSEC validation.\n   */\n  CD: boolean\n\n  /**\n   * The records that were requested.\n   */\n  Question: Question[]\n\n  /**\n   * Values for the records that were requested.\n   */\n  Answer: Answer[]\n}\n\n/**\n * The default maximum amount of recursion allowed during a query\n */\nexport const MAX_RECURSIVE_DEPTH = 32\n\nexport interface QueryOptions extends ProgressOptions<ResolveDnsProgressEvents> {\n  signal?: AbortSignal\n\n  /**\n   * Do not use cached DNS entries\n   *\n   * @default false\n   */\n  cached?: boolean\n\n  /**\n   * The type or types of DNS records to resolve\n   *\n   * @default [RecordType.A, RecordType.AAAA]\n   */\n  types?: RecordType | RecordType[]\n}\n\nexport interface DNS {\n  query(fqdn: string, options?: QueryOptions): Promise<DNSResponse>\n}\n\nexport type ResolveDnsProgressEvents =\n  ProgressEvent<'dns:cache', string> |\n  ProgressEvent<'dns:query', string> |\n  ProgressEvent<'dns:response', DNSResponse> |\n  ProgressEvent<'dns:error', Error>\n\nexport type DNSResolvers = Record<string, DNSResolver | DNSResolver[]>\n\nexport interface DNSInit {\n  /**\n   * A set of resolvers used to answer DNS queries\n   *\n   * String keys control which resolvers are used for which TLDs.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * import { dns } from '@multiformats/dns'\n   * import { dnsOverHttps } from '@multiformats/dns'\n   *\n   * const resolver = dns({\n   *   resolvers: {\n   *     // only used for .com domains\n   *     'com.': dnsOverHttps('https://example-1.com'),\n   *\n   *     // only used for .net domains, can be an array\n   *     'net.': [\n   *       dnsOverHttps('https://example-2.com'),\n   *       dnsOverHttps('https://example-3.com'),\n   *     ],\n   *\n   *     // used for everything else (can be an array)\n   *     '.': dnsOverHttps('https://example-4.com')\n   *   }\n   * })\n   * ```\n   */\n  resolvers?: DNSResolvers\n\n  /**\n   * To avoid repeating DNS lookups, successful answers are cached according to\n   * their TTL. To avoid exhausting memory, this option controls how many\n   * answers to cache.\n   *\n   * @default 1000\n   */\n  cacheSize?: number\n}\n\nexport function dns (init: DNSInit = {}): DNS {\n  return new DNSClass(init)\n}\n", "import { dns, RecordType } from '@multiformats/dns'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport type { MultiaddrResolver, MultiaddrResolveOptions } from '@libp2p/interface'\nimport type { DNS } from '@multiformats/dns'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nclass DNSAddrResolver implements MultiaddrResolver {\n  private dns?: DNS\n\n  canResolve (ma: Multiaddr): boolean {\n    return ma.getComponents().some(({ name }) => name === 'dnsaddr')\n  }\n\n  async resolve (ma: Multiaddr, options: MultiaddrResolveOptions): Promise<Multiaddr[]> {\n    const hostname = ma.getComponents()\n      .find(component => component.name === 'dnsaddr')\n      ?.value\n\n    if (hostname == null) {\n      return [ma]\n    }\n\n    const resolver = this.getDNS(options)\n    const result = await resolver.query(`_dnsaddr.${hostname}`, {\n      signal: options?.signal,\n      types: [\n        RecordType.TXT\n      ]\n    })\n\n    const peerId = ma.getComponents()\n      .find(component => component.name === 'p2p')\n      ?.value\n    const output: Multiaddr[] = []\n\n    for (const answer of result.Answer) {\n      const addr = answer.data\n        .replace(/[\"']/g, '')\n        .trim()\n        .split('=')[1]\n\n      if (addr == null) {\n        continue\n      }\n\n      if (peerId != null && !addr.includes(peerId)) {\n        continue\n      }\n\n      output.push(multiaddr(addr))\n    }\n\n    return output\n  }\n\n  private getDNS (options: MultiaddrResolveOptions): DNS {\n    if (options.dns != null) {\n      return options.dns\n    }\n\n    if (this.dns == null) {\n      this.dns = dns()\n    }\n\n    return this.dns\n  }\n}\n\nexport const dnsaddrResolver = new DNSAddrResolver()\n", "import { RecursionLimitError } from '../../errors.ts'\nimport { MAX_RECURSIVE_DEPTH } from '../constants.defaults.ts'\nimport type { MultiaddrResolveOptions, MultiaddrResolver } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport interface ResolveOptions extends MultiaddrResolveOptions {\n  /**\n   * When resolving DNSADDR Multiaddrs that resolve to other DNSADDR Multiaddrs,\n   * limit how many times we will recursively resolve them.\n   *\n   * @default 32\n   */\n  maxRecursiveDepth?: number\n\n  /**\n   * The current recursive depth\n   *\n   * @default 0\n   */\n  depth?: number\n}\n\n/**\n * Recursively resolve multiaddrs\n */\nexport async function resolveMultiaddr (address: Multiaddr, resolvers: Record<string, MultiaddrResolver>, options: ResolveOptions): Promise<Multiaddr[]> {\n  const depth = options.depth ?? 0\n\n  if (depth > (options.maxRecursiveDepth ?? MAX_RECURSIVE_DEPTH)) {\n    throw new RecursionLimitError('Max recursive depth reached')\n  }\n\n  let resolved = false\n  const output: Multiaddr[] = []\n\n  for (const resolver of Object.values(resolvers)) {\n    if (resolver.canResolve(address)) {\n      resolved = true\n      const addresses = await resolver.resolve(address, options)\n\n      for (const address of addresses) {\n        output.push(\n          ...(await resolveMultiaddr(address, resolvers, {\n            ...options,\n            depth: depth + 1\n          }))\n        )\n      }\n    }\n  }\n\n  if (resolved === false) {\n    output.push(address)\n  }\n\n  return output\n}\n\nexport { dnsaddrResolver } from './dnsaddr.js'\n", "/* eslint-disable max-depth */\nimport { TimeoutError, DialError, AbortError } from '@libp2p/interface'\nimport { PeerMap } from '@libp2p/peer-collections'\nimport { PriorityQueue } from '@libp2p/utils'\nimport { CODE_P2P, multiaddr } from '@multiformats/multiaddr'\nimport { Circuit } from '@multiformats/multiaddr-matcher'\nimport { anySignal } from 'any-signal'\nimport { setMaxListeners } from 'main-event'\nimport { CustomProgressEvent } from 'progress-events'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { DialDeniedError, NoValidAddressesError } from '../errors.js'\nimport { getPeerAddress } from '../get-peer.js'\nimport { defaultAddressSorter } from './address-sorter.js'\nimport {\n  DIAL_TIMEOUT,\n  MAX_PARALLEL_DIALS,\n  MAX_PEER_ADDRS_TO_DIAL,\n  LAST_DIAL_FAILURE_KEY,\n  MAX_DIAL_QUEUE_LENGTH,\n  LAST_DIAL_SUCCESS_KEY\n} from './constants.js'\nimport { resolveMultiaddr, dnsaddrResolver } from './resolvers/index.js'\nimport { findExistingConnection } from './utils.ts'\nimport { DEFAULT_DIAL_PRIORITY } from './index.js'\nimport type { AddressSorter, ComponentLogger, Logger, Connection, ConnectionGater, Metrics, PeerId, Address, PeerStore, PeerRouting, IsDialableOptions, OpenConnectionProgressEvents, MultiaddrResolver } from '@libp2p/interface'\nimport type { OpenConnectionOptions, TransportManager } from '@libp2p/interface-internal'\nimport type { PriorityQueueJobOptions } from '@libp2p/utils'\nimport type { DNS } from '@multiformats/dns'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { ProgressOptions } from 'progress-events'\n\nexport interface PendingDialTarget {\n  resolve(value: any): void\n  reject(err: Error): void\n}\n\ninterface DialQueueJobOptions extends PriorityQueueJobOptions, ProgressOptions<OpenConnectionProgressEvents> {\n  peerId?: PeerId\n  multiaddrs: Set<string>\n}\n\ninterface DialerInit {\n  addressSorter?: AddressSorter\n  maxParallelDials?: number\n  maxDialQueueLength?: number\n  maxPeerAddrsToDial?: number\n  dialTimeout?: number\n  resolvers?: Record<string, MultiaddrResolver>\n  connections?: PeerMap<Connection[]>\n}\n\nconst defaultOptions = {\n  maxParallelDials: MAX_PARALLEL_DIALS,\n  maxDialQueueLength: MAX_DIAL_QUEUE_LENGTH,\n  maxPeerAddrsToDial: MAX_PEER_ADDRS_TO_DIAL,\n  dialTimeout: DIAL_TIMEOUT,\n  resolvers: {\n    dnsaddr: dnsaddrResolver\n  }\n}\n\ninterface DialQueueComponents {\n  peerId: PeerId\n  metrics?: Metrics\n  peerStore: PeerStore\n  peerRouting: PeerRouting\n  transportManager: TransportManager\n  connectionGater: ConnectionGater\n  logger: ComponentLogger\n  dns?: DNS\n}\n\nexport class DialQueue {\n  public queue: PriorityQueue<Connection, DialQueueJobOptions>\n  private readonly components: DialQueueComponents\n  private readonly addressSorter?: AddressSorter\n  private readonly maxPeerAddrsToDial: number\n  private readonly maxDialQueueLength: number\n  private readonly dialTimeout: number\n  private shutDownController: AbortController\n  private readonly connections: PeerMap<Connection[]>\n  private readonly log: Logger\n  private readonly resolvers: Record<string, MultiaddrResolver>\n\n  constructor (components: DialQueueComponents, init: DialerInit = {}) {\n    this.addressSorter = init.addressSorter\n    this.maxPeerAddrsToDial = init.maxPeerAddrsToDial ?? defaultOptions.maxPeerAddrsToDial\n    this.maxDialQueueLength = init.maxDialQueueLength ?? defaultOptions.maxDialQueueLength\n    this.dialTimeout = init.dialTimeout ?? defaultOptions.dialTimeout\n    this.connections = init.connections ?? new PeerMap()\n    this.log = components.logger.forComponent('libp2p:connection-manager:dial-queue')\n    this.components = components\n    this.resolvers = init.resolvers ?? defaultOptions.resolvers\n\n    this.shutDownController = new AbortController()\n    setMaxListeners(Infinity, this.shutDownController.signal)\n\n    // controls dial concurrency\n    this.queue = new PriorityQueue({\n      concurrency: init.maxParallelDials ?? defaultOptions.maxParallelDials,\n      metricName: 'libp2p_dial_queue',\n      metrics: components.metrics\n    })\n    // a started job errored\n    this.queue.addEventListener('failure', (event) => {\n      if (event.detail?.error.name !== AbortError.name) {\n        this.log.error('error in dial queue - %e', event.detail.error)\n      }\n    })\n  }\n\n  start (): void {\n    this.shutDownController = new AbortController()\n    setMaxListeners(Infinity, this.shutDownController.signal)\n  }\n\n  /**\n   * Clears any pending dials\n   */\n  stop (): void {\n    this.shutDownController.abort()\n    this.queue.abort()\n  }\n\n  /**\n   * Connects to a given peer, multiaddr or list of multiaddrs.\n   *\n   * If a peer is passed, all known multiaddrs will be tried. If a multiaddr or\n   * multiaddrs are passed only those will be dialled.\n   *\n   * Where a list of multiaddrs is passed, if any contain a peer id then all\n   * multiaddrs in the list must contain the same peer id.\n   *\n   * The dial to the first address that is successfully able to upgrade a\n   * connection will be used, all other dials will be aborted when that happens.\n   */\n  async dial (peerIdOrMultiaddr: PeerId | Multiaddr | Multiaddr[], options: OpenConnectionOptions = {}): Promise<Connection> {\n    const { peerId, multiaddrs } = getPeerAddress(peerIdOrMultiaddr)\n\n    if (peerId != null && options.force !== true) {\n      const existingConnection = findExistingConnection(peerId, this.connections.get(peerId), multiaddrs)\n\n      if (existingConnection != null) {\n        this.log('already connected to %a', existingConnection.remoteAddr)\n        options.onProgress?.(new CustomProgressEvent('dial-queue:already-connected'))\n        return existingConnection\n      }\n    }\n\n    // ready to dial, all async work finished - make sure we don't have any\n    // pending dials in progress for this peer or set of multiaddrs\n    const existingDial = this.queue.queue.find(job => {\n      if (peerId?.equals(job.options.peerId) === true) {\n        return true\n      }\n\n      // does the dial contain any of the target multiaddrs?\n      const addresses = job.options.multiaddrs\n\n      if (addresses == null) {\n        return false\n      }\n\n      for (const multiaddr of multiaddrs) {\n        if (addresses.has(multiaddr.toString())) {\n          return true\n        }\n      }\n\n      return false\n    })\n\n    if (existingDial != null) {\n      this.log('joining existing dial target for %p', peerId)\n\n      // add all multiaddrs to the dial target\n      for (const multiaddr of multiaddrs) {\n        existingDial.options.multiaddrs.add(multiaddr.toString())\n      }\n\n      options.onProgress?.(new CustomProgressEvent('dial-queue:already-in-dial-queue'))\n      return existingDial.join(options)\n    }\n\n    if (this.queue.size >= this.maxDialQueueLength) {\n      throw new DialError('Dial queue is full')\n    }\n\n    this.log('creating dial target for %p', peerId, multiaddrs.map(ma => ma.toString()))\n\n    options.onProgress?.(new CustomProgressEvent('dial-queue:add-to-dial-queue'))\n    return this.queue.add(async (options) => {\n      options.onProgress?.(new CustomProgressEvent('dial-queue:start-dial'))\n      // create abort conditions - need to do this before `calculateMultiaddrs` as\n      // we may be about to resolve a dns addr which can time out\n      const signal = anySignal([\n        this.shutDownController.signal,\n        options.signal\n      ])\n      setMaxListeners(Infinity, signal)\n\n      try {\n        return await this.dialPeer(options, signal)\n      } finally {\n        // clean up abort signals/controllers\n        signal.clear()\n      }\n    }, {\n      peerId,\n      priority: options.priority ?? DEFAULT_DIAL_PRIORITY,\n      multiaddrs: new Set(multiaddrs.map(ma => ma.toString())),\n      signal: options.signal ?? AbortSignal.timeout(this.dialTimeout),\n      onProgress: options.onProgress\n    })\n  }\n\n  private async dialPeer (options: DialQueueJobOptions, signal: AbortSignal): Promise<Connection> {\n    const peerId = options.peerId\n    const multiaddrs = options.multiaddrs\n    const failedMultiaddrs = new Set<string>()\n\n    // if we have no multiaddrs, only a peer id, set a flag so we will look the\n    // peer up in the peer routing to obtain multiaddrs\n    let forcePeerLookup = options.multiaddrs.size === 0\n\n    let dialed = 0\n    let dialIteration = 0\n    const errors: Error[] = []\n\n    this.log('starting dial to %p', peerId)\n\n    // repeat this operation in case addresses are added to the dial while we\n    // resolve multiaddrs, etc\n    while (forcePeerLookup || multiaddrs.size > 0) {\n      dialIteration++\n\n      // only perform peer lookup once\n      forcePeerLookup = false\n\n      // the addresses we will dial\n      const addrsToDial: Address[] = []\n\n      // copy the addresses into a new set\n      const addrs = new Set(options.multiaddrs)\n\n      // empty the old set - subsequent dial attempts for the same peer id may\n      // add more addresses to try\n      multiaddrs.clear()\n\n      this.log('calculating addrs to dial %p from %s', peerId, [...addrs])\n\n      // load addresses from address book, resolve and dnsaddrs, filter\n      // undialables, add peer IDs, etc\n      const calculatedAddrs = await this.calculateMultiaddrs(peerId, addrs, {\n        ...options,\n        signal\n      })\n\n      for (const addr of calculatedAddrs) {\n        // skip any addresses we have previously failed to dial\n        if (failedMultiaddrs.has(addr.multiaddr.toString())) {\n          this.log.trace('skipping previously failed multiaddr %a while dialing %p', addr.multiaddr, peerId)\n          continue\n        }\n\n        addrsToDial.push(addr)\n      }\n\n      this.log('%s dial to %p with %s', dialIteration === 1 ? 'starting' : 'continuing', peerId, addrsToDial.map(ma => ma.multiaddr.toString()))\n\n      options?.onProgress?.(new CustomProgressEvent<Address[]>('dial-queue:calculated-addresses', addrsToDial))\n\n      for (const address of addrsToDial) {\n        if (dialed === this.maxPeerAddrsToDial) {\n          this.log('dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others', dialed, options.peerId)\n\n          throw new DialError('Peer had more than maxPeerAddrsToDial')\n        }\n\n        dialed++\n\n        try {\n          // try to dial the address\n          const conn = await this.components.transportManager.dial(address.multiaddr, {\n            ...options,\n            signal\n          })\n\n          this.log('dial to %a succeeded', address.multiaddr)\n\n          // record the successful dial and the address\n          try {\n            await this.components.peerStore.merge(conn.remotePeer, {\n              multiaddrs: [\n                conn.remoteAddr\n              ],\n              metadata: {\n                [LAST_DIAL_SUCCESS_KEY]: uint8ArrayFromString(Date.now().toString())\n              }\n            })\n          } catch (err: any) {\n            this.log.error('could not update last dial failure key for %p - %e', peerId, err)\n          }\n\n          // dial successful, return the connection\n          return conn\n        } catch (err: any) {\n          this.log.error('dial failed to %a - %e', address.multiaddr, err)\n\n          // ensure we don't dial it again in this attempt\n          failedMultiaddrs.add(address.multiaddr.toString())\n\n          if (peerId != null) {\n            // record the failed dial\n            try {\n              await this.components.peerStore.merge(peerId, {\n                metadata: {\n                  [LAST_DIAL_FAILURE_KEY]: uint8ArrayFromString(Date.now().toString())\n                }\n              })\n            } catch (err: any) {\n              this.log.error('could not update last dial failure key for %p - %e', peerId, err)\n            }\n          }\n\n          // the user/dial timeout/shutdown controller signal aborted\n          if (signal.aborted) {\n            throw new TimeoutError(err.message)\n          }\n\n          errors.push(err)\n        }\n      }\n    }\n\n    if (errors.length === 1) {\n      throw errors[0]\n    }\n\n    throw new AggregateError(errors, 'All multiaddr dials failed')\n  }\n\n  // eslint-disable-next-line complexity\n  private async calculateMultiaddrs (peerId?: PeerId, multiaddrs: Set<string> = new Set<string>(), options: OpenConnectionOptions = {}): Promise<Address[]> {\n    const addrs: Address[] = [...multiaddrs].map(ma => ({\n      multiaddr: multiaddr(ma),\n      isCertified: false\n    }))\n\n    // if a peer id or multiaddr(s) with a peer id, make sure it isn't our peer id and that we are allowed to dial it\n    if (peerId != null) {\n      if (this.components.peerId.equals(peerId)) {\n        throw new DialError('Tried to dial self')\n      }\n\n      if ((await this.components.connectionGater.denyDialPeer?.(peerId)) === true) {\n        throw new DialDeniedError('The dial request is blocked by gater.allowDialPeer')\n      }\n\n      // if just a peer id was passed, load available multiaddrs for this peer\n      // from the peer store\n      if (addrs.length === 0) {\n        this.log('loading multiaddrs for %p', peerId)\n        try {\n          const peer = await this.components.peerStore.get(peerId)\n          addrs.push(...peer.addresses)\n          this.log('loaded multiaddrs for %p', peerId, addrs.map(({ multiaddr }) => multiaddr.toString()))\n        } catch (err: any) {\n          if (err.name !== 'NotFoundError') {\n            throw err\n          }\n        }\n      }\n\n      // if we still don't have any addresses for this peer, or the only\n      // addresses we have are without any routing information (e.g.\n      // `/p2p/Qmfoo`), try a lookup using the peer routing\n      if (addrs.length === 0) {\n        this.log('looking up multiaddrs for %p in the peer routing', peerId)\n\n        try {\n          const peerInfo = await this.components.peerRouting.findPeer(peerId, options)\n\n          this.log('found multiaddrs for %p in the peer routing', peerId, addrs.map(({ multiaddr }) => multiaddr.toString()))\n\n          addrs.push(...peerInfo.multiaddrs.map(multiaddr => ({\n            multiaddr,\n            isCertified: false\n          })))\n        } catch (err: any) {\n          if (err.name === 'NoPeerRoutersError') {\n            this.log('no peer routers configured', peerId)\n          } else {\n            this.log.error('looking up multiaddrs for %p in the peer routing failed - %e', peerId, err)\n          }\n        }\n      }\n    }\n\n    // resolve addresses - this can result in a one-to-many translation when\n    // dnsaddrs are resolved\n    let resolvedAddresses = (await Promise.all(\n      addrs.map(async addr => {\n        const result = await resolveMultiaddr(addr.multiaddr, this.resolvers, {\n          dns: this.components.dns,\n          log: this.log,\n          ...options\n        })\n\n        if (result.length === 1 && result[0].equals(addr.multiaddr)) {\n          return addr\n        }\n\n        return result.map(multiaddr => ({\n          multiaddr,\n          isCertified: false\n        }))\n      })\n    ))\n      .flat()\n\n    // ensure the peer id is appended to the multiaddr\n    if (peerId != null) {\n      const peerIdMultiaddr = `/p2p/${peerId.toString()}`\n      resolvedAddresses = resolvedAddresses.map(addr => {\n        const lastComponent = addr.multiaddr.getComponents().pop()\n\n        // append peer id to multiaddr if it is not already present\n        if (lastComponent?.name !== 'p2p') {\n          return {\n            multiaddr: addr.multiaddr.encapsulate(peerIdMultiaddr),\n            isCertified: addr.isCertified\n          }\n        }\n\n        return addr\n      })\n    }\n\n    const filteredAddrs = resolvedAddresses.filter(addr => {\n      // filter out any multiaddrs that we do not have transports for\n      if (this.components.transportManager.dialTransportForMultiaddr(addr.multiaddr) == null) {\n        return false\n      }\n\n      // if the resolved multiaddr has a PeerID but it's the wrong one, ignore it\n      // - this can happen with addresses like bootstrap.libp2p.io that resolve\n      // to multiple different peers\n      const addrPeerId = addr.multiaddr.getComponents().findLast(c => c.code === CODE_P2P)?.value\n      if (peerId != null && addrPeerId != null) {\n        return peerId.equals(addrPeerId)\n      }\n\n      return true\n    })\n\n    // deduplicate addresses\n    const dedupedAddrs = new Map<string, Address>()\n\n    for (const addr of filteredAddrs) {\n      const maStr = addr.multiaddr.toString()\n      const existing = dedupedAddrs.get(maStr)\n\n      if (existing != null) {\n        existing.isCertified = existing.isCertified || addr.isCertified || false\n        continue\n      }\n\n      dedupedAddrs.set(maStr, addr)\n    }\n\n    const dedupedMultiaddrs = [...dedupedAddrs.values()]\n\n    // make sure we actually have some addresses to dial\n    if (dedupedMultiaddrs.length === 0) {\n      throw new NoValidAddressesError('The dial request has no valid addresses')\n    }\n\n    const gatedAddrs: Address[] = []\n\n    for (const addr of dedupedMultiaddrs) {\n      if (this.components.connectionGater.denyDialMultiaddr != null && await this.components.connectionGater.denyDialMultiaddr(addr.multiaddr)) {\n        continue\n      }\n\n      gatedAddrs.push(addr)\n    }\n\n    const sortedGatedAddrs = this.addressSorter == null ? defaultAddressSorter(gatedAddrs) : gatedAddrs.sort(this.addressSorter)\n\n    // make sure we actually have some addresses to dial\n    if (sortedGatedAddrs.length === 0) {\n      throw new DialDeniedError('The connection gater denied all addresses in the dial request')\n    }\n\n    this.log.trace('addresses for %p before filtering', peerId ?? 'unknown peer', resolvedAddresses.map(({ multiaddr }) => multiaddr.toString()))\n    this.log.trace('addresses for %p after filtering', peerId ?? 'unknown peer', sortedGatedAddrs.map(({ multiaddr }) => multiaddr.toString()))\n\n    return sortedGatedAddrs\n  }\n\n  async isDialable (multiaddr: Multiaddr | Multiaddr[], options: IsDialableOptions = {}): Promise<boolean> {\n    if (!Array.isArray(multiaddr)) {\n      multiaddr = [multiaddr]\n    }\n\n    try {\n      const addresses = await this.calculateMultiaddrs(undefined, new Set(multiaddr.map(ma => ma.toString())), options)\n\n      if (options.runOnLimitedConnection === false) {\n        // return true if any resolved multiaddrs are not relay addresses\n        return addresses.find(addr => {\n          return !Circuit.matches(addr.multiaddr)\n        }) != null\n      }\n\n      return true\n    } catch {\n\n    }\n\n    return false\n  }\n}\n", "const objectToString = Object.prototype.toString;\n\nconst isError = value => objectToString.call(value) === '[object Error]';\n\nconst errorMessages = new Set([\n\t'network error', // Chrome\n\t'Failed to fetch', // Chrome\n\t'NetworkError when attempting to fetch resource.', // Firefox\n\t'The Internet connection appears to be offline.', // Safari 16\n\t'Network request failed', // `cross-fetch`\n\t'fetch failed', // Undici (Node.js)\n\t'terminated', // Undici (Node.js)\n\t' A network error occurred.', // Bun (WebKit)\n\t'Network connection lost', // Cloudflare Workers (fetch)\n]);\n\nexport default function isNetworkError(error) {\n\tconst isValid = error\n\t\t&& isError(error)\n\t\t&& error.name === 'TypeError'\n\t\t&& typeof error.message === 'string';\n\n\tif (!isValid) {\n\t\treturn false;\n\t}\n\n\tconst {message, stack} = error;\n\n\t// Safari 17+ has generic message but no stack for network errors\n\tif (message === 'Load failed') {\n\t\treturn stack === undefined\n\t\t\t// Sentry adds its own stack trace to the fetch error, so also check for that\n\t\t\t|| '__sentry_captured__' in error;\n\t}\n\n\t// Deno network errors start with specific text\n\tif (message.startsWith('error sending request for url')) {\n\t\treturn true;\n\t}\n\n\t// Standard network error messages\n\treturn errorMessages.has(message);\n}\n", "import isNetworkError from 'is-network-error';\n\nfunction validateRetries(retries) {\n\tif (typeof retries === 'number') {\n\t\tif (retries < 0) {\n\t\t\tthrow new TypeError('Expected `retries` to be a non-negative number.');\n\t\t}\n\n\t\tif (Number.isNaN(retries)) {\n\t\t\tthrow new TypeError('Expected `retries` to be a valid number or Infinity, got NaN.');\n\t\t}\n\t} else if (retries !== undefined) {\n\t\tthrow new TypeError('Expected `retries` to be a number or Infinity.');\n\t}\n}\n\nfunction validateNumberOption(name, value, {min = 0, allowInfinity = false} = {}) {\n\tif (value === undefined) {\n\t\treturn;\n\t}\n\n\tif (typeof value !== 'number' || Number.isNaN(value)) {\n\t\tthrow new TypeError(`Expected \\`${name}\\` to be a number${allowInfinity ? ' or Infinity' : ''}.`);\n\t}\n\n\tif (!allowInfinity && !Number.isFinite(value)) {\n\t\tthrow new TypeError(`Expected \\`${name}\\` to be a finite number.`);\n\t}\n\n\tif (value < min) {\n\t\tthrow new TypeError(`Expected \\`${name}\\` to be \\u2265 ${min}.`);\n\t}\n}\n\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\n\t\tif (message instanceof Error) {\n\t\t\tthis.originalError = message;\n\t\t\t({message} = message);\n\t\t} else {\n\t\t\tthis.originalError = new Error(message);\n\t\t\tthis.originalError.stack = this.stack;\n\t\t}\n\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\nfunction calculateDelay(retriesConsumed, options) {\n\tconst attempt = Math.max(1, retriesConsumed + 1);\n\tconst random = options.randomize ? (Math.random() + 1) : 1;\n\n\tlet timeout = Math.round(random * options.minTimeout * (options.factor ** (attempt - 1)));\n\ttimeout = Math.min(timeout, options.maxTimeout);\n\n\treturn timeout;\n}\n\nfunction calculateRemainingTime(start, max) {\n\tif (!Number.isFinite(max)) {\n\t\treturn max;\n\t}\n\n\treturn max - (performance.now() - start);\n}\n\nasync function onAttemptFailure({error, attemptNumber, retriesConsumed, startTime, options}) {\n\tconst normalizedError = error instanceof Error\n\t\t? error\n\t\t: new TypeError(`Non-error was thrown: \"${error}\". You should only throw errors.`);\n\n\tif (normalizedError instanceof AbortError) {\n\t\tthrow normalizedError.originalError;\n\t}\n\n\tconst retriesLeft = Number.isFinite(options.retries)\n\t\t? Math.max(0, options.retries - retriesConsumed)\n\t\t: options.retries;\n\n\tconst maxRetryTime = options.maxRetryTime ?? Number.POSITIVE_INFINITY;\n\n\tconst context = Object.freeze({\n\t\terror: normalizedError,\n\t\tattemptNumber,\n\t\tretriesLeft,\n\t\tretriesConsumed,\n\t});\n\n\tawait options.onFailedAttempt(context);\n\n\tif (calculateRemainingTime(startTime, maxRetryTime) <= 0) {\n\t\tthrow normalizedError;\n\t}\n\n\tconst consumeRetry = await options.shouldConsumeRetry(context);\n\n\tconst remainingTime = calculateRemainingTime(startTime, maxRetryTime);\n\n\tif (remainingTime <= 0 || retriesLeft <= 0) {\n\t\tthrow normalizedError;\n\t}\n\n\tif (normalizedError instanceof TypeError && !isNetworkError(normalizedError)) {\n\t\tif (consumeRetry) {\n\t\t\tthrow normalizedError;\n\t\t}\n\n\t\toptions.signal?.throwIfAborted();\n\t\treturn false;\n\t}\n\n\tif (!await options.shouldRetry(context)) {\n\t\tthrow normalizedError;\n\t}\n\n\tif (!consumeRetry) {\n\t\toptions.signal?.throwIfAborted();\n\t\treturn false;\n\t}\n\n\tconst delayTime = calculateDelay(retriesConsumed, options);\n\tconst finalDelay = Math.min(delayTime, remainingTime);\n\n\toptions.signal?.throwIfAborted();\n\n\tif (finalDelay > 0) {\n\t\tawait new Promise((resolve, reject) => {\n\t\t\tconst onAbort = () => {\n\t\t\t\tclearTimeout(timeoutToken);\n\t\t\t\toptions.signal?.removeEventListener('abort', onAbort);\n\t\t\t\treject(options.signal.reason);\n\t\t\t};\n\n\t\t\tconst timeoutToken = setTimeout(() => {\n\t\t\t\toptions.signal?.removeEventListener('abort', onAbort);\n\t\t\t\tresolve();\n\t\t\t}, finalDelay);\n\n\t\t\tif (options.unref) {\n\t\t\t\ttimeoutToken.unref?.();\n\t\t\t}\n\n\t\t\toptions.signal?.addEventListener('abort', onAbort, {once: true});\n\t\t});\n\t}\n\n\toptions.signal?.throwIfAborted();\n\n\treturn true;\n}\n\nexport default async function pRetry(input, options = {}) {\n\toptions = {...options};\n\n\tvalidateRetries(options.retries);\n\n\tif (Object.hasOwn(options, 'forever')) {\n\t\tthrow new Error('The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.');\n\t}\n\n\toptions.retries ??= 10;\n\toptions.factor ??= 2;\n\toptions.minTimeout ??= 1000;\n\toptions.maxTimeout ??= Number.POSITIVE_INFINITY;\n\toptions.maxRetryTime ??= Number.POSITIVE_INFINITY;\n\toptions.randomize ??= false;\n\toptions.onFailedAttempt ??= () => {};\n\toptions.shouldRetry ??= () => true;\n\toptions.shouldConsumeRetry ??= () => true;\n\n\t// Validate numeric options and normalize edge cases\n\tvalidateNumberOption('factor', options.factor, {min: 0, allowInfinity: false});\n\tvalidateNumberOption('minTimeout', options.minTimeout, {min: 0, allowInfinity: false});\n\tvalidateNumberOption('maxTimeout', options.maxTimeout, {min: 0, allowInfinity: true});\n\tvalidateNumberOption('maxRetryTime', options.maxRetryTime, {min: 0, allowInfinity: true});\n\n\t// Treat non-positive factor as 1 to avoid zero backoff or negative behavior\n\tif (!(options.factor > 0)) {\n\t\toptions.factor = 1;\n\t}\n\n\toptions.signal?.throwIfAborted();\n\n\tlet attemptNumber = 0;\n\tlet retriesConsumed = 0;\n\tconst startTime = performance.now();\n\n\twhile (Number.isFinite(options.retries) ? retriesConsumed <= options.retries : true) {\n\t\tattemptNumber++;\n\n\t\ttry {\n\t\t\toptions.signal?.throwIfAborted();\n\n\t\t\tconst result = await input(attemptNumber);\n\n\t\t\toptions.signal?.throwIfAborted();\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tif (await onAttemptFailure({\n\t\t\t\terror,\n\t\t\t\tattemptNumber,\n\t\t\t\tretriesConsumed,\n\t\t\t\tstartTime,\n\t\t\t\toptions,\n\t\t\t})) {\n\t\t\t\tretriesConsumed++;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Should not reach here, but in case it does, throw an error\n\tthrow new Error('Retry attempts exhausted without throwing an error.');\n}\n\nexport function makeRetriable(function_, options) {\n\treturn function (...arguments_) {\n\t\treturn pRetry(() => function_.apply(this, arguments_), options);\n\t};\n}\n", "import { KEEP_ALIVE } from '@libp2p/interface'\nimport { PeerQueue } from '@libp2p/utils'\nimport pRetry from 'p-retry'\nimport { MAX_PARALLEL_RECONNECTS } from './constants.js'\nimport type { ComponentLogger, Libp2pEvents, Logger, Metrics, Peer, PeerId, PeerStore, Startable } from '@libp2p/interface'\nimport type { ConnectionManager } from '@libp2p/interface-internal'\nimport type { TypedEventTarget } from 'main-event'\n\nexport interface ReconnectQueueComponents {\n  connectionManager: ConnectionManager\n  events: TypedEventTarget<Libp2pEvents>\n  peerStore: PeerStore\n  logger: ComponentLogger\n  metrics?: Metrics\n}\n\nexport interface ReconnectQueueInit {\n  retries?: number\n  retryInterval?: number\n  backoffFactor?: number\n  maxParallelReconnects?: number\n}\n\n/**\n * When peers tagged with `KEEP_ALIVE` disconnect, this component attempts to\n * redial them\n */\nexport class ReconnectQueue implements Startable {\n  private readonly log: Logger\n  private readonly queue: PeerQueue\n  private started: boolean\n  private readonly peerStore: PeerStore\n  private readonly retries: number\n  private readonly retryInterval?: number\n  private readonly backoffFactor?: number\n  private readonly connectionManager: ConnectionManager\n  private readonly events: TypedEventTarget<Libp2pEvents>\n\n  constructor (components: ReconnectQueueComponents, init: ReconnectQueueInit = {}) {\n    this.log = components.logger.forComponent('libp2p:reconnect-queue')\n    this.peerStore = components.peerStore\n    this.connectionManager = components.connectionManager\n    this.queue = new PeerQueue({\n      concurrency: init.maxParallelReconnects ?? MAX_PARALLEL_RECONNECTS,\n      metricName: 'libp2p_reconnect_queue',\n      metrics: components.metrics\n    })\n    this.started = false\n    this.retries = init.retries ?? 5\n    this.backoffFactor = init.backoffFactor\n    this.retryInterval = init.retryInterval\n    this.events = components.events\n\n    components.events.addEventListener('peer:disconnect', (evt) => {\n      this.maybeReconnect(evt.detail)\n        .catch(err => {\n          this.log.error('failed to maybe reconnect to %p - %e', evt.detail, err)\n        })\n    })\n  }\n\n  private async maybeReconnect (peerId: PeerId): Promise<void> {\n    if (!this.started) {\n      return\n    }\n\n    const peer = await this.peerStore.get(peerId)\n\n    if (!hasKeepAliveTag(peer)) {\n      return\n    }\n\n    if (this.queue.has(peerId)) {\n      return\n    }\n\n    this.queue.add(async (options) => {\n      await pRetry(async (attempt) => {\n        if (!this.started) {\n          return\n        }\n\n        try {\n          await this.connectionManager.openConnection(peerId, {\n            signal: options?.signal\n          })\n        } catch (err) {\n          this.log('reconnecting to %p attempt %d of %d failed - %e', peerId, attempt, this.retries, err)\n          throw err\n        }\n      }, {\n        signal: options?.signal,\n        retries: this.retries,\n        factor: this.backoffFactor,\n        minTimeout: this.retryInterval\n      })\n    }, {\n      peerId\n    })\n      .catch(async err => {\n        this.log.error('failed to reconnect to %p - %e', peerId, err)\n\n        const tags: Record<string, undefined> = {}\n\n        ;[...peer.tags.keys()].forEach(key => {\n          if (key.startsWith(KEEP_ALIVE)) {\n            tags[key] = undefined\n          }\n        })\n\n        await this.peerStore.merge(peerId, {\n          tags\n        })\n\n        this.events.safeDispatchEvent('peer:reconnect-failure', {\n          detail: peerId\n        })\n      })\n      .catch(async err => {\n        this.log.error('failed to remove keep-alive tag from %p - %e', peerId, err)\n      })\n  }\n\n  start (): void {\n    this.started = true\n  }\n\n  async afterStart (): Promise<void> {\n    // re-connect to any peers with the KEEP_ALIVE tag\n    void Promise.resolve()\n      .then(async () => {\n        const keepAlivePeers: Peer[] = await this.peerStore.all({\n          filters: [\n            (peer) => hasKeepAliveTag(peer)\n          ]\n        })\n\n        await Promise.all(\n          keepAlivePeers.map(async peer => {\n            await this.connectionManager.openConnection(peer.id)\n              .catch(err => {\n                this.log.error('could not open connection to keepalive peer - %e', err)\n              })\n          })\n        )\n      })\n      .catch(err => {\n        this.log.error('error reconnect to peers after start - %e', err)\n      })\n  }\n\n  stop (): void {\n    this.started = false\n    this.queue.abort()\n  }\n}\n\nfunction hasKeepAliveTag (peer: Peer): boolean {\n  for (const tag of peer.tags.keys()) {\n    if (tag.startsWith(KEEP_ALIVE)) {\n      return true\n    }\n  }\n\n  return false\n}\n", "import { ConnectionClosedError, InvalidMultiaddrError, InvalidParametersError, InvalidPeerIdError, NotStartedError, start, stop } from '@libp2p/interface'\nimport { PeerMap } from '@libp2p/peer-collections'\nimport { getNetConfig, isNetworkAddress, RateLimiter } from '@libp2p/utils'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { pEvent } from 'p-event'\nimport { CustomProgressEvent } from 'progress-events'\nimport { getPeerAddress } from '../get-peer.js'\nimport { ConnectionPruner } from './connection-pruner.js'\nimport { DIAL_TIMEOUT, INBOUND_CONNECTION_THRESHOLD, MAX_CONNECTIONS, MAX_DIAL_QUEUE_LENGTH, MAX_INCOMING_PENDING_CONNECTIONS, MAX_PARALLEL_DIALS, MAX_PEER_ADDRS_TO_DIAL } from './constants.js'\nimport { DialQueue } from './dial-queue.js'\nimport { ReconnectQueue } from './reconnect-queue.js'\nimport { dnsaddrResolver } from './resolvers/index.ts'\nimport { findExistingConnection, multiaddrToIpNet } from './utils.js'\nimport type { IpNet } from '@chainsafe/netmask'\nimport type { PendingDial, AddressSorter, Libp2pEvents, AbortOptions, ComponentLogger, Logger, Connection, MultiaddrConnection, ConnectionGater, Metrics, PeerId, PeerStore, Startable, PendingDialStatus, PeerRouting, IsDialableOptions, MultiaddrResolver, Stream, NewStreamOptions } from '@libp2p/interface'\nimport type { ConnectionManager, OpenConnectionOptions, TransportManager } from '@libp2p/interface-internal'\nimport type { JobStatus } from '@libp2p/utils'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { TypedEventTarget } from 'main-event'\n\nexport const DEFAULT_DIAL_PRIORITY = 50\n\nexport interface ConnectionManagerInit {\n  /**\n   * The maximum number of connections libp2p is willing to have before it\n   * starts pruning connections to reduce resource usage.\n   *\n   * @default 300/100\n   */\n  maxConnections?: number\n\n  /**\n   * Sort the known addresses of a peer before trying to dial, By default public\n   * addresses will be dialled before private (e.g. loopback or LAN) addresses.\n   */\n  addressSorter?: AddressSorter\n\n  /**\n   * The maximum number of dials across all peers to execute in parallel.\n   *\n   * @default 100/50\n   */\n  maxParallelDials?: number\n\n  /**\n   * The maximum size the dial queue is allowed to grow to. Promises returned\n   * when dialing peers after this limit is reached will not resolve until the\n   * queue size falls beneath this size.\n   *\n   * @default 500\n   */\n  maxDialQueueLength?: number\n\n  /**\n   * Maximum number of addresses allowed for a given peer before giving up\n   *\n   * @default 25\n   */\n  maxPeerAddrsToDial?: number\n\n  /**\n   * How long a dial attempt is allowed to take, including DNS resolution\n   * of the multiaddr, opening a socket and upgrading it to a Connection.\n   *\n   * @default 10_000\n   */\n  dialTimeout?: number\n\n  /**\n   * How many ms to wait when closing a connection if an abort signal is not\n   * passed\n   *\n   * @default 1_000\n   */\n  connectionCloseTimeout?: number\n\n  /**\n   * When a new incoming connection is opened, the upgrade process (e.g.\n   * protect, encrypt, multiplex etc) must complete within this number of ms.\n   *\n   * @default 10_000\n   */\n  inboundUpgradeTimeout?: number\n\n  /**\n   * Outbound protocol negotiation must complete within this number of ms.\n   *\n   * Does not apply if an abort signal is passed to the `.dial` or\n   * `.dialProtocol` method of the `ConnectionManager` or the `openStream`\n   * method of the `Connection`.\n   *\n   * @default 10_000\n   */\n  outboundStreamProtocolNegotiationTimeout?: number\n\n  /**\n   * Inbound protocol negotiation must complete within this number of ms\n   *\n   * @default 10_000\n   */\n  inboundStreamProtocolNegotiationTimeout?: number\n\n  /**\n   * Multiaddr resolvers to use when dialling\n   */\n  resolvers?: Record<string, MultiaddrResolver>\n\n  /**\n   * A list of multiaddrs that will always be allowed (except if they are in the\n   * deny list) to open connections to this node even if we've reached\n   * maxConnections\n   */\n  allow?: string[]\n\n  /**\n   * A list of multiaddrs that will never be allowed to open connections to\n   * this node under any circumstances\n   */\n  deny?: string[]\n\n  /**\n   * If more than this many connections are opened per second by a single\n   * host, reject subsequent connections.\n   *\n   * @default 5\n   */\n  inboundConnectionThreshold?: number\n\n  /**\n   * The maximum number of parallel incoming connections allowed that have yet\n   * to complete the connection upgrade - e.g. choosing connection encryption,\n   * muxer, etc.\n   *\n   * @default 10\n   */\n  maxIncomingPendingConnections?: number\n\n  /**\n   * When a peer tagged with `KEEP_ALIVE` disconnects, attempt to redial them\n   * this many times.\n   *\n   * @default 5\n   */\n  reconnectRetries?: number\n\n  /**\n   * When a peer tagged with `KEEP_ALIVE` disconnects, wait this long between\n   * each retry. Note this will be multiplied by `reconnectFactor` to create an\n   * increasing retry backoff.\n   *\n   * @default 1000\n   */\n  reconnectRetryInterval?: number\n\n  /**\n   * When a peer tagged with `KEEP_ALIVE` disconnects, apply this multiplication\n   * factor to the time interval between each retry.\n   *\n   * @default 2\n   */\n  reconnectBackoffFactor?: number\n\n  /**\n   * When a peers tagged with `KEEP_ALIVE` disconnect, reconnect to this many at\n   * once.\n   *\n   * @default 5\n   */\n  maxParallelReconnects?: number\n}\n\nconst defaultOptions = {\n  maxConnections: MAX_CONNECTIONS,\n  inboundConnectionThreshold: INBOUND_CONNECTION_THRESHOLD,\n  maxIncomingPendingConnections: MAX_INCOMING_PENDING_CONNECTIONS\n}\n\nexport interface DefaultConnectionManagerComponents {\n  peerId: PeerId\n  metrics?: Metrics\n  peerStore: PeerStore\n  peerRouting: PeerRouting\n  transportManager: TransportManager\n  connectionGater: ConnectionGater\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\n/**\n * Responsible for managing known connections.\n */\nexport class DefaultConnectionManager implements ConnectionManager, Startable {\n  private started: boolean\n  private readonly connections: PeerMap<Connection[]>\n  private readonly allow: IpNet[]\n  private readonly deny: IpNet[]\n  private readonly maxIncomingPendingConnections: number\n  private incomingPendingConnections: number\n  private outboundPendingConnections: number\n  private maxConnections: number\n\n  public readonly dialQueue: DialQueue\n  public readonly reconnectQueue: ReconnectQueue\n  public readonly connectionPruner: ConnectionPruner\n  private readonly inboundConnectionRateLimiter: RateLimiter\n  private readonly peerStore: PeerStore\n  private readonly metrics?: Metrics\n  private readonly events: TypedEventTarget<Libp2pEvents>\n  private readonly log: Logger\n  private readonly peerId: PeerId\n\n  constructor (components: DefaultConnectionManagerComponents, init: ConnectionManagerInit = {}) {\n    this.maxConnections = init.maxConnections ?? defaultOptions.maxConnections\n\n    if (this.maxConnections < 1) {\n      throw new InvalidParametersError('Connection Manager maxConnections must be greater than 0')\n    }\n\n    /**\n     * Map of connections per peer\n     */\n    this.connections = new PeerMap()\n\n    this.started = false\n    this.peerId = components.peerId\n    this.peerStore = components.peerStore\n    this.metrics = components.metrics\n    this.events = components.events\n    this.log = components.logger.forComponent('libp2p:connection-manager')\n\n    this.onConnect = this.onConnect.bind(this)\n    this.onDisconnect = this.onDisconnect.bind(this)\n\n    // allow/deny lists\n    this.allow = (init.allow ?? []).map(str => multiaddrToIpNet(multiaddr(str)))\n    this.deny = (init.deny ?? []).map(str => multiaddrToIpNet(multiaddr(str)))\n\n    this.incomingPendingConnections = 0\n    this.maxIncomingPendingConnections = init.maxIncomingPendingConnections ?? defaultOptions.maxIncomingPendingConnections\n    this.outboundPendingConnections = 0\n\n    // controls individual peers trying to dial us too quickly\n    this.inboundConnectionRateLimiter = new RateLimiter({\n      points: init.inboundConnectionThreshold ?? defaultOptions.inboundConnectionThreshold,\n      duration: 1\n    })\n\n    // controls what happens when we have too many connections\n    this.connectionPruner = new ConnectionPruner({\n      connectionManager: this,\n      peerStore: components.peerStore,\n      events: components.events,\n      logger: components.logger\n    }, {\n      allow: init.allow?.map(a => multiaddr(a))\n    })\n\n    this.dialQueue = new DialQueue(components, {\n      addressSorter: init.addressSorter,\n      maxParallelDials: init.maxParallelDials ?? MAX_PARALLEL_DIALS,\n      maxDialQueueLength: init.maxDialQueueLength ?? MAX_DIAL_QUEUE_LENGTH,\n      maxPeerAddrsToDial: init.maxPeerAddrsToDial ?? MAX_PEER_ADDRS_TO_DIAL,\n      dialTimeout: init.dialTimeout ?? DIAL_TIMEOUT,\n      resolvers: init.resolvers ?? {\n        dnsaddr: dnsaddrResolver\n      },\n      connections: this.connections\n    })\n\n    this.reconnectQueue = new ReconnectQueue({\n      events: components.events,\n      peerStore: components.peerStore,\n      logger: components.logger,\n      connectionManager: this\n    }, {\n      retries: init.reconnectRetries,\n      retryInterval: init.reconnectRetryInterval,\n      backoffFactor: init.reconnectBackoffFactor,\n      maxParallelReconnects: init.maxParallelReconnects\n    })\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/connection-manager'\n\n  /**\n   * Starts the Connection Manager. If Metrics are not enabled on libp2p\n   * only event loop and connection limits will be monitored.\n   */\n  async start (): Promise<void> {\n    // track inbound/outbound connections\n    this.metrics?.registerMetricGroup('libp2p_connection_manager_connections', {\n      calculate: () => {\n        const metric = {\n          inbound: 0,\n          'inbound pending': this.incomingPendingConnections,\n          outbound: 0,\n          'outbound pending': this.outboundPendingConnections\n        }\n\n        for (const conns of this.connections.values()) {\n          for (const conn of conns) {\n            metric[conn.direction]++\n          }\n        }\n\n        return metric\n      }\n    })\n\n    // track total number of streams per protocol\n    this.metrics?.registerMetricGroup('libp2p_protocol_streams_total', {\n      label: 'protocol',\n      calculate: () => {\n        const metric: Record<string, number> = {}\n\n        for (const conns of this.connections.values()) {\n          for (const conn of conns) {\n            for (const stream of conn.streams) {\n              const key = `${stream.direction} ${stream.protocol ?? 'unnegotiated'}`\n\n              metric[key] = (metric[key] ?? 0) + 1\n            }\n          }\n        }\n\n        return metric\n      }\n    })\n\n    // track 90th percentile of streams per protocol\n    this.metrics?.registerMetricGroup('libp2p_connection_manager_protocol_streams_per_connection_90th_percentile', {\n      label: 'protocol',\n      calculate: () => {\n        const allStreams: Record<string, number[]> = {}\n\n        for (const conns of this.connections.values()) {\n          for (const conn of conns) {\n            const streams: Record<string, number> = {}\n\n            for (const stream of conn.streams) {\n              const key = `${stream.direction} ${stream.protocol ?? 'unnegotiated'}`\n\n              streams[key] = (streams[key] ?? 0) + 1\n            }\n\n            for (const [protocol, count] of Object.entries(streams)) {\n              allStreams[protocol] = allStreams[protocol] ?? []\n              allStreams[protocol].push(count)\n            }\n          }\n        }\n\n        const metric: Record<string, number> = {}\n\n        for (let [protocol, counts] of Object.entries(allStreams)) {\n          counts = counts.sort((a, b) => a - b)\n\n          const index = Math.floor(counts.length * 0.9)\n          metric[protocol] = counts[index]\n        }\n\n        return metric\n      }\n    })\n\n    this.events.addEventListener('connection:open', this.onConnect)\n    this.events.addEventListener('connection:close', this.onDisconnect)\n\n    await start(\n      this.dialQueue,\n      this.reconnectQueue,\n      this.connectionPruner\n    )\n\n    this.started = true\n    this.log('started')\n  }\n\n  /**\n   * Stops the Connection Manager\n   */\n  async stop (): Promise<void> {\n    this.events.removeEventListener('connection:open', this.onConnect)\n    this.events.removeEventListener('connection:close', this.onDisconnect)\n\n    await stop(\n      this.reconnectQueue,\n      this.dialQueue,\n      this.connectionPruner\n    )\n\n    // Close all connections we're tracking\n    const tasks: Array<Promise<any>> = []\n    for (const connectionList of this.connections.values()) {\n      for (const connection of connectionList) {\n        tasks.push(\n          Promise.all([\n            pEvent(connection, 'close', {\n              signal: AbortSignal.timeout(500)\n            }),\n            connection.close({\n              signal: AbortSignal.timeout(500)\n            })\n          ])\n            .catch(err => {\n              connection.abort(err)\n            })\n        )\n      }\n    }\n\n    this.log('closing %d connections', tasks.length)\n    await Promise.all(tasks)\n    this.connections.clear()\n\n    this.log('stopped')\n  }\n\n  getMaxConnections (): number {\n    return this.maxConnections\n  }\n\n  setMaxConnections (maxConnections: number): void {\n    if (this.maxConnections < 1) {\n      throw new InvalidParametersError('Connection Manager maxConnections must be greater than 0')\n    }\n\n    let needsPrune = false\n\n    if (maxConnections < this.maxConnections) {\n      needsPrune = true\n    }\n\n    this.maxConnections = maxConnections\n\n    if (needsPrune) {\n      this.connectionPruner.maybePruneConnections()\n    }\n  }\n\n  onConnect (evt: CustomEvent<Connection>): void {\n    void this._onConnect(evt).catch(err => {\n      this.log.error('could not connect - %e', err)\n    })\n  }\n\n  /**\n   * Tracks the incoming connection and check the connection limit\n   */\n  async _onConnect (evt: CustomEvent<Connection>): Promise<void> {\n    const { detail: connection } = evt\n\n    if (!this.started) {\n      // This can happen when we are in the process of shutting down the node\n      await connection.close()\n      return\n    }\n\n    if (connection.status !== 'open') {\n      // this can happen when the remote closes the connection immediately after\n      // opening\n      return\n    }\n\n    const peerId = connection.remotePeer\n    const isNewPeer = !this.connections.has(peerId)\n    const storedConns = this.connections.get(peerId) ?? []\n    storedConns.push(connection)\n\n    this.connections.set(peerId, storedConns)\n\n    // only need to store RSA public keys, all other types are embedded in the peer id\n    if (peerId.publicKey != null && peerId.type === 'RSA') {\n      await this.peerStore.patch(peerId, {\n        publicKey: peerId.publicKey\n      })\n    }\n\n    if (isNewPeer) {\n      this.events.safeDispatchEvent('peer:connect', { detail: connection.remotePeer })\n    }\n  }\n\n  /**\n   * Removes the connection from tracking\n   */\n  onDisconnect (evt: CustomEvent<Connection>): void {\n    const { detail: connection } = evt\n    const peerId = connection.remotePeer\n    const peerConns = this.connections.get(peerId) ?? []\n\n    // remove closed connection\n    const filteredPeerConns = peerConns.filter(conn => conn.id !== connection.id)\n\n    // update peer connections\n    this.connections.set(peerId, filteredPeerConns)\n\n    if (filteredPeerConns.length === 0) {\n      // trigger disconnect event if no connections remain\n      this.log.trace('peer %p disconnected, removing connection map entry', peerId)\n      this.connections.delete(peerId)\n\n      // broadcast disconnect event\n      this.events.safeDispatchEvent('peer:disconnect', { detail: peerId })\n    }\n  }\n\n  getConnections (peerId?: PeerId): Connection[] {\n    if (peerId != null) {\n      return this.connections.get(peerId) ?? []\n    }\n\n    let conns: Connection[] = []\n\n    for (const c of this.connections.values()) {\n      conns = conns.concat(c)\n    }\n\n    return conns\n  }\n\n  getConnectionsMap (): PeerMap<Connection[]> {\n    return this.connections\n  }\n\n  async openConnection (peerIdOrMultiaddr: PeerId | Multiaddr | Multiaddr[], options: OpenConnectionOptions = {}): Promise<Connection> {\n    if (!this.started) {\n      throw new NotStartedError('Not started')\n    }\n\n    this.outboundPendingConnections++\n\n    try {\n      options.signal?.throwIfAborted()\n\n      const { peerId, multiaddrs } = getPeerAddress(peerIdOrMultiaddr)\n\n      if (this.peerId.equals(peerId)) {\n        throw new InvalidPeerIdError('Can not dial self')\n      }\n\n      if (peerId != null && options.force !== true) {\n        this.log('dial %p', peerId)\n        const existingConnection = findExistingConnection(peerId, this.getConnections(peerId), multiaddrs)\n\n        if (existingConnection != null) {\n          this.log('had an existing connection to %p as %a', peerId, existingConnection.remoteAddr)\n\n          options.onProgress?.(new CustomProgressEvent('dial-queue:already-connected'))\n          return existingConnection\n        }\n      }\n\n      const connection = await this.dialQueue.dial(peerIdOrMultiaddr, {\n        ...options,\n        priority: options.priority ?? DEFAULT_DIAL_PRIORITY\n      })\n\n      if (connection.status !== 'open') {\n        throw new ConnectionClosedError('Remote closed connection during opening')\n      }\n\n      let peerConnections = this.connections.get(connection.remotePeer)\n\n      if (peerConnections == null) {\n        peerConnections = []\n        this.connections.set(connection.remotePeer, peerConnections)\n      }\n\n      // we get notified of connections via the Upgrader emitting \"connection\"\n      // events, double check we aren't already tracking this connection before\n      // storing it\n      let trackedConnection = false\n\n      for (const conn of peerConnections) {\n        if (conn.id === connection.id) {\n          trackedConnection = true\n        }\n\n        // make sure we don't already have a connection to this multiaddr\n        if (options.force !== true && conn.id !== connection.id && conn.remoteAddr.equals(connection.remoteAddr)) {\n          connection.abort(new InvalidMultiaddrError('Duplicate multiaddr connection'))\n\n          // return the existing connection\n          return conn\n        }\n      }\n\n      if (!trackedConnection) {\n        peerConnections.push(connection)\n      }\n\n      return connection\n    } finally {\n      this.outboundPendingConnections--\n    }\n  }\n\n  async openStream (peerIdOrMultiaddr: PeerId | Multiaddr | Multiaddr[], protocol: string | string[], options: OpenConnectionOptions & NewStreamOptions = {}): Promise<Stream> {\n    const connection = await this.openConnection(peerIdOrMultiaddr, options)\n\n    return connection.newStream(protocol, options)\n  }\n\n  async closeConnections (peerId: PeerId, options: AbortOptions = {}): Promise<void> {\n    const connections = this.connections.get(peerId) ?? []\n\n    await Promise.all(\n      connections.map(async connection => {\n        try {\n          await Promise.all([\n            pEvent(connection, 'close', options),\n            connection.close(options)\n          ])\n        } catch (err: any) {\n          connection.abort(err)\n        }\n      })\n    )\n  }\n\n  acceptIncomingConnection (maConn: MultiaddrConnection): boolean {\n    // check deny list\n    const denyConnection = this.deny.some(ipNet => {\n      if (isNetworkAddress(maConn.remoteAddr)) {\n        const config = getNetConfig(maConn.remoteAddr)\n        return ipNet.contains(config.host)\n      }\n\n      return false\n    })\n\n    if (denyConnection) {\n      this.log('connection from %a refused - connection remote address was in deny list', maConn.remoteAddr)\n      return false\n    }\n\n    // check allow list\n    const allowConnection = this.allow.some(ipNet => {\n      if (isNetworkAddress(maConn.remoteAddr)) {\n        const config = getNetConfig(maConn.remoteAddr)\n        return ipNet.contains(config.host)\n      }\n\n      return true\n    })\n\n    if (allowConnection) {\n      this.incomingPendingConnections++\n\n      return true\n    }\n\n    // check pending connections\n    if (this.incomingPendingConnections === this.maxIncomingPendingConnections) {\n      this.log('connection from %a refused - incomingPendingConnections exceeded by host', maConn.remoteAddr)\n      return false\n    }\n\n    if (isNetworkAddress(maConn.remoteAddr)) {\n      const config = getNetConfig(maConn.remoteAddr)\n\n      try {\n        this.inboundConnectionRateLimiter.consume(config.host, 1)\n      } catch {\n        this.log('connection from %a refused - inboundConnectionThreshold exceeded by host %s', maConn.remoteAddr, config.host)\n        return false\n      }\n    }\n\n    if (this.getConnections().length < this.maxConnections) {\n      this.incomingPendingConnections++\n\n      return true\n    }\n\n    this.log('connection from %a refused - maxConnections exceeded', maConn.remoteAddr)\n    return false\n  }\n\n  afterUpgradeInbound (): void {\n    this.incomingPendingConnections--\n  }\n\n  getDialQueue (): PendingDial[] {\n    const statusMap: Record<JobStatus, PendingDialStatus> = {\n      queued: 'queued',\n      running: 'active',\n      errored: 'error',\n      complete: 'success'\n    }\n\n    return this.dialQueue.queue.queue.map(job => {\n      return {\n        id: job.id,\n        status: statusMap[job.status],\n        peerId: job.options.peerId,\n        multiaddrs: [...job.options.multiaddrs].map(ma => multiaddr(ma))\n      }\n    })\n  }\n\n  async isDialable (multiaddr: Multiaddr | Multiaddr[], options: IsDialableOptions = {}): Promise<boolean> {\n    return this.dialQueue.isDialable(multiaddr, options)\n  }\n}\n", "import { randomBytes } from '@libp2p/crypto'\nimport { serviceCapabilities } from '@libp2p/interface'\nimport { AdaptiveTimeout, byteStream } from '@libp2p/utils'\nimport { setMaxListeners } from 'main-event'\nimport type { ComponentLogger, Logger, Metrics, Startable } from '@libp2p/interface'\nimport type { ConnectionManager } from '@libp2p/interface-internal'\nimport type { AdaptiveTimeoutInit } from '@libp2p/utils'\n\nconst DEFAULT_PING_INTERVAL_MS = 10000\nconst PROTOCOL_VERSION = '1.0.0'\nconst PROTOCOL_NAME = 'ping'\nconst PROTOCOL_PREFIX = 'ipfs'\nconst PING_LENGTH = 32\nconst DEFAULT_ABORT_CONNECTION_ON_PING_FAILURE = true\n\nexport interface ConnectionMonitorInit {\n  /**\n   * Whether the connection monitor is enabled\n   *\n   * @default true\n   */\n  enabled?: boolean\n\n  /**\n   * How often to ping remote peers in ms\n   *\n   * @default 10000\n   */\n  pingInterval?: number\n\n  /**\n   * Timeout settings for how long the ping is allowed to take before the\n   * connection will be judged inactive and aborted.\n   *\n   * The timeout is adaptive to cope with slower networks or nodes that\n   * have changing network characteristics, such as mobile.\n   */\n  pingTimeout?: Omit<AdaptiveTimeoutInit, 'metricsName' | 'metrics'>\n\n  /**\n   * If true, any connection that fails the ping will be aborted\n   *\n   * @default true\n   */\n  abortConnectionOnPingFailure?: boolean\n\n  /**\n   * Override the ping protocol prefix\n   *\n   * @default 'ipfs'\n   */\n  protocolPrefix?: string\n}\n\nexport interface ConnectionMonitorComponents {\n  logger: ComponentLogger\n  connectionManager: ConnectionManager\n  metrics?: Metrics\n}\n\nexport class ConnectionMonitor implements Startable {\n  private readonly protocol: string\n  private readonly components: ConnectionMonitorComponents\n  private readonly log: Logger\n  private heartbeatInterval?: ReturnType<typeof setInterval>\n  private readonly pingIntervalMs: number\n  private abortController?: AbortController\n  private readonly timeout: AdaptiveTimeout\n  private readonly abortConnectionOnPingFailure: boolean\n\n  constructor (components: ConnectionMonitorComponents, init: ConnectionMonitorInit = {}) {\n    this.components = components\n    this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`\n\n    this.log = components.logger.forComponent('libp2p:connection-monitor')\n    this.pingIntervalMs = init.pingInterval ?? DEFAULT_PING_INTERVAL_MS\n    this.abortConnectionOnPingFailure = init.abortConnectionOnPingFailure ?? DEFAULT_ABORT_CONNECTION_ON_PING_FAILURE\n    this.timeout = new AdaptiveTimeout({\n      ...(init.pingTimeout ?? {}),\n      metrics: components.metrics,\n      metricName: 'libp2p_connection_monitor_ping_time_milliseconds'\n    })\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/connection-monitor'\n\n  readonly [serviceCapabilities]: string[] = [\n    '@libp2p/connection-monitor'\n  ]\n\n  start (): void {\n    this.abortController = new AbortController()\n    setMaxListeners(Infinity, this.abortController.signal)\n\n    this.heartbeatInterval = setInterval(() => {\n      this.components.connectionManager.getConnections().forEach(conn => {\n        Promise.resolve().then(async () => {\n          let start = Date.now()\n          try {\n            const signal = this.timeout.getTimeoutSignal({\n              signal: this.abortController?.signal\n            })\n            const stream = await conn.newStream(this.protocol, {\n              signal,\n              runOnLimitedConnection: true\n            })\n            const bs = byteStream(stream)\n            start = Date.now()\n\n            await Promise.all([\n              bs.write(randomBytes(PING_LENGTH), {\n                signal\n              }),\n              bs.read({\n                bytes: PING_LENGTH,\n                signal\n              })\n            ])\n\n            conn.rtt = Date.now() - start\n\n            await stream.close({\n              signal\n            })\n          } catch (err: any) {\n            if (err.name !== 'UnsupportedProtocolError') {\n              throw err\n            }\n\n            // protocol was unsupported, but that's ok as it means the remote\n            // peer was still alive. We ran multistream-select which means two\n            // round trips (e.g. 1x for the mss header, then another for the\n            // protocol) so divide the time it took by two\n            conn.rtt = (Date.now() - start) / 2\n          }\n        })\n          .catch(err => {\n            this.log.error('error during heartbeat - %e', err)\n\n            if (this.abortConnectionOnPingFailure) {\n              this.log.error('aborting connection due to ping failure')\n              conn.abort(err)\n            } else {\n              this.log('connection ping failed, but not aborting due to abortConnectionOnPingFailure flag')\n            }\n          })\n      })\n    }, this.pingIntervalMs)\n  }\n\n  stop (): void {\n    this.abortController?.abort()\n\n    if (this.heartbeatInterval != null) {\n      clearInterval(this.heartbeatInterval)\n    }\n  }\n}\n", "import { NotStartedError } from '@libp2p/interface'\nimport { PeerSet } from '@libp2p/peer-collections'\nimport merge from 'it-merge'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { NoContentRoutersError } from './errors.js'\nimport type { AbortOptions, ComponentLogger, ContentRouting, Metrics, PeerRouting, PeerStore, Provider, RoutingOptions, Startable } from '@libp2p/interface'\nimport type { CID } from 'multiformats/cid'\n\nexport interface CompoundContentRoutingInit {\n  routers: ContentRouting[]\n}\n\nexport interface CompoundContentRoutingComponents {\n  peerStore: PeerStore\n  peerRouting: PeerRouting\n  logger: ComponentLogger\n  metrics?: Metrics\n}\n\nexport class CompoundContentRouting implements ContentRouting, Startable {\n  private readonly routers: ContentRouting[]\n  private started: boolean\n  private readonly components: CompoundContentRoutingComponents\n\n  constructor (components: CompoundContentRoutingComponents, init: CompoundContentRoutingInit) {\n    this.routers = init.routers ?? []\n    this.started = false\n    this.components = components\n\n    this.findProviders = components.metrics?.traceFunction('libp2p.contentRouting.findProviders', this.findProviders.bind(this), {\n      optionsIndex: 1,\n      getAttributesFromArgs: ([cid], attrs) => {\n        return {\n          ...attrs,\n          cid: cid.toString()\n        }\n      },\n      getAttributesFromYieldedValue: (value, attrs: { providers?: string[] }) => {\n        return {\n          ...attrs,\n          providers: [...(Array.isArray(attrs.providers) ? attrs.providers : []), value.id.toString()]\n        }\n      }\n    }) ?? this.findProviders\n    this.provide = components.metrics?.traceFunction('libp2p.contentRouting.provide', this.provide.bind(this), {\n      optionsIndex: 1,\n      getAttributesFromArgs: ([cid], attrs) => {\n        return {\n          ...attrs,\n          cid: cid.toString()\n        }\n      }\n    }) ?? this.provide\n    this.cancelReprovide = components.metrics?.traceFunction('libp2p.contentRouting.cancelReprovide', this.cancelReprovide.bind(this), {\n      optionsIndex: 1,\n      getAttributesFromArgs: ([cid], attrs) => {\n        return {\n          ...attrs,\n          cid: cid.toString()\n        }\n      }\n    }) ?? this.cancelReprovide\n    this.put = components.metrics?.traceFunction('libp2p.contentRouting.put', this.put.bind(this), {\n      optionsIndex: 2,\n      getAttributesFromArgs: ([key]) => {\n        return {\n          key: uint8ArrayToString(key, 'base36')\n        }\n      }\n    }) ?? this.put\n    this.get = components.metrics?.traceFunction('libp2p.contentRouting.get', this.get.bind(this), {\n      optionsIndex: 1,\n      getAttributesFromArgs: ([key]) => {\n        return {\n          key: uint8ArrayToString(key, 'base36')\n        }\n      }\n    }) ?? this.get\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/content-routing'\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  async start (): Promise<void> {\n    this.started = true\n  }\n\n  async stop (): Promise<void> {\n    this.started = false\n  }\n\n  /**\n   * Iterates over all content routers in parallel to find providers of the given key\n   */\n  async * findProviders (key: CID, options: RoutingOptions = {}): AsyncGenerator<Provider> {\n    if (this.routers.length === 0) {\n      throw new NoContentRoutersError('No content routers available')\n    }\n\n    const self = this\n    const seen = new PeerSet()\n\n    for await (const peer of merge(\n      ...self.routers\n        .filter(router => router.findProviders instanceof Function)\n        .map(router => router.findProviders(key, options))\n    )) {\n      // the peer was yielded by a content router without multiaddrs and we\n      // failed to load them\n      if (peer == null) {\n        continue\n      }\n\n      // store the addresses for the peer if found\n      if (peer.multiaddrs.length > 0) {\n        await this.components.peerStore.merge(peer.id, {\n          multiaddrs: peer.multiaddrs\n        }, options)\n      }\n\n      // deduplicate peers\n      if (seen.has(peer.id)) {\n        continue\n      }\n\n      seen.add(peer.id)\n\n      yield peer\n    }\n  }\n\n  /**\n   * Iterates over all content routers in parallel to notify it is\n   * a provider of the given key\n   */\n  async provide (key: CID, options: AbortOptions = {}): Promise<void> {\n    if (this.routers.length === 0) {\n      throw new NoContentRoutersError('No content routers available')\n    }\n\n    await Promise.all(\n      this.routers\n        .filter(router => router.provide instanceof Function)\n        .map(async (router) => {\n          await router.provide(key, options)\n        }))\n  }\n\n  async cancelReprovide (key: CID, options: AbortOptions = {}): Promise<void> {\n    if (this.routers.length === 0) {\n      throw new NoContentRoutersError('No content routers available')\n    }\n\n    await Promise.all(\n      this.routers\n        .filter(router => router.cancelReprovide instanceof Function)\n        .map(async (router) => {\n          await router.cancelReprovide(key, options)\n        })\n    )\n  }\n\n  /**\n   * Store the given key/value pair in the available content routings\n   */\n  async put (key: Uint8Array, value: Uint8Array, options?: AbortOptions): Promise<void> {\n    if (!this.isStarted()) {\n      throw new NotStartedError()\n    }\n\n    await Promise.all(\n      this.routers\n        .filter(router => router.put instanceof Function)\n        .map(async (router) => {\n          await router.put(key, value, options)\n        })\n    )\n  }\n\n  /**\n   * Get the value to the given key.\n   * Times out after 1 minute by default.\n   */\n  async get (key: Uint8Array, options?: AbortOptions): Promise<Uint8Array> {\n    if (!this.isStarted()) {\n      throw new NotStartedError()\n    }\n\n    return Promise.any(\n      this.routers\n        .filter(router => router.get instanceof Function)\n        .map(async (router) => {\n          return router.get(key, options)\n        })\n    )\n  }\n}\n", "import { NotFoundError } from '@libp2p/interface'\nimport { createScalableCuckooFilter } from '@libp2p/utils'\nimport merge from 'it-merge'\nimport parallel from 'it-parallel'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { NoPeerRoutersError, QueriedForSelfError } from './errors.js'\nimport type { Logger, Metrics, PeerId, PeerInfo, PeerRouting, PeerStore, RoutingOptions } from '@libp2p/interface'\nimport type { ComponentLogger } from '@libp2p/logger'\n\nexport interface PeerRoutingInit {\n  routers?: PeerRouting[]\n}\n\nexport interface DefaultPeerRoutingComponents {\n  peerId: PeerId\n  peerStore: PeerStore\n  logger: ComponentLogger\n  metrics?: Metrics\n}\n\nexport class DefaultPeerRouting implements PeerRouting {\n  private readonly log: Logger\n  private readonly peerId: PeerId\n  private readonly peerStore: PeerStore\n  private readonly routers: PeerRouting[]\n\n  constructor (components: DefaultPeerRoutingComponents, init: PeerRoutingInit = {}) {\n    this.log = components.logger.forComponent('libp2p:peer-routing')\n    this.peerId = components.peerId\n    this.peerStore = components.peerStore\n    this.routers = init.routers ?? []\n\n    this.findPeer = components.metrics?.traceFunction('libp2p.peerRouting.findPeer', this.findPeer.bind(this), {\n      optionsIndex: 1,\n      getAttributesFromArgs: ([peer], attrs) => {\n        return {\n          ...attrs,\n          peer: peer.toString()\n        }\n      }\n    }) ?? this.findPeer\n    this.getClosestPeers = components.metrics?.traceFunction('libp2p.peerRouting.getClosestPeers', this.getClosestPeers.bind(this), {\n      optionsIndex: 1,\n      getAttributesFromArgs: ([key], attrs) => {\n        return {\n          ...attrs,\n          key: uint8ArrayToString(key, 'base36')\n        }\n      },\n      getAttributesFromYieldedValue: (value, attrs: { peers?: string[] }) => {\n        return {\n          ...attrs,\n          peers: [...(Array.isArray(attrs.peers) ? attrs.peers : []), value.id.toString()]\n        }\n      }\n    }) ?? this.getClosestPeers\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/peer-routing'\n\n  /**\n   * Iterates over all peer routers in parallel to find the given peer\n   */\n  async findPeer (id: PeerId, options?: RoutingOptions): Promise<PeerInfo> {\n    if (this.routers.length === 0) {\n      throw new NoPeerRoutersError('No peer routers available')\n    }\n\n    if (id.toString() === this.peerId.toString()) {\n      throw new QueriedForSelfError('Should not try to find self')\n    }\n\n    const self = this\n    const source = merge(\n      ...this.routers\n        .filter(router => router.findPeer instanceof Function)\n        .map(router => (async function * () {\n          try {\n            yield await router.findPeer(id, options)\n          } catch (err) {\n            self.log.error('router failed to find peer - %e', err)\n          }\n        })())\n    )\n\n    for await (const peer of source) {\n      if (peer == null) {\n        continue\n      }\n\n      // store the addresses for the peer if found\n      if (peer.multiaddrs.length > 0) {\n        await this.peerStore.merge(peer.id, {\n          multiaddrs: peer.multiaddrs\n        }, options)\n      }\n\n      return peer\n    }\n\n    throw new NotFoundError()\n  }\n\n  /**\n   * Attempt to find the closest peers on the network to the given key\n   */\n  async * getClosestPeers (key: Uint8Array, options: RoutingOptions = {}): AsyncGenerator<PeerInfo> {\n    if (this.routers.length === 0) {\n      throw new NoPeerRoutersError('No peer routers available')\n    }\n\n    const self = this\n    const seen = createScalableCuckooFilter(1024)\n\n    for await (const peer of parallel(\n      async function * () {\n        const source = merge(\n          ...self.routers\n            .filter(router => router.getClosestPeers instanceof Function)\n            .map(router => router.getClosestPeers(key, options))\n        )\n\n        for await (let peer of source) {\n          yield async () => {\n            // find multiaddrs if they are missing\n            if (peer.multiaddrs.length === 0) {\n              try {\n                peer = await self.findPeer(peer.id, {\n                  ...options,\n                  useCache: false\n                })\n              } catch (err) {\n                self.log.error('could not find peer multiaddrs - %e', err)\n                return\n              }\n            }\n\n            return peer\n          }\n        }\n      }()\n    )) {\n      if (peer == null) {\n        continue\n      }\n\n      // store the addresses for the peer if found\n      if (peer.multiaddrs.length > 0) {\n        await this.peerStore.merge(peer.id, {\n          multiaddrs: peer.multiaddrs\n        }, options)\n      }\n\n      // deduplicate peers\n      if (seen.has(peer.id.toMultihash().bytes)) {\n        continue\n      }\n\n      seen.add(peer.id.toMultihash().bytes)\n\n      yield peer\n    }\n  }\n}\n", "import { randomBytes } from '@libp2p/crypto'\nimport { anySignal } from 'any-signal'\nimport { TypedEventEmitter, setMaxListeners } from 'main-event'\nimport pDefer from 'p-defer'\nimport { pEvent } from 'p-event'\nimport { raceSignal } from 'race-signal'\nimport type { AbortOptions, ComponentLogger, Logger, PeerInfo, PeerRouting, Startable } from '@libp2p/interface'\nimport type { RandomWalk as RandomWalkInterface } from '@libp2p/interface-internal'\nimport type { DeferredPromise } from 'p-defer'\n\nexport interface RandomWalkComponents {\n  peerRouting: PeerRouting\n  logger: ComponentLogger\n}\n\ninterface RandomWalkEvents {\n  'walk:peer': CustomEvent<PeerInfo>\n  'walk:error': CustomEvent<Error>\n}\n\nexport class RandomWalk extends TypedEventEmitter<RandomWalkEvents> implements RandomWalkInterface, Startable {\n  private readonly peerRouting: PeerRouting\n  private readonly log: Logger\n  private walking: boolean\n  private walkers: number\n  private shutdownController: AbortController\n  private walkController?: AbortController\n  private needNext?: DeferredPromise<void>\n\n  constructor (components: RandomWalkComponents) {\n    super()\n\n    this.log = components.logger.forComponent('libp2p:random-walk')\n    this.peerRouting = components.peerRouting\n    this.walkers = 0\n    this.walking = false\n\n    // stops any in-progress walks when the node is shut down\n    this.shutdownController = new AbortController()\n    setMaxListeners(Infinity, this.shutdownController.signal)\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/random-walk'\n\n  start (): void {\n    this.shutdownController = new AbortController()\n    setMaxListeners(Infinity, this.shutdownController.signal)\n  }\n\n  stop (): void {\n    this.shutdownController.abort()\n  }\n\n  async * walk (options?: AbortOptions): AsyncGenerator<PeerInfo> {\n    if (!this.walking) {\n      // start the query that causes walk:peer events to be emitted\n      this.startWalk()\n    }\n\n    this.walkers++\n    const signal = anySignal([this.shutdownController.signal, options?.signal])\n    setMaxListeners(Infinity, signal)\n\n    try {\n      while (true) {\n        // if another consumer has paused the query, start it again\n        this.needNext?.resolve()\n        this.needNext = pDefer()\n\n        // wait for a walk:peer or walk:error event\n        const event = await pEvent<'walk:peer', CustomEvent<PeerInfo>>(this, 'walk:peer', {\n          signal,\n          rejectionEvents: [\n            'walk:error'\n          ]\n        })\n\n        yield event.detail\n      }\n    } catch (err: any) {\n      // test for walk:error event\n      if (err.detail != null) {\n        throw err.detail\n      }\n\n      throw err\n    } finally {\n      signal.clear()\n      this.walkers--\n\n      // stop the walk if no more consumers are interested\n      if (this.walkers === 0) {\n        this.walkController?.abort()\n        this.walkController = undefined\n      }\n    }\n  }\n\n  private startWalk (): void {\n    this.walking = true\n\n    // the signal for this controller will be aborted if no more random peers\n    // are required\n    this.walkController = new AbortController()\n    setMaxListeners(Infinity, this.walkController.signal)\n\n    const signal = anySignal([this.walkController.signal, this.shutdownController.signal])\n    setMaxListeners(Infinity, signal)\n\n    const start = Date.now()\n    let found = 0\n\n    Promise.resolve().then(async () => {\n      this.log('start walk')\n\n      // find peers until no more consumers are interested\n      while (this.walkers > 0) {\n        try {\n          const data = randomBytes(32)\n          let s = Date.now()\n\n          for await (const peer of this.peerRouting.getClosestPeers(data, { signal })) {\n            if (signal.aborted) {\n              this.log('aborting walk')\n            }\n\n            signal.throwIfAborted()\n\n            this.log('found peer %p after %dms for %d walkers', peer.id, Date.now() - s, this.walkers)\n            found++\n            this.safeDispatchEvent('walk:peer', {\n              detail: peer\n            })\n\n            // if we only have one consumer, pause the query until they request\n            // another random peer or they signal they are no longer interested\n            if (this.walkers === 1 && this.needNext != null) {\n              this.log('wait for need next')\n              await raceSignal(this.needNext.promise, signal)\n            }\n\n            s = Date.now()\n          }\n\n          this.log('walk iteration for %b and %d walkers finished, found %d peers', data, this.walkers, found)\n        } catch (err) {\n          this.log.error('random walk errored - %e', err)\n\n          this.safeDispatchEvent('walk:error', {\n            detail: err\n          })\n        }\n      }\n\n      this.log('no walkers left, ended walk')\n    })\n      .catch(err => {\n        this.log.error('random walk errored - %e', err)\n      })\n      .finally(() => {\n        this.log('finished walk, found %d peers after %dms', found, Date.now() - start)\n        this.walking = false\n      })\n  }\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { trackedMap } from '@libp2p/utils'\nimport { DuplicateProtocolHandlerError, UnhandledProtocolError } from './errors.js'\nimport type { IdentifyResult, Libp2pEvents, Logger, PeerUpdate, PeerId, PeerStore, Topology, StreamHandler, StreamHandlerRecord, StreamHandlerOptions, AbortOptions, Metrics, StreamMiddleware } from '@libp2p/interface'\nimport type { Registrar as RegistrarInterface } from '@libp2p/interface-internal'\nimport type { ComponentLogger } from '@libp2p/logger'\nimport type { TypedEventTarget } from 'main-event'\n\nexport const DEFAULT_MAX_INBOUND_STREAMS = 32\nexport const DEFAULT_MAX_OUTBOUND_STREAMS = 64\n\nexport interface RegistrarComponents {\n  peerId: PeerId\n  peerStore: PeerStore\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n  metrics?: Metrics\n}\n\n/**\n * Responsible for notifying registered protocols of events in the network.\n */\nexport class Registrar implements RegistrarInterface {\n  private readonly log: Logger\n  private readonly topologies: Map<string, Map<string, Topology>>\n  private readonly handlers: Map<string, StreamHandlerRecord>\n  private readonly components: RegistrarComponents\n  private readonly middleware: Map<string, StreamMiddleware[]>\n\n  constructor (components: RegistrarComponents) {\n    this.components = components\n    this.log = components.logger.forComponent('libp2p:registrar')\n    this.middleware = new Map()\n    this.topologies = new Map()\n    components.metrics?.registerMetricGroup('libp2p_registrar_topologies', {\n      calculate: () => {\n        const output: Record<string, number> = {}\n\n        for (const [key, value] of this.topologies) {\n          output[key] = value.size\n        }\n\n        return output\n      }\n    })\n    this.handlers = trackedMap({\n      name: 'libp2p_registrar_protocol_handlers',\n      metrics: components.metrics\n    })\n\n    this._onDisconnect = this._onDisconnect.bind(this)\n    this._onPeerUpdate = this._onPeerUpdate.bind(this)\n    this._onPeerIdentify = this._onPeerIdentify.bind(this)\n\n    this.components.events.addEventListener('peer:disconnect', this._onDisconnect)\n    this.components.events.addEventListener('peer:update', this._onPeerUpdate)\n    this.components.events.addEventListener('peer:identify', this._onPeerIdentify)\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/registrar'\n\n  getProtocols (): string[] {\n    return Array.from(new Set<string>([\n      ...this.handlers.keys()\n    ])).sort()\n  }\n\n  getHandler (protocol: string): StreamHandlerRecord {\n    const handler = this.handlers.get(protocol)\n\n    if (handler == null) {\n      throw new UnhandledProtocolError(`No handler registered for protocol ${protocol}`)\n    }\n\n    return handler\n  }\n\n  getTopologies (protocol: string): Topology[] {\n    const topologies = this.topologies.get(protocol)\n\n    if (topologies == null) {\n      return []\n    }\n\n    return [\n      ...topologies.values()\n    ]\n  }\n\n  /**\n   * Registers the `handler` for each protocol\n   */\n  async handle (protocol: string, handler: StreamHandler, opts?: StreamHandlerOptions): Promise<void> {\n    if (this.handlers.has(protocol) && opts?.force !== true) {\n      throw new DuplicateProtocolHandlerError(`Handler already registered for protocol ${protocol}`)\n    }\n\n    this.handlers.set(protocol, {\n      handler,\n      options: {\n        maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS,\n        maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS,\n        ...opts\n      }\n    })\n\n    // Add new protocol to self protocols in the peer store\n    await this.components.peerStore.merge(this.components.peerId, {\n      protocols: [protocol]\n    }, opts)\n  }\n\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   */\n  async unhandle (protocols: string | string[], options?: AbortOptions): Promise<void> {\n    const protocolList = Array.isArray(protocols) ? protocols : [protocols]\n\n    protocolList.forEach(protocol => {\n      this.handlers.delete(protocol)\n    })\n\n    // Update self protocols in the peer store\n    await this.components.peerStore.patch(this.components.peerId, {\n      protocols: this.getProtocols()\n    }, options)\n  }\n\n  /**\n   * Register handlers for a set of multicodecs given\n   */\n  async register (protocol: string, topology: Topology): Promise<string> {\n    if (topology == null) {\n      throw new InvalidParametersError('invalid topology')\n    }\n\n    // Create topology\n    const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`\n\n    let topologies = this.topologies.get(protocol)\n\n    if (topologies == null) {\n      topologies = new Map<string, Topology>()\n      this.topologies.set(protocol, topologies)\n    }\n\n    topologies.set(id, topology)\n\n    return id\n  }\n\n  /**\n   * Unregister topology\n   */\n  unregister (id: string): void {\n    for (const [protocol, topologies] of this.topologies.entries()) {\n      if (topologies.has(id)) {\n        topologies.delete(id)\n\n        if (topologies.size === 0) {\n          this.topologies.delete(protocol)\n        }\n      }\n    }\n  }\n\n  use (protocol: string, middleware: StreamMiddleware[]): void {\n    this.middleware.set(protocol, middleware)\n  }\n\n  unuse (protocol: string): void {\n    this.middleware.delete(protocol)\n  }\n\n  getMiddleware (protocol: string): StreamMiddleware[] {\n    return this.middleware.get(protocol) ?? []\n  }\n\n  /**\n   * Remove a disconnected peer from the record\n   */\n  async _onDisconnect (evt: CustomEvent<PeerId>): Promise<void> {\n    const remotePeer = evt.detail\n    const options = {\n      signal: AbortSignal.timeout(5_000)\n    }\n\n    try {\n      const peer = await this.components.peerStore.get(remotePeer, options)\n\n      for (const protocol of peer.protocols) {\n        const topologies = this.topologies.get(protocol)\n\n        if (topologies == null) {\n          // no topologies are interested in this protocol\n          continue\n        }\n\n        await Promise.all(\n          [...topologies.values()].map(async topology => {\n            if (topology.filter?.has(remotePeer) === false) {\n              return\n            }\n\n            topology.filter?.remove(remotePeer)\n            await topology.onDisconnect?.(remotePeer)\n          })\n        )\n      }\n    } catch (err: any) {\n      if (err.name === 'NotFoundError') {\n        // peer has not completed identify so they are not in the peer store\n        return\n      }\n\n      this.log.error('could not inform topologies of disconnecting peer %p - %e', remotePeer, err)\n    }\n  }\n\n  /**\n   * When a peer is updated, if they have removed supported protocols notify any\n   * topologies interested in the removed protocols.\n   */\n  async _onPeerUpdate (evt: CustomEvent<PeerUpdate>): Promise<void> {\n    const { peer, previous } = evt.detail\n    const removed = (previous?.protocols ?? []).filter(protocol => !peer.protocols.includes(protocol))\n\n    try {\n      for (const protocol of removed) {\n        const topologies = this.topologies.get(protocol)\n\n        if (topologies == null) {\n          // no topologies are interested in this protocol\n          continue\n        }\n\n        await Promise.all(\n          [...topologies.values()].map(async topology => {\n            if (topology.filter?.has(peer.id) === false) {\n              return\n            }\n\n            topology.filter?.remove(peer.id)\n            await topology.onDisconnect?.(peer.id)\n          })\n        )\n      }\n    } catch (err: any) {\n      this.log.error('could not inform topologies of updated peer %p - %e', peer.id, err)\n    }\n  }\n\n  /**\n   * After identify has completed and we have received the list of supported\n   * protocols, notify any topologies interested in those protocols.\n   */\n  async _onPeerIdentify (evt: CustomEvent<IdentifyResult>): Promise<void> {\n    const protocols = evt.detail.protocols\n    const connection = evt.detail.connection\n    const peerId = evt.detail.peerId\n\n    try {\n      for (const protocol of protocols) {\n        const topologies = this.topologies.get(protocol)\n\n        if (topologies == null) {\n          // no topologies are interested in this protocol\n          continue\n        }\n\n        await Promise.all(\n          [...topologies.values()].map(async topology => {\n            if (connection.limits != null && topology.notifyOnLimitedConnection !== true) {\n              return\n            }\n\n            if (topology.filter?.has(peerId) === true) {\n              return\n            }\n\n            topology.filter?.add(peerId)\n            await topology.onConnect?.(peerId, connection)\n          })\n        )\n      }\n    } catch (err: any) {\n      this.log.error('could not inform topologies of updated peer after identify %p - %e', peerId, err)\n    }\n  }\n}\n", "import { FaultTolerance, InvalidParametersError, NotStartedError } from '@libp2p/interface'\nimport { trackedMap } from '@libp2p/utils'\nimport { IP4, IP6 } from '@multiformats/multiaddr-matcher'\nimport { CustomProgressEvent } from 'progress-events'\nimport { TransportUnavailableError, UnsupportedListenAddressError, UnsupportedListenAddressesError } from './errors.js'\nimport type { Libp2pEvents, ComponentLogger, Logger, Connection, Metrics, Startable, Listener, Transport, Upgrader } from '@libp2p/interface'\nimport type { AddressManager, TransportManager, TransportManagerDialOptions } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { TypedEventTarget } from 'main-event'\n\nexport interface TransportManagerInit {\n  faultTolerance?: FaultTolerance\n}\n\nexport interface DefaultTransportManagerComponents {\n  metrics?: Metrics\n  addressManager: AddressManager\n  upgrader: Upgrader\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\ninterface IPStats {\n  success: number\n  attempts: number\n}\n\ninterface ListenStats {\n  errors: Map<string, Error>\n  ipv4: IPStats\n  ipv6: IPStats\n}\n\nexport class DefaultTransportManager implements TransportManager, Startable {\n  private readonly log: Logger\n  private readonly components: DefaultTransportManagerComponents\n  private readonly transports: Map<string, Transport>\n  private readonly listeners: Map<string, Listener[]>\n  private readonly faultTolerance: FaultTolerance\n  private started: boolean\n\n  constructor (components: DefaultTransportManagerComponents, init: TransportManagerInit = {}) {\n    this.log = components.logger.forComponent('libp2p:transports')\n    this.components = components\n    this.started = false\n    this.transports = trackedMap({\n      name: 'libp2p_transport_manager_transports',\n      metrics: this.components.metrics\n    })\n    this.listeners = trackedMap({\n      name: 'libp2p_transport_manager_listeners',\n      metrics: this.components.metrics\n    })\n    this.faultTolerance = init.faultTolerance ?? FaultTolerance.FATAL_ALL\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/transport-manager'\n\n  /**\n   * Adds a `Transport` to the manager\n   */\n  add (transport: Transport): void {\n    const tag = transport[Symbol.toStringTag]\n\n    if (tag == null) {\n      throw new InvalidParametersError('Transport must have a valid tag')\n    }\n\n    if (this.transports.has(tag)) {\n      throw new InvalidParametersError(`There is already a transport with the tag ${tag}`)\n    }\n\n    this.log('adding transport %s', tag)\n\n    this.transports.set(tag, transport)\n\n    if (!this.listeners.has(tag)) {\n      this.listeners.set(tag, [])\n    }\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  start (): void {\n    this.started = true\n  }\n\n  async afterStart (): Promise<void> {\n    // Listen on the provided transports for the provided addresses\n    const addrs = this.components.addressManager.getListenAddrs()\n\n    await this.listen(addrs)\n  }\n\n  /**\n   * Stops all listeners\n   */\n  async stop (): Promise<void> {\n    const tasks = []\n    for (const [key, listeners] of this.listeners) {\n      this.log('closing listeners for %s', key)\n      while (listeners.length > 0) {\n        const listener = listeners.pop()\n\n        if (listener == null) {\n          continue\n        }\n\n        tasks.push(listener.close())\n      }\n    }\n\n    await Promise.all(tasks)\n    this.log('all listeners closed')\n    for (const key of this.listeners.keys()) {\n      this.listeners.set(key, [])\n    }\n\n    this.started = false\n  }\n\n  /**\n   * Dials the given Multiaddr over it's supported transport\n   */\n  async dial (ma: Multiaddr, options?: TransportManagerDialOptions): Promise<Connection> {\n    const transport = this.dialTransportForMultiaddr(ma)\n\n    if (transport == null) {\n      throw new TransportUnavailableError(`No transport available for address ${String(ma)}`)\n    }\n\n    options?.onProgress?.(new CustomProgressEvent<string>('transport-manager:selected-transport', transport[Symbol.toStringTag]))\n\n    // @ts-expect-error the transport has a typed onProgress option but we\n    // can't predict what transport implementation we selected so all we can\n    // do is pass the onProgress handler in and hope for the best\n    return transport.dial(ma, {\n      ...options,\n      upgrader: this.components.upgrader\n    })\n  }\n\n  /**\n   * Returns all Multiaddr's the listeners are using\n   */\n  getAddrs (): Multiaddr[] {\n    let addrs: Multiaddr[] = []\n    for (const listeners of this.listeners.values()) {\n      for (const listener of listeners) {\n        addrs = [...addrs, ...listener.getAddrs()]\n      }\n    }\n    return addrs\n  }\n\n  /**\n   * Returns all the transports instances\n   */\n  getTransports (): Transport[] {\n    return Array.of(...this.transports.values())\n  }\n\n  /**\n   * Returns all the listener instances\n   */\n  getListeners (): Listener[] {\n    return Array.of(...this.listeners.values()).flat()\n  }\n\n  /**\n   * Finds a transport that matches the given Multiaddr\n   */\n  dialTransportForMultiaddr (ma: Multiaddr): Transport | undefined {\n    for (const transport of this.transports.values()) {\n      const addrs = transport.dialFilter([ma])\n\n      if (addrs.length > 0) {\n        return transport\n      }\n    }\n  }\n\n  /**\n   * Finds a transport that matches the given Multiaddr\n   */\n  listenTransportForMultiaddr (ma: Multiaddr): Transport | undefined {\n    for (const transport of this.transports.values()) {\n      const addrs = transport.listenFilter([ma])\n\n      if (addrs.length > 0) {\n        return transport\n      }\n    }\n  }\n\n  /**\n   * Starts listeners for each listen Multiaddr\n   */\n  async listen (addrs: Multiaddr[]): Promise<void> {\n    if (!this.isStarted()) {\n      throw new NotStartedError('Not started')\n    }\n\n    if (addrs == null || addrs.length === 0) {\n      this.log('no addresses were provided for listening, this node is dial only')\n      return\n    }\n\n    // track IPv4/IPv6 results - if we succeed on IPv4 but all IPv6 attempts\n    // fail then we are probably on a network without IPv6 support\n    const listenStats: ListenStats = {\n      errors: new Map(),\n      ipv4: {\n        success: 0,\n        attempts: 0\n      },\n      ipv6: {\n        success: 0,\n        attempts: 0\n      }\n    }\n\n    addrs.forEach(ma => {\n      listenStats.errors.set(ma.toString(), new UnsupportedListenAddressError())\n    })\n\n    const tasks: Array<Promise<void>> = []\n\n    for (const [key, transport] of this.transports.entries()) {\n      const supportedAddrs = transport.listenFilter(addrs)\n\n      // For each supported multiaddr, create a listener\n      for (const addr of supportedAddrs) {\n        this.log('creating listener for %s on %a', key, addr)\n        const listener = transport.createListener({\n          upgrader: this.components.upgrader\n        })\n\n        let listeners: Listener[] = this.listeners.get(key) ?? []\n\n        if (listeners == null) {\n          listeners = []\n          this.listeners.set(key, listeners)\n        }\n\n        listeners.push(listener)\n\n        // Track listen/close events\n        listener.addEventListener('listening', () => {\n          this.components.events.safeDispatchEvent('transport:listening', {\n            detail: listener\n          })\n        })\n        listener.addEventListener('close', () => {\n          const index = listeners.findIndex(l => l === listener)\n\n          // remove the listener\n          listeners.splice(index, 1)\n\n          this.components.events.safeDispatchEvent('transport:close', {\n            detail: listener\n          })\n        })\n\n        // track IPv4/IPv6 support\n        if (IP4.matches(addr)) {\n          listenStats.ipv4.attempts++\n        } else if (IP6.matches(addr)) {\n          listenStats.ipv6.attempts++\n        }\n\n        // We need to attempt to listen on everything\n        tasks.push(\n          listener.listen(addr)\n            .then(() => {\n              listenStats.errors.delete(addr.toString())\n\n              if (IP4.matches(addr)) {\n                listenStats.ipv4.success++\n              }\n\n              if (IP6.matches(addr)) {\n                listenStats.ipv6.success++\n              }\n            }, (err) => {\n              this.log.error('transport %s could not listen on address %a - %e', key, addr, err)\n              listenStats.errors.set(addr.toString(), err)\n              throw err\n            })\n        )\n      }\n    }\n\n    const results = await Promise.allSettled(tasks)\n\n    // listening on all addresses, all good\n    if (results.length > 0 && results.every(res => res.status === 'fulfilled')) {\n      return\n    }\n\n    // detect lack of IPv6 support on the current network - if we tried to\n    // listen on IPv4 and IPv6 addresses, and all IPv4 addresses succeeded but\n    // all IPv6 addresses fail, then we can assume there's no IPv6 here\n    if (this.ipv6Unsupported(listenStats)) {\n      this.log('all IPv4 addresses succeed but all IPv6 failed')\n      return\n    }\n\n    if (this.faultTolerance === FaultTolerance.NO_FATAL) {\n      // ok to be dial-only\n      this.log('failed to listen on any address but fault tolerance allows this')\n      return\n    }\n\n    // if a configured address was not able to be listened on, throw an error\n    throw new UnsupportedListenAddressesError(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \\`transportManager.faultTolerance\\` to NO_FATAL:\\n${\n      [...listenStats.errors.entries()].map(([addr, err]) => {\n        return `\n  ${addr}: ${`${getErrorMessage(err)}`.split('\\n').join('\\n  ')}\n`\n      }).join('')\n    }`)\n  }\n\n  private ipv6Unsupported (listenStats: ListenStats): boolean {\n    if (listenStats.ipv4.attempts === 0 || listenStats.ipv6.attempts === 0) {\n      return false\n    }\n\n    const allIpv4Succeeded = listenStats.ipv4.attempts === listenStats.ipv4.success\n    const allIpv6Failed = listenStats.ipv6.success === 0\n\n    return allIpv4Succeeded && allIpv6Failed\n  }\n\n  /**\n   * Removes the given transport from the manager.\n   * If a transport has any running listeners, they will be closed.\n   */\n  async remove (key: string): Promise<void> {\n    const listeners = this.listeners.get(key) ?? []\n    this.log.trace('removing transport %s', key)\n\n    // Close any running listeners\n    const tasks = []\n    this.log.trace('closing listeners for %s', key)\n    while (listeners.length > 0) {\n      const listener = listeners.pop()\n\n      if (listener == null) {\n        continue\n      }\n\n      tasks.push(listener.close())\n    }\n    await Promise.all(tasks)\n\n    this.transports.delete(key)\n    this.listeners.delete(key)\n  }\n\n  /**\n   * Removes all transports from the manager.\n   * If any listeners are running, they will be closed.\n   *\n   * @async\n   */\n  async removeAll (): Promise<void> {\n    const tasks = []\n    for (const key of this.transports.keys()) {\n      tasks.push(this.remove(key))\n    }\n\n    await Promise.all(tasks)\n  }\n}\n\n/**\n * Not every error has useful fields, browsers particularly often have an empty\n * string for the \"stack\" so try a few different fields here.\n */\nfunction getErrorMessage (err: Error): string {\n  if (err.stack != null && err.stack.trim() !== '') {\n    return err.stack\n  }\n\n  if (err.message != null) {\n    return err.message\n  }\n\n  return err.toString()\n}\n", "export const PROTOCOL_ID = '/multistream/1.0.0'\n\n// Conforming to go-libp2p\n// See https://github.com/multiformats/go-multistream/blob/master/multistream.go#L297\nexport const MAX_PROTOCOL_LENGTH = 1024\n", "import { InvalidMessageError } from '@libp2p/interface'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { LengthPrefixedStream } from '@libp2p/utils'\n\nconst NewLine = uint8ArrayFromString('\\n')\n\n/**\n * Read a length-prefixed string from the passed stream, stripping the final newline character\n */\nexport async function readString (reader: LengthPrefixedStream<any>, options?: AbortOptions): Promise<string> {\n  const buf = await reader.read(options)\n  const arr = buf.subarray()\n\n  if (arr.byteLength === 0 || arr[arr.length - 1] !== NewLine[0]) {\n    throw new InvalidMessageError('Missing newline')\n  }\n\n  return uint8ArrayToString(arr).trimEnd()\n}\n", "import { UnsupportedProtocolError } from '@libp2p/interface'\nimport { lpStream } from '@libp2p/utils'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { MAX_PROTOCOL_LENGTH } from './constants.js'\nimport { readString } from './multistream.js'\nimport { PROTOCOL_ID } from './index.js'\nimport type { MultistreamSelectInit } from './index.js'\nimport type { MessageStream } from '@libp2p/interface'\n\n/**\n * Negotiate a protocol to use from a list of protocols.\n *\n * @param stream - A duplex iterable stream to dial on\n * @param protocols - A list of protocols (or single protocol) to negotiate with. Protocols are attempted in order until a match is made.\n * @param options - An options object containing an AbortSignal and an optional boolean `writeBytes` - if this is true, `Uint8Array`s will be written into `duplex`, otherwise `Uint8ArrayList`s will\n * @returns A stream for the selected protocol and the protocol that was selected from the list of protocols provided to `select`.\n * @example\n *\n * ```TypeScript\n * import { pipe } from 'it-pipe'\n * import * as mss from '@libp2p/multistream-select'\n * import { Mplex } from '@libp2p/mplex'\n *\n * const muxer = new Mplex()\n * const muxedStream = muxer.newStream()\n *\n * // mss.select(protocol(s))\n * // Select from one of the passed protocols (in priority order)\n * // Returns selected stream and protocol\n * const { stream: dhtStream, protocol } = await mss.select(muxedStream, [\n *   // This might just be different versions of DHT, but could be different implementations\n *   '/ipfs-dht/2.0.0', // Most of the time this will probably just be one item.\n *   '/ipfs-dht/1.0.0'\n * ])\n *\n * // Typically this stream will be passed back to the caller of libp2p.dialProtocol\n * //\n * // ...it might then do something like this:\n * // try {\n * //   await pipe(\n * //     [uint8ArrayFromString('Some DHT data')]\n * //     dhtStream,\n * //     async source => {\n * //       for await (const chunk of source)\n * //         // DHT response data\n * //     }\n * //   )\n * // } catch (err) {\n * //   // Error in stream\n * // }\n * ```\n */\nexport async function select <Stream extends MessageStream> (stream: Stream, protocols: string | string[], options: MultistreamSelectInit = {}): Promise<string> {\n  protocols = Array.isArray(protocols) ? [...protocols] : [protocols]\n\n  if (protocols.length === 0) {\n    throw new Error('At least one protocol must be specified')\n  }\n\n  const log = stream.log.newScope('mss:select')\n  const lp = lpStream(stream, {\n    ...options,\n    maxDataLength: MAX_PROTOCOL_LENGTH\n  })\n\n  for (let i = 0; i < protocols.length; i++) {\n    const protocol = protocols[i]\n    let response: string\n\n    if (i === 0) {\n      // Write the multistream-select header along with the first protocol\n      log.trace('write [\"%s\", \"%s\"]', PROTOCOL_ID, protocol)\n      const p1 = uint8ArrayFromString(`${PROTOCOL_ID}\\n`)\n      const p2 = uint8ArrayFromString(`${protocol}\\n`)\n      await lp.writeV([p1, p2], options)\n\n      log.trace('reading multistream-select header')\n      response = await readString(lp, options)\n      log.trace('read \"%s\"', response)\n\n      // Read the protocol response if we got the protocolId in return\n      if (response !== PROTOCOL_ID) {\n        log.error('did not read multistream-select header from response')\n        break\n      }\n    } else {\n      // We haven't gotten a valid ack, try the other protocols\n      log.trace('write \"%s\"', protocol)\n      await lp.write(uint8ArrayFromString(`${protocol}\\n`), options)\n    }\n\n    log.trace('reading protocol response')\n    response = await readString(lp, options)\n    log.trace('read \"%s\"', response)\n\n    if (response === protocol) {\n      log.trace('selected \"%s\" after negotiation', response)\n      lp.unwrap()\n\n      return protocol\n    }\n  }\n\n  throw new UnsupportedProtocolError(`Protocol selection failed - could not negotiate ${protocols}`)\n}\n", "// Maximum length of the length section of the message\nexport const MAX_LENGTH_LENGTH = 8 // Varint.encode(Number.MAX_SAFE_INTEGER).length\n// Maximum length of the data section of the message\nexport const MAX_DATA_LENGTH = 1024 * 1024 * 4\n", "/**\n * The reported length of the next data message was not a positive integer\n */\nexport class InvalidMessageLengthError extends Error {\n  name = 'InvalidMessageLengthError'\n  code = 'ERR_INVALID_MSG_LENGTH'\n}\n\n/**\n * The reported length of the next data message was larger than the configured\n * max allowable value\n */\nexport class InvalidDataLengthError extends Error {\n  name = 'InvalidDataLengthError'\n  code = 'ERR_MSG_DATA_TOO_LONG'\n}\n\n/**\n * The varint used to specify the length of the next data message contained more\n * bytes than the configured max allowable value\n */\nexport class InvalidDataLengthLengthError extends Error {\n  name = 'InvalidDataLengthLengthError'\n  code = 'ERR_MSG_LENGTH_TOO_LONG'\n}\n\n/**\n * The incoming stream ended before the expected number of bytes were read\n */\nexport class UnexpectedEOFError extends Error {\n  name = 'UnexpectedEOFError'\n  code = 'ERR_UNEXPECTED_EOF'\n}\n", "export function isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n", "import * as varint from 'uint8-varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { allocUnsafe } from 'uint8arrays/alloc'\nimport { MAX_DATA_LENGTH } from './constants.js'\nimport { InvalidDataLengthError } from './errors.js'\nimport { isAsyncIterable } from './utils.js'\nimport type { EncoderOptions, LengthEncoderFunction } from './index.js'\nimport type { Source } from 'it-stream-types'\n\n// Helper function to validate the chunk size against maxDataLength\nfunction validateMaxDataLength (chunk: Uint8Array | Uint8ArrayList, maxDataLength: number): void {\n  if (chunk.byteLength > maxDataLength) {\n    throw new InvalidDataLengthError('Message length too long')\n  }\n}\n\nconst defaultEncoder: LengthEncoderFunction = (length) => {\n  const lengthLength = varint.encodingLength(length)\n  const lengthBuf = allocUnsafe(lengthLength)\n\n  varint.encode(length, lengthBuf)\n\n  defaultEncoder.bytes = lengthLength\n\n  return lengthBuf\n}\ndefaultEncoder.bytes = 0\n\nexport function encode (source: Iterable<Uint8ArrayList | Uint8Array>, options?: EncoderOptions): Generator<Uint8Array, void, undefined>\nexport function encode (source: Source<Uint8ArrayList | Uint8Array>, options?: EncoderOptions): AsyncGenerator<Uint8Array, void, undefined>\nexport function encode (source: Source<Uint8ArrayList | Uint8Array>, options?: EncoderOptions): Generator<Uint8Array, void, undefined> | AsyncGenerator<Uint8Array, void, undefined> {\n  options = options ?? {}\n\n  const encodeLength = options.lengthEncoder ?? defaultEncoder\n  const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH\n\n  function * maybeYield (chunk: Uint8Array | Uint8ArrayList): Generator<Uint8Array, void, undefined> {\n    validateMaxDataLength(chunk, maxDataLength)\n\n    // length + data\n    const length = encodeLength(chunk.byteLength)\n\n    // yield only Uint8Arrays\n    if (length instanceof Uint8Array) {\n      yield length\n    } else {\n      yield * length\n    }\n\n    // yield only Uint8Arrays\n    if (chunk instanceof Uint8Array) {\n      yield chunk\n    } else {\n      yield * chunk\n    }\n  }\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const chunk of source) {\n        yield * maybeYield(chunk)\n      }\n    })()\n  }\n\n  return (function * () {\n    for (const chunk of source) {\n      yield * maybeYield(chunk)\n    }\n  })()\n}\n\nencode.single = (chunk: Uint8ArrayList | Uint8Array, options?: EncoderOptions) => {\n  options = options ?? {}\n  const encodeLength = options.lengthEncoder ?? defaultEncoder\n  const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH\n\n  validateMaxDataLength(chunk, maxDataLength)\n\n  return new Uint8ArrayList(\n    encodeLength(chunk.byteLength),\n    chunk\n  )\n}\n", "/* eslint max-depth: [\"error\", 6] */\n\nimport * as varint from 'uint8-varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { MAX_DATA_LENGTH, MAX_LENGTH_LENGTH } from './constants.js'\nimport { InvalidDataLengthError, InvalidDataLengthLengthError, InvalidMessageLengthError, UnexpectedEOFError } from './errors.js'\nimport { isAsyncIterable } from './utils.js'\nimport type { DecoderOptions, LengthDecoderFunction } from './index.js'\nimport type { Reader } from 'it-reader'\nimport type { Source } from 'it-stream-types'\n\nenum ReadMode {\n  LENGTH,\n  DATA\n}\n\nconst defaultDecoder: LengthDecoderFunction = (buf) => {\n  const length = varint.decode(buf)\n  defaultDecoder.bytes = varint.encodingLength(length)\n\n  return length\n}\ndefaultDecoder.bytes = 0\n\nexport function decode (source: Iterable<Uint8ArrayList | Uint8Array>, options?: DecoderOptions): Generator<Uint8ArrayList, void, unknown>\nexport function decode (source: Source<Uint8ArrayList | Uint8Array>, options?: DecoderOptions): AsyncGenerator<Uint8ArrayList, void, unknown>\nexport function decode (source: Source<Uint8ArrayList | Uint8Array>, options?: DecoderOptions): Generator<Uint8ArrayList, void, unknown> | AsyncGenerator<Uint8ArrayList, void, unknown> {\n  const buffer = new Uint8ArrayList()\n  let mode = ReadMode.LENGTH\n  let dataLength = -1\n\n  const lengthDecoder = options?.lengthDecoder ?? defaultDecoder\n  const maxLengthLength = options?.maxLengthLength ?? MAX_LENGTH_LENGTH\n  const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH\n\n  function * maybeYield (): Generator<Uint8ArrayList> {\n    while (buffer.byteLength > 0) {\n      if (mode === ReadMode.LENGTH) {\n        // read length, ignore errors for short reads\n        try {\n          dataLength = lengthDecoder(buffer)\n\n          if (dataLength < 0) {\n            throw new InvalidMessageLengthError('Invalid message length')\n          }\n\n          if (dataLength > maxDataLength) {\n            throw new InvalidDataLengthError('Message length too long')\n          }\n\n          const dataLengthLength = lengthDecoder.bytes\n          buffer.consume(dataLengthLength)\n\n          if (options?.onLength != null) {\n            options.onLength(dataLength)\n          }\n\n          mode = ReadMode.DATA\n        } catch (err: any) {\n          if (err instanceof RangeError) {\n            if (buffer.byteLength > maxLengthLength) {\n              throw new InvalidDataLengthLengthError('Message length length too long')\n            }\n\n            break\n          }\n\n          throw err\n        }\n      }\n\n      if (mode === ReadMode.DATA) {\n        if (buffer.byteLength < dataLength) {\n          // not enough data, wait for more\n          break\n        }\n\n        const data = buffer.sublist(0, dataLength)\n        buffer.consume(dataLength)\n\n        if (options?.onData != null) {\n          options.onData(data)\n        }\n\n        yield data\n\n        mode = ReadMode.LENGTH\n      }\n    }\n  }\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const buf of source) {\n        buffer.append(buf)\n\n        yield * maybeYield()\n      }\n\n      if (buffer.byteLength > 0) {\n        throw new UnexpectedEOFError('Unexpected end of input')\n      }\n    })()\n  }\n\n  return (function * () {\n    for (const buf of source) {\n      buffer.append(buf)\n\n      yield * maybeYield()\n    }\n\n    if (buffer.byteLength > 0) {\n      throw new UnexpectedEOFError('Unexpected end of input')\n    }\n  })()\n}\n\ndecode.fromReader = (reader: Reader, options?: DecoderOptions) => {\n  let byteLength = 1 // Read single byte chunks until the length is known\n\n  const varByteSource = (async function * () {\n    while (true) {\n      try {\n        const { done, value } = await reader.next(byteLength)\n\n        if (done === true) {\n          return\n        }\n\n        if (value != null) {\n          yield value\n        }\n      } catch (err: any) {\n        if (err.code === 'ERR_UNDER_READ') {\n          return { done: true, value: null }\n        }\n        throw err\n      } finally {\n        // Reset the byteLength so we continue to check for varints\n        byteLength = 1\n      }\n    }\n  }())\n\n  /**\n   * Once the length has been parsed, read chunk for that length\n   */\n  const onLength = (l: number): void => { byteLength = l }\n  return decode(varByteSource, {\n    ...(options ?? {}),\n    onLength\n  })\n}\n", "import { lpStream } from '@libp2p/utils'\nimport { encode } from 'it-length-prefixed'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { MAX_PROTOCOL_LENGTH, PROTOCOL_ID } from './constants.js'\nimport { readString } from './multistream.js'\nimport type { MultistreamSelectInit } from './index.js'\nimport type { MultiaddrConnection, MessageStream } from '@libp2p/interface'\n\n/**\n * Handle multistream protocol selections for the given list of protocols.\n *\n * Note that after a protocol is handled `listener` can no longer be used.\n *\n * @param stream - A duplex iterable stream to listen on\n * @param protocols - A list of protocols (or single protocol) that this listener is able to speak.\n * @param options - an options object containing an AbortSignal and an optional boolean `writeBytes` - if this is true, `Uint8Array`s will be written into `duplex`, otherwise `Uint8ArrayList`s will\n * @returns A stream for the selected protocol and the protocol that was selected from the list of protocols provided to `select`\n * @example\n *\n * ```TypeScript\n * import { pipe } from 'it-pipe'\n * import * as mss from '@libp2p/multistream-select'\n * import { Mplex } from '@libp2p/mplex'\n *\n * const muxer = new Mplex({\n *   async onStream (muxedStream) {\n *   // mss.handle(handledProtocols)\n *   // Returns selected stream and protocol\n *   const { stream, protocol } = await mss.handle(muxedStream, [\n *     '/ipfs-dht/1.0.0',\n *     '/ipfs-bitswap/1.0.0'\n *   ])\n *\n *   // Typically here we'd call the handler function that was registered in\n *   // libp2p for the given protocol:\n *   // e.g. handlers[protocol].handler(stream)\n *   //\n *   // If protocol was /ipfs-dht/1.0.0 it might do something like this:\n *   // try {\n *   //   await pipe(\n *   //     dhtStream,\n *   //     source => (async function * () {\n *   //       for await (const chunk of source)\n *   //         // Incoming DHT data -> process and yield to respond\n *   //     })(),\n *   //     dhtStream\n *   //   )\n *   // } catch (err) {\n *   //   // Error in stream\n *   // }\n *   }\n * })\n * ```\n */\nexport async function handle <Stream extends MessageStream = MultiaddrConnection> (stream: Stream, protocols: string | string[], options: MultistreamSelectInit = {}): Promise<string> {\n  protocols = Array.isArray(protocols) ? protocols : [protocols]\n\n  const log = stream.log.newScope('mss:handle')\n\n  const lp = lpStream(stream, {\n    ...options,\n    maxDataLength: MAX_PROTOCOL_LENGTH,\n    maxLengthLength: 2 // 2 bytes is enough to length-prefix MAX_PROTOCOL_LENGTH\n  })\n\n  while (true) {\n    log.trace('reading incoming string')\n    const protocol = await readString(lp, options)\n    log.trace('read \"%s\"', protocol)\n\n    if (protocol === PROTOCOL_ID) {\n      log.trace('respond with \"%s\" for \"%s\"', PROTOCOL_ID, protocol)\n      await lp.write(uint8ArrayFromString(`${PROTOCOL_ID}\\n`), options)\n      log.trace('responded with \"%s\" for \"%s\"', PROTOCOL_ID, protocol)\n      continue\n    }\n\n    if (protocols.includes(protocol)) {\n      log.trace('respond with \"%s\" for \"%s\"', protocol, protocol)\n      await lp.write(uint8ArrayFromString(`${protocol}\\n`), options)\n      log.trace('responded with \"%s\" for \"%s\"', protocol, protocol)\n\n      lp.unwrap()\n\n      return protocol\n    }\n\n    if (protocol === 'ls') {\n      // <varint-msg-len><varint-proto-name-len><proto-name>\\n<varint-proto-name-len><proto-name>\\n\\n\n      const protos = new Uint8ArrayList(\n        ...protocols.map(p => encode.single(uint8ArrayFromString(`${p}\\n`))),\n        uint8ArrayFromString('\\n')\n      )\n\n      log.trace('respond with \"%s\" for %s', protocols, protocol)\n      await lp.write(protos, options)\n      log.trace('responded with \"%s\" for %s', protocols, protocol)\n      continue\n    }\n\n    log.trace('respond with \"na\" for \"%s\"', protocol)\n    await lp.write(uint8ArrayFromString('na\\n'), options)\n    log('responded with \"na\" for \"%s\"', protocol)\n  }\n}\n", "import { connectionSymbol, LimitedConnectionError, ConnectionClosedError, TooManyOutboundProtocolStreamsError, TooManyInboundProtocolStreamsError, StreamCloseEvent } from '@libp2p/interface'\nimport * as mss from '@libp2p/multistream-select'\nimport { CODE_P2P } from '@multiformats/multiaddr'\nimport { setMaxListeners, TypedEventEmitter } from 'main-event'\nimport { CONNECTION_CLOSE_TIMEOUT, PROTOCOL_NEGOTIATION_TIMEOUT } from './connection-manager/constants.defaults.ts'\nimport { isDirect } from './connection-manager/utils.ts'\nimport { MuxerUnavailableError } from './errors.ts'\nimport { DEFAULT_MAX_INBOUND_STREAMS, DEFAULT_MAX_OUTBOUND_STREAMS } from './registrar.ts'\nimport type { AbortOptions, Logger, MessageStreamDirection, Connection as ConnectionInterface, Stream, NewStreamOptions, PeerId, ConnectionLimits, StreamMuxer, Metrics, PeerStore, MultiaddrConnection, MessageStreamEvents, MultiaddrConnectionTimeline, ConnectionStatus, MessageStream, StreamMiddleware } from '@libp2p/interface'\nimport type { Registrar } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport interface ConnectionComponents {\n  peerStore: PeerStore\n  registrar: Registrar\n  metrics?: Metrics\n}\n\nexport interface ConnectionInit {\n  id: string\n  maConn: MultiaddrConnection\n  stream: MessageStream\n  remotePeer: PeerId\n  direction?: MessageStreamDirection\n  muxer?: StreamMuxer\n  cryptoProtocol?: string\n  limits?: ConnectionLimits\n  outboundStreamProtocolNegotiationTimeout?: number\n  inboundStreamProtocolNegotiationTimeout?: number\n  closeTimeout?: number\n}\n\n/**\n * An implementation of the js-libp2p connection.\n * Any libp2p transport should use an upgrader to return this connection.\n */\nexport class Connection extends TypedEventEmitter<MessageStreamEvents> implements ConnectionInterface {\n  public readonly id: string\n  public readonly remoteAddr: Multiaddr\n  public readonly remotePeer: PeerId\n  public direction: MessageStreamDirection\n  public timeline: MultiaddrConnectionTimeline\n  public direct: boolean\n  public multiplexer?: string\n  public encryption?: string\n  public limits?: ConnectionLimits\n  public readonly log: Logger\n\n  private readonly maConn: MultiaddrConnection\n  private readonly muxer?: StreamMuxer\n  private readonly components: ConnectionComponents\n  private readonly outboundStreamProtocolNegotiationTimeout: number\n  private readonly inboundStreamProtocolNegotiationTimeout: number\n  private readonly closeTimeout: number\n\n  constructor (components: ConnectionComponents, init: ConnectionInit) {\n    super()\n\n    this.components = components\n\n    this.id = init.id\n    this.remoteAddr = init.maConn.remoteAddr\n    this.remotePeer = init.remotePeer\n    this.direction = init.direction ?? 'outbound'\n    this.timeline = init.maConn.timeline\n    this.encryption = init.cryptoProtocol\n    this.limits = init.limits\n    this.maConn = init.maConn\n    this.log = init.maConn.log\n    this.outboundStreamProtocolNegotiationTimeout = init.outboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT\n    this.inboundStreamProtocolNegotiationTimeout = init.inboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT\n    this.closeTimeout = init.closeTimeout ?? CONNECTION_CLOSE_TIMEOUT\n    this.direct = isDirect(init.maConn.remoteAddr)\n\n    this.onIncomingStream = this.onIncomingStream.bind(this)\n\n    if (this.remoteAddr.getComponents().find(component => component.code === CODE_P2P) == null) {\n      this.remoteAddr = this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)\n    }\n\n    if (init.muxer != null) {\n      this.multiplexer = init.muxer.protocol\n      this.muxer = init.muxer\n      this.muxer.addEventListener('stream', this.onIncomingStream)\n    }\n\n    this.maConn.addEventListener('close', (evt) => {\n      this.dispatchEvent(new StreamCloseEvent(evt.local, evt.error))\n    })\n  }\n\n  readonly [Symbol.toStringTag] = 'Connection'\n\n  readonly [connectionSymbol] = true\n\n  get streams (): Stream[] {\n    return this.muxer?.streams ?? []\n  }\n\n  get status (): ConnectionStatus {\n    return this.maConn.status\n  }\n\n  /**\n   * Create a new stream over this connection\n   */\n  newStream = async (protocols: string[], options: NewStreamOptions = {}): Promise<Stream> => {\n    if (this.muxer == null) {\n      throw new MuxerUnavailableError('Connection is not multiplexed')\n    }\n\n    if (this.muxer.status !== 'open') {\n      throw new ConnectionClosedError(`The connection muxer is \"${this.muxer.status}\" and not \"open\"`)\n    }\n\n    if (this.maConn.status !== 'open') {\n      throw new ConnectionClosedError(`The connection is \"${this.status}\" and not \"open\"`)\n    }\n\n    if (this.limits != null && options?.runOnLimitedConnection !== true) {\n      throw new LimitedConnectionError('Cannot open protocol stream on limited connection')\n    }\n\n    if (!Array.isArray(protocols)) {\n      protocols = [protocols]\n    }\n\n    this.log.trace('starting new stream for protocols %s', protocols)\n    const muxedStream = await this.muxer.createStream({\n      ...options,\n\n      // most underlying transports only support negotiating a single protocol\n      // so only pass the early protocol if a single protocol has been requested\n      // otherwise fall back to mss\n      protocol: protocols.length === 1 ? protocols[0] : undefined\n    })\n    this.log.trace('started new stream %s for protocols %s', muxedStream.id, protocols)\n\n    try {\n      if (options.signal == null) {\n        muxedStream.log('no abort signal was passed while trying to negotiate protocols %s falling back to default timeout', protocols)\n\n        const signal = AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout)\n        setMaxListeners(Infinity, signal)\n\n        options = {\n          ...options,\n          signal\n        }\n      }\n\n      if (muxedStream.protocol === '') {\n        muxedStream.log.trace('selecting protocol from protocols %s', protocols)\n\n        muxedStream.protocol = await mss.select(muxedStream, protocols, options)\n\n        muxedStream.log('negotiated protocol %s', muxedStream.protocol)\n      } else {\n        muxedStream.log('pre-negotiated protocol %s', muxedStream.protocol)\n      }\n\n      const outgoingLimit = findOutgoingStreamLimit(muxedStream.protocol, this.components.registrar, options)\n      const streamCount = countStreams(muxedStream.protocol, 'outbound', this)\n\n      if (streamCount > outgoingLimit) {\n        const err = new TooManyOutboundProtocolStreamsError(`Too many outbound protocol streams for protocol \"${muxedStream.protocol}\" - ${streamCount}/${outgoingLimit}`)\n        muxedStream.abort(err)\n\n        throw err\n      }\n\n      // If a protocol stream has been successfully negotiated and is to be passed to the application,\n      // the peer store should ensure that the peer is registered with that protocol\n      await this.components.peerStore.merge(this.remotePeer, {\n        protocols: [muxedStream.protocol]\n      })\n\n      this.components.metrics?.trackProtocolStream(muxedStream)\n\n      const middleware = this.components.registrar.getMiddleware(muxedStream.protocol)\n\n      return await this.runMiddlewareChain(muxedStream, this, middleware)\n    } catch (err: any) {\n      if (muxedStream.status === 'open') {\n        muxedStream.abort(err)\n      } else {\n        this.log.error('could not create new outbound stream on connection %s %a for protocols %s - %e', this.direction === 'inbound' ? 'from' : 'to', this.remoteAddr, protocols, err)\n      }\n\n      throw err\n    }\n  }\n\n  private async onIncomingStream (evt: CustomEvent<Stream>): Promise<void> {\n    const muxedStream = evt.detail\n\n    const signal = AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout)\n    setMaxListeners(Infinity, signal)\n\n    muxedStream.log('start protocol negotiation, timing out after %dms', this.inboundStreamProtocolNegotiationTimeout)\n\n    try {\n      if (muxedStream.protocol === '') {\n        const protocols = this.components.registrar.getProtocols()\n\n        muxedStream.log.trace('selecting protocol from protocols %s', protocols)\n\n        muxedStream.protocol = await mss.handle(muxedStream, protocols, {\n          signal\n        })\n\n        muxedStream.log('negotiated protocol %s', muxedStream.protocol)\n      } else {\n        muxedStream.log('pre-negotiated protocol %s', muxedStream.protocol)\n      }\n\n      const incomingLimit = findIncomingStreamLimit(muxedStream.protocol, this.components.registrar)\n      const streamCount = countStreams(muxedStream.protocol, 'inbound', this)\n\n      if (streamCount > incomingLimit) {\n        throw new TooManyInboundProtocolStreamsError(`Too many inbound protocol streams for protocol \"${muxedStream.protocol}\" - limit ${incomingLimit}`)\n      }\n\n      // If a protocol stream has been successfully negotiated and is to be passed to the application,\n      // the peer store should ensure that the peer is registered with that protocol\n      await this.components.peerStore.merge(this.remotePeer, {\n        protocols: [muxedStream.protocol]\n      }, {\n        signal\n      })\n\n      this.components.metrics?.trackProtocolStream(muxedStream)\n\n      const { handler, options } = this.components.registrar.getHandler(muxedStream.protocol)\n\n      if (this.limits != null && options.runOnLimitedConnection !== true) {\n        throw new LimitedConnectionError('Cannot open protocol stream on limited connection')\n      }\n\n      const middleware = this.components.registrar.getMiddleware(muxedStream.protocol)\n\n      middleware.push(async (stream, connection, next) => {\n        await handler(stream, connection)\n        next(stream, connection)\n      })\n\n      await this.runMiddlewareChain(muxedStream, this, middleware)\n    } catch (err: any) {\n      muxedStream.abort(err)\n    }\n  }\n\n  private async runMiddlewareChain (stream: Stream, connection: ConnectionInterface, middleware: StreamMiddleware[]): Promise<Stream> {\n    for (let i = 0; i < middleware.length; i++) {\n      const mw = middleware[i]\n      stream.log.trace('running middleware', i, mw)\n\n      // eslint-disable-next-line no-loop-func\n      await new Promise<void>((resolve, reject) => {\n        try {\n          const result = mw(stream, connection, (s, c) => {\n            stream = s\n            connection = c\n            resolve()\n          })\n\n          if (result instanceof Promise) {\n            result.catch(reject)\n          }\n        } catch (err) {\n          reject(err)\n        }\n      })\n\n      stream.log.trace('ran middleware', i, mw)\n    }\n\n    return stream\n  }\n\n  /**\n   * Close the connection\n   */\n  async close (options: AbortOptions = {}): Promise<void> {\n    this.log('closing connection to %a', this.remoteAddr)\n\n    if (options.signal == null) {\n      const signal = AbortSignal.timeout(this.closeTimeout)\n      setMaxListeners(Infinity, signal)\n\n      options = {\n        ...options,\n        signal\n      }\n    }\n\n    await this.muxer?.close(options)\n    await this.maConn.close(options)\n  }\n\n  abort (err: Error): void {\n    this.muxer?.abort(err)\n    this.maConn.abort(err)\n  }\n}\n\nexport function createConnection (components: ConnectionComponents, init: ConnectionInit): ConnectionInterface {\n  return new Connection(components, init)\n}\n\nfunction findIncomingStreamLimit (protocol: string, registrar: Registrar): number {\n  try {\n    const { options } = registrar.getHandler(protocol)\n\n    if (options.maxInboundStreams != null) {\n      return options.maxInboundStreams\n    }\n  } catch (err: any) {\n    if (err.name !== 'UnhandledProtocolError') {\n      throw err\n    }\n  }\n\n  return DEFAULT_MAX_INBOUND_STREAMS\n}\n\nfunction findOutgoingStreamLimit (protocol: string, registrar: Registrar, options: NewStreamOptions = {}): number {\n  try {\n    const { options } = registrar.getHandler(protocol)\n\n    if (options.maxOutboundStreams != null) {\n      return options.maxOutboundStreams\n    }\n  } catch (err: any) {\n    if (err.name !== 'UnhandledProtocolError') {\n      throw err\n    }\n  }\n\n  return options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS\n}\n\nfunction countStreams (protocol: string, direction: 'inbound' | 'outbound', connection: Connection): number {\n  let streamCount = 0\n\n  connection.streams.forEach(stream => {\n    if (stream.direction === direction && stream.protocol === protocol) {\n      streamCount++\n    }\n  })\n\n  return streamCount\n}\n", "import { InvalidMultiaddrError, InvalidPeerIdError } from '@libp2p/interface'\nimport * as mss from '@libp2p/multistream-select'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { trackedMap } from '@libp2p/utils'\nimport { CODE_P2P } from '@multiformats/multiaddr'\nimport { anySignal } from 'any-signal'\nimport { setMaxListeners } from 'main-event'\nimport { CustomProgressEvent } from 'progress-events'\nimport { raceSignal } from 'race-signal'\nimport { PROTOCOL_NEGOTIATION_TIMEOUT, INBOUND_UPGRADE_TIMEOUT, CONNECTION_CLOSE_TIMEOUT } from './connection-manager/constants.js'\nimport { createConnection } from './connection.js'\nimport { ConnectionDeniedError, ConnectionInterceptedError, EncryptionFailedError, MuxerUnavailableError } from './errors.js'\nimport type { Libp2pEvents, AbortOptions, ComponentLogger, MultiaddrConnection, Connection, ConnectionProtector, ConnectionEncrypter, ConnectionGater, Metrics, PeerId, PeerStore, StreamMuxerFactory, Upgrader as UpgraderInterface, UpgraderOptions, ConnectionLimits, CounterGroup, ClearableSignal, MessageStream, SecuredConnection, StreamMuxer, UpgraderWithoutEncryptionOptions, SecureConnectionOptions } from '@libp2p/interface'\nimport type { ConnectionManager, Registrar } from '@libp2p/interface-internal'\nimport type { TypedEventTarget } from 'main-event'\n\ninterface CreateConnectionOptions {\n  id: string\n  cryptoProtocol: string\n  direction: 'inbound' | 'outbound'\n\n  /**\n   * The raw underlying connection\n   */\n  maConn: MultiaddrConnection\n\n  /**\n   * The encrypted, multiplexed connection\n   */\n  stream: MessageStream\n\n  remotePeer: PeerId\n  muxer?: StreamMuxer\n  limits?: ConnectionLimits\n  closeTimeout?: number\n}\n\nexport interface UpgraderInit {\n  connectionEncrypters: ConnectionEncrypter[]\n  streamMuxers: StreamMuxerFactory[]\n\n  /**\n   * An amount of ms by which an inbound connection upgrade must complete\n   *\n   * @default 3000\n   */\n  inboundUpgradeTimeout?: number\n\n  /**\n   * When a new incoming stream is opened on a multiplexed connection, protocol\n   * negotiation on that stream must complete within this many ms\n   *\n   * @default 2000\n   */\n  inboundStreamProtocolNegotiationTimeout?: number\n\n  /**\n   * When a new incoming stream is opened on a multiplexed connection, protocol\n   * negotiation on that stream must complete within this many ms\n   *\n   * @default 2000\n   */\n  outboundStreamProtocolNegotiationTimeout?: number\n\n  /**\n   * How long to wait before closing a connection\n   *\n   * @default 1_000\n   */\n  connectionCloseTimeout?: number\n}\n\nexport interface UpgraderComponents {\n  peerId: PeerId\n  metrics?: Metrics\n  connectionManager: ConnectionManager\n  connectionGater: ConnectionGater\n  connectionProtector?: ConnectionProtector\n  registrar: Registrar\n  peerStore: PeerStore\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\ninterface EncryptedConnection extends SecuredConnection {\n  protocol: string\n}\n\ntype ConnectionDeniedType = keyof Pick<ConnectionGater, 'denyOutboundConnection' | 'denyInboundEncryptedConnection' | 'denyOutboundEncryptedConnection' | 'denyInboundUpgradedConnection' | 'denyOutboundUpgradedConnection'>\n\nexport class Upgrader implements UpgraderInterface {\n  private readonly components: UpgraderComponents\n  private readonly connectionEncrypters: Map<string, ConnectionEncrypter>\n  private readonly streamMuxers: Map<string, StreamMuxerFactory>\n  private readonly inboundUpgradeTimeout: number\n  private readonly inboundStreamProtocolNegotiationTimeout: number\n  private readonly outboundStreamProtocolNegotiationTimeout: number\n  private readonly events: TypedEventTarget<Libp2pEvents>\n  private readonly metrics: {\n    dials?: CounterGroup<'inbound' | 'outbound'>\n    errors?: CounterGroup<'inbound' | 'outbound'>\n    inboundErrors?: CounterGroup\n    outboundErrors?: CounterGroup\n  }\n\n  private readonly connectionCloseTimeout?: number\n\n  constructor (components: UpgraderComponents, init: UpgraderInit) {\n    this.components = components\n    this.connectionEncrypters = trackedMap({\n      name: 'libp2p_upgrader_connection_encrypters',\n      metrics: this.components.metrics\n    })\n\n    init.connectionEncrypters.forEach(encrypter => {\n      this.connectionEncrypters.set(encrypter.protocol, encrypter)\n    })\n\n    this.streamMuxers = trackedMap({\n      name: 'libp2p_upgrader_stream_multiplexers',\n      metrics: this.components.metrics\n    })\n\n    init.streamMuxers.forEach(muxer => {\n      this.streamMuxers.set(muxer.protocol, muxer)\n    })\n\n    this.inboundUpgradeTimeout = init.inboundUpgradeTimeout ?? INBOUND_UPGRADE_TIMEOUT\n    this.inboundStreamProtocolNegotiationTimeout = init.inboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT\n    this.outboundStreamProtocolNegotiationTimeout = init.outboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT\n    this.connectionCloseTimeout = init.connectionCloseTimeout ?? CONNECTION_CLOSE_TIMEOUT\n    this.events = components.events\n    this.metrics = {\n      dials: components.metrics?.registerCounterGroup('libp2p_connection_manager_dials_total'),\n      errors: components.metrics?.registerCounterGroup('libp2p_connection_manager_dial_errors_total'),\n      inboundErrors: components.metrics?.registerCounterGroup('libp2p_connection_manager_dials_inbound_errors_total'),\n      outboundErrors: components.metrics?.registerCounterGroup('libp2p_connection_manager_dials_outbound_errors_total')\n    }\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/upgrader'\n\n  async shouldBlockConnection (connectionType: 'denyInboundConnection', maConn: MultiaddrConnection): Promise<void>\n  async shouldBlockConnection (connectionType: ConnectionDeniedType, remotePeer: PeerId, maConn: MultiaddrConnection): Promise<void>\n  async shouldBlockConnection (method: ConnectionDeniedType | 'denyInboundConnection', ...args: any[]): Promise<void> {\n    const denyOperation: any = this.components.connectionGater[method]\n\n    if (denyOperation == null) {\n      return\n    }\n\n    const result = await denyOperation.apply(this.components.connectionGater, args)\n\n    if (result === true) {\n      throw new ConnectionInterceptedError(`The multiaddr connection is blocked by gater.${method}`)\n    }\n  }\n\n  createInboundAbortSignal (signal: AbortSignal): ClearableSignal {\n    const output = anySignal([\n      AbortSignal.timeout(this.inboundUpgradeTimeout),\n      signal\n    ])\n    setMaxListeners(Infinity, output)\n\n    return output\n  }\n\n  /**\n   * Upgrades an inbound connection\n   */\n  async upgradeInbound (maConn: MultiaddrConnection, opts: UpgraderOptions): Promise<void>\n  async upgradeInbound (maConn: MultiaddrConnection, opts: UpgraderWithoutEncryptionOptions): Promise<void>\n  async upgradeInbound (maConn: MultiaddrConnection, opts: UpgraderOptions | UpgraderWithoutEncryptionOptions): Promise<void> {\n    let accepted = false\n\n    // always apply upgrade timeout for incoming upgrades\n    const signal = this.createInboundAbortSignal(opts.signal)\n\n    try {\n      this.metrics.dials?.increment({\n        inbound: true\n      })\n\n      accepted = this.components.connectionManager.acceptIncomingConnection(maConn)\n\n      if (!accepted) {\n        throw new ConnectionDeniedError('Connection denied')\n      }\n\n      await raceSignal(this.shouldBlockConnection('denyInboundConnection', maConn), signal)\n\n      await this._performUpgrade(maConn, 'inbound', {\n        ...opts,\n        signal\n      })\n    } catch (err: any) {\n      this.metrics.errors?.increment({\n        inbound: true\n      })\n      this.metrics.inboundErrors?.increment({\n        [err.name ?? 'Error']: true\n      })\n\n      throw err\n    } finally {\n      signal.clear()\n\n      if (accepted) {\n        this.components.connectionManager.afterUpgradeInbound()\n      }\n    }\n  }\n\n  /**\n   * Upgrades an outbound connection\n   */\n  async upgradeOutbound (maConn: MultiaddrConnection, opts: UpgraderOptions): Promise<Connection>\n  async upgradeOutbound (maConn: MultiaddrConnection, opts: UpgraderWithoutEncryptionOptions): Promise<Connection>\n  async upgradeOutbound (maConn: MultiaddrConnection, opts: UpgraderOptions | UpgraderWithoutEncryptionOptions): Promise<Connection> {\n    try {\n      this.metrics.dials?.increment({\n        outbound: true\n      })\n\n      const idStr = maConn.remoteAddr.getComponents().findLast(c => c.code === CODE_P2P)?.value\n      let remotePeerId: PeerId | undefined\n\n      if (idStr != null) {\n        remotePeerId = peerIdFromString(idStr)\n        await raceSignal(this.shouldBlockConnection('denyOutboundConnection', remotePeerId, maConn), opts.signal)\n      }\n\n      let direction: 'inbound' | 'outbound' = 'outbound'\n\n      // act as the multistream-select server if we are not to be the initiator\n      if (opts.initiator === false) {\n        direction = 'inbound'\n      }\n\n      return await this._performUpgrade(maConn, direction, opts)\n    } catch (err: any) {\n      this.metrics.errors?.increment({\n        outbound: true\n      })\n      this.metrics.outboundErrors?.increment({\n        [err.name ?? 'Error']: true\n      })\n\n      throw err\n    }\n  }\n\n  private async _performUpgrade (maConn: MultiaddrConnection, direction: 'inbound' | 'outbound', opts: UpgraderOptions | UpgraderWithoutEncryptionOptions): Promise<Connection> {\n    let stream: MessageStream = maConn\n    let remotePeer: PeerId\n    let muxerFactory: StreamMuxerFactory | undefined\n    let muxer: StreamMuxer | undefined\n    let cryptoProtocol\n\n    const id = `${(parseInt(String(Math.random() * 1e9))).toString(36)}${Date.now()}`\n    maConn.log = maConn.log.newScope(`${direction}:${id}`)\n\n    this.components.metrics?.trackMultiaddrConnection(maConn)\n\n    maConn.log.trace('starting the %s connection upgrade', direction)\n\n    // Protect\n    if (opts?.skipProtection !== true) {\n      const protector = this.components.connectionProtector\n\n      if (protector != null) {\n        maConn.log('protecting the %s connection', direction)\n        stream = await protector.protect(stream, opts)\n      }\n    }\n\n    try {\n      // Encrypt the connection\n      if (isEncryptionSkipped(opts)) {\n        if (opts.remotePeer == null) {\n          throw new InvalidMultiaddrError(`${direction} connection that skipped encryption must have a peer id`)\n        }\n\n        cryptoProtocol = 'native'\n        remotePeer = opts.remotePeer\n      } else {\n        const peerIdString = maConn.remoteAddr.getComponents().findLast(c => c.code === CODE_P2P)?.value\n        let remotePeerFromMultiaddr: PeerId | undefined\n\n        if (peerIdString != null) {\n          remotePeerFromMultiaddr = peerIdFromString(peerIdString)\n        }\n\n        opts?.onProgress?.(new CustomProgressEvent(`upgrader:encrypt-${direction}-connection`));\n\n        ({\n          connection: stream,\n          remotePeer,\n          protocol: cryptoProtocol,\n          streamMuxer: muxerFactory\n        } = await (direction === 'inbound'\n          ? this._encryptInbound(stream, {\n            ...opts,\n            remotePeer: remotePeerFromMultiaddr\n          })\n          : this._encryptOutbound(stream, {\n            ...opts,\n            remotePeer: remotePeerFromMultiaddr\n          })\n        ))\n      }\n\n      // this can happen if we dial a multiaddr without a peer id, we only find\n      // out the identity of the remote after the connection is encrypted\n      if (remotePeer.equals(this.components.peerId)) {\n        const err = new InvalidPeerIdError('Can not dial self')\n        maConn.abort(err)\n        throw err\n      }\n\n      // stream.pause()\n      await this.shouldBlockConnection(direction === 'inbound' ? 'denyInboundEncryptedConnection' : 'denyOutboundEncryptedConnection', remotePeer, maConn)\n      // stream.resume()\n\n      if (opts?.muxerFactory != null) {\n        muxerFactory = opts.muxerFactory\n      } else if (muxerFactory == null && this.streamMuxers.size > 0) {\n        opts?.onProgress?.(new CustomProgressEvent(`upgrader:multiplex-${direction}-connection`))\n\n        // Multiplex the connection\n        muxerFactory = await (direction === 'inbound'\n          ? this._multiplexInbound(stream, this.streamMuxers, opts)\n          : this._multiplexOutbound(stream, this.streamMuxers, opts))\n      }\n    } catch (err: any) {\n      maConn.log.error('failed to upgrade %s connection %s %a - %e', direction, direction === 'inbound' ? 'from' : 'to', maConn.remoteAddr, err)\n      throw err\n    }\n\n    // create the connection muxer if one is configured\n    if (muxerFactory != null) {\n      maConn.log('create muxer %s', muxerFactory.protocol)\n      muxer = muxerFactory.createStreamMuxer(stream)\n    }\n\n    // stream.pause()\n    await this.shouldBlockConnection(direction === 'inbound' ? 'denyInboundUpgradedConnection' : 'denyOutboundUpgradedConnection', remotePeer, maConn)\n\n    const conn = this._createConnection({\n      id,\n      cryptoProtocol,\n      direction,\n      maConn,\n      stream,\n      muxer,\n      remotePeer,\n      limits: opts?.limits,\n      closeTimeout: this.connectionCloseTimeout\n    })\n\n    conn.log('successfully upgraded connection')\n\n    // stream.resume()\n\n    return conn\n  }\n\n  /**\n   * A convenience method for generating a new `Connection`\n   */\n  _createConnection (opts: CreateConnectionOptions): Connection {\n    // Create the connection\n    const connection = createConnection(this.components, {\n      ...opts,\n      outboundStreamProtocolNegotiationTimeout: this.outboundStreamProtocolNegotiationTimeout,\n      inboundStreamProtocolNegotiationTimeout: this.inboundStreamProtocolNegotiationTimeout\n    })\n\n    connection.addEventListener('close', () => {\n      this.events.safeDispatchEvent('connection:close', {\n        detail: connection\n      })\n    })\n\n    this.events.safeDispatchEvent('connection:open', {\n      detail: connection\n    })\n\n    return connection\n  }\n\n  /**\n   * Attempts to encrypt the incoming `connection` with the provided `cryptos`\n   */\n  async _encryptInbound (connection: MessageStream, options?: SecureConnectionOptions): Promise<EncryptedConnection> {\n    const protocols = Array.from(this.connectionEncrypters.keys())\n\n    try {\n      const protocol = await mss.handle(connection, protocols, options)\n      const encrypter = this.connectionEncrypters.get(protocol)\n\n      if (encrypter == null) {\n        throw new EncryptionFailedError(`no crypto module found for ${protocol}`)\n      }\n\n      connection.log('encrypting inbound connection using %s', protocol)\n\n      return {\n        ...await encrypter.secureInbound(connection, options),\n        protocol\n      }\n    } catch (err: any) {\n      throw new EncryptionFailedError(err.message)\n    }\n  }\n\n  /**\n   * Attempts to encrypt the given `connection` with the provided connection encrypters.\n   * The first `ConnectionEncrypter` module to succeed will be used\n   */\n  async _encryptOutbound (connection: MessageStream, options?: SecureConnectionOptions): Promise<EncryptedConnection> {\n    const protocols = Array.from(this.connectionEncrypters.keys())\n\n    try {\n      connection.log.trace('selecting encrypter from %s', protocols)\n\n      const protocol = await mss.select(connection, protocols, options)\n      const encrypter = this.connectionEncrypters.get(protocol)\n\n      if (encrypter == null) {\n        throw new EncryptionFailedError(`no crypto module found for ${protocol}`)\n      }\n\n      connection.log('encrypting outbound connection using %s', protocol)\n\n      return {\n        ...await encrypter.secureOutbound(connection, options),\n        protocol\n      }\n    } catch (err: any) {\n      throw new EncryptionFailedError(err.message)\n    }\n  }\n\n  /**\n   * Selects one of the given muxers via multistream-select. That\n   * muxer will be used for all future streams on the connection.\n   */\n  async _multiplexOutbound (maConn: MessageStream, muxers: Map<string, StreamMuxerFactory>, options: AbortOptions): Promise<StreamMuxerFactory> {\n    const protocols = Array.from(muxers.keys())\n    maConn.log('outbound selecting muxer %s', protocols)\n\n    try {\n      maConn.log.trace('selecting stream muxer from %s', protocols)\n      const protocol = await mss.select(maConn, protocols, options)\n      const muxerFactory = muxers.get(protocol)\n\n      if (muxerFactory == null) {\n        throw new MuxerUnavailableError(`No muxer configured for protocol \"${protocol}\"`)\n      }\n\n      maConn.log('selected %s as muxer protocol', protocol)\n      return muxerFactory\n    } catch (err: any) {\n      maConn.log.error('error multiplexing outbound connection - %e', err)\n      throw new MuxerUnavailableError(String(err))\n    }\n  }\n\n  /**\n   * Registers support for one of the given muxers via multistream-select. The\n   * selected muxer will be used for all future streams on the connection.\n   */\n  async _multiplexInbound (maConn: MessageStream, muxers: Map<string, StreamMuxerFactory>, options: AbortOptions): Promise<StreamMuxerFactory> {\n    const protocols = Array.from(muxers.keys())\n    maConn.log('inbound handling muxers %s', protocols)\n    try {\n      maConn.log.trace('selecting stream muxer from %s', protocols)\n      const protocol = await mss.handle(maConn, protocols, options)\n      const muxerFactory = muxers.get(protocol)\n\n      if (muxerFactory == null) {\n        throw new MuxerUnavailableError(`No muxer configured for protocol \"${protocol}\"`)\n      }\n\n      maConn.log('selected %s as muxer protocol', protocol)\n      return muxerFactory\n    } catch (err: any) {\n      maConn.log.error('error multiplexing inbound connection - %e', err)\n      throw err\n    }\n  }\n\n  getConnectionEncrypters (): Map<string, ConnectionEncrypter<unknown>> {\n    return this.connectionEncrypters\n  }\n\n  getStreamMuxers (): Map<string, StreamMuxerFactory> {\n    return this.streamMuxers\n  }\n}\n\nfunction isEncryptionSkipped (opts?: any): opts is UpgraderWithoutEncryptionOptions {\n  return opts.skipEncryption === true\n}\n", "export const version = '3.1.2'\nexport const name = 'js-libp2p'\n", "import * as pkg from './version.js'\n\nexport function userAgent (name?: string, version?: string): string {\n  return `${name ?? pkg.name}/${version ?? pkg.version} browser/${globalThis.navigator.userAgent}`\n}\n", "import { publicKeyFromProtobuf } from '@libp2p/crypto/keys'\nimport { contentRoutingSymbol, peerDiscoverySymbol, peerRoutingSymbol, InvalidParametersError } from '@libp2p/interface'\nimport { defaultLogger } from '@libp2p/logger'\nimport { PeerSet } from '@libp2p/peer-collections'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { persistentPeerStore } from '@libp2p/peer-store'\nimport { CODE_P2P, isMultiaddr } from '@multiformats/multiaddr'\nimport { MemoryDatastore } from 'datastore-core/memory'\nimport { TypedEventEmitter, setMaxListeners } from 'main-event'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { AddressManager } from './address-manager/index.js'\nimport { checkServiceDependencies, defaultComponents } from './components.js'\nimport { connectionGater } from './config/connection-gater.js'\nimport { DefaultConnectionManager } from './connection-manager/index.js'\nimport { ConnectionMonitor } from './connection-monitor.js'\nimport { CompoundContentRouting } from './content-routing.js'\nimport { DefaultPeerRouting } from './peer-routing.js'\nimport { RandomWalk } from './random-walk.js'\nimport { Registrar } from './registrar.js'\nimport { DefaultTransportManager } from './transport-manager.js'\nimport { Upgrader } from './upgrader.js'\nimport { userAgent } from './user-agent.js'\nimport * as pkg from './version.js'\nimport type { Components } from './components.js'\nimport type { Libp2p as Libp2pInterface, Libp2pInit } from './index.js'\nimport type { PeerRouting, ContentRouting, Libp2pEvents, PendingDial, ServiceMap, AbortOptions, ComponentLogger, Logger, Connection, NewStreamOptions, Stream, Metrics, PeerId, PeerInfo, PeerStore, Topology, Libp2pStatus, IsDialableOptions, DialOptions, PublicKey, Ed25519PeerId, Secp256k1PeerId, RSAPublicKey, RSAPeerId, URLPeerId, Ed25519PublicKey, Secp256k1PublicKey, StreamHandler, StreamHandlerOptions, StreamMiddleware } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport class Libp2p<T extends ServiceMap = ServiceMap> extends TypedEventEmitter<Libp2pEvents> implements Libp2pInterface<T> {\n  public peerId: PeerId\n  public peerStore: PeerStore\n  public contentRouting: ContentRouting\n  public peerRouting: PeerRouting\n  public metrics?: Metrics\n  public services: T\n  public logger: ComponentLogger\n  public status: Libp2pStatus\n\n  public components: Components & T\n  private readonly log: Logger\n\n  // eslint-disable-next-line complexity\n  constructor (init: Libp2pInit<T> & { peerId: PeerId }) {\n    super()\n\n    this.status = 'stopped'\n\n    // event bus - components can listen to this emitter to be notified of system events\n    // and also cause them to be emitted\n    const events = new TypedEventEmitter<Libp2pEvents>()\n    const originalDispatch = events.dispatchEvent.bind(events)\n    events.dispatchEvent = (evt: any) => {\n      const internalResult = originalDispatch(evt)\n      const externalResult = this.dispatchEvent(\n        new CustomEvent(evt.type, { detail: evt.detail })\n      )\n\n      return internalResult || externalResult\n    }\n\n    // This emitter gets listened to a lot\n    setMaxListeners(Infinity, events)\n\n    this.peerId = init.peerId\n    this.logger = init.logger ?? defaultLogger()\n    this.log = this.logger.forComponent('libp2p')\n    // @ts-expect-error {} may not be of type T\n    this.services = {}\n\n    const nodeInfoName = init.nodeInfo?.name ?? pkg.name\n    const nodeInfoVersion = init.nodeInfo?.version ?? pkg.version\n\n    // @ts-expect-error defaultComponents is missing component types added later\n    const components = this.components = defaultComponents({\n      peerId: init.peerId,\n      privateKey: init.privateKey,\n      nodeInfo: {\n        name: nodeInfoName,\n        version: nodeInfoVersion,\n        userAgent: init.nodeInfo?.userAgent ?? userAgent(nodeInfoName, nodeInfoVersion)\n      },\n      logger: this.logger,\n      events,\n      datastore: init.datastore ?? new MemoryDatastore(),\n      connectionGater: connectionGater(init.connectionGater),\n      dns: init.dns\n    })\n\n    // Create Metrics\n    if (init.metrics != null) {\n      this.metrics = this.configureComponent('metrics', init.metrics(this.components))\n    }\n\n    this.peerStore = this.configureComponent('peerStore', persistentPeerStore(components, {\n      addressFilter: this.components.connectionGater.filterMultiaddrForPeer,\n      ...init.peerStore\n    }))\n\n    components.events.addEventListener('peer:update', evt => {\n      // if there was no peer previously in the peer store this is a new peer\n      if (evt.detail.previous == null) {\n        const peerInfo: PeerInfo = {\n          id: evt.detail.peer.id,\n          multiaddrs: evt.detail.peer.addresses.map(a => a.multiaddr)\n        }\n\n        components.events.safeDispatchEvent('peer:discovery', { detail: peerInfo })\n      }\n    })\n\n    // Set up connection protector if configured\n    if (init.connectionProtector != null) {\n      this.configureComponent('connectionProtector', init.connectionProtector(components))\n    }\n\n    // Set up the Upgrader\n    this.components.upgrader = new Upgrader(this.components, {\n      connectionEncrypters: (init.connectionEncrypters ?? []).map((fn, index) => this.configureComponent(`connection-encryption-${index}`, fn(this.components))),\n      streamMuxers: (init.streamMuxers ?? []).map((fn, index) => this.configureComponent(`stream-muxers-${index}`, fn(this.components))),\n      inboundUpgradeTimeout: init.connectionManager?.inboundUpgradeTimeout,\n      inboundStreamProtocolNegotiationTimeout: init.connectionManager?.inboundStreamProtocolNegotiationTimeout,\n      outboundStreamProtocolNegotiationTimeout: init.connectionManager?.outboundStreamProtocolNegotiationTimeout,\n      connectionCloseTimeout: init.connectionManager?.connectionCloseTimeout\n    })\n\n    // Setup the transport manager\n    this.configureComponent('transportManager', new DefaultTransportManager(this.components, init.transportManager))\n\n    // Create the Connection Manager\n    this.configureComponent('connectionManager', new DefaultConnectionManager(this.components, init.connectionManager))\n\n    if (init.connectionMonitor?.enabled !== false) {\n      // Create the Connection Monitor if not disabled\n      this.configureComponent('connectionMonitor', new ConnectionMonitor(this.components, init.connectionMonitor))\n    }\n\n    // Create the Registrar\n    this.configureComponent('registrar', new Registrar(this.components))\n\n    // Addresses {listen, announce, noAnnounce}\n    this.configureComponent('addressManager', new AddressManager(this.components, init.addresses))\n\n    // Peer routers\n    const peerRouters: PeerRouting[] = (init.peerRouters ?? []).map((fn, index) => this.configureComponent(`peer-router-${index}`, fn(this.components)))\n    this.peerRouting = this.components.peerRouting = this.configureComponent('peerRouting', new DefaultPeerRouting(this.components, {\n      routers: peerRouters\n    }))\n\n    // Content routers\n    const contentRouters: ContentRouting[] = (init.contentRouters ?? []).map((fn, index) => this.configureComponent(`content-router-${index}`, fn(this.components)))\n    this.contentRouting = this.components.contentRouting = this.configureComponent('contentRouting', new CompoundContentRouting(this.components, {\n      routers: contentRouters\n    }))\n\n    // Random walk\n    this.configureComponent('randomWalk', new RandomWalk(this.components))\n\n    // Discovery modules\n    ;(init.peerDiscovery ?? []).forEach((fn, index) => {\n      const service = this.configureComponent(`peer-discovery-${index}`, fn(this.components))\n\n      service.addEventListener('peer', (evt) => {\n        this.#onDiscoveryPeer(evt)\n      })\n    })\n\n    // Transport modules\n    init.transports?.forEach((fn, index) => {\n      this.components.transportManager.add(this.configureComponent(`transport-${index}`, fn(this.components)))\n    })\n\n    // User defined modules\n    if (init.services != null) {\n      for (const name of Object.keys(init.services)) {\n        const createService = init.services[name]\n        const service: any = createService(this.components)\n\n        if (service == null) {\n          this.log.error('service factory %s returned null or undefined instance', name)\n          continue\n        }\n\n        this.services[name as keyof T] = service\n        this.configureComponent(name, service)\n\n        if (service[contentRoutingSymbol] != null) {\n          this.log('registering service %s for content routing', name)\n          contentRouters.push(service[contentRoutingSymbol])\n        }\n\n        if (service[peerRoutingSymbol] != null) {\n          this.log('registering service %s for peer routing', name)\n          peerRouters.push(service[peerRoutingSymbol])\n        }\n\n        if (service[peerDiscoverySymbol] != null) {\n          this.log('registering service %s for peer discovery', name)\n          service[peerDiscoverySymbol].addEventListener?.('peer', (evt: CustomEvent<PeerInfo>) => {\n            this.#onDiscoveryPeer(evt)\n          })\n        }\n      }\n    }\n\n    // Ensure all services have their required dependencies\n    checkServiceDependencies(components)\n  }\n\n  private configureComponent <T> (name: string, component: T): T {\n    if (component == null) {\n      this.log.error('component %s was null or undefined', name)\n    }\n\n    // @ts-expect-error cannot assign props\n    this.components[name] = component\n\n    return component\n  }\n\n  /**\n   * Starts the libp2p node and all its subsystems\n   */\n  async start (): Promise<void> {\n    if (this.status !== 'stopped') {\n      return\n    }\n\n    this.status = 'starting'\n\n    this.log('libp2p is starting')\n\n    try {\n      await this.components.beforeStart?.()\n      await this.components.start()\n      await this.components.afterStart?.()\n\n      this.status = 'started'\n      this.safeDispatchEvent('start', { detail: this })\n      this.log('libp2p has started with peer id %p', this.peerId)\n    } catch (err: any) {\n      this.log.error('an error occurred starting libp2p - %e', err)\n      // set status to 'started' so this.stop() will stop any running components\n      this.status = 'started'\n      await this.stop()\n      throw err\n    }\n  }\n\n  /**\n   * Stop the libp2p node by closing its listeners and open connections\n   */\n  async stop (): Promise<void> {\n    if (this.status !== 'started') {\n      return\n    }\n\n    this.log('libp2p is stopping')\n\n    this.status = 'stopping'\n\n    await this.components.beforeStop?.()\n    await this.components.stop()\n    await this.components.afterStop?.()\n\n    this.status = 'stopped'\n    this.safeDispatchEvent('stop', { detail: this })\n    this.log('libp2p has stopped')\n  }\n\n  getConnections (peerId?: PeerId): Connection[] {\n    return this.components.connectionManager.getConnections(peerId)\n  }\n\n  getDialQueue (): PendingDial[] {\n    return this.components.connectionManager.getDialQueue()\n  }\n\n  getPeers (): PeerId[] {\n    const peerSet = new PeerSet()\n\n    for (const conn of this.components.connectionManager.getConnections()) {\n      peerSet.add(conn.remotePeer)\n    }\n\n    return Array.from(peerSet)\n  }\n\n  async dial (peer: PeerId | Multiaddr | Multiaddr[], options: DialOptions = {}): Promise<Connection> {\n    return this.components.connectionManager.openConnection(peer, {\n      // ensure any userland dials take top priority in the queue\n      priority: 75,\n      ...options\n    })\n  }\n\n  async dialProtocol (peer: PeerId | Multiaddr | Multiaddr[], protocols: string | string[], options: NewStreamOptions = {}): Promise<Stream> {\n    if (protocols == null) {\n      throw new InvalidParametersError('no protocols were provided to open a stream')\n    }\n\n    protocols = Array.isArray(protocols) ? protocols : [protocols]\n\n    if (protocols.length === 0) {\n      throw new InvalidParametersError('no protocols were provided to open a stream')\n    }\n\n    return this.components.connectionManager.openStream(peer, protocols, options)\n  }\n\n  getMultiaddrs (): Multiaddr[] {\n    return this.components.addressManager.getAddresses()\n  }\n\n  getProtocols (): string[] {\n    return this.components.registrar.getProtocols()\n  }\n\n  async hangUp (peer: PeerId | Multiaddr, options: AbortOptions = {}): Promise<void> {\n    if (isMultiaddr(peer)) {\n      peer = peerIdFromString(peer.getComponents().findLast(c => c.code === CODE_P2P)?.value ?? '')\n    }\n\n    await this.components.connectionManager.closeConnections(peer, options)\n  }\n\n  /**\n   * Get the public key for the given peer id\n   */\n  async getPublicKey (peer: Ed25519PeerId, options?: AbortOptions): Promise<Ed25519PublicKey>\n  async getPublicKey (peer: Secp256k1PeerId, options?: AbortOptions): Promise<Secp256k1PublicKey>\n  async getPublicKey (peer: RSAPeerId, options?: AbortOptions): Promise<RSAPublicKey>\n  async getPublicKey (peer: URLPeerId, options?: AbortOptions): Promise<never>\n  async getPublicKey (peer: PeerId, options?: AbortOptions): Promise<PublicKey>\n  async getPublicKey (peer: PeerId, options: AbortOptions = {}): Promise<PublicKey> {\n    this.log('getPublicKey %p', peer)\n\n    if (peer.publicKey != null) {\n      return peer.publicKey\n    }\n\n    try {\n      const peerInfo = await this.peerStore.get(peer, options)\n\n      if (peerInfo.id.publicKey != null) {\n        return peerInfo.id.publicKey\n      }\n    } catch (err: any) {\n      if (err.name !== 'NotFoundError') {\n        throw err\n      }\n    }\n\n    const peerKey = uint8ArrayConcat([\n      uint8ArrayFromString('/pk/'),\n      peer.toMultihash().bytes\n    ])\n\n    // search any available content routing methods\n    const bytes = await this.contentRouting.get(peerKey, options)\n\n    // ensure the returned key is valid\n    const publicKey = publicKeyFromProtobuf(bytes)\n\n    await this.peerStore.patch(peer, {\n      publicKey\n    }, options)\n\n    return publicKey\n  }\n\n  async handle (protocols: string | string[], handler: StreamHandler, options?: StreamHandlerOptions): Promise<void> {\n    if (!Array.isArray(protocols)) {\n      protocols = [protocols]\n    }\n\n    await Promise.all(\n      protocols.map(async protocol => {\n        await this.components.registrar.handle(protocol, handler, options)\n      })\n    )\n  }\n\n  async unhandle (protocols: string[] | string, options?: AbortOptions): Promise<void> {\n    if (!Array.isArray(protocols)) {\n      protocols = [protocols]\n    }\n\n    await Promise.all(\n      protocols.map(async protocol => {\n        await this.components.registrar.unhandle(protocol, options)\n      })\n    )\n  }\n\n  async register (protocol: string, topology: Topology, options?: AbortOptions): Promise<string> {\n    return this.components.registrar.register(protocol, topology, options)\n  }\n\n  unregister (id: string): void {\n    this.components.registrar.unregister(id)\n  }\n\n  use (protocol: string, middleware: StreamMiddleware | StreamMiddleware[]): void {\n    this.components.registrar.use(protocol, Array.isArray(middleware) ? middleware : [middleware])\n  }\n\n  unuse (protocol: string): void {\n    this.components.registrar.unuse(protocol)\n  }\n\n  async isDialable (multiaddr: Multiaddr, options: IsDialableOptions = {}): Promise<boolean> {\n    return this.components.connectionManager.isDialable(multiaddr, options)\n  }\n\n  /**\n   * Called whenever peer discovery services emit `peer` events and adds peers\n   * to the peer store.\n   */\n  #onDiscoveryPeer (evt: CustomEvent<PeerInfo>): void {\n    const { detail: peer } = evt\n\n    if (peer.id.toString() === this.peerId.toString()) {\n      this.log.error('peer discovery mechanism discovered self')\n      return\n    }\n\n    void this.components.peerStore.merge(peer.id, {\n      multiaddrs: peer.multiaddrs\n    })\n      .catch(err => { this.log.error('could not update multiaddrs of discovered peer - %e', err) })\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Use the `createLibp2p` function to create a libp2p node.\n *\n * @example\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n *\n * const node = await createLibp2p({\n *   // ...other options\n * })\n * ```\n */\n\nimport { generateKeyPair } from '@libp2p/crypto/keys'\nimport { peerIdFromPrivateKey } from '@libp2p/peer-id'\nimport { validateConfig } from './config.js'\nimport { Libp2p as Libp2pClass } from './libp2p.js'\nimport type { AddressManagerInit, AddressFilter } from './address-manager/index.js'\nimport type { Components } from './components.js'\nimport type { ConnectionManagerInit } from './connection-manager/index.js'\nimport type { ConnectionMonitorInit } from './connection-monitor.js'\nimport type { TransportManagerInit } from './transport-manager.js'\nimport type { Libp2p, ServiceMap, ComponentLogger, NodeInfo, ConnectionProtector, ConnectionEncrypter, ConnectionGater, ContentRouting, Metrics, PeerDiscovery, PeerRouting, StreamMuxerFactory, Transport, PrivateKey } from '@libp2p/interface'\nimport type { PersistentPeerStoreInit } from '@libp2p/peer-store'\nimport type { DNS } from '@multiformats/dns'\nimport type { Datastore } from 'interface-datastore'\n\nexport type ServiceFactoryMap<T extends ServiceMap = ServiceMap> = {\n  [Property in keyof T]: (components: Components & T) => T[Property]\n}\n\nexport type { AddressManagerInit, AddressFilter }\n\nexport { dnsaddrResolver } from './connection-manager/resolvers/index.ts'\n\n/**\n * For Libp2p configurations and modules details read the [Configuration Document](https://github.com/libp2p/js-libp2p/tree/main/doc/CONFIGURATION.md).\n */\nexport interface Libp2pInit<T extends ServiceMap = ServiceMap> {\n  /**\n   * The private key is used in cryptographic operations and the Peer ID derived\n   * from it's corresponding public key is used to identify the node to other\n   * peers on the network.\n   *\n   * If this is not passed a new Ed25519 private key will be generated.\n   */\n  privateKey?: PrivateKey\n\n  /**\n   * Metadata about the node - implementation name, version number, etc\n   */\n  nodeInfo?: Partial<NodeInfo>\n\n  /**\n   * Addresses for transport listening and to advertise to the network\n   */\n  addresses?: AddressManagerInit\n\n  /**\n   * libp2p Connection Manager configuration\n   */\n  connectionManager?: ConnectionManagerInit\n\n  /**\n   * libp2p Connection Monitor configuration\n   */\n  connectionMonitor?: ConnectionMonitorInit\n\n  /**\n   * A connection gater can deny new connections based on user criteria\n   */\n  connectionGater?: ConnectionGater\n\n  /**\n   * libp2p transport manager configuration\n   */\n  transportManager?: TransportManagerInit\n\n  /**\n   * An optional datastore to persist peer information, DHT records, etc.\n   *\n   * An in-memory datastore will be used if one is not provided.\n   */\n  datastore?: Datastore\n\n  /**\n   * libp2p PeerStore configuration\n   */\n  peerStore?: PersistentPeerStoreInit\n\n  /**\n   * Transports are low-level communication channels\n   */\n  transports?: Array<(components: Components) => Transport>\n\n  /**\n   * Stream muxers allow the creation of many data streams over a single\n   * connection.\n   */\n  streamMuxers?: Array<(components: Components) => StreamMuxerFactory>\n\n  /**\n   * Connection encrypters ensure that data sent over connections cannot be\n   * eavesdropped on, and that the remote peer possesses the private key that\n   * corresponds to the public key that it's Peer ID is derived from.\n   */\n  connectionEncrypters?: Array<(components: Components) => ConnectionEncrypter>\n\n  /**\n   * Peer discovery mechanisms allow finding peers on the network\n   */\n  peerDiscovery?: Array<(components: Components) => PeerDiscovery>\n\n  /**\n   * Peer routers provide implementations for peer routing queries\n   */\n  peerRouters?: Array<(components: Components) => PeerRouting>\n\n  /**\n   * Content routers provide implementations for content routing queries\n   */\n  contentRouters?: Array<(components: Components) => ContentRouting>\n\n  /**\n   * A Metrics implementation can be supplied to collect metrics on this node\n   */\n  metrics?(components: Components): Metrics\n\n  /**\n   * A ConnectionProtector can be used to create a secure overlay on top of the network using pre-shared keys\n   */\n  connectionProtector?(components: Components): ConnectionProtector\n\n  /**\n   * Arbitrary libp2p modules\n   */\n  services?: ServiceFactoryMap<T>\n\n  /**\n   * An optional logging implementation that can be used to write runtime logs.\n   *\n   * Set the `DEBUG` env var or the `debug` key on LocalStorage to see logs.\n   *\n   * @example\n   *\n   * Node.js:\n   *\n   * ```console\n   * $ DEBUG=\"*libp2p:*\" node myscript.js\n   * ```\n   *\n   * Browsers:\n   *\n   * ```TypeScript\n   * localStorage.setItem('debug', '*libp2p:*')\n   * ```\n   */\n  logger?: ComponentLogger\n\n  /**\n   * An optional DNS resolver configuration. If omitted the default DNS resolver\n   * for the platform will be used which means `node:dns` on Node.js and\n   * DNS-JSON-over-HTTPS for browsers using Google and Cloudflare servers.\n   */\n  dns?: DNS\n}\n\nexport type { Libp2p, ConnectionManagerInit, ConnectionMonitorInit, TransportManagerInit }\n\nexport type Libp2pOptions<T extends ServiceMap = ServiceMap> = Libp2pInit<T> & { start?: boolean }\n\n/**\n * Returns a new instance of the Libp2p interface, generating a new PeerId\n * if one is not passed as part of the options.\n *\n * The node will be started unless `start: false` is passed as an option.\n *\n * @example\n *\n * ```TypeScript\n * import { createLibp2p } from 'libp2p'\n * import { tcp } from '@libp2p/tcp'\n * import { mplex } from '@libp2p/mplex'\n * import { noise } from '@chainsafe/libp2p-noise'\n * import { yamux } from '@chainsafe/libp2p-yamux'\n *\n * // specify options\n * const options = {\n *   transports: [tcp()],\n *   streamMuxers: [yamux(), mplex()],\n *   connectionEncrypters: [noise()]\n * }\n *\n * // create libp2p\n * const libp2p = await createLibp2p(options)\n * ```\n */\nexport async function createLibp2p <T extends ServiceMap = ServiceMap> (options: Libp2pOptions<T> = {}): Promise<Libp2p<T>> {\n  options.privateKey ??= await generateKeyPair('Ed25519')\n\n  const node = new Libp2pClass({\n    ...await validateConfig(options),\n    peerId: peerIdFromPrivateKey(options.privateKey)\n  })\n\n  if (options.start !== false) {\n    await node.start()\n  }\n\n  return node\n}\n\n// a non-exhaustive list of methods found on the libp2p object\nconst LIBP2P_METHODS = ['dial', 'dialProtocol', 'hangUp', 'handle', 'unhandle', 'getMultiaddrs', 'getProtocols']\n\n/**\n * Returns true if the passed object is a libp2p node - this can be used for\n * type guarding in TypeScript.\n */\nexport function isLibp2p <T extends ServiceMap = ServiceMap> (obj?: any): obj is Libp2p<T> {\n  if (obj == null) {\n    return false\n  }\n\n  if (obj instanceof Libp2pClass) {\n    return true\n  }\n\n  // if these are all functions it's probably a libp2p object\n  return LIBP2P_METHODS.every(m => typeof obj[m] === 'function')\n}\n"],
  "mappings": "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",
  "names": ["cache", "_a", "_b", "arr", "src_default", "AbortError", "message", "AbortError", "_a", "message", "_a", "AbortError", "_a", "AbortError", "debounce", "debounce", "_a", "AbortError", "_b", "_c", "event", "name", "_a", "_b", "_c", "event", "_a", "AbortError", "name", "implementation", "defaultOptions", "Peer", "Peer$metadataEntry", "_codec", "Peer$tagsEntry", "_a", "_b", "_c", "Address", "Tag", "filter", "_a", "_a", "_b", "peerRecordEnvelope", "multiaddr", "_c", "addr", "src_default", "multiaddr", "message", "NotFoundError", "src_default", "isAsyncIterable", "peekable", "src_default", "isAsyncIterable", "src_default", "isAsyncIterable", "src_default", "src_default", "it", "_a", "NotFoundError", "_b", "_a", "_a", "defaultValues", "multiaddr", "_a", "defaultValues", "_a", "multiaddr", "ma", "messages", "message", "_a", "serviceCapabilities", "multiaddr", "_a", "_a", "PriorityQueue", "_queue", "EventEmitter", "_a", "_b", "PriorityQueue", "reject", "filter", "_a", "response", "hashlru", "_a", "_b", "_c", "RecordType", "name", "_a", "_b", "address", "defaultOptions", "_a", "_b", "_c", "multiaddr", "options", "err", "message", "name", "AbortError", "message", "start", "_a", "_b", "_c", "defaultOptions", "_a", "_b", "_c", "multiaddr", "_a", "start", "_a", "_b", "_c", "_a", "_b", "peer", "_a", "_b", "start", "_a", "_b", "_c", "_a", "isAsyncIterable", "encode", "isAsyncIterable", "ReadMode", "decode", "isAsyncIterable", "encode", "_a", "_b", "options", "_a", "_b", "_c", "name", "version", "_a", "_b", "_c", "name", "multiaddr"]
}
