{
  "version": 3,
  "sources": ["../../../../../peercompute/node_modules/@libp2p/plaintext/src/pb/proto.ts", "../../../../../peercompute/node_modules/@libp2p/plaintext/src/index.ts"],
  "sourcesContent": ["import { decodeMessage, encodeMessage, enumeration, message } from 'protons-runtime'\nimport { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc'\nimport type { Codec, DecodeOptions } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Exchange {\n  id?: Uint8Array\n  pubkey?: PublicKey\n}\n\nexport namespace Exchange {\n  let _codec: Codec<Exchange>\n\n  export const codec = (): Codec<Exchange> => {\n    if (_codec == null) {\n      _codec = message<Exchange>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.id != null) {\n          w.uint32(10)\n          w.bytes(obj.id)\n        }\n\n        if (obj.pubkey != null) {\n          w.uint32(18)\n          PublicKey.codec().encode(obj.pubkey, w)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.id = reader.bytes()\n              break\n            }\n            case 2: {\n              obj.pubkey = PublicKey.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.pubkey\n              })\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Exchange>): Uint8Array => {\n    return encodeMessage(obj, Exchange.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Exchange>): Exchange => {\n    return decodeMessage(buf, Exchange.codec(), opts)\n  }\n}\n\nexport enum KeyType {\n  RSA = 'RSA',\n  Ed25519 = 'Ed25519',\n  secp256k1 = 'secp256k1',\n  ECDSA = 'ECDSA'\n}\n\nenum __KeyTypeValues {\n  RSA = 0,\n  Ed25519 = 1,\n  secp256k1 = 2,\n  ECDSA = 3\n}\n\nexport namespace KeyType {\n  export const codec = (): Codec<KeyType> => {\n    return enumeration<KeyType>(__KeyTypeValues)\n  }\n}\nexport interface PublicKey {\n  Type?: KeyType\n  Data: Uint8Array\n}\n\nexport namespace PublicKey {\n  let _codec: Codec<PublicKey>\n\n  export const codec = (): Codec<PublicKey> => {\n    if (_codec == null) {\n      _codec = message<PublicKey>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.Type != null) {\n          w.uint32(8)\n          KeyType.codec().encode(obj.Type, w)\n        }\n\n        if ((obj.Data != null && obj.Data.byteLength > 0)) {\n          w.uint32(18)\n          w.bytes(obj.Data)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          Data: uint8ArrayAlloc(0)\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.Type = KeyType.codec().decode(reader)\n              break\n            }\n            case 2: {\n              obj.Data = reader.bytes()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<PublicKey>): Uint8Array => {\n    return encodeMessage(obj, PublicKey.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<PublicKey>): PublicKey => {\n    return decodeMessage(buf, PublicKey.codec(), opts)\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * A connection encrypter that does no connection encryption and trusts the\n * remote peer to provide the correct PeerId.\n *\n * This should not be used in production and is for research purposes only.\n *\n * @example\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n * import { plaintext } from '@libp2p/plaintext'\n *\n * const node = await createLibp2p({\n *   // ...other options\n *   connectionEncrypters: [\n *     plaintext()\n *   ]\n * })\n * ```\n */\n\nimport { publicKeyFromRaw } from '@libp2p/crypto/keys'\nimport { UnexpectedPeerError, InvalidCryptoExchangeError, serviceCapabilities, ProtocolError } from '@libp2p/interface'\nimport { peerIdFromPublicKey } from '@libp2p/peer-id'\nimport { pbStream } from '@libp2p/utils'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { Exchange, KeyType } from './pb/proto.js'\nimport type { ComponentLogger, Logger, ConnectionEncrypter, SecuredConnection, PrivateKey, SecureConnectionOptions, MessageStream } from '@libp2p/interface'\n\nconst PROTOCOL = '/plaintext/2.0.0'\n\nexport interface PlaintextComponents {\n  privateKey: PrivateKey\n  logger: ComponentLogger\n}\n\nclass Plaintext implements ConnectionEncrypter {\n  public protocol: string = PROTOCOL\n  private readonly privateKey: PrivateKey\n  private readonly log: Logger\n\n  constructor (components: PlaintextComponents) {\n    this.privateKey = components.privateKey\n    this.log = components.logger.forComponent('libp2p:plaintext')\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/plaintext'\n\n  readonly [serviceCapabilities]: string[] = [\n    '@libp2p/connection-encryption'\n  ]\n\n  async secureInbound (connection: MessageStream, options?: SecureConnectionOptions): Promise<SecuredConnection> {\n    return this._encrypt(connection, options)\n  }\n\n  async secureOutbound (connection: MessageStream, options?: SecureConnectionOptions): Promise<SecuredConnection> {\n    return this._encrypt(connection, options)\n  }\n\n  /**\n   * Encrypt connection\n   */\n  async _encrypt (connection: MessageStream, options?: SecureConnectionOptions): Promise<SecuredConnection> {\n    const log = connection.log?.newScope('plaintext') ?? this.log\n    const pb = pbStream(connection).pb(Exchange)\n\n    log('write pubkey exchange to peer %p', options?.remotePeer)\n\n    const publicKey = this.privateKey.publicKey\n\n    // Encode the public key and write it to the remote peer\n    await pb.write({\n      id: publicKey.toMultihash().bytes,\n      pubkey: {\n        Type: KeyType[publicKey.type],\n        Data: publicKey.raw\n      }\n    }, options)\n\n    // Get the Exchange message\n    const response = await pb.read(options)\n\n    let peerId\n    try {\n      if (response.pubkey == null) {\n        throw new ProtocolError('Public key missing')\n      }\n\n      if (response.pubkey.Data.byteLength === 0) {\n        throw new ProtocolError('Public key data too short')\n      }\n\n      if (response.id == null) {\n        throw new ProtocolError('Remote id missing')\n      }\n\n      const pubKey = publicKeyFromRaw(response.pubkey.Data)\n      peerId = peerIdFromPublicKey(pubKey)\n\n      if (!uint8ArrayEquals(peerId.toMultihash().bytes, response.id)) {\n        throw new InvalidCryptoExchangeError('Public key did not match id')\n      }\n    } catch (err: any) {\n      log.error('invalid public key - %e', err)\n      throw new InvalidCryptoExchangeError(`Invalid public key - ${err.message}`)\n    }\n\n    if (options?.remotePeer != null && !peerId.equals(options?.remotePeer)) {\n      throw new UnexpectedPeerError()\n    }\n\n    log('plaintext key exchange completed successfully with peer %p', peerId)\n\n    return {\n      connection: pb.unwrap().unwrap(),\n      remotePeer: peerId\n    }\n  }\n}\n\nexport function plaintext (): (components: PlaintextComponents) => ConnectionEncrypter {\n  return (components) => new Plaintext(components)\n}\n"],
  "mappings": "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",
  "names": ["Exchange", "_a", "KeyType", "__KeyTypeValues", "PublicKey", "_a"]
}
