import {
  createScalableCuckooFilter
} from "./chunk-O3N7UJNM.js";
import {
  peerIdFromMultihash
} from "./chunk-7EPQD6JW.js";
import {
  base58btc,
  decode
} from "./chunk-5QZ7JOES.js";
import {
  __publicField
} from "./chunk-WOOG5QLI.js";

// ../../peercompute/node_modules/@libp2p/peer-collections/dist/src/util.js
function mapIterable(iter, map) {
  const iterator = {
    [Symbol.iterator]: () => {
      return iterator;
    },
    next: () => {
      const next = iter.next();
      const val = next.value;
      if (next.done === true || val == null) {
        const result = {
          done: true,
          value: void 0
        };
        return result;
      }
      return {
        done: false,
        value: map(val)
      };
    }
  };
  return iterator;
}
function peerIdFromString(str) {
  const multihash = decode(base58btc.decode(`z${str}`));
  return peerIdFromMultihash(multihash);
}

// ../../peercompute/node_modules/@libp2p/peer-collections/dist/src/map.js
var PeerMap = class {
  constructor(map) {
    __publicField(this, "map");
    this.map = /* @__PURE__ */ new Map();
    if (map != null) {
      for (const [key, value] of map.entries()) {
        this.map.set(key.toString(), { key, value });
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  clear() {
    this.map.clear();
  }
  delete(peer) {
    return this.map.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.map.entries(), (val) => {
      return [val[1].key, val[1].value];
    });
  }
  forEach(fn) {
    this.map.forEach((value, key) => {
      fn(value.value, value.key, this);
    });
  }
  get(peer) {
    var _a;
    return (_a = this.map.get(peer.toString())) == null ? void 0 : _a.value;
  }
  has(peer) {
    return this.map.has(peer.toString());
  }
  set(peer, value) {
    this.map.set(peer.toString(), { key: peer, value });
  }
  keys() {
    return mapIterable(this.map.values(), (val) => {
      return val.key;
    });
  }
  values() {
    return mapIterable(this.map.values(), (val) => val.value);
  }
  get size() {
    return this.map.size;
  }
};

// ../../peercompute/node_modules/@libp2p/peer-collections/dist/src/set.js
var PeerSet = class _PeerSet {
  constructor(set) {
    __publicField(this, "set");
    this.set = /* @__PURE__ */ new Set();
    if (set != null) {
      for (const key of set) {
        this.set.add(key.toString());
      }
    }
  }
  get size() {
    return this.set.size;
  }
  [Symbol.iterator]() {
    return this.values();
  }
  add(peer) {
    this.set.add(peer.toString());
  }
  clear() {
    this.set.clear();
  }
  delete(peer) {
    this.set.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.set.entries(), (val) => {
      const peerId = peerIdFromString(val[0]);
      return [peerId, peerId];
    });
  }
  forEach(predicate) {
    this.set.forEach((str) => {
      const peerId = peerIdFromString(str);
      predicate(peerId, peerId, this);
    });
  }
  has(peer) {
    return this.set.has(peer.toString());
  }
  values() {
    return mapIterable(this.set.values(), (val) => {
      return peerIdFromString(val);
    });
  }
  intersection(other) {
    const output = new _PeerSet();
    for (const peerId of other) {
      if (this.has(peerId)) {
        output.add(peerId);
      }
    }
    return output;
  }
  difference(other) {
    const output = new _PeerSet();
    for (const peerId of this) {
      if (!other.has(peerId)) {
        output.add(peerId);
      }
    }
    return output;
  }
  union(other) {
    const output = new _PeerSet();
    for (const peerId of other) {
      output.add(peerId);
    }
    for (const peerId of this) {
      output.add(peerId);
    }
    return output;
  }
};

// ../../peercompute/node_modules/@libp2p/peer-collections/dist/src/filter.js
var PeerFilter = class {
  constructor(size, errorRate) {
    __publicField(this, "filter");
    this.filter = createScalableCuckooFilter(size, errorRate);
  }
  has(peerId) {
    return this.filter.has(peerId.toMultihash().bytes);
  }
  add(peerId) {
    this.filter.add(peerId.toMultihash().bytes);
  }
  remove(peerId) {
    var _a, _b;
    (_b = (_a = this.filter).remove) == null ? void 0 : _b.call(_a, peerId.toMultihash().bytes);
  }
};
function peerFilter(size, errorRate = 1e-3) {
  return new PeerFilter(size, errorRate);
}

// ../../peercompute/node_modules/@libp2p/peer-collections/dist/src/tracked-map.js
var TrackedPeerMap = class extends PeerMap {
  constructor(init) {
    super();
    __publicField(this, "metric");
    const { name, metrics } = init;
    this.metric = metrics.registerMetric(name);
    this.updateComponentMetric();
  }
  set(key, value) {
    super.set(key, value);
    this.updateComponentMetric();
    return this;
  }
  delete(key) {
    const deleted = super.delete(key);
    this.updateComponentMetric();
    return deleted;
  }
  clear() {
    super.clear();
    this.updateComponentMetric();
  }
  updateComponentMetric() {
    this.metric.update(this.size);
  }
};
function trackedPeerMap(config) {
  const { name, metrics } = config;
  let map;
  if (metrics != null) {
    map = new TrackedPeerMap({ name, metrics });
  } else {
    map = new PeerMap();
  }
  return map;
}

export {
  PeerMap,
  PeerSet,
  peerFilter,
  trackedPeerMap
};
//# sourceMappingURL=chunk-DIEVBDCT.js.map
