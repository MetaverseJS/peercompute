{
  "version": 3,
  "sources": ["../../../../../node_modules/@libp2p/peer-collections/src/util.ts", "../../../../../node_modules/@libp2p/peer-collections/src/map.ts", "../../../../../node_modules/@libp2p/peer-collections/src/set.ts", "../../../../../node_modules/@libp2p/peer-collections/src/filter.ts", "../../../../../node_modules/@libp2p/peer-collections/src/tracked-map.ts"],
  "sourcesContent": ["import { peerIdFromMultihash } from '@libp2p/peer-id'\nimport { base58btc } from 'multiformats/bases/base58'\nimport * as Digest from 'multiformats/hashes/digest'\nimport type { PeerId } from '@libp2p/interface'\n\n/**\n * Calls the passed map function on every entry of the passed iterable iterator\n */\nexport function mapIterable <T, R> (iter: IterableIterator<T>, map: (val: T) => R): IterableIterator<R> {\n  const iterator: IterableIterator<R> = {\n    [Symbol.iterator]: () => {\n      return iterator\n    },\n    next: () => {\n      const next = iter.next()\n      const val = next.value\n\n      if (next.done === true || val == null) {\n        const result: IteratorReturnResult<any> = {\n          done: true,\n          value: undefined\n        }\n\n        return result\n      }\n\n      return {\n        done: false,\n        value: map(val)\n      }\n    }\n  }\n\n  return iterator\n}\n\nexport function peerIdFromString (str: string): PeerId {\n  const multihash = Digest.decode(base58btc.decode(`z${str}`))\n  return peerIdFromMultihash(multihash)\n}\n", "import { mapIterable } from './util.js'\nimport type { PeerId } from '@libp2p/interface'\n\n/**\n * We can't use PeerIds as map keys because map keys are\n * compared using same-value-zero equality, so this is just\n * a map that stringifies the PeerIds before storing them.\n *\n * PeerIds cache stringified versions of themselves so this\n * should be a cheap operation.\n *\n * @example\n *\n * ```TypeScript\n * import { peerMap } from '@libp2p/peer-collections'\n *\n * const map = peerMap<string>()\n * map.set(peerId, 'value')\n * ```\n */\nexport class PeerMap <T> {\n  private readonly map: Map<string, { key: PeerId, value: T }>\n\n  constructor (map?: PeerMap<T>) {\n    this.map = new Map()\n\n    if (map != null) {\n      for (const [key, value] of map.entries()) {\n        this.map.set(key.toString(), { key, value })\n      }\n    }\n  }\n\n  [Symbol.iterator] (): IterableIterator<[PeerId, T]> {\n    return this.entries()\n  }\n\n  clear (): void {\n    this.map.clear()\n  }\n\n  delete (peer: PeerId): boolean {\n    return this.map.delete(peer.toString())\n  }\n\n  entries (): IterableIterator<[PeerId, T]> {\n    return mapIterable<[string, { key: PeerId, value: T }], [PeerId, T]>(\n      this.map.entries(),\n      (val) => {\n        return [val[1].key, val[1].value]\n      }\n    )\n  }\n\n  forEach (fn: (value: T, key: PeerId, map: PeerMap<T>) => void): void {\n    this.map.forEach((value, key) => {\n      fn(value.value, value.key, this)\n    })\n  }\n\n  get (peer: PeerId): T | undefined {\n    return this.map.get(peer.toString())?.value\n  }\n\n  has (peer: PeerId): boolean {\n    return this.map.has(peer.toString())\n  }\n\n  set (peer: PeerId, value: T): void {\n    this.map.set(peer.toString(), { key: peer, value })\n  }\n\n  keys (): IterableIterator<PeerId> {\n    return mapIterable<{ key: PeerId, value: T }, PeerId>(\n      this.map.values(),\n      (val) => {\n        return val.key\n      }\n    )\n  }\n\n  values (): IterableIterator<T> {\n    return mapIterable(this.map.values(), (val) => val.value)\n  }\n\n  get size (): number {\n    return this.map.size\n  }\n}\n\nexport function peerMap <T> (): PeerMap<T> {\n  return new PeerMap<T>()\n}\n", "import { mapIterable, peerIdFromString } from './util.js'\nimport type { PeerId } from '@libp2p/interface'\n\n/**\n * We can't use PeerIds as set entries because set entries are\n * compared using same-value-zero equality, so this is just\n * a map that stringifies the PeerIds before storing them.\n *\n * PeerIds cache stringified versions of themselves so this\n * should be a cheap operation.\n *\n * @example\n *\n * ```TypeScript\n * import { peerSet } from '@libp2p/peer-collections'\n *\n * const set = peerSet()\n * set.add(peerId)\n * ```\n */\nexport class PeerSet {\n  private readonly set: Set<string>\n\n  constructor (set?: PeerSet | Iterable<PeerId>) {\n    this.set = new Set()\n\n    if (set != null) {\n      for (const key of set) {\n        this.set.add(key.toString())\n      }\n    }\n  }\n\n  get size (): number {\n    return this.set.size\n  }\n\n  [Symbol.iterator] (): IterableIterator<PeerId> {\n    return this.values()\n  }\n\n  add (peer: PeerId): void {\n    this.set.add(peer.toString())\n  }\n\n  clear (): void {\n    this.set.clear()\n  }\n\n  delete (peer: PeerId): void {\n    this.set.delete(peer.toString())\n  }\n\n  entries (): IterableIterator<[PeerId, PeerId]> {\n    return mapIterable<[string, string], [PeerId, PeerId]>(\n      this.set.entries(),\n      (val) => {\n        const peerId = peerIdFromString(val[0])\n\n        return [peerId, peerId]\n      }\n    )\n  }\n\n  forEach (predicate: (peerId: PeerId, index: PeerId, set: PeerSet) => void): void {\n    this.set.forEach((str) => {\n      const peerId = peerIdFromString(str)\n\n      predicate(peerId, peerId, this)\n    })\n  }\n\n  has (peer: PeerId): boolean {\n    return this.set.has(peer.toString())\n  }\n\n  values (): IterableIterator<PeerId> {\n    return mapIterable<string, PeerId>(\n      this.set.values(),\n      (val) => {\n        return peerIdFromString(val)\n      }\n    )\n  }\n\n  intersection (other: PeerSet): PeerSet {\n    const output = new PeerSet()\n\n    for (const peerId of other) {\n      if (this.has(peerId)) {\n        output.add(peerId)\n      }\n    }\n\n    return output\n  }\n\n  difference (other: PeerSet): PeerSet {\n    const output = new PeerSet()\n\n    for (const peerId of this) {\n      if (!other.has(peerId)) {\n        output.add(peerId)\n      }\n    }\n\n    return output\n  }\n\n  union (other: PeerSet): PeerSet {\n    const output = new PeerSet()\n\n    for (const peerId of other) {\n      output.add(peerId)\n    }\n\n    for (const peerId of this) {\n      output.add(peerId)\n    }\n\n    return output\n  }\n}\n\nexport function peerSet (): PeerSet {\n  return new PeerSet()\n}\n", "import { createScalableCuckooFilter } from '@libp2p/utils'\nimport type { PeerId } from '@libp2p/interface'\nimport type { Filter } from '@libp2p/utils'\n\n/**\n * Uses a Cuckoo filter to implement a mechanism for deduplicating PeerIds in a\n * way that uses a smaller amount of memory than a PeerSet.\n */\nexport class PeerFilter {\n  private readonly filter: Filter\n\n  constructor (size: number, errorRate?: number) {\n    this.filter = createScalableCuckooFilter(size, errorRate)\n  }\n\n  has (peerId: PeerId): boolean {\n    return this.filter.has(peerId.toMultihash().bytes)\n  }\n\n  add (peerId: PeerId): void {\n    this.filter.add(peerId.toMultihash().bytes)\n  }\n\n  remove (peerId: PeerId): void {\n    this.filter.remove?.(peerId.toMultihash().bytes)\n  }\n}\n\n/**\n * Create and return a PeerFilter. This can be used by topologies to prevent\n * them receiving duplicate notifications for a peer that connects repeatedly.\n *\n * @example\n *\n * ```TypeScript\n * import { peerFilter } from '@libp2p/peer-collections'\n * import type { Registrar } from '@libp2p/interface-internal'\n *\n * const registrar: Registrar\n *\n * registrar.register('/my/protocol/1.0.0', {\n *   filter: peerFilter(),\n *   onConnect: (peerId) => {\n *     // will only be invoked for a given peerId once\n *   }\n * })\n * ```\n *\n * @param size - The maximum number of peers expected to be added to the filter\n * @param errorRate - The acceptable error rate\n */\nexport function peerFilter (size: number, errorRate: number = 0.001): PeerFilter {\n  return new PeerFilter(size, errorRate)\n}\n", "import { PeerMap } from './map.js'\nimport type { Metric, Metrics, PeerId } from '@libp2p/interface'\n\nexport interface TrackedPeerMapInit {\n  name: string\n  metrics?: Metrics\n}\n\nclass TrackedPeerMap<V> extends PeerMap<V> {\n  private readonly metric: Metric\n\n  constructor (init: Required<TrackedPeerMapInit>) {\n    super()\n\n    const { name, metrics } = init\n\n    this.metric = metrics.registerMetric(name)\n    this.updateComponentMetric()\n  }\n\n  set (key: PeerId, value: V): this {\n    super.set(key, value)\n    this.updateComponentMetric()\n    return this\n  }\n\n  delete (key: PeerId): boolean {\n    const deleted = super.delete(key)\n    this.updateComponentMetric()\n    return deleted\n  }\n\n  clear (): void {\n    super.clear()\n    this.updateComponentMetric()\n  }\n\n  private updateComponentMetric (): void {\n    this.metric.update(this.size)\n  }\n}\n\n/**\n * Creates a PeerMap that reports it's size to the libp2p Metrics service\n *\n * @example\n *\n * ```Typescript\n * import { trackedPeerMap } from '@libp2p/peer-collections'\n * import { createLibp2p } from 'libp2p'\n *\n * const libp2p = await createLibp2p()\n *\n * const list = trackedPeerMap({ name: 'my_metric_name', metrics: libp2p.metrics })\n * map.set(peerId, 'value')\n * ```\n */\nexport function trackedPeerMap <V> (config: TrackedPeerMapInit): PeerMap<V> {\n  const { name, metrics } = config\n  let map: PeerMap<V>\n\n  if (metrics != null) {\n    map = new TrackedPeerMap<V>({ name, metrics })\n  } else {\n    map = new PeerMap<V>()\n  }\n\n  return map\n}\n"],
  "mappings": "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",
  "names": []
}
