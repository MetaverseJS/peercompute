import {
  CODE_CERTHASH,
  CODE_DNS,
  CODE_DNS4,
  CODE_DNS6,
  CODE_DNSADDR,
  CODE_HTTP,
  CODE_HTTPS,
  CODE_IP4,
  CODE_IP6,
  CODE_IP6ZONE,
  CODE_IPCIDR,
  CODE_MEMORY,
  CODE_P2P,
  CODE_P2P_CIRCUIT,
  CODE_QUIC,
  CODE_QUIC_V1,
  CODE_SNI,
  CODE_TCP,
  CODE_TLS,
  CODE_UDP,
  CODE_UNIX,
  CODE_WEBRTC,
  CODE_WEBRTC_DIRECT,
  CODE_WEBTRANSPORT,
  CODE_WS,
  CODE_WSS
} from "./chunk-DKVXG43P.js";

// ../../peercompute/node_modules/@multiformats/multiaddr-matcher/dist/src/utils.js
var code = (code2) => {
  return {
    match: (vals) => {
      const component = vals[0];
      if (component == null) {
        return false;
      }
      if (component.code !== code2) {
        return false;
      }
      if (component.value != null) {
        return false;
      }
      return vals.slice(1);
    }
  };
};
var value = (code2, value2) => {
  return {
    match: (vals) => {
      const component = vals[0];
      if ((component == null ? void 0 : component.code) !== code2) {
        return false;
      }
      if (component.value == null) {
        return false;
      }
      if (value2 != null && component.value !== value2) {
        return false;
      }
      return vals.slice(1);
    }
  };
};
var not = (matcher) => {
  return {
    match: (vals) => {
      const result = matcher.match(vals);
      if (result === false) {
        return vals;
      }
      return false;
    }
  };
};
var optional = (matcher) => {
  return {
    match: (vals) => {
      const result = matcher.match(vals);
      if (result === false) {
        return vals;
      }
      return result;
    }
  };
};
var or = (...matchers) => {
  return {
    match: (vals) => {
      let matches;
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          continue;
        }
        if (matches == null || result.length < matches.length) {
          matches = result;
        }
      }
      if (matches == null) {
        return false;
      }
      return matches;
    }
  };
};
var and = (...matchers) => {
  return {
    match: (vals) => {
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          return false;
        }
        vals = result;
      }
      return vals;
    }
  };
};
function fmt(...matchers) {
  function match(ma) {
    if (ma == null) {
      return false;
    }
    let parts = ma.getComponents();
    for (const matcher of matchers) {
      const result = matcher.match(parts);
      if (result === false) {
        return false;
      }
      parts = result;
    }
    return parts;
  }
  function matches(ma) {
    const result = match(ma);
    return result !== false;
  }
  function exactMatch(ma) {
    const result = match(ma);
    if (result === false) {
      return false;
    }
    return result.length === 0;
  }
  return {
    matchers,
    matches,
    exactMatch
  };
}

// ../../peercompute/node_modules/@multiformats/multiaddr-matcher/dist/src/index.js
var _PEER_ID = value(CODE_P2P);
var PEER_ID = fmt(_PEER_ID);
var _DNS4 = value(CODE_DNS4);
var _DNS6 = value(CODE_DNS6);
var _DNSADDR = value(CODE_DNSADDR);
var _DNS = value(CODE_DNS);
var DNS4 = fmt(_DNS4, optional(value(CODE_P2P)));
var DNS6 = fmt(_DNS6, optional(value(CODE_P2P)));
var DNSADDR = fmt(_DNSADDR, optional(value(CODE_P2P)));
var DNS = fmt(or(_DNS, _DNSADDR, _DNS4, _DNS6), optional(value(CODE_P2P)));
var _IP4 = and(value(CODE_IP4), optional(value(CODE_IPCIDR)));
var _IP6 = and(optional(value(CODE_IP6ZONE)), value(CODE_IP6), optional(value(CODE_IPCIDR)));
var _IP = or(_IP4, _IP6);
var _IP_OR_DOMAIN = or(_IP, _DNS, _DNS4, _DNS6, _DNSADDR);
var IP_OR_DOMAIN = fmt(or(_IP, and(or(_DNS, _DNSADDR, _DNS4, _DNS6), optional(value(CODE_P2P)))));
var IP4 = fmt(_IP4);
var IP6 = fmt(_IP6);
var IP = fmt(_IP);
var _TCP = and(_IP_OR_DOMAIN, value(CODE_TCP));
var _UDP = and(_IP_OR_DOMAIN, value(CODE_UDP));
var TCP = fmt(and(_TCP, optional(value(CODE_P2P))));
var UDP = fmt(_UDP);
var _QUIC = and(_UDP, code(CODE_QUIC), optional(value(CODE_P2P)));
var _QUIC_V1 = and(_UDP, code(CODE_QUIC_V1), optional(value(CODE_P2P)));
var QUIC_V0_OR_V1 = or(_QUIC, _QUIC_V1);
var QUIC = fmt(_QUIC);
var QUIC_V1 = fmt(_QUIC_V1);
var _WEB = or(_IP_OR_DOMAIN, _TCP, _UDP, _QUIC, _QUIC_V1);
var _WebSockets = or(and(_WEB, code(CODE_WS), optional(value(CODE_P2P))));
var WebSockets = fmt(_WebSockets);
var _WebSocketsSecure = or(and(_WEB, code(CODE_WSS), optional(value(CODE_P2P))), and(_WEB, code(CODE_TLS), optional(value(CODE_SNI)), code(CODE_WS), optional(value(CODE_P2P))));
var WebSocketsSecure = fmt(_WebSocketsSecure);
var _WebRTCDirect = and(_UDP, code(CODE_WEBRTC_DIRECT), optional(value(CODE_CERTHASH)), optional(value(CODE_CERTHASH)), optional(value(CODE_P2P)));
var WebRTCDirect = fmt(_WebRTCDirect);
var _WebTransport = and(_QUIC_V1, code(CODE_WEBTRANSPORT), optional(value(CODE_CERTHASH)), optional(value(CODE_CERTHASH)), optional(value(CODE_P2P)));
var WebTransport = fmt(_WebTransport);
var _P2P = or(_WebSockets, _WebSocketsSecure, and(_TCP, optional(value(CODE_P2P))), and(QUIC_V0_OR_V1, optional(value(CODE_P2P))), and(_IP_OR_DOMAIN, optional(value(CODE_P2P))), _WebRTCDirect, _WebTransport, value(CODE_P2P));
var P2P = fmt(_P2P);
var _Circuit = and(optional(_P2P), code(CODE_P2P_CIRCUIT), not(code(CODE_WEBRTC)), optional(value(CODE_P2P)));
var Circuit = fmt(_Circuit);
var _WebRTC = or(and(_P2P, code(CODE_P2P_CIRCUIT), code(CODE_WEBRTC), optional(value(CODE_P2P))), and(_P2P, code(CODE_WEBRTC), optional(value(CODE_P2P))), and(code(CODE_WEBRTC), optional(value(CODE_P2P))));
var WebRTC = fmt(_WebRTC);
var _HTTP = or(and(_IP_OR_DOMAIN, value(CODE_TCP), code(CODE_HTTP), optional(value(CODE_P2P))), and(_IP_OR_DOMAIN, code(CODE_HTTP), optional(value(CODE_P2P))));
var HTTP = fmt(_HTTP);
var _HTTPS = and(_IP_OR_DOMAIN, or(and(value(CODE_TCP, "443"), code(CODE_HTTP)), and(value(CODE_TCP), code(CODE_HTTPS)), and(value(CODE_TCP), code(CODE_TLS), code(CODE_HTTP)), and(code(CODE_TLS), code(CODE_HTTP)), code(CODE_TLS), code(CODE_HTTPS)), optional(value(CODE_P2P)));
var HTTPS = fmt(_HTTPS);
var _Memory = or(and(value(CODE_MEMORY), optional(value(CODE_P2P))));
var Memory = fmt(_Memory);
var _Unix = or(and(value(CODE_UNIX), optional(value(CODE_P2P))));
var Unix = fmt(_Unix);

export {
  code,
  and,
  fmt,
  PEER_ID,
  IP_OR_DOMAIN,
  IP4,
  IP6,
  TCP,
  QUIC_V1,
  WebSockets,
  WebSocketsSecure,
  WebRTCDirect,
  WebTransport,
  P2P,
  Circuit,
  WebRTC
};
//# sourceMappingURL=chunk-MFNF3PBW.js.map
