import {
  CustomProgressEvent
} from "./chunk-4JMPDFLF.js";
import {
  WebSockets,
  WebSocketsSecure
} from "./chunk-MFNF3PBW.js";
import {
  AbstractMultiaddrConnection,
  repeatingTask
} from "./chunk-O3N7UJNM.js";
import {
  CODE_DNS,
  CODE_DNS4,
  CODE_DNS6,
  CODE_DNSADDR,
  CODE_IP6,
  CODE_TCP,
  CODE_TLS,
  multiaddr
} from "./chunk-DKVXG43P.js";
import {
  pEvent
} from "./chunk-HJM7NZQ6.js";
import {
  ConnectionFailedError,
  serviceCapabilities,
  transportSymbol
} from "./chunk-NTF5EBGJ.js";
import {
  fromString
} from "./chunk-5QZ7JOES.js";
import {
  __publicField
} from "./chunk-WOOG5QLI.js";

// ../../peercompute/node_modules/@multiformats/multiaddr-to-uri/dist/src/index.js
var ASSUME_HTTP_CODES = [
  CODE_TCP,
  CODE_DNS,
  CODE_DNSADDR,
  CODE_DNS4,
  CODE_DNS6
];
function extractSNI(ma) {
  var _a2;
  return (_a2 = extractTuple("sni", ma)) == null ? void 0 : _a2.value;
}
function extractPort(ma) {
  var _a2;
  const port = (_a2 = extractTuple("tcp", ma)) == null ? void 0 : _a2.value;
  if (port == null) {
    return "";
  }
  return `:${port}`;
}
function extractTuple(name, ma) {
  return ma.find((component) => component.name === name);
}
function hasTLS(ma) {
  return ma.some(({ code }) => code === CODE_TLS);
}
function interpretNext(head, rest) {
  const interpreter = interpreters[head.name];
  if (interpreter == null) {
    throw new Error(`Can't interpret protocol ${head.name}`);
  }
  const restVal = interpreter(head, rest);
  if (head.code === CODE_IP6) {
    return `[${restVal}]`;
  }
  return restVal;
}
var interpreters = {
  ip4: (head, rest) => head.value,
  ip6: (head, rest) => {
    if (rest.length === 0) {
      return head.value;
    }
    return `[${head.value}]`;
  },
  tcp: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `tcp://${interpretNext(tail, rest)}:${head.value}`;
  },
  udp: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `udp://${interpretNext(tail, rest)}:${head.value}`;
  },
  dnsaddr: (head, rest) => head.value,
  dns4: (head, rest) => head.value,
  dns6: (head, rest) => head.value,
  dns: (head, rest) => head.value,
  ipfs: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tail, rest)}`;
  },
  p2p: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tail, rest)}`;
  },
  http: (head, rest) => {
    const maHasTLS = hasTLS(rest);
    const sni = extractSNI(rest);
    const port = extractPort(rest);
    if (maHasTLS && sni != null) {
      return `https://${sni}${port}`;
    }
    const protocol = maHasTLS ? "https://" : "http://";
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tail, rest);
    baseVal = baseVal == null ? void 0 : baseVal.replace("tcp://", "");
    return `${protocol}${baseVal}`;
  },
  "http-path": (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    const baseVal = interpretNext(tail, rest);
    const decodedValue = decodeURIComponent(head.value ?? "");
    return `${baseVal}${decodedValue}`;
  },
  tls: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return interpretNext(tail, rest);
  },
  sni: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return interpretNext(tail, rest);
  },
  https: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tail, rest);
    baseVal = baseVal == null ? void 0 : baseVal.replace("tcp://", "");
    return `https://${baseVal}`;
  },
  ws: (head, rest) => {
    const maHasTLS = hasTLS(rest);
    const sni = extractSNI(rest);
    const port = extractPort(rest);
    if (maHasTLS && sni != null) {
      return `wss://${sni}${port}`;
    }
    const protocol = maHasTLS ? "wss://" : "ws://";
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tail, rest);
    baseVal = baseVal == null ? void 0 : baseVal.replace("tcp://", "");
    return `${protocol}${baseVal}`;
  },
  wss: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tail, rest);
    baseVal = baseVal == null ? void 0 : baseVal.replace("tcp://", "");
    return `wss://${baseVal}`;
  }
};
function multiaddrToUri(input, opts) {
  const ma = multiaddr(input);
  const components = ma.getComponents();
  const head = components.pop();
  if (head == null) {
    throw new Error("Unexpected end of multiaddr");
  }
  const interpreter = interpreters[head.name];
  if (interpreter == null) {
    throw new Error(`No interpreter found for ${head.name}`);
  }
  let uri = interpreter(head, components) ?? "";
  if ((opts == null ? void 0 : opts.assumeHttp) !== false && ASSUME_HTTP_CODES.includes(head.code)) {
    uri = uri.replace(/^.*:\/\//, "");
    if (head.value === "443") {
      uri = `https://${uri}`;
    } else {
      uri = `http://${uri}`;
    }
  }
  if (uri.startsWith("http://") || uri.startsWith("https://") || uri.startsWith("ws://") || uri.startsWith("wss://")) {
    uri = new URL(uri).toString();
    if (uri.endsWith("/")) {
      uri = uri.substring(0, uri.length - 1);
    }
  }
  return uri;
}

// ../../peercompute/node_modules/@libp2p/websockets/dist/src/listener.browser.js
function createListener() {
  throw new Error("WebSocket Servers can not be created in the browser!");
}

// ../../peercompute/node_modules/@libp2p/websockets/dist/src/websocket-to-conn.js
var DEFAULT_MAX_BUFFERED_AMOUNT = 1024 * 1024 * 4;
var DEFAULT_BUFFERED_AMOUNT_POLL_INTERVAL = 10;
var WebSocketMultiaddrConnection = class extends AbstractMultiaddrConnection {
  constructor(init) {
    super(init);
    __publicField(this, "websocket");
    __publicField(this, "maxBufferedAmount");
    __publicField(this, "checkBufferedAmountTask");
    this.websocket = init.websocket;
    this.maxBufferedAmount = init.maxBufferedAmount ?? DEFAULT_MAX_BUFFERED_AMOUNT;
    this.checkBufferedAmountTask = repeatingTask(this.checkBufferedAmount.bind(this), init.bufferedAmountPollInterval ?? DEFAULT_BUFFERED_AMOUNT_POLL_INTERVAL);
    this.websocket.addEventListener("close", (evt) => {
      this.log('closed - code %d, reason "%s", wasClean %s', evt.code, evt.reason, evt.wasClean);
      this.checkBufferedAmountTask.stop();
      if (!evt.wasClean) {
        this.onRemoteReset();
        return;
      }
      this.onTransportClosed();
    }, { once: true });
    this.websocket.addEventListener("message", (evt) => {
      try {
        let buf;
        if (typeof evt.data === "string") {
          buf = fromString(evt.data);
        } else if (evt.data instanceof ArrayBuffer) {
          buf = new Uint8Array(evt.data, 0, evt.data.byteLength);
        } else {
          this.abort(new Error("Incorrect binary type"));
          return;
        }
        this.onData(buf);
      } catch (err) {
        this.log.error("error receiving data - %e", err);
      }
    });
  }
  sendData(data) {
    for (const buf of data) {
      this.websocket.send(buf);
    }
    const canSendMore = this.websocket.bufferedAmount < this.maxBufferedAmount;
    if (!canSendMore) {
      this.checkBufferedAmountTask.start();
    }
    return {
      sentBytes: data.byteLength,
      canSendMore
    };
  }
  sendReset() {
    this.websocket.close(1006);
  }
  async sendClose(options) {
    var _a2;
    this.websocket.close();
    (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
  }
  sendPause() {
  }
  sendResume() {
  }
  checkBufferedAmount() {
    this.log("buffered amount now %d", this.websocket.bufferedAmount);
    if (this.websocket.bufferedAmount === 0) {
      this.checkBufferedAmountTask.stop();
      this.safeDispatchEvent("drain");
    }
  }
};
function webSocketToMaConn(init) {
  return new WebSocketMultiaddrConnection(init);
}

// ../../peercompute/node_modules/@libp2p/websockets/dist/src/index.js
var _a, _b, _c;
_c = transportSymbol, _b = Symbol.toStringTag, _a = serviceCapabilities;
var WebSockets2 = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "init");
    __publicField(this, "logger");
    __publicField(this, "metrics");
    __publicField(this, "components");
    __publicField(this, _c, true);
    __publicField(this, _b, "@libp2p/websockets");
    __publicField(this, _a, [
      "@libp2p/transport"
    ]);
    this.log = components.logger.forComponent("libp2p:websockets");
    this.logger = components.logger;
    this.components = components;
    this.init = init;
    if (components.metrics != null) {
      this.metrics = {
        dialerEvents: components.metrics.registerCounterGroup("libp2p_websockets_dialer_events_total", {
          label: "event",
          help: "Total count of WebSockets dialer events by type"
        })
      };
    }
  }
  async dial(ma, options) {
    var _a2;
    this.log("dialing %s", ma);
    options = options ?? {};
    const maConn = webSocketToMaConn({
      websocket: await this._connect(ma, options),
      remoteAddr: ma,
      metrics: (_a2 = this.metrics) == null ? void 0 : _a2.dialerEvents,
      direction: "outbound",
      log: this.components.logger.forComponent("libp2p:websockets:connection"),
      maxBufferedAmount: this.init.maxBufferedAmount,
      bufferedAmountPollInterval: this.init.bufferedAmountPollInterval
    });
    this.log("new outbound connection %s", maConn.remoteAddr);
    const conn = await options.upgrader.upgradeOutbound(maConn, options);
    this.log("outbound connection %s upgraded", maConn.remoteAddr);
    return conn;
  }
  async _connect(ma, options) {
    var _a2, _b2, _c2, _d, _e, _f;
    (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
    const uri = multiaddrToUri(ma);
    this.log("create websocket connection to %s", uri);
    const websocket = new WebSocket(uri);
    websocket.binaryType = "arraybuffer";
    try {
      (_b2 = options.onProgress) == null ? void 0 : _b2.call(options, new CustomProgressEvent("websockets:open-connection"));
      await pEvent(websocket, "open", options);
    } catch (err) {
      if ((_c2 = options.signal) == null ? void 0 : _c2.aborted) {
        (_d = this.metrics) == null ? void 0 : _d.dialerEvents.increment({ abort: true });
        throw new ConnectionFailedError(`Could not connect to ${uri}`);
      } else {
        (_e = this.metrics) == null ? void 0 : _e.dialerEvents.increment({ error: true });
      }
      try {
        websocket.close();
      } catch {
      }
      throw err;
    }
    this.log("connected %s", ma);
    (_f = this.metrics) == null ? void 0 : _f.dialerEvents.increment({ connect: true });
    return websocket;
  }
  /**
   * Creates a WebSockets listener. The provided `handler` function will be called
   * anytime a new incoming Connection has been successfully upgraded via
   * `upgrader.upgradeInbound`
   */
  createListener(options) {
    return createListener({
      logger: this.logger,
      events: this.components.events,
      metrics: this.components.metrics
    }, {
      ...this.init,
      ...options
    });
  }
  listenFilter(multiaddrs) {
    return multiaddrs.filter((ma) => WebSockets.exactMatch(ma) || WebSocketsSecure.exactMatch(ma));
  }
  dialFilter(multiaddrs) {
    return this.listenFilter(multiaddrs);
  }
};
function webSockets(init = {}) {
  return (components) => {
    return new WebSockets2(components, init);
  };
}
export {
  webSockets
};
//# sourceMappingURL=@libp2p_websockets.js.map
