{
  "version": 3,
  "sources": ["../../../../../node_modules/@libp2p/floodsub/src/constants.ts", "../../../../../node_modules/@libp2p/floodsub/src/cache.ts", "../../../../../node_modules/@libp2p/floodsub/src/message/rpc.ts", "../../../../../node_modules/@libp2p/floodsub/src/peer-streams.ts", "../../../../../node_modules/@libp2p/floodsub/src/utils.ts", "../../../../../node_modules/@libp2p/floodsub/src/sign.ts", "../../../../../node_modules/@libp2p/floodsub/src/floodsub.ts", "../../../../../node_modules/@libp2p/floodsub/src/index.ts"],
  "sourcesContent": ["/**\n * All Pubsub implementations must use this symbol as the name of a property\n * with a boolean `true` value\n */\nexport const pubSubSymbol = Symbol.for('@libp2p/pubsub')\n", "interface SimpleTimeCacheOpts {\n  validityMs: number\n}\n\ninterface CacheValue<T> {\n  value: T\n  validUntilMs: number\n}\n\n/**\n * This is similar to https://github.com/daviddias/time-cache/blob/master/src/index.js\n * for our own need, we don't use lodash throttle to improve performance.\n * This gives 4x - 5x performance gain compared to npm TimeCache\n */\nexport class SimpleTimeCache<T> {\n  private entries: Map<string, CacheValue<T>>\n  private readonly validityMs: number\n  private lastPruneTime = 0\n\n  constructor (options: SimpleTimeCacheOpts) {\n    this.entries = new Map()\n    this.validityMs = options.validityMs\n\n    // allow negative validityMs so that this does not cache anything, spec test compliance.spec.js\n    // sends duplicate messages and expect peer to receive all. Application likely uses positive validityMs\n  }\n\n  put (key: string, value: T): void {\n    this.entries.set(key, { value, validUntilMs: Date.now() + this.validityMs })\n    this.prune()\n  }\n\n  prune (): void {\n    const now = Date.now()\n    if (now - this.lastPruneTime < 200) {\n      return\n    }\n    this.lastPruneTime = now\n\n    for (const [k, v] of this.entries.entries()) {\n      if (v.validUntilMs < now) {\n        this.entries.delete(k)\n      } else {\n        // sort by insertion order\n        break\n      }\n    }\n  }\n\n  has (key: string): boolean {\n    return this.entries.has(key)\n  }\n\n  get (key: string): T | undefined {\n    const value = this.entries.get(key)\n    return (value != null && value.validUntilMs >= Date.now()) ? value.value : undefined\n  }\n\n  clear (): void {\n    this.entries = new Map()\n    this.lastPruneTime = 0\n  }\n}\n", "/* eslint-disable complexity */\n\nimport { decodeMessage, encodeMessage, MaxLengthError, message } from 'protons-runtime'\nimport type { Codec, DecodeOptions } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface RPC {\n  subscriptions: RPC.SubOpts[]\n  messages: RPC.Message[]\n  control?: ControlMessage\n}\n\nexport namespace RPC {\n  export interface SubOpts {\n    subscribe?: boolean\n    topic?: string\n  }\n\n  export namespace SubOpts {\n    let _codec: Codec<SubOpts>\n\n    export const codec = (): Codec<SubOpts> => {\n      if (_codec == null) {\n        _codec = message<SubOpts>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if (obj.subscribe != null) {\n            w.uint32(8)\n            w.bool(obj.subscribe)\n          }\n\n          if (obj.topic != null) {\n            w.uint32(18)\n            w.string(obj.topic)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {}\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                obj.subscribe = reader.bool()\n                break\n              }\n              case 2: {\n                obj.topic = reader.string()\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<SubOpts>): Uint8Array => {\n      return encodeMessage(obj, SubOpts.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<SubOpts>): SubOpts => {\n      return decodeMessage(buf, SubOpts.codec(), opts)\n    }\n  }\n\n  export interface Message {\n    from?: Uint8Array\n    data?: Uint8Array\n    sequenceNumber?: Uint8Array\n    topic?: string\n    signature?: Uint8Array\n    key?: Uint8Array\n  }\n\n  export namespace Message {\n    let _codec: Codec<Message>\n\n    export const codec = (): Codec<Message> => {\n      if (_codec == null) {\n        _codec = message<Message>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if (obj.from != null) {\n            w.uint32(10)\n            w.bytes(obj.from)\n          }\n\n          if (obj.data != null) {\n            w.uint32(18)\n            w.bytes(obj.data)\n          }\n\n          if (obj.sequenceNumber != null) {\n            w.uint32(26)\n            w.bytes(obj.sequenceNumber)\n          }\n\n          if (obj.topic != null) {\n            w.uint32(34)\n            w.string(obj.topic)\n          }\n\n          if (obj.signature != null) {\n            w.uint32(42)\n            w.bytes(obj.signature)\n          }\n\n          if (obj.key != null) {\n            w.uint32(50)\n            w.bytes(obj.key)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {}\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                obj.from = reader.bytes()\n                break\n              }\n              case 2: {\n                obj.data = reader.bytes()\n                break\n              }\n              case 3: {\n                obj.sequenceNumber = reader.bytes()\n                break\n              }\n              case 4: {\n                obj.topic = reader.string()\n                break\n              }\n              case 5: {\n                obj.signature = reader.bytes()\n                break\n              }\n              case 6: {\n                obj.key = reader.bytes()\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<Message>): Uint8Array => {\n      return encodeMessage(obj, Message.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Message>): Message => {\n      return decodeMessage(buf, Message.codec(), opts)\n    }\n  }\n\n  let _codec: Codec<RPC>\n\n  export const codec = (): Codec<RPC> => {\n    if (_codec == null) {\n      _codec = message<RPC>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.subscriptions != null) {\n          for (const value of obj.subscriptions) {\n            w.uint32(10)\n            RPC.SubOpts.codec().encode(value, w)\n          }\n        }\n\n        if (obj.messages != null) {\n          for (const value of obj.messages) {\n            w.uint32(18)\n            RPC.Message.codec().encode(value, w)\n          }\n        }\n\n        if (obj.control != null) {\n          w.uint32(26)\n          ControlMessage.codec().encode(obj.control, w)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          subscriptions: [],\n          messages: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              if (opts.limits?.subscriptions != null && obj.subscriptions.length === opts.limits.subscriptions) {\n                throw new MaxLengthError('Decode error - map field \"subscriptions\" had too many elements')\n              }\n\n              obj.subscriptions.push(RPC.SubOpts.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.subscriptions$\n              }))\n              break\n            }\n            case 2: {\n              if (opts.limits?.messages != null && obj.messages.length === opts.limits.messages) {\n                throw new MaxLengthError('Decode error - map field \"messages\" had too many elements')\n              }\n\n              obj.messages.push(RPC.Message.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.messages$\n              }))\n              break\n            }\n            case 3: {\n              obj.control = ControlMessage.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.control\n              })\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<RPC>): Uint8Array => {\n    return encodeMessage(obj, RPC.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<RPC>): RPC => {\n    return decodeMessage(buf, RPC.codec(), opts)\n  }\n}\n\nexport interface ControlMessage {\n  ihave: ControlIHave[]\n  iwant: ControlIWant[]\n  graft: ControlGraft[]\n  prune: ControlPrune[]\n}\n\nexport namespace ControlMessage {\n  let _codec: Codec<ControlMessage>\n\n  export const codec = (): Codec<ControlMessage> => {\n    if (_codec == null) {\n      _codec = message<ControlMessage>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.ihave != null) {\n          for (const value of obj.ihave) {\n            w.uint32(10)\n            ControlIHave.codec().encode(value, w)\n          }\n        }\n\n        if (obj.iwant != null) {\n          for (const value of obj.iwant) {\n            w.uint32(18)\n            ControlIWant.codec().encode(value, w)\n          }\n        }\n\n        if (obj.graft != null) {\n          for (const value of obj.graft) {\n            w.uint32(26)\n            ControlGraft.codec().encode(value, w)\n          }\n        }\n\n        if (obj.prune != null) {\n          for (const value of obj.prune) {\n            w.uint32(34)\n            ControlPrune.codec().encode(value, w)\n          }\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          ihave: [],\n          iwant: [],\n          graft: [],\n          prune: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              if (opts.limits?.ihave != null && obj.ihave.length === opts.limits.ihave) {\n                throw new MaxLengthError('Decode error - map field \"ihave\" had too many elements')\n              }\n\n              obj.ihave.push(ControlIHave.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.ihave$\n              }))\n              break\n            }\n            case 2: {\n              if (opts.limits?.iwant != null && obj.iwant.length === opts.limits.iwant) {\n                throw new MaxLengthError('Decode error - map field \"iwant\" had too many elements')\n              }\n\n              obj.iwant.push(ControlIWant.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.iwant$\n              }))\n              break\n            }\n            case 3: {\n              if (opts.limits?.graft != null && obj.graft.length === opts.limits.graft) {\n                throw new MaxLengthError('Decode error - map field \"graft\" had too many elements')\n              }\n\n              obj.graft.push(ControlGraft.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.graft$\n              }))\n              break\n            }\n            case 4: {\n              if (opts.limits?.prune != null && obj.prune.length === opts.limits.prune) {\n                throw new MaxLengthError('Decode error - map field \"prune\" had too many elements')\n              }\n\n              obj.prune.push(ControlPrune.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.prune$\n              }))\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<ControlMessage>): Uint8Array => {\n    return encodeMessage(obj, ControlMessage.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<ControlMessage>): ControlMessage => {\n    return decodeMessage(buf, ControlMessage.codec(), opts)\n  }\n}\n\nexport interface ControlIHave {\n  topic?: string\n  messageIDs: Uint8Array[]\n}\n\nexport namespace ControlIHave {\n  let _codec: Codec<ControlIHave>\n\n  export const codec = (): Codec<ControlIHave> => {\n    if (_codec == null) {\n      _codec = message<ControlIHave>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.topic != null) {\n          w.uint32(10)\n          w.string(obj.topic)\n        }\n\n        if (obj.messageIDs != null) {\n          for (const value of obj.messageIDs) {\n            w.uint32(18)\n            w.bytes(value)\n          }\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          messageIDs: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.topic = reader.string()\n              break\n            }\n            case 2: {\n              if (opts.limits?.messageIDs != null && obj.messageIDs.length === opts.limits.messageIDs) {\n                throw new MaxLengthError('Decode error - map field \"messageIDs\" had too many elements')\n              }\n\n              obj.messageIDs.push(reader.bytes())\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<ControlIHave>): Uint8Array => {\n    return encodeMessage(obj, ControlIHave.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<ControlIHave>): ControlIHave => {\n    return decodeMessage(buf, ControlIHave.codec(), opts)\n  }\n}\n\nexport interface ControlIWant {\n  messageIDs: Uint8Array[]\n}\n\nexport namespace ControlIWant {\n  let _codec: Codec<ControlIWant>\n\n  export const codec = (): Codec<ControlIWant> => {\n    if (_codec == null) {\n      _codec = message<ControlIWant>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.messageIDs != null) {\n          for (const value of obj.messageIDs) {\n            w.uint32(10)\n            w.bytes(value)\n          }\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          messageIDs: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              if (opts.limits?.messageIDs != null && obj.messageIDs.length === opts.limits.messageIDs) {\n                throw new MaxLengthError('Decode error - map field \"messageIDs\" had too many elements')\n              }\n\n              obj.messageIDs.push(reader.bytes())\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<ControlIWant>): Uint8Array => {\n    return encodeMessage(obj, ControlIWant.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<ControlIWant>): ControlIWant => {\n    return decodeMessage(buf, ControlIWant.codec(), opts)\n  }\n}\n\nexport interface ControlGraft {\n  topic?: string\n}\n\nexport namespace ControlGraft {\n  let _codec: Codec<ControlGraft>\n\n  export const codec = (): Codec<ControlGraft> => {\n    if (_codec == null) {\n      _codec = message<ControlGraft>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.topic != null) {\n          w.uint32(10)\n          w.string(obj.topic)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.topic = reader.string()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<ControlGraft>): Uint8Array => {\n    return encodeMessage(obj, ControlGraft.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<ControlGraft>): ControlGraft => {\n    return decodeMessage(buf, ControlGraft.codec(), opts)\n  }\n}\n\nexport interface ControlPrune {\n  topic?: string\n  peers: PeerInfo[]\n  backoff?: bigint\n}\n\nexport namespace ControlPrune {\n  let _codec: Codec<ControlPrune>\n\n  export const codec = (): Codec<ControlPrune> => {\n    if (_codec == null) {\n      _codec = message<ControlPrune>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.topic != null) {\n          w.uint32(10)\n          w.string(obj.topic)\n        }\n\n        if (obj.peers != null) {\n          for (const value of obj.peers) {\n            w.uint32(18)\n            PeerInfo.codec().encode(value, w)\n          }\n        }\n\n        if (obj.backoff != null) {\n          w.uint32(24)\n          w.uint64(obj.backoff)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          peers: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.topic = reader.string()\n              break\n            }\n            case 2: {\n              if (opts.limits?.peers != null && obj.peers.length === opts.limits.peers) {\n                throw new MaxLengthError('Decode error - map field \"peers\" had too many elements')\n              }\n\n              obj.peers.push(PeerInfo.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.peers$\n              }))\n              break\n            }\n            case 3: {\n              obj.backoff = reader.uint64()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<ControlPrune>): Uint8Array => {\n    return encodeMessage(obj, ControlPrune.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<ControlPrune>): ControlPrune => {\n    return decodeMessage(buf, ControlPrune.codec(), opts)\n  }\n}\n\nexport interface PeerInfo {\n  peerID?: Uint8Array\n  signedPeerRecord?: Uint8Array\n}\n\nexport namespace PeerInfo {\n  let _codec: Codec<PeerInfo>\n\n  export const codec = (): Codec<PeerInfo> => {\n    if (_codec == null) {\n      _codec = message<PeerInfo>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.peerID != null) {\n          w.uint32(10)\n          w.bytes(obj.peerID)\n        }\n\n        if (obj.signedPeerRecord != null) {\n          w.uint32(18)\n          w.bytes(obj.signedPeerRecord)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.peerID = reader.bytes()\n              break\n            }\n            case 2: {\n              obj.signedPeerRecord = reader.bytes()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<PeerInfo>): Uint8Array => {\n    return encodeMessage(obj, PeerInfo.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<PeerInfo>): PeerInfo => {\n    return decodeMessage(buf, PeerInfo.codec(), opts)\n  }\n}\n", "import { pbStream } from '@libp2p/utils'\nimport { TypedEventEmitter } from 'main-event'\nimport { RPC } from './message/rpc.ts'\nimport type { PubSubRPC } from './floodsub.ts'\nimport type { PeerStreamsEvents } from './index.ts'\nimport type { Stream, PeerId } from '@libp2p/interface'\nimport type { ProtobufMessageStream, ProtobufStreamOpts } from '@libp2p/utils'\nimport type { DecoderOptions as LpDecoderOptions } from 'it-length-prefixed'\n\nexport interface PeerStreamInit {\n  peerId: PeerId\n  stream: Stream\n}\n\nexport interface DecoderOptions extends LpDecoderOptions {\n  // other custom options we might want for `attachInboundStream`\n}\n\n/**\n * Thin wrapper around a peer's inbound / outbound pubsub streams\n */\nexport class PeerStreams extends TypedEventEmitter<PeerStreamsEvents> {\n  public readonly peerId: PeerId\n\n  /**\n   * An AbortController for controlled shutdown of the inbound stream\n   */\n  private readonly shutDownController: AbortController\n  // messages sent by the remote\n  private inboundPb?: ProtobufMessageStream<RPC>\n  // messages we send\n  private outboundPb?: ProtobufMessageStream<RPC>\n\n  constructor (peerId: PeerId) {\n    super()\n\n    this.peerId = peerId\n    this.shutDownController = new AbortController()\n  }\n\n  attachInboundStream (stream: Stream, streamOpts?: Partial<ProtobufStreamOpts>): void {\n    this.inboundPb = pbStream(stream, streamOpts).pb(RPC)\n\n    Promise.resolve().then(async () => {\n      while (true) {\n        if (this.inboundPb == null) {\n          return\n        }\n\n        const message = await this.inboundPb.read({\n          signal: this.shutDownController.signal\n        })\n\n        this.safeDispatchEvent('message', {\n          detail: message\n        })\n      }\n    })\n      .catch(err => {\n        this.inboundPb?.unwrap().unwrap().abort(err)\n      })\n  }\n\n  attachOutboundStream (stream: Stream, streamOpts?: Partial<ProtobufStreamOpts>): void {\n    this.outboundPb = pbStream(stream, streamOpts).pb(RPC)\n  }\n\n  /**\n   * Send a message to this peer\n   */\n  write (message: PubSubRPC): void {\n    if (this.outboundPb == null) {\n      return\n    }\n\n    this.outboundPb.write(message, {\n      signal: this.shutDownController.signal\n    })\n      .catch(err => {\n        this.outboundPb?.unwrap().unwrap().abort(err)\n      })\n  }\n\n  /**\n   * Closes the open connection to peer\n   */\n  close (): void {\n    this.shutDownController.abort()\n\n    Promise.all([\n      this.inboundPb?.unwrap().unwrap().close()\n        .catch(err => {\n          this.inboundPb?.unwrap().unwrap().abort(err)\n        }),\n      this.outboundPb?.unwrap().unwrap().close()\n        .catch(err => {\n          this.inboundPb?.unwrap().unwrap().abort(err)\n        })\n    ])\n      .finally(() => {\n        this.safeDispatchEvent('close')\n      })\n  }\n}\n", "import { randomBytes } from '@libp2p/crypto'\nimport { publicKeyFromProtobuf, publicKeyToProtobuf } from '@libp2p/crypto/keys'\nimport { InvalidMessageError } from '@libp2p/interface'\nimport { peerIdFromMultihash, peerIdFromPublicKey } from '@libp2p/peer-id'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport type { PubSubRPCMessage } from './floodsub.ts'\nimport type { Message } from './index.ts'\nimport type { PublicKey } from '@libp2p/interface'\n\n/**\n * Generate a random sequence number\n */\nexport function randomSeqno (): bigint {\n  return BigInt(`0x${uint8ArrayToString(randomBytes(8), 'base16')}`)\n}\n\n/**\n * Generate a message id, based on the `key` and `seqno`\n */\nexport const msgId = (key: PublicKey, seqno: bigint): Uint8Array => {\n  const seqnoBytes = uint8ArrayFromString(seqno.toString(16).padStart(16, '0'), 'base16')\n  const keyBytes = publicKeyToProtobuf(key)\n\n  const msgId = new Uint8Array(keyBytes.byteLength + seqnoBytes.length)\n  msgId.set(keyBytes, 0)\n  msgId.set(seqnoBytes, keyBytes.byteLength)\n\n  return msgId\n}\n\n/**\n * Generate a message id, based on message `data`\n */\nexport const noSignMsgId = (data: Uint8Array): Uint8Array | Promise<Uint8Array> => {\n  return sha256.encode(data)\n}\n\n/**\n * Check if any member of the first set is also a member\n * of the second set\n */\nexport const anyMatch = (a: Set<number> | number[], b: Set<number> | number[]): boolean => {\n  let bHas\n  if (Array.isArray(b)) {\n    bHas = (val: number) => b.includes(val)\n  } else {\n    bHas = (val: number) => b.has(val)\n  }\n\n  for (const val of a) {\n    if (bHas(val)) {\n      return true\n    }\n  }\n\n  return false\n}\n\nconst isSigned = async (message: PubSubRPCMessage): Promise<boolean> => {\n  if ((message.sequenceNumber == null) || (message.from == null) || (message.signature == null)) {\n    return false\n  }\n  // if a public key is present in the `from` field, the message should be signed\n  const fromID = peerIdFromMultihash(Digest.decode(message.from))\n  if (fromID.publicKey != null) {\n    return true\n  }\n\n  if (message.key != null) {\n    const signingKey = message.key\n    const signingID = peerIdFromPublicKey(publicKeyFromProtobuf(signingKey))\n\n    return signingID.equals(fromID)\n  }\n\n  return false\n}\n\nexport const toMessage = async (message: PubSubRPCMessage): Promise<Message> => {\n  if (message.from == null) {\n    throw new InvalidMessageError('RPC message was missing from')\n  }\n\n  if (!await isSigned(message)) {\n    return {\n      type: 'unsigned',\n      topic: message.topic ?? '',\n      data: message.data ?? new Uint8Array(0)\n    }\n  }\n\n  const from = peerIdFromMultihash(Digest.decode(message.from))\n  const key = message.key ?? from.publicKey\n\n  if (key == null) {\n    throw new InvalidMessageError('RPC message was missing public key')\n  }\n\n  const msg: Message = {\n    type: 'signed',\n    from,\n    topic: message.topic ?? '',\n    sequenceNumber: bigIntFromBytes(message.sequenceNumber ?? new Uint8Array(0)),\n    data: message.data ?? new Uint8Array(0),\n    signature: message.signature ?? new Uint8Array(0),\n    key: key instanceof Uint8Array ? publicKeyFromProtobuf(key) : key\n  }\n\n  return msg\n}\n\nexport const toRpcMessage = (message: Message): PubSubRPCMessage => {\n  if (message.type === 'signed') {\n    return {\n      from: message.from.toMultihash().bytes,\n      data: message.data,\n      sequenceNumber: bigIntToBytes(message.sequenceNumber),\n      topic: message.topic,\n      signature: message.signature,\n\n      key: message.key ? publicKeyToProtobuf(message.key) : undefined\n    }\n  }\n\n  return {\n    data: message.data,\n    topic: message.topic\n  }\n}\n\nexport const bigIntToBytes = (num: bigint): Uint8Array => {\n  let str = num.toString(16)\n\n  if (str.length % 2 !== 0) {\n    str = `0${str}`\n  }\n\n  return uint8ArrayFromString(str, 'base16')\n}\n\nexport const bigIntFromBytes = (num: Uint8Array): bigint => {\n  return BigInt(`0x${uint8ArrayToString(num, 'base16')}`)\n}\n", "import { peerIdFromPrivateKey } from '@libp2p/peer-id'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toRpcMessage } from './utils.js'\nimport type { PubSubRPCMessage } from './floodsub.ts'\nimport type { SignedMessage } from './index.ts'\nimport type { PeerId, PrivateKey, PublicKey } from '@libp2p/interface'\n\nexport const SignPrefix = uint8ArrayFromString('libp2p-pubsub:')\n\n/**\n * Signs the provided message with the given `peerId`\n */\nexport async function signMessage (privateKey: PrivateKey, message: { from: PeerId, topic: string, data: Uint8Array, sequenceNumber: bigint }, encode: (rpc: PubSubRPCMessage) => Uint8Array): Promise<SignedMessage> {\n  // @ts-expect-error signature field is missing, added below\n  const outputMessage: SignedMessage = {\n    type: 'signed',\n    topic: message.topic,\n    data: message.data,\n    sequenceNumber: message.sequenceNumber,\n    from: peerIdFromPrivateKey(privateKey)\n  }\n\n  // Get the message in bytes, and prepend with the pubsub prefix\n  const bytes = uint8ArrayConcat([\n    SignPrefix,\n    encode(toRpcMessage(outputMessage)).subarray()\n  ])\n\n  outputMessage.signature = await privateKey.sign(bytes)\n  outputMessage.key = privateKey.publicKey\n\n  return outputMessage\n}\n\n/**\n * Verifies the signature of the given message\n */\nexport async function verifySignature (message: SignedMessage, encode: (rpc: PubSubRPCMessage) => Uint8Array): Promise<boolean> {\n  if (message.type !== 'signed') {\n    throw new Error('Message type must be \"signed\" to be verified')\n  }\n\n  if (message.signature == null) {\n    throw new Error('Message must contain a signature to be verified')\n  }\n\n  if (message.from == null) {\n    throw new Error('Message must contain a from property to be verified')\n  }\n\n  // Get message sans the signature\n  const bytes = uint8ArrayConcat([\n    SignPrefix,\n    encode({\n      ...toRpcMessage(message),\n      signature: undefined,\n      key: undefined\n    }).subarray()\n  ])\n\n  // Get the public key\n  const pubKey = messagePublicKey(message)\n\n  // verify the base message\n  return pubKey.verify(bytes, message.signature)\n}\n\n/**\n * Returns the PublicKey associated with the given message.\n * If no valid PublicKey can be retrieved an error will be returned.\n */\nexport function messagePublicKey (message: SignedMessage): PublicKey {\n  if (message.type !== 'signed') {\n    throw new Error('Message type must be \"signed\" to have a public key')\n  }\n\n  // should be available in the from property of the message (peer id)\n  if (message.from == null) {\n    throw new Error('Could not get the public key from the originator id')\n  }\n\n  if (message.key != null) {\n    return message.key\n  }\n\n  if (message.from.publicKey != null) {\n    return message.from.publicKey\n  }\n\n  // We couldn't validate pubkey is from the originator, error\n  throw new Error('Could not get the public key from the originator id')\n}\n", "import { InvalidMessageError, NotStartedError, InvalidParametersError, serviceCapabilities, serviceDependencies } from '@libp2p/interface'\nimport { PeerMap, PeerSet } from '@libp2p/peer-collections'\nimport { TypedEventEmitter } from 'main-event'\nimport Queue from 'p-queue'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { SimpleTimeCache } from './cache.js'\nimport { pubSubSymbol } from './constants.ts'\nimport { RPC } from './message/rpc.js'\nimport { PeerStreams } from './peer-streams.js'\nimport { signMessage, verifySignature } from './sign.js'\nimport { toMessage, noSignMsgId, msgId, toRpcMessage, randomSeqno } from './utils.js'\nimport { protocol, StrictNoSign, TopicValidatorResult, StrictSign } from './index.js'\nimport type { FloodSubComponents, FloodSubEvents, FloodSubInit, FloodSub as FloodSubInterface, Message, PublishResult, SubscriptionChangeData, TopicValidatorFn } from './index.js'\nimport type { Logger, Connection, PeerId, Stream } from '@libp2p/interface'\n\nexport interface PubSubRPCMessage {\n  from?: Uint8Array\n  topic?: string\n  data?: Uint8Array\n  sequenceNumber?: Uint8Array\n  signature?: Uint8Array\n  key?: Uint8Array\n}\n\nexport interface PubSubRPCSubscription {\n  subscribe?: boolean\n  topic?: string\n}\n\nexport interface PubSubRPC {\n  subscriptions: PubSubRPCSubscription[]\n  messages: PubSubRPCMessage[]\n}\n\n/**\n * PubSubBaseProtocol handles the peers and connections logic for pubsub routers\n * and specifies the API that pubsub routers should have.\n */\nexport class FloodSub extends TypedEventEmitter<FloodSubEvents> implements FloodSubInterface {\n  protected log: Logger\n\n  public started: boolean\n  /**\n   * Map of topics to which peers are subscribed to\n   */\n  public topics: Map<string, PeerSet>\n  /**\n   * List of our subscriptions\n   */\n  public subscriptions: Set<string>\n  /**\n   * Map of peer streams\n   */\n  public peers: PeerMap<PeerStreams>\n  /**\n   * The signature policy to follow by default\n   */\n  public globalSignaturePolicy: typeof StrictNoSign | typeof StrictSign\n  /**\n   * If router can relay received messages, even if not subscribed\n   */\n  public canRelayMessage: boolean\n  /**\n   * if publish should emit to self, if subscribed\n   */\n  public emitSelf: boolean\n  /**\n   * Topic validator map\n   *\n   * Keyed by topic\n   * Topic validators are functions with the following input:\n   */\n  public topicValidators: Map<string, TopicValidatorFn>\n  public queue: Queue\n  public protocol: string\n  public components: FloodSubComponents\n\n  private _registrarTopologyId: string | undefined\n  private readonly maxInboundStreams: number\n  private readonly maxOutboundStreams: number\n  public seenCache: SimpleTimeCache<boolean>\n\n  constructor (components: FloodSubComponents, init: FloodSubInit) {\n    super()\n\n    this.log = components.logger.forComponent('libp2p:floodsub')\n    this.components = components\n    this.protocol = init.protocol ?? protocol\n    this.started = false\n    this.topics = new Map()\n    this.subscriptions = new Set()\n    this.peers = new PeerMap<PeerStreams>()\n    this.globalSignaturePolicy = init.globalSignaturePolicy === 'StrictNoSign' ? 'StrictNoSign' : 'StrictSign'\n    this.canRelayMessage = init.canRelayMessage ?? true\n    this.emitSelf = init.emitSelf ?? false\n    this.topicValidators = new Map()\n    this.queue = new Queue({\n      concurrency: init.messageProcessingConcurrency ?? 10\n    })\n    this.maxInboundStreams = init.maxInboundStreams ?? 1\n    this.maxOutboundStreams = init.maxOutboundStreams ?? 1\n    this.seenCache = new SimpleTimeCache<boolean>({\n      validityMs: init?.seenTTL ?? 30000\n    })\n\n    this._onIncomingStream = this._onIncomingStream.bind(this)\n    this._onPeerConnected = this._onPeerConnected.bind(this)\n    this._onPeerDisconnected = this._onPeerDisconnected.bind(this)\n  }\n\n  readonly [pubSubSymbol] = true\n\n  readonly [Symbol.toStringTag] = '@libp2p/floodsub'\n\n  readonly [serviceCapabilities]: string[] = [\n    '@libp2p/pubsub'\n  ]\n\n  readonly [serviceDependencies]: string[] = [\n    '@libp2p/identify'\n  ]\n\n  // LIFECYCLE METHODS\n\n  /**\n   * Register the pubsub protocol onto the libp2p node.\n   */\n  async start (): Promise<void> {\n    if (this.started) {\n      return\n    }\n\n    this.log('starting')\n\n    // Incoming streams\n    // Called after a peer dials us\n    await this.components.registrar.handle(this.protocol, this._onIncomingStream, {\n      maxInboundStreams: this.maxInboundStreams,\n      maxOutboundStreams: this.maxOutboundStreams\n    })\n\n    // register protocol with topology\n    // Topology callbacks called after identify has run on a new connection\n    this._registrarTopologyId = await this.components.registrar.register(this.protocol, {\n      onConnect: this._onPeerConnected,\n      onDisconnect: this._onPeerDisconnected\n    })\n\n    this.log('started')\n    this.started = true\n  }\n\n  /**\n   * Unregister the pubsub protocol and the streams with other peers will be closed.\n   */\n  async stop (): Promise<void> {\n    if (!this.started) {\n      return\n    }\n\n    const registrar = this.components.registrar\n\n    // unregister protocol and handlers\n    if (this._registrarTopologyId != null) {\n      registrar.unregister(this._registrarTopologyId)\n    }\n\n    await registrar.unhandle(this.protocol)\n\n    this.log('stopping')\n    for (const peerStreams of this.peers.values()) {\n      peerStreams.close()\n    }\n\n    this.peers.clear()\n    this.subscriptions = new Set()\n    this.started = false\n    this.log('stopped')\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  /**\n   * On an inbound stream opened\n   */\n  protected _onIncomingStream (stream: Stream, connection: Connection): void {\n    const peerStreams = this.addPeer(connection.remotePeer, stream)\n    peerStreams.attachInboundStream(stream)\n  }\n\n  /**\n   * Registrar notifies an established connection with pubsub protocol\n   */\n  protected async _onPeerConnected (peerId: PeerId, conn: Connection): Promise<void> {\n    this.log('connected %p', peerId)\n\n    // if this connection is already in use for pubsub, ignore it\n    if (conn.streams.find(stream => stream.direction === 'outbound' && stream.protocol === this.protocol)) {\n      this.log('outbound pubsub stream already present on connection from %p', peerId)\n      return\n    }\n\n    const stream = await conn.newStream(this.protocol)\n    const peerStreams = this.addPeer(peerId, stream)\n    peerStreams.attachOutboundStream(stream)\n\n    // Immediately send my own subscriptions to the newly established conn\n    this.send(peerId, {\n      subscriptions: Array.from(this.subscriptions).map(sub => sub.toString()),\n      subscribe: true\n    })\n  }\n\n  /**\n   * Registrar notifies a closing connection with pubsub protocol\n   */\n  protected _onPeerDisconnected (peerId: PeerId, conn?: Connection): void {\n    this.log('connection ended %p', peerId)\n    this._removePeer(peerId)\n  }\n\n  /**\n   * Notifies the router that a peer has been connected\n   */\n  addPeer (peerId: PeerId, stream: Stream): PeerStreams {\n    const existing = this.peers.get(peerId)\n\n    // If peer streams already exists, do nothing\n    if (existing != null) {\n      return existing\n    }\n\n    // else create a new peer streams\n    this.log('new peer %p', peerId)\n\n    const peerStreams = new PeerStreams(peerId)\n\n    this.peers.set(peerId, peerStreams)\n    peerStreams.addEventListener('message', (evt) => {\n      const rpcMsg = evt.detail\n      const messages: PubSubRPCMessage[] = []\n\n      for (const msg of (rpcMsg.messages ?? [])) {\n        if (msg.from == null || msg.data == null || msg.topic == null) {\n          this.log('message from %p was missing from, data or topic fields, dropping', peerId)\n          continue\n        }\n\n        messages.push({\n          from: msg.from,\n          data: msg.data,\n          topic: msg.topic,\n          sequenceNumber: msg.sequenceNumber ?? undefined,\n          signature: msg.signature ?? undefined,\n          key: msg.key ?? undefined\n        })\n      }\n\n      // Since processRpc may be overridden entirely in unsafe ways,\n      // the simplest/safest option here is to wrap in a function and capture all errors\n      // to prevent a top-level unhandled exception\n      // This processing of rpc messages should happen without awaiting full validation/execution of prior messages\n      this.processRpc(peerStreams, {\n        subscriptions: (rpcMsg.subscriptions ?? []).map(sub => ({\n          subscribe: Boolean(sub.subscribe),\n          topic: sub.topic ?? ''\n        })),\n        messages\n      })\n        .catch(err => { this.log(err) })\n    })\n    peerStreams.addEventListener('close', () => this._removePeer(peerId), {\n      once: true\n    })\n\n    return peerStreams\n  }\n\n  /**\n   * Notifies the router that a peer has been disconnected\n   */\n  protected _removePeer (peerId: PeerId): void {\n    const peerStreams = this.peers.get(peerId)\n    if (peerStreams == null) {\n      return\n    }\n\n    // close peer streams\n    peerStreams.close()\n\n    // delete peer streams\n    this.log('delete peer %p', peerId)\n    this.peers.delete(peerId)\n\n    // remove peer from topics map\n    for (const peers of this.topics.values()) {\n      peers.delete(peerId)\n    }\n  }\n\n  /**\n   * Handles an rpc request from a peer\n   */\n  async processRpc (peerStream: PeerStreams, rpc: PubSubRPC): Promise<boolean> {\n    this.log('rpc from %p', peerStream.peerId)\n\n    const { subscriptions, messages } = rpc\n\n    if (subscriptions != null && subscriptions.length > 0) {\n      this.log('subscription update from %p', peerStream.peerId)\n\n      // update peer subscriptions\n      subscriptions.forEach((subOpt) => {\n        this.processRpcSubOpt(peerStream.peerId, subOpt)\n      })\n\n      super.dispatchEvent(new CustomEvent<SubscriptionChangeData>('subscription-change', {\n        detail: {\n          peerId: peerStream.peerId,\n          subscriptions: subscriptions.map(({ topic, subscribe }) => ({\n            topic: `${topic ?? ''}`,\n            subscribe: Boolean(subscribe)\n          }))\n        }\n      }))\n    }\n\n    if (messages != null && messages.length > 0) {\n      this.log('messages from %p', peerStream.peerId)\n\n      this.queue.addAll(messages.map(message => async () => {\n        if (message.topic == null || (!this.subscriptions.has(message.topic) && !this.canRelayMessage)) {\n          this.log('received message we didn\\'t subscribe to. Dropping.')\n          return false\n        }\n\n        try {\n          const msg = await toMessage(message)\n\n          await this.processMessage(peerStream.peerId, msg)\n        } catch (err: any) {\n          this.log.error('failed to queue messages from %p - %e', peerStream.peerId, err)\n        }\n      }))\n        .catch(err => { this.log(err) })\n    }\n\n    return true\n  }\n\n  /**\n   * Handles a subscription change from a peer\n   */\n  processRpcSubOpt (id: PeerId, subOpt: PubSubRPCSubscription): void {\n    const t = subOpt.topic\n\n    if (t == null) {\n      return\n    }\n\n    let topicSet = this.topics.get(t)\n    if (topicSet == null) {\n      topicSet = new PeerSet()\n      this.topics.set(t, topicSet)\n    }\n\n    if (subOpt.subscribe === true) {\n      // subscribe peer to new topic\n      topicSet.add(id)\n    } else {\n      // unsubscribe from existing topic\n      topicSet.delete(id)\n    }\n  }\n\n  /**\n   * Handles a message from a peer\n   */\n  async processMessage (from: PeerId, msg: Message): Promise<void> {\n    if (this.components.peerId.equals(from) && !this.emitSelf) {\n      return\n    }\n\n    // Check if I've seen the message, if yes, ignore\n    const seqno = await this.getMsgId(msg)\n    const msgIdStr = uint8ArrayToString(seqno, 'base64')\n\n    if (this.seenCache.has(msgIdStr)) {\n      return\n    }\n\n    this.seenCache.put(msgIdStr, true)\n\n    // Ensure the message is valid before processing it\n    try {\n      await this.validate(from, msg)\n    } catch (err: any) {\n      this.log('Message is invalid, dropping it. %O', err)\n      return\n    }\n\n    if (this.subscriptions.has(msg.topic)) {\n      const isFromSelf = this.components.peerId.equals(from)\n\n      if (!isFromSelf || this.emitSelf) {\n        super.dispatchEvent(new CustomEvent<Message>('message', {\n          detail: msg\n        }))\n      }\n    }\n\n    await this.publishMessage(from, msg)\n  }\n\n  /**\n   * The default msgID implementation\n   * Child class can override this.\n   */\n  getMsgId (msg: Message): Promise<Uint8Array> | Uint8Array {\n    const signaturePolicy = this.globalSignaturePolicy\n    switch (signaturePolicy) {\n      case 'StrictSign':\n        if (msg.type !== 'signed') {\n          throw new InvalidMessageError('Message type should be \"signed\" when signature policy is StrictSign but it was not')\n        }\n\n        if (msg.sequenceNumber == null) {\n          throw new InvalidMessageError('Need sequence number when signature policy is StrictSign but it was missing')\n        }\n\n        if (msg.key == null) {\n          throw new InvalidMessageError('Need key when signature policy is StrictSign but it was missing')\n        }\n\n        return msgId(msg.key, msg.sequenceNumber)\n      case 'StrictNoSign':\n        return noSignMsgId(msg.data)\n      default:\n        throw new InvalidMessageError('Cannot get message id: unhandled signature policy')\n    }\n  }\n\n  /**\n   * Encode RPC object into a Uint8Array.\n   * This can be override to use a custom router protobuf.\n   */\n  encodeMessage (rpc: PubSubRPCMessage): Uint8Array {\n    return RPC.Message.encode(rpc)\n  }\n\n  /**\n   * Send an rpc object to a peer\n   */\n  send (peer: PeerId, data: { messages?: Message[], subscriptions?: string[], subscribe?: boolean }): void {\n    const { messages, subscriptions, subscribe } = data\n\n    this.sendRpc(peer, {\n      subscriptions: (subscriptions ?? []).map(str => ({ topic: str, subscribe: Boolean(subscribe) })),\n      messages: (messages ?? []).map(toRpcMessage)\n    })\n  }\n\n  /**\n   * Send an rpc object to a peer\n   */\n  sendRpc (peer: PeerId, rpc: PubSubRPC): void {\n    const peerStreams = this.peers.get(peer)\n\n    if (peerStreams == null) {\n      this.log.error('cannot send RPC to %p as there are no streams to it available', peer)\n\n      return\n    }\n\n    peerStreams.write(rpc)\n  }\n\n  /**\n   * Validates the given message. The signature will be checked for authenticity.\n   * Throws an error on invalid messages\n   */\n  async validate (from: PeerId, message: Message): Promise<void> {\n    const signaturePolicy = this.globalSignaturePolicy\n    switch (signaturePolicy) {\n      case 'StrictNoSign':\n        if (message.type !== 'unsigned') {\n          throw new InvalidMessageError('Message type should be \"unsigned\" when signature policy is StrictNoSign but it was not')\n        }\n\n        // @ts-expect-error should not be present\n        if (message.signature != null) {\n          throw new InvalidMessageError('StrictNoSigning: signature should not be present')\n        }\n\n        // @ts-expect-error should not be present\n        if (message.key != null) {\n          throw new InvalidMessageError('StrictNoSigning: key should not be present')\n        }\n\n        // @ts-expect-error should not be present\n        if (message.sequenceNumber != null) {\n          throw new InvalidMessageError('StrictNoSigning: seqno should not be present')\n        }\n        break\n      case 'StrictSign':\n        if (message.type !== 'signed') {\n          throw new InvalidMessageError('Message type should be \"signed\" when signature policy is StrictSign but it was not')\n        }\n\n        if (message.signature == null) {\n          throw new InvalidMessageError('StrictSigning: Signing required and no signature was present')\n        }\n\n        if (message.sequenceNumber == null) {\n          throw new InvalidMessageError('StrictSigning: Signing required and no sequenceNumber was present')\n        }\n\n        if (!(await verifySignature(message, this.encodeMessage.bind(this)))) {\n          throw new InvalidMessageError('StrictSigning: Invalid message signature')\n        }\n\n        break\n      default:\n        throw new InvalidMessageError('Cannot validate message: unhandled signature policy')\n    }\n\n    const validatorFn = this.topicValidators.get(message.topic)\n    if (validatorFn != null) {\n      const result = await validatorFn(from, message)\n      if (result === TopicValidatorResult.Reject || result === TopicValidatorResult.Ignore) {\n        throw new InvalidMessageError('Message validation failed')\n      }\n    }\n  }\n\n  /**\n   * Normalizes the message and signs it, if signing is enabled.\n   * Should be used by the routers to create the message to send.\n   */\n  async buildMessage (message: { from: PeerId, topic: string, data: Uint8Array, sequenceNumber: bigint }): Promise<Message> {\n    const signaturePolicy = this.globalSignaturePolicy\n    switch (signaturePolicy) {\n      case 'StrictSign':\n        return signMessage(this.components.privateKey, message, this.encodeMessage.bind(this))\n      case 'StrictNoSign':\n        return Promise.resolve({\n          type: 'unsigned',\n          ...message\n        })\n      default:\n        throw new InvalidMessageError('Cannot build message: unhandled signature policy')\n    }\n  }\n\n  // API METHODS\n\n  /**\n   * Get a list of the peer-ids that are subscribed to one topic.\n   */\n  getSubscribers (topic: string): PeerId[] {\n    if (!this.started) {\n      throw new NotStartedError('not started yet')\n    }\n\n    if (topic == null) {\n      throw new InvalidParametersError('Topic is required')\n    }\n\n    const peersInTopic = this.topics.get(topic.toString())\n\n    if (peersInTopic == null) {\n      return []\n    }\n\n    return Array.from(peersInTopic.values())\n  }\n\n  /**\n   * Publishes messages to all subscribed peers\n   */\n  async publish (topic: string, data?: Uint8Array): Promise<PublishResult> {\n    if (!this.started) {\n      throw new Error('Pubsub has not started')\n    }\n\n    const message = {\n      from: this.components.peerId,\n      topic,\n      data: data ?? new Uint8Array(0),\n      sequenceNumber: randomSeqno()\n    }\n\n    this.log('publish topic: %s from: %p data: %m', topic, message.from, message.data)\n\n    const rpcMessage = await this.buildMessage(message)\n    let emittedToSelf = false\n\n    // dispatch the event if we are interested\n    if (this.emitSelf) {\n      if (this.subscriptions.has(topic)) {\n        emittedToSelf = true\n        super.dispatchEvent(new CustomEvent<Message>('message', {\n          detail: rpcMessage\n        }))\n      }\n    }\n\n    // send to all the other peers\n    const result = await this.publishMessage(this.components.peerId, rpcMessage)\n\n    if (emittedToSelf) {\n      result.recipients = [...result.recipients, this.components.peerId]\n    }\n\n    return result\n  }\n\n  /**\n   * Overriding the implementation of publish should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply publish each message to each topic for every peer.\n   *\n   * `sender` might be this peer, or we might be forwarding a message on behalf of another peer, in which case sender\n   * is the peer we received the message from, which may not be the peer the message was created by.\n   */\n  async publishMessage (from: PeerId, message: Message): Promise<PublishResult> {\n    const peers = this.getSubscribers(message.topic)\n    const recipients: PeerId[] = []\n\n    if (peers == null || peers.length === 0) {\n      this.log('no peers are subscribed to topic %s', message.topic)\n      return { recipients }\n    }\n\n    peers.forEach(id => {\n      if (this.components.peerId.equals(id)) {\n        this.log('not sending message on topic %s to myself', message.topic)\n        return\n      }\n\n      if (id.equals(from)) {\n        this.log('not sending message on topic %s to sender %p', message.topic, id)\n        return\n      }\n\n      this.log('publish msgs on topics %s %p', message.topic, id)\n\n      recipients.push(id)\n      this.send(id, { messages: [message] })\n    })\n\n    return { recipients }\n  }\n\n  /**\n   * Subscribes to a given topic.\n   */\n  subscribe (topic: string): void {\n    if (!this.started) {\n      throw new Error('Pubsub has not started')\n    }\n\n    if (this.subscriptions.has(topic)) {\n      // already subscribed\n      return\n    }\n\n    this.log('subscribe to topic: %s', topic)\n\n    this.subscriptions.add(topic)\n\n    for (const peerId of this.peers.keys()) {\n      this.send(peerId, {\n        subscriptions: [\n          topic\n        ],\n        subscribe: true\n      })\n    }\n  }\n\n  /**\n   * Unsubscribe from the given topic\n   */\n  unsubscribe (topic: string): void {\n    if (!this.started) {\n      throw new Error('Pubsub is not started')\n    }\n\n    if (!this.subscriptions.has(topic)) {\n      // not subscribed\n      return\n    }\n\n    this.log('unsubscribe from %s', topic)\n\n    this.subscriptions.delete(topic)\n\n    for (const peerId of this.peers.keys()) {\n      this.send(peerId, {\n        subscriptions: [\n          topic\n        ],\n        subscribe: false\n      })\n    }\n  }\n\n  /**\n   * Get the list of topics which the peer is subscribed to.\n   */\n  getTopics (): string[] {\n    if (!this.started) {\n      throw new Error('Pubsub is not started')\n    }\n\n    return Array.from(this.subscriptions)\n  }\n\n  getPeers (): PeerId[] {\n    if (!this.started) {\n      throw new Error('Pubsub is not started')\n    }\n\n    return Array.from(this.peers.keys())\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * > Don't use this module\n *\n * This module is a naive implementation of pubsub. It broadcasts all messages to all network peers, cannot provide older messages and has no protection against bad actors.\n *\n * It exists for academic purposes only, you should not use it in production.\n *\n * Instead please use [gossipsub](https://www.npmjs.com/package/@chainsafe/libp2p-gossipsub) - a more complete implementation which is also compatible with floodsub.\n *\n * @example Configuring libp2p to use floodsub\n *\n * ```TypeScript\n * import { createLibp2p } from 'libp2p'\n * import { floodsub } from '@libp2p/floodsub'\n *\n * const node = await createLibp2p({\n *   services: {\n *     pubsub: floodsub()\n *   }\n *   //... other options\n * })\n * await node.start()\n *\n * node.services.pubsub.subscribe('fruit')\n * node.services.pubsub.addEventListener('message', (evt) => {\n *   console.log(evt)\n * })\n *\n * node.services.pubsub.publish('fruit', new TextEncoder().encode('banana'))\n * ```\n */\n\nimport { pubSubSymbol } from './constants.ts'\nimport { FloodSub as FloodSubClass } from './floodsub.js'\nimport type { PubSubRPC } from './floodsub.js'\nimport type { ComponentLogger, PeerId, PrivateKey, PublicKey, TypedEventTarget } from '@libp2p/interface'\nimport type { Registrar } from '@libp2p/interface-internal'\n\nexport const protocol = '/floodsub/1.0.0'\n\n/**\n * On the producing side:\n * - Build messages with the signature, key (from may be enough for certain inlineable public key types), from and seqno fields.\n *\n * On the consuming side:\n * - Enforce the fields to be present, reject otherwise.\n * - Propagate only if the fields are valid and signature can be verified, reject otherwise.\n */\nexport const StrictSign = 'StrictSign'\n\n/**\n * On the producing side:\n * - Build messages without the signature, key, from and seqno fields.\n * - The corresponding protobuf key-value pairs are absent from the marshaled message, not just empty.\n *\n * On the consuming side:\n * - Enforce the fields to be absent, reject otherwise.\n * - Propagate only if the fields are absent, reject otherwise.\n * - A message_id function will not be able to use the above fields, and should instead rely on the data field. A commonplace strategy is to calculate a hash.\n */\nexport const StrictNoSign = 'StrictNoSign'\n\nexport type SignaturePolicy = typeof StrictSign | typeof StrictNoSign\n\nexport interface SignedMessage {\n  type: 'signed'\n  from: PeerId\n  topic: string\n  data: Uint8Array\n  sequenceNumber: bigint\n  signature: Uint8Array\n  key: PublicKey\n}\n\nexport interface UnsignedMessage {\n  type: 'unsigned'\n  topic: string\n  data: Uint8Array\n}\n\nexport type Message = SignedMessage | UnsignedMessage\n\nexport interface Subscription {\n  topic: string\n  subscribe: boolean\n}\n\nexport interface SubscriptionChangeData {\n  peerId: PeerId\n  subscriptions: Subscription[]\n}\n\nexport interface FloodSubEvents {\n  'subscription-change': CustomEvent<SubscriptionChangeData>\n  message: CustomEvent<Message>\n}\n\nexport interface PublishResult {\n  recipients: PeerId[]\n}\n\nexport enum TopicValidatorResult {\n  /**\n   * The message is considered valid, and it should be delivered and forwarded to the network\n   */\n  Accept = 'accept',\n  /**\n   * The message is neither delivered nor forwarded to the network\n   */\n  Ignore = 'ignore',\n  /**\n   * The message is considered invalid, and it should be rejected\n   */\n  Reject = 'reject'\n}\n\nexport interface TopicValidatorFn {\n  (peer: PeerId, message: Message): TopicValidatorResult | Promise<TopicValidatorResult>\n}\n\nexport interface PeerStreamsEvents {\n  message: CustomEvent<PubSubRPC>\n  close: CustomEvent<never>\n}\n\nexport { pubSubSymbol }\n\n/**\n * Returns true if the passed argument is a PubSub implementation\n */\nexport function isPubSub (obj?: any): obj is FloodSub {\n  return Boolean(obj?.[pubSubSymbol])\n}\n\nexport interface FloodSub extends TypedEventTarget<FloodSubEvents> {\n  /**\n   * The global signature policy controls whether or not we sill send and receive\n   * signed or unsigned messages.\n   *\n   * Signed messages prevent spoofing message senders and should be preferred to\n   * using unsigned messages.\n   */\n  globalSignaturePolicy: typeof StrictSign | typeof StrictNoSign\n\n  /**\n   * The protocol name used by FloodSub\n   */\n  protocol: string\n\n  /**\n   * Pubsub routers support message validators per topic, which will validate the message\n   * before its propagations. They are stored in a map where keys are the topic name and\n   * values are the validators.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const validateMessage = (msgTopic, msg) => {\n   *   const input = uint8ArrayToString(msg.data)\n   *   const validInputs = ['a', 'b', 'c']\n   *\n   *   if (!validInputs.includes(input)) {\n   *     throw new Error('no valid input received')\n   *   }\n   * }\n   * libp2p.pubsub.topicValidators.set(topic, validateMessage)\n   * ```\n   */\n  topicValidators: Map<string, TopicValidatorFn>\n\n  getPeers(): PeerId[]\n\n  /**\n   * Gets a list of topics the node is subscribed to.\n   *\n   * ```TypeScript\n   * const topics = libp2p.pubsub.getTopics()\n   * ```\n   */\n  getTopics(): string[]\n\n  /**\n   * Subscribes to a pubsub topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const handler = (msg) => {\n   *   if (msg.topic === topic) {\n   *     // msg.data - pubsub data received\n   *   }\n   * }\n   *\n   * libp2p.pubsub.addEventListener('message', handler)\n   * libp2p.pubsub.subscribe(topic)\n   * ```\n   */\n  subscribe(topic: string): void\n\n  /**\n   * Unsubscribes from a pubsub topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const handler = (msg) => {\n   *   // msg.data - pubsub data received\n   * }\n   *\n   * libp2p.pubsub.removeEventListener(topic handler)\n   * libp2p.pubsub.unsubscribe(topic)\n   * ```\n   */\n  unsubscribe(topic: string): void\n\n  /**\n   * Gets a list of the PeerIds that are subscribed to one topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peerIds = libp2p.pubsub.getSubscribers(topic)\n   * ```\n   */\n  getSubscribers(topic: string): PeerId[]\n\n  /**\n   * Publishes messages to the given topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const data = uint8ArrayFromString('data')\n   *\n   * await libp2p.pubsub.publish(topic, data)\n   * ```\n   */\n  publish(topic: string, data?: Uint8Array): Promise<PublishResult>\n}\n\nexport interface FloodSubComponents {\n  peerId: PeerId\n  privateKey: PrivateKey\n  registrar: Registrar\n  logger: ComponentLogger\n}\n\nexport interface FloodSubInit {\n  seenTTL?: number\n\n  /**\n   * Override the protocol registered with the registrar\n   *\n   * @default '/floodsub/1.0.0'\n   */\n  protocol?: string\n\n  /**\n   * defines how signatures should be handled\n   */\n  globalSignaturePolicy?: SignaturePolicy\n\n  /**\n   * if can relay messages not subscribed\n   */\n  canRelayMessage?: boolean\n\n  /**\n   * if publish should emit to self, if subscribed\n   */\n  emitSelf?: boolean\n\n  /**\n   * handle this many incoming pubsub messages concurrently\n   */\n  messageProcessingConcurrency?: number\n\n  /**\n   * How many parallel incoming streams to allow on the pubsub protocol per-connection\n   */\n  maxInboundStreams?: number\n\n  /**\n   * How many parallel outgoing streams to allow on the pubsub protocol per-connection\n   */\n  maxOutboundStreams?: number\n}\n\nexport function floodsub (init: FloodSubInit = {}): (components: FloodSubComponents) => FloodSub {\n  return (components: FloodSubComponents) => new FloodSubClass(components, init)\n}\n"],
  "mappings": "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",
  "names": ["RPC", "SubOpts", "_codec", "Message", "_a", "_b", "_c", "_d", "_e", "ControlMessage", "ControlIHave", "ControlIWant", "ControlGraft", "ControlPrune", "PeerInfo", "message", "_a", "_b", "msgId", "message", "message", "stream", "message", "TopicValidatorResult"]
}
