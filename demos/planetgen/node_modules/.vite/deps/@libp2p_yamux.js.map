{
  "version": 3,
  "sources": ["../../../../../node_modules/@libp2p/yamux/src/frame.ts", "../../../../../node_modules/@libp2p/yamux/src/errors.ts", "../../../../../node_modules/@libp2p/yamux/src/constants.ts", "../../../../../node_modules/@libp2p/yamux/src/config.ts", "../../../../../node_modules/@libp2p/yamux/src/decode.ts", "../../../../../node_modules/@libp2p/yamux/src/encode.ts", "../../../../../node_modules/@libp2p/yamux/src/stream.ts", "../../../../../node_modules/@libp2p/yamux/src/muxer.ts", "../../../../../node_modules/@libp2p/yamux/src/index.ts"],
  "sourcesContent": ["export enum FrameType {\n  /** Used to transmit data. May transmit zero length payloads depending on the flags. */\n  Data = 0x0,\n  /** Used to updated the senders receive window size. This is used to implement per-session flow control. */\n  WindowUpdate = 0x1,\n  /** Used to measure RTT. It can also be used to heart-beat and do keep-alive over TCP. */\n  Ping = 0x2,\n  /** Used to close a session. */\n  GoAway = 0x3\n}\n\nexport enum Flag {\n  /** Signals the start of a new stream. May be sent with a data or window update message. Also sent with a ping to indicate outbound. */\n  SYN = 0x1,\n  /** Acknowledges the start of a new stream. May be sent with a data or window update message. Also sent with a ping to indicate response. */\n  ACK = 0x2,\n  /** Performs a half-close of a stream. May be sent with a data message or window update. */\n  FIN = 0x4,\n  /** Reset a stream immediately. May be sent with a data or window update message. */\n  RST = 0x8\n}\n\nconst flagCodes = Object.values(Flag).filter((x) => typeof x !== 'string') as Flag[]\n\nexport const YAMUX_VERSION = 0\n\nexport enum GoAwayCode {\n  NormalTermination = 0x0,\n  ProtocolError = 0x1,\n  InternalError = 0x2\n}\n\nexport const HEADER_LENGTH = 12\n\nexport interface FrameHeader {\n  /**\n   * The version field is used for future backward compatibility.\n   * At the current time, the field is always set to 0, to indicate the initial version.\n   */\n  version?: number\n  /** The type field is used to switch the frame message type. */\n  type: FrameType\n  /** The flags field is used to provide additional information related to the message type. */\n  flag: number\n  /**\n   * The StreamID field is used to identify the logical stream the frame is addressing.\n   * The client side should use odd ID's, and the server even.\n   * This prevents any collisions. Additionally, the 0 ID is reserved to represent the session.\n   */\n  streamID: number\n  /**\n   * The meaning of the length field depends on the message type:\n   * Data - provides the length of bytes following the header\n   * Window update - provides a delta update to the window size\n   * Ping - Contains an opaque value, echoed back\n   * Go Away - Contains an error code\n   */\n  length: number\n}\n\nexport function stringifyHeader (header: FrameHeader): string {\n  const flags = flagCodes.filter(f => (header.flag & f) === f).map(f => Flag[f]).join('|')\n  return `streamID=${header.streamID} type=${FrameType[header.type]} flag=${flags} length=${header.length}`\n}\n", "import { GoAwayCode } from './frame.ts'\n\nexport class ProtocolError extends Error {\n  static name = 'ProtocolError'\n\n  public reason: GoAwayCode\n\n  constructor (message: string, reason: GoAwayCode) {\n    super(message)\n    this.name = 'ProtocolError'\n    this.reason = reason\n  }\n}\n\nexport function isProtocolError (err?: any): err is ProtocolError {\n  return err?.reason !== null\n}\n\nexport class InvalidFrameError extends ProtocolError {\n  static name = 'InvalidFrameError'\n\n  constructor (message = 'The frame was invalid') {\n    super(message, GoAwayCode.ProtocolError)\n    this.name = 'InvalidFrameError'\n  }\n}\n\nexport class UnRequestedPingError extends ProtocolError {\n  static name = 'UnRequestedPingError'\n\n  constructor (message = 'Un-requested ping error') {\n    super(message, GoAwayCode.ProtocolError)\n    this.name = 'UnRequestedPingError'\n  }\n}\n\nexport class NotMatchingPingError extends ProtocolError {\n  static name = 'NotMatchingPingError'\n\n  constructor (message = 'Not matching ping error') {\n    super(message, GoAwayCode.ProtocolError)\n    this.name = 'NotMatchingPingError'\n  }\n}\n\nexport class InvalidStateError extends Error {\n  static name = 'InvalidStateError'\n\n  constructor (message = 'Invalid state') {\n    super(message)\n    this.name = 'InvalidStateError'\n  }\n}\n\nexport class StreamAlreadyExistsError extends ProtocolError {\n  static name = 'StreamAlreadyExistsError'\n\n  constructor (message = 'Stream already exists') {\n    super(message, GoAwayCode.ProtocolError)\n    this.name = 'StreamAlreadyExistsError'\n  }\n}\n\nexport class DecodeInvalidVersionError extends ProtocolError {\n  static name = 'DecodeInvalidVersionError'\n\n  constructor (message = 'Decode invalid version') {\n    super(message, GoAwayCode.ProtocolError)\n    this.name = 'DecodeInvalidVersionError'\n  }\n}\n\nexport class BothClientsError extends ProtocolError {\n  static name = 'BothClientsError'\n\n  constructor (message = 'Both clients') {\n    super(message, GoAwayCode.ProtocolError)\n    this.name = 'BothClientsError'\n  }\n}\n\nexport class ReceiveWindowExceededError extends ProtocolError {\n  static name = 'ReceiveWindowExceededError'\n\n  constructor (message = 'Receive window exceeded') {\n    super(message, GoAwayCode.ProtocolError)\n    this.name = 'ReceiveWindowExceededError'\n  }\n}\n", "// Protocol violation errors\n\nimport { BothClientsError, DecodeInvalidVersionError, InvalidFrameError, NotMatchingPingError, ReceiveWindowExceededError, StreamAlreadyExistsError, UnRequestedPingError } from './errors.js'\n\nexport const PROTOCOL_ERRORS = new Set([\n  InvalidFrameError.name,\n  UnRequestedPingError.name,\n  NotMatchingPingError.name,\n  StreamAlreadyExistsError.name,\n  DecodeInvalidVersionError.name,\n  BothClientsError.name,\n  ReceiveWindowExceededError.name\n])\n\n/**\n * INITIAL_STREAM_WINDOW is the initial stream window size.\n *\n * Not an implementation choice, this is defined in the specification\n */\nexport const INITIAL_STREAM_WINDOW = 256 * 1024\n\n/**\n * Default max stream window\n */\nexport const MAX_STREAM_WINDOW = 16 * 1024 * 1024\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { INITIAL_STREAM_WINDOW, MAX_STREAM_WINDOW } from './constants.js'\nimport type { StreamMuxerOptions, StreamOptions } from '@libp2p/interface'\n\nexport interface YamuxStreamOptions extends StreamOptions {\n  /**\n   * Used to control the initial window size that we allow for a stream.\n   *\n   * measured in bytes\n   */\n  initialStreamWindowSize?: number\n\n  /**\n   * Used to control the maximum window size that we allow for a stream.\n   */\n  maxStreamWindowSize?: number\n}\n\n// TODO use config items or delete them\nexport interface Config extends StreamMuxerOptions<YamuxStreamOptions> {\n  /**\n   * Used to do periodic keep alive messages using a ping\n   */\n  enableKeepAlive?: boolean\n\n  /**\n   * How often to perform the keep alive\n   *\n   * measured in milliseconds\n   */\n  keepAliveInterval?: number\n}\n\nexport const defaultConfig: Required<Config> & { streamOptions: Required<YamuxStreamOptions> } = {\n  enableKeepAlive: true,\n  keepAliveInterval: 30_000,\n  maxInboundStreams: 1_000,\n  maxOutboundStreams: 1_000,\n  maxMessageSize: 64 * 1024,\n  maxEarlyStreams: 10,\n  streamOptions: {\n    initialStreamWindowSize: INITIAL_STREAM_WINDOW,\n    maxStreamWindowSize: MAX_STREAM_WINDOW,\n    inactivityTimeout: 120_000,\n    maxReadBufferLength: 4_194_304,\n    maxWriteBufferLength: Infinity\n  }\n}\n\nexport function verifyConfig (config: Config): void {\n  if (config.keepAliveInterval != null && config.keepAliveInterval <= 0) {\n    throw new InvalidParametersError('keep-alive interval must be positive')\n  }\n  if (config.maxInboundStreams != null && config.maxInboundStreams < 0) {\n    throw new InvalidParametersError('max inbound streams must be larger or equal 0')\n  }\n  if (config.maxOutboundStreams != null && config.maxOutboundStreams < 0) {\n    throw new InvalidParametersError('max outbound streams must be larger or equal 0')\n  }\n  if (config.maxMessageSize != null && config.maxMessageSize < 1024) {\n    throw new InvalidParametersError('MaxMessageSize must be greater than a kilobyte')\n  }\n  if (config.streamOptions?.initialStreamWindowSize != null && config.streamOptions?.initialStreamWindowSize < INITIAL_STREAM_WINDOW) {\n    throw new InvalidParametersError('InitialStreamWindowSize must be larger or equal 256 kB')\n  }\n  if (config.streamOptions?.maxStreamWindowSize != null && config.streamOptions?.initialStreamWindowSize != null && config.streamOptions?.maxStreamWindowSize < config.streamOptions?.initialStreamWindowSize) {\n    throw new InvalidParametersError('MaxStreamWindowSize must be larger than the InitialStreamWindowSize')\n  }\n  if (config.streamOptions?.maxStreamWindowSize != null && config.streamOptions?.maxStreamWindowSize > 2 ** 32 - 1) {\n    throw new InvalidParametersError('MaxStreamWindowSize must be less than equal MAX_UINT32')\n  }\n}\n", "import { Uint8ArrayList } from 'uint8arraylist'\nimport { InvalidFrameError } from './errors.js'\nimport { FrameType, HEADER_LENGTH, YAMUX_VERSION } from './frame.js'\nimport type { FrameHeader } from './frame.js'\n\nexport interface Frame {\n  header: FrameHeader\n  data?: Uint8ArrayList\n}\n\nexport interface DataFrame {\n  header: FrameHeader\n  data: Uint8ArrayList\n}\n\nexport function isDataFrame (frame: Frame): frame is DataFrame {\n  return frame.header.type === FrameType.Data && frame.data !== null\n}\n\n// used to bit shift in decoding\n// native bit shift can overflow into a negative number, so we bit shift by\n// multiplying by a power of 2\nconst twoPow24 = 2 ** 24\n\n/**\n * Decode a header from the front of a buffer\n *\n * @param data - Assumed to have enough bytes for a header\n */\nexport function decodeHeader (data: Uint8Array): FrameHeader {\n  if (data[0] !== YAMUX_VERSION) {\n    throw new InvalidFrameError('Invalid frame version')\n  }\n\n  return {\n    type: data[1],\n    flag: (data[2] << 8) + data[3],\n    streamID: (data[4] * twoPow24) + (data[5] << 16) + (data[6] << 8) + data[7],\n    length: (data[8] * twoPow24) + (data[9] << 16) + (data[10] << 8) + data[11]\n  }\n}\n\n/**\n * Decodes yamux frames from a source\n */\nexport class Decoder {\n  /** Buffer for in-progress frames */\n  private readonly buffer: Uint8ArrayList\n\n  constructor () {\n    this.buffer = new Uint8ArrayList()\n  }\n\n  /**\n   * Emits frames from the decoder source.\n   *\n   * Note: If `readData` is emitted, it _must_ be called before the next iteration\n   * Otherwise an error is thrown\n   */\n  * emitFrames (buf: Uint8Array | Uint8ArrayList): Generator<Frame> {\n    this.buffer.append(buf)\n\n    // Loop to consume as many bytes from the buffer as possible\n    // Eg: when a single chunk contains several frames\n    while (true) {\n      const frame = this.readFrame()\n\n      if (frame === undefined) {\n        break\n      }\n\n      yield frame\n    }\n  }\n\n  private readFrame (): Frame | undefined {\n    let frameSize = HEADER_LENGTH\n\n    if (this.buffer.byteLength < HEADER_LENGTH) {\n      // not enough data yet\n      return\n    }\n\n    // TODO: use sublist?\n    const header = decodeHeader(this.buffer.subarray(0, HEADER_LENGTH))\n\n    if (header.type === FrameType.Data) {\n      frameSize += header.length\n\n      if (this.buffer.byteLength < frameSize) {\n        // not enough data yet\n        return\n      }\n\n      const data = this.buffer.sublist(HEADER_LENGTH, frameSize)\n      this.buffer.consume(frameSize)\n\n      return { header, data }\n    }\n\n    this.buffer.consume(frameSize)\n\n    return { header }\n  }\n}\n", "import { HEADER_LENGTH } from './frame.js'\nimport type { FrameHeader } from './frame.js'\n\nexport function encodeHeader (header: FrameHeader): Uint8Array {\n  const frame = new Uint8Array(HEADER_LENGTH)\n\n  // always assume version 0\n  // frameView.setUint8(0, header.version)\n\n  frame[1] = header.type\n\n  frame[2] = header.flag >>> 8\n  frame[3] = header.flag\n\n  frame[4] = header.streamID >>> 24\n  frame[5] = header.streamID >>> 16\n  frame[6] = header.streamID >>> 8\n  frame[7] = header.streamID\n\n  frame[8] = header.length >>> 24\n  frame[9] = header.length >>> 16\n  frame[10] = header.length >>> 8\n  frame[11] = header.length\n\n  return frame\n}\n", "import { AbstractStream } from '@libp2p/utils'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { INITIAL_STREAM_WINDOW, MAX_STREAM_WINDOW } from './constants.js'\nimport { isDataFrame } from './decode.ts'\nimport { InvalidFrameError, ReceiveWindowExceededError } from './errors.js'\nimport { Flag, FrameType, HEADER_LENGTH } from './frame.js'\nimport type { Frame } from './decode.ts'\nimport type { FrameHeader } from './frame.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { AbstractStreamInit, SendResult } from '@libp2p/utils'\n\nexport enum StreamState {\n  Init,\n  SYNSent,\n  SYNReceived,\n  Established,\n  Finished,\n  Paused\n}\n\nexport interface YamuxStreamInit extends AbstractStreamInit {\n  streamId: number\n  sendFrame(header: FrameHeader, body?: Uint8ArrayList): boolean\n  getRTT(): number\n  initialStreamWindowSize?: number\n  maxMessageSize?: number\n  maxStreamWindowSize?: number\n  state: StreamState\n}\n\n/** YamuxStream is used to represent a logical stream within a session */\nexport class YamuxStream extends AbstractStream {\n  streamId: number\n  state: StreamState\n\n  /** The number of available bytes to send */\n  private sendWindowCapacity: number\n  /** The number of bytes available to receive in a full window */\n  private recvWindow: number\n  /** The number of available bytes to receive */\n  private recvWindowCapacity: number\n  private maxStreamWindowSize: number\n\n  /**\n   * An 'epoch' is the time it takes to process and read data\n   *\n   * Used in conjunction with RTT to determine whether to increase the recvWindow\n   */\n  private epochStart: number\n  private readonly getRTT: () => number\n\n  private readonly sendFrame: (header: FrameHeader, body?: Uint8ArrayList) => boolean\n\n  constructor (init: YamuxStreamInit) {\n    const initialWindowSize = init.initialStreamWindowSize ?? INITIAL_STREAM_WINDOW\n\n    super({\n      ...init,\n      maxMessageSize: initialWindowSize - HEADER_LENGTH\n    })\n\n    this.streamId = init.streamId\n    this.state = init.state\n    this.sendWindowCapacity = initialWindowSize\n    this.recvWindow = initialWindowSize\n    this.recvWindowCapacity = this.recvWindow\n    this.maxStreamWindowSize = init.maxStreamWindowSize ?? MAX_STREAM_WINDOW\n    this.epochStart = Date.now()\n    this.getRTT = init.getRTT\n    this.sendFrame = init.sendFrame\n\n    const setStateToFinishedOnCloseListener = (): void => {\n      this.state = StreamState.Finished\n    }\n    this.addEventListener('close', setStateToFinishedOnCloseListener)\n  }\n\n  /**\n   * Send a data message to the remote muxer\n   */\n  sendData (buf: Uint8ArrayList): SendResult {\n    const totalBytes = buf.byteLength\n    let sentBytes = 0\n    let canSendMore = true\n\n    this.log?.trace('send window capacity is %d bytes', this.sendWindowCapacity)\n\n    // send in chunks, waiting for window updates\n    while (buf.byteLength > 0) {\n      // we exhausted the send window, sending will resume later\n      if (this.sendWindowCapacity === 0) {\n        canSendMore = false\n        this.log?.trace('sent %d/%d bytes, exhausted send window, waiting for window update', sentBytes, totalBytes)\n        break\n      }\n\n      // send as much as we can\n      const toSend = Math.min(this.sendWindowCapacity, buf.byteLength)\n      const flags = this.getSendFlags()\n\n      const data = buf.sublist(0, toSend)\n      buf.consume(toSend)\n\n      const muxerSendMore = this.sendFrame({\n        type: FrameType.Data,\n        flag: flags,\n        streamID: this.streamId,\n        length: toSend\n      }, data)\n\n      this.sendWindowCapacity -= toSend\n      sentBytes += toSend\n\n      if (!muxerSendMore) {\n        canSendMore = muxerSendMore\n        this.log.trace('sent %d/%d bytes, wait for muxer to have more send capacity', sentBytes, totalBytes)\n        break\n      }\n    }\n\n    return {\n      sentBytes,\n      canSendMore\n    }\n  }\n\n  /**\n   * Send a reset message to the remote muxer\n   */\n  async sendReset (): Promise<void> {\n    this.sendFrame({\n      type: FrameType.WindowUpdate,\n      flag: Flag.RST,\n      streamID: this.streamId,\n      length: 0\n    })\n  }\n\n  /**\n   * Send a message to the remote muxer, informing them no more data messages\n   * will be sent by this end of the stream\n   */\n  async sendCloseWrite (): Promise<void> {\n    const flags = this.getSendFlags() | Flag.FIN\n    this.sendFrame({\n      type: FrameType.WindowUpdate,\n      flag: flags,\n      streamID: this.streamId,\n      length: 0\n    })\n  }\n\n  /**\n   * Send a message to the remote muxer, informing them no more data messages\n   * will be read by this end of the stream - this is a no-op on Yamux streams\n   */\n  async sendCloseRead (options?: AbortOptions): Promise<void> {\n    options?.signal?.throwIfAborted()\n  }\n\n  /**\n   * Stop sending window updates temporarily - in the interim the the remote\n   * send window will exhaust and the remote will stop sending data\n   */\n  sendPause (): void {\n    this.state = StreamState.Paused\n  }\n\n  /**\n   * Start sending window updates as normal\n   */\n  sendResume (): void {\n    this.state = StreamState.Established\n    this.sendWindowUpdate()\n  }\n\n  /**\n   * handleWindowUpdate is called when the stream receives a window update frame\n   */\n  handleWindowUpdate (frame: Frame): void {\n    this.processFlags(frame.header.flag)\n\n    // increase send window\n    this.sendWindowCapacity += frame.header.length\n\n    // change the chunk size the superclass uses\n    this.maxMessageSize = this.sendWindowCapacity - HEADER_LENGTH\n\n    if (this.maxMessageSize < 0) {\n      this.maxMessageSize = 0\n    }\n\n    if (this.maxMessageSize === 0) {\n      return\n    }\n\n    // if writing is paused and the update increases our send window, notify\n    // writers that writing can resume\n    if (this.writeBuffer.byteLength > 0) {\n      this.log?.trace('window update of %d bytes allows more data to be sent, have %d bytes queued, sending data %s', frame.header.length, this.writeBuffer.byteLength, this.sendingData)\n      this.safeDispatchEvent('drain')\n    }\n  }\n\n  /**\n   * handleData is called when the stream receives a data frame\n   */\n  handleData (frame: Frame): void {\n    if (!isDataFrame(frame)) {\n      throw new InvalidFrameError('Frame was not data frame')\n    }\n\n    this.processFlags(frame.header.flag)\n\n    // check that our recv window is not exceeded\n    if (this.recvWindowCapacity < frame.header.length) {\n      throw new ReceiveWindowExceededError('Receive window exceeded')\n    }\n\n    this.recvWindowCapacity -= frame.header.length\n\n    this.onData(frame.data)\n\n    this.sendWindowUpdate()\n  }\n\n  /**\n   * processFlags is used to update the state of the stream based on set flags, if any.\n   */\n  private processFlags (flags: number): void {\n    if ((flags & Flag.ACK) === Flag.ACK) {\n      if (this.state === StreamState.SYNSent) {\n        this.state = StreamState.Established\n      }\n    }\n\n    if ((flags & Flag.FIN) === Flag.FIN) {\n      this.onRemoteCloseWrite()\n    }\n\n    if ((flags & Flag.RST) === Flag.RST) {\n      this.onRemoteReset()\n    }\n  }\n\n  /**\n   * getSendFlags determines any flags that are appropriate\n   * based on the current stream state.\n   *\n   * The state is updated as a side-effect.\n   */\n  private getSendFlags (): number {\n    switch (this.state) {\n      case StreamState.Init:\n        this.state = StreamState.SYNSent\n        return Flag.SYN\n      case StreamState.SYNReceived:\n        this.state = StreamState.Established\n        return Flag.ACK\n      default:\n        return 0\n    }\n  }\n\n  /**\n   * Potentially sends a window update enabling further remote writes to take\n   * place.\n   */\n  sendWindowUpdate (): void {\n    if (this.state === StreamState.Paused) {\n      // we don't want any more data from the remote right now - update the\n      // epoch start as otherwise when we unpause we'd be looking at the epoch\n      // start from before we were paused\n      this.epochStart = Date.now()\n\n      return\n    }\n\n    // determine the flags if any\n    const flags = this.getSendFlags()\n\n    // If the stream has already been established\n    // and we've processed data within the time it takes for 4 round trips\n    // then we (up to) double the recvWindow\n    const now = Date.now()\n    const rtt = this.getRTT()\n\n    if (flags === 0 && rtt > -1 && (now - this.epochStart) <= (rtt * 4)) {\n      // we've already validated that maxStreamWindowSize can't be more than MAX_UINT32\n      this.recvWindow = Math.min(this.recvWindow * 2, this.maxStreamWindowSize)\n    }\n\n    if (this.recvWindowCapacity >= this.recvWindow && flags === 0) {\n      // a window update isn't needed\n      return\n    }\n\n    // update the receive window\n    const delta = this.recvWindow - this.recvWindowCapacity\n    this.recvWindowCapacity = this.recvWindow\n\n    // update the epoch start\n    this.epochStart = now\n\n    // send window update\n    this.sendFrame({\n      type: FrameType.WindowUpdate,\n      flag: flags,\n      streamID: this.streamId,\n      length: delta\n    })\n  }\n}\n", "import { InvalidParametersError, MuxerClosedError, TooManyOutboundProtocolStreamsError, serviceCapabilities } from '@libp2p/interface'\nimport { AbstractStreamMuxer, repeatingTask } from '@libp2p/utils'\nimport { raceSignal } from 'race-signal'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { defaultConfig, verifyConfig } from './config.js'\nimport { Decoder } from './decode.js'\nimport { encodeHeader } from './encode.js'\nimport { InvalidFrameError, isProtocolError, NotMatchingPingError, UnRequestedPingError } from './errors.js'\nimport { Flag, FrameType, GoAwayCode } from './frame.js'\nimport { StreamState, YamuxStream } from './stream.js'\nimport type { Config } from './config.js'\nimport type { Frame } from './decode.js'\nimport type { FrameHeader } from './frame.js'\nimport type { AbortOptions, MessageStream, StreamMuxerFactory } from '@libp2p/interface'\nimport type { RepeatingTask } from '@libp2p/utils'\n\nfunction debugFrame (header: FrameHeader): any {\n  return {\n    type: FrameType[header.type],\n    flags: [\n      (header.flag & Flag.SYN) === Flag.SYN ? 'SYN' : undefined,\n      (header.flag & Flag.ACK) === Flag.ACK ? 'ACK' : undefined,\n      (header.flag & Flag.FIN) === Flag.FIN ? 'FIN' : undefined,\n      (header.flag & Flag.RST) === Flag.RST ? 'RST' : undefined\n    ].filter(Boolean),\n    streamID: header.streamID,\n    length: header.length\n  }\n}\n\nconst YAMUX_PROTOCOL_ID = '/yamux/1.0.0'\n\nexport interface YamuxMuxerInit extends Partial<Config> {\n}\n\nexport class Yamux implements StreamMuxerFactory {\n  protocol = YAMUX_PROTOCOL_ID\n  private readonly _init: Partial<Config>\n\n  constructor (init: Partial<Config> = {}) {\n    this._init = init\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/yamux'\n\n  readonly [serviceCapabilities]: string[] = [\n    '@libp2p/stream-multiplexing'\n  ]\n\n  createStreamMuxer (maConn: MessageStream): YamuxMuxer {\n    return new YamuxMuxer(maConn, {\n      ...this._init\n    })\n  }\n}\n\nexport interface CloseOptions extends AbortOptions {\n  reason?: GoAwayCode\n}\n\nexport interface ActivePing extends PromiseWithResolvers<number> {\n  id: number\n  start: number\n}\n\nexport class YamuxMuxer extends AbstractStreamMuxer<YamuxStream> {\n  /** The next stream id to be used when initiating a new stream */\n  private nextStreamID: number\n\n  /** The next ping id to be used when pinging */\n  private nextPingID: number\n  /** Tracking info for the currently active ping */\n  private activePing?: ActivePing\n  /** Round trip time */\n  private rtt: number\n\n  /** True if client, false if server */\n  private client: boolean\n\n  private localGoAway?: GoAwayCode\n  private remoteGoAway?: GoAwayCode\n\n  /** Number of tracked inbound streams */\n  private numInboundStreams: number\n  /** Number of tracked outbound streams */\n  private numOutboundStreams: number\n\n  private decoder: Decoder\n  private keepAlive?: RepeatingTask\n\n  private enableKeepAlive: boolean\n  private keepAliveInterval: number\n  private maxInboundStreams: number\n  private maxOutboundStreams: number\n\n  constructor (maConn: MessageStream, init: YamuxMuxerInit = {}) {\n    super(maConn, {\n      ...init,\n      protocol: YAMUX_PROTOCOL_ID,\n      name: 'yamux'\n    })\n\n    this.client = maConn.direction === 'outbound'\n    verifyConfig(init)\n\n    this.enableKeepAlive = init.enableKeepAlive ?? defaultConfig.enableKeepAlive\n    this.keepAliveInterval = init.keepAliveInterval ?? defaultConfig.keepAliveInterval\n    this.maxInboundStreams = init.maxInboundStreams ?? defaultConfig.maxInboundStreams\n    this.maxOutboundStreams = init.maxOutboundStreams ?? defaultConfig.maxOutboundStreams\n\n    this.decoder = new Decoder()\n\n    this.numInboundStreams = 0\n    this.numOutboundStreams = 0\n\n    // client uses odd streamIDs, server uses even streamIDs\n    this.nextStreamID = this.client ? 1 : 2\n\n    this.nextPingID = 0\n    this.rtt = -1\n\n    this.log.trace('muxer created')\n\n    if (this.enableKeepAlive) {\n      this.log.trace('muxer keepalive enabled interval=%s', this.keepAliveInterval)\n      this.keepAlive = repeatingTask(async (options) => {\n        try {\n          await this.ping(options)\n        } catch (err: any) {\n          // TODO: should abort here?\n          this.log.error('ping error: %s', err)\n        }\n      }, this.keepAliveInterval, {\n        // send an initial ping to establish RTT\n        runImmediately: true\n      })\n      this.keepAlive.start()\n    }\n  }\n\n  onData (buf: Uint8Array | Uint8ArrayList): void {\n    for (const frame of this.decoder.emitFrames(buf)) {\n      this.handleFrame(frame)\n    }\n  }\n\n  onCreateStream (): YamuxStream {\n    if (this.remoteGoAway !== undefined) {\n      throw new MuxerClosedError('Muxer closed remotely')\n    }\n\n    if (this.localGoAway !== undefined) {\n      throw new MuxerClosedError('Muxer closed locally')\n    }\n\n    const id = this.nextStreamID\n    this.nextStreamID += 2\n\n    // check against our configured maximum number of outbound streams\n    if (this.numOutboundStreams >= this.maxOutboundStreams) {\n      throw new TooManyOutboundProtocolStreamsError('max outbound streams exceeded')\n    }\n\n    this.log.trace('new outgoing stream id=%s', id)\n\n    const stream = this._newStream(id, StreamState.Init, 'outbound')\n\n    this.numOutboundStreams++\n\n    // send a window update to open the stream on the receiver end. do this in a\n    // microtask so the stream gets added to the streams array by the superclass\n    // before we send the SYN flag, otherwise we create a race condition whereby\n    // we can receive the ACK before the stream is added to the streams list\n    queueMicrotask(() => {\n      stream.sendWindowUpdate()\n    })\n\n    return stream\n  }\n\n  /**\n   * Initiate a ping and wait for a response\n   *\n   * Note: only a single ping will be initiated at a time.\n   * If a ping is already in progress, a new ping will not be initiated.\n   *\n   * @returns the round-trip-time in milliseconds\n   */\n  async ping (options?: AbortOptions): Promise<number> {\n    if (this.remoteGoAway !== undefined) {\n      throw new MuxerClosedError('Muxer closed remotely')\n    }\n    if (this.localGoAway !== undefined) {\n      throw new MuxerClosedError('Muxer closed locally')\n    }\n\n    if (this.activePing != null) {\n      // an active ping is already in progress, piggyback off that\n      return raceSignal(this.activePing.promise, options?.signal)\n    }\n\n    // An active ping does not yet exist, handle the process here\n    // create active ping\n    this.activePing = Object.assign(Promise.withResolvers<number>(), {\n      id: this.nextPingID++,\n      start: Date.now()\n    })\n    // send ping\n    this.sendPing(this.activePing.id)\n    // await pong\n    try {\n      this.rtt = await raceSignal(this.activePing.promise, options?.signal)\n    } finally {\n      // clean-up active ping\n      this.activePing = undefined\n    }\n\n    return this.rtt\n  }\n\n  /**\n   * Get the ping round trip time\n   *\n   * Note: Will return 0 if no successful ping has yet been completed\n   *\n   * @returns the round-trip-time in milliseconds\n   */\n  getRTT (): number {\n    return this.rtt\n  }\n\n  /**\n   * Close the muxer\n   */\n  async close (options: CloseOptions = {}): Promise<void> {\n    if (this.status !== 'open') {\n      // already closed\n      return\n    }\n\n    try {\n      const reason = options?.reason ?? GoAwayCode.NormalTermination\n\n      this.log.trace('muxer close reason=%s', GoAwayCode[reason])\n\n      await super.close(options)\n\n      // send reason to the other side, allow the other side to close gracefully\n      this.sendGoAway(reason)\n    } finally {\n      this.keepAlive?.stop()\n    }\n  }\n\n  abort (err: Error): void {\n    if (this.status !== 'open') {\n      // already closed\n      return\n    }\n\n    try {\n      super.abort(err)\n\n      let reason = GoAwayCode.InternalError\n\n      if (isProtocolError(err)) {\n        reason = err.reason\n      }\n\n      // If reason was provided, use that, otherwise use the presence of `err` to determine the reason\n      this.log.error('muxer abort reason=%s error=%s', reason, err)\n\n      // send reason to the other side, allow the other side to close gracefully\n      this.sendGoAway(reason)\n    } finally {\n      this.keepAlive?.stop()\n    }\n  }\n\n  onTransportClosed (): void {\n    try {\n      super.onTransportClosed()\n    } finally {\n      this.keepAlive?.stop()\n    }\n  }\n\n  /** Create a new stream */\n  private _newStream (streamId: number, state: StreamState, direction: 'inbound' | 'outbound'): YamuxStream {\n    if (this.streams.find(s => s.streamId === streamId) != null) {\n      throw new InvalidParametersError('Stream already exists with that id')\n    }\n\n    const stream = new YamuxStream({\n      ...this.streamOptions,\n      id: `${streamId}`,\n      streamId,\n      state,\n      direction,\n      sendFrame: this.sendFrame.bind(this),\n      log: this.log.newScope(`${direction}:${streamId}`),\n      getRTT: this.getRTT.bind(this)\n    })\n\n    stream.addEventListener('close', () => {\n      this.closeStream(streamId)\n    }, {\n      once: true\n    })\n\n    return stream\n  }\n\n  /**\n   * closeStream is used to close a stream once both sides have\n   * issued a close.\n   */\n  private closeStream (id: number): void {\n    if (this.client === (id % 2 === 0)) {\n      this.numInboundStreams--\n    } else {\n      this.numOutboundStreams--\n    }\n  }\n\n  private handleFrame (frame: Frame): void {\n    const {\n      streamID,\n      type,\n      length\n    } = frame.header\n\n    this.log.trace('received frame %o', debugFrame(frame.header))\n\n    if (streamID === 0) {\n      switch (type) {\n        case FrameType.Ping:\n        { this.handlePing(frame.header); return }\n        case FrameType.GoAway:\n        { this.handleGoAway(length); return }\n        default:\n          // Invalid state\n          throw new InvalidFrameError('Invalid frame type')\n      }\n    } else {\n      switch (frame.header.type) {\n        case FrameType.Data:\n        case FrameType.WindowUpdate:\n        { this.handleStreamMessage(frame); return }\n        default:\n          // Invalid state\n          throw new InvalidFrameError('Invalid frame type')\n      }\n    }\n  }\n\n  private handlePing (header: FrameHeader): void {\n    // If the ping  is initiated by the sender, send a response\n    if (header.flag === Flag.SYN) {\n      this.log.trace('received ping request pingId=%s', header.length)\n      this.sendPing(header.length, Flag.ACK)\n    } else if (header.flag === Flag.ACK) {\n      this.log.trace('received ping response pingId=%s', header.length)\n      this.handlePingResponse(header.length)\n    } else {\n      // Invalid state\n      throw new InvalidFrameError('Invalid frame flag')\n    }\n  }\n\n  private handlePingResponse (pingId: number): void {\n    if (this.activePing === undefined) {\n      // this ping was not requested\n      throw new UnRequestedPingError('ping not requested')\n    }\n    if (this.activePing.id !== pingId) {\n      // this ping doesn't match our active ping request\n      throw new NotMatchingPingError('ping doesn\\'t match our id')\n    }\n\n    // valid ping response\n    this.activePing.resolve(Date.now() - this.activePing.start)\n  }\n\n  private handleGoAway (reason: GoAwayCode): void {\n    this.log.trace('received GoAway reason=%s', GoAwayCode[reason] ?? 'unknown')\n    this.remoteGoAway = reason\n\n    if (reason === GoAwayCode.NormalTermination) {\n      this.onTransportClosed()\n    } else {\n      // reset any streams that are still open and close the muxer\n      this.abort(new Error('Remote sent GoAway'))\n    }\n  }\n\n  private handleStreamMessage (frame: Frame): void {\n    const { streamID, flag, type } = frame.header\n\n    if ((flag & Flag.SYN) === Flag.SYN) {\n      this.incomingStream(streamID)\n    }\n\n    const stream = this.streams.find(s => s.streamId === streamID)\n    if (stream === undefined) {\n      this.log.trace('frame for missing stream id=%s', streamID)\n\n      return\n    }\n\n    switch (type) {\n      case FrameType.WindowUpdate: {\n        stream.handleWindowUpdate(frame); return\n      }\n      case FrameType.Data: {\n        stream.handleData(frame); return\n      }\n      default:\n        throw new Error('unreachable')\n    }\n  }\n\n  private incomingStream (id: number): void {\n    if (this.client !== (id % 2 === 0)) {\n      throw new InvalidParametersError('Both endpoints are clients')\n    }\n    if (this.streams.find(s => s.streamId === id)) {\n      return\n    }\n\n    this.log.trace('new incoming stream id=%s', id)\n\n    if (this.localGoAway !== undefined) {\n      // reject (reset) immediately if we are doing a go away\n      this.sendFrame({\n        type: FrameType.WindowUpdate,\n        flag: Flag.RST,\n        streamID: id,\n        length: 0\n      })\n      return\n    }\n\n    // check against our configured maximum number of inbound streams\n    if (this.numInboundStreams >= this.maxInboundStreams) {\n      this.log('maxIncomingStreams exceeded, forcing stream reset')\n      this.sendFrame({\n        type: FrameType.WindowUpdate,\n        flag: Flag.RST,\n        streamID: id,\n        length: 0\n      })\n      return\n    }\n\n    // allocate a new stream\n    const stream = this._newStream(id, StreamState.SYNReceived, 'inbound')\n\n    this.numInboundStreams++\n\n    // the stream should now be tracked\n    this.onRemoteStream(stream)\n  }\n\n  private sendFrame (header: FrameHeader, data?: Uint8ArrayList): boolean {\n    let encoded: Uint8Array | Uint8ArrayList\n\n    if (header.type === FrameType.Data) {\n      if (data == null) {\n        throw new InvalidFrameError('Invalid frame')\n      }\n\n      encoded = new Uint8ArrayList(encodeHeader(header), data)\n    } else {\n      encoded = encodeHeader(header)\n    }\n\n    this.log.trace('sending frame %o', debugFrame(header))\n\n    return this.send(encoded)\n  }\n\n  private sendPing (pingId: number, flag: Flag = Flag.SYN): void {\n    if (flag === Flag.SYN) {\n      this.log.trace('sending ping request pingId=%s', pingId)\n    } else {\n      this.log.trace('sending ping response pingId=%s', pingId)\n    }\n    this.sendFrame({\n      type: FrameType.Ping,\n      flag,\n      streamID: 0,\n      length: pingId\n    })\n  }\n\n  private sendGoAway (reason: GoAwayCode = GoAwayCode.NormalTermination): void {\n    this.log('sending GoAway reason=%s', GoAwayCode[reason])\n    this.localGoAway = reason\n    this.sendFrame({\n      type: FrameType.GoAway,\n      flag: 0,\n      streamID: 0,\n      length: reason\n    })\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * This module is a JavaScript implementation of [Yamux from Hashicorp](https://github.com/hashicorp/yamux/blob/master/spec.md) designed to be used with [js-libp2p](https://github.com/libp2p/js-libp2p).\n *\n * @example Configure libp2p with Yamux\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n * import { yamux } from '@libp2p/yamux'\n *\n * const node = await createLibp2p({\n *   // ... other options\n *   streamMuxers: [\n *     yamux()\n *   ]\n * })\n * ```\n *\n * @example Using the low-level API\n *\n * ```js\n * import { yamux } from '@libp2p/yamux'\n * import { pipe } from 'it-pipe'\n * import { duplexPair } from 'it-pair/duplex'\n * import all from 'it-all'\n *\n * // Connect two yamux muxers to demo basic stream multiplexing functionality\n *\n * const clientMuxer = yamux({\n *   client: true,\n *   onIncomingStream: stream => {\n *     // echo data on incoming streams\n *     pipe(stream, stream)\n *   },\n *   onStreamEnd: stream => {\n *     // do nothing\n *   }\n * })()\n *\n * const serverMuxer = yamux({\n *   client: false,\n *   onIncomingStream: stream => {\n *     // echo data on incoming streams\n *     pipe(stream, stream)\n *   },\n *   onStreamEnd: stream => {\n *     // do nothing\n *   }\n * })()\n *\n * // `p` is our \"connections\", what we use to connect the two sides\n * // In a real application, a connection is usually to a remote computer\n * const p = duplexPair()\n *\n * // connect the muxers together\n * pipe(p[0], clientMuxer, p[0])\n * pipe(p[1], serverMuxer, p[1])\n *\n * // now either side can open streams\n * const stream0 = clientMuxer.newStream()\n * const stream1 = serverMuxer.newStream()\n *\n * // Send some data to the other side\n * const encoder = new TextEncoder()\n * const data = [encoder.encode('hello'), encoder.encode('world')]\n * pipe(data, stream0)\n *\n * // Receive data back\n * const result = await pipe(stream0, all)\n *\n * // close a stream\n * stream1.close()\n *\n * // close the muxer\n * clientMuxer.close()\n * ```\n */\n\nimport { Yamux } from './muxer.js'\nimport type { YamuxMuxer, YamuxMuxerInit } from './muxer.js'\nimport type { StreamMuxerFactory } from '@libp2p/interface'\n\nexport { GoAwayCode } from './frame.js'\nexport type { FrameHeader, FrameType } from './frame.js'\nexport type { YamuxMuxerInit }\n\nexport function yamux (init: YamuxMuxerInit = {}): () => StreamMuxerFactory<YamuxMuxer> {\n  return () => new Yamux(init)\n}\n"],
  "mappings": "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",
  "names": ["FrameType", "Flag", "GoAwayCode", "_a", "_b", "StreamState", "_a", "_b", "_a"]
}
