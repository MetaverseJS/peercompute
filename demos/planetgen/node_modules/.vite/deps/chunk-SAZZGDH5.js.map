{
  "version": 3,
  "sources": ["../../../../../node_modules/@multiformats/multiaddr/src/errors.ts", "../../../../../node_modules/@chainsafe/is-ip/src/parser.ts", "../../../../../node_modules/@chainsafe/is-ip/src/parse.ts", "../../../../../node_modules/@chainsafe/is-ip/src/is-ip.ts", "../../../../../node_modules/@multiformats/multiaddr/src/constants.ts", "../../../../../node_modules/@multiformats/multiaddr/src/utils.ts", "../../../../../node_modules/@multiformats/multiaddr/src/validation.ts", "../../../../../node_modules/@multiformats/multiaddr/src/registry.ts", "../../../../../node_modules/@multiformats/multiaddr/src/components.ts", "../../../../../node_modules/@multiformats/multiaddr/src/multiaddr.ts", "../../../../../node_modules/@multiformats/multiaddr/src/index.ts"],
  "sourcesContent": ["/**\n * Thrown when an invalid multiaddr is encountered\n */\nexport class InvalidMultiaddrError extends Error {\n  static name = 'InvalidMultiaddrError'\n  name = 'InvalidMultiaddrError'\n}\n\nexport class ValidationError extends Error {\n  static name = 'ValidationError'\n  name = 'ValidationError'\n}\n\nexport class InvalidParametersError extends Error {\n  static name = 'InvalidParametersError'\n  name = 'InvalidParametersError'\n}\n\nexport class UnknownProtocolError extends Error {\n  static name = 'UnknownProtocolError'\n  name = 'UnknownProtocolError'\n}\n", "/* eslint-disable @typescript-eslint/no-unsafe-return */\n\n// Heavily inspired by https://doc.rust-lang.org/src/std/net/parser.rs.html\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Fn = (...foo: any) => any;\n\nexport class Parser {\n  private index = 0;\n  private input = \"\";\n\n  new(input: string): this {\n    this.index = 0;\n    this.input = input;\n    return this;\n  }\n\n  /** Run a parser, and restore the pre-parse state if it fails. */\n  readAtomically<T extends Fn>(fn: T): ReturnType<T> {\n    const index = this.index;\n    const result = fn();\n    if (result === undefined) {\n      this.index = index;\n    }\n    return result;\n  }\n\n  /** Run a parser, but fail if the entire input wasn't consumed. Doesn't run atomically. */\n  parseWith<T extends Fn>(fn: T): ReturnType<T> | undefined {\n    const result = fn();\n    if (this.index !== this.input.length) {\n      return undefined;\n    }\n    return result;\n  }\n\n  /** Peek the next character from the input */\n  peekChar(): string | undefined {\n    if (this.index >= this.input.length) {\n      return undefined;\n    }\n    return this.input[this.index];\n  }\n\n  /** Read the next character from the input */\n  readChar(): string | undefined {\n    if (this.index >= this.input.length) {\n      return undefined;\n    }\n    return this.input[this.index++];\n  }\n\n  /** Read the next character from the input if it matches the target. */\n  readGivenChar(target: string): string | undefined {\n    return this.readAtomically(() => {\n      const char = this.readChar();\n      if (char !== target) {\n        return undefined;\n      }\n      return char;\n    });\n  }\n\n  /**\n   * Helper for reading separators in an indexed loop. Reads the separator\n   * character iff index > 0, then runs the parser. When used in a loop,\n   * the separator character will only be read on index > 0 (see\n   * readIPv4Addr for an example)\n   */\n  readSeparator<T extends Fn>(sep: string, index: number, inner: T): ReturnType<T> {\n    return this.readAtomically(() => {\n      if (index > 0) {\n        if (this.readGivenChar(sep) === undefined) {\n          return undefined;\n        }\n      }\n      return inner();\n    });\n  }\n\n  /**\n   * Read a number off the front of the input in the given radix, stopping\n   * at the first non-digit character or eof. Fails if the number has more\n   * digits than max_digits or if there is no number.\n   */\n  readNumber(\n    radix: number,\n    maxDigits: number | undefined,\n    allowZeroPrefix: boolean,\n    maxBytes: number\n  ): number | undefined {\n    return this.readAtomically(() => {\n      let result = 0;\n      let digitCount = 0;\n\n      const leadingChar = this.peekChar();\n      if (leadingChar === undefined) {\n        return undefined;\n      }\n      const hasLeadingZero = leadingChar === \"0\";\n      const maxValue = 2 ** (8 * maxBytes) - 1;\n\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        const digit = this.readAtomically(() => {\n          const char = this.readChar();\n          if (char === undefined) {\n            return undefined;\n          }\n          const num = Number.parseInt(char, radix);\n          if (Number.isNaN(num)) {\n            return undefined;\n          }\n          return num;\n        });\n        if (digit === undefined) {\n          break;\n        }\n        result *= radix;\n        result += digit;\n        if (result > maxValue) {\n          return undefined;\n        }\n        digitCount += 1;\n        if (maxDigits !== undefined) {\n          if (digitCount > maxDigits) {\n            return undefined;\n          }\n        }\n      }\n\n      if (digitCount === 0) {\n        return undefined;\n      } else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {\n        return undefined;\n      } else {\n        return result;\n      }\n    });\n  }\n\n  /** Read an IPv4 address. */\n  readIPv4Addr(): Uint8Array | undefined {\n    return this.readAtomically(() => {\n      const out = new Uint8Array(4);\n\n      for (let i = 0; i < out.length; i++) {\n        const ix = this.readSeparator(\".\", i, () => this.readNumber(10, 3, false, 1));\n        if (ix === undefined) {\n          return undefined;\n        }\n        out[i] = ix;\n      }\n\n      return out;\n    });\n  }\n\n  /** Read an IPv6 Address. */\n  readIPv6Addr(): Uint8Array | undefined {\n    /**\n     * Read a chunk of an IPv6 address into `groups`. Returns the number\n     * of groups read, along with a bool indicating if an embedded\n     * trailing IPv4 address was read. Specifically, read a series of\n     * colon-separated IPv6 groups (0x0000 - 0xFFFF), with an optional\n     * trailing embedded IPv4 address.\n     */\n    const readGroups = (groups: Uint8Array): [number, boolean] => {\n      for (let i = 0; i < groups.length / 2; i++) {\n        const ix = i * 2;\n        // Try to read a trailing embedded IPv4 address. There must be at least 4 groups left.\n        if (i < groups.length - 3) {\n          const ipv4 = this.readSeparator(\":\", i, () => this.readIPv4Addr());\n          if (ipv4 !== undefined) {\n            groups[ix] = ipv4[0];\n            groups[ix + 1] = ipv4[1];\n            groups[ix + 2] = ipv4[2];\n            groups[ix + 3] = ipv4[3];\n\n            return [ix + 4, true];\n          }\n        }\n\n        const group = this.readSeparator(\":\", i, () => this.readNumber(16, 4, true, 2));\n        if (group === undefined) {\n          return [ix, false];\n        }\n        groups[ix] = group >> 8;\n        groups[ix + 1] = group & 255;\n      }\n      return [groups.length, false];\n    };\n\n    return this.readAtomically(() => {\n      // Read the front part of the address; either the whole thing, or up to the first ::\n      const head = new Uint8Array(16);\n      const [headSize, headIp4] = readGroups(head);\n\n      if (headSize === 16) {\n        return head;\n      }\n\n      // IPv4 part is not allowed before `::`\n      if (headIp4) {\n        return undefined;\n      }\n\n      // Read `::` if previous code parsed less than 8 groups.\n      // `::` indicates one or more groups of 16 bits of zeros.\n      if (this.readGivenChar(\":\") === undefined) {\n        return undefined;\n      }\n      if (this.readGivenChar(\":\") === undefined) {\n        return undefined;\n      }\n\n      // Read the back part of the address. The :: must contain at least one\n      // set of zeroes, so our max length is 7.\n      const tail = new Uint8Array(14);\n      const limit = 16 - (headSize + 2);\n      const [tailSize] = readGroups(tail.subarray(0, limit));\n\n      // Concat the head and tail of the IP address\n      head.set(tail.subarray(0, tailSize), 16 - tailSize);\n\n      return head;\n    });\n  }\n\n  /** Read an IP Address, either IPv4 or IPv6. */\n  readIPAddr(): Uint8Array | undefined {\n    return this.readIPv4Addr() ?? this.readIPv6Addr();\n  }\n}\n", "import { Parser } from \"./parser.js\";\n\n// See https://stackoverflow.com/questions/166132/maximum-length-of-the-textual-representation-of-an-ipv6-address\nconst MAX_IPV6_LENGTH = 45;\nconst MAX_IPV4_LENGTH = 15;\n\nconst parser = new Parser();\n\n/** Parse `input` into IPv4 bytes. */\nexport function parseIPv4(input: string): Uint8Array | undefined {\n  if (input.length > MAX_IPV4_LENGTH) {\n    return undefined;\n  }\n  return parser.new(input).parseWith(() => parser.readIPv4Addr());\n}\n\n/** Parse IPv4 `input` into IPv6 with IPv4-mapped bytes, eg ::ffff:1.2.3.4 */\nexport function parseIPv4Mapped(input: string): Uint8Array | undefined {\n  if (input.length > MAX_IPV4_LENGTH) {\n    return undefined;\n  }\n\n  const ipv4 = parser.new(input).parseWith(() => parser.readIPv4Addr());\n  if (ipv4 === undefined) {\n    return undefined;\n  }\n\n  return Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, ipv4[0], ipv4[1], ipv4[2], ipv4[3]]);\n}\n\n/** Parse `input` into IPv6 bytes. */\nexport function parseIPv6(input: string): Uint8Array | undefined {\n  // strip zone index if it is present\n  if (input.includes(\"%\")) {\n    input = input.split(\"%\")[0];\n  }\n  if (input.length > MAX_IPV6_LENGTH) {\n    return undefined;\n  }\n  return parser.new(input).parseWith(() => parser.readIPv6Addr());\n}\n\n/** Parse `input` into IPv4 or IPv6 bytes. */\nexport function parseIP(input: string, mapIPv4ToIPv6 = false): Uint8Array | undefined {\n  // strip zone index if it is present\n  if (input.includes(\"%\")) {\n    input = input.split(\"%\")[0];\n  }\n\n  if (input.length > MAX_IPV6_LENGTH) {\n    return undefined;\n  }\n\n  const addr = parser.new(input).parseWith(() => parser.readIPAddr());\n  if (!addr) {\n    return undefined;\n  }\n\n  if (mapIPv4ToIPv6 && addr.length === 4) {\n    return Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, addr[0], addr[1], addr[2], addr[3]]);\n  }\n\n  return addr;\n}\n", "import { parseIP, parseIPv4, parseIPv6 } from \"./parse.js\";\n\n/** Check if `input` is IPv4. */\nexport function isIPv4(input: string): boolean {\n  return Boolean(parseIPv4(input));\n}\n\n/** Check if `input` is IPv6. */\nexport function isIPv6(input: string): boolean {\n  return Boolean(parseIPv6(input));\n}\n\n/** Check if `input` is IPv4 or IPv6. */\nexport function isIP(input: string): boolean {\n  return Boolean(parseIP(input));\n}\n\n/**\n * @returns `6` if `input` is IPv6, `4` if `input` is IPv4, or `undefined` if `input` is neither.\n */\nexport function ipVersion(input: string): 4 | 6 | undefined {\n  if (isIPv4(input)) {\n    return 4;\n  } else if (isIPv6(input)) {\n    return 6;\n  } else {\n    return undefined;\n  }\n}\n", "// the values here come from https://github.com/multiformats/multiaddr/blob/master/protocols.csv\n\nexport const CODE_IP4 = 4\nexport const CODE_TCP = 6\nexport const CODE_UDP = 273\nexport const CODE_DCCP = 33\nexport const CODE_IP6 = 41\nexport const CODE_IP6ZONE = 42\nexport const CODE_IPCIDR = 43\nexport const CODE_DNS = 53\nexport const CODE_DNS4 = 54\nexport const CODE_DNS6 = 55\nexport const CODE_DNSADDR = 56\nexport const CODE_SCTP = 132\nexport const CODE_UDT = 301\nexport const CODE_UTP = 302\nexport const CODE_UNIX = 400\nexport const CODE_P2P = 421 // also IPFS\nexport const CODE_ONION = 444\nexport const CODE_ONION3 = 445\nexport const CODE_GARLIC64 = 446\nexport const CODE_GARLIC32 = 447\nexport const CODE_TLS = 448\nexport const CODE_SNI = 449\nexport const CODE_NOISE = 454\nexport const CODE_QUIC = 460\nexport const CODE_QUIC_V1 = 461\nexport const CODE_WEBTRANSPORT = 465\nexport const CODE_CERTHASH = 466\nexport const CODE_HTTP = 480\nexport const CODE_HTTP_PATH = 481\nexport const CODE_HTTPS = 443\nexport const CODE_WS = 477\nexport const CODE_WSS = 478\nexport const CODE_P2P_WEBSOCKET_STAR = 479\nexport const CODE_P2P_STARDUST = 277\nexport const CODE_P2P_WEBRTC_STAR = 275\nexport const CODE_P2P_WEBRTC_DIRECT = 276\nexport const CODE_WEBRTC_DIRECT = 280\nexport const CODE_WEBRTC = 281\nexport const CODE_P2P_CIRCUIT = 290\nexport const CODE_MEMORY = 777\n", "import { isIPv4 } from '@chainsafe/is-ip'\nimport { base32 } from 'multiformats/bases/base32'\nimport { bases } from 'multiformats/basics'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { InvalidMultiaddrError } from './errors.ts'\nimport type { MultibaseCodec } from 'multiformats'\nimport type { SupportedEncodings } from 'uint8arrays/to-string'\n\nexport function bytesToString (base: SupportedEncodings): (buf: Uint8Array) => string {\n  return (buf) => {\n    return uint8ArrayToString(buf, base)\n  }\n}\n\nexport function stringToBytes (base: SupportedEncodings): (value: string) => Uint8Array {\n  return (buf) => {\n    return uint8ArrayFromString(buf, base)\n  }\n}\n\nexport function bytes2port (buf: Uint8Array): string {\n  const view = new DataView(buf.buffer)\n  return view.getUint16(buf.byteOffset).toString()\n}\n\nexport function port2bytes (port: string | number): Uint8Array {\n  const buf = new ArrayBuffer(2)\n  const view = new DataView(buf)\n  view.setUint16(0, typeof port === 'string' ? parseInt(port) : port)\n\n  return new Uint8Array(buf)\n}\n\nexport function onion2bytes (str: string): Uint8Array {\n  const addr = str.split(':')\n\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`)\n  }\n\n  if (addr[0].length !== 16) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`)\n  }\n\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = uint8ArrayFromString(addr[0], 'base32')\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n\n  const portBuf = port2bytes(port)\n\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)\n}\n\nexport function onion32bytes (str: string): Uint8Array {\n  const addr = str.split(':')\n\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`)\n  }\n\n  if (addr[0].length !== 56) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`)\n  }\n\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = base32.decode(`b${addr[0]}`)\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n\n  const portBuf = port2bytes(port)\n\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)\n}\n\nexport function bytes2onion (buf: Uint8Array): string {\n  const addrBytes = buf.subarray(0, buf.length - 2)\n  const portBytes = buf.subarray(buf.length - 2)\n  const addr = uint8ArrayToString(addrBytes, 'base32')\n  const port = bytes2port(portBytes)\n  return `${addr}:${port}`\n}\n\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L7\n// but with buf/offset args removed because we don't use them\nexport const ip4ToBytes = function (ip: string): Uint8Array {\n  ip = ip.toString().trim()\n\n  const bytes = new Uint8Array(4)\n\n  ip.split(/\\./g).forEach((byte, index) => {\n    const value = parseInt(byte, 10)\n\n    if (isNaN(value) || value < 0 || value > 0xff) {\n      throw new InvalidMultiaddrError('Invalid byte value in IP address')\n    }\n\n    bytes[index] = value\n  })\n\n  return bytes\n}\n\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L7\n// but with buf/offset args removed because we don't use them\nexport const ip6ToBytes = function (ip: string): Uint8Array {\n  let offset = 0\n  ip = ip.toString().trim()\n\n  const sections = ip.split(':', 8)\n\n  let i\n  for (i = 0; i < sections.length; i++) {\n    const isv4 = isIPv4(sections[i])\n    let v4Buffer: Uint8Array | undefined\n\n    if (isv4) {\n      v4Buffer = ip4ToBytes(sections[i])\n      sections[i] = uint8ArrayToString(v4Buffer.subarray(0, 2), 'base16')\n    }\n\n    if (v4Buffer != null && ++i < 8) {\n      sections.splice(i, 0, uint8ArrayToString(v4Buffer.subarray(2, 4), 'base16'))\n    }\n  }\n\n  if (sections[0] === '') {\n    while (sections.length < 8) { sections.unshift('0') }\n  } else if (sections[sections.length - 1] === '') {\n    while (sections.length < 8) { sections.push('0') }\n  } else if (sections.length < 8) {\n    for (i = 0; i < sections.length && sections[i] !== ''; i++) { }\n    const argv: [number, number, ...string[]] = [i, 1]\n    for (i = 9 - sections.length; i > 0; i--) {\n      argv.push('0')\n    }\n    sections.splice.apply(sections, argv)\n  }\n\n  const bytes = new Uint8Array(offset + 16)\n\n  for (i = 0; i < sections.length; i++) {\n    if (sections[i] === '') {\n      sections[i] = '0'\n    }\n\n    const word = parseInt(sections[i], 16)\n\n    if (isNaN(word) || word < 0 || word > 0xffff) {\n      throw new InvalidMultiaddrError('Invalid byte value in IP address')\n    }\n\n    bytes[offset++] = (word >> 8) & 0xff\n    bytes[offset++] = word & 0xff\n  }\n\n  return bytes\n}\n\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L63\nexport const ip4ToString = function (buf: Uint8Array): string {\n  if (buf.byteLength !== 4) {\n    throw new InvalidMultiaddrError('IPv4 address was incorrect length')\n  }\n\n  const result = []\n\n  for (let i = 0; i < buf.byteLength; i++) {\n    result.push(buf[i])\n  }\n\n  return result.join('.')\n}\n\nexport const ip6ToString = function (buf: Uint8Array): string {\n  if (buf.byteLength !== 16) {\n    throw new InvalidMultiaddrError('IPv6 address was incorrect length')\n  }\n\n  const result: string[] = []\n\n  for (let i = 0; i < buf.byteLength; i += 2) {\n    const byte1 = buf[i]\n    const byte2 = buf[i + 1]\n\n    const tuple = `${byte1.toString(16).padStart(2, '0')}${byte2.toString(16).padStart(2, '0')}`\n\n    result.push(tuple)\n  }\n\n  const ip = result.join(':')\n\n  try {\n    const url = new URL(`http://[${ip}]`)\n\n    return url.hostname.substring(1, url.hostname.length - 1)\n  } catch {\n    throw new InvalidMultiaddrError(`Invalid IPv6 address \"${ip}\"`)\n  }\n}\n\nexport function ip6StringToValue (str: string): string {\n  try {\n    const url = new URL(`http://[${str}]`)\n\n    return url.hostname.substring(1, url.hostname.length - 1)\n  } catch {\n    throw new InvalidMultiaddrError(`Invalid IPv6 address \"${str}\"`)\n  }\n}\n\nconst decoders = Object.values(bases).map((c) => c.decoder)\nconst anybaseDecoder = (function () {\n  let acc = decoders[0].or(decoders[1])\n  decoders.slice(2).forEach((d) => (acc = acc.or(d)))\n  return acc\n})()\n\nexport function mb2bytes (mbstr: string): Uint8Array {\n  return anybaseDecoder.decode(mbstr)\n}\n\nexport function bytes2mb (base: MultibaseCodec<any>): (buf: Uint8Array) => string {\n  return (buf) => {\n    return base.encoder.encode(buf)\n  }\n}\n", "import { ValidationError } from './errors.ts'\n\nexport function integer (value: string): void {\n  const int = parseInt(value)\n\n  if (int.toString() !== value) {\n    throw new ValidationError('Value must be an integer')\n  }\n}\n\nexport function positive (value: any): void {\n  if (value < 0) {\n    throw new ValidationError('Value must be a positive integer, or zero')\n  }\n}\n\nexport function maxValue (max: number): (value: any) => void {\n  return (value) => {\n    if (value > max) {\n      throw new ValidationError(`Value must be smaller than or equal to ${max}`)\n    }\n  }\n}\n\nexport function validate (...funcs: Array<(value: string) => void>): (value: string) => void {\n  return (value) => {\n    for (const fn of funcs) {\n      fn(value)\n    }\n  }\n}\n\nexport const validatePort = validate(\n  integer,\n  positive,\n  maxValue(65_535)\n)\n", "import { isIPv4, isIPv6 } from '@chainsafe/is-ip'\nimport { CID } from 'multiformats'\nimport { base64url } from 'multiformats/bases/base64'\nimport { CODE_CERTHASH, CODE_DCCP, CODE_DNS, CODE_DNS4, CODE_DNS6, CODE_DNSADDR, CODE_GARLIC32, CODE_GARLIC64, CODE_HTTP, CODE_HTTP_PATH, CODE_HTTPS, CODE_IP4, CODE_IP6, CODE_IP6ZONE, CODE_IPCIDR, CODE_MEMORY, CODE_NOISE, CODE_ONION, CODE_ONION3, CODE_P2P, CODE_P2P_CIRCUIT, CODE_P2P_STARDUST, CODE_P2P_WEBRTC_DIRECT, CODE_P2P_WEBRTC_STAR, CODE_P2P_WEBSOCKET_STAR, CODE_QUIC, CODE_QUIC_V1, CODE_SCTP, CODE_SNI, CODE_TCP, CODE_TLS, CODE_UDP, CODE_UDT, CODE_UNIX, CODE_UTP, CODE_WEBRTC, CODE_WEBRTC_DIRECT, CODE_WEBTRANSPORT, CODE_WS, CODE_WSS } from './constants.ts'\nimport { UnknownProtocolError, ValidationError } from './errors.ts'\nimport { bytes2mb, bytes2onion, bytes2port, bytesToString, ip4ToBytes, ip4ToString, ip6StringToValue, ip6ToBytes, ip6ToString, mb2bytes, onion2bytes, onion32bytes, port2bytes, stringToBytes } from './utils.ts'\nimport { validatePort } from './validation.ts'\nimport type { Registry as RegistryInterface } from './index.ts'\n\nexport const V = -1\n\nexport interface ProtocolCodec {\n  /**\n   * A numeric code that will be used in the binary representation of the tuple.\n   */\n  code: number\n\n  /**\n   * A string name that will be used in the string representation of the addr.\n   */\n  name: string\n\n  /**\n   * Size defines the expected length of the address part of the tuple - valid\n   * values are `-1` (or the `V` constant) for variable length (this will be\n   * varint encoded in the binary representation), `0` for no address part or a\n   * number that represents a fixed-length address.\n   */\n  size?: number\n\n  /**\n   * If specified this protocol codec will also be used to decode tuples with\n   * these names from string multiaddrs.\n   */\n  aliases?: string[]\n\n  /**\n   * Where the multiaddr has been encoded as a string, decode the value if\n   * necessary, unescaping any escaped values\n   */\n  stringToValue?(value: string): string\n\n  /**\n   * To encode the multiaddr as a string, escape any necessary values\n   */\n  valueToString?(value: string): string\n\n  /**\n   * To encode the multiaddr as bytes, convert the value to bytes\n   */\n  valueToBytes?(value: string): Uint8Array\n\n  /**\n   * To decode bytes to a multiaddr, convert the value bytes to a string\n   */\n  bytesToValue?(bytes: Uint8Array): string\n\n  /**\n   * Perform any necessary validation on the string value\n   */\n  validate?(value: string): void\n}\n\nclass Registry implements RegistryInterface {\n  private protocolsByCode = new Map<number, ProtocolCodec>()\n  private protocolsByName = new Map<string, ProtocolCodec>()\n\n  getProtocol (key: string | number): ProtocolCodec {\n    let codec: ProtocolCodec | undefined\n\n    if (typeof key === 'string') {\n      codec = this.protocolsByName.get(key)\n    } else {\n      codec = this.protocolsByCode.get(key)\n    }\n\n    if (codec == null) {\n      throw new UnknownProtocolError(`Protocol ${key} was unknown`)\n    }\n\n    return codec\n  }\n\n  addProtocol (codec: ProtocolCodec): void {\n    this.protocolsByCode.set(codec.code, codec)\n    this.protocolsByName.set(codec.name, codec)\n\n    codec.aliases?.forEach(alias => {\n      this.protocolsByName.set(alias, codec)\n    })\n  }\n\n  removeProtocol (code: number): void {\n    const codec = this.protocolsByCode.get(code)\n\n    if (codec == null) {\n      return\n    }\n\n    this.protocolsByCode.delete(codec.code)\n    this.protocolsByName.delete(codec.name)\n\n    codec.aliases?.forEach(alias => {\n      this.protocolsByName.delete(alias)\n    })\n  }\n}\n\nexport const registry = new Registry()\n\nconst codecs: ProtocolCodec[] = [{\n  code: CODE_IP4,\n  name: 'ip4',\n  size: 32,\n  valueToBytes: ip4ToBytes,\n  bytesToValue: ip4ToString,\n  validate: (value) => {\n    if (!isIPv4(value)) {\n      throw new ValidationError(`Invalid IPv4 address \"${value}\"`)\n    }\n  }\n}, {\n  code: CODE_TCP,\n  name: 'tcp',\n  size: 16,\n  valueToBytes: port2bytes,\n  bytesToValue: bytes2port,\n  validate: validatePort\n}, {\n  code: CODE_UDP,\n  name: 'udp',\n  size: 16,\n  valueToBytes: port2bytes,\n  bytesToValue: bytes2port,\n  validate: validatePort\n}, {\n  code: CODE_DCCP,\n  name: 'dccp',\n  size: 16,\n  valueToBytes: port2bytes,\n  bytesToValue: bytes2port,\n  validate: validatePort\n}, {\n  code: CODE_IP6,\n  name: 'ip6',\n  size: 128,\n  valueToBytes: ip6ToBytes,\n  bytesToValue: ip6ToString,\n  stringToValue: ip6StringToValue,\n  validate: (value) => {\n    if (!isIPv6(value)) {\n      throw new ValidationError(`Invalid IPv6 address \"${value}\"`)\n    }\n  }\n}, {\n  code: CODE_IP6ZONE,\n  name: 'ip6zone',\n  size: V\n}, {\n  code: CODE_IPCIDR,\n  name: 'ipcidr',\n  size: 8,\n  bytesToValue: bytesToString('base10'),\n  valueToBytes: stringToBytes('base10')\n}, {\n  code: CODE_DNS,\n  name: 'dns',\n  size: V\n}, {\n  code: CODE_DNS4,\n  name: 'dns4',\n  size: V\n}, {\n  code: CODE_DNS6,\n  name: 'dns6',\n  size: V\n}, {\n  code: CODE_DNSADDR,\n  name: 'dnsaddr',\n  size: V\n}, {\n  code: CODE_SCTP,\n  name: 'sctp',\n  size: 16,\n  valueToBytes: port2bytes,\n  bytesToValue: bytes2port,\n  validate: validatePort\n}, {\n  code: CODE_UDT,\n  name: 'udt'\n}, {\n  code: CODE_UTP,\n  name: 'utp'\n}, {\n  code: CODE_UNIX,\n  name: 'unix',\n  size: V,\n  stringToValue: (str) => decodeURIComponent(str),\n  valueToString: (val) => encodeURIComponent(val)\n}, {\n  code: CODE_P2P,\n  name: 'p2p',\n  aliases: ['ipfs'],\n  size: V,\n  bytesToValue: bytesToString('base58btc'),\n  valueToBytes: (val) => {\n    if (val.startsWith('Q') || val.startsWith('1')) {\n      return stringToBytes('base58btc')(val)\n    }\n\n    return CID.parse(val).multihash.bytes\n  }\n}, {\n  code: CODE_ONION,\n  name: 'onion',\n  size: 96,\n  bytesToValue: bytes2onion,\n  valueToBytes: onion2bytes\n}, {\n  code: CODE_ONION3,\n  name: 'onion3',\n  size: 296,\n  bytesToValue: bytes2onion,\n  valueToBytes: onion32bytes\n}, {\n  code: CODE_GARLIC64,\n  name: 'garlic64',\n  size: V\n}, {\n  code: CODE_GARLIC32,\n  name: 'garlic32',\n  size: V\n}, {\n  code: CODE_TLS,\n  name: 'tls'\n}, {\n  code: CODE_SNI,\n  name: 'sni',\n  size: V\n}, {\n  code: CODE_NOISE,\n  name: 'noise'\n}, {\n  code: CODE_QUIC,\n  name: 'quic'\n}, {\n  code: CODE_QUIC_V1,\n  name: 'quic-v1'\n}, {\n  code: CODE_WEBTRANSPORT,\n  name: 'webtransport'\n}, {\n  code: CODE_CERTHASH,\n  name: 'certhash',\n  size: V,\n  bytesToValue: bytes2mb(base64url),\n  valueToBytes: mb2bytes\n}, {\n  code: CODE_HTTP,\n  name: 'http'\n}, {\n  code: CODE_HTTP_PATH,\n  name: 'http-path',\n  size: V,\n  stringToValue: (str) => `/${decodeURIComponent(str)}`,\n  valueToString: (val) => encodeURIComponent(val.substring(1))\n}, {\n  code: CODE_HTTPS,\n  name: 'https'\n}, {\n  code: CODE_WS,\n  name: 'ws'\n}, {\n  code: CODE_WSS,\n  name: 'wss'\n}, {\n  code: CODE_P2P_WEBSOCKET_STAR,\n  name: 'p2p-websocket-star'\n}, {\n  code: CODE_P2P_STARDUST,\n  name: 'p2p-stardust'\n}, {\n  code: CODE_P2P_WEBRTC_STAR,\n  name: 'p2p-webrtc-star'\n}, {\n  code: CODE_P2P_WEBRTC_DIRECT,\n  name: 'p2p-webrtc-direct'\n}, {\n  code: CODE_WEBRTC_DIRECT,\n  name: 'webrtc-direct'\n}, {\n  code: CODE_WEBRTC,\n  name: 'webrtc'\n}, {\n  code: CODE_P2P_CIRCUIT,\n  name: 'p2p-circuit'\n}, {\n  code: CODE_MEMORY,\n  name: 'memory',\n  size: V\n}]\n\ncodecs.forEach(codec => {\n  registry.addProtocol(codec)\n})\n", "import * as varint from 'uint8-varint'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { InvalidMultiaddrError } from './errors.ts'\nimport { registry, V } from './registry.ts'\nimport type { Component } from './index.js'\nimport type { ProtocolCodec } from './registry.ts'\n\nexport function bytesToComponents (bytes: Uint8Array): Component[] {\n  const components: Component[] = []\n\n  let i = 0\n  while (i < bytes.length) {\n    const code = varint.decode(bytes, i)\n    const codec = registry.getProtocol(code)\n    const codeLength = varint.encodingLength(code)\n    const size = sizeForAddr(codec, bytes, i + codeLength)\n    let sizeLength = 0\n\n    if (size > 0 && codec.size === V) {\n      sizeLength = varint.encodingLength(size)\n    }\n\n    const componentLength = codeLength + sizeLength + size\n\n    const component: Component = {\n      code,\n      name: codec.name,\n      bytes: bytes.subarray(i, i + componentLength)\n    }\n\n    if (size > 0) {\n      const valueOffset = i + codeLength + sizeLength\n      const valueBytes = bytes.subarray(valueOffset, valueOffset + size)\n\n      component.value = codec.bytesToValue?.(valueBytes) ?? uint8ArrayToString(valueBytes)\n    }\n\n    components.push(component)\n\n    i += componentLength\n  }\n\n  return components\n}\n\nexport function componentsToBytes (components: Component[]): Uint8Array {\n  let length = 0\n  const bytes: Uint8Array[] = []\n\n  for (const component of components) {\n    if (component.bytes == null) {\n      const codec = registry.getProtocol(component.code)\n      const codecLength = varint.encodingLength(component.code)\n      let valueBytes: Uint8Array | undefined\n      let valueLength = 0\n      let valueLengthLength = 0\n\n      if (component.value != null) {\n        valueBytes = codec.valueToBytes?.(component.value) ?? uint8ArrayFromString(component.value)\n        valueLength = valueBytes.byteLength\n\n        if (codec.size === V) {\n          valueLengthLength = varint.encodingLength(valueLength)\n        }\n      }\n\n      const bytes = new Uint8Array(codecLength + valueLengthLength + valueLength)\n\n      // encode the protocol code\n      let offset = 0\n      varint.encodeUint8Array(component.code, bytes, offset)\n      offset += codecLength\n\n      // if there is a value\n      if (valueBytes != null) {\n        // if the value has variable length, encode the length\n        if (codec.size === V) {\n          varint.encodeUint8Array(valueLength, bytes, offset)\n          offset += valueLengthLength\n        }\n\n        // finally encode the value\n        bytes.set(valueBytes, offset)\n      }\n\n      component.bytes = bytes\n    }\n\n    bytes.push(component.bytes)\n    length += component.bytes.byteLength\n  }\n\n  return uint8ArrayConcat(bytes, length)\n}\n\nexport function stringToComponents (string: string): Component[] {\n  if (string.charAt(0) !== '/') {\n    throw new InvalidMultiaddrError('String multiaddr must start with \"/\"')\n  }\n\n  const components: Component[] = []\n  let collecting: 'protocol' | 'value' = 'protocol'\n  let value = ''\n  let protocol = ''\n\n  for (let i = 1; i < string.length; i++) {\n    const char = string.charAt(i)\n\n    if (char !== '/') {\n      if (collecting === 'protocol') {\n        protocol += string.charAt(i)\n      } else {\n        value += string.charAt(i)\n      }\n    }\n\n    const ended = i === string.length - 1\n\n    if (char === '/' || ended) {\n      const codec = registry.getProtocol(protocol)\n\n      if (collecting === 'protocol') {\n        if (codec.size == null || codec.size === 0) {\n          // a protocol without an address, eg. `/tls`\n          components.push({\n            code: codec.code,\n            name: codec.name\n          })\n\n          value = ''\n          protocol = ''\n          collecting = 'protocol'\n\n          continue\n        } else if (ended) {\n          throw new InvalidMultiaddrError(`Component ${protocol} was missing value`)\n        }\n\n        // continue collecting value\n        collecting = 'value'\n      } else if (collecting === 'value') {\n        const component: Component = {\n          code: codec.code,\n          name: codec.name\n        }\n\n        if (codec.size != null && codec.size !== 0) {\n          if (value === '') {\n            throw new InvalidMultiaddrError(`Component ${protocol} was missing value`)\n          }\n\n          component.value = codec.stringToValue?.(value) ?? value\n        }\n\n        components.push(component)\n\n        value = ''\n        protocol = ''\n        collecting = 'protocol'\n      }\n    }\n  }\n\n  if (protocol !== '' && value !== '') {\n    throw new InvalidMultiaddrError('Incomplete multiaddr')\n  }\n\n  return components\n}\n\nexport function componentsToString (components: Component[]): string {\n  return `/${components.flatMap(component => {\n      if (component.value == null) {\n        return component.name\n      }\n\n      const codec = registry.getProtocol(component.code)\n\n      if (codec == null) {\n        throw new InvalidMultiaddrError(`Unknown protocol code ${component.code}`)\n      }\n\n      return [\n        component.name,\n        codec.valueToString?.(component.value) ?? component.value\n      ]\n    }).join('/')}`\n}\n\n/**\n * For the passed address, return the serialized size\n */\nfunction sizeForAddr (codec: ProtocolCodec, bytes: Uint8Array, offset: number): number {\n  if (codec.size == null || codec.size === 0) {\n    return 0\n  }\n\n  if (codec.size > 0) {\n    return codec.size / 8\n  }\n\n  return varint.decode(bytes, offset)\n}\n", "import { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { bytesToComponents, componentsToBytes, componentsToString, stringToComponents } from './components.js'\nimport { InvalidMultiaddrError, InvalidParametersError } from './errors.ts'\nimport { registry } from './registry.ts'\nimport { isMultiaddr } from './index.js'\nimport type { MultiaddrInput, Multiaddr as MultiaddrInterface, Component } from './index.js'\n\nconst inspect = Symbol.for('nodejs.util.inspect.custom')\nexport const symbol = Symbol.for('@multiformats/multiaddr')\n\nfunction toComponents (addr: MultiaddrInput): Component[] {\n  if (addr == null) {\n    addr = '/'\n  }\n\n  if (isMultiaddr(addr)) {\n    return addr.getComponents()\n  }\n\n  if (addr instanceof Uint8Array) {\n    return bytesToComponents(addr)\n  }\n\n  if (typeof addr === 'string') {\n    addr = addr\n      .replace(/\\/(\\/)+/, '/')\n      .replace(/(\\/)+$/, '')\n\n    if (addr === '') {\n      addr = '/'\n    }\n\n    return stringToComponents(addr)\n  }\n\n  if (Array.isArray(addr)) {\n    return addr\n  }\n\n  throw new InvalidMultiaddrError('Must be a string, Uint8Array, Component[], or another Multiaddr')\n}\n\ninterface MultiaddrOptions {\n  validate?: boolean\n}\n\n/**\n * Creates a {@link Multiaddr} from a {@link MultiaddrInput}\n */\nexport class Multiaddr implements MultiaddrInterface {\n  [symbol]: boolean = true\n  readonly #components: Component[]\n\n  // cache string representation\n  #string: string | undefined\n  // cache byte representation\n  #bytes: Uint8Array | undefined\n\n  constructor (addr: MultiaddrInput | Component[] = '/', options: MultiaddrOptions = {}) {\n    this.#components = toComponents(addr)\n\n    if (options.validate !== false) {\n      validate(this)\n    }\n  }\n\n  get bytes (): Uint8Array {\n    if (this.#bytes == null) {\n      this.#bytes = componentsToBytes(this.#components)\n    }\n\n    return this.#bytes\n  }\n\n  toString (): string {\n    if (this.#string == null) {\n      this.#string = componentsToString(this.#components)\n    }\n\n    return this.#string\n  }\n\n  toJSON (): string {\n    return this.toString()\n  }\n\n  getComponents (): Component[] {\n    return [\n      ...this.#components.map(c => ({ ...c }))\n    ]\n  }\n\n  encapsulate (addr: MultiaddrInput): MultiaddrInterface {\n    const ma = new Multiaddr(addr)\n\n    return new Multiaddr([\n      ...this.#components,\n      ...ma.getComponents()\n    ], {\n      validate: false\n    })\n  }\n\n  decapsulate (addr: Multiaddr | string): MultiaddrInterface {\n    const addrString = addr.toString()\n    const s = this.toString()\n    const i = s.lastIndexOf(addrString)\n\n    if (i < 0) {\n      throw new InvalidParametersError(`Address ${this.toString()} does not contain subaddress: ${addrString}`)\n    }\n\n    return new Multiaddr(s.slice(0, i), {\n      validate: false\n    })\n  }\n\n  decapsulateCode (code: number): Multiaddr {\n    let index\n\n    for (let i = this.#components.length - 1; i > -1; i--) {\n      if (this.#components[i].code === code) {\n        index = i\n        break\n      }\n    }\n\n    return new Multiaddr(this.#components.slice(0, index), {\n      validate: false\n    })\n  }\n\n  equals (addr: { bytes: Uint8Array }): boolean {\n    return uint8ArrayEquals(this.bytes, addr.bytes)\n  }\n\n  /**\n   * Returns Multiaddr as a human-readable string\n   * https://nodejs.org/api/util.html#utilinspectcustom\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n   * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'\n   * ```\n   */\n  [inspect] (): string {\n    return `Multiaddr(${this.toString()})`\n  }\n}\n\n/**\n * Ensures all multiaddr tuples are correct. Throws if any invalid protocols or\n * values are encountered.\n */\nexport function validate (addr: Multiaddr): void {\n  addr.getComponents()\n    .forEach(component => {\n      const codec = registry.getProtocol(component.code)\n\n      if (component.value == null) {\n        return\n      }\n\n      codec.validate?.(component.value)\n    })\n}\n", "/**\n * @packageDocumentation\n *\n * A standard way to represent addresses that\n *\n * - support any standard network protocol\n * - have a binary packed format\n * - have a nice string representation\n * - encapsulate well\n *\n * @example\n *\n * ```TypeScript\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const addr = multiaddr('/ip4/127.0.0.1/udp/1234')\n * // Multiaddr(/ip4/127.0.0.1/udp/1234)\n *\n * addr.bytes\n * // <Uint8Array 04 7f 00 00 01 11 04 d2>\n *\n * addr.toString()\n * // '/ip4/127.0.0.1/udp/1234'\n *\n * addr.getComponents()\n * // [\n * //   { code: 4, name: 'ip4', value: '127.0.0.1' },\n * //   { code: 273, name: 'udp', value: '1234' }\n * // ]\n *\n * addr.encapsulate('/sctp/5678')\n * // Multiaddr(/ip4/127.0.0.1/udp/1234/sctp/5678)\n * ```\n *\n * @example Adding custom protocols\n *\n * To add application-specific or experimental protocols, add a protocol codec\n * to the protocol registry:\n *\n * ```ts\n * import { registry, V, multiaddr } from '@multiformats/multiaddr'\n * import type { ProtocolCodec } from '@multiformats/multiaddr'\n *\n * const maWithCustomTuple = '/custom-protocol/hello'\n *\n * // throws UnknownProtocolError\n * multiaddr(maWithCustomTuple)\n *\n * const protocol: ProtocolCodec = {\n *   code: 2059,\n *   name: 'custom-protocol',\n *   size: V\n *   // V means variable length, can also be 0, a positive integer (e.g. a fixed\n *   // length or omitted\n * }\n *\n * registry.addProtocol(protocol)\n *\n * // does not throw UnknownProtocolError\n * multiaddr(maWithCustomTuple)\n *\n * // protocols can also be removed\n * registry.removeProtocol(protocol.code)\n * ```\n */\n\nimport { Multiaddr as MultiaddrClass, symbol } from './multiaddr.js'\nimport { registry, V } from './registry.ts'\nimport type { ProtocolCodec } from './registry.ts'\n\n/**\n * The protocol registry stores protocol codecs that allow transformation of\n * multiaddr tuples from bytes to string and back again, and also validation of\n * the address values.\n */\nexport interface Registry {\n  /**\n   * Retrieve a protocol definition by it's code or name\n   */\n  getProtocol (key: string | number): ProtocolCodec\n\n  /**\n   * Add a new protocol definition\n   */\n  addProtocol (codec: ProtocolCodec): void\n\n  /**\n   * Remove a protocol definition by it's code\n   */\n  removeProtocol (code: number): void\n}\n\n/**\n * These types can be parsed into a {@link Multiaddr} object\n */\nexport type MultiaddrInput = string | Multiaddr | Uint8Array | null | Component[]\n\n/**\n * A Component is a section of a multiaddr with a name/code, possibly with a\n * value.\n *\n * Component names/codes are defined in the protocol table.\n *\n * @see https://github.com/multiformats/multiaddr/blob/master/protocols.csv\n */\nexport interface Component {\n  /**\n   * The code of the component as defined in the protocol table\n   */\n  code: number\n\n  /**\n   * The name of the component as defined in the protocol table\n   */\n  name: string\n\n  /**\n   * The component value, if one is present\n   */\n  value?: string\n\n  /**\n   * The bytes that make up the component. This will be set if the multiaddr\n   * was parsed from a `Uint8Array`, or if `.bytes` has been accessed on it.\n   */\n  bytes?: Uint8Array\n}\n\nexport interface Multiaddr {\n  bytes: Uint8Array\n\n  /**\n   * Returns Multiaddr as a String\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').toString()\n   * // '/ip4/127.0.0.1/tcp/4001'\n   * ```\n   */\n  toString(): string\n\n  /**\n   * Returns Multiaddr as a JSON encoded object\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * JSON.stringify(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n   * // '/ip4/127.0.0.1/tcp/4001'\n   * ```\n   */\n  toJSON(): string\n\n  /**\n   * Returns the components that make up this Multiaddr\n   *\n   * @example\n   * ```ts\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').getComponents()\n   * // [{ name: 'ip4', code: 4, value: '127.0.0.1' }, { name: 'tcp', code: 6, value: '4001' }]\n   * ```\n   */\n  getComponents(): Component[]\n\n  /**\n   * Encapsulates a Multiaddr in another Multiaddr\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080)\n   *\n   * const mh2 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   *\n   * const mh3 = mh1.encapsulate(mh2)\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001)\n   *\n   * mh3.toString()\n   * // '/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001'\n   * ```\n   *\n   * @param {MultiaddrInput} addr - Multiaddr to add into this Multiaddr\n   */\n  encapsulate(addr: MultiaddrInput): Multiaddr\n\n  /**\n   * Decapsulates a Multiaddr from another Multiaddr\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080)\n   *\n   * const mh2 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   *\n   * const mh3 = mh1.encapsulate(mh2)\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001)\n   *\n   * mh3.decapsulate(mh2).toString()\n   * // '/ip4/8.8.8.8/tcp/1080'\n   * ```\n   *\n   * @param {Multiaddr | string} addr - Multiaddr to remove from this Multiaddr\n   */\n  decapsulate(addr: Multiaddr | string): Multiaddr\n\n  /**\n   * A more reliable version of `decapsulate` if you are targeting a specific\n   * code, such as 421 (the `p2p` protocol code). The last index of the code\n   * will be removed from the `Multiaddr`, and a new instance will be returned.\n   * If the code is not present, the original `Multiaddr` is returned.\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const addr = multiaddr('/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC')\n   * // Multiaddr(/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC)\n   *\n   * addr.decapsulateCode(421).toString()\n   * // '/ip4/0.0.0.0/tcp/8080'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/8080').decapsulateCode(421).toString()\n   * // '/ip4/127.0.0.1/tcp/8080'\n   * ```\n   */\n  decapsulateCode(code: number): Multiaddr\n\n  /**\n   * Checks if two Multiaddrs are the same\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080)\n   *\n   * const mh2 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   *\n   * mh1.equals(mh1)\n   * // true\n   *\n   * mh1.equals(mh2)\n   * // false\n   * ```\n   */\n  equals(addr: { bytes: Uint8Array }): boolean\n}\n\n/**\n * Check if object is a {@link Multiaddr} instance\n *\n * @example\n *\n * ```js\n * import { isMultiaddr, multiaddr } from '@multiformats/multiaddr'\n *\n * isMultiaddr(5)\n * // false\n * isMultiaddr(multiaddr('/ip4/127.0.0.1'))\n * // true\n * ```\n */\nexport function isMultiaddr (value: any): value is Multiaddr {\n  return Boolean(value?.[symbol])\n}\n\n/**\n * A function that takes a {@link MultiaddrInput} and returns a {@link Multiaddr}\n *\n * @example\n * ```js\n * import { multiaddr } from '@libp2p/multiaddr'\n *\n * multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n *\n * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\n */\nexport function multiaddr (addr?: MultiaddrInput): Multiaddr {\n  return new MultiaddrClass(addr)\n}\n\n/**\n * Export all table.csv codes. These are all named exports so can be tree-shaken\n * out by bundlers.\n */\nexport * from './constants.ts'\nexport { registry, V }\nexport type { ProtocolCodec }\n"],
  "mappings": "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",
  "names": ["maxValue", "_a", "_a", "bytes", "validate", "_a"]
}
