{
  "version": 3,
  "sources": ["../../../../../node_modules/netmask/lib/netmask.js", "../../../../../node_modules/p-defer/index.js", "../../../../../node_modules/it-pushable/src/fifo.ts", "../../../../../node_modules/it-pushable/src/index.ts", "../../../../../node_modules/it-queueless-pushable/src/index.ts", "../../../../../node_modules/it-merge/src/index.ts", "../../../../../node_modules/it-pipe/src/index.ts", "../../../../../node_modules/@libp2p/utils/src/errors.ts", "../../../../../node_modules/@libp2p/utils/src/stream-utils.ts", "../../../../../node_modules/@sindresorhus/fnv1a/index.js", "../../../../../node_modules/@libp2p/utils/src/filters/hashes.ts", "../../../../../node_modules/@libp2p/utils/src/filters/bloom-filter.ts", "../../../../../node_modules/@libp2p/utils/src/filters/fingerprint.ts", "../../../../../node_modules/@libp2p/utils/src/filters/utils.ts", "../../../../../node_modules/@libp2p/utils/src/filters/bucket.ts", "../../../../../node_modules/@libp2p/utils/src/filters/cuckoo-filter.ts", "../../../../../node_modules/@libp2p/utils/src/filters/scalable-cuckoo-filter.ts", "../../../../../node_modules/@libp2p/utils/src/multiaddr/get-net-config.ts", "../../../../../node_modules/@chainsafe/netmask/src/util.ts", "../../../../../node_modules/@chainsafe/netmask/src/ip.ts", "../../../../../node_modules/@chainsafe/netmask/src/cidr.ts", "../../../../../node_modules/@chainsafe/netmask/src/ipnet.ts", "../../../../../node_modules/@chainsafe/netmask/src/index.ts", "../../../../../node_modules/@libp2p/utils/src/multiaddr/is-global-unicast.ts", "../../../../../node_modules/@libp2p/utils/src/multiaddr/is-link-local.ts", "../../../../../node_modules/is-loopback-addr/src/index.ts", "../../../../../node_modules/@libp2p/utils/src/multiaddr/is-loopback.ts", "../../../../../node_modules/@libp2p/utils/src/multiaddr/is-network-address.ts", "../../../../../node_modules/@libp2p/utils/src/private-ip.ts", "../../../../../node_modules/@libp2p/utils/src/multiaddr/is-private.ts", "../../../../../node_modules/@libp2p/utils/src/debounce.ts", "../../../../../node_modules/@libp2p/utils/src/queue/recipient.ts", "../../../../../node_modules/@libp2p/utils/src/queue/job.ts", "../../../../../node_modules/@libp2p/utils/src/queue/index.ts", "../../../../../node_modules/@libp2p/utils/src/abstract-message-stream.ts", "../../../../../node_modules/@libp2p/utils/src/abstract-multiaddr-connection.ts", "../../../../../node_modules/@libp2p/utils/src/is-promise.ts", "../../../../../node_modules/@libp2p/utils/src/abstract-stream-muxer.ts", "../../../../../node_modules/@libp2p/utils/src/abstract-stream.ts", "../../../../../node_modules/any-signal/src/index.ts", "../../../../../node_modules/@libp2p/utils/src/moving-average.ts", "../../../../../node_modules/@libp2p/utils/src/adaptive-timeout.ts", "../../../../../node_modules/@libp2p/utils/src/length-prefixed-decoder.ts", "../../../../../node_modules/cborg/lib/is.js", "../../../../../node_modules/cborg/lib/token.js", "../../../../../node_modules/cborg/lib/byte-utils.js", "../../../../../node_modules/cborg/lib/bl.js", "../../../../../node_modules/cborg/lib/common.js", "../../../../../node_modules/cborg/lib/0uint.js", "../../../../../node_modules/cborg/lib/1negint.js", "../../../../../node_modules/cborg/lib/2bytes.js", "../../../../../node_modules/cborg/lib/3string.js", "../../../../../node_modules/cborg/lib/4array.js", "../../../../../node_modules/cborg/lib/5map.js", "../../../../../node_modules/cborg/lib/6tag.js", "../../../../../node_modules/cborg/lib/7float.js", "../../../../../node_modules/cborg/lib/jump.js", "../../../../../node_modules/cborg/lib/encode.js", "../../../../../node_modules/cborg/lib/decode.js", "../../../../../node_modules/it-length-prefixed/src/constants.ts", "../../../../../node_modules/it-length-prefixed/src/errors.ts", "../../../../../node_modules/it-length-prefixed/src/utils.ts", "../../../../../node_modules/it-length-prefixed/src/encode.ts", "../../../../../node_modules/it-length-prefixed/src/decode.ts", "../../../../../node_modules/weald/node_modules/ms/src/index.ts", "../../../../../node_modules/weald/src/common.ts", "../../../../../node_modules/weald/src/browser.ts", "../../../../../node_modules/weald/src/index.ts", "../../../../../node_modules/@libp2p/logger/src/index.ts", "../../../../../node_modules/unlimited-timeout/index.js", "../../../../../node_modules/delay/index.js", "../../../../../node_modules/@libp2p/utils/src/message-queue.ts", "../../../../../node_modules/@libp2p/utils/src/peer-queue.ts", "../../../../../node_modules/@libp2p/utils/src/priority-queue.ts", "../../../../../node_modules/@libp2p/utils/src/rate-limiter.ts", "../../../../../node_modules/@libp2p/utils/src/repeating-task.ts", "../../../../../node_modules/@libp2p/utils/src/tracked-map.ts"],
  "sourcesContent": ["// Generated by CoffeeScript 1.12.7\n(function() {\n  var Netmask, atob, chr, chr0, chrA, chra, ip2long, long2ip;\n\n  long2ip = function(long) {\n    var a, b, c, d;\n    a = (long & (0xff << 24)) >>> 24;\n    b = (long & (0xff << 16)) >>> 16;\n    c = (long & (0xff << 8)) >>> 8;\n    d = long & 0xff;\n    return [a, b, c, d].join('.');\n  };\n\n  ip2long = function(ip) {\n    var b, c, i, j, n, ref;\n    b = [];\n    for (i = j = 0; j <= 3; i = ++j) {\n      if (ip.length === 0) {\n        break;\n      }\n      if (i > 0) {\n        if (ip[0] !== '.') {\n          throw new Error('Invalid IP');\n        }\n        ip = ip.substring(1);\n      }\n      ref = atob(ip), n = ref[0], c = ref[1];\n      ip = ip.substring(c);\n      b.push(n);\n    }\n    if (ip.length !== 0) {\n      throw new Error('Invalid IP');\n    }\n    switch (b.length) {\n      case 1:\n        if (b[0] > 0xFFFFFFFF) {\n          throw new Error('Invalid IP');\n        }\n        return b[0] >>> 0;\n      case 2:\n        if (b[0] > 0xFF || b[1] > 0xFFFFFF) {\n          throw new Error('Invalid IP');\n        }\n        return (b[0] << 24 | b[1]) >>> 0;\n      case 3:\n        if (b[0] > 0xFF || b[1] > 0xFF || b[2] > 0xFFFF) {\n          throw new Error('Invalid IP');\n        }\n        return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;\n      case 4:\n        if (b[0] > 0xFF || b[1] > 0xFF || b[2] > 0xFF || b[3] > 0xFF) {\n          throw new Error('Invalid IP');\n        }\n        return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;\n      default:\n        throw new Error('Invalid IP');\n    }\n  };\n\n  chr = function(b) {\n    return b.charCodeAt(0);\n  };\n\n  chr0 = chr('0');\n\n  chra = chr('a');\n\n  chrA = chr('A');\n\n  atob = function(s) {\n    var base, dmax, i, n, start;\n    n = 0;\n    base = 10;\n    dmax = '9';\n    i = 0;\n    if (s.length > 1 && s[i] === '0') {\n      if (s[i + 1] === 'x' || s[i + 1] === 'X') {\n        i += 2;\n        base = 16;\n      } else if ('0' <= s[i + 1] && s[i + 1] <= '9') {\n        i++;\n        base = 8;\n        dmax = '7';\n      }\n    }\n    start = i;\n    while (i < s.length) {\n      if ('0' <= s[i] && s[i] <= dmax) {\n        n = (n * base + (chr(s[i]) - chr0)) >>> 0;\n      } else if (base === 16) {\n        if ('a' <= s[i] && s[i] <= 'f') {\n          n = (n * base + (10 + chr(s[i]) - chra)) >>> 0;\n        } else if ('A' <= s[i] && s[i] <= 'F') {\n          n = (n * base + (10 + chr(s[i]) - chrA)) >>> 0;\n        } else {\n          break;\n        }\n      } else {\n        break;\n      }\n      if (n > 0xFFFFFFFF) {\n        throw new Error('too large');\n      }\n      i++;\n    }\n    if (i === start) {\n      throw new Error('empty octet');\n    }\n    return [n, i];\n  };\n\n  Netmask = (function() {\n    function Netmask(net, mask) {\n      var error, i, j, ref;\n      if (typeof net !== 'string') {\n        throw new Error(\"Missing `net' parameter\");\n      }\n      if (!mask) {\n        ref = net.split('/', 2), net = ref[0], mask = ref[1];\n      }\n      if (!mask) {\n        mask = 32;\n      }\n      if (typeof mask === 'string' && mask.indexOf('.') > -1) {\n        try {\n          this.maskLong = ip2long(mask);\n        } catch (error1) {\n          error = error1;\n          throw new Error(\"Invalid mask: \" + mask);\n        }\n        for (i = j = 32; j >= 0; i = --j) {\n          if (this.maskLong === (0xffffffff << (32 - i)) >>> 0) {\n            this.bitmask = i;\n            break;\n          }\n        }\n      } else if (mask || mask === 0) {\n        this.bitmask = parseInt(mask, 10);\n        this.maskLong = 0;\n        if (this.bitmask > 0) {\n          this.maskLong = (0xffffffff << (32 - this.bitmask)) >>> 0;\n        }\n      } else {\n        throw new Error(\"Invalid mask: empty\");\n      }\n      try {\n        this.netLong = (ip2long(net) & this.maskLong) >>> 0;\n      } catch (error1) {\n        error = error1;\n        throw new Error(\"Invalid net address: \" + net);\n      }\n      if (!(this.bitmask <= 32)) {\n        throw new Error(\"Invalid mask for ip4: \" + mask);\n      }\n      this.size = Math.pow(2, 32 - this.bitmask);\n      this.base = long2ip(this.netLong);\n      this.mask = long2ip(this.maskLong);\n      this.hostmask = long2ip(~this.maskLong);\n      this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;\n      this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);\n      this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;\n    }\n\n    Netmask.prototype.contains = function(ip) {\n      if (typeof ip === 'string' && (ip.indexOf('/') > 0 || ip.split('.').length !== 4)) {\n        ip = new Netmask(ip);\n      }\n      if (ip instanceof Netmask) {\n        return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);\n      } else {\n        return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;\n      }\n    };\n\n    Netmask.prototype.next = function(count) {\n      if (count == null) {\n        count = 1;\n      }\n      return new Netmask(long2ip(this.netLong + (this.size * count)), this.mask);\n    };\n\n    Netmask.prototype.forEach = function(fn) {\n      var index, lastLong, long;\n      long = ip2long(this.first);\n      lastLong = ip2long(this.last);\n      index = 0;\n      while (long <= lastLong) {\n        fn(long2ip(long), long, index);\n        index++;\n        long++;\n      }\n    };\n\n    Netmask.prototype.toString = function() {\n      return this.base + \"/\" + this.bitmask;\n    };\n\n    return Netmask;\n\n  })();\n\n  exports.ip2long = ip2long;\n\n  exports.long2ip = long2ip;\n\n  exports.Netmask = Netmask;\n\n}).call(this);\n", "export default function pDefer() {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n}\n", "// ported from https://www.npmjs.com/package/fast-fifo\n\nexport interface Next<T> {\n  done?: boolean\n  error?: Error\n  value?: T\n}\n\nclass FixedFIFO<T> {\n  public buffer: Array<Next<T> | undefined>\n  private readonly mask: number\n  private top: number\n  private btm: number\n  public next: FixedFIFO<T> | null\n\n  constructor (hwm: number) {\n    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) {\n      throw new Error('Max size for a FixedFIFO should be a power of two')\n    }\n\n    this.buffer = new Array(hwm)\n    this.mask = hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.next = null\n  }\n\n  push (data: Next<T>): boolean {\n    if (this.buffer[this.top] !== undefined) {\n      return false\n    }\n\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n\n    return true\n  }\n\n  shift (): Next<T> | undefined {\n    const last = this.buffer[this.btm]\n\n    if (last === undefined) {\n      return undefined\n    }\n\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    return last\n  }\n\n  isEmpty (): boolean {\n    return this.buffer[this.btm] === undefined\n  }\n}\n\nexport interface FIFOOptions {\n  /**\n   * When the queue reaches this size, it will be split into head/tail parts\n   */\n  splitLimit?: number\n}\n\nexport class FIFO<T> {\n  public size: number\n  private readonly hwm: number\n  private head: FixedFIFO<T>\n  private tail: FixedFIFO<T>\n\n  constructor (options: FIFOOptions = {}) {\n    this.hwm = options.splitLimit ?? 16\n    this.head = new FixedFIFO<T>(this.hwm)\n    this.tail = this.head\n    this.size = 0\n  }\n\n  calculateSize (obj: any): number {\n    if (obj?.byteLength != null) {\n      return obj.byteLength\n    }\n\n    return 1\n  }\n\n  push (val: Next<T>): void {\n    if (val?.value != null) {\n      this.size += this.calculateSize(val.value)\n    }\n\n    if (!this.head.push(val)) {\n      const prev = this.head\n      this.head = prev.next = new FixedFIFO<T>(2 * this.head.buffer.length)\n      this.head.push(val)\n    }\n  }\n\n  shift (): Next<T> | undefined {\n    let val = this.tail.shift()\n\n    if (val === undefined && (this.tail.next != null)) {\n      const next = this.tail.next\n      this.tail.next = null\n      this.tail = next\n      val = this.tail.shift()\n    }\n\n    if (val?.value != null) {\n      this.size -= this.calculateSize(val.value)\n    }\n\n    return val\n  }\n\n  isEmpty (): boolean {\n    return this.head.isEmpty()\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\n\nimport deferred from 'p-defer'\nimport { FIFO, type Next } from './fifo.js'\n\nexport class AbortError extends Error {\n  type: string\n  code: string\n\n  constructor (message?: string, code?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\ninterface BasePushable<T> {\n  /**\n   * End the iterable after all values in the buffer (if any) have been yielded. If an\n   * error is passed the buffer is cleared immediately and the next iteration will\n   * throw the passed error\n   */\n  end(err?: Error): this\n\n  /**\n   * Push a value into the iterable. Values are yielded from the iterable in the order\n   * they are pushed. Values not yet consumed from the iterable are buffered.\n   */\n  push(value: T): this\n\n  /**\n   * Returns a promise that resolves when the underlying queue becomes empty (e.g.\n   * this.readableLength === 0).\n   *\n   * If an AbortSignal is passed as an option and that signal aborts, it only\n   * causes the returned promise to reject - it does not end the pushable.\n   */\n  onEmpty(options?: AbortOptions): Promise<void>\n\n  /**\n   * This property contains the number of bytes (or objects) in the queue ready to be read.\n   *\n   * If `objectMode` is true, this is the number of objects in the queue, if false it's the\n   * total number of bytes in the queue.\n   */\n  readableLength: number\n}\n\n/**\n * An iterable that you can push values into.\n */\nexport interface Pushable<T, R = void, N = unknown> extends AsyncGenerator<T, R, N>, BasePushable<T> {}\n\n/**\n * Similar to `pushable`, except it yields multiple buffered chunks at a time. All values yielded from the iterable will be arrays.\n */\nexport interface PushableV<T, R = void, N = unknown> extends AsyncGenerator<T[], R, N>, BasePushable<T> {}\n\nexport interface Options {\n  /**\n   * A boolean value that means non-`Uint8Array`s will be passed to `.push`, default: `false`\n   */\n  objectMode?: boolean\n\n  /**\n   * A function called after *all* values have been yielded from the iterator (including\n   * buffered values). In the case when the iterator is ended with an error it will be\n   * passed the error as a parameter.\n   */\n  onEnd?(err?: Error): void\n}\n\nexport interface DoneResult { done: true }\nexport interface ValueResult<T> { done: false, value: T }\nexport type NextResult<T> = ValueResult<T> | DoneResult\n\ninterface getNext<T, V = T> { (buffer: FIFO<T>): NextResult<V> }\n\nexport interface ObjectPushableOptions extends Options {\n  objectMode: true\n}\n\nexport interface BytePushableOptions extends Options {\n  objectMode?: false\n}\n\n/**\n * Create a new async iterable. The values yielded from calls to `.next()`\n * or when used in a `for await of`loop are \"pushed\" into the iterable.\n * Returns an async iterable object with additional methods.\n */\nexport function pushable<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): Pushable<T>\nexport function pushable<T> (options: ObjectPushableOptions): Pushable<T>\nexport function pushable<T> (options: Options = {}): Pushable<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T> => {\n    const next: Next<T> | undefined = buffer.shift()\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    if (next.error != null) {\n      throw next.error\n    }\n\n    return {\n      done: next.done === true,\n      // @ts-expect-error if done is false, value will be present\n      value: next.value\n    }\n  }\n\n  return _pushable<T, T, Pushable<T>>(getNext, options)\n}\n\nexport function pushableV<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): PushableV<T>\nexport function pushableV<T> (options: ObjectPushableOptions): PushableV<T>\nexport function pushableV<T> (options: Options = {}): PushableV<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T[]> => {\n    let next: Next<T> | undefined\n    const values: T[] = []\n\n    while (!buffer.isEmpty()) {\n      next = buffer.shift()\n\n      if (next == null) {\n        break\n      }\n\n      if (next.error != null) {\n        throw next.error\n      }\n\n      if (next.done === false) {\n        // @ts-expect-error if done is false value should be pushed\n        values.push(next.value)\n      }\n    }\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    return {\n      done: next.done === true,\n      value: values\n    }\n  }\n\n  return _pushable<T, T[], PushableV<T>>(getNext, options)\n}\n\nfunction _pushable<PushType, ValueType, ReturnType> (getNext: getNext<PushType, ValueType>, options?: Options): ReturnType {\n  options = options ?? {}\n  let onEnd = options.onEnd\n  let buffer = new FIFO<PushType>()\n  let pushable: any\n  let onNext: ((next: Next<PushType>) => ReturnType) | null\n  let ended: boolean\n  let drain = deferred()\n\n  const waitNext = async (): Promise<NextResult<ValueType>> => {\n    try {\n      if (!buffer.isEmpty()) {\n        return getNext(buffer)\n      }\n\n      if (ended) {\n        return { done: true }\n      }\n\n      return await new Promise<NextResult<ValueType>>((resolve, reject) => {\n        onNext = (next: Next<PushType>) => {\n          onNext = null\n          buffer.push(next)\n\n          try {\n            resolve(getNext(buffer))\n          } catch (err) {\n            reject(err)\n          }\n\n          return pushable\n        }\n      })\n    } finally {\n      if (buffer.isEmpty()) {\n        // settle promise in the microtask queue to give consumers a chance to\n        // await after calling .push\n        queueMicrotask(() => {\n          drain.resolve()\n          drain = deferred()\n        })\n      }\n    }\n  }\n\n  const bufferNext = (next: Next<PushType>): ReturnType => {\n    if (onNext != null) {\n      return onNext(next)\n    }\n\n    buffer.push(next)\n    return pushable\n  }\n\n  const bufferError = (err: Error): ReturnType => {\n    buffer = new FIFO()\n\n    if (onNext != null) {\n      return onNext({ error: err })\n    }\n\n    buffer.push({ error: err })\n    return pushable\n  }\n\n  const push = (value: PushType): ReturnType => {\n    if (ended) {\n      return pushable\n    }\n\n    // @ts-expect-error `byteLength` is not declared on PushType\n    if (options?.objectMode !== true && value?.byteLength == null) {\n      throw new Error('objectMode was not true but tried to push non-Uint8Array value')\n    }\n\n    return bufferNext({ done: false, value })\n  }\n  const end = (err?: Error): ReturnType => {\n    if (ended) return pushable\n    ended = true\n\n    return (err != null) ? bufferError(err) : bufferNext({ done: true })\n  }\n  const _return = (): DoneResult => {\n    buffer = new FIFO()\n    end()\n\n    return { done: true }\n  }\n  const _throw = (err: Error): DoneResult => {\n    end(err)\n\n    return { done: true }\n  }\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next: waitNext,\n    return: _return,\n    throw: _throw,\n    push,\n    end,\n    get readableLength (): number {\n      return buffer.size\n    },\n    onEmpty: async (options?: AbortOptions) => {\n      const signal = options?.signal\n      signal?.throwIfAborted()\n\n      if (buffer.isEmpty()) {\n        return\n      }\n\n      let cancel: Promise<void> | undefined\n      let listener: (() => void) | undefined\n\n      if (signal != null) {\n        cancel = new Promise((resolve, reject) => {\n          listener = () => {\n            reject(new AbortError())\n          }\n\n          signal.addEventListener('abort', listener)\n        })\n      }\n\n      try {\n        await Promise.race([\n          drain.promise,\n          cancel\n        ])\n      } finally {\n        if (listener != null && signal != null) {\n          signal?.removeEventListener('abort', listener)\n        }\n      }\n    }\n  }\n\n  if (onEnd == null) {\n    return pushable\n  }\n\n  const _pushable = pushable\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next () {\n      return _pushable.next()\n    },\n    throw (err: Error) {\n      _pushable.throw(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    return () {\n      _pushable.return()\n\n      if (onEnd != null) {\n        onEnd()\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    push,\n    end (err: Error) {\n      _pushable.end(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return pushable\n    },\n    get readableLength () {\n      return _pushable.readableLength\n    },\n    onEmpty: (opts?: AbortOptions) => {\n      return _pushable.onEmpty(opts)\n    }\n  }\n\n  return pushable\n}\n", "/**\n * @packageDocumentation\n *\n * A pushable async generator that waits until the current value is consumed\n * before allowing a new value to be pushed.\n *\n * Useful for when you don't want to keep memory usage under control and/or\n * allow a downstream consumer to dictate how fast data flows through a pipe,\n * but you want to be able to apply a transform to that data.\n *\n * @example\n *\n * ```typescript\n * import { queuelessPushable } from 'it-queueless-pushable'\n *\n * const pushable = queuelessPushable<string>()\n *\n * // run asynchronously\n * Promise.resolve().then(async () => {\n *   // push a value - the returned promise will not resolve until the value is\n *   // read from the pushable\n *   await pushable.push('hello')\n * })\n *\n * // read a value\n * const result = await pushable.next()\n * console.info(result) // { done: false, value: 'hello' }\n * ```\n */\n\nimport deferred from 'p-defer'\nimport { raceSignal } from 'race-signal'\nimport type { AbortOptions } from 'abort-error'\nimport type { RaceSignalOptions } from 'race-signal'\n\nexport interface Pushable<T> extends AsyncGenerator<T, void, unknown> {\n  /**\n   * End the iterable after all values in the buffer (if any) have been yielded. If an\n   * error is passed the buffer is cleared immediately and the next iteration will\n   * throw the passed error\n   */\n  end(err?: Error, options?: AbortOptions & RaceSignalOptions): Promise<void>\n\n  /**\n   * Push a value into the iterable. Values are yielded from the iterable in the order\n   * they are pushed. Values not yet consumed from the iterable are buffered.\n   */\n  push(value: T, options?: AbortOptions & RaceSignalOptions): Promise<void>\n}\n\nclass QueuelessPushable <T> implements Pushable<T> {\n  private readNext: PromiseWithResolvers<void>\n  private haveNext: PromiseWithResolvers<void>\n  private ended: boolean\n  private nextResult: IteratorResult<T> | undefined\n  private error?: Error\n\n  constructor () {\n    this.ended = false\n\n    this.readNext = deferred()\n    this.haveNext = deferred()\n  }\n\n  [Symbol.asyncIterator] (): AsyncGenerator<T, void, unknown> {\n    return this\n  }\n\n  async next (): Promise<IteratorResult<T, void>> {\n    if (this.nextResult == null) {\n      // wait for the supplier to push a value\n      await this.haveNext.promise\n    }\n\n    if (this.nextResult == null) {\n      throw new Error('HaveNext promise resolved but nextResult was undefined')\n    }\n\n    const nextResult = this.nextResult\n    this.nextResult = undefined\n\n    // signal to the supplier that we read the value\n    this.readNext.resolve()\n    this.readNext = deferred()\n\n    return nextResult\n  }\n\n  async throw (err?: Error): Promise<IteratorReturnResult<undefined>> {\n    this.ended = true\n    this.error = err\n\n    if (err != null) {\n      // this can cause unhandled promise rejections if nothing is awaiting the\n      // next value so attach a dummy catch listener to the promise\n      this.haveNext.promise.catch(() => {})\n      this.haveNext.reject(err)\n    }\n\n    const result: IteratorReturnResult<undefined> = {\n      done: true,\n      value: undefined\n    }\n\n    return result\n  }\n\n  async return (): Promise<IteratorResult<T>> {\n    const result: IteratorReturnResult<undefined> = {\n      done: true,\n      value: undefined\n    }\n\n    this.ended = true\n    this.nextResult = result\n\n    // let the consumer know we have a new value\n    this.haveNext.resolve()\n\n    return result\n  }\n\n  async push (value: T, options?: AbortOptions & RaceSignalOptions): Promise<void> {\n    await this._push(value, options)\n  }\n\n  async end (err?: Error, options?: AbortOptions & RaceSignalOptions): Promise<void> {\n    if (err != null) {\n      await this.throw(err)\n    } else {\n      // abortable return\n      await this._push(undefined, options)\n    }\n  }\n\n  private async _push (value?: T, options?: AbortOptions & RaceSignalOptions): Promise<void> {\n    if (value != null && this.ended) {\n      throw this.error ?? new Error('Cannot push value onto an ended pushable')\n    }\n\n    // wait for all values to be read\n    while (this.nextResult != null) {\n      await this.readNext.promise\n    }\n\n    if (value != null) {\n      this.nextResult = { done: false, value }\n    } else {\n      this.ended = true\n      this.nextResult = { done: true, value: undefined }\n    }\n\n    // let the consumer know we have a new value\n    this.haveNext.resolve()\n    this.haveNext = deferred()\n\n    // wait for the consumer to have finished processing the value and requested\n    // the next one or for the passed signal to abort the waiting\n    await raceSignal(\n      this.readNext.promise,\n      options?.signal,\n      options\n    )\n  }\n}\n\nexport function queuelessPushable <T> (): Pushable<T> {\n  return new QueuelessPushable<T>()\n}\n", "/**\n * @packageDocumentation\n *\n * Merge several (async)iterables into one, yield values as they arrive.\n *\n * Nb. sources are iterated over in parallel so the order of emitted items is not guaranteed.\n *\n * @example\n *\n * ```javascript\n * import merge from 'it-merge'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values1 = [0, 1, 2, 3, 4]\n * const values2 = [5, 6, 7, 8, 9]\n *\n * const arr = all(merge(values1, values2))\n *\n * console.info(arr) // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import merge from 'it-merge'\n * import all from 'it-all'\n *\n * // This can also be an iterator, async iterator, generator, etc\n * const values1 = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n * const values2 = async function * () {\n *   yield * [5, 6, 7, 8, 9]\n * }\n *\n * const arr = await all(merge(values1(), values2()))\n *\n * console.info(arr) // 0, 1, 5, 6, 2, 3, 4, 7, 8, 9  <- nb. order is not guaranteed\n * ```\n */\n\nimport { queuelessPushable } from 'it-queueless-pushable'\nimport type { Pushable } from 'it-queueless-pushable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\nasync function addAllToPushable <T> (sources: Array<AsyncIterable<T> | Iterable<T>>, output: Pushable<T>, signal: AbortSignal): Promise<void> {\n  try {\n    await Promise.all(\n      sources.map(async (source) => {\n        for await (const item of source) {\n          await output.push(item, {\n            signal\n          })\n          signal.throwIfAborted()\n        }\n      })\n    )\n\n    await output.end(undefined, {\n      signal\n    })\n  } catch (err: any) {\n    await output.end(err, {\n      signal\n    })\n      .catch(() => {})\n  }\n}\n\nasync function * mergeSources <T> (sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined> {\n  const controller = new AbortController()\n  const output = queuelessPushable<T>()\n\n  addAllToPushable(sources, output, controller.signal)\n    .catch(() => {})\n\n  try {\n    yield * output\n  } finally {\n    controller.abort()\n  }\n}\n\nfunction * mergeSyncSources <T> (syncSources: Array<Iterable<T>>): Generator<T, void, undefined> {\n  for (const source of syncSources) {\n    yield * source\n  }\n}\n\n/**\n * Treat one or more iterables as a single iterable.\n *\n * Nb. sources are iterated over in parallel so the\n * order of emitted items is not guaranteed.\n */\nfunction merge <T> (...sources: Array<Iterable<T>>): Generator<T, void, undefined>\nfunction merge <T> (...sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined>\nfunction merge <T> (...sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined> | Generator<T, void, undefined> {\n  const syncSources: Array<Iterable<T>> = []\n\n  for (const source of sources) {\n    if (!isAsyncIterable(source)) {\n      syncSources.push(source)\n    }\n  }\n\n  if (syncSources.length === sources.length) {\n    // all sources are synchronous\n    return mergeSyncSources(syncSources)\n  }\n\n  return mergeSources(sources)\n}\n\nexport default merge\n", "import { pushable } from 'it-pushable'\nimport merge from 'it-merge'\nimport type { Duplex, Transform, Sink } from 'it-stream-types'\n\ninterface SourceFn<A = any> { (): A }\n\ntype PipeSource<A = any> =\n  Iterable<A> |\n  AsyncIterable<A> |\n  SourceFn<A> |\n  Duplex<A, any, any>\n\ntype PipeTransform<A = any, B = any> =\n  Transform<A, B> |\n  Duplex<B, A>\n\ntype PipeSink<A = any, B = any> =\n  Sink<A, B> |\n  Duplex<any, A, B>\n\ntype PipeOutput<A> =\n  A extends Sink<any> ? ReturnType<A> :\n    A extends Duplex<any, any, any> ? ReturnType<A['sink']> :\n      never\n\n// single item pipe output includes pipe source types\ntype SingleItemPipeOutput<A> =\n  A extends Iterable<any> ? A :\n    A extends AsyncIterable<any> ? A :\n      A extends SourceFn ? ReturnType<A> :\n        A extends Duplex<any, any, any> ? A['source'] :\n          PipeOutput<A>\n\ntype PipeFnInput<A> =\n  A extends Iterable<any> ? A :\n    A extends AsyncIterable<any> ? A :\n      A extends SourceFn ? ReturnType<A> :\n        A extends Transform<any, any> ? ReturnType<A> :\n          A extends Duplex<any, any, any> ? A['source'] :\n            never\n\n// one item, just a pass-through\nexport function pipe<\n  A extends PipeSource\n> (\n  source: A\n): SingleItemPipeOutput<A>\n\n// two items, source to sink\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeSink<PipeFnInput<A>>\n> (\n  source: A,\n  sink: B\n): PipeOutput<B>\n\n// three items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeSink<PipeFnInput<B>>\n> (\n  source: A,\n  transform1: B,\n  sink: C\n): PipeOutput<C>\n\n// many items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeSink<PipeFnInput<C>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  sink: D\n): PipeOutput<D>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeSink<PipeFnInput<D>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  sink: E\n): PipeOutput<E>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeSink<PipeFnInput<E>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  sink: F\n): PipeOutput<F>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeSink<PipeFnInput<F>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  sink: G\n): PipeOutput<G>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeSink<PipeFnInput<G>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  sink: H\n): PipeOutput<H>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeSink<PipeFnInput<H>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  sink: I\n): PipeOutput<I>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeSink<PipeFnInput<I>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  sink: J\n): PipeOutput<J>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeTransform<PipeFnInput<I>>,\n  K extends PipeSink<PipeFnInput<J>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  transform9: J,\n  sink: K\n): PipeOutput<K>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeTransform<PipeFnInput<I>>,\n  K extends PipeTransform<PipeFnInput<J>>,\n  L extends PipeSink<PipeFnInput<K>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  transform9: J,\n  transform10: K,\n  sink: L\n): PipeOutput<L>\n\nexport function pipe (first: any, ...rest: any[]): any {\n  if (first == null) {\n    throw new Error('Empty pipeline')\n  }\n\n  // Duplex at start: wrap in function and return duplex source\n  if (isDuplex(first)) {\n    const duplex = first\n    first = () => duplex.source\n  // Iterable at start: wrap in function\n  } else if (isIterable(first) || isAsyncIterable(first)) {\n    const source = first\n    first = () => source\n  }\n\n  const fns = [first, ...rest]\n\n  if (fns.length > 1) {\n    // Duplex at end: use duplex sink\n    if (isDuplex(fns[fns.length - 1])) {\n      fns[fns.length - 1] = fns[fns.length - 1].sink\n    }\n  }\n\n  if (fns.length > 2) {\n    // Duplex in the middle, consume source with duplex sink and return duplex source\n    for (let i = 1; i < fns.length - 1; i++) {\n      if (isDuplex(fns[i])) {\n        fns[i] = duplexPipelineFn(fns[i])\n      }\n    }\n  }\n\n  return rawPipe(...fns)\n}\n\nexport const rawPipe = (...fns: any): any => {\n  let res\n  while (fns.length > 0) {\n    res = fns.shift()(res)\n  }\n  return res\n}\n\nconst isAsyncIterable = (obj: any): obj is AsyncIterable<unknown> => {\n  return obj?.[Symbol.asyncIterator] != null\n}\n\nconst isIterable = (obj: any): obj is Iterable<unknown> => {\n  return obj?.[Symbol.iterator] != null\n}\n\nconst isDuplex = (obj: any): obj is Duplex => {\n  if (obj == null) {\n    return false\n  }\n\n  return obj.sink != null && obj.source != null\n}\n\nconst duplexPipelineFn = (duplex: Duplex<any, any, any>) => {\n  return (source: any) => {\n    const p = duplex.sink(source)\n\n    if (p?.then != null) {\n      const stream = pushable<any>({\n        objectMode: true\n      })\n      p.then(() => {\n        stream.end()\n      }, (err: Error) => {\n        stream.end(err)\n      })\n\n      let sourceWrap: () => Iterable<any> | AsyncIterable<any>\n      const source = duplex.source\n\n      if (isAsyncIterable(source)) {\n        sourceWrap = async function * () {\n          yield * source\n          stream.end()\n        }\n      } else if (isIterable(source)) {\n        sourceWrap = function * () {\n          yield * source\n          stream.end()\n        }\n      } else {\n        throw new Error('Unknown duplex source type - must be Iterable or AsyncIterable')\n      }\n\n      return merge(stream, sourceWrap())\n    }\n\n    return duplex.source\n  }\n}\n", "import type { RateLimiterResult } from './rate-limiter.js'\n\n/**\n * A rate limit was hit\n */\nexport class RateLimitError extends Error {\n  remainingPoints: number\n  msBeforeNext: number\n  consumedPoints: number\n  isFirstInDuration: boolean\n\n  constructor (message = 'Rate limit exceeded', props: RateLimiterResult) {\n    super(message)\n    this.name = 'RateLimitError'\n    this.remainingPoints = props.remainingPoints\n    this.msBeforeNext = props.msBeforeNext\n    this.consumedPoints = props.consumedPoints\n    this.isFirstInDuration = props.isFirstInDuration\n  }\n}\n\nexport class QueueFullError extends Error {\n  static name = 'QueueFullError'\n\n  constructor (message: string = 'The queue was full') {\n    super(message)\n    this.name = 'QueueFullError'\n  }\n}\n\nexport class UnexpectedEOFError extends Error {\n  static name = 'UnexpectedEOFError'\n  name = 'UnexpectedEOFError'\n}\n\nexport class MaxEarlyStreamsError extends Error {\n  static name = 'MaxEarlyStreamsError'\n  name = 'MaxEarlyStreamsError'\n}\n\nexport class StreamClosedError extends Error {\n  static name = 'StreamClosedError'\n  name = 'StreamClosedError'\n}\n", "import { StreamMessageEvent, StreamCloseEvent, InvalidParametersError } from '@libp2p/interface'\nimport { pipe as itPipe } from 'it-pipe'\nimport { pushable } from 'it-pushable'\nimport { pEvent } from 'p-event'\nimport { raceSignal } from 'race-signal'\nimport * as varint from 'uint8-varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { UnexpectedEOFError } from './errors.js'\nimport type { MessageStream, MultiaddrConnection, Stream, AbortOptions } from '@libp2p/interface'\nimport type { Duplex, Source, Transform, Sink } from 'it-stream-types'\n\nconst DEFAULT_MAX_BUFFER_SIZE = 4_194_304\n\nexport class UnwrappedError extends Error {\n  static name = 'UnwrappedError'\n  name = 'UnwrappedError'\n}\n\n/**\n * The reported length of the next data message was not a positive integer\n */\nexport class InvalidMessageLengthError extends Error {\n  name = 'InvalidMessageLengthError'\n  code = 'ERR_INVALID_MSG_LENGTH'\n}\n\n/**\n * The reported length of the next data message was larger than the configured\n * max allowable value\n */\nexport class InvalidDataLengthError extends Error {\n  name = 'InvalidDataLengthError'\n  code = 'ERR_MSG_DATA_TOO_LONG'\n}\n\n/**\n * The varint used to specify the length of the next data message contained more\n * bytes than the configured max allowable value\n */\nexport class InvalidDataLengthLengthError extends Error {\n  name = 'InvalidDataLengthLengthError'\n  code = 'ERR_MSG_LENGTH_TOO_LONG'\n}\n\nexport interface ByteStreamOpts {\n  /**\n   * Incoming bytes are buffered until read, this setting limits how many bytes\n   * will be buffered.\n   *\n   * @default 4_194_304\n   */\n  maxBufferSize?: number\n}\n\nexport interface ReadBytesOptions extends AbortOptions {\n  /**\n   * If specified, read this number of bytes from the stream\n   */\n  bytes: number\n}\n\nexport interface ByteStream<S extends MessageStream> {\n  /**\n   * Read bytes from the stream.\n   *\n   * If a required number of bytes is passed as an option, this will wait for\n   * the underlying stream to supply that number of bytes, throwing an\n   * `UnexpectedEOFError` if the stream closes before this happens.\n   *\n   * If no required number of bytes is passed, this will return `null` if the\n   * underlying stream closes before supplying any bytes.\n   */\n  read(options: ReadBytesOptions): Promise<Uint8ArrayList>\n  read(options?: AbortOptions): Promise<Uint8ArrayList | null>\n\n  /**\n   * Write the passed bytes to the stream\n   */\n  write(data: Uint8Array | Uint8ArrayList, options?: AbortOptions): Promise<void>\n\n  /**\n   * After calling this method the stream can no longer be used. Any unread data\n   * will be emitted as a message event during the microtask queue of the\n   * current event loop tick.\n   */\n  unwrap(): S\n}\n\nfunction isStream (obj?: any): obj is Stream {\n  return typeof obj?.closeRead === 'function'\n}\n\nfunction isMultiaddrConnection (obj?: any): obj is MultiaddrConnection {\n  return typeof obj?.close === 'function'\n}\n\nfunction isEOF (obj?: any): boolean {\n  if (isStream(obj)) {\n    return obj.remoteWriteStatus !== 'writable' && obj.readBufferLength === 0\n  }\n\n  if (isMultiaddrConnection(obj)) {\n    return obj.status !== 'open'\n  }\n\n  return false\n}\n\ntype ByteStreamReadable = Pick<Stream & MultiaddrConnection, 'addEventListener' | 'removeEventListener' | 'send' | 'push' | 'log'>\n\nfunction isValid (obj?: any): obj is ByteStreamReadable {\n  return obj?.addEventListener != null && obj?.removeEventListener != null && obj?.send != null && obj?.push != null && obj?.log != null\n}\n\nexport function byteStream <T extends MessageStream> (stream: T, opts?: ByteStreamOpts): ByteStream<T> {\n  const maxBufferSize = opts?.maxBufferSize ?? DEFAULT_MAX_BUFFER_SIZE\n  const readBuffer = new Uint8ArrayList()\n\n  let hasBytes: PromiseWithResolvers<void> | undefined\n  let unwrapped = false\n\n  if (!isValid(stream)) {\n    throw new InvalidParametersError('Argument should be a Stream or a Multiaddr')\n  }\n\n  const byteStreamOnMessageListener = (evt: StreamMessageEvent): void => {\n    readBuffer.append(evt.data)\n\n    if (readBuffer.byteLength > maxBufferSize) {\n      const readBufferSize = readBuffer.byteLength\n      readBuffer.consume(readBuffer.byteLength)\n      hasBytes?.reject(new Error(`Read buffer overflow - ${readBufferSize} > ${maxBufferSize}`))\n    }\n\n    hasBytes?.resolve()\n  }\n  stream.addEventListener('message', byteStreamOnMessageListener)\n\n  const byteStreamOnCloseListener = (evt: StreamCloseEvent): void => {\n    if (evt.error != null) {\n      hasBytes?.reject(evt.error)\n    } else {\n      hasBytes?.resolve()\n    }\n  }\n  stream.addEventListener('close', byteStreamOnCloseListener)\n\n  const byteStreamOnRemoteCloseWrite = (): void => {\n    hasBytes?.resolve()\n  }\n  stream.addEventListener('remoteCloseWrite', byteStreamOnRemoteCloseWrite)\n\n  const byteStream: ByteStream<T> = {\n    readBuffer,\n\n    // @ts-expect-error options type prevents type inference\n    async read (options?: ReadBytesOptions) {\n      if (unwrapped === true) {\n        throw new UnwrappedError('Stream was unwrapped')\n      }\n\n      if (isEOF(stream)) {\n        if (options?.bytes == null) {\n          return null\n        }\n\n        if (readBuffer.byteLength < options.bytes) {\n          stream.log.error('closed after reading %d/%d bytes', readBuffer.byteLength, options.bytes)\n          throw new UnexpectedEOFError(`Unexpected EOF - stream closed after reading ${readBuffer.byteLength}/${options.bytes} bytes`)\n        }\n      }\n\n      const bytesToRead = options?.bytes ?? 1\n      hasBytes = Promise.withResolvers<void>()\n\n      while (true) {\n        if (readBuffer.byteLength >= bytesToRead) {\n          // if we are about to exit the loop this promise will not be awaited\n          // so resolve it to prevent and unhandled promise rejections that may\n          // occur\n          hasBytes.resolve()\n\n          break\n        }\n\n        await raceSignal(hasBytes.promise, options?.signal)\n\n        if (isEOF(stream)) {\n          if (readBuffer.byteLength === 0 && options?.bytes == null) {\n            return null\n          }\n\n          break\n        }\n\n        hasBytes = Promise.withResolvers<void>()\n      }\n\n      const toRead = options?.bytes ?? readBuffer.byteLength\n\n      if (readBuffer.byteLength < toRead) {\n        if (isEOF(stream)) {\n          stream.log.error('closed while reading %d/%d bytes', readBuffer.byteLength, toRead)\n          throw new UnexpectedEOFError(`Unexpected EOF - stream closed while reading ${readBuffer.byteLength}/${toRead} bytes`)\n        }\n\n        return byteStream.read(options)\n      }\n\n      const output = readBuffer.sublist(0, toRead)\n      readBuffer.consume(toRead)\n\n      return output\n    },\n    async write (data: Uint8Array | Uint8ArrayList, options?: AbortOptions) {\n      if (unwrapped === true) {\n        throw new UnwrappedError('Stream was unwrapped')\n      }\n\n      if (!stream.send(data)) {\n        await pEvent(stream, 'drain', {\n          signal: options?.signal,\n          rejectionEvents: ['close']\n        })\n      }\n    },\n    unwrap () {\n      // already unwrapped, just return the original stream\n      if (unwrapped) {\n        return stream\n      }\n\n      // only unwrap once\n      unwrapped = true\n      stream.removeEventListener('message', byteStreamOnMessageListener)\n      stream.removeEventListener('close', byteStreamOnCloseListener)\n      stream.removeEventListener('remoteCloseWrite', byteStreamOnRemoteCloseWrite)\n\n      // emit any unread data\n      if (readBuffer.byteLength > 0) {\n        stream.log('stream unwrapped with %d unread bytes', readBuffer.byteLength)\n        stream.push(readBuffer)\n      }\n\n      return stream\n    }\n  }\n\n  return byteStream\n}\n\nexport interface LengthPrefixedStream<S extends MessageStream = MessageStream> {\n  /**\n   * Read the next length-prefixed number of bytes from the stream\n   */\n  read(options?: AbortOptions): Promise<Uint8ArrayList>\n\n  /**\n   * Write the passed bytes to the stream prefixed by their length\n   */\n  write(data: Uint8Array | Uint8ArrayList, options?: AbortOptions): Promise<void>\n\n  /**\n   * Write passed list of bytes, prefix by their individual lengths to the stream as a single write\n   */\n  writeV(input: Array<Uint8Array | Uint8ArrayList>, options?: AbortOptions): Promise<void>\n\n  /**\n   * Returns the underlying stream\n   */\n  unwrap(): S\n}\n\nexport interface LengthPrefixedStreamOpts extends ByteStreamOpts {\n  lengthEncoder (value: number): Uint8ArrayList | Uint8Array\n  lengthDecoder (data: Uint8ArrayList): number\n  maxLengthLength: number\n  maxDataLength: number\n}\n\nexport function lpStream <T extends MessageStream> (stream: T, opts: Partial<LengthPrefixedStreamOpts> = {}): LengthPrefixedStream<T> {\n  const bytes = byteStream(stream, opts)\n\n  if (opts.maxDataLength != null && opts.maxLengthLength == null) {\n    // if max data length is set but max length length is not, calculate the\n    // max length length needed to encode max data length\n    opts.maxLengthLength = varint.encodingLength(opts.maxDataLength)\n  }\n\n  const decodeLength = opts?.lengthDecoder ?? varint.decode\n  const encodeLength = opts?.lengthEncoder ?? varint.encode\n\n  const lpStream: LengthPrefixedStream<any> = {\n    async read (options?: AbortOptions) {\n      let dataLength: number = -1\n      const lengthBuffer = new Uint8ArrayList()\n\n      while (true) {\n        // read one byte at a time until we can decode a varint\n        const buf = await bytes.read({\n          ...options,\n          bytes: 1\n        })\n\n        // the underlying resource closed gracefully\n        if (buf == null) {\n          break\n        }\n\n        // append byte and try to decode\n        lengthBuffer.append(buf)\n\n        try {\n          dataLength = decodeLength(lengthBuffer)\n        } catch (err) {\n          if (err instanceof RangeError) {\n            continue\n          }\n\n          throw err\n        }\n\n        if (dataLength < 0) {\n          throw new InvalidMessageLengthError('Invalid message length')\n        }\n\n        if (opts?.maxLengthLength != null && lengthBuffer.byteLength > opts.maxLengthLength) {\n          throw new InvalidDataLengthLengthError(`Message length length too long - ${lengthBuffer.byteLength} > ${opts.maxLengthLength}`)\n        }\n\n        if (dataLength > -1) {\n          break\n        }\n      }\n\n      if (opts?.maxDataLength != null && dataLength > opts.maxDataLength) {\n        throw new InvalidDataLengthError(`Message length too long - ${dataLength} > ${opts.maxDataLength}`)\n      }\n\n      const buf = await bytes.read({\n        ...options,\n        bytes: dataLength\n      })\n\n      if (buf == null) {\n        stream.log.error('tried to read %d bytes but the stream closed', dataLength)\n        throw new UnexpectedEOFError(`Unexpected EOF - tried to read ${dataLength} bytes but the stream closed`)\n      }\n\n      if (buf.byteLength !== dataLength) {\n        stream.log.error('read %d/%d bytes before the stream closed', buf.byteLength, dataLength)\n        throw new UnexpectedEOFError(`Unexpected EOF - read ${buf.byteLength}/${dataLength} bytes before the stream closed`)\n      }\n\n      return buf\n    },\n    async write (data, options?: AbortOptions) {\n      // encode, write\n      await bytes.write(new Uint8ArrayList(encodeLength(data.byteLength), data), options)\n    },\n    async writeV (data, options?: AbortOptions) {\n      const list = new Uint8ArrayList(\n        ...data.flatMap(buf => ([encodeLength(buf.byteLength), buf]))\n      )\n\n      // encode, write\n      await bytes.write(list, options)\n    },\n    unwrap () {\n      return bytes.unwrap()\n    }\n  }\n\n  return lpStream\n}\n\n/**\n * A protobuf decoder - takes a byte array and returns an object\n */\nexport interface ProtobufDecoder<T> {\n  (data: Uint8Array | Uint8ArrayList): T\n}\n\n/**\n * A protobuf encoder - takes an object and returns a byte array\n */\nexport interface ProtobufEncoder<T> {\n  (data: T): Uint8Array\n}\n\n/**\n * Convenience methods for working with protobuf streams\n */\nexport interface ProtobufStream<S extends MessageStream = MessageStream> {\n  /**\n   * Read the next length-prefixed byte array from the stream and decode it as the passed protobuf format\n   */\n  read<T>(proto: { decode: ProtobufDecoder<T> }, options?: AbortOptions): Promise<T>\n\n  /**\n   * Encode the passed object as a protobuf message and write it's length-prefixed bytes to the stream\n   */\n  write<T>(data: T, proto: { encode: ProtobufEncoder<T> }, options?: AbortOptions): Promise<void>\n\n  /**\n   * Encode the passed objects as protobuf messages and write their length-prefixed bytes to the stream as a single write\n   */\n  writeV<T>(input: T[], proto: { encode: ProtobufEncoder<T> }, options?: AbortOptions): Promise<void>\n\n  /**\n   * Returns an object with read/write methods for operating on one specific type of protobuf message\n   */\n  pb<T>(proto: { encode: ProtobufEncoder<T>, decode: ProtobufDecoder<T> }): ProtobufMessageStream<T, S>\n\n  /**\n   * Returns the underlying stream\n   */\n  unwrap(): S\n}\n\n/**\n * A message reader/writer that only uses one type of message\n */\nexport interface ProtobufMessageStream <T, S extends MessageStream = MessageStream> {\n  /**\n   * Read a message from the stream\n   */\n  read(options?: AbortOptions): Promise<T>\n\n  /**\n   * Write a message to the stream\n   */\n  write(d: T, options?: AbortOptions): Promise<void>\n\n  /**\n   * Write several messages to the stream\n   */\n  writeV(d: T[], options?: AbortOptions): Promise<void>\n\n  /**\n   * Unwrap the underlying protobuf stream\n   */\n  unwrap(): ProtobufStream<S>\n}\n\nexport interface ProtobufStreamOpts extends LengthPrefixedStreamOpts {\n\n}\n\nexport function pbStream <T extends MessageStream = Stream> (stream: T, opts?: Partial<ProtobufStreamOpts>): ProtobufStream<T> {\n  const lp = lpStream(stream, opts)\n\n  const pbStream: ProtobufStream<T> = {\n    read: async (proto, options?: AbortOptions) => {\n      // readLP, decode\n      const value = await lp.read(options)\n\n      return proto.decode(value)\n    },\n    write: async (message, proto, options?: AbortOptions) => {\n      // encode, writeLP\n      await lp.write(proto.encode(message), options)\n    },\n    writeV: async (messages, proto, options?: AbortOptions) => {\n      // encode, writeLP\n      await lp.writeV(messages.map(message => proto.encode(message)), options)\n    },\n    pb: (proto) => {\n      return {\n        read: async (options) => pbStream.read(proto, options),\n        write: async (d, options) => pbStream.write(d, proto, options),\n        writeV: async (d, options) => pbStream.writeV(d, proto, options),\n        unwrap: () => pbStream\n      }\n    },\n    unwrap: () => {\n      return lp.unwrap()\n    }\n  }\n\n  return pbStream\n}\n\nexport async function echo (stream: MessageStream, options?: AbortOptions): Promise<void> {\n  const log = stream.log.newScope('echo')\n  const start = Date.now()\n\n  let bytes = 0\n\n  try {\n    for await (const buf of stream) {\n      bytes += buf.byteLength\n\n      if (!stream.send(buf)) {\n        stream.pause()\n\n        await pEvent(stream, 'drain', {\n          rejectionEvents: [\n            'close'\n          ],\n          ...options\n        })\n\n        stream.resume()\n      }\n    }\n\n    log('echoed %d bytes in %dms', bytes, Date.now() - start)\n\n    await stream.close(options)\n  } catch (err: any) {\n    stream.abort(err)\n  }\n}\n\nexport type PipeInput = Iterable<Uint8Array | Uint8ArrayList> | AsyncIterable<Uint8Array | Uint8ArrayList> | Stream\n\nfunction isMessageStream (obj?: any): obj is Stream {\n  return obj?.addEventListener != null\n}\n\nexport function messageStreamToDuplex (stream: Stream): Duplex<AsyncGenerator<Uint8ArrayList | Uint8Array>, Iterable<Uint8ArrayList | Uint8Array> | AsyncIterable<Uint8ArrayList | Uint8Array>, Promise<void>> {\n  const source = pushable<Uint8ArrayList | Uint8Array>()\n  let onError: PromiseWithResolvers<IteratorResult<Uint8ArrayList | Uint8Array>> | undefined\n\n  const onMessage = (evt: StreamMessageEvent): void => {\n    source.push(evt.data)\n  }\n\n  const onRemoteCloseWrite = (): void => {\n    source.end()\n\n    stream.removeEventListener('message', onMessage)\n    stream.removeEventListener('close', onClose)\n    stream.removeEventListener('remoteCloseWrite', onRemoteCloseWrite)\n  }\n\n  const onClose = (evt: StreamCloseEvent): void => {\n    source.end(evt.error)\n\n    if (evt.error != null) {\n      onError?.reject(evt.error)\n    }\n\n    stream.removeEventListener('message', onMessage)\n    stream.removeEventListener('close', onClose)\n    stream.removeEventListener('remoteCloseWrite', onRemoteCloseWrite)\n  }\n\n  stream.addEventListener('message', onMessage)\n  stream.addEventListener('close', onClose, {\n    once: true\n  })\n  stream.addEventListener('remoteCloseWrite', onRemoteCloseWrite, {\n    once: true\n  })\n\n  return {\n    source,\n    async sink (source: Source<Uint8Array | Uint8ArrayList>) {\n      async function * toGenerator (): AsyncGenerator<Uint8Array | Uint8ArrayList> {\n        yield * source\n      }\n\n      const gen = toGenerator()\n\n      while (true) {\n        onError = Promise.withResolvers<IteratorResult<Uint8ArrayList | Uint8Array>>()\n\n        const { done, value } = await Promise.race([\n          gen.next(),\n          onError.promise\n        ])\n\n        if (stream.writeStatus === 'closing' || stream.writeStatus === 'closed') {\n          break\n        }\n\n        if (value != null) {\n          if (!stream.send(value)) {\n            await Promise.race([\n              pEvent(stream, 'drain', {\n                rejectionEvents: [\n                  'close'\n                ]\n              })\n            ])\n          }\n        }\n\n        if (done === true) {\n          break\n        }\n      }\n\n      await stream.close()\n    }\n  }\n}\n\ninterface SourceFn<A = any> { (): A }\n\ntype PipeSource<A = any> =\n  Iterable<A> |\n  AsyncIterable<A> |\n  SourceFn<A> |\n  Duplex<A, any, any> |\n  MessageStream\n\ntype PipeTransform<A = any, B = any> =\n  Transform<A, B> |\n  Duplex<B, A> |\n  MessageStream\n\ntype PipeSink<A = any, B = any> =\n  Sink<A, B> |\n  Duplex<any, A, B> |\n  MessageStream\n\ntype PipeOutput<A> =\n  A extends Sink<any> ? ReturnType<A> :\n    A extends Duplex<any, any, any> ? ReturnType<A['sink']> :\n      A extends MessageStream ? Promise<void> :\n        never\n\n// single item pipe output includes pipe source types\ntype SingleItemPipeOutput<A> =\n  A extends Iterable<any> ? A :\n    A extends AsyncIterable<any> ? A :\n      A extends SourceFn ? ReturnType<A> :\n        A extends Duplex<any, any, any> ? A['source'] :\n          PipeOutput<A>\n\ntype PipeFnInput<A> =\n  A extends Iterable<any> ? A :\n    A extends AsyncIterable<any> ? A :\n      A extends SourceFn ? ReturnType<A> :\n        A extends Transform<any, any> ? ReturnType<A> :\n          A extends Duplex<any, any, any> ? A['source'] :\n            never\n\nexport function pipe<\n  A extends PipeSource\n> (\n  source: A\n): SingleItemPipeOutput<A>\n// two items, source to sink\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeSink<PipeFnInput<A>>\n> (\n  source: A,\n  sink: B\n): PipeOutput<B>\n\n// three items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeSink<PipeFnInput<B>>\n> (\n  source: A,\n  transform1: B,\n  sink: C\n): PipeOutput<C>\n\n// many items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeSink<PipeFnInput<C>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  sink: D\n): PipeOutput<D>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeSink<PipeFnInput<D>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  sink: E\n): PipeOutput<E>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeSink<PipeFnInput<E>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  sink: F\n): PipeOutput<F>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeSink<PipeFnInput<F>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  sink: G\n): PipeOutput<G>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeSink<PipeFnInput<G>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  sink: H\n): PipeOutput<H>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeSink<PipeFnInput<H>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  sink: I\n): PipeOutput<I>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeSink<PipeFnInput<I>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  sink: J\n): PipeOutput<J>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeTransform<PipeFnInput<I>>,\n  K extends PipeSink<PipeFnInput<J>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  transform9: J,\n  sink: K\n): PipeOutput<K>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeTransform<PipeFnInput<I>>,\n  K extends PipeTransform<PipeFnInput<J>>,\n  L extends PipeSink<PipeFnInput<K>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  transform9: J,\n  transform10: K,\n  sink: L\n): PipeOutput<L>\nexport function pipe (...input: any[]): any {\n  const sources = input.map(source => {\n    if (isMessageStream(source)) {\n      return messageStreamToDuplex(source)\n    }\n\n    return source\n  })\n\n  // @ts-expect-error it-pipe types say args cannot be spread like this\n  return itPipe(...sources)\n}\n", "// FNV_PRIMES and FNV_OFFSETS from\n// http://www.isthe.com/chongo/tech/comp/fnv/index.html#FNV-param\n\nconst FNV_PRIMES = {\n\t32: 16_777_619n,\n\t64: 1_099_511_628_211n,\n\t128: 309_485_009_821_345_068_724_781_371n,\n\t256: 374_144_419_156_711_147_060_143_317_175_368_453_031_918_731_002_211n,\n\t512: 35_835_915_874_844_867_368_919_076_489_095_108_449_946_327_955_754_392_558_399_825_615_420_669_938_882_575_126_094_039_892_345_713_852_759n,\n\t1024: 5_016_456_510_113_118_655_434_598_811_035_278_955_030_765_345_404_790_744_303_017_523_831_112_055_108_147_451_509_157_692_220_295_382_716_162_651_878_526_895_249_385_292_291_816_524_375_083_746_691_371_804_094_271_873_160_484_737_966_720_260_389_217_684_476_157_468_082_573n,\n};\n\nconst FNV_OFFSETS = {\n\t32: 2_166_136_261n,\n\t64: 14_695_981_039_346_656_037n,\n\t128: 144_066_263_297_769_815_596_495_629_667_062_367_629n,\n\t256: 100_029_257_958_052_580_907_070_968_620_625_704_837_092_796_014_241_193_945_225_284_501_741_471_925_557n,\n\t512: 9_659_303_129_496_669_498_009_435_400_716_310_466_090_418_745_672_637_896_108_374_329_434_462_657_994_582_932_197_716_438_449_813_051_892_206_539_805_784_495_328_239_340_083_876_191_928_701_583_869_517_785n,\n\t1024: 14_197_795_064_947_621_068_722_070_641_403_218_320_880_622_795_441_933_960_878_474_914_617_582_723_252_296_732_303_717_722_150_864_096_521_202_355_549_365_628_174_669_108_571_814_760_471_015_076_148_029_755_969_804_077_320_157_692_458_563_003_215_304_957_150_157_403_644_460_363_550_505_412_711_285_966_361_610_267_868_082_893_823_963_790_439_336_411_086_884_584_107_735_010_676_915n,\n};\n\nconst cachedEncoder = new globalThis.TextEncoder();\n\nfunction fnv1aUint8Array(uint8Array, size) {\n\tconst fnvPrime = FNV_PRIMES[size];\n\tlet hash = FNV_OFFSETS[size];\n\n\t// eslint-disable-next-line unicorn/no-for-loop -- This is a performance-sensitive loop\n\tfor (let index = 0; index < uint8Array.length; index++) {\n\t\thash ^= BigInt(uint8Array[index]);\n\t\thash = BigInt.asUintN(size, hash * fnvPrime);\n\t}\n\n\treturn hash;\n}\n\nfunction fnv1aEncodeInto(string, size, utf8Buffer) {\n\tif (utf8Buffer.length === 0) {\n\t\tthrow new Error('The `utf8Buffer` option must have a length greater than zero');\n\t}\n\n\tconst fnvPrime = FNV_PRIMES[size];\n\tlet hash = FNV_OFFSETS[size];\n\tlet remaining = string;\n\n\twhile (remaining.length > 0) {\n\t\tconst result = cachedEncoder.encodeInto(remaining, utf8Buffer);\n\t\tremaining = remaining.slice(result.read);\n\t\tfor (let index = 0; index < result.written; index++) {\n\t\t\thash ^= BigInt(utf8Buffer[index]);\n\t\t\thash = BigInt.asUintN(size, hash * fnvPrime);\n\t\t}\n\t}\n\n\treturn hash;\n}\n\nexport default function fnv1a(value, {size = 32, utf8Buffer} = {}) {\n\tif (!FNV_PRIMES[size]) {\n\t\tthrow new Error('The `size` option must be one of 32, 64, 128, 256, 512, or 1024');\n\t}\n\n\tif (typeof value === 'string') {\n\t\tif (utf8Buffer) {\n\t\t\treturn fnv1aEncodeInto(value, size, utf8Buffer);\n\t\t}\n\n\t\tvalue = cachedEncoder.encode(value);\n\t}\n\n\treturn fnv1aUint8Array(value, size);\n}\n", "import fnv1aHash from '@sindresorhus/fnv1a'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\n\nexport interface Hash {\n  hash(input: Uint8Array, seed: number): number\n  hashV(input: Uint8Array, seed: number): Uint8Array\n}\n\nexport const fnv1a: Hash = {\n  hash: (input) => {\n    return Number(fnv1aHash(input, {\n      size: 32\n    }))\n  },\n  hashV: (input, seed) => {\n    return numberToBuffer(fnv1a.hash(input, seed))\n  }\n}\n\nexport function numberToBuffer (num: bigint | number): Uint8Array {\n  let hex = num.toString(16)\n\n  if (hex.length % 2 === 1) {\n    hex = `0${hex}`\n  }\n\n  return uint8ArrayFromString(hex, 'base16')\n}\n", "// ported from xxbloom - https://github.com/ceejbot/xxbloom/blob/master/LICENSE\nimport { randomBytes } from '@libp2p/crypto'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { alloc } from 'uint8arrays/alloc'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { fnv1a } from './hashes.js'\nimport type { Filter } from './index.js'\n\nconst LN2_SQUARED = Math.LN2 * Math.LN2\n\nexport interface BloomFilterOptions {\n  seeds?: number[]\n  hashes?: number\n  bits?: number\n}\n\nexport class BloomFilter implements Filter {\n  public readonly seeds: number[]\n  public readonly bits: number\n  public buffer: Uint8Array\n\n  constructor (options: BloomFilterOptions = {}) {\n    if (options.seeds != null) {\n      this.seeds = options.seeds\n    } else {\n      this.seeds = generateSeeds(options.hashes ?? 8)\n    }\n\n    this.bits = options.bits ?? 1024\n    this.buffer = alloc(Math.ceil(this.bits / 8))\n  }\n\n  /**\n   * Add an item to the filter\n   */\n  add (item: Uint8Array | string): void {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    for (let i = 0; i < this.seeds.length; i++) {\n      const hash = fnv1a.hash(item, this.seeds[i])\n      const bit = hash % this.bits\n\n      this.setbit(bit)\n    }\n  }\n\n  /**\n   * Test if the filter has an item. If it returns false it definitely does not\n   * have the item. If it returns true, it probably has the item but there's\n   * an `errorRate` chance it doesn't.\n   */\n  has (item: Uint8Array | string): boolean {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    for (let i = 0; i < this.seeds.length; i++) {\n      const hash = fnv1a.hash(item, this.seeds[i])\n      const bit = hash % this.bits\n\n      const isSet = this.getbit(bit)\n\n      if (!isSet) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Reset the filter\n   */\n  clear (): void {\n    this.buffer.fill(0)\n  }\n\n  setbit (bit: number): void {\n    const pos = Math.floor(bit / 8)\n    const shift = bit % 8\n\n    let bitField = this.buffer[pos]\n    bitField |= (0x1 << shift)\n    this.buffer[pos] = bitField\n  }\n\n  getbit (bit: number): boolean {\n    const pos = Math.floor(bit / 8)\n    const shift = bit % 8\n\n    const bitField = this.buffer[pos]\n    return (bitField & (0x1 << shift)) !== 0\n  }\n}\n\n/**\n * Create a `BloomFilter` with the smallest `bits` and `hashes` value for the\n * specified item count and error rate.\n */\nexport function createBloomFilter (itemCount: number, errorRate: number = 0.005): Filter {\n  const opts = optimize(itemCount, errorRate)\n  return new BloomFilter(opts)\n}\n\nfunction optimize (itemCount: number, errorRate: number = 0.005): { bits: number, hashes: number } {\n  const bits = Math.round(-1 * itemCount * Math.log(errorRate) / LN2_SQUARED)\n  const hashes = Math.round((bits / itemCount) * Math.LN2)\n\n  return { bits, hashes }\n}\n\nfunction generateSeeds (count: number): number[] {\n  let buf: Uint8ArrayList\n  let j: number\n  const seeds = []\n\n  for (let i = 0; i < count; i++) {\n    buf = new Uint8ArrayList(randomBytes(4))\n    seeds[i] = buf.getUint32(0, true)\n\n    // Make sure we don't end up with two identical seeds,\n    // which is unlikely but possible.\n    for (j = 0; j < i; j++) {\n      if (seeds[i] === seeds[j]) {\n        i--\n        break\n      }\n    }\n  }\n\n  return seeds\n}\n", "import { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport type { Hash } from './hashes.js'\n\nexport const MAX_FINGERPRINT_SIZE = 64\n\nexport class Fingerprint {\n  private readonly fp: Uint8Array\n  private readonly h: Hash\n  private readonly seed: number\n\n  constructor (buf: Uint8Array, hash: Hash, seed: number, fingerprintSize: number = 2) {\n    if (fingerprintSize > MAX_FINGERPRINT_SIZE) {\n      throw new TypeError('Invalid Fingerprint Size')\n    }\n\n    const fnv = hash.hashV(buf, seed)\n    const fp = uint8ArrayAlloc(fingerprintSize)\n\n    for (let i = 0; i < fp.length; i++) {\n      fp[i] = fnv[i]\n    }\n\n    if (fp.length === 0) {\n      fp[0] = 7\n    }\n\n    this.fp = fp\n    this.h = hash\n    this.seed = seed\n  }\n\n  hash (): number {\n    return this.h.hash(this.fp, this.seed)\n  }\n\n  equals (other?: any): boolean {\n    if (!(other?.fp instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.fp, other.fp)\n  }\n}\n", "export function getRandomInt (min: number, max: number): number {\n  return Math.floor(Math.random() * (max - min)) + min\n}\n", "import { Fingerprint } from './fingerprint.js'\nimport { getRandomInt } from './utils.js'\n\nexport class Bucket {\n  private readonly contents: Array<Fingerprint | null>\n\n  constructor (size: number) {\n    this.contents = new Array(size).fill(null)\n  }\n\n  has (fingerprint: Fingerprint): boolean {\n    if (!(fingerprint instanceof Fingerprint)) {\n      throw new TypeError('Invalid Fingerprint')\n    }\n\n    return this.contents.some((fp) => {\n      return fingerprint.equals(fp)\n    })\n  }\n\n  add (fingerprint: Fingerprint): boolean {\n    if (!(fingerprint instanceof Fingerprint)) {\n      throw new TypeError('Invalid Fingerprint')\n    }\n\n    for (let i = 0; i < this.contents.length; i++) {\n      if (this.contents[i] == null) {\n        this.contents[i] = fingerprint\n        return true\n      }\n    }\n\n    return true\n  }\n\n  swap (fingerprint: Fingerprint): Fingerprint | null {\n    if (!(fingerprint instanceof Fingerprint)) {\n      throw new TypeError('Invalid Fingerprint')\n    }\n\n    const i = getRandomInt(0, this.contents.length - 1)\n    const current = this.contents[i]\n    this.contents[i] = fingerprint\n\n    return current\n  }\n\n  remove (fingerprint: Fingerprint): boolean {\n    if (!(fingerprint instanceof Fingerprint)) {\n      throw new TypeError('Invalid Fingerprint')\n    }\n\n    const found = this.contents.findIndex((fp) => {\n      return fingerprint.equals(fp)\n    })\n\n    if (found > -1) {\n      this.contents[found] = null\n      return true\n    } else {\n      return false\n    }\n  }\n}\n", "import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { Bucket } from './bucket.js'\nimport { Fingerprint, MAX_FINGERPRINT_SIZE } from './fingerprint.js'\nimport { fnv1a } from './hashes.js'\nimport { getRandomInt } from './utils.js'\nimport type { Hash } from './hashes.js'\nimport type { Filter } from './index.js'\n\nconst maxCuckooCount = 500\n\nexport interface CuckooFilterInit {\n  /**\n   * How many items the filter is expected to contain\n   */\n  filterSize: number\n\n  /**\n   * How many items to put in each bucket\n   */\n  bucketSize?: number\n\n  /**\n   * How many bytes the fingerprint is expected to be\n   */\n  fingerprintSize?: number\n\n  /**\n   * A non-cryptographic hash implementation\n   */\n  hash?: Hash\n\n  /**\n   * A number used to seed the hash\n   */\n  seed?: number\n}\n\nexport class CuckooFilter implements Filter {\n  private readonly bucketSize: number\n  private readonly filterSize: number\n  private readonly fingerprintSize: number\n  private readonly buckets: Bucket[]\n  public count: number\n  private readonly hash: Hash\n  private readonly seed: number\n\n  constructor (init: CuckooFilterInit) {\n    this.filterSize = init.filterSize\n    this.bucketSize = init.bucketSize ?? 4\n    this.fingerprintSize = init.fingerprintSize ?? 2\n    this.count = 0\n    this.buckets = []\n    this.hash = init.hash ?? fnv1a\n    this.seed = init.seed ?? getRandomInt(0, Math.pow(2, 10))\n  }\n\n  add (item: Uint8Array | string): boolean {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize)\n    const j = this.hash.hash(item, this.seed) % this.filterSize\n    const k = (j ^ fingerprint.hash()) % this.filterSize\n\n    if (this.buckets[j] == null) {\n      this.buckets[j] = new Bucket(this.bucketSize)\n    }\n\n    if (this.buckets[k] == null) {\n      this.buckets[k] = new Bucket(this.bucketSize)\n    }\n\n    if (this.buckets[j].add(fingerprint) || this.buckets[k].add(fingerprint)) {\n      this.count++\n      return true\n    }\n\n    const rand = [j, k]\n    let i = rand[getRandomInt(0, rand.length - 1)]\n\n    if (this.buckets[i] == null) {\n      this.buckets[i] = new Bucket(this.bucketSize)\n    }\n\n    for (let n = 0; n < maxCuckooCount; n++) {\n      const swapped = this.buckets[i].swap(fingerprint)\n\n      if (swapped == null) {\n        continue\n      }\n\n      i = (i ^ swapped.hash()) % this.filterSize\n\n      if (this.buckets[i] == null) {\n        this.buckets[i] = new Bucket(this.bucketSize)\n      }\n\n      if (this.buckets[i].add(swapped)) {\n        this.count++\n\n        return true\n      } else {\n        continue\n      }\n    }\n\n    return false\n  }\n\n  has (item: Uint8Array | string): boolean {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize)\n    const j = this.hash.hash(item, this.seed) % this.filterSize\n    const inJ = this.buckets[j]?.has(fingerprint) ?? false\n\n    if (inJ) {\n      return inJ\n    }\n\n    const k = (j ^ fingerprint.hash()) % this.filterSize\n\n    return this.buckets[k]?.has(fingerprint) ?? false\n  }\n\n  remove (item: Uint8Array | string): boolean {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize)\n    const j = this.hash.hash(item, this.seed) % this.filterSize\n    const inJ = this.buckets[j]?.remove(fingerprint) ?? false\n\n    if (inJ) {\n      this.count--\n      return inJ\n    }\n\n    const k = (j ^ fingerprint.hash()) % this.filterSize\n    const inK = this.buckets[k]?.remove(fingerprint) ?? false\n\n    if (inK) {\n      this.count--\n    }\n\n    return inK\n  }\n\n  get reliable (): boolean {\n    return Math.floor(100 * (this.count / this.filterSize)) <= 90\n  }\n}\n\n// max load constants, defined in the cuckoo paper\nconst MAX_LOAD = {\n  1: 0.5,\n  2: 0.84,\n  4: 0.95,\n  8: 0.98\n}\n\nfunction calculateBucketSize (errorRate: number = 0.001): 2 | 4 | 8 {\n  if (errorRate > 0.002) {\n    return 2\n  }\n\n  if (errorRate > 0.00001) {\n    return 4\n  }\n\n  return 8\n}\n\nexport function optimize (maxItems: number, errorRate: number = 0.001): CuckooFilterInit {\n  // https://www.eecs.harvard.edu/~michaelm/postscripts/cuckoo-conext2014.pdf\n  // Section 5.1 Optimal Bucket Size\n  const bucketSize = calculateBucketSize(errorRate)\n  const load = MAX_LOAD[bucketSize]\n\n  // https://stackoverflow.com/questions/57555236/how-to-size-a-cuckoo-filter/57617208#57617208\n  const filterSize = Math.round(maxItems / load)\n  const fingerprintSize = Math.min(Math.ceil(Math.log2(1 / errorRate) + Math.log2(2 * bucketSize)), MAX_FINGERPRINT_SIZE)\n\n  return {\n    filterSize,\n    bucketSize,\n    fingerprintSize\n  }\n}\n\nexport function createCuckooFilter (maxItems: number, errorRate: number = 0.005): Filter {\n  const opts = optimize(maxItems, errorRate)\n  return new CuckooFilter(opts)\n}\n", "import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { CuckooFilter, optimize } from './cuckoo-filter.js'\nimport { fnv1a } from './hashes.js'\nimport { getRandomInt } from './utils.js'\nimport type { CuckooFilterInit } from './cuckoo-filter.js'\nimport type { Hash } from './hashes.js'\nimport type { Filter } from './index.js'\n\nexport interface ScalableCuckooFilterInit extends CuckooFilterInit {\n  /**\n   * A number to multiply maxItems by when adding new sub-filters\n   */\n  scale?: number\n}\n\nexport class ScalableCuckooFilter implements Filter {\n  private readonly filterSize: number\n  private readonly bucketSize: number\n  private readonly fingerprintSize: number\n  private readonly scale: number\n  private readonly filterSeries: CuckooFilter[]\n  private readonly hash: Hash\n  private readonly seed: number\n\n  constructor (init: ScalableCuckooFilterInit) {\n    this.bucketSize = init.bucketSize ?? 4\n    this.filterSize = init.filterSize ?? (1 << 18) / this.bucketSize\n    this.fingerprintSize = init.fingerprintSize ?? 2\n    this.scale = init.scale ?? 2\n    this.hash = init.hash ?? fnv1a\n    this.seed = init.seed ?? getRandomInt(0, Math.pow(2, 10))\n    this.filterSeries = [\n      new CuckooFilter({\n        filterSize: this.filterSize,\n        bucketSize: this.bucketSize,\n        fingerprintSize: this.fingerprintSize,\n        hash: this.hash,\n        seed: this.seed\n      })\n    ]\n  }\n\n  add (item: Uint8Array | string): boolean {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    if (this.has(item)) {\n      return true\n    }\n\n    let current = this.filterSeries.find((cuckoo) => {\n      return cuckoo.reliable\n    })\n\n    if (current == null) {\n      const curSize = this.filterSize * Math.pow(this.scale, this.filterSeries.length)\n\n      current = new CuckooFilter({\n        filterSize: curSize,\n        bucketSize: this.bucketSize,\n        fingerprintSize: this.fingerprintSize,\n        hash: this.hash,\n        seed: this.seed\n      })\n\n      this.filterSeries.push(current)\n    }\n\n    return current.add(item)\n  }\n\n  has (item: Uint8Array | string): boolean {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    for (let i = 0; i < this.filterSeries.length; i++) {\n      if (this.filterSeries[i].has(item)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  remove (item: Uint8Array | string): boolean {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    for (let i = 0; i < this.filterSeries.length; i++) {\n      if (this.filterSeries[i].remove(item)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  get count (): number {\n    return this.filterSeries.reduce((acc, curr) => {\n      return acc + curr.count\n    }, 0)\n  }\n}\n\nexport function createScalableCuckooFilter (maxItems: number, errorRate: number = 0.001, options?: Pick<ScalableCuckooFilterInit, 'hash' | 'seed' | 'scale'>): Filter {\n  return new ScalableCuckooFilter({\n    ...optimize(maxItems, errorRate),\n    ...(options ?? {})\n  })\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport interface IP4NetConfig {\n  type: 'ip4'\n  host: string\n  protocol?: 'tcp' | 'udp'\n  port?: number\n  cidr?: number\n  sni?: string\n}\n\nexport interface IP6NetConfig {\n  type: 'ip6'\n  host: string\n  protocol?: 'tcp' | 'udp'\n  port?: number\n  zone?: string\n  cidr?: string\n  sni?: string\n}\n\nexport interface DNSNetConfig {\n  type: 'dns'\n  host: string\n  protocol?: 'tcp' | 'udp'\n  port: number\n  cidr?: number\n}\n\nexport interface DNS4NetConfig {\n  type: 'dns4'\n  host: string\n  protocol?: 'tcp' | 'udp'\n  port: number\n  cidr?: number\n}\n\nexport interface DNS6NetConfig {\n  type: 'dns6'\n  host: string\n  protocol?: 'tcp' | 'udp'\n  port: number\n  cidr?: number\n}\n\nexport interface DNSAddrNetConfig {\n  type: 'dnsaddr'\n  host: string\n  protocol?: 'tcp' | 'udp'\n  port: number\n  cidr?: number\n}\n\nexport type NetConfig = IP4NetConfig | IP6NetConfig | DNSNetConfig | DNS4NetConfig | DNS6NetConfig | DNSAddrNetConfig\n\n/**\n * Returns host/port/etc information for multiaddrs, if it is available.\n *\n * It will throw if the passed multiaddr does not start with a network address,\n * e.g. a IPv4, IPv6, DNS, DNS4, DNS6 or DNSADDR address\n */\nexport function getNetConfig (ma: Multiaddr): NetConfig {\n  const components = ma.getComponents()\n  const config: any = {}\n  let index = 0\n\n  if (components[index]?.name === 'ip6zone') {\n    config.zone = `${components[index].value}`\n    index++\n  }\n\n  if (components[index].name === 'ip4' || components[index].name === 'ip6') {\n    config.type = components[index].name\n    config.host = components[index].value\n    index++\n  } else if (components[index].name === 'dns' || components[index].name === 'dns4' || components[index].name === 'dns6') {\n    config.type = components[index].name\n    config.host = components[index].value\n    index++\n  } else if (components[index].name === 'dnsaddr') {\n    config.type = components[index].name\n    config.host = `_dnsaddr.${components[index].value}`\n    index++\n  }\n\n  if (components[index]?.name === 'tcp' || components[index]?.name === 'udp') {\n    config.protocol = components[index].name === 'tcp' ? 'tcp' : 'udp'\n    config.port = parseInt(`${components[index].value}`)\n    index++\n  }\n\n  if (components[index]?.name === 'ipcidr') {\n    if (config.type === 'ip4') {\n      config.cidr = parseInt(`${components[index].value}`)\n    } else if (config.type === 'ip6') {\n      config.cidr = `${components[index].value}`\n    }\n    index++\n  }\n\n  if (config.type == null || config.host == null) {\n    throw new InvalidParametersError(`Multiaddr ${ma} was not an IPv4, IPv6, DNS, DNS4, DNS6 or DNSADDR address`)\n  }\n\n  if (components[index]?.name === 'tls' && components[index + 1]?.name === 'sni') {\n    config.sni = components[index + 1].value\n    index += 2\n  }\n\n  return config\n}\n", "import { IPv4Len, IPv6Len } from \"./ip.js\";\n\nexport function allFF(\n  a: number[] | Uint8Array,\n  from: number,\n  to: number\n): boolean {\n  let i = 0;\n  for (const e of a) {\n    if (i < from) continue;\n    if (i > to) break;\n    if (e !== 0xff) return false;\n    i++;\n  }\n  return true;\n}\n\nexport function deepEqual(\n  a: Uint8Array | number[],\n  b: Uint8Array,\n  from: number,\n  to: number\n): boolean {\n  let i = 0;\n  for (const e of a) {\n    if (i < from) continue;\n    if (i > to) break;\n    if (e !== b[i]) return false;\n    i++;\n  }\n  return true;\n}\n\n/***\n * Returns long ip format\n */\nexport function ipToString(ip: Uint8Array | number[]): string {\n  switch (ip.length) {\n    case IPv4Len: {\n      return ip.join(\".\");\n    }\n    case IPv6Len: {\n      const result = [] as string[];\n      for (let i = 0; i < ip.length; i++) {\n        if (i % 2 === 0) {\n          result.push(\n            ip[i].toString(16).padStart(2, \"0\") +\n              ip[i + 1].toString(16).padStart(2, \"0\")\n          );\n        }\n      }\n      return result.join(\":\");\n    }\n    default: {\n      throw new Error(\"Invalid ip length\");\n    }\n  }\n}\n\n/**\n * If mask is a sequence of 1 bits followed by 0 bits, return number of 1 bits else -1\n */\nexport function simpleMaskLength(mask: Uint8Array): number {\n  let ones = 0;\n  // eslint-disable-next-line prefer-const\n  for (let [index, byte] of mask.entries()) {\n    if (byte === 0xff) {\n      ones += 8;\n      continue;\n    }\n    while ((byte & 0x80) != 0) {\n      ones++;\n      byte = byte << 1;\n    }\n    if ((byte & 0x80) != 0) {\n      return -1;\n    }\n    for (let i = index + 1; i < mask.length; i++) {\n      if (mask[i] != 0) {\n        return -1;\n      }\n    }\n    break;\n  }\n  return ones;\n}\n\nexport function maskToHex(mask: Uint8Array): string {\n  let hex = \"0x\";\n  for (const byte of mask) {\n    hex += (byte >> 4).toString(16) + (byte & 0x0f).toString(16);\n  }\n  return hex;\n}\n", "import { parseIP } from \"@chainsafe/is-ip/parse\";\nimport { allFF, deepEqual } from \"./util.js\";\n\nexport const IPv4Len = 4;\nexport const IPv6Len = 16;\n\nexport const maxIPv6Octet = parseInt(\"0xFFFF\", 16);\nexport const ipv4Prefix = new Uint8Array([\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255,\n]);\n\nexport interface IpNetRaw {\n  network: Uint8Array;\n  mask: Uint8Array;\n}\n\nexport function maskIp(ip: Uint8Array, mask: Uint8Array): Uint8Array {\n  if (mask.length === IPv6Len && ip.length === IPv4Len && allFF(mask, 0, 11)) {\n    mask = mask.slice(12);\n  }\n  if (\n    mask.length === IPv4Len &&\n    ip.length === IPv6Len &&\n    deepEqual(ip, ipv4Prefix, 0, 11)\n  ) {\n    ip = ip.slice(12);\n  }\n  const n = ip.length;\n  if (n != mask.length) {\n    throw new Error(\"Failed to mask ip\");\n  }\n  const out = new Uint8Array(n);\n  for (let i = 0; i < n; i++) {\n    out[i] = ip[i] & mask[i];\n  }\n  return out;\n}\n\nexport function containsIp(\n  net: IpNetRaw,\n  ip: Uint8Array | number[] | string\n): boolean {\n  if (typeof ip === \"string\") {\n    ip = parseIP(ip)!;\n  }\n  if (ip == null) throw new Error(\"Invalid ip\");\n  if (ip.length !== net.network.length) {\n    return false;\n  }\n  for (let i = 0; i < ip.length; i++) {\n    if ((net.network[i] & net.mask[i]) !== (ip[i] & net.mask[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function iPv4FromIPv6(ip: Uint8Array): Uint8Array {\n  if (!isIPv4mappedIPv6(ip)) {\n    throw new Error(\"Must have 0xffff prefix\");\n  }\n  return ip.slice(12);\n}\n\nexport function isIPv4mappedIPv6(ip: Uint8Array | number[]): boolean {\n  return deepEqual(ip, ipv4Prefix, 0, 11);\n}\n", "import { parseIPv4, parseIPv6 } from \"@chainsafe/is-ip/parse\";\nimport { IPv4Len, IPv6Len, maskIp } from \"./ip.js\";\n\nexport function parseCidr(s: string): {\n  network: Uint8Array;\n  mask: Uint8Array;\n} {\n  const [address, maskString] = s.split(\"/\");\n  if (!address || !maskString)\n    throw new Error(\"Failed to parse given CIDR: \" + s);\n  let ipLength = IPv4Len;\n  let ip = parseIPv4(address);\n  if (ip == null) {\n    ipLength = IPv6Len;\n    ip = parseIPv6(address);\n    if (ip == null) throw new Error(\"Failed to parse given CIDR: \" + s);\n  }\n  const m = parseInt(maskString, 10);\n  if (\n    Number.isNaN(m) ||\n    String(m).length !== maskString.length ||\n    m < 0 ||\n    m > ipLength * 8\n  ) {\n    throw new Error(\"Failed to parse given CIDR: \" + s);\n  }\n  const mask = cidrMask(m, 8 * ipLength);\n  return {\n    network: maskIp(ip, mask),\n    mask,\n  };\n}\n\nexport function cidrMask(ones: number, bits: number): Uint8Array {\n  if (bits !== 8 * IPv4Len && bits !== 8 * IPv6Len)\n    throw new Error(\"Invalid CIDR mask\");\n  if (ones < 0 || ones > bits) throw new Error(\"Invalid CIDR mask\");\n  const l = bits / 8;\n  const m = new Uint8Array(l);\n  for (let i = 0; i < l; i++) {\n    if (ones >= 8) {\n      m[i] = 0xff;\n      ones -= 8;\n      continue;\n    }\n    m[i] = 255 - (0xff >> ones);\n    ones = 0;\n  }\n  return m;\n}\n", "import { parseIP } from \"@chainsafe/is-ip/parse\";\nimport { cidrMask, parseCidr } from \"./cidr.js\";\nimport { containsIp, maskIp } from \"./ip.js\";\nimport { ipToString, maskToHex, simpleMaskLength } from \"./util.js\";\n\nexport class IpNet {\n  public readonly network: Uint8Array;\n  public readonly mask: Uint8Array;\n\n  /**\n   *\n   * @param ipOrCidr either network ip or full cidr address\n   * @param mask in case ipOrCidr is network this can be either mask in decimal format or as ip address\n   */\n  constructor(ipOrCidr: string, mask?: string | number) {\n    if (mask == null) {\n      ({ network: this.network, mask: this.mask } = parseCidr(ipOrCidr));\n    } else {\n      const ipResult = parseIP(ipOrCidr);\n      if (ipResult == null) {\n        throw new Error(\"Failed to parse network\");\n      }\n      mask = String(mask);\n      const m = parseInt(mask, 10);\n      if (\n        Number.isNaN(m) ||\n        String(m).length !== mask.length ||\n        m < 0 ||\n        m > ipResult.length * 8\n      ) {\n        const maskResult = parseIP(mask);\n        if (maskResult == null) {\n          throw new Error(\"Failed to parse mask\");\n        }\n        this.mask = maskResult;\n      } else {\n        this.mask = cidrMask(m, 8 * ipResult.length);\n      }\n      this.network = maskIp(ipResult, this.mask);\n    }\n  }\n\n  /**\n   * Checks if netmask contains ip address\n   * @param ip\n   * @returns\n   */\n  contains(ip: Uint8Array | number[] | string): boolean {\n    return containsIp({ network: this.network, mask: this.mask }, ip);\n  }\n\n  /**Serializes back to string format */\n  toString(): string {\n    const l = simpleMaskLength(this.mask);\n    const mask = l !== -1 ? String(l) : maskToHex(this.mask);\n    return ipToString(this.network) + \"/\" + mask;\n  }\n}\n", "import { IpNet } from \"./ipnet.js\";\n\nexport { ipToString } from \"./util.js\";\nexport { maskIp, iPv4FromIPv6, isIPv4mappedIPv6 } from \"./ip.js\";\nexport { IpNet } from \"./ipnet.js\";\nexport { parseCidr } from \"./cidr.js\";\n\n/**\n * Checks if cidr block contains ip address\n * @param cidr ipv4 or ipv6 formatted cidr . Example 198.51.100.14/24 or 2001:db8::/48\n * @param ip ipv4 or ipv6 address Example 198.51.100.14 or 2001:db8::\n *\n */\nexport function cidrContains(cidr: string, ip: string): boolean {\n  const ipnet = new IpNet(cidr);\n  return ipnet.contains(ip);\n}\n", "import { cidrContains } from '@chainsafe/netmask'\nimport { getNetConfig } from './get-net-config.ts'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\n/**\n * Check if a given multiaddr is an IPv6 global unicast address\n */\nexport function isGlobalUnicast (ma: Multiaddr): boolean {\n  try {\n    const config = getNetConfig(ma)\n\n    switch (config.type) {\n      case 'ip6':\n        return cidrContains('2000::/3', config.host)\n      default:\n        return false\n    }\n  } catch {\n    return false\n  }\n}\n", "import { getNetConfig } from './get-net-config.ts'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\n/**\n * Check if a given multiaddr is a link-local address\n */\nexport function isLinkLocal (ma: Multiaddr): boolean {\n  try {\n    const config = getNetConfig(ma)\n\n    switch (config.type) {\n      case 'ip4':\n        return config.host.startsWith('169.254.')\n      case 'ip6':\n        return config.host.toLowerCase().startsWith('fe80')\n      default:\n        return false\n    }\n  } catch (err) {\n    return false\n  }\n}\n", "/**\n * Check if a given ip address is a loopback address\n */\nexport function isLoopbackAddr (ip: string) {\n  return /^127\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(ip) ||\n    /^::1$/.test(ip)\n}\n", "import { isLoopbackAddr } from 'is-loopback-addr'\nimport { getNetConfig } from './get-net-config.ts'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\n/**\n * Check if a given multiaddr is a loopback address.\n */\nexport function isLoopback (ma: Multiaddr): boolean {\n  try {\n    const config = getNetConfig(ma)\n\n    switch (config.type) {\n      case 'ip4':\n      case 'ip6':\n        return isLoopbackAddr(config.host)\n      default:\n        return false\n    }\n  } catch {\n    return false\n  }\n}\n", "import { getNetConfig } from './get-net-config.ts'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\n/**\n * Check if a given multiaddr is a network address\n */\nexport function isNetworkAddress (ma: Multiaddr): boolean {\n  try {\n    getNetConfig(ma)\n\n    return true\n  } catch {\n    return false\n  }\n}\n", "import { isIPv4, isIPv6 } from '@chainsafe/is-ip'\nimport { Netmask } from 'netmask'\n\nconst PRIVATE_IP_RANGES = [\n  '0.0.0.0/8',\n  '10.0.0.0/8',\n  '100.64.0.0/10',\n  '127.0.0.0/8',\n  '169.254.0.0/16',\n  '172.16.0.0/12',\n  '192.0.0.0/24',\n  '192.0.0.0/29',\n  '192.0.0.8/32',\n  '192.0.0.9/32',\n  '192.0.0.10/32',\n  '192.0.0.170/32',\n  '192.0.0.171/32',\n  '192.0.2.0/24',\n  '192.31.196.0/24',\n  '192.52.193.0/24',\n  '192.88.99.0/24',\n  '192.168.0.0/16',\n  '192.175.48.0/24',\n  '198.18.0.0/15',\n  '198.51.100.0/24',\n  '203.0.113.0/24',\n  '240.0.0.0/4',\n  '255.255.255.255/32'\n]\n\nconst NETMASK_RANGES = PRIVATE_IP_RANGES.map(ipRange => new Netmask(ipRange))\n\nfunction ipv4Check (ipAddr: string): boolean {\n  for (const r of NETMASK_RANGES) {\n    if (r.contains(ipAddr)) { return true }\n  }\n\n  return false\n}\n\nfunction isIpv4MappedIpv6 (ipAddr: string): boolean {\n  return /^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(ipAddr)\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc4291#section-2.5.5.2\n */\nfunction ipv4MappedIpv6Check (ipAddr: string): boolean {\n  const parts = ipAddr.split(':')\n\n  if (parts.length < 2) {\n    return false\n  }\n\n  const octet34 = parts[parts.length - 1].padStart(4, '0')\n  const octet12 = parts[parts.length - 2].padStart(4, '0')\n\n  const ip4 = `${parseInt(octet12.substring(0, 2), 16)}.${parseInt(octet12.substring(2), 16)}.${parseInt(octet34.substring(0, 2), 16)}.${parseInt(octet34.substring(2), 16)}`\n\n  return ipv4Check(ip4)\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc4291#section-2.2 example 3\n */\nfunction isIpv4EmbeddedIpv6 (ipAddr: string): boolean {\n  return /^::ffff:([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/.test(ipAddr)\n}\n\nfunction ipv4EmbeddedIpv6Check (ipAddr: string): boolean {\n  const parts = ipAddr.split(':')\n  const ip4 = parts[parts.length - 1]\n\n  return ipv4Check(ip4)\n}\n\nfunction ipv6Check (ipAddr: string): boolean {\n  return /^::$/.test(ipAddr) ||\n    /^::1$/.test(ipAddr) ||\n    /^64:ff9b::([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/.test(ipAddr) ||\n    /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) ||\n    /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) ||\n    /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) ||\n    /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) ||\n    /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) ||\n    /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ipAddr) ||\n    /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ipAddr) ||\n    /^ff([0-9a-fA-F]{2,2}):/i.test(ipAddr)\n}\n\nexport function isPrivateIp (ip: string): boolean | undefined {\n  if (isIPv4(ip)) {\n    return ipv4Check(ip)\n  }\n\n  if (isIpv4MappedIpv6(ip)) {\n    return ipv4MappedIpv6Check(ip)\n  }\n\n  if (isIpv4EmbeddedIpv6(ip)) {\n    return ipv4EmbeddedIpv6Check(ip)\n  }\n\n  if (isIPv6(ip)) {\n    return ipv6Check(ip)\n  }\n}\n", "import { isPrivateIp } from '../private-ip.js'\nimport { getNetConfig } from './get-net-config.ts'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\n/**\n * Check if a given multiaddr starts with a private address\n */\nexport function isPrivate (ma: Multiaddr): boolean {\n  try {\n    const config = getNetConfig(ma)\n\n    switch (config.type) {\n      case 'ip4':\n      case 'ip6':\n        return isPrivateIp(config.host) ?? false\n      default:\n        return config.host === 'localhost'\n    }\n  } catch {\n    return false\n  }\n}\n", "import type { Startable } from '@libp2p/interface'\n\nexport interface DebouncedFunction extends Startable {\n  (): void\n}\n\n/**\n * Returns a function wrapper that will only call the passed function once\n *\n * Important - the passed function should not throw or reject\n */\nexport function debounce (func: () => void | Promise<void>, wait: number): DebouncedFunction {\n  let timeout: ReturnType<typeof setTimeout> | undefined\n\n  const output = function (): void {\n    const later = function (): void {\n      timeout = undefined\n      void func()\n    }\n\n    clearTimeout(timeout)\n    timeout = setTimeout(later, wait)\n  }\n  output.start = (): void => {}\n  output.stop = (): void => {\n    clearTimeout(timeout)\n  }\n\n  return output\n}\n", "import { AbortError } from '@libp2p/interface'\nimport pDefer from 'p-defer'\nimport type { DeferredPromise } from 'p-defer'\n\nexport class JobRecipient<JobReturnType> {\n  public deferred: DeferredPromise<JobReturnType>\n  public signal?: AbortSignal\n\n  constructor (signal?: AbortSignal) {\n    this.signal = signal\n    this.deferred = pDefer()\n\n    this.onAbort = this.onAbort.bind(this)\n    this.signal?.addEventListener('abort', this.onAbort)\n  }\n\n  onAbort (): void {\n    this.deferred.reject(this.signal?.reason ?? new AbortError())\n  }\n\n  cleanup (): void {\n    this.signal?.removeEventListener('abort', this.onAbort)\n  }\n}\n", "import { AbortError } from '@libp2p/interface'\nimport { setMaxListeners } from 'main-event'\nimport { raceSignal } from 'race-signal'\nimport { JobRecipient } from './recipient.js'\nimport type { JobStatus } from './index.js'\nimport type { AbortOptions } from '@libp2p/interface'\n\n/**\n * Returns a random string\n */\nfunction randomId (): string {\n  return `${(parseInt(String(Math.random() * 1e9), 10)).toString()}${Date.now()}`\n}\n\nexport interface JobTimeline {\n  created: number\n  started?: number\n  finished?: number\n}\n\nexport class Job <JobOptions extends AbortOptions = AbortOptions, JobReturnType = unknown> {\n  public id: string\n  public fn: (options: JobOptions) => Promise<JobReturnType>\n  public options: JobOptions\n  public recipients: Array<JobRecipient<JobReturnType>>\n  public status: JobStatus\n  public readonly timeline: JobTimeline\n  private readonly controller: AbortController\n\n  constructor (fn: (options: JobOptions) => Promise<JobReturnType>, options: any) {\n    this.id = randomId()\n    this.status = 'queued'\n    this.fn = fn\n    this.options = options\n    this.recipients = []\n    this.timeline = {\n      created: Date.now()\n    }\n\n    this.controller = new AbortController()\n    setMaxListeners(Infinity, this.controller.signal)\n\n    this.onAbort = this.onAbort.bind(this)\n  }\n\n  abort (err: Error): void {\n    this.controller.abort(err)\n  }\n\n  onAbort (): void {\n    const allAborted = this.recipients.reduce((acc, curr) => {\n      return acc && (curr.signal?.aborted === true)\n    }, true)\n\n    // if all recipients have aborted the job, actually abort the job\n    if (allAborted) {\n      this.controller.abort(new AbortError())\n      this.cleanup()\n    }\n  }\n\n  async join (options: AbortOptions = {}): Promise<JobReturnType> {\n    const recipient = new JobRecipient<JobReturnType>(options.signal)\n    this.recipients.push(recipient)\n\n    options.signal?.addEventListener('abort', this.onAbort)\n\n    return recipient.deferred.promise\n  }\n\n  async run (): Promise<void> {\n    this.status = 'running'\n    this.timeline.started = Date.now()\n\n    try {\n      this.controller.signal.throwIfAborted()\n\n      const result = await raceSignal(this.fn({\n        ...(this.options ?? {}),\n        signal: this.controller.signal\n      }), this.controller.signal)\n\n      this.recipients.forEach(recipient => {\n        recipient.deferred.resolve(result)\n      })\n\n      this.status = 'complete'\n    } catch (err) {\n      this.recipients.forEach(recipient => {\n        recipient.deferred.reject(err)\n      })\n\n      this.status = 'errored'\n    } finally {\n      this.timeline.finished = Date.now()\n      this.cleanup()\n    }\n  }\n\n  cleanup (): void {\n    this.recipients.forEach(recipient => {\n      recipient.cleanup()\n      recipient.signal?.removeEventListener('abort', this.onAbort)\n    })\n  }\n}\n", "import { AbortError } from '@libp2p/interface'\nimport { pushable } from 'it-pushable'\nimport { TypedEventEmitter } from 'main-event'\nimport { pEvent } from 'p-event'\nimport { debounce } from '../debounce.js'\nimport { QueueFullError } from '../errors.js'\nimport { Job } from './job.js'\nimport type { AbortOptions, Metrics } from '@libp2p/interface'\n\nexport type { Job, JobTimeline } from './job.js'\nexport type { JobRecipient } from './recipient.js'\n\nexport interface Comparator<T> {\n  (a: T, b: T): -1 | 0 | 1\n}\n\nexport interface QueueInit<JobReturnType, JobOptions extends AbortOptions = AbortOptions> {\n  /**\n   * Concurrency limit.\n   *\n   * Minimum: `1`.\n   *\n   * @default Infinity\n   */\n  concurrency?: number\n\n  /**\n   * If the queue size grows to larger than this number the promise returned\n   * from the add function will reject\n   *\n   * @default Infinity\n   */\n  maxSize?: number\n\n  /**\n   * The name of the metric for the queue length\n   */\n  metricName?: string\n\n  /**\n   * An implementation of the libp2p Metrics interface\n   */\n  metrics?: Metrics\n\n  /**\n   * An optional function that will sort the queue after a job has been added\n   */\n  sort?: Comparator<Job<JobOptions, JobReturnType>>\n}\n\nexport type JobStatus = 'queued' | 'running' | 'errored' | 'complete'\n\nexport interface RunFunction<Options extends AbortOptions = AbortOptions, ReturnType = void> {\n  (options: Options): Promise<ReturnType>\n}\n\nexport interface JobMatcher<JobOptions extends AbortOptions = AbortOptions> {\n  (options?: Partial<JobOptions>): boolean\n}\n\nexport interface QueueJobSuccess<JobReturnType, JobOptions extends AbortOptions = AbortOptions> {\n  job: Job<JobOptions, JobReturnType>\n  result: JobReturnType\n}\n\nexport interface QueueJobFailure<JobReturnType, JobOptions extends AbortOptions = AbortOptions> {\n  job: Job<JobOptions, JobReturnType>\n  error: Error\n}\n\nexport interface QueueEvents<JobReturnType, JobOptions extends AbortOptions = AbortOptions> {\n  /**\n   * A job is about to start running\n   */\n  active: CustomEvent\n\n  /**\n   * All jobs have finished and the queue is empty\n   */\n  idle: CustomEvent\n\n  /**\n   * The queue is empty, jobs may be running\n   */\n  empty: CustomEvent\n\n  /**\n   * A job was added to the queue\n   */\n  add: CustomEvent\n\n  /**\n   * A job has finished or failed\n   */\n  next: CustomEvent\n\n  /**\n   * A job has finished successfully\n   */\n  completed: CustomEvent<JobReturnType>\n\n  /**\n   * Emitted just after `\"completed\", a job has finished successfully - this\n   * event gives access to the job and it's result\n   */\n  success: CustomEvent<QueueJobSuccess<JobReturnType, JobOptions>>\n\n  /**\n   * Emitted just after `\"error\", a job has failed - this event gives access to\n   * the job and the thrown error\n   */\n  failure: CustomEvent<QueueJobFailure<JobReturnType, JobOptions>>\n}\n\n/**\n * Heavily influence by `p-queue` with the following differences:\n *\n * 1. Items remain at the head of the queue while they are running so `queue.size` includes `queue.pending` items - this is so interested parties can join the results of a queue item while it is running\n * 2. The options for a job are stored separately to the job in order for them to be modified while they are still in the queue\n */\nexport class Queue<JobReturnType = unknown, JobOptions extends AbortOptions = AbortOptions> extends TypedEventEmitter<QueueEvents<JobReturnType, JobOptions>> {\n  public concurrency: number\n  public maxSize: number\n  public queue: Array<Job<JobOptions, JobReturnType>>\n  private pending: number\n  private readonly sort?: Comparator<Job<JobOptions, JobReturnType>>\n  private paused: boolean\n\n  constructor (init: QueueInit<JobReturnType, JobOptions> = {}) {\n    super()\n\n    this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY\n    this.maxSize = init.maxSize ?? Number.POSITIVE_INFINITY\n    this.pending = 0\n    this.paused = false\n\n    if (init.metricName != null) {\n      init.metrics?.registerMetricGroup(init.metricName, {\n        calculate: () => {\n          return {\n            size: this.queue.length,\n            running: this.pending,\n            queued: this.queue.length - this.pending\n          }\n        }\n      })\n    }\n\n    this.sort = init.sort\n    this.queue = []\n\n    this.emitEmpty = debounce(this.emitEmpty.bind(this), 1)\n    this.emitIdle = debounce(this.emitIdle.bind(this), 1)\n  }\n\n  emitEmpty (): void {\n    if (this.size !== 0) {\n      return\n    }\n\n    this.safeDispatchEvent('empty')\n  }\n\n  emitIdle (): void {\n    if (this.running !== 0) {\n      return\n    }\n\n    this.safeDispatchEvent('idle')\n  }\n\n  pause (): void {\n    this.paused = true\n  }\n\n  resume (): void {\n    if (!this.paused) {\n      return\n    }\n\n    this.paused = false\n    this.tryToStartAnother()\n  }\n\n  private tryToStartAnother (): boolean {\n    if (this.paused) {\n      return false\n    }\n\n    if (this.size === 0) {\n      this.emitEmpty()\n\n      if (this.running === 0) {\n        this.emitIdle()\n      }\n\n      return false\n    }\n\n    if (this.pending < this.concurrency) {\n      let job: Job<JobOptions, JobReturnType> | undefined\n\n      for (const j of this.queue) {\n        if (j.status === 'queued') {\n          job = j\n          break\n        }\n      }\n\n      if (job == null) {\n        return false\n      }\n\n      this.safeDispatchEvent('active')\n\n      this.pending++\n\n      void job.run()\n        .finally(() => {\n          // remove the job from the queue\n          for (let i = 0; i < this.queue.length; i++) {\n            if (this.queue[i] === job) {\n              this.queue.splice(i, 1)\n              break\n            }\n          }\n\n          this.pending--\n          this.tryToStartAnother()\n          this.safeDispatchEvent('next')\n        })\n\n      return true\n    }\n\n    return false\n  }\n\n  private enqueue (job: Job<JobOptions, JobReturnType>): void {\n    this.queue.push(job)\n\n    if (this.sort != null) {\n      this.queue.sort(this.sort)\n    }\n  }\n\n  /**\n   * Adds a sync or async task to the queue. Always returns a promise.\n   */\n  async add (fn: RunFunction<JobOptions, JobReturnType>, options?: JobOptions): Promise<JobReturnType> {\n    options?.signal?.throwIfAborted()\n\n    if (this.size === this.maxSize) {\n      throw new QueueFullError()\n    }\n\n    const job = new Job<JobOptions, JobReturnType>(fn, options)\n    this.enqueue(job)\n    this.safeDispatchEvent('add')\n    this.tryToStartAnother()\n\n    return job.join(options)\n      .then(result => {\n        this.safeDispatchEvent('completed', { detail: result })\n        this.safeDispatchEvent('success', { detail: { job, result } })\n\n        return result\n      })\n      .catch(err => {\n        if (job.status === 'queued') {\n          // job was aborted before it started - remove the job from the queue\n          for (let i = 0; i < this.queue.length; i++) {\n            if (this.queue[i] === job) {\n              this.queue.splice(i, 1)\n              break\n            }\n          }\n        }\n\n        this.safeDispatchEvent('failure', { detail: { job, error: err } })\n\n        throw err\n      })\n  }\n\n  /**\n   * Clear the queue\n   */\n  clear (): void {\n    this.queue.splice(0, this.queue.length)\n  }\n\n  /**\n   * Abort all jobs in the queue and clear it\n   */\n  abort (): void {\n    this.queue.forEach(job => {\n      job.abort(new AbortError())\n    })\n\n    this.clear()\n  }\n\n  /**\n   * Can be called multiple times. Useful if you for example add additional items at a later time.\n   *\n   * @returns A promise that settles when the queue becomes empty.\n   */\n  async onEmpty (options?: AbortOptions): Promise<void> {\n    // Instantly resolve if the queue is empty\n    if (this.size === 0) {\n      return\n    }\n\n    await pEvent(this, 'empty', options)\n  }\n\n  /**\n   * @returns A promise that settles when the queue size is less than the given\n   * limit: `queue.size < limit`.\n   *\n   * If you want to avoid having the queue grow beyond a certain size you can\n   * `await queue.onSizeLessThan()` before adding a new item.\n   *\n   * Note that this only limits the number of items waiting to start. There\n   * could still be up to `concurrency` jobs already running that this call does\n   * not include in its calculation.\n   */\n  async onSizeLessThan (limit: number, options?: AbortOptions): Promise<void> {\n    // Instantly resolve if the queue is empty.\n    if (this.size < limit) {\n      return\n    }\n\n    await pEvent(this, 'next', {\n      ...options,\n      filter: () => this.size < limit\n    })\n  }\n\n  /**\n   * The difference with `.onEmpty` is that `.onIdle` guarantees that all work\n   * from the queue has finished. `.onEmpty` merely signals that the queue is\n   * empty, but it could mean that some promises haven't completed yet.\n   *\n   * @returns A promise that settles when the queue becomes empty, and all\n   * promises have completed; `queue.size === 0 && queue.pending === 0`.\n   */\n  async onIdle (options?: AbortOptions): Promise<void> {\n    // Instantly resolve if none pending and if nothing else is queued\n    if (this.pending === 0 && this.size === 0) {\n      return\n    }\n\n    await pEvent(this, 'idle', options)\n  }\n\n  /**\n   * Size of the queue including running items\n   */\n  get size (): number {\n    return this.queue.length\n  }\n\n  /**\n   * The number of queued items waiting to run.\n   */\n  get queued (): number {\n    return this.queue.length - this.pending\n  }\n\n  /**\n   * The number of items currently running.\n   */\n  get running (): number {\n    return this.pending\n  }\n\n  /**\n   * Returns an async generator that makes it easy to iterate over the results\n   * of jobs added to the queue.\n   *\n   * The generator will end when the queue becomes idle, that is there are no\n   * jobs running and no jobs that have yet to run.\n   *\n   * If you need to keep the queue open indefinitely, consider using it-pushable\n   * instead.\n   */\n  async * toGenerator (options?: AbortOptions): AsyncGenerator<JobReturnType, void, unknown> {\n    options?.signal?.throwIfAborted()\n\n    const stream = pushable<JobReturnType>({\n      objectMode: true\n    })\n\n    const cleanup = (err?: Error): void => {\n      if (err != null) {\n        this.abort()\n      } else {\n        this.clear()\n      }\n\n      stream.end(err)\n    }\n\n    const onQueueJobComplete = (evt: CustomEvent<JobReturnType>): void => {\n      if (evt.detail != null) {\n        stream.push(evt.detail)\n      }\n    }\n\n    const onQueueFailure = (evt: CustomEvent<QueueJobFailure<JobReturnType, JobOptions>>): void => {\n      cleanup(evt.detail.error)\n    }\n\n    const onQueueIdle = (): void => {\n      cleanup()\n    }\n\n    // clear the queue and throw if the query is aborted\n    const onSignalAbort = (): void => {\n      cleanup(new AbortError('Queue aborted'))\n    }\n\n    // add listeners\n    this.addEventListener('completed', onQueueJobComplete)\n    this.addEventListener('failure', onQueueFailure)\n    this.addEventListener('idle', onQueueIdle)\n    options?.signal?.addEventListener('abort', onSignalAbort)\n\n    try {\n      yield * stream\n    } finally {\n      // remove listeners\n      this.removeEventListener('completed', onQueueJobComplete)\n      this.removeEventListener('failure', onQueueFailure)\n      this.removeEventListener('idle', onQueueIdle)\n      options?.signal?.removeEventListener('abort', onSignalAbort)\n\n      // empty the queue for when the user has broken out of a loop early\n      cleanup()\n    }\n  }\n}\n", "import { StreamResetError, TypedEventEmitter, StreamMessageEvent, StreamBufferError, StreamResetEvent, StreamAbortEvent, StreamCloseEvent, StreamStateError } from '@libp2p/interface'\nimport { pushable } from 'it-pushable'\nimport { raceSignal } from 'race-signal'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { StreamClosedError } from './errors.ts'\nimport type { MessageStreamEvents, MessageStreamStatus, MessageStream, AbortOptions, MessageStreamTimeline, MessageStreamDirection, EventHandler, StreamOptions, MessageStreamReadStatus, MessageStreamWriteStatus } from '@libp2p/interface'\nimport type { Logger } from '@libp2p/logger'\n\nconst DEFAULT_MAX_READ_BUFFER_LENGTH = Math.pow(2, 20) * 4 // 4MB\n\nexport interface MessageStreamInit extends StreamOptions {\n  /**\n   * A Logger implementation used to log stream-specific information\n   */\n  log: Logger\n\n  /**\n   * The stream direction\n   */\n  direction?: MessageStreamDirection\n\n  /**\n   * By default all available bytes are passed to the `sendData` method of\n   * extending classes, if smaller chunks are required, pass a value here.\n   */\n  maxMessageSize?: number\n}\n\nexport interface SendResult {\n  /**\n   * The number of bytes from the passed buffer that were sent\n   */\n  sentBytes: number\n\n  /**\n   * If the underlying resource can accept more data immediately. If `true`,\n   * `sent` must equal the `.byteLength` of the buffer passed to `sendData`.\n   */\n  canSendMore: boolean\n}\n\nexport abstract class AbstractMessageStream<Timeline extends MessageStreamTimeline = MessageStreamTimeline> extends TypedEventEmitter<MessageStreamEvents> implements MessageStream {\n  public status: MessageStreamStatus\n  public readonly timeline: Timeline\n  public inactivityTimeout: number\n  public maxReadBufferLength: number\n  public maxWriteBufferLength?: number\n  public readonly log: Logger\n  public direction: MessageStreamDirection\n  public maxMessageSize?: number\n\n  public readStatus: MessageStreamReadStatus\n  public writeStatus: MessageStreamWriteStatus\n  public remoteReadStatus: MessageStreamReadStatus\n  public remoteWriteStatus: MessageStreamWriteStatus\n\n  public writableNeedsDrain: boolean\n\n  /**\n   * Any data stored here is emitted before any new incoming data.\n   *\n   * This is used when the stream is paused or if data is pushed onto the stream\n   */\n  protected readonly readBuffer: Uint8ArrayList\n  protected readonly writeBuffer: Uint8ArrayList\n  protected sendingData: boolean\n\n  private onDrainPromise?: PromiseWithResolvers<void>\n\n  constructor (init: MessageStreamInit) {\n    super()\n\n    this.status = 'open'\n    this.log = init.log\n    this.direction = init.direction ?? 'outbound'\n    this.inactivityTimeout = init.inactivityTimeout ?? 120_000\n    this.maxReadBufferLength = init.maxReadBufferLength ?? DEFAULT_MAX_READ_BUFFER_LENGTH\n    this.maxWriteBufferLength = init.maxWriteBufferLength\n    this.maxMessageSize = init.maxMessageSize\n    this.readBuffer = new Uint8ArrayList()\n    this.writeBuffer = new Uint8ArrayList()\n\n    this.readStatus = 'readable'\n    this.remoteReadStatus = 'readable'\n    this.writeStatus = 'writable'\n    this.remoteWriteStatus = 'writable'\n    this.sendingData = false\n    this.writableNeedsDrain = false\n\n    // @ts-expect-error type could have required fields other than 'open'\n    this.timeline = {\n      open: Date.now()\n    }\n\n    this.processSendQueue = this.processSendQueue.bind(this)\n\n    const continueSendingOnDrain = (): void => {\n      if (this.writableNeedsDrain) {\n        this.log.trace('drain event received, continue sending data')\n        this.writableNeedsDrain = false\n        this.processSendQueue()\n      }\n\n      this.onDrainPromise?.resolve()\n    }\n    this.addEventListener('drain', continueSendingOnDrain)\n\n    const rejectOnDrainOnClose = (evt: StreamCloseEvent): void => {\n      this.onDrainPromise?.reject(evt.error ?? new StreamClosedError())\n    }\n    this.addEventListener('close', rejectOnDrainOnClose)\n  }\n\n  get readBufferLength (): number {\n    return this.readBuffer.byteLength\n  }\n\n  get writeBufferLength (): number {\n    return this.writeBuffer.byteLength\n  }\n\n  async onDrain (options?: AbortOptions): Promise<void> {\n    if (this.writableNeedsDrain !== true) {\n      return Promise.resolve()\n    }\n\n    if (this.onDrainPromise == null) {\n      this.onDrainPromise = Promise.withResolvers()\n    }\n\n    return raceSignal(this.onDrainPromise.promise, options?.signal)\n  }\n\n  async * [Symbol.asyncIterator] (): AsyncGenerator<Uint8Array | Uint8ArrayList> {\n    if (this.readStatus !== 'readable' && this.readStatus !== 'paused') {\n      return\n    }\n\n    const output = pushable<Uint8Array | Uint8ArrayList>()\n\n    const streamAsyncIterableOnMessageListener = (evt: StreamMessageEvent): void => {\n      output.push(evt.data)\n    }\n    this.addEventListener('message', streamAsyncIterableOnMessageListener)\n\n    const streamAsyncIterableOnCloseListener = (evt: StreamCloseEvent): void => {\n      output.end(evt.error)\n    }\n    this.addEventListener('close', streamAsyncIterableOnCloseListener)\n\n    const streamAsyncIterableOnRemoteCloseWriteListener = (): void => {\n      output.end()\n    }\n    this.addEventListener('remoteCloseWrite', streamAsyncIterableOnRemoteCloseWriteListener)\n\n    try {\n      yield * output\n    } finally {\n      this.removeEventListener('message', streamAsyncIterableOnMessageListener)\n      this.removeEventListener('close', streamAsyncIterableOnCloseListener)\n      this.removeEventListener('remoteCloseWrite', streamAsyncIterableOnRemoteCloseWriteListener)\n    }\n  }\n\n  isReadable (): boolean {\n    return this.status === 'open'\n  }\n\n  send (data: Uint8Array | Uint8ArrayList): boolean {\n    if (this.writeStatus === 'closed' || this.writeStatus === 'closing') {\n      throw new StreamStateError(`Cannot write to a stream that is ${this.writeStatus}`)\n    }\n\n    this.log.trace('append %d bytes to write buffer', data.byteLength)\n    this.writeBuffer.append(data)\n\n    return this.processSendQueue()\n  }\n\n  /**\n   * Close immediately for reading and writing and send a reset message (local\n   * error)\n   */\n  abort (err: Error): void {\n    if (this.status === 'aborted' || this.status === 'reset' || this.status === 'closed') {\n      return\n    }\n\n    this.log.error('abort with error - %e', err)\n\n    this.status = 'aborted'\n\n    // throw away unread data\n    if (this.readBuffer.byteLength > 0) {\n      this.readBuffer.consume(this.readBuffer.byteLength)\n    }\n\n    // throw away unsent data\n    if (this.writeBuffer.byteLength > 0) {\n      this.writeBuffer.consume(this.writeBuffer.byteLength)\n      this.safeDispatchEvent('idle')\n    }\n\n    this.writeStatus = 'closed'\n    this.remoteWriteStatus = 'closed'\n\n    this.readStatus = 'closed'\n    this.remoteReadStatus = 'closed'\n    this.timeline.close = Date.now()\n\n    try {\n      this.sendReset(err)\n    } catch (err: any) {\n      this.log('failed to send reset to remote - %e', err)\n    }\n\n    this.dispatchEvent(new StreamAbortEvent(err))\n  }\n\n  pause (): void {\n    if (this.readStatus === 'closed' || this.readStatus === 'closing') {\n      throw new StreamStateError('Cannot pause a stream that is closing/closed')\n    }\n\n    if (this.readStatus === 'paused') {\n      return\n    }\n\n    this.readStatus = 'paused'\n    this.sendPause()\n  }\n\n  resume (): void {\n    if (this.readStatus === 'closed' || this.readStatus === 'closing') {\n      throw new StreamStateError('Cannot resume a stream that is closing/closed')\n    }\n\n    if (this.readStatus === 'readable') {\n      return\n    }\n\n    this.readStatus = 'readable'\n    // emit any data that accumulated while we were paused\n    this.dispatchReadBuffer()\n    this.sendResume()\n  }\n\n  push (data: Uint8Array | Uint8ArrayList): void {\n    if (this.readStatus === 'closed' || this.readStatus === 'closing') {\n      throw new StreamStateError(`Cannot push data onto a stream that is ${this.readStatus}`)\n    }\n\n    if (data.byteLength === 0) {\n      return\n    }\n\n    this.readBuffer.append(data)\n\n    if (this.readStatus === 'paused' || this.listenerCount('message') === 0) {\n      // abort if the read buffer is too large\n      this.checkReadBufferLength()\n\n      return\n    }\n\n    // TODO: use a microtask instead?\n    setTimeout(() => {\n      this.dispatchReadBuffer()\n    }, 0)\n  }\n\n  unshift (data: Uint8Array | Uint8ArrayList): void {\n    if (this.readStatus === 'closed' || this.readStatus === 'closing') {\n      throw new StreamStateError(`Cannot push data onto a stream that is ${this.readStatus}`)\n    }\n\n    if (data.byteLength === 0) {\n      return\n    }\n\n    this.readBuffer.prepend(data)\n\n    if (this.readStatus === 'paused' || this.listenerCount('message') === 0) {\n      // abort if the read buffer is too large\n      this.checkReadBufferLength()\n\n      return\n    }\n\n    // TODO: use a microtask instead?\n    setTimeout(() => {\n      this.dispatchReadBuffer()\n    }, 0)\n  }\n\n  /**\n   * When an extending class reads data from it's implementation-specific source,\n   * call this method to allow the stream consumer to read the data.\n   */\n  onData (data: Uint8Array | Uint8ArrayList): void {\n    if (data.byteLength === 0) {\n      // this.log('ignoring empty data')\n      return\n    }\n\n    // discard the data if our readable end is closed\n    if (this.readStatus === 'closing' || this.readStatus === 'closed') {\n      this.log('ignoring data - read status %s', this.readStatus)\n      return\n    }\n\n    this.readBuffer.append(data)\n    this.dispatchReadBuffer()\n  }\n\n  addEventListener<K extends keyof MessageStreamEvents>(type: K, listener: EventHandler<MessageStreamEvents[K]> | null, options?: boolean | AddEventListenerOptions): void\n  addEventListener (type: string, listener: EventHandler<Event>, options?: boolean | AddEventListenerOptions): void\n  addEventListener (...args: any[]): void {\n    // @ts-expect-error cannot ensure args has enough members\n    super.addEventListener.apply(this, args)\n\n    // if a 'message' listener is being added and we have queued data, dispatch\n    // the data\n    if (args[0] === 'message' && this.readBuffer.byteLength > 0) {\n      // event listeners can be added in constructors and often use object\n      // properties - if this the case we can access a class member before it\n      // has been initialized so dispatch the message in the microtask queue\n      queueMicrotask(() => {\n        this.dispatchReadBuffer()\n      })\n    }\n  }\n\n  /**\n   * Receive a reset message - close immediately for reading and writing (remote\n   * error)\n   */\n  onRemoteReset (): void {\n    this.log('remote reset')\n\n    this.status = 'reset'\n    this.writeStatus = 'closed'\n    this.remoteWriteStatus = 'closed'\n    this.remoteReadStatus = 'closed'\n    this.timeline.close = Date.now()\n\n    if (this.readBuffer.byteLength === 0) {\n      this.readStatus = 'closed'\n    }\n\n    const err = new StreamResetError()\n    this.dispatchEvent(new StreamResetEvent(err))\n  }\n\n  /**\n   * The underlying resource or transport this stream uses has closed - it is\n   * not possible to send any more messages though any data still in the read\n   * buffer may still be read\n   */\n  onTransportClosed (err?: Error): void {\n    this.log('transport closed')\n\n    if (this.readStatus === 'readable' && this.readBuffer.byteLength === 0) {\n      this.log('close readable end after transport closed and read buffer is empty')\n      this.readStatus = 'closed'\n    }\n\n    if (this.remoteReadStatus !== 'closed') {\n      this.remoteReadStatus = 'closed'\n    }\n\n    if (this.remoteWriteStatus !== 'closed') {\n      this.remoteWriteStatus = 'closed'\n    }\n\n    if (this.writeStatus !== 'closed') {\n      this.writeStatus = 'closed'\n    }\n\n    if (err != null) {\n      this.abort(err)\n    } else {\n      if (this.status === 'open' || this.status === 'closing') {\n        this.timeline.close = Date.now()\n        this.status = 'closed'\n        this.writeStatus = 'closed'\n        this.remoteWriteStatus = 'closed'\n        this.remoteReadStatus = 'closed'\n        this.dispatchEvent(new StreamCloseEvent())\n      }\n    }\n  }\n\n  /**\n   * Called by extending classes when the remote closes its writable end\n   */\n  onRemoteCloseWrite (): void {\n    if (this.remoteWriteStatus === 'closed') {\n      return\n    }\n\n    this.log.trace('on remote close write')\n\n    this.remoteWriteStatus = 'closed'\n\n    this.safeDispatchEvent('remoteCloseWrite')\n\n    if (this.writeStatus === 'closed') {\n      this.onTransportClosed()\n    }\n  }\n\n  /**\n   * Called by extending classes when the remote closes its readable end\n   */\n  onRemoteCloseRead (): void {\n    this.log.trace('on remote close read')\n\n    this.remoteReadStatus = 'closed'\n\n    // throw away any unsent bytes if the remote closes it's readable end\n    if (this.writeBuffer.byteLength > 0) {\n      this.writeBuffer.consume(this.writeBuffer.byteLength)\n      this.safeDispatchEvent('idle')\n    }\n  }\n\n  protected processSendQueue (): boolean {\n    // bail if the underlying transport is full\n    if (this.writableNeedsDrain) {\n      this.log.trace('not processing send queue as drain is required')\n      this.checkWriteBufferLength()\n\n      return false\n    }\n\n    // bail if there is no data to send\n    if (this.writeBuffer.byteLength === 0) {\n      this.log.trace('not processing send queue as no bytes to send')\n      return true\n    }\n\n    // bail if we are already sending data\n    if (this.sendingData) {\n      this.log.trace('not processing send queue as already sending data')\n      return true\n    }\n\n    this.sendingData = true\n\n    this.log.trace('processing send queue with %d queued bytes', this.writeBuffer.byteLength)\n\n    try {\n      let canSendMore = true\n      const totalBytes = this.writeBuffer.byteLength\n      let sentBytes = 0\n\n      // send as much data as possible while we have data to send and the\n      // underlying muxer can still accept data\n      while (this.writeBuffer.byteLength > 0) {\n        const end = Math.min(this.maxMessageSize ?? this.writeBuffer.byteLength, this.writeBuffer.byteLength)\n\n        // this can happen if a subclass changes the max message size dynamically\n        if (end === 0) {\n          canSendMore = false\n          break\n        }\n\n        // chunk to send to the remote end\n        const toSend = this.writeBuffer.sublist(0, end)\n\n        // copy toSend in case the extending class modifies the list\n        const willSend = new Uint8ArrayList(toSend)\n\n        this.writeBuffer.consume(toSend.byteLength)\n\n        // sending data can cause buffers to fill up, events to be emitted and\n        // this method to be invoked again\n        const sendResult = this.sendData(toSend)\n        canSendMore = sendResult.canSendMore\n        sentBytes += sendResult.sentBytes\n\n        if (sendResult.sentBytes !== willSend.byteLength) {\n          willSend.consume(sendResult.sentBytes)\n          this.writeBuffer.prepend(willSend)\n        }\n\n        if (!canSendMore) {\n          break\n        }\n      }\n\n      if (!canSendMore) {\n        this.log.trace('sent %d/%d bytes, pausing sending because underlying stream is full, %d bytes left in the write buffer', sentBytes, totalBytes, this.writeBuffer.byteLength)\n        this.writableNeedsDrain = true\n        this.checkWriteBufferLength()\n      }\n\n      // we processed all bytes in the queue, resolve the write queue idle promise\n      if (this.writeBuffer.byteLength === 0) {\n        this.safeDispatchEvent('idle')\n      }\n\n      return canSendMore\n    } finally {\n      this.sendingData = false\n    }\n  }\n\n  protected dispatchReadBuffer (): void {\n    try {\n      if (this.listenerCount('message') === 0) {\n        this.log.trace('not dispatching pause buffer as there are no listeners for the message event')\n        return\n      }\n\n      if (this.readBuffer.byteLength === 0) {\n        this.log.trace('not dispatching pause buffer as there is no data to dispatch')\n        return\n      }\n\n      if (this.readStatus === 'paused') {\n        this.log.trace('not dispatching pause buffer we are paused')\n        return\n      }\n\n      // discard the pause buffer if our readable end is closed\n      if (this.readStatus === 'closing' || this.readStatus === 'closed') {\n        this.log('dropping %d bytes because the readable end is %s', this.readBuffer.byteLength, this.readStatus)\n        this.readBuffer.consume(this.readBuffer.byteLength)\n        return\n      }\n\n      const buf = this.readBuffer.sublist()\n      this.readBuffer.consume(buf.byteLength)\n\n      this.dispatchEvent(new StreamMessageEvent(buf))\n    } finally {\n      if (this.readBuffer.byteLength === 0 && this.remoteWriteStatus === 'closed') {\n        this.log('close readable end after dispatching read buffer and remote writable end is closed')\n        this.readStatus = 'closed'\n      }\n\n      // abort if we failed to consume the read buffer and it is too large\n      this.checkReadBufferLength()\n    }\n  }\n\n  private checkReadBufferLength (): void {\n    if (this.readBuffer.byteLength > this.maxReadBufferLength) {\n      this.abort(new StreamBufferError(`Read buffer length of ${this.readBuffer.byteLength} exceeded limit of ${this.maxReadBufferLength}, read status is ${this.readStatus}`))\n    }\n  }\n\n  private checkWriteBufferLength (): void {\n    if (this.maxWriteBufferLength == null) {\n      return\n    }\n\n    if (this.writeBuffer.byteLength > this.maxWriteBufferLength) {\n      this.abort(new StreamBufferError(`Write buffer length of ${this.writeBuffer.byteLength} exceeded limit of ${this.maxWriteBufferLength}, write status is ${this.writeStatus}`))\n    }\n  }\n\n  public onMuxerNeedsDrain (): void {\n    this.writableNeedsDrain = true\n  }\n\n  public onMuxerDrain (): void {\n    this.safeDispatchEvent('drain')\n  }\n\n  /**\n   * Send a data message to the remote end of the stream. Implementations of\n   * this method should return the number of bytes from the passed buffer that\n   * were sent successfully and if the underlying resource can accept more data.\n   *\n   * The implementation should always attempt to send the maximum amount of data\n   * possible.\n   *\n   * Returning a result that means the data was only partially sent but that the\n   * underlying resource can accept more data is invalid.\n   */\n  abstract sendData (data: Uint8ArrayList): SendResult\n\n  /**\n   * Send a reset message to the remote end of the stream\n   */\n  abstract sendReset (err: Error): void\n\n  /**\n   * If supported, instruct the remote end of the stream to temporarily stop\n   * sending data messages\n   */\n  abstract sendPause (): void\n\n  /**\n   * If supported, inform the remote end of the stream they may resume sending\n   * data messages\n   */\n  abstract sendResume (): void\n\n  /**\n   * Stop accepting new data to send and return a promise that resolves when any\n   * unsent data has been written into the underlying resource.\n   */\n  abstract close (options?: AbortOptions): Promise<void>\n}\n", "import { pEvent } from 'p-event'\nimport { AbstractMessageStream } from './abstract-message-stream.ts'\nimport type { MessageStreamInit } from './abstract-message-stream.ts'\nimport type { CounterGroup, Logger, MultiaddrConnection, MessageStreamDirection, AbortOptions } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport interface AbstractMultiaddrConnectionInit extends Omit<MessageStreamInit, 'log'> {\n  remoteAddr: Multiaddr\n  direction: MessageStreamDirection\n  log: Logger\n  inactivityTimeout?: number\n  localAddr?: Multiaddr\n  metricPrefix?: string\n  metrics?: CounterGroup\n}\n\nexport abstract class AbstractMultiaddrConnection extends AbstractMessageStream implements MultiaddrConnection {\n  public remoteAddr: Multiaddr\n\n  private metricPrefix: string\n  private metrics?: CounterGroup\n\n  constructor (init: AbstractMultiaddrConnectionInit) {\n    super(init)\n\n    this.metricPrefix = init.metricPrefix ?? ''\n    this.metrics = init.metrics\n    this.remoteAddr = init.remoteAddr\n\n    this.addEventListener('close', (evt) => {\n      this.metrics?.increment({ [`${this.metricPrefix}end`]: true })\n\n      if (evt.error != null) {\n        if (evt.local) {\n          this.metrics?.increment({ [`${this.metricPrefix}abort`]: true })\n        } else {\n          this.metrics?.increment({ [`${this.metricPrefix}reset`]: true })\n        }\n      } else {\n        if (evt.local) {\n          this.metrics?.increment({ [`${this.metricPrefix}_local_close`]: true })\n        } else {\n          this.metrics?.increment({ [`${this.metricPrefix}_remote_close`]: true })\n        }\n      }\n    })\n  }\n\n  async close (options?: AbortOptions): Promise<void> {\n    if (this.status !== 'open') {\n      return\n    }\n\n    this.status = 'closing'\n    this.writeStatus = 'closing'\n    this.remoteWriteStatus = 'closing'\n    this.remoteReadStatus = 'closing'\n\n    // if we are currently sending data, wait for all the data to be written\n    // into the underlying transport\n    if (this.sendingData || this.writeBuffer.byteLength > 0) {\n      this.log('waiting for write queue to become idle before closing writable end of stream, %d unsent bytes', this.writeBuffer.byteLength)\n      await pEvent(this, 'idle', {\n        ...options,\n        rejectionEvents: [\n          'close'\n        ]\n      })\n    }\n\n    // now that the underlying transport has all the data, if the buffer is full\n    // wait for it to be emptied\n    if (this.writableNeedsDrain) {\n      this.log('waiting for write queue to drain before closing writable end of stream, %d unsent bytes', this.writeBuffer.byteLength)\n      await pEvent(this, 'drain', {\n        ...options,\n        rejectionEvents: [\n          'close'\n        ]\n      })\n    }\n\n    await this.sendClose(options)\n\n    this.onTransportClosed()\n  }\n\n  /**\n   * Wait for any unsent data to be written to the underlying resource, then\n   * close the resource and resolve the returned promise\n   */\n  abstract sendClose (options?: AbortOptions): Promise<void>\n}\n", "export function isPromise <T = unknown> (thing: any): thing is Promise<T> {\n  if (thing == null) {\n    return false\n  }\n\n  return typeof thing.then === 'function' &&\n    typeof thing.catch === 'function' &&\n    typeof thing.finally === 'function'\n}\n", "import { MuxerClosedError, TypedEventEmitter } from '@libp2p/interface'\nimport { raceSignal } from 'race-signal'\nimport { MaxEarlyStreamsError } from './errors.ts'\nimport { isPromise } from './is-promise.ts'\nimport type { AbstractStream } from './abstract-stream.ts'\nimport type { AbortOptions, CounterGroup, CreateStreamOptions, EventHandler, Logger, MessageStream, Stream, StreamCloseEvent, StreamMessageEvent, StreamMuxer, StreamMuxerEvents, StreamMuxerOptions, StreamMuxerStatus, StreamOptions } from '@libp2p/interface'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface AbstractStreamMuxerInit extends StreamMuxerOptions {\n  /**\n   * The protocol name for the muxer\n   */\n  protocol: string\n\n  /**\n   * The name of the muxer, used to create a new logging scope from the passed\n   * connection's logger\n   */\n  name: string\n\n  /**\n   * A counter for muxer metrics\n   */\n  metrics?: CounterGroup\n}\n\nexport abstract class AbstractStreamMuxer <MuxedStream extends AbstractStream = AbstractStream> extends TypedEventEmitter<StreamMuxerEvents<MuxedStream>> implements StreamMuxer<MuxedStream> {\n  public streams: MuxedStream[]\n  public protocol: string\n  public status: StreamMuxerStatus\n\n  protected log: Logger\n  protected maConn: MessageStream\n  protected streamOptions?: StreamOptions\n  protected earlyStreams: MuxedStream[]\n  protected maxEarlyStreams: number\n\n  private readonly metrics?: CounterGroup\n\n  constructor (maConn: MessageStream, init: AbstractStreamMuxerInit) {\n    super()\n\n    this.maConn = maConn\n    this.protocol = init.protocol\n    this.streams = []\n    this.earlyStreams = []\n    this.status = 'open'\n    this.log = maConn.log.newScope(init.name)\n    this.streamOptions = init.streamOptions\n    this.maxEarlyStreams = init.maxEarlyStreams ?? 10\n    this.metrics = init.metrics\n\n    // read/write all data from/to underlying maConn\n    const muxerMaConnOnMessage = (evt: StreamMessageEvent): void => {\n      try {\n        this.onData(evt.data)\n      } catch (err: any) {\n        this.abort(err)\n        this.maConn.abort(err)\n      }\n    }\n    this.maConn.addEventListener('message', muxerMaConnOnMessage)\n\n    // signal stream writers when the underlying connection can accept more data\n    const muxerMaConnOnDrain = (): void => {\n      this.log('underlying stream drained, signal %d streams to continue writing', this.streams.length)\n\n      this.streams.forEach(stream => {\n        stream.onMuxerDrain()\n      })\n    }\n    this.maConn.addEventListener('drain', muxerMaConnOnDrain)\n\n    const muxerOnMaConnClose = (): void => {\n      this.log('underlying stream closed with status %s and %d streams', this.status, this.streams.length)\n      this.onTransportClosed()\n    }\n    this.maConn.addEventListener('close', muxerOnMaConnClose)\n  }\n\n  send (data: Uint8Array | Uint8ArrayList): boolean {\n    const result = this.maConn.send(data)\n\n    if (result === false) {\n      this.log('underlying stream saturated, signal %d streams to pause writing', this.streams.length)\n\n      this.streams.forEach(stream => {\n        stream.onMuxerNeedsDrain()\n      })\n    }\n\n    return result\n  }\n\n  async close (options?: AbortOptions): Promise<void> {\n    if (this.status === 'closed' || this.status === 'closing') {\n      return\n    }\n\n    this.status = 'closing'\n\n    await raceSignal(Promise.all(\n      [...this.streams].map(async s => {\n        await s.close(options)\n      })\n    ), options?.signal)\n\n    this.status = 'closed'\n  }\n\n  abort (err: Error): void {\n    if (this.status === 'closed') {\n      return\n    }\n\n    this.status = 'closing'\n\n    ;[...this.streams].forEach(s => {\n      s.abort(err)\n    })\n\n    this.status = 'closed'\n  }\n\n  onTransportClosed (err?: Error): void {\n    this.status = 'closing'\n\n    try {\n      [...this.streams].forEach(stream => {\n        stream.onTransportClosed(err)\n      })\n    } catch (err: any) {\n      this.abort(err)\n    }\n\n    this.status = 'closed'\n  }\n\n  async createStream (options?: CreateStreamOptions): Promise<MuxedStream> {\n    if (this.status !== 'open') {\n      throw new MuxerClosedError()\n    }\n\n    let stream = this.onCreateStream({\n      ...this.streamOptions,\n      ...options\n    })\n\n    if (isPromise(stream)) {\n      stream = await stream\n    }\n\n    this.streams.push(stream)\n    this.cleanUpStream(stream)\n\n    return stream\n  }\n\n  /**\n   * Extending classes should invoke this method when a new stream was created\n   * by the remote muxer\n   */\n  onRemoteStream (stream: MuxedStream): void {\n    this.streams.push(stream)\n    this.cleanUpStream(stream)\n\n    if (this.listenerCount('stream') === 0) {\n      // no listener has been added for the stream event yet, store the stream\n      // to emit it later\n      this.earlyStreams.push(stream)\n\n      if (this.earlyStreams.length > this.maxEarlyStreams) {\n        this.abort(new MaxEarlyStreamsError(`Too many early streams were opened - ${this.earlyStreams.length}/${this.maxEarlyStreams}`))\n      }\n\n      return\n    }\n\n    this.safeDispatchEvent('stream', {\n      detail: stream\n    })\n  }\n\n  private cleanUpStream (stream: Stream): void {\n    const muxerOnStreamEnd = (evt: StreamCloseEvent): void => {\n      const index = this.streams.findIndex(s => s === stream)\n\n      if (index !== -1) {\n        this.streams.splice(index, 1)\n      }\n\n      if (evt.error != null) {\n        if (evt.local) {\n          this.metrics?.increment({ [`${stream.direction}_stream_reset`]: true })\n        } else {\n          this.metrics?.increment({ [`${stream.direction}_stream_abort`]: true })\n        }\n      } else {\n        this.metrics?.increment({ [`${stream.direction}_stream_end`]: true })\n      }\n    }\n    stream.addEventListener('close', muxerOnStreamEnd)\n\n    this.metrics?.increment({ [`${stream.direction}_stream`]: true })\n  }\n\n  addEventListener<K extends keyof StreamMuxerEvents<MuxedStream>>(type: K, listener: EventHandler<StreamMuxerEvents<MuxedStream>[K]> | null, options?: boolean | AddEventListenerOptions): void\n  addEventListener (type: string, listener: EventHandler<Event>, options?: boolean | AddEventListenerOptions): void\n  addEventListener (...args: any[]): void {\n    // @ts-expect-error cannot ensure args has enough members\n    super.addEventListener.apply(this, args)\n\n    // if a 'stream' listener is being added and we have early streams, emit\n    // them\n    if (args[0] === 'stream' && this.earlyStreams.length > 0) {\n      // event listeners can be added in constructors and often use object\n      // properties - if this the case we can access a class member before it\n      // has been initialized so dispatch the message in the microtask queue\n      queueMicrotask(() => {\n        this.earlyStreams.forEach(stream => {\n          this.safeDispatchEvent('stream', {\n            detail: stream\n          })\n        })\n        this.earlyStreams = []\n      })\n    }\n  }\n\n  /**\n   * A new outgoing stream needs to be created\n   */\n  abstract onCreateStream (options: CreateStreamOptions): MuxedStream | Promise<MuxedStream>\n\n  /**\n   * Multiplexed data was received from the remote muxer\n   */\n  abstract onData (data: Uint8Array | Uint8ArrayList): void\n}\n", "import { pEvent } from 'p-event'\nimport { AbstractMessageStream } from './abstract-message-stream.js'\nimport type { MessageStreamInit } from './abstract-message-stream.js'\nimport type { AbortOptions, Stream } from '@libp2p/interface'\n\nexport interface AbstractStreamInit extends MessageStreamInit {\n  /**\n   * A unique identifier for this stream\n   */\n  id: string\n\n  /**\n   * The protocol name for the stream, if it is known\n   */\n  protocol?: string\n}\n\nexport abstract class AbstractStream extends AbstractMessageStream implements Stream {\n  public id: string\n  public protocol: string\n\n  constructor (init: AbstractStreamInit) {\n    super(init)\n\n    this.id = init.id\n    this.protocol = init.protocol ?? ''\n  }\n\n  async close (options?: AbortOptions): Promise<void> {\n    if (this.writeStatus === 'closing' || this.writeStatus === 'closed') {\n      return\n    }\n\n    this.writeStatus = 'closing'\n\n    // if we are currently sending data, wait for all the data to be written\n    // into the underlying transport\n    if (this.sendingData || this.writeBuffer.byteLength > 0) {\n      this.log('waiting for write queue to become idle before closing writable end of stream, %d unsent bytes', this.writeBuffer.byteLength)\n      await pEvent(this, 'idle', {\n        ...options,\n        rejectionEvents: [\n          'close'\n        ]\n      })\n    }\n\n    // now that the underlying transport has all the data, if the buffer is full\n    // wait for it to be emptied\n    if (this.writableNeedsDrain) {\n      this.log('waiting for write queue to drain before closing writable end of stream, %d unsent bytes, sending %s', this.writeBuffer.byteLength, this.sendingData)\n      await pEvent(this, 'drain', {\n        ...options,\n        rejectionEvents: [\n          'close'\n        ]\n      })\n      this.log('write queue drained, closing writable end of stream, %d unsent bytes, sending %s', this.writeBuffer.byteLength, this.sendingData)\n    }\n\n    await this.sendCloseWrite(options)\n\n    this.writeStatus = 'closed'\n\n    this.log('closed writable end gracefully')\n\n    if (this.remoteWriteStatus === 'closed') {\n      this.onTransportClosed()\n    }\n  }\n\n  async closeRead (options?: AbortOptions): Promise<void> {\n    if (this.readStatus === 'closing' || this.readStatus === 'closed') {\n      return\n    }\n\n    // throw away any unread data\n    if (this.readBuffer.byteLength > 0) {\n      this.readBuffer.consume(this.readBuffer.byteLength)\n    }\n\n    this.readStatus = 'closing'\n\n    await this.sendCloseRead(options)\n\n    this.readStatus = 'closed'\n\n    this.log('closed readable end gracefully')\n  }\n\n  /**\n   * Send a message to the remote end of the stream, informing them that we will\n   * send no more data messages.\n   */\n  abstract sendCloseWrite (options?: AbortOptions): Promise<void>\n\n  /**\n   * If supported, send a message to the remote end of the stream, informing\n   * them that we will read no more data messages.\n   */\n  abstract sendCloseRead (options?: AbortOptions): Promise<void>\n}\n", "/**\n * @packageDocumentation\n *\n * Similar to [AbortSignal.any](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/any_static)\n * except the returned promise has a `.clear` method that removes all event\n * listeners added to passed signals preventing memory leaks.\n *\n * At the time of writing at least, `AbortSignal.any` leaks memory in Node.js\n * and Deno environments:\n *\n * - https://github.com/nodejs/node/issues/54614\n * - https://github.com/denoland/deno/issues/24842\n *\n * @example\n *\n * ```js\n * import { anySignal } from 'any-signal'\n *\n * const userController = new AbortController()\n *\n * // Abort after 1 second\n * const timeoutSignal = AbortSignal.timeout(1000)\n *\n * const combinedSignal = anySignal([userController.signal, timeoutSignal])\n * combinedSignal.addEventListener('abort', () => console.log('Abort!'))\n *\n * try {\n *   // The user or the timeout can now abort the action\n *   await performSomeAction({ signal: combinedSignal })\n * } finally {\n *   // Clear will clean up internal event handlers\n *   combinedSignal.clear()\n * }\n * ```\n */\n\nexport interface ClearableSignal extends AbortSignal {\n  clear(): void\n}\n\n/**\n * Takes an array of AbortSignals and returns a single signal.\n * If any signals are aborted, the returned signal will be aborted.\n */\nexport function anySignal (signals: Array<AbortSignal | undefined | null>): ClearableSignal {\n  const controller = new globalThis.AbortController()\n\n  function onAbort (): void {\n    const reason = signals\n      .filter(s => s?.aborted === true)\n      .map(s => s?.reason)\n      .pop()\n\n    controller.abort(reason)\n\n    for (const signal of signals) {\n      if (signal?.removeEventListener != null) {\n        signal.removeEventListener('abort', onAbort)\n      }\n    }\n  }\n\n  for (const signal of signals) {\n    if (signal?.aborted === true) {\n      onAbort()\n      break\n    }\n\n    if (signal?.addEventListener != null) {\n      signal.addEventListener('abort', onAbort)\n    }\n  }\n\n  function clear (): void {\n    for (const signal of signals) {\n      if (signal?.removeEventListener != null) {\n        signal.removeEventListener('abort', onAbort)\n      }\n    }\n  }\n\n  const signal = controller.signal as ClearableSignal\n  signal.clear = clear\n\n  return signal\n}\n", "/**\n * Implements exponential moving average. Ported from `moving-average`.\n *\n * @see https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n * @see https://www.npmjs.com/package/moving-average\n */\nexport class MovingAverage {\n  public movingAverage: number\n  public variance: number\n  public deviation: number\n  public forecast: number\n  private readonly timeSpan: number\n  private previousTime?: number\n\n  constructor (timeSpan: number) {\n    this.timeSpan = timeSpan\n    this.movingAverage = 0\n    this.variance = 0\n    this.deviation = 0\n    this.forecast = 0\n  }\n\n  alpha (t: number, pt: number): number {\n    return 1 - (Math.exp(-(t - pt) / this.timeSpan))\n  }\n\n  push (value: number, time: number = Date.now()): void {\n    if (this.previousTime != null) {\n      // calculate moving average\n      const a = this.alpha(time, this.previousTime)\n      const diff = value - this.movingAverage\n      const incr = a * diff\n      this.movingAverage = a * value + (1 - a) * this.movingAverage\n      // calculate variance & deviation\n      this.variance = (1 - a) * (this.variance + diff * incr)\n      this.deviation = Math.sqrt(this.variance)\n      // calculate forecast\n      this.forecast = this.movingAverage + a * diff\n    } else {\n      this.movingAverage = value\n    }\n\n    this.previousTime = time\n  }\n}\n", "import { anySignal } from 'any-signal'\nimport { setMaxListeners } from 'main-event'\nimport { MovingAverage } from './moving-average.js'\nimport type { MetricGroup, Metrics } from '@libp2p/interface'\nimport type { ClearableSignal } from 'any-signal'\n\nexport const DEFAULT_TIMEOUT_MULTIPLIER = 1.2\nexport const DEFAULT_FAILURE_MULTIPLIER = 2\nexport const DEFAULT_MIN_TIMEOUT = 5_000\nexport const DEFAULT_MAX_TIMEOUT = 60_000\nexport const DEFAULT_INTERVAL = 5_000\n\nexport interface AdaptiveTimeoutSignal extends ClearableSignal {\n  start: number\n  timeout: number\n}\n\nexport interface AdaptiveTimeoutInit {\n  metricName?: string\n  metrics?: Metrics\n  interval?: number\n  timeoutMultiplier?: number\n  failureMultiplier?: number\n  minTimeout?: number\n  maxTimeout?: number\n}\n\nexport interface GetTimeoutSignalOptions {\n  timeoutFactor?: number\n  signal?: AbortSignal\n}\n\nexport class AdaptiveTimeout {\n  private readonly success: MovingAverage\n  private readonly failure: MovingAverage\n  private readonly next: MovingAverage\n  private readonly metric?: MetricGroup\n  private readonly timeoutMultiplier: number\n  private readonly failureMultiplier: number\n  private readonly minTimeout: number\n  private readonly maxTimeout: number\n\n  constructor (init: AdaptiveTimeoutInit = {}) {\n    const interval = init.interval ?? DEFAULT_INTERVAL\n    this.success = new MovingAverage(interval)\n    this.failure = new MovingAverage(interval)\n    this.next = new MovingAverage(interval)\n    this.failureMultiplier = init.failureMultiplier ?? DEFAULT_FAILURE_MULTIPLIER\n    this.timeoutMultiplier = init.timeoutMultiplier ?? DEFAULT_TIMEOUT_MULTIPLIER\n    this.minTimeout = init.minTimeout ?? DEFAULT_MIN_TIMEOUT\n    this.maxTimeout = init.maxTimeout ?? DEFAULT_MAX_TIMEOUT\n\n    if (init.metricName != null) {\n      this.metric = init.metrics?.registerMetricGroup(init.metricName)\n    }\n  }\n\n  getTimeoutSignal (options: GetTimeoutSignalOptions = {}): AdaptiveTimeoutSignal {\n    // calculate timeout for individual peers based on moving average of\n    // previous successful requests\n    let timeout = Math.round(this.next.movingAverage * (options.timeoutFactor ?? this.timeoutMultiplier))\n\n    if (timeout < this.minTimeout) {\n      timeout = this.minTimeout\n    }\n\n    if (timeout > this.maxTimeout) {\n      timeout = this.maxTimeout\n    }\n\n    const sendTimeout = AbortSignal.timeout(timeout)\n    const timeoutSignal = anySignal([options.signal, sendTimeout]) as AdaptiveTimeoutSignal\n    setMaxListeners(Infinity, timeoutSignal, sendTimeout)\n\n    timeoutSignal.start = Date.now()\n    timeoutSignal.timeout = timeout\n\n    return timeoutSignal\n  }\n\n  cleanUp (signal: AdaptiveTimeoutSignal): void {\n    const time = Date.now() - signal.start\n\n    if (signal.aborted) {\n      this.failure.push(time)\n      this.next.push(time * this.failureMultiplier)\n      this.metric?.update({\n        failureMovingAverage: this.failure.movingAverage,\n        failureDeviation: this.failure.deviation,\n        failureForecast: this.failure.forecast,\n        failureVariance: this.failure.variance,\n        failure: time\n      })\n    } else {\n      this.success.push(time)\n      this.next.push(time)\n      this.metric?.update({\n        successMovingAverage: this.success.movingAverage,\n        successDeviation: this.success.deviation,\n        successForecast: this.success.forecast,\n        successVariance: this.success.variance,\n        success: time\n      })\n    }\n  }\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport * as varint from 'uint8-varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { InvalidMessageLengthError } from './stream-utils.ts'\n\nconst DEFAULT_MAX_BUFFER_SIZE = 1024 * 1024 * 4\nconst DEFAULT_MAX_DATA_LENGTH = 1024 * 1024 * 4\n\nexport interface LengthPrefixedDecoderInit {\n  /**\n   * How large the internal buffer is allowed to grow - attempting to store more\n   * data than this will throw\n   */\n  maxBufferSize?: number\n\n  /**\n   * Throw an error if the message that would be read from the buffer is larger\n   * than this value\n   */\n  maxDataLength?: number\n\n  /**\n   * Read a varint from the buffer\n   */\n  lengthDecoder?(data: Uint8ArrayList | Uint8Array): number\n\n  /**\n   * Return how many bytes it takes to encode the passed value\n   */\n  encodingLength?(length: number): number\n}\n\n/**\n * Decode length-prefixed data from a buffer\n */\nexport class LengthPrefixedDecoder {\n  private readonly buffer: Uint8ArrayList\n  private readonly maxBufferSize: number\n  private readonly lengthDecoder: (data: Uint8ArrayList | Uint8Array) => number\n  private readonly maxDataLength: number\n  private readonly encodingLength: (length: number) => number\n\n  constructor (init: LengthPrefixedDecoderInit = {}) {\n    this.buffer = new Uint8ArrayList()\n    this.maxBufferSize = init.maxBufferSize ?? DEFAULT_MAX_BUFFER_SIZE\n    this.maxDataLength = init.maxDataLength ?? DEFAULT_MAX_DATA_LENGTH\n    this.lengthDecoder = init.lengthDecoder ?? varint.decode\n    this.encodingLength = init.encodingLength ?? varint.encodingLength\n  }\n\n  /**\n   * Decodes length-prefixed data\n   */\n  * decode (buf: Uint8Array | Uint8ArrayList): Generator<Uint8ArrayList> {\n    this.buffer.append(buf)\n\n    if (this.buffer.byteLength > this.maxBufferSize) {\n      throw new InvalidParametersError(`Buffer length limit exceeded - ${this.buffer.byteLength}/${this.maxBufferSize}`)\n    }\n\n    // Loop to consume as many bytes from the buffer as possible\n    // Eg: when a single chunk contains several frames\n    while (true) {\n      let dataLength: number\n\n      try {\n        dataLength = this.lengthDecoder(this.buffer)\n      } catch (err) {\n        if (err instanceof RangeError) {\n          // ignore errors where we don't have enough data to read the length\n          // prefix\n          break\n        }\n\n        throw err\n      }\n\n      if (dataLength < 0 || dataLength > this.maxDataLength) {\n        throw new InvalidMessageLengthError('Invalid message length')\n      }\n\n      const lengthLength = this.encodingLength(dataLength)\n      const chunkLength = lengthLength + dataLength\n\n      if (this.buffer.byteLength >= chunkLength) {\n        const buf = this.buffer.sublist(lengthLength, chunkLength)\n\n        this.buffer.consume(chunkLength)\n\n        if (buf.byteLength > 0) {\n          yield buf\n        }\n      } else {\n        break\n      }\n    }\n  }\n}\n", "// This is an unfortunate replacement for @sindresorhus/is that we need to\n// re-implement for performance purposes. In particular the is.observable()\n// check is expensive, and unnecessary for our purposes. The values returned\n// are compatible with @sindresorhus/is, however.\n\nconst typeofs = [\n  'string',\n  'number',\n  'bigint',\n  'symbol'\n]\n\nconst objectTypeNames = [\n  'Function',\n  'Generator',\n  'AsyncGenerator',\n  'GeneratorFunction',\n  'AsyncGeneratorFunction',\n  'AsyncFunction',\n  'Observable',\n  'Array',\n  'Buffer',\n  'Object',\n  'RegExp',\n  'Date',\n  'Error',\n  'Map',\n  'Set',\n  'WeakMap',\n  'WeakSet',\n  'ArrayBuffer',\n  'SharedArrayBuffer',\n  'DataView',\n  'Promise',\n  'URL',\n  'HTMLElement',\n  'Int8Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Int16Array',\n  'Uint16Array',\n  'Int32Array',\n  'Uint32Array',\n  'Float32Array',\n  'Float64Array',\n  'BigInt64Array',\n  'BigUint64Array'\n]\n\n/**\n * @param {any} value\n * @returns {string}\n */\nexport function is (value) {\n  if (value === null) {\n    return 'null'\n  }\n  if (value === undefined) {\n    return 'undefined'\n  }\n  if (value === true || value === false) {\n    return 'boolean'\n  }\n  const typeOf = typeof value\n  if (typeofs.includes(typeOf)) {\n    return typeOf\n  }\n  /* c8 ignore next 4 */\n  // not going to bother testing this, it's not going to be valid anyway\n  if (typeOf === 'function') {\n    return 'Function'\n  }\n  if (Array.isArray(value)) {\n    return 'Array'\n  }\n  if (isBuffer(value)) {\n    return 'Buffer'\n  }\n  const objectType = getObjectType(value)\n  if (objectType) {\n    return objectType\n  }\n  /* c8 ignore next */\n  return 'Object'\n}\n\n/**\n * @param {any} value\n * @returns {boolean}\n */\nfunction isBuffer (value) {\n  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value)\n}\n\n/**\n * @param {any} value\n * @returns {string|undefined}\n */\nfunction getObjectType (value) {\n  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1)\n  if (objectTypeNames.includes(objectTypeName)) {\n    return objectTypeName\n  }\n  /* c8 ignore next */\n  return undefined\n}\n", "class Type {\n  /**\n   * @param {number} major\n   * @param {string} name\n   * @param {boolean} terminal\n   */\n  constructor (major, name, terminal) {\n    this.major = major\n    this.majorEncoded = major << 5\n    this.name = name\n    this.terminal = terminal\n  }\n\n  /* c8 ignore next 3 */\n  toString () {\n    return `Type[${this.major}].${this.name}`\n  }\n\n  /**\n   * @param {Type} typ\n   * @returns {number}\n   */\n  compare (typ) {\n    /* c8 ignore next 1 */\n    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0\n  }\n}\n\n// convert to static fields when better supported\nType.uint = new Type(0, 'uint', true)\nType.negint = new Type(1, 'negint', true)\nType.bytes = new Type(2, 'bytes', true)\nType.string = new Type(3, 'string', true)\nType.array = new Type(4, 'array', false)\nType.map = new Type(5, 'map', false)\nType.tag = new Type(6, 'tag', false) // terminal?\nType.float = new Type(7, 'float', true)\nType.false = new Type(7, 'false', true)\nType.true = new Type(7, 'true', true)\nType.null = new Type(7, 'null', true)\nType.undefined = new Type(7, 'undefined', true)\nType.break = new Type(7, 'break', true)\n// Type.indefiniteLength = new Type(0, 'indefiniteLength', true)\n\nclass Token {\n  /**\n   * @param {Type} type\n   * @param {any} [value]\n   * @param {number} [encodedLength]\n   */\n  constructor (type, value, encodedLength) {\n    this.type = type\n    this.value = value\n    this.encodedLength = encodedLength\n    /** @type {Uint8Array|undefined} */\n    this.encodedBytes = undefined\n    /** @type {Uint8Array|undefined} */\n    this.byteValue = undefined\n  }\n\n  /* c8 ignore next 3 */\n  toString () {\n    return `Token[${this.type}].${this.value}`\n  }\n}\n\nexport { Type, Token }\n", "// Use Uint8Array directly in the browser, use Buffer in Node.js but don't\n// speak its name directly to avoid bundlers pulling in the `Buffer` polyfill\n\n// @ts-ignore\nexport const useBuffer = globalThis.process &&\n  // @ts-ignore\n  !globalThis.process.browser &&\n  // @ts-ignore\n  globalThis.Buffer &&\n  // @ts-ignore\n  typeof globalThis.Buffer.isBuffer === 'function'\n\nconst textDecoder = new TextDecoder()\nconst textEncoder = new TextEncoder()\n\n/**\n * @param {Uint8Array} buf\n * @returns {boolean}\n */\nfunction isBuffer (buf) {\n  // @ts-ignore\n  return useBuffer && globalThis.Buffer.isBuffer(buf)\n}\n\n/**\n * @param {Uint8Array|number[]} buf\n * @returns {Uint8Array}\n */\nexport function asU8A (buf) {\n  /* c8 ignore next */\n  if (!(buf instanceof Uint8Array)) {\n    return Uint8Array.from(buf)\n  }\n  return isBuffer(buf) ? new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) : buf\n}\n\nexport const toString = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return end - start > 64\n        ? // eslint-disable-line operator-linebreak\n      // @ts-ignore\n        globalThis.Buffer.from(bytes.subarray(start, end)).toString('utf8')\n        : utf8Slice(bytes, start, end)\n    }\n  /* c8 ignore next 11 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return end - start > 64\n        ? textDecoder.decode(bytes.subarray(start, end))\n        : utf8Slice(bytes, start, end)\n    }\n\nexport const fromString = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {string} string\n     */\n    (string) => {\n      return string.length > 64\n        ? // eslint-disable-line operator-linebreak\n      // @ts-ignore\n        globalThis.Buffer.from(string)\n        : utf8ToBytes(string)\n    }\n  /* c8 ignore next 7 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {string} string\n     */\n    (string) => {\n      return string.length > 64 ? textEncoder.encode(string) : utf8ToBytes(string)\n    }\n\n/**\n * Buffer variant not fast enough for what we need\n * @param {number[]} arr\n * @returns {Uint8Array}\n */\nexport const fromArray = (arr) => {\n  return Uint8Array.from(arr)\n}\n\nexport const slice = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      if (isBuffer(bytes)) {\n        return new Uint8Array(bytes.subarray(start, end))\n      }\n      return bytes.slice(start, end)\n    }\n  /* c8 ignore next 9 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return bytes.slice(start, end)\n    }\n\nexport const concat = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array[]} chunks\n     * @param {number} length\n     * @returns {Uint8Array}\n     */\n    (chunks, length) => {\n      // might get a stray plain Array here\n      /* c8 ignore next 1 */\n      chunks = chunks.map((c) => c instanceof Uint8Array\n        ? c\n        // this case is occasionally missed during test runs so becomes coverage-flaky\n        /* c8 ignore next 4 */\n        : // eslint-disable-line operator-linebreak\n        // @ts-ignore\n        globalThis.Buffer.from(c))\n      // @ts-ignore\n      return asU8A(globalThis.Buffer.concat(chunks, length))\n    }\n  /* c8 ignore next 19 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array[]} chunks\n     * @param {number} length\n     * @returns {Uint8Array}\n     */\n    (chunks, length) => {\n      const out = new Uint8Array(length)\n      let off = 0\n      for (let b of chunks) {\n        if (off + b.length > out.length) {\n          // final chunk that's bigger than we need\n          b = b.subarray(0, out.length - off)\n        }\n        out.set(b, off)\n        off += b.length\n      }\n      return out\n    }\n\nexport const alloc = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {number} size\n     * @returns {Uint8Array}\n     */\n    (size) => {\n      // we always write over the contents we expose so this should be safe\n      // @ts-ignore\n      return globalThis.Buffer.allocUnsafe(size)\n    }\n  /* c8 ignore next 8 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {number} size\n     * @returns {Uint8Array}\n     */\n    (size) => {\n      return new Uint8Array(size)\n    }\n\nexport const toHex = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} d\n     * @returns {string}\n     */\n    (d) => {\n      if (typeof d === 'string') {\n        return d\n      }\n      // @ts-ignore\n      return globalThis.Buffer.from(toBytes(d)).toString('hex')\n    }\n  /* c8 ignore next 12 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} d\n     * @returns {string}\n     */\n    (d) => {\n      if (typeof d === 'string') {\n        return d\n      }\n      // @ts-ignore not smart enough to figure this out\n      return Array.prototype.reduce.call(toBytes(d), (p, c) => `${p}${c.toString(16).padStart(2, '0')}`, '')\n    }\n\nexport const fromHex = useBuffer\n  ? // eslint-disable-line operator-linebreak\n  /**\n   * @param {string|Uint8Array} hex\n   * @returns {Uint8Array}\n   */\n    (hex) => {\n      if (hex instanceof Uint8Array) {\n        return hex\n      }\n      // @ts-ignore\n      return globalThis.Buffer.from(hex, 'hex')\n    }\n  /* c8 ignore next 17 */\n  : // eslint-disable-line operator-linebreak\n  /**\n   * @param {string|Uint8Array} hex\n   * @returns {Uint8Array}\n   */\n    (hex) => {\n      if (hex instanceof Uint8Array) {\n        return hex\n      }\n      if (!hex.length) {\n        return new Uint8Array(0)\n      }\n      return new Uint8Array(hex.split('')\n        .map((/** @type {string} */ c, /** @type {number} */ i, /** @type {string[]} */ d) => i % 2 === 0 ? `0x${c}${d[i + 1]}` : '')\n        .filter(Boolean)\n        .map((/** @type {string} */ e) => parseInt(e, 16)))\n    }\n\n/**\n * @param {Uint8Array|ArrayBuffer|ArrayBufferView} obj\n * @returns {Uint8Array}\n */\nfunction toBytes (obj) {\n  if (obj instanceof Uint8Array && obj.constructor.name === 'Uint8Array') {\n    return obj\n  }\n  if (obj instanceof ArrayBuffer) {\n    return new Uint8Array(obj)\n  }\n  if (ArrayBuffer.isView(obj)) {\n    return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength)\n  }\n  /* c8 ignore next */\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {Uint8Array} b1\n * @param {Uint8Array} b2\n * @returns {number}\n */\nexport function compare (b1, b2) {\n  /* c8 ignore next 5 */\n  if (isBuffer(b1) && isBuffer(b2)) {\n    // probably not possible to get here in the current API\n    // @ts-ignore Buffer\n    return b1.compare(b2)\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] === b2[i]) {\n      continue\n    }\n    return b1[i] < b2[i] ? -1 : 1\n  } /* c8 ignore next 3 */\n  return 0\n}\n\n// The below code is taken from https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143\n// Licensed Apache-2.0.\n\n/**\n * @param {string} str\n * @returns {number[]}\n */\nfunction utf8ToBytes (str) {\n  const out = []\n  let p = 0\n  for (let i = 0; i < str.length; i++) {\n    let c = str.charCodeAt(i)\n    if (c < 128) {\n      out[p++] = c\n    } else if (c < 2048) {\n      out[p++] = (c >> 6) | 192\n      out[p++] = (c & 63) | 128\n    } else if (\n      ((c & 0xFC00) === 0xD800) && (i + 1) < str.length &&\n      ((str.charCodeAt(i + 1) & 0xFC00) === 0xDC00)) {\n      // Surrogate Pair\n      c = 0x10000 + ((c & 0x03FF) << 10) + (str.charCodeAt(++i) & 0x03FF)\n      out[p++] = (c >> 18) | 240\n      out[p++] = ((c >> 12) & 63) | 128\n      out[p++] = ((c >> 6) & 63) | 128\n      out[p++] = (c & 63) | 128\n    } else {\n      out[p++] = (c >> 12) | 224\n      out[p++] = ((c >> 6) & 63) | 128\n      out[p++] = (c & 63) | 128\n    }\n  }\n  return out\n}\n\n// The below code is mostly taken from https://github.com/feross/buffer\n// Licensed MIT. Copyright (c) Feross Aboukhadijeh\n\n/**\n * @param {Uint8Array} buf\n * @param {number} offset\n * @param {number} end\n * @returns {string}\n */\nfunction utf8Slice (buf, offset, end) {\n  const res = []\n\n  while (offset < end) {\n    const firstByte = buf[offset]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xef) ? 4 : (firstByte > 0xdf) ? 3 : (firstByte > 0xbf) ? 2 : 1\n\n    if (offset + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[offset + 1]\n          if ((secondByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1f) << 0x6 | (secondByte & 0x3f)\n            if (tempCodePoint > 0x7f) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[offset + 1]\n          thirdByte = buf[offset + 2]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0xc | (secondByte & 0x3f) << 0x6 | (thirdByte & 0x3f)\n            /* c8 ignore next 3 */\n            if (tempCodePoint > 0x7ff && (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[offset + 1]\n          thirdByte = buf[offset + 2]\n          fourthByte = buf[offset + 3]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80 && (fourthByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0x12 | (secondByte & 0x3f) << 0xc | (thirdByte & 0x3f) << 0x6 | (fourthByte & 0x3f)\n            if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    /* c8 ignore next 5 */\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xfffd\n      bytesPerSequence = 1\n    } else if (codePoint > 0xffff) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3ff | 0xd800)\n      codePoint = 0xdc00 | codePoint & 0x3ff\n    }\n\n    res.push(codePoint)\n    offset += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\n/**\n * @param {number[]} codePoints\n * @returns {string}\n */\nexport function decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n  /* c8 ignore next 10 */\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n", "/**\n * Bl is a list of byte chunks, similar to https://github.com/rvagg/bl but for\n * writing rather than reading.\n * A Bl object accepts set() operations for individual bytes and copyTo() for\n * inserting byte arrays. These write operations don't automatically increment\n * the internal cursor so its \"length\" won't be changed. Instead, increment()\n * must be called to extend its length to cover the inserted data.\n * The toBytes() call will convert all internal memory to a single Uint8Array of\n * the correct length, truncating any data that is stored but hasn't been\n * included by an increment().\n * get() can retrieve a single byte.\n * All operations (except toBytes()) take an \"offset\" argument that will perform\n * the write at the offset _from the current cursor_. For most operations this\n * will be `0` to write at the current cursor position but it can be ahead of\n * the current cursor. Negative offsets probably work but are untested.\n */\n\n// TODO: ipjs doesn't support this, only for test files: https://github.com/mikeal/ipjs/blob/master/src/package/testFile.js#L39\nimport { alloc, concat, slice } from './byte-utils.js'\n\n// the ts-ignores in this file are almost all for the `Uint8Array|number[]` duality that exists\n// for perf reasons. Consider better approaches to this or removing it entirely, it is quite\n// risky because of some assumptions about small chunks === number[] and everything else === Uint8Array.\n\nconst defaultChunkSize = 256\n\nexport class Bl {\n  /**\n   * @param {number} [chunkSize]\n   */\n  constructor (chunkSize = defaultChunkSize) {\n    this.chunkSize = chunkSize\n    /** @type {number} */\n    this.cursor = 0\n    /** @type {number} */\n    this.maxCursor = -1\n    /** @type {(Uint8Array|number[])[]} */\n    this.chunks = []\n    // keep the first chunk around if we can to save allocations for future encodes\n    /** @type {Uint8Array|number[]|null} */\n    this._initReuseChunk = null\n  }\n\n  reset () {\n    this.cursor = 0\n    this.maxCursor = -1\n    if (this.chunks.length) {\n      this.chunks = []\n    }\n    if (this._initReuseChunk !== null) {\n      this.chunks.push(this._initReuseChunk)\n      this.maxCursor = this._initReuseChunk.length - 1\n    }\n  }\n\n  /**\n   * @param {Uint8Array|number[]} bytes\n   */\n  push (bytes) {\n    let topChunk = this.chunks[this.chunks.length - 1]\n    const newMax = this.cursor + bytes.length\n    if (newMax <= this.maxCursor + 1) {\n      // we have at least one chunk and we can fit these bytes into that chunk\n      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1\n      // @ts-ignore\n      topChunk.set(bytes, chunkPos)\n    } else {\n      // can't fit it in\n      if (topChunk) {\n        // trip the last chunk to `cursor` if we need to\n        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1\n        if (chunkPos < topChunk.length) {\n          // @ts-ignore\n          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos)\n          this.maxCursor = this.cursor - 1\n        }\n      }\n      if (bytes.length < 64 && bytes.length < this.chunkSize) {\n        // make a new chunk and copy the new one into it\n        topChunk = alloc(this.chunkSize)\n        this.chunks.push(topChunk)\n        this.maxCursor += topChunk.length\n        if (this._initReuseChunk === null) {\n          this._initReuseChunk = topChunk\n        }\n        // @ts-ignore\n        topChunk.set(bytes, 0)\n      } else {\n        // push the new bytes in as its own chunk\n        this.chunks.push(bytes)\n        this.maxCursor += bytes.length\n      }\n    }\n    this.cursor += bytes.length\n  }\n\n  /**\n   * @param {boolean} [reset]\n   * @returns {Uint8Array}\n   */\n  toBytes (reset = false) {\n    let byts\n    if (this.chunks.length === 1) {\n      const chunk = this.chunks[0]\n      if (reset && this.cursor > chunk.length / 2) {\n        /* c8 ignore next 2 */\n        // @ts-ignore\n        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor)\n        this._initReuseChunk = null\n        this.chunks = []\n      } else {\n        // @ts-ignore\n        byts = slice(chunk, 0, this.cursor)\n      }\n    } else {\n      // @ts-ignore\n      byts = concat(this.chunks, this.cursor)\n    }\n    if (reset) {\n      this.reset()\n    }\n    return byts\n  }\n}\n", "const decodeErrPrefix = 'CBOR decode error:'\nconst encodeErrPrefix = 'CBOR encode error:'\n\nconst uintMinorPrefixBytes = []\nuintMinorPrefixBytes[23] = 1\nuintMinorPrefixBytes[24] = 2\nuintMinorPrefixBytes[25] = 3\nuintMinorPrefixBytes[26] = 5\nuintMinorPrefixBytes[27] = 9\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} need\n */\nfunction assertEnoughData (data, pos, need) {\n  if (data.length - pos < need) {\n    throw new Error(`${decodeErrPrefix} not enough data for type`)\n  }\n}\n\nexport {\n  decodeErrPrefix,\n  encodeErrPrefix,\n  uintMinorPrefixBytes,\n  assertEnoughData\n}\n", "/* globals BigInt */\n\nimport { Token, Type } from './token.js'\nimport { decodeErrPrefix, assertEnoughData } from './common.js'\n\nexport const uintBoundaries = [24, 256, 65536, 4294967296, BigInt('18446744073709551616')]\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint8 (data, offset, options) {\n  assertEnoughData(data, offset, 1)\n  const value = data[offset]\n  if (options.strict === true && value < uintBoundaries[0]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint16 (data, offset, options) {\n  assertEnoughData(data, offset, 2)\n  const value = (data[offset] << 8) | data[offset + 1]\n  if (options.strict === true && value < uintBoundaries[1]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint32 (data, offset, options) {\n  assertEnoughData(data, offset, 4)\n  const value = (data[offset] * 16777216 /* 2 ** 24 */) + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3]\n  if (options.strict === true && value < uintBoundaries[2]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number|bigint}\n */\nexport function readUint64 (data, offset, options) {\n  // assume BigInt, convert back to Number if within safe range\n  assertEnoughData(data, offset, 8)\n  const hi = (data[offset] * 16777216 /* 2 ** 24 */) + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3]\n  const lo = (data[offset + 4] * 16777216 /* 2 ** 24 */) + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7]\n  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo)\n  if (options.strict === true && value < uintBoundaries[3]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  if (value <= Number.MAX_SAFE_INTEGER) {\n    return Number(value)\n  }\n  if (options.allowBigInt === true) {\n    return value\n  }\n  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)\n}\n\n/* not required thanks to quick[] list\nconst oneByteTokens = new Array(24).fill(0).map((v, i) => new Token(Type.uint, i, 1))\nexport function decodeUintCompact (data, pos, minor, options) {\n  return oneByteTokens[minor]\n}\n*/\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint8 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint16 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint32 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint32(data, pos + 1, options), 5)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint64 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint64(data, pos + 1, options), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeUint (buf, token) {\n  return encodeUintValue(buf, 0, token.value)\n}\n\n/**\n * @param {Bl} buf\n * @param {number} major\n * @param {number|bigint} uint\n */\nexport function encodeUintValue (buf, major, uint) {\n  if (uint < uintBoundaries[0]) {\n    const nuint = Number(uint)\n    // pack into one byte, minor=0, additional=value\n    buf.push([major | nuint])\n  } else if (uint < uintBoundaries[1]) {\n    const nuint = Number(uint)\n    // pack into two byte, minor=0, additional=24\n    buf.push([major | 24, nuint])\n  } else if (uint < uintBoundaries[2]) {\n    const nuint = Number(uint)\n    // pack into three byte, minor=0, additional=25\n    buf.push([major | 25, nuint >>> 8, nuint & 0xff])\n  } else if (uint < uintBoundaries[3]) {\n    const nuint = Number(uint)\n    // pack into five byte, minor=0, additional=26\n    buf.push([major | 26, (nuint >>> 24) & 0xff, (nuint >>> 16) & 0xff, (nuint >>> 8) & 0xff, nuint & 0xff])\n  } else {\n    const buint = BigInt(uint)\n    if (buint < uintBoundaries[4]) {\n      // pack into nine byte, minor=0, additional=27\n      const set = [major | 27, 0, 0, 0, 0, 0, 0, 0]\n      // simulate bitwise above 32 bits\n      let lo = Number(buint & BigInt(0xffffffff))\n      let hi = Number(buint >> BigInt(32) & BigInt(0xffffffff))\n      set[8] = lo & 0xff\n      lo = lo >> 8\n      set[7] = lo & 0xff\n      lo = lo >> 8\n      set[6] = lo & 0xff\n      lo = lo >> 8\n      set[5] = lo & 0xff\n      set[4] = hi & 0xff\n      hi = hi >> 8\n      set[3] = hi & 0xff\n      hi = hi >> 8\n      set[2] = hi & 0xff\n      hi = hi >> 8\n      set[1] = hi & 0xff\n      buf.push(set)\n    } else {\n      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`)\n    }\n  }\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeUint.encodedSize = function encodedSize (token) {\n  return encodeUintValue.encodedSize(token.value)\n}\n\n/**\n * @param {number} uint\n * @returns {number}\n */\nencodeUintValue.encodedSize = function encodedSize (uint) {\n  if (uint < uintBoundaries[0]) {\n    return 1\n  }\n  if (uint < uintBoundaries[1]) {\n    return 2\n  }\n  if (uint < uintBoundaries[2]) {\n    return 3\n  }\n  if (uint < uintBoundaries[3]) {\n    return 5\n  }\n  return 9\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeUint.compareTokens = function compareTokens (tok1, tok2) {\n  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : /* c8 ignore next */ 0\n}\n", "/* eslint-env es2020 */\n\nimport { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint8 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint16 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint32 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint32(data, pos + 1, options), 5)\n}\n\nconst neg1b = BigInt(-1)\nconst pos1b = BigInt(1)\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint64 (data, pos, _minor, options) {\n  const int = uint.readUint64(data, pos + 1, options)\n  if (typeof int !== 'bigint') {\n    const value = -1 - int\n    if (value >= Number.MIN_SAFE_INTEGER) {\n      return new Token(Type.negint, value, 9)\n    }\n  }\n  if (options.allowBigInt !== true) {\n    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)\n  }\n  return new Token(Type.negint, neg1b - BigInt(int), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeNegint (buf, token) {\n  const negint = token.value\n  const unsigned = (typeof negint === 'bigint' ? (negint * neg1b - pos1b) : (negint * -1 - 1))\n  uint.encodeUintValue(buf, token.type.majorEncoded, unsigned)\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeNegint.encodedSize = function encodedSize (token) {\n  const negint = token.value\n  const unsigned = (typeof negint === 'bigint' ? (negint * neg1b - pos1b) : (negint * -1 - 1))\n  /* c8 ignore next 4 */\n  // handled by quickEncode, we shouldn't get here but it's included for completeness\n  if (unsigned < uint.uintBoundaries[0]) {\n    return 1\n  }\n  if (unsigned < uint.uintBoundaries[1]) {\n    return 2\n  }\n  if (unsigned < uint.uintBoundaries[2]) {\n    return 3\n  }\n  if (unsigned < uint.uintBoundaries[3]) {\n    return 5\n  }\n  return 9\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeNegint.compareTokens = function compareTokens (tok1, tok2) {\n  // opposite of the uint comparison since we store the uint version in bytes\n  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : /* c8 ignore next */ 0\n}\n", "import { Token, Type } from './token.js'\nimport { assertEnoughData, decodeErrPrefix } from './common.js'\nimport * as uint from './0uint.js'\nimport { compare, fromString, slice } from './byte-utils.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (data, pos, prefix, length) {\n  assertEnoughData(data, pos, prefix + length)\n  const buf = slice(data, pos + prefix, pos + prefix + length)\n  return new Token(Type.bytes, buf, prefix + length)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeBytesCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * `encodedBytes` allows for caching when we do a byte version of a string\n * for key sorting purposes\n * @param {Token} token\n * @returns {Uint8Array}\n */\nfunction tokenBytes (token) {\n  if (token.encodedBytes === undefined) {\n    token.encodedBytes = token.type === Type.string ? fromString(token.value) : token.value\n  }\n  // @ts-ignore c'mon\n  return token.encodedBytes\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeBytes (buf, token) {\n  const bytes = tokenBytes(token)\n  uint.encodeUintValue(buf, token.type.majorEncoded, bytes.length)\n  buf.push(bytes)\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeBytes.encodedSize = function encodedSize (token) {\n  const bytes = tokenBytes(token)\n  return uint.encodeUintValue.encodedSize(bytes.length) + bytes.length\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeBytes.compareTokens = function compareTokens (tok1, tok2) {\n  return compareBytes(tokenBytes(tok1), tokenBytes(tok2))\n}\n\n/**\n * @param {Uint8Array} b1\n * @param {Uint8Array} b2\n * @returns {number}\n */\nexport function compareBytes (b1, b2) {\n  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2)\n}\n", "import { Token, Type } from './token.js'\nimport { assertEnoughData, decodeErrPrefix } from './common.js'\nimport * as uint from './0uint.js'\nimport { encodeBytes } from './2bytes.js'\nimport { toString, slice } from './byte-utils.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} prefix\n * @param {number} length\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction toToken (data, pos, prefix, length, options) {\n  const totLength = prefix + length\n  assertEnoughData(data, pos, totLength)\n  const tok = new Token(Type.string, toString(data, pos + prefix, pos + totLength), totLength)\n  if (options.retainStringBytes === true) {\n    tok.byteValue = slice(data, pos + prefix, pos + totLength)\n  }\n  return tok\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeStringCompact (data, pos, minor, options) {\n  return toToken(data, pos, 1, minor, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options), options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options), options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options), options)\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`)\n  }\n  return toToken(data, pos, 9, l, options)\n}\n\nexport const encodeString = encodeBytes\n", "import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (_data, _pos, prefix, length) {\n  return new Token(Type.array, length, prefix)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeArrayCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArrayIndefinite (data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return toToken(data, pos, 1, Infinity)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeArray (buf, token) {\n  uint.encodeUintValue(buf, Type.array.majorEncoded, token.value)\n}\n\n// using an array as a map key, are you sure about this? we can only sort\n// by map length here, it's up to the encoder to decide to look deeper\nencodeArray.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeArray.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n", "import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (_data, _pos, prefix, length) {\n  return new Token(Type.map, length, prefix)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeMapCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMapIndefinite (data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return toToken(data, pos, 1, Infinity)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeMap (buf, token) {\n  uint.encodeUintValue(buf, Type.map.majorEncoded, token.value)\n}\n\n// using a map as a map key, are you sure about this? we can only sort\n// by map length here, it's up to the encoder to decide to look deeper\nencodeMap.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeMap.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n", "import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeTagCompact (_data, _pos, minor, _options) {\n  return new Token(Type.tag, minor, 1)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag8 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag16 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag32 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint32(data, pos + 1, options), 5)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag64 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint64(data, pos + 1, options), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeTag (buf, token) {\n  uint.encodeUintValue(buf, Type.tag.majorEncoded, token.value)\n}\n\nencodeTag.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeTag.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n", "// TODO: shift some of the bytes logic to bytes-utils so we can use Buffer\n// where possible\n\nimport { Token, Type } from './token.js'\nimport { decodeErrPrefix } from './common.js'\nimport { encodeUint } from './0uint.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n */\n\nconst MINOR_FALSE = 20\nconst MINOR_TRUE = 21\nconst MINOR_NULL = 22\nconst MINOR_UNDEFINED = 23\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUndefined (_data, _pos, _minor, options) {\n  if (options.allowUndefined === false) {\n    throw new Error(`${decodeErrPrefix} undefined values are not supported`)\n  } else if (options.coerceUndefinedToNull === true) {\n    return new Token(Type.null, null, 1)\n  }\n  return new Token(Type.undefined, undefined, 1)\n}\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBreak (_data, _pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return new Token(Type.break, undefined, 1)\n}\n\n/**\n * @param {number} value\n * @param {number} bytes\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction createToken (value, bytes, options) {\n  if (options) {\n    if (options.allowNaN === false && Number.isNaN(value)) {\n      throw new Error(`${decodeErrPrefix} NaN values are not supported`)\n    }\n    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {\n      throw new Error(`${decodeErrPrefix} Infinity values are not supported`)\n    }\n  }\n  return new Token(Type.float, value, bytes)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat16 (data, pos, _minor, options) {\n  return createToken(readFloat16(data, pos + 1), 3, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat32 (data, pos, _minor, options) {\n  return createToken(readFloat32(data, pos + 1), 5, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat64 (data, pos, _minor, options) {\n  return createToken(readFloat64(data, pos + 1), 9, options)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n * @param {EncodeOptions} options\n */\nexport function encodeFloat (buf, token, options) {\n  const float = token.value\n\n  if (float === false) {\n    buf.push([Type.float.majorEncoded | MINOR_FALSE])\n  } else if (float === true) {\n    buf.push([Type.float.majorEncoded | MINOR_TRUE])\n  } else if (float === null) {\n    buf.push([Type.float.majorEncoded | MINOR_NULL])\n  } else if (float === undefined) {\n    buf.push([Type.float.majorEncoded | MINOR_UNDEFINED])\n  } else {\n    let decoded\n    let success = false\n    if (!options || options.float64 !== true) {\n      encodeFloat16(float)\n      decoded = readFloat16(ui8a, 1)\n      if (float === decoded || Number.isNaN(float)) {\n        ui8a[0] = 0xf9\n        buf.push(ui8a.slice(0, 3))\n        success = true\n      } else {\n        encodeFloat32(float)\n        decoded = readFloat32(ui8a, 1)\n        if (float === decoded) {\n          ui8a[0] = 0xfa\n          buf.push(ui8a.slice(0, 5))\n          success = true\n        }\n      }\n    }\n    if (!success) {\n      encodeFloat64(float)\n      decoded = readFloat64(ui8a, 1)\n      ui8a[0] = 0xfb\n      buf.push(ui8a.slice(0, 9))\n    }\n  }\n}\n\n/**\n * @param {Token} token\n * @param {EncodeOptions} options\n * @returns {number}\n */\nencodeFloat.encodedSize = function encodedSize (token, options) {\n  const float = token.value\n\n  if (float === false || float === true || float === null || float === undefined) {\n    return 1\n  }\n\n  if (!options || options.float64 !== true) {\n    encodeFloat16(float)\n    let decoded = readFloat16(ui8a, 1)\n    if (float === decoded || Number.isNaN(float)) {\n      return 3\n    }\n    encodeFloat32(float)\n    decoded = readFloat32(ui8a, 1)\n    if (float === decoded) {\n      return 5\n    }\n  }\n  return 9\n}\n\nconst buffer = new ArrayBuffer(9)\nconst dataView = new DataView(buffer, 1)\nconst ui8a = new Uint8Array(buffer, 0)\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat16 (inp) {\n  if (inp === Infinity) {\n    dataView.setUint16(0, 0x7c00, false)\n  } else if (inp === -Infinity) {\n    dataView.setUint16(0, 0xfc00, false)\n  } else if (Number.isNaN(inp)) {\n    dataView.setUint16(0, 0x7e00, false)\n  } else {\n    dataView.setFloat32(0, inp)\n    const valu32 = dataView.getUint32(0)\n    const exponent = (valu32 & 0x7f800000) >> 23\n    const mantissa = valu32 & 0x7fffff\n\n    /* c8 ignore next 6 */\n    if (exponent === 0xff) {\n      // too big, Infinity, but this should be hard (impossible?) to trigger\n      dataView.setUint16(0, 0x7c00, false)\n    } else if (exponent === 0x00) {\n      // 0.0, -0.0 and subnormals, shouldn't be possible to get here because 0.0 should be counted as an int\n      dataView.setUint16(0, ((inp & 0x80000000) >> 16) | (mantissa >> 13), false)\n    } else { // standard numbers\n      // chunks of logic here borrowed from https://github.com/PJK/libcbor/blob/c78f437182533e3efa8d963ff4b945bb635c2284/src/cbor/encoding.c#L127\n      const logicalExponent = exponent - 127\n      // Now we know that 2^exponent <= 0 logically\n      /* c8 ignore next 6 */\n      if (logicalExponent < -24) {\n        /* No unambiguous representation exists, this float is not a half float\n          and is too small to be represented using a half, round off to zero.\n          Consistent with the reference implementation. */\n        // should be difficult (impossible?) to get here in JS\n        dataView.setUint16(0, 0)\n      } else if (logicalExponent < -14) {\n        /* Offset the remaining decimal places by shifting the significand, the\n          value is lost. This is an implementation decision that works around the\n          absence of standard half-float in the language. */\n        dataView.setUint16(0, ((valu32 & 0x80000000) >> 16) | /* sign bit */ (1 << (24 + logicalExponent)), false)\n      } else {\n        dataView.setUint16(0, ((valu32 & 0x80000000) >> 16) | ((logicalExponent + 15) << 10) | (mantissa >> 13), false)\n      }\n    }\n  }\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat16 (ui8a, pos) {\n  if (ui8a.length - pos < 2) {\n    throw new Error(`${decodeErrPrefix} not enough data for float16`)\n  }\n\n  const half = (ui8a[pos] << 8) + ui8a[pos + 1]\n  if (half === 0x7c00) {\n    return Infinity\n  }\n  if (half === 0xfc00) {\n    return -Infinity\n  }\n  if (half === 0x7e00) {\n    return NaN\n  }\n  const exp = (half >> 10) & 0x1f\n  const mant = half & 0x3ff\n  let val\n  if (exp === 0) {\n    val = mant * (2 ** -24)\n  } else if (exp !== 31) {\n    val = (mant + 1024) * (2 ** (exp - 25))\n  /* c8 ignore next 4 */\n  } else {\n    // may not be possible to get here\n    val = mant === 0 ? Infinity : NaN\n  }\n  return (half & 0x8000) ? -val : val\n}\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat32 (inp) {\n  dataView.setFloat32(0, inp, false)\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat32 (ui8a, pos) {\n  if (ui8a.length - pos < 4) {\n    throw new Error(`${decodeErrPrefix} not enough data for float32`)\n  }\n  const offset = (ui8a.byteOffset || 0) + pos\n  return new DataView(ui8a.buffer, offset, 4).getFloat32(0, false)\n}\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat64 (inp) {\n  dataView.setFloat64(0, inp, false)\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat64 (ui8a, pos) {\n  if (ui8a.length - pos < 8) {\n    throw new Error(`${decodeErrPrefix} not enough data for float64`)\n  }\n  const offset = (ui8a.byteOffset || 0) + pos\n  return new DataView(ui8a.buffer, offset, 8).getFloat64(0, false)\n}\n\n/**\n * @param {Token} _tok1\n * @param {Token} _tok2\n * @returns {number}\n */\nencodeFloat.compareTokens = encodeUint.compareTokens\n/*\nencodeFloat.compareTokens = function compareTokens (_tok1, _tok2) {\n  return _tok1\n  throw new Error(`${encodeErrPrefix} cannot use floats as map keys`)\n}\n*/\n", "import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport * as negint from './1negint.js'\nimport * as bytes from './2bytes.js'\nimport * as string from './3string.js'\nimport * as array from './4array.js'\nimport * as map from './5map.js'\nimport * as tag from './6tag.js'\nimport * as float from './7float.js'\nimport { decodeErrPrefix } from './common.js'\nimport { fromArray } from './byte-utils.js'\n\n/**\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n */\nfunction invalidMinor (data, pos, minor) {\n  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`)\n}\n\n/**\n * @param {string} msg\n * @returns {()=>any}\n */\nfunction errorer (msg) {\n  return () => { throw new Error(`${decodeErrPrefix} ${msg}`) }\n}\n\n/** @type {((data:Uint8Array, pos:number, minor:number, options?:DecodeOptions) => any)[]} */\nexport const jump = []\n\n// unsigned integer, 0x00..0x17 (0..23)\nfor (let i = 0; i <= 0x17; i++) {\n  jump[i] = invalidMinor // uint.decodeUintCompact, handled by quick[]\n}\njump[0x18] = uint.decodeUint8 // unsigned integer, one-byte uint8_t follows\njump[0x19] = uint.decodeUint16 // unsigned integer, two-byte uint16_t follows\njump[0x1a] = uint.decodeUint32 // unsigned integer, four-byte uint32_t follows\njump[0x1b] = uint.decodeUint64 // unsigned integer, eight-byte uint64_t follows\njump[0x1c] = invalidMinor\njump[0x1d] = invalidMinor\njump[0x1e] = invalidMinor\njump[0x1f] = invalidMinor\n// negative integer, -1-0x00..-1-0x17 (-1..-24)\nfor (let i = 0x20; i <= 0x37; i++) {\n  jump[i] = invalidMinor // negintDecode, handled by quick[]\n}\njump[0x38] = negint.decodeNegint8 // negative integer, -1-n one-byte uint8_t for n follows\njump[0x39] = negint.decodeNegint16 // negative integer, -1-n two-byte uint16_t for n follows\njump[0x3a] = negint.decodeNegint32 // negative integer, -1-n four-byte uint32_t for follows\njump[0x3b] = negint.decodeNegint64 // negative integer, -1-n eight-byte uint64_t for follows\njump[0x3c] = invalidMinor\njump[0x3d] = invalidMinor\njump[0x3e] = invalidMinor\njump[0x3f] = invalidMinor\n// byte string, 0x00..0x17 bytes follow\nfor (let i = 0x40; i <= 0x57; i++) {\n  jump[i] = bytes.decodeBytesCompact\n}\njump[0x58] = bytes.decodeBytes8 // byte string, one-byte uint8_t for n, and then n bytes follow\njump[0x59] = bytes.decodeBytes16 // byte string, two-byte uint16_t for n, and then n bytes follow\njump[0x5a] = bytes.decodeBytes32 // byte string, four-byte uint32_t for n, and then n bytes follow\njump[0x5b] = bytes.decodeBytes64 // byte string, eight-byte uint64_t for n, and then n bytes follow\njump[0x5c] = invalidMinor\njump[0x5d] = invalidMinor\njump[0x5e] = invalidMinor\njump[0x5f] = errorer('indefinite length bytes/strings are not supported') // byte string, byte strings follow, terminated by \"break\"\n// UTF-8 string 0x00..0x17 bytes follow\nfor (let i = 0x60; i <= 0x77; i++) {\n  jump[i] = string.decodeStringCompact\n}\njump[0x78] = string.decodeString8 // UTF-8 string, one-byte uint8_t for n, and then n bytes follow\njump[0x79] = string.decodeString16 // UTF-8 string, two-byte uint16_t for n, and then n bytes follow\njump[0x7a] = string.decodeString32 // UTF-8 string, four-byte uint32_t for n, and then n bytes follow\njump[0x7b] = string.decodeString64 // UTF-8 string, eight-byte uint64_t for n, and then n bytes follow\njump[0x7c] = invalidMinor\njump[0x7d] = invalidMinor\njump[0x7e] = invalidMinor\njump[0x7f] = errorer('indefinite length bytes/strings are not supported') // UTF-8 strings follow, terminated by \"break\"\n// array, 0x00..0x17 data items follow\nfor (let i = 0x80; i <= 0x97; i++) {\n  jump[i] = array.decodeArrayCompact\n}\njump[0x98] = array.decodeArray8 // array, one-byte uint8_t for n, and then n data items follow\njump[0x99] = array.decodeArray16 // array, two-byte uint16_t for n, and then n data items follow\njump[0x9a] = array.decodeArray32 // array, four-byte uint32_t for n, and then n data items follow\njump[0x9b] = array.decodeArray64 // array, eight-byte uint64_t for n, and then n data items follow\njump[0x9c] = invalidMinor\njump[0x9d] = invalidMinor\njump[0x9e] = invalidMinor\njump[0x9f] = array.decodeArrayIndefinite // array, data items follow, terminated by \"break\"\n// map, 0x00..0x17 pairs of data items follow\nfor (let i = 0xa0; i <= 0xb7; i++) {\n  jump[i] = map.decodeMapCompact\n}\njump[0xb8] = map.decodeMap8 // map, one-byte uint8_t for n, and then n pairs of data items follow\njump[0xb9] = map.decodeMap16 // map, two-byte uint16_t for n, and then n pairs of data items follow\njump[0xba] = map.decodeMap32 // map, four-byte uint32_t for n, and then n pairs of data items follow\njump[0xbb] = map.decodeMap64 // map, eight-byte uint64_t for n, and then n pairs of data items follow\njump[0xbc] = invalidMinor\njump[0xbd] = invalidMinor\njump[0xbe] = invalidMinor\njump[0xbf] = map.decodeMapIndefinite // map, pairs of data items follow, terminated by \"break\"\n// tags\nfor (let i = 0xc0; i <= 0xd7; i++) {\n  jump[i] = tag.decodeTagCompact\n}\njump[0xd8] = tag.decodeTag8\njump[0xd9] = tag.decodeTag16\njump[0xda] = tag.decodeTag32\njump[0xdb] = tag.decodeTag64\njump[0xdc] = invalidMinor\njump[0xdd] = invalidMinor\njump[0xde] = invalidMinor\njump[0xdf] = invalidMinor\n// 0xe0..0xf3 simple values, unsupported\nfor (let i = 0xe0; i <= 0xf3; i++) {\n  jump[i] = errorer('simple values are not supported')\n}\njump[0xf4] = invalidMinor // false, handled by quick[]\njump[0xf5] = invalidMinor // true, handled by quick[]\njump[0xf6] = invalidMinor // null, handled by quick[]\njump[0xf7] = float.decodeUndefined // undefined\njump[0xf8] = errorer('simple values are not supported') // simple value, one byte follows, unsupported\njump[0xf9] = float.decodeFloat16 // half-precision float (two-byte IEEE 754)\njump[0xfa] = float.decodeFloat32 // single-precision float (four-byte IEEE 754)\njump[0xfb] = float.decodeFloat64 // double-precision float (eight-byte IEEE 754)\njump[0xfc] = invalidMinor\njump[0xfd] = invalidMinor\njump[0xfe] = invalidMinor\njump[0xff] = float.decodeBreak // \"break\" stop code\n\n/** @type {Token[]} */\nexport const quick = []\n// ints <24\nfor (let i = 0; i < 24; i++) {\n  quick[i] = new Token(Type.uint, i, 1)\n}\n// negints >= -24\nfor (let i = -1; i >= -24; i--) {\n  quick[31 - i] = new Token(Type.negint, i, 1)\n}\n// empty bytes\nquick[0x40] = new Token(Type.bytes, new Uint8Array(0), 1)\n// empty string\nquick[0x60] = new Token(Type.string, '', 1)\n// empty list\nquick[0x80] = new Token(Type.array, 0, 1)\n// empty map\nquick[0xa0] = new Token(Type.map, 0, 1)\n// false\nquick[0xf4] = new Token(Type.false, false, 1)\n// true\nquick[0xf5] = new Token(Type.true, true, 1)\n// null\nquick[0xf6] = new Token(Type.null, null, 1)\n\n/**\n * @param {Token} token\n * @returns {Uint8Array|undefined}\n */\nexport function quickEncodeToken (token) {\n  switch (token.type) {\n    case Type.false:\n      return fromArray([0xf4])\n    case Type.true:\n      return fromArray([0xf5])\n    case Type.null:\n      return fromArray([0xf6])\n    case Type.bytes:\n      if (!token.value.length) {\n        return fromArray([0x40])\n      }\n      return\n    case Type.string:\n      if (token.value === '') {\n        return fromArray([0x60])\n      }\n      return\n    case Type.array:\n      if (token.value === 0) {\n        return fromArray([0x80])\n      }\n      /* c8 ignore next 2 */\n      // shouldn't be possible if this were called when there was only one token\n      return\n    case Type.map:\n      if (token.value === 0) {\n        return fromArray([0xa0])\n      }\n      /* c8 ignore next 2 */\n      // shouldn't be possible if this were called when there was only one token\n      return\n    case Type.uint:\n      if (token.value < 24) {\n        return fromArray([Number(token.value)])\n      }\n      return\n    case Type.negint:\n      if (token.value >= -24) {\n        return fromArray([31 - Number(token.value)])\n      }\n  }\n}\n", "import { is } from './is.js'\nimport { Token, Type } from './token.js'\nimport { Bl } from './bl.js'\nimport { encodeErrPrefix } from './common.js'\nimport { quickEncodeToken } from './jump.js'\nimport { asU8A, compare } from './byte-utils.js'\n\nimport { encodeUint } from './0uint.js'\nimport { encodeNegint } from './1negint.js'\nimport { encodeBytes } from './2bytes.js'\nimport { encodeString } from './3string.js'\nimport { encodeArray } from './4array.js'\nimport { encodeMap } from './5map.js'\nimport { encodeTag } from './6tag.js'\nimport { encodeFloat } from './7float.js'\n\n/**\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n * @typedef {import('../interface').OptionalTypeEncoder} OptionalTypeEncoder\n * @typedef {import('../interface').Reference} Reference\n * @typedef {import('../interface').StrictTypeEncoder} StrictTypeEncoder\n * @typedef {import('../interface').TokenTypeEncoder} TokenTypeEncoder\n * @typedef {import('../interface').TokenOrNestedTokens} TokenOrNestedTokens\n */\n\n/** @type {EncodeOptions} */\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken\n}\n\n/** @type {EncodeOptions} */\nexport const rfc8949EncodeOptions = Object.freeze({\n  float64: true,\n  mapSorter: rfc8949MapSorter,\n  quickEncodeToken\n})\n\n/** @returns {TokenTypeEncoder[]} */\nexport function makeCborEncoders () {\n  const encoders = []\n  encoders[Type.uint.major] = encodeUint\n  encoders[Type.negint.major] = encodeNegint\n  encoders[Type.bytes.major] = encodeBytes\n  encoders[Type.string.major] = encodeString\n  encoders[Type.array.major] = encodeArray\n  encoders[Type.map.major] = encodeMap\n  encoders[Type.tag.major] = encodeTag\n  encoders[Type.float.major] = encodeFloat\n  return encoders\n}\n\nconst cborEncoders = makeCborEncoders()\n\nconst buf = new Bl()\n\n/** @implements {Reference} */\nclass Ref {\n  /**\n   * @param {object|any[]} obj\n   * @param {Reference|undefined} parent\n   */\n  constructor (obj, parent) {\n    this.obj = obj\n    this.parent = parent\n  }\n\n  /**\n   * @param {object|any[]} obj\n   * @returns {boolean}\n   */\n  includes (obj) {\n    /** @type {Reference|undefined} */\n    let p = this\n    do {\n      if (p.obj === obj) {\n        return true\n      }\n    } while (p = p.parent) // eslint-disable-line\n    return false\n  }\n\n  /**\n   * @param {Reference|undefined} stack\n   * @param {object|any[]} obj\n   * @returns {Reference}\n   */\n  static createCheck (stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${encodeErrPrefix} object contains circular references`)\n    }\n    return new Ref(obj, stack)\n  }\n}\n\nconst simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n}\n\n/** @type {{[typeName: string]: StrictTypeEncoder}} */\nconst typeEncoders = {\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  number (obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj)\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj)\n    } else {\n      return new Token(Type.negint, obj)\n    }\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  bigint (obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj)\n    } else {\n      return new Token(Type.negint, obj)\n    }\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Uint8Array (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj)\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  string (obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj)\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  boolean (obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false\n  },\n\n  /**\n   * @param {any} _obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  null (_obj, _typ, _options, _refStack) {\n    return simpleTokens.null\n  },\n\n  /**\n   * @param {any} _obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  undefined (_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  ArrayBuffer (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj))\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  DataView (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength))\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} options\n   * @param {Reference} [refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Array (obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyArray, new Token(Type.break)]\n      }\n      return simpleTokens.emptyArray\n    }\n    refStack = Ref.createCheck(refStack, obj)\n    const entries = []\n    let i = 0\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack)\n    }\n    if (options.addBreakTokens) {\n      return [new Token(Type.array, obj.length), entries, new Token(Type.break)]\n    }\n    return [new Token(Type.array, obj.length), entries]\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} typ\n   * @param {EncodeOptions} options\n   * @param {Reference} [refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Object (obj, typ, options, refStack) {\n    // could be an Object or a Map\n    const isMap = typ !== 'Object'\n    // it's slightly quicker to use Object.keys() than Object.entries()\n    const keys = isMap ? obj.keys() : Object.keys(obj)\n    const length = isMap ? obj.size : keys.length\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyMap, new Token(Type.break)]\n      }\n      return simpleTokens.emptyMap\n    }\n    refStack = Ref.createCheck(refStack, obj)\n    /** @type {TokenOrNestedTokens[]} */\n    const entries = []\n    let i = 0\n    for (const key of keys) {\n      entries[i++] = [\n        objectToTokens(key, options, refStack),\n        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)\n      ]\n    }\n    sortMapEntries(entries, options)\n    if (options.addBreakTokens) {\n      return [new Token(Type.map, length), entries, new Token(Type.break)]\n    }\n    return [new Token(Type.map, length), entries]\n  }\n}\n\ntypeEncoders.Map = typeEncoders.Object\ntypeEncoders.Buffer = typeEncoders.Uint8Array\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${typ}Array`] = typeEncoders.DataView\n}\n\n/**\n * @param {any} obj\n * @param {EncodeOptions} [options]\n * @param {Reference} [refStack]\n * @returns {TokenOrNestedTokens}\n */\nfunction objectToTokens (obj, options = {}, refStack) {\n  const typ = is(obj)\n  const customTypeEncoder = (options && options.typeEncoders && /** @type {OptionalTypeEncoder} */ options.typeEncoders[typ]) || typeEncoders[typ]\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack)\n    if (tokens != null) {\n      return tokens\n    }\n  }\n  const typeEncoder = typeEncoders[typ]\n  if (!typeEncoder) {\n    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`)\n  }\n  return typeEncoder(obj, typ, options, refStack)\n}\n\n/*\nCBOR key sorting is a mess.\n\nThe canonicalisation recommendation from https://tools.ietf.org/html/rfc7049#section-3.9\nincludes the wording:\n\n> The keys in every map must be sorted lowest value to highest.\n> Sorting is performed on the bytes of the representation of the key\n> data items without paying attention to the 3/5 bit splitting for\n> major types.\n> ...\n>  *  If two keys have different lengths, the shorter one sorts\n      earlier;\n>  *  If two keys have the same length, the one with the lower value\n      in (byte-wise) lexical order sorts earlier.\n\n1. It is not clear what \"bytes of the representation of the key\" means: is it\n   the CBOR representation, or the binary representation of the object itself?\n   Consider the int and uint difference here.\n2. It is not clear what \"without paying attention to\" means: do we include it\n   and compare on that? Or do we omit the special prefix byte, (mostly) treating\n   the key in its plain binary representation form.\n\nThe FIDO 2.0: Client To Authenticator Protocol spec takes the original CBOR\nwording and clarifies it according to their understanding.\nhttps://fidoalliance.org/specs/fido-v2.0-rd-20170927/fido-client-to-authenticator-protocol-v2.0-rd-20170927.html#message-encoding\n\n> The keys in every map must be sorted lowest value to highest. Sorting is\n> performed on the bytes of the representation of the key data items without\n> paying attention to the 3/5 bit splitting for major types. The sorting rules\n> are:\n>  * If the major types are different, the one with the lower value in numerical\n>    order sorts earlier.\n>  * If two keys have different lengths, the shorter one sorts earlier;\n>  * If two keys have the same length, the one with the lower value in\n>    (byte-wise) lexical order sorts earlier.\n\nSome other implementations, such as borc, do a full encode then do a\nlength-first, byte-wise-second comparison:\nhttps://github.com/dignifiedquire/borc/blob/b6bae8b0bcde7c3976b0f0f0957208095c392a36/src/encoder.js#L358\nhttps://github.com/dignifiedquire/borc/blob/b6bae8b0bcde7c3976b0f0f0957208095c392a36/src/utils.js#L143-L151\n\nThis has the benefit of being able to easily handle arbitrary keys, including\ncomplex types (maps and arrays).\n\nWe'll opt for the FIDO approach, since it affords some efficies since we don't\nneed a full encode of each key to determine order and can defer to the types\nto determine how to most efficiently order their values (i.e. int and uint\nordering can be done on the numbers, no need for byte-wise, for example).\n\nRecommendation: stick to single key types or you'll get into trouble, and prefer\nstring keys because it's much simpler that way.\n*/\n\n/**\n * @param {TokenOrNestedTokens[]} entries\n * @param {EncodeOptions} options\n */\nfunction sortMapEntries (entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter)\n  }\n}\n\n/**\n * @param {(Token|Token[])[]} e1\n * @param {(Token|Token[])[]} e2\n * @returns {number}\n */\nfunction mapSorter (e1, e2) {\n  // the key position ([0]) could have a single token or an array\n  // almost always it'll be a single token but complex key might get involved\n  /* c8 ignore next 2 */\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0]\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0]\n\n  // different key types\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type)\n  }\n\n  const major = keyToken1.type.major\n  // TODO: handle case where cmp === 0 but there are more keyToken e. complex type)\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2)\n  /* c8 ignore next 5 */\n  if (tcmp === 0) {\n    // duplicate key or complex type where the first token matched,\n    // i.e. a map or array and we're only comparing the opening token\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone')\n  }\n  return tcmp\n}\n\n/**\n * @typedef {Token & { _keyBytes?: Uint8Array }} TokenEx\n *\n * @param {(Token|Token[])[]} e1\n * @param {(Token|Token[])[]} e2\n * @returns {number}\n */\nfunction rfc8949MapSorter (e1, e2) {\n  if (e1[0] instanceof Token && e2[0] instanceof Token) {\n    const t1 = /** @type {TokenEx} */ (e1[0])\n    const t2 = /** @type {TokenEx} */ (e2[0])\n\n    if (!t1._keyBytes) {\n      t1._keyBytes = encodeRfc8949(t1.value)\n    }\n\n    if (!t2._keyBytes) {\n      t2._keyBytes = encodeRfc8949(t2.value)\n    }\n\n    return compare(t1._keyBytes, t2._keyBytes)\n  }\n\n  throw new Error('rfc8949MapSorter: complex key types are not supported yet')\n}\n\n/**\n * @param {any} data\n * @returns {Uint8Array}\n */\nfunction encodeRfc8949 (data) {\n  return encodeCustom(data, cborEncoders, rfc8949EncodeOptions)\n}\n\n/**\n * @param {Bl} buf\n * @param {TokenOrNestedTokens} tokens\n * @param {TokenTypeEncoder[]} encoders\n * @param {EncodeOptions} options\n */\nfunction tokensToEncoded (buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options)\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options)\n  }\n}\n\n/**\n * @param {any} data\n * @param {TokenTypeEncoder[]} encoders\n * @param {EncodeOptions} options\n * @returns {Uint8Array}\n */\nfunction encodeCustom (data, encoders, options) {\n  const tokens = objectToTokens(data, options)\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens)\n    if (quickBytes) {\n      return quickBytes\n    }\n    const encoder = encoders[tokens.type.major]\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options)\n      const buf = new Bl(size)\n      encoder(buf, tokens, options)\n      /* c8 ignore next 4 */\n      // this would be a problem with encodedSize() functions\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`)\n      }\n      return asU8A(buf.chunks[0])\n    }\n  }\n  buf.reset()\n  tokensToEncoded(buf, tokens, encoders, options)\n  return buf.toBytes(true)\n}\n\n/**\n * @param {any} data\n * @param {EncodeOptions} [options]\n * @returns {Uint8Array}\n */\nfunction encode (data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options)\n  return encodeCustom(data, cborEncoders, options)\n}\n\nexport { objectToTokens, encode, encodeCustom, Ref }\n", "import { decodeErrPrefix } from './common.js'\nimport { Type } from './token.js'\nimport { jump, quick } from './jump.js'\n\n/**\n * @typedef {import('./token.js').Token} Token\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../interface').DecodeTokenizer} DecodeTokenizer\n */\n\nconst defaultDecodeOptions = {\n  strict: false,\n  allowIndefinite: true,\n  allowUndefined: true,\n  allowBigInt: true\n}\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass Tokeniser {\n  /**\n   * @param {Uint8Array} data\n   * @param {DecodeOptions} options\n   */\n  constructor (data, options = {}) {\n    this._pos = 0\n    this.data = data\n    this.options = options\n  }\n\n  pos () {\n    return this._pos\n  }\n\n  done () {\n    return this._pos >= this.data.length\n  }\n\n  next () {\n    const byt = this.data[this._pos]\n    let token = quick[byt]\n    if (token === undefined) {\n      const decoder = jump[byt]\n      /* c8 ignore next 4 */\n      // if we're here then there's something wrong with our jump or quick lists!\n      if (!decoder) {\n        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, '0')})`)\n      }\n      const minor = byt & 31\n      token = decoder(this.data, this._pos, minor, this.options)\n    }\n    // @ts-ignore we get to assume encodedLength is set (crossing fingers slightly)\n    this._pos += token.encodedLength\n    return token\n  }\n}\n\nconst DONE = Symbol.for('DONE')\nconst BREAK = Symbol.for('BREAK')\n\n/**\n * @param {Token} token\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokenToArray (token, tokeniser, options) {\n  const arr = []\n  for (let i = 0; i < token.value; i++) {\n    const value = tokensToObject(tokeniser, options)\n    if (value === BREAK) {\n      if (token.value === Infinity) {\n        // normal end to indefinite length array\n        break\n      }\n      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`)\n    }\n    if (value === DONE) {\n      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`)\n    }\n    arr[i] = value\n  }\n  return arr\n}\n\n/**\n * @param {Token} token\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokenToMap (token, tokeniser, options) {\n  const useMaps = options.useMaps === true\n  const obj = useMaps ? undefined : {}\n  const m = useMaps ? new Map() : undefined\n  for (let i = 0; i < token.value; i++) {\n    const key = tokensToObject(tokeniser, options)\n    if (key === BREAK) {\n      if (token.value === Infinity) {\n        // normal end to indefinite length map\n        break\n      }\n      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`)\n    }\n    if (key === DONE) {\n      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`)\n    }\n    if (useMaps !== true && typeof key !== 'string') {\n      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`)\n    }\n    if (options.rejectDuplicateMapKeys === true) {\n      // @ts-ignore\n      if ((useMaps && m.has(key)) || (!useMaps && (key in obj))) {\n        throw new Error(`${decodeErrPrefix} found repeat map key \"${key}\"`)\n      }\n    }\n    const value = tokensToObject(tokeniser, options)\n    if (value === DONE) {\n      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`)\n    }\n    if (useMaps) {\n      // @ts-ignore TODO reconsider this .. maybe needs to be strict about key types\n      m.set(key, value)\n    } else {\n      // @ts-ignore TODO reconsider this .. maybe needs to be strict about key types\n      obj[key] = value\n    }\n  }\n  // @ts-ignore c'mon man\n  return useMaps ? m : obj\n}\n\n/**\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokensToObject (tokeniser, options) {\n  // should we support array as an argument?\n  // check for tokenIter[Symbol.iterator] and replace tokenIter with what that returns?\n  if (tokeniser.done()) {\n    return DONE\n  }\n\n  const token = tokeniser.next()\n\n  if (token.type === Type.break) {\n    return BREAK\n  }\n\n  if (token.type.terminal) {\n    return token.value\n  }\n\n  if (token.type === Type.array) {\n    return tokenToArray(token, tokeniser, options)\n  }\n\n  if (token.type === Type.map) {\n    return tokenToMap(token, tokeniser, options)\n  }\n\n  if (token.type === Type.tag) {\n    if (options.tags && typeof options.tags[token.value] === 'function') {\n      const tagged = tokensToObject(tokeniser, options)\n      return options.tags[token.value](tagged)\n    }\n    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`)\n  }\n  /* c8 ignore next */\n  throw new Error('unsupported')\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {[any, Uint8Array]}\n */\nfunction decodeFirst (data, options) {\n  if (!(data instanceof Uint8Array)) {\n    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`)\n  }\n  options = Object.assign({}, defaultDecodeOptions, options)\n  const tokeniser = options.tokenizer || new Tokeniser(data, options)\n  const decoded = tokensToObject(tokeniser, options)\n  if (decoded === DONE) {\n    throw new Error(`${decodeErrPrefix} did not find any content to decode`)\n  }\n  if (decoded === BREAK) {\n    throw new Error(`${decodeErrPrefix} got unexpected break`)\n  }\n  return [decoded, data.subarray(tokeniser.pos())]\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {any}\n */\nfunction decode (data, options) {\n  const [decoded, remainder] = decodeFirst(data, options)\n  if (remainder.length > 0) {\n    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`)\n  }\n  return decoded\n}\n\nexport { Tokeniser, tokensToObject, decode, decodeFirst }\n", "// Maximum length of the length section of the message\nexport const MAX_LENGTH_LENGTH = 8 // Varint.encode(Number.MAX_SAFE_INTEGER).length\n// Maximum length of the data section of the message\nexport const MAX_DATA_LENGTH = 1024 * 1024 * 4\n", "/**\n * The reported length of the next data message was not a positive integer\n */\nexport class InvalidMessageLengthError extends Error {\n  name = 'InvalidMessageLengthError'\n  code = 'ERR_INVALID_MSG_LENGTH'\n}\n\n/**\n * The reported length of the next data message was larger than the configured\n * max allowable value\n */\nexport class InvalidDataLengthError extends Error {\n  name = 'InvalidDataLengthError'\n  code = 'ERR_MSG_DATA_TOO_LONG'\n}\n\n/**\n * The varint used to specify the length of the next data message contained more\n * bytes than the configured max allowable value\n */\nexport class InvalidDataLengthLengthError extends Error {\n  name = 'InvalidDataLengthLengthError'\n  code = 'ERR_MSG_LENGTH_TOO_LONG'\n}\n\n/**\n * The incoming stream ended before the expected number of bytes were read\n */\nexport class UnexpectedEOFError extends Error {\n  name = 'UnexpectedEOFError'\n  code = 'ERR_UNEXPECTED_EOF'\n}\n", "export function isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n", "import * as varint from 'uint8-varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { allocUnsafe } from 'uint8arrays/alloc'\nimport { MAX_DATA_LENGTH } from './constants.js'\nimport { InvalidDataLengthError } from './errors.js'\nimport { isAsyncIterable } from './utils.js'\nimport type { EncoderOptions, LengthEncoderFunction } from './index.js'\nimport type { Source } from 'it-stream-types'\n\n// Helper function to validate the chunk size against maxDataLength\nfunction validateMaxDataLength (chunk: Uint8Array | Uint8ArrayList, maxDataLength: number): void {\n  if (chunk.byteLength > maxDataLength) {\n    throw new InvalidDataLengthError('Message length too long')\n  }\n}\n\nconst defaultEncoder: LengthEncoderFunction = (length) => {\n  const lengthLength = varint.encodingLength(length)\n  const lengthBuf = allocUnsafe(lengthLength)\n\n  varint.encode(length, lengthBuf)\n\n  defaultEncoder.bytes = lengthLength\n\n  return lengthBuf\n}\ndefaultEncoder.bytes = 0\n\nexport function encode (source: Iterable<Uint8ArrayList | Uint8Array>, options?: EncoderOptions): Generator<Uint8Array, void, undefined>\nexport function encode (source: Source<Uint8ArrayList | Uint8Array>, options?: EncoderOptions): AsyncGenerator<Uint8Array, void, undefined>\nexport function encode (source: Source<Uint8ArrayList | Uint8Array>, options?: EncoderOptions): Generator<Uint8Array, void, undefined> | AsyncGenerator<Uint8Array, void, undefined> {\n  options = options ?? {}\n\n  const encodeLength = options.lengthEncoder ?? defaultEncoder\n  const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH\n\n  function * maybeYield (chunk: Uint8Array | Uint8ArrayList): Generator<Uint8Array, void, undefined> {\n    validateMaxDataLength(chunk, maxDataLength)\n\n    // length + data\n    const length = encodeLength(chunk.byteLength)\n\n    // yield only Uint8Arrays\n    if (length instanceof Uint8Array) {\n      yield length\n    } else {\n      yield * length\n    }\n\n    // yield only Uint8Arrays\n    if (chunk instanceof Uint8Array) {\n      yield chunk\n    } else {\n      yield * chunk\n    }\n  }\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const chunk of source) {\n        yield * maybeYield(chunk)\n      }\n    })()\n  }\n\n  return (function * () {\n    for (const chunk of source) {\n      yield * maybeYield(chunk)\n    }\n  })()\n}\n\nencode.single = (chunk: Uint8ArrayList | Uint8Array, options?: EncoderOptions) => {\n  options = options ?? {}\n  const encodeLength = options.lengthEncoder ?? defaultEncoder\n  const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH\n\n  validateMaxDataLength(chunk, maxDataLength)\n\n  return new Uint8ArrayList(\n    encodeLength(chunk.byteLength),\n    chunk\n  )\n}\n", "/* eslint max-depth: [\"error\", 6] */\n\nimport * as varint from 'uint8-varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { MAX_DATA_LENGTH, MAX_LENGTH_LENGTH } from './constants.js'\nimport { InvalidDataLengthError, InvalidDataLengthLengthError, InvalidMessageLengthError, UnexpectedEOFError } from './errors.js'\nimport { isAsyncIterable } from './utils.js'\nimport type { DecoderOptions, LengthDecoderFunction } from './index.js'\nimport type { Reader } from 'it-reader'\nimport type { Source } from 'it-stream-types'\n\nenum ReadMode {\n  LENGTH,\n  DATA\n}\n\nconst defaultDecoder: LengthDecoderFunction = (buf) => {\n  const length = varint.decode(buf)\n  defaultDecoder.bytes = varint.encodingLength(length)\n\n  return length\n}\ndefaultDecoder.bytes = 0\n\nexport function decode (source: Iterable<Uint8ArrayList | Uint8Array>, options?: DecoderOptions): Generator<Uint8ArrayList, void, unknown>\nexport function decode (source: Source<Uint8ArrayList | Uint8Array>, options?: DecoderOptions): AsyncGenerator<Uint8ArrayList, void, unknown>\nexport function decode (source: Source<Uint8ArrayList | Uint8Array>, options?: DecoderOptions): Generator<Uint8ArrayList, void, unknown> | AsyncGenerator<Uint8ArrayList, void, unknown> {\n  const buffer = new Uint8ArrayList()\n  let mode = ReadMode.LENGTH\n  let dataLength = -1\n\n  const lengthDecoder = options?.lengthDecoder ?? defaultDecoder\n  const maxLengthLength = options?.maxLengthLength ?? MAX_LENGTH_LENGTH\n  const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH\n\n  function * maybeYield (): Generator<Uint8ArrayList> {\n    while (buffer.byteLength > 0) {\n      if (mode === ReadMode.LENGTH) {\n        // read length, ignore errors for short reads\n        try {\n          dataLength = lengthDecoder(buffer)\n\n          if (dataLength < 0) {\n            throw new InvalidMessageLengthError('Invalid message length')\n          }\n\n          if (dataLength > maxDataLength) {\n            throw new InvalidDataLengthError('Message length too long')\n          }\n\n          const dataLengthLength = lengthDecoder.bytes\n          buffer.consume(dataLengthLength)\n\n          if (options?.onLength != null) {\n            options.onLength(dataLength)\n          }\n\n          mode = ReadMode.DATA\n        } catch (err: any) {\n          if (err instanceof RangeError) {\n            if (buffer.byteLength > maxLengthLength) {\n              throw new InvalidDataLengthLengthError('Message length length too long')\n            }\n\n            break\n          }\n\n          throw err\n        }\n      }\n\n      if (mode === ReadMode.DATA) {\n        if (buffer.byteLength < dataLength) {\n          // not enough data, wait for more\n          break\n        }\n\n        const data = buffer.sublist(0, dataLength)\n        buffer.consume(dataLength)\n\n        if (options?.onData != null) {\n          options.onData(data)\n        }\n\n        yield data\n\n        mode = ReadMode.LENGTH\n      }\n    }\n  }\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const buf of source) {\n        buffer.append(buf)\n\n        yield * maybeYield()\n      }\n\n      if (buffer.byteLength > 0) {\n        throw new UnexpectedEOFError('Unexpected end of input')\n      }\n    })()\n  }\n\n  return (function * () {\n    for (const buf of source) {\n      buffer.append(buf)\n\n      yield * maybeYield()\n    }\n\n    if (buffer.byteLength > 0) {\n      throw new UnexpectedEOFError('Unexpected end of input')\n    }\n  })()\n}\n\ndecode.fromReader = (reader: Reader, options?: DecoderOptions) => {\n  let byteLength = 1 // Read single byte chunks until the length is known\n\n  const varByteSource = (async function * () {\n    while (true) {\n      try {\n        const { done, value } = await reader.next(byteLength)\n\n        if (done === true) {\n          return\n        }\n\n        if (value != null) {\n          yield value\n        }\n      } catch (err: any) {\n        if (err.code === 'ERR_UNDER_READ') {\n          return { done: true, value: null }\n        }\n        throw err\n      } finally {\n        // Reset the byteLength so we continue to check for varints\n        byteLength = 1\n      }\n    }\n  }())\n\n  /**\n   * Once the length has been parsed, read chunk for that length\n   */\n  const onLength = (l: number): void => { byteLength = l }\n  return decode(varByteSource, {\n    ...(options ?? {}),\n    onLength\n  })\n}\n", "const s = 1000;\nconst m = s * 60;\nconst h = m * 60;\nconst d = h * 24;\nconst w = d * 7;\nconst y = d * 365.25;\nconst mo = y / 12;\n\ntype Years = 'years' | 'year' | 'yrs' | 'yr' | 'y';\ntype Months = 'months' | 'month' | 'mo';\ntype Weeks = 'weeks' | 'week' | 'w';\ntype Days = 'days' | 'day' | 'd';\ntype Hours = 'hours' | 'hour' | 'hrs' | 'hr' | 'h';\ntype Minutes = 'minutes' | 'minute' | 'mins' | 'min' | 'm';\ntype Seconds = 'seconds' | 'second' | 'secs' | 'sec' | 's';\ntype Milliseconds = 'milliseconds' | 'millisecond' | 'msecs' | 'msec' | 'ms';\ntype Unit =\n  | Years\n  | Months\n  | Weeks\n  | Days\n  | Hours\n  | Minutes\n  | Seconds\n  | Milliseconds;\n\ntype UnitAnyCase = Capitalize<Unit> | Uppercase<Unit> | Unit;\n\nexport type StringValue =\n  | `${number}`\n  | `${number}${UnitAnyCase}`\n  | `${number} ${UnitAnyCase}`;\n\ninterface Options {\n  /**\n   * Set to `true` to use verbose formatting. Defaults to `false`.\n   */\n  long?: boolean;\n}\n\n/**\n * Parse or format the given value.\n *\n * @param value - The string or number to convert\n * @param options - Options for the conversion\n * @throws Error if `value` is not a non-empty string or a number\n */\nexport function ms(value: StringValue, options?: Options): number;\nexport function ms(value: number, options?: Options): string;\nexport function ms(\n  value: StringValue | number,\n  options?: Options,\n): number | string {\n  if (typeof value === 'string') {\n    return parse(value);\n  } else if (typeof value === 'number') {\n    return format(value, options);\n  }\n  throw new Error(\n    `Value provided to ms() must be a string or number. value=${JSON.stringify(value)}`,\n  );\n}\n\nexport default ms;\n\n/**\n * Parse the given string and return milliseconds.\n *\n * @param str - A string to parse to milliseconds\n * @returns The parsed value in milliseconds, or `NaN` if the string can't be\n * parsed\n */\nexport function parse(str: string): number {\n  if (typeof str !== 'string' || str.length === 0 || str.length > 100) {\n    throw new Error(\n      `Value provided to ms.parse() must be a string with length between 1 and 99. value=${JSON.stringify(str)}`,\n    );\n  }\n  const match =\n    /^(?<value>-?\\d*\\.?\\d+) *(?<unit>milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|months?|mo|years?|yrs?|y)?$/i.exec(\n      str,\n    );\n\n  if (!match?.groups) {\n    return NaN;\n  }\n\n  // Named capture groups need to be manually typed today.\n  // https://github.com/microsoft/TypeScript/issues/32098\n  const { value, unit = 'ms' } = match.groups as {\n    value: string;\n    unit: string | undefined;\n  };\n\n  const n = parseFloat(value);\n\n  const matchUnit = unit.toLowerCase() as Lowercase<Unit>;\n\n  /* istanbul ignore next - istanbul doesn't understand, but thankfully the TypeScript the exhaustiveness check in the default case keeps us type safe here */\n  switch (matchUnit) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'months':\n    case 'month':\n    case 'mo':\n      return n * mo;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      matchUnit satisfies never;\n      throw new Error(\n        `Unknown unit \"${matchUnit}\" provided to ms.parse(). value=${JSON.stringify(str)}`,\n      );\n  }\n}\n\n/**\n * Parse the given StringValue and return milliseconds.\n *\n * @param value - A typesafe StringValue to parse to milliseconds\n * @returns The parsed value in milliseconds, or `NaN` if the string can't be\n * parsed\n */\nexport function parseStrict(value: StringValue): number {\n  return parse(value);\n}\n\n/**\n * Short format for `ms`.\n */\nfunction fmtShort(ms: number): StringValue {\n  const msAbs = Math.abs(ms);\n  if (msAbs >= y) {\n    return `${Math.round(ms / y)}y`;\n  }\n  if (msAbs >= mo) {\n    return `${Math.round(ms / mo)}mo`;\n  }\n  if (msAbs >= w) {\n    return `${Math.round(ms / w)}w`;\n  }\n  if (msAbs >= d) {\n    return `${Math.round(ms / d)}d`;\n  }\n  if (msAbs >= h) {\n    return `${Math.round(ms / h)}h`;\n  }\n  if (msAbs >= m) {\n    return `${Math.round(ms / m)}m`;\n  }\n  if (msAbs >= s) {\n    return `${Math.round(ms / s)}s`;\n  }\n  return `${ms}ms`;\n}\n\n/**\n * Long format for `ms`.\n */\nfunction fmtLong(ms: number): StringValue {\n  const msAbs = Math.abs(ms);\n  if (msAbs >= y) {\n    return plural(ms, msAbs, y, 'year');\n  }\n  if (msAbs >= mo) {\n    return plural(ms, msAbs, mo, 'month');\n  }\n  if (msAbs >= w) {\n    return plural(ms, msAbs, w, 'week');\n  }\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return `${ms} ms`;\n}\n\n/**\n * Format the given integer as a string.\n *\n * @param ms - milliseconds\n * @param options - Options for the conversion\n * @returns The formatted string\n */\nexport function format(ms: number, options?: Options): string {\n  if (typeof ms !== 'number' || !Number.isFinite(ms)) {\n    throw new Error('Value provided to ms.format() must be of type number.');\n  }\n\n  return options?.long ? fmtLong(ms) : fmtShort(ms);\n}\n\n/**\n * Pluralization helper.\n */\nfunction plural(\n  ms: number,\n  msAbs: number,\n  n: number,\n  name: string,\n): StringValue {\n  const isPlural = msAbs >= n * 1.5;\n  return `${Math.round(ms / n)} ${name}${isPlural ? 's' : ''}` as StringValue;\n}\n", "/* eslint-disable no-console */\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\nimport humanize from 'ms'\nimport type { Debug, Debugger, Options } from './index.js'\n\nexport default function setup (env: any): Debug {\n  createDebug.debug = createDebug\n  createDebug.default = createDebug\n  createDebug.coerce = coerce\n  createDebug.disable = disable\n  createDebug.enable = enable\n  createDebug.enabled = enabled\n  createDebug.humanize = humanize\n  createDebug.destroy = destroy\n\n  Object.keys(env).forEach(key => {\n    // @ts-expect-error cannot use string to index type\n    createDebug[key] = env[key]\n  })\n\n  /**\n   * The currently active debug mode names, and names to skip.\n   */\n\n  createDebug.names = [] as any[]\n  createDebug.skips = [] as any[]\n\n  /**\n   * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n   *\n   * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n   */\n  createDebug.formatters = {} satisfies Record<string, any>\n\n  /**\n   * Selects a color for a debug namespace\n   *\n   * @param {string} namespace - The namespace string for the debug instance to be colored\n   * @returns {number | string} An ANSI color code for the given namespace\n   */\n  function selectColor (namespace: string): number | string {\n    let hash = 0\n\n    for (let i = 0; i < namespace.length; i++) {\n      hash = ((hash << 5) - hash) + namespace.charCodeAt(i)\n      hash |= 0 // Convert to 32bit integer\n    }\n\n    // @ts-expect-error colors is not in the types\n    return createDebug.colors[Math.abs(hash) % createDebug.colors.length]\n  }\n  createDebug.selectColor = selectColor\n\n  /**\n   * Create a debugger with the given `namespace`.\n   *\n   * @param {string} namespace\n   * @returns {Function}\n   */\n  function createDebug (namespace: string, options?: Options): Debugger {\n    let prevTime: any\n    let enableOverride: any = null\n    let namespacesCache: any\n    let enabledCache: any\n\n    function debug (...args: any[]): void {\n      // Disabled?\n      // @ts-expect-error enabled is not in the types\n      if (!debug.enabled) {\n        return\n      }\n\n      const self: any = debug\n\n      // Set `diff` timestamp\n      const curr = Number(new Date())\n      const ms = curr - (prevTime || curr)\n      self.diff = ms\n      self.prev = prevTime\n      self.curr = curr\n      prevTime = curr\n\n      args[0] = createDebug.coerce(args[0])\n\n      if (typeof args[0] !== 'string') {\n        // Anything else let's inspect with %O\n        args.unshift('%O')\n      }\n\n      // Apply any `formatters` transformations\n      let index = 0\n      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match: any, format: any): any => {\n        // If we encounter an escaped % then don't increase the array index\n        if (match === '%%') {\n          return '%'\n        }\n        index++\n        // @ts-expect-error formatters is not in the types\n        const formatter = createDebug.formatters[format]\n        if (typeof formatter === 'function') {\n          const val = args[index]\n          match = formatter.call(self, val)\n\n          // Now we need to remove `args[index]` since it's inlined in the `format`\n          args.splice(index, 1)\n          index--\n        }\n        return match\n      })\n\n      // Apply env-specific formatting (colors, etc.)\n      // @ts-expect-error formatArgs is not in the types\n      createDebug.formatArgs.call(self, args)\n\n      if (options?.onLog != null) {\n        options.onLog(...args)\n      }\n\n      // @ts-expect-error log is not in the types\n      const logFn = self.log || createDebug.log\n      logFn.apply(self, args)\n    }\n\n    debug.namespace = namespace\n    // @ts-expect-error useColors is not in the types\n    debug.useColors = createDebug.useColors()\n    debug.color = createDebug.selectColor(namespace)\n    debug.extend = extend\n    debug.destroy = createDebug.destroy // XXX Temporary. Will be removed in the next major release.\n\n    Object.defineProperty(debug, 'enabled', {\n      enumerable: true,\n      configurable: false,\n      get: () => {\n        if (enableOverride !== null) {\n          return enableOverride\n        }\n        // @ts-expect-error namespaces is not in the types\n        if (namespacesCache !== createDebug.namespaces) {\n          // @ts-expect-error namespaces is not in the types\n          namespacesCache = createDebug.namespaces\n          enabledCache = createDebug.enabled(namespace)\n        }\n\n        return enabledCache\n      },\n      set: v => {\n        enableOverride = v\n      }\n    })\n\n    // Env-specific initialization logic for debug instances\n    // @ts-expect-error init is not in the types\n    if (typeof createDebug.init === 'function') {\n      // @ts-expect-error init is not in the types\n      createDebug.init(debug)\n    }\n\n    // @ts-expect-error some properties are added dynamically\n    return debug\n  }\n\n  function extend (this: any, namespace: string, delimiter: string): any {\n    const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace)\n    newDebug.log = this.log\n    return newDebug\n  }\n\n  /**\n   * Enables a debug mode by namespaces. This can include modes\n   * separated by a colon and wildcards.\n   *\n   * @param {string} namespaces\n   */\n  function enable (namespaces: string): void {\n    // @ts-expect-error save is not in the types\n    createDebug.save(namespaces)\n    // @ts-expect-error namespaces is not in the types\n    createDebug.namespaces = namespaces\n\n    createDebug.names = []\n    createDebug.skips = []\n\n    let i\n    const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/)\n    const len = split.length\n\n    for (i = 0; i < len; i++) {\n      if (!split[i]) {\n        // ignore empty strings\n        continue\n      }\n\n      namespaces = split[i].replace(/\\*/g, '.*?')\n\n      if (namespaces[0] === '-') {\n        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'))\n      } else {\n        createDebug.names.push(new RegExp('^' + namespaces + '$'))\n      }\n    }\n  }\n\n  /**\n   * Disable debug output.\n   *\n   * @returns {string} namespaces\n   */\n  function disable (): string {\n    const namespaces = [\n      ...createDebug.names.map(toNamespace),\n      ...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n    ].join(',')\n    createDebug.enable('')\n    return namespaces\n  }\n\n  /**\n   * Returns true if the given mode name is enabled, false otherwise.\n   *\n   * @param {string} name\n   * @returns {boolean}\n   */\n  function enabled (name: string): boolean {\n    if (name[name.length - 1] === '*') {\n      return true\n    }\n\n    let i\n    let len\n\n    for (i = 0, len = createDebug.skips.length; i < len; i++) {\n      if (createDebug.skips[i].test(name)) {\n        return false\n      }\n    }\n\n    for (i = 0, len = createDebug.names.length; i < len; i++) {\n      if (createDebug.names[i].test(name)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Convert regexp to namespace\n   */\n  function toNamespace (regexp: RegExp): string {\n    return regexp.toString()\n      .substring(2, regexp.toString().length - 2)\n      .replace(/\\.\\*\\?$/, '*')\n  }\n\n  /**\n   * Coerce `val`.\n   */\n  function coerce (val: any): any {\n    if (val instanceof Error) {\n      return val.stack ?? val.message\n    }\n    return val\n  }\n\n  /**\n   * XXX DO NOT USE. This is a temporary stub function.\n   * XXX It WILL be removed in the next major release.\n   */\n  function destroy (): void {\n    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.')\n  }\n\n  // @ts-expect-error setupFormatters is not in the types\n  createDebug.setupFormatters(createDebug.formatters)\n\n  // @ts-expect-error load is not in the types\n  createDebug.enable(createDebug.load())\n\n  // @ts-expect-error some properties are added dynamically\n  return createDebug\n}\n", "/* eslint-disable no-console */\n\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\nimport humanize from 'ms'\nimport setup from './common.js'\n\nconst storage = localstorage()\n\n/**\n * Colors.\n */\nconst colors = [\n  '#0000CC',\n  '#0000FF',\n  '#0033CC',\n  '#0033FF',\n  '#0066CC',\n  '#0066FF',\n  '#0099CC',\n  '#0099FF',\n  '#00CC00',\n  '#00CC33',\n  '#00CC66',\n  '#00CC99',\n  '#00CCCC',\n  '#00CCFF',\n  '#3300CC',\n  '#3300FF',\n  '#3333CC',\n  '#3333FF',\n  '#3366CC',\n  '#3366FF',\n  '#3399CC',\n  '#3399FF',\n  '#33CC00',\n  '#33CC33',\n  '#33CC66',\n  '#33CC99',\n  '#33CCCC',\n  '#33CCFF',\n  '#6600CC',\n  '#6600FF',\n  '#6633CC',\n  '#6633FF',\n  '#66CC00',\n  '#66CC33',\n  '#9900CC',\n  '#9900FF',\n  '#9933CC',\n  '#9933FF',\n  '#99CC00',\n  '#99CC33',\n  '#CC0000',\n  '#CC0033',\n  '#CC0066',\n  '#CC0099',\n  '#CC00CC',\n  '#CC00FF',\n  '#CC3300',\n  '#CC3333',\n  '#CC3366',\n  '#CC3399',\n  '#CC33CC',\n  '#CC33FF',\n  '#CC6600',\n  '#CC6633',\n  '#CC9900',\n  '#CC9933',\n  '#CCCC00',\n  '#CCCC33',\n  '#FF0000',\n  '#FF0033',\n  '#FF0066',\n  '#FF0099',\n  '#FF00CC',\n  '#FF00FF',\n  '#FF3300',\n  '#FF3333',\n  '#FF3366',\n  '#FF3399',\n  '#FF33CC',\n  '#FF33FF',\n  '#FF6600',\n  '#FF6633',\n  '#FF9900',\n  '#FF9933',\n  '#FFCC00',\n  '#FFCC33'\n]\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors (): boolean {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  // @ts-expect-error window.process.type and window.process.__nwjs are not in the types\n  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n    return true\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && (navigator.userAgent?.toLowerCase().match(/(edge|trident)\\/(\\d+)/) != null)) {\n    return false\n  }\n\n  // Is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  // @ts-expect-error document.documentElement.style.WebkitAppearance is not in the types\n  return (typeof document !== 'undefined' && document.documentElement?.style?.WebkitAppearance) ||\n    // Is firebug? http://stackoverflow.com/a/398120/376773\n    // @ts-expect-error window.console.firebug and window.console.exception are not in the types\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // Is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && (navigator.userAgent?.toLowerCase().match(/firefox\\/(\\d+)/) != null) && parseInt(RegExp.$1, 10) >= 31) ||\n    // Double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent?.toLowerCase().match(/applewebkit\\/(\\d+)/))\n}\n\n/**\n * Colorize log arguments if enabled.\n */\nfunction formatArgs (this: any, args: any[]): void {\n  args[0] = (this.useColors ? '%c' : '') +\n    this.namespace +\n    (this.useColors ? ' %c' : ' ') +\n    args[0] +\n    (this.useColors ? '%c ' : ' ') +\n    '+' + humanize(this.diff)\n\n  if (!this.useColors) {\n    return\n  }\n\n  const c = 'color: ' + this.color\n  args.splice(1, 0, c, 'color: inherit')\n\n  // The final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  let index = 0\n  let lastC = 0\n  args[0].replace(/%[a-zA-Z%]/g, (match: string) => {\n    if (match === '%%') {\n      return\n    }\n    index++\n    if (match === '%c') {\n      // We only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index\n    }\n  })\n\n  args.splice(lastC, 0, c)\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n */\nconst log = console.debug ?? console.log ?? (() => { })\n\n/**\n * Save `namespaces`.\n *\n * @param {string} namespaces\n */\nfunction save (namespaces: string): void {\n  try {\n    if (namespaces) {\n      storage?.setItem('debug', namespaces)\n    } else {\n      storage?.removeItem('debug')\n    }\n  } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @returns {string} returns the previously persisted debug modes\n */\nfunction load (): string | null | undefined {\n  let r\n  try {\n    r = storage?.getItem('debug')\n  } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof globalThis.process !== 'undefined' && 'env' in globalThis.process) {\n    r = globalThis.process.env.DEBUG\n  }\n\n  return r\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n */\nfunction localstorage (): Storage | undefined {\n  try {\n    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n    // The Browser also has localStorage in the global context.\n    return localStorage\n  } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n\nfunction setupFormatters (formatters: any): void {\n  /**\n   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n   */\n  formatters.j = function (v: any) {\n    try {\n      return JSON.stringify(v)\n    } catch (error: any) {\n      return '[UnexpectedJSONParseError]: ' + error.message\n    }\n  }\n}\n\nexport default setup({ formatArgs, save, load, useColors, setupFormatters, colors, storage, log })\n", "/**\n * @packageDocumentation\n *\n * This module is a fork of the [debug](https://www.npmjs.com/package/debug) module. It has been converted to TypeScript and the output is ESM.\n *\n * It is API compatible with no extra features or bug fixes, it should only be used if you want a 100% ESM application.\n *\n * ESM should be arriving in `debug@5.x.x` so this module can be retired after that.\n *\n * Please see [debug](https://www.npmjs.com/package/debug) for API details.\n */\n\n/**\n * Module dependencies.\n */\nimport weald from './node.js'\nimport type ms from 'ms'\n\nexport interface Options {\n  /**\n   * Receives log lines. The default transport writes the log line to\n   * `process.stderr`, `console.debug` or `console.log` depending on what is\n   * available in the environment.\n   *\n   * The args are not formatted - they can be passed to `util.format` from\n   * Node.js or to `format` exported from this module as `weald/format`.\n   *\n   * @example Receiving log lines\n   *\n   * ```ts\n   * import debug from 'weald'\n   * import { format } from 'weald/format'\n   *\n   * const logger = debug('my-namespace', {\n   *   onLog (...args: any[]) {\n   *     const line = format(...args)\n   *     // do something with `line`\n   *   }\n   * })\n   * ```\n   */\n  onLog?(...args: any[]): void\n}\n\nexport interface Debug {\n  (namespace: string, options?: Options): Debugger\n  coerce(val: any): any\n  disable(...args: string[]): string\n  enable(namespaces: string | boolean): void\n  enabled(namespaces: string): boolean\n  formatArgs(this: Debugger, args: any[]): void\n  log(fmt: string, ...args: any[]): unknown\n  selectColor(namespace: string): string | number\n  humanize: typeof ms\n  useColors(): boolean\n\n  names: RegExp[]\n  skips: RegExp[]\n\n  formatters: Formatters\n\n  inspectOpts?: {\n    hideDate?: boolean | number | null\n    colors?: boolean | number | null\n    depth?: boolean | number | null\n    showHidden?: boolean | number | null\n  }\n}\n\nexport type Formatters = Record<string, (v: any) => string>\n\nexport interface Debugger {\n  (formatter: any, ...args: any[]): void\n\n  color: string\n  diff: number\n  enabled: boolean\n  log(fmt: string, ...args: any[]): unknown\n  namespace: string\n  destroy(): boolean\n  extend(namespace: string, delimiter?: string): Debugger\n  useColors(): boolean\n}\n\nexport default weald\n", "/**\n * @packageDocumentation\n *\n * A logger for libp2p based on [weald](https://www.npmjs.com/package/weald), a TypeScript port of the venerable [debug](https://www.npmjs.com/package/debug) module.\n *\n * @example\n *\n * ```TypeScript\n * import { logger } from '@libp2p/logger'\n *\n * const log = logger('libp2p:my:component:name')\n *\n * try {\n *   // an operation\n *   log('something happened: %s', 'it was ok')\n * } catch (err) {\n *   log.error('something bad happened: %e', err)\n * }\n *\n * log('with this peer: %p', {})\n * log('and this base58btc: %b', Uint8Array.from([0, 1, 2, 3]))\n * log('and this base32: %t', Uint8Array.from([4, 5, 6, 7]))\n * ```\n *\n * ```console\n * $ DEBUG=libp2p:* node index.js\n * something happened: it was ok\n * something bad happened: <stack trace>\n * with this peer: 12D3Foo\n * with this base58btc: Qmfoo\n * with this base32: bafyfoo\n * ```\n */\n\nimport { base32 } from 'multiformats/bases/base32'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { base64 } from 'multiformats/bases/base64'\nimport debug from 'weald'\nimport { truncatePeerId } from './utils.js'\nimport type { PeerId, Logger, ComponentLogger } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Key } from 'interface-datastore'\nimport type { CID } from 'multiformats/cid'\nimport type { Options as LoggerOptions } from 'weald'\n\nexport type { LoggerOptions }\n\n// Add a formatter for converting to a base58 string\ndebug.formatters.b = (v?: Uint8Array): string => {\n  return v == null ? 'undefined' : base58btc.baseEncode(v)\n}\n\n// Add a formatter for converting to a base32 string\ndebug.formatters.t = (v?: Uint8Array): string => {\n  return v == null ? 'undefined' : base32.baseEncode(v)\n}\n\n// Add a formatter for converting to a base64 string\ndebug.formatters.m = (v?: Uint8Array): string => {\n  return v == null ? 'undefined' : base64.baseEncode(v)\n}\n\n// Add a formatter for stringifying peer ids\ndebug.formatters.p = (v?: PeerId): string => {\n  return v == null ? 'undefined' : v.toString()\n}\n\n// Add a formatter for stringifying CIDs\ndebug.formatters.c = (v?: CID): string => {\n  return v == null ? 'undefined' : v.toString()\n}\n\n// Add a formatter for stringifying Datastore keys\ndebug.formatters.k = (v: Key): string => {\n  return v == null ? 'undefined' : v.toString()\n}\n\n// Add a formatter for stringifying Multiaddrs\ndebug.formatters.a = (v?: Multiaddr): string => {\n  return v == null ? 'undefined' : v.toString()\n}\n\nfunction formatError (v: Error, indent = ''): string {\n  const message = notEmpty(v.message)\n  const stack = notEmpty(v.stack)\n\n  // some browser errors (mostly from Firefox) have no message or no stack,\n  // sometimes both, sometimes neither. Sometimes the message is in the stack,\n  // sometimes is isn't so try to do *something* useful\n  if (message != null && stack != null) {\n    if (stack.includes(message)) {\n      return `${stack.split('\\n').join(`\\n${indent}`)}`\n    }\n\n    return `${message}\\n${indent}${stack.split('\\n').join(`\\n${indent}`)}`\n  }\n\n  if (stack != null) {\n    return `${stack.split('\\n').join(`\\n${indent}`)}`\n  }\n\n  if (message != null) {\n    return `${message}`\n  }\n\n  return `${v.toString()}`\n}\n\nfunction isAggregateError (err?: any): err is AggregateError {\n  return err instanceof AggregateError || (err?.name === 'AggregateError' && Array.isArray(err.errors))\n}\n\nfunction printError (err: Error, indent = ''): string {\n  if (isAggregateError(err)) {\n    let output = formatError(err, indent)\n\n    if (err.errors.length > 0) {\n      indent = `${indent}    `\n\n      output += `\\n${indent}${\n        err.errors\n        .map(err => `${printError(err, `${indent}`)}`)\n        .join(`\\n${indent}`)\n      }`\n    } else {\n      output += `\\n${indent}[Error list was empty]`\n    }\n\n    return output.trim()\n  }\n\n  return formatError(err, indent)\n}\n\n// Add a formatter for stringifying Errors\ndebug.formatters.e = (v?: Error): string => {\n  if (v == null) {\n    return 'undefined'\n  }\n\n  return printError(v)\n}\n\nexport type { Logger, ComponentLogger }\n\nfunction createDisabledLogger (namespace: string): debug.Debugger {\n  const logger = (): void => {}\n  logger.enabled = false\n  logger.color = ''\n  logger.diff = 0\n  logger.log = (): void => {}\n  logger.namespace = namespace\n  logger.destroy = () => true\n  logger.extend = () => logger\n\n  return logger\n}\n\nexport interface PeerLoggerOptions extends LoggerOptions {\n  prefixLength?: number\n  suffixLength?: number\n}\n\n/**\n * Create a component logger that will prefix any log messages with a truncated\n * peer id.\n *\n * @example\n *\n * ```TypeScript\n * import { peerLogger } from '@libp2p/logger'\n * import { peerIdFromString } from '@libp2p/peer-id'\n *\n * const peerId = peerIdFromString('12D3FooBar')\n * const logger = peerLogger(peerId)\n *\n * const log = logger.forComponent('my-component')\n * log.info('hello world')\n * // logs \"12oBar:my-component hello world\"\n * ```\n */\nexport function peerLogger (peerId: PeerId, options: PeerLoggerOptions = {}): ComponentLogger {\n  return prefixLogger(truncatePeerId(peerId, options), options)\n}\n\n/**\n * Create a component logger that will prefix any log messages with the passed\n * string.\n *\n * @example\n *\n * ```TypeScript\n * import { prefixLogger } from '@libp2p/logger'\n *\n * const logger = prefixLogger('my-node')\n *\n * const log = logger.forComponent('my-component')\n * log.info('hello world')\n * // logs \"my-node:my-component hello world\"\n * ```\n */\nexport function prefixLogger (prefix: string, options?: LoggerOptions): ComponentLogger {\n  return {\n    forComponent (name: string) {\n      return logger(`${prefix}:${name}`, options)\n    }\n  }\n}\n\n/**\n * Create a component logger\n *\n * @example\n *\n * ```TypeScript\n * import { defaultLogger } from '@libp2p/logger'\n * import { peerIdFromString } from '@libp2p/peer-id'\n *\n * const logger = defaultLogger()\n *\n * const log = logger.forComponent('my-component')\n * log.info('hello world')\n * // logs \"my-component hello world\"\n * ```\n */\nexport function defaultLogger (options?: LoggerOptions): ComponentLogger {\n  return {\n    forComponent (name: string) {\n      return logger(name, options)\n    }\n  }\n}\n\n/**\n * Creates a logger for the passed component name.\n *\n * @example\n *\n * ```TypeScript\n * import { logger } from '@libp2p/logger'\n *\n * const log = logger('my-component')\n * log.info('hello world')\n * // logs \"my-component hello world\"\n * ```\n */\nexport function logger (name: string, options?: LoggerOptions): Logger {\n  // trace logging is a no-op by default\n  let trace: debug.Debugger = createDisabledLogger(`${name}:trace`)\n\n  // look at all the debug names and see if trace logging has explicitly been enabled\n  if (debug.enabled(`${name}:trace`) && debug.names.map((r: any) => r.toString()).find((n: string) => n.includes(':trace')) != null) {\n    trace = debug(`${name}:trace`, options)\n  }\n\n  return Object.assign(debug(name, options), {\n    error: debug(`${name}:error`, options),\n    trace,\n    newScope: (scope: string) => logger(`${name}:${scope}`, options)\n  })\n}\n\nexport function disable (): void {\n  debug.disable()\n}\n\nexport function enable (namespaces: string): void {\n  debug.enable(namespaces)\n}\n\nexport function enabled (namespaces: string): boolean {\n  return debug.enabled(namespaces)\n}\n\nfunction notEmpty (str?: string): string | undefined {\n  if (str == null) {\n    return\n  }\n\n  str = str.trim()\n\n  if (str.length === 0) {\n    return\n  }\n\n  return str\n}\n", "// Maximum safe timeout value for setTimeout in JavaScript (2^31 - 1 milliseconds)\n// This is approximately 24.8 days\nexport const MAX_TIMEOUT = 2_147_483_647;\n\n// Brand symbol to identify our timeout/interval objects\n// Use Symbol.for to ensure cross-copy compatibility (monorepos, hoisted deps, etc.)\nconst brandSymbol = Symbol.for('sindresorhus/unlimited-timeout#brand');\n\nexport function setTimeout(callback, delay, ...arguments_) {\n\tif (typeof callback !== 'function') {\n\t\tthrow new TypeError('Expected callback to be a function');\n\t}\n\n\t// Coerce delay to number, matching native setTimeout behavior\n\tdelay ??= 0;\n\tdelay = Number(delay);\n\n\tlet shouldUnref = false;\n\tconst timeout = {\n\t\t[brandSymbol]: true,\n\t\tid: undefined,\n\t\tcleared: false,\n\t\tref() {\n\t\t\tshouldUnref = false;\n\t\t\ttimeout.id?.ref?.();\n\t\t\treturn timeout;\n\t\t},\n\t\tunref() {\n\t\t\tshouldUnref = true;\n\t\t\ttimeout.id?.unref?.();\n\t\t\treturn timeout;\n\t\t},\n\t};\n\n\t// Treat delays beyond MAX_SAFE_INTEGER as Infinity (precision loss)\n\t// and positive Infinity means wait forever (never fire)\n\tif (delay === Number.POSITIVE_INFINITY || delay > Number.MAX_SAFE_INTEGER) {\n\t\treturn timeout;\n\t}\n\n\t// Clamp invalid values to 0 (NaN, negative numbers result in immediate firing)\n\tif (!Number.isFinite(delay) || delay < 0) {\n\t\tdelay = 0;\n\t}\n\n\t// Track target timestamp to avoid overshoot when chunks fire late\n\tconst targetTime = performance.now() + delay;\n\n\tconst schedule = remainingDelay => {\n\t\tif (timeout.cleared) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (remainingDelay <= MAX_TIMEOUT) {\n\t\t\t// Final timeout - execute callback\n\t\t\ttimeout.id = globalThis.setTimeout(() => {\n\t\t\t\tif (!timeout.cleared) {\n\t\t\t\t\tcallback(...arguments_);\n\t\t\t\t}\n\t\t\t}, remainingDelay);\n\n\t\t\tif (shouldUnref) {\n\t\t\t\ttimeout.id?.unref?.();\n\t\t\t}\n\t\t} else {\n\t\t\t// Schedule next chunk\n\t\t\ttimeout.id = globalThis.setTimeout(() => {\n\t\t\t\tconst now = performance.now();\n\t\t\t\tconst remaining = Math.max(0, targetTime - now);\n\t\t\t\tschedule(remaining);\n\t\t\t}, MAX_TIMEOUT);\n\n\t\t\tif (shouldUnref) {\n\t\t\t\ttimeout.id?.unref?.();\n\t\t\t}\n\t\t}\n\t};\n\n\tschedule(delay);\n\n\treturn timeout;\n}\n\nexport function clearTimeout(timeout) {\n\tif (!timeout || typeof timeout !== 'object' || !timeout[brandSymbol]) {\n\t\treturn;\n\t}\n\n\ttimeout.cleared = true;\n\n\tif (timeout.id !== undefined) {\n\t\tglobalThis.clearTimeout(timeout.id);\n\t\ttimeout.id = undefined;\n\t}\n}\n\nexport function setInterval(callback, delay, ...arguments_) {\n\tif (typeof callback !== 'function') {\n\t\tthrow new TypeError('Expected callback to be a function');\n\t}\n\n\t// Coerce delay to number, matching native setInterval behavior\n\tdelay ??= 0;\n\tdelay = Number(delay);\n\n\tlet shouldUnref = false;\n\tconst interval = {\n\t\t[brandSymbol]: true,\n\t\tid: undefined,\n\t\tcleared: false,\n\t\tref() {\n\t\t\tshouldUnref = false;\n\t\t\tinterval.id?.ref?.();\n\t\t\treturn interval;\n\t\t},\n\t\tunref() {\n\t\t\tshouldUnref = true;\n\t\t\tinterval.id?.unref?.();\n\t\t\treturn interval;\n\t\t},\n\t};\n\n\t// Treat delays beyond MAX_SAFE_INTEGER as Infinity (precision loss)\n\t// and positive Infinity means wait forever (never fire)\n\tif (delay === Number.POSITIVE_INFINITY || delay > Number.MAX_SAFE_INTEGER) {\n\t\treturn interval;\n\t}\n\n\t// Clamp invalid values to 0 (NaN, negative numbers result in immediate firing)\n\tif (!Number.isFinite(delay) || delay < 0) {\n\t\tdelay = 0;\n\t}\n\n\t// Track target timestamp to avoid drift (use monotonic clock)\n\tlet nextTargetTime = performance.now() + delay;\n\n\tconst schedule = remainingDelay => {\n\t\tif (interval.cleared) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (remainingDelay <= MAX_TIMEOUT) {\n\t\t\t// Final timeout before callback\n\t\t\tinterval.id = globalThis.setTimeout(() => {\n\t\t\t\tif (interval.cleared) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Pre-schedule next tick so throws don't kill the interval\n\t\t\t\tnextTargetTime += delay;\n\t\t\t\tconst now = performance.now();\n\t\t\t\tconst nextDelay = Math.max(0, nextTargetTime - now);\n\t\t\t\tschedule(nextDelay);\n\n\t\t\t\t// Now run user code  if it throws, the next tick still happens\n\t\t\t\tcallback(...arguments_);\n\t\t\t}, remainingDelay);\n\n\t\t\tif (shouldUnref) {\n\t\t\t\tinterval.id?.unref?.();\n\t\t\t}\n\t\t} else {\n\t\t\t// Schedule next chunk\n\t\t\tinterval.id = globalThis.setTimeout(() => {\n\t\t\t\tconst now = performance.now();\n\t\t\t\tconst nextDelay = Math.max(0, nextTargetTime - now);\n\t\t\t\tschedule(nextDelay);\n\t\t\t}, MAX_TIMEOUT);\n\n\t\t\tif (shouldUnref) {\n\t\t\t\tinterval.id?.unref?.();\n\t\t\t}\n\t\t}\n\t};\n\n\tschedule(delay);\n\n\treturn interval;\n}\n\nexport function clearInterval(interval) {\n\tif (!interval || typeof interval !== 'object' || !interval[brandSymbol]) {\n\t\treturn;\n\t}\n\n\tinterval.cleared = true;\n\n\tif (interval.id !== undefined) {\n\t\tglobalThis.clearTimeout(interval.id);\n\t\tinterval.id = undefined;\n\t}\n}\n", "import {setTimeout as safeSetTimeout, clearTimeout as safeClearTimeout} from 'unlimited-timeout';\nimport randomInteger from 'random-int';\n\nconst clearMethods = new WeakMap();\n\nexport function createDelay({clearTimeout: defaultClear, setTimeout: defaultSet} = {}) {\n\t// We cannot use `async` here as we need the promise identity.\n\treturn (milliseconds, {value, signal} = {}) => {\n\t\tif (signal?.aborted) {\n\t\t\treturn Promise.reject(signal.reason);\n\t\t}\n\n\t\tlet timeoutId;\n\t\tlet settle;\n\t\tlet rejectFunction;\n\t\tconst clear = defaultClear ?? clearTimeout;\n\n\t\tconst signalListener = () => {\n\t\t\tclear(timeoutId);\n\t\t\trejectFunction(signal.reason);\n\t\t};\n\n\t\tconst cleanup = () => {\n\t\t\tif (signal) {\n\t\t\t\tsignal.removeEventListener('abort', signalListener);\n\t\t\t}\n\t\t};\n\n\t\tconst delayPromise = new Promise((resolve, reject) => {\n\t\t\tsettle = () => {\n\t\t\t\tcleanup();\n\t\t\t\tresolve(value);\n\t\t\t};\n\n\t\t\trejectFunction = reject;\n\t\t\ttimeoutId = (defaultSet ?? setTimeout)(settle, milliseconds);\n\t\t});\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', signalListener, {once: true});\n\t\t}\n\n\t\tclearMethods.set(delayPromise, () => {\n\t\t\tclear(timeoutId);\n\t\t\ttimeoutId = null;\n\t\t\tsettle();\n\t\t});\n\n\t\treturn delayPromise;\n\t};\n}\n\nconst delay = createDelay({setTimeout: safeSetTimeout, clearTimeout: safeClearTimeout});\n\nexport default delay;\n\nexport async function rangeDelay(minimum, maximum, options) {\n\treturn delay(randomInteger(minimum, maximum), options);\n}\n\nexport function clearDelay(promise) {\n\tclearMethods.get(promise)?.();\n}\n", "import { StreamMessageEvent } from '@libp2p/interface'\nimport delay from 'delay'\nimport { TypedEventEmitter } from 'main-event'\nimport { raceSignal } from 'race-signal'\nimport { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist'\nimport { Queue } from './queue/index.js'\nimport type { AbortOptions, Logger } from '@libp2p/interface'\n\nconst DEFAULT_CHUNK_SIZE = 1024 * 64\n\nexport interface MessageQueueEvents {\n  /**\n   * Message data\n   */\n  message: StreamMessageEvent\n\n  /**\n   * Emitted when the queue is empty\n   */\n  drain: Event\n\n  /**\n   * The remote closed the connection abruptly\n   */\n  reset: Event\n}\n\nexport interface MessageQueueInit {\n  /**\n   * How much delay there should be between each message send in ms (note that\n   * even 0 introduces a small delay)\n   *\n   * @default 0\n   */\n  delay?: number\n\n  /**\n   * How many messages to hold in the send queue before applying backpressure to\n   * the sender\n   */\n  capacity?: number\n\n  /**\n   * Data messages larger than this size will be chunked into smaller messages.\n   *\n   * Defaults to the maximum TCP package size.\n   *\n   * @default 65_536\n   */\n  chunkSize?: number\n}\n\ninterface MessageQueueJobOptions extends AbortOptions {\n  evt: Event\n}\n\n/**\n * Accepts events to emit after a short delay, and with a configurable maximum\n * queue capacity after which the send method will return false to let us\n * simulate write backpressure.\n */\nexport class MessageQueue<Events> extends TypedEventEmitter<Events & MessageQueueEvents> {\n  public needsDrain: boolean\n\n  private queue: Queue<void, MessageQueueJobOptions>\n  private capacity: number\n  private delay: number\n  private log: Logger\n  private chunkSize: number\n\n  constructor (init: MessageQueueInit & { log: Logger }) {\n    super()\n\n    this.needsDrain = false\n    this.queue = new Queue({\n      concurrency: 1\n    })\n    this.capacity = init.capacity ?? 5\n    this.delay = init.delay ?? 0\n    this.log = init.log\n    this.chunkSize = init.chunkSize ?? DEFAULT_CHUNK_SIZE\n\n    this.queue.addEventListener('idle', () => {\n      if (this.needsDrain) {\n        this.log('network send queue drained')\n        this.needsDrain = false\n        this.safeDispatchEvent('drain')\n      } else {\n        this.log('network send queue idle')\n      }\n    })\n  }\n\n  send (evt: Event): boolean {\n    if (isMessageEvent(evt)) {\n      // chunk outgoing messages to match TCP packet sizes\n      const data = new Uint8ArrayList(evt.data)\n\n      while (data.byteLength > 0) {\n        const end = Math.min(this.chunkSize, data.byteLength)\n        const chunk = data.sublist(0, end)\n        data.consume(chunk.byteLength)\n\n        const chunkEvent = new StreamMessageEvent(chunk)\n\n        this.queue.add(async (opts) => {\n          if (this.delay > 0) {\n            await raceSignal(delay(this.delay), opts.signal)\n          }\n\n          this.dispatchEvent(opts.evt)\n        }, {\n          evt: chunkEvent\n        })\n      }\n    } else {\n      this.queue.add(async (opts) => {\n        if (this.delay > 0) {\n          await raceSignal(delay(this.delay), opts.signal)\n        }\n\n        this.dispatchEvent(opts.evt)\n      }, {\n        evt\n      })\n    }\n\n    if (this.queue.size >= this.capacity) {\n      this.log('network send queue full')\n      this.needsDrain = true\n      return false\n    }\n\n    return true\n  }\n\n  pause (): void {\n    this.queue.pause()\n  }\n\n  resume (): void {\n    this.queue.resume()\n  }\n\n  onIdle (): Promise<void> {\n    return this.queue.onIdle()\n  }\n\n  size (): number {\n    return this.queue.size\n  }\n}\n\nfunction isMessageEvent (evt?: any): evt is StreamMessageEvent {\n  return evt?.data instanceof Uint8Array || isUint8ArrayList(evt?.data)\n}\n", "import { Queue } from './queue/index.js'\nimport type { Job } from './queue/job.js'\nimport type { AbortOptions, PeerId } from '@libp2p/interface'\n\nexport interface PeerQueueJobOptions extends AbortOptions {\n  peerId: PeerId\n}\n\n/**\n * Extends Queue to add support for querying queued jobs by peer id\n */\nexport class PeerQueue<JobReturnType = void, JobOptions extends PeerQueueJobOptions = PeerQueueJobOptions> extends Queue<JobReturnType, JobOptions> {\n  has (peerId: PeerId): boolean {\n    return this.find(peerId) != null\n  }\n\n  find (peerId: PeerId): Job<JobOptions, JobReturnType> | undefined {\n    return this.queue.find(job => {\n      return peerId.equals(job.options.peerId)\n    })\n  }\n}\n", "import { Queue } from './queue/index.js'\nimport type { QueueInit } from './queue/index.js'\nimport type { AbortOptions } from '@libp2p/interface'\n\nexport interface PriorityQueueJobOptions extends AbortOptions {\n  priority: number\n}\n\nexport class PriorityQueue <JobReturnType = void, JobOptions extends PriorityQueueJobOptions = PriorityQueueJobOptions> extends Queue<JobReturnType, JobOptions> {\n  constructor (init: QueueInit<JobReturnType, JobOptions> = {}) {\n    super({\n      ...init,\n      sort: (a, b) => {\n        if (a.options.priority > b.options.priority) {\n          return -1\n        }\n\n        if (a.options.priority < b.options.priority) {\n          return 1\n        }\n\n        return 0\n      }\n    })\n  }\n}\n", "import { RateLimitError } from './errors.js'\n\nexport interface RateLimiterInit {\n  /**\n   * Number of points\n   *\n   * @default 4\n   */\n  points?: number\n\n  /**\n   * Per seconds\n   *\n   * @default 1\n   */\n  duration?: number\n\n  /**\n   * Block if consumed more than points in current duration for blockDuration seconds\n   *\n   * @default 0\n   */\n  blockDuration?: number\n\n  /**\n   * @default \"rlflx\"\n   */\n  keyPrefix?: string\n}\n\nexport interface GetKeySecDurationOptions {\n  customDuration?: number\n}\n\nexport interface RateLimiterResult {\n  remainingPoints: number\n  msBeforeNext: number\n  consumedPoints: number\n  isFirstInDuration: boolean\n}\n\nexport interface RateRecord {\n  value: number\n  expiresAt?: Date\n  timeoutId?: ReturnType<typeof setTimeout>\n}\n\nexport class RateLimiter {\n  public readonly memoryStorage: MemoryStorage\n  protected points: number\n  protected duration: number\n  protected blockDuration: number\n  protected keyPrefix: string\n\n  constructor (opts: RateLimiterInit = {}) {\n    this.points = opts.points ?? 4\n    this.duration = opts.duration ?? 1\n    this.blockDuration = opts.blockDuration ?? 0\n    this.keyPrefix = opts.keyPrefix ?? 'rlflx'\n    this.memoryStorage = new MemoryStorage()\n  }\n\n  consume (key: string, pointsToConsume: number = 1, options: GetKeySecDurationOptions = {}): RateLimiterResult {\n    const rlKey = this.getKey(key)\n    const secDuration = this._getKeySecDuration(options)\n    let res = this.memoryStorage.incrby(rlKey, pointsToConsume, secDuration)\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0)\n\n    if (res.consumedPoints > this.points) {\n      // Block only first time when consumed more than points\n      if (this.blockDuration > 0 && res.consumedPoints <= (this.points + pointsToConsume)) {\n        // Block key\n        res = this.memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration)\n      }\n\n      throw new RateLimitError('Rate limit exceeded', res)\n    }\n\n    return res\n  }\n\n  penalty (key: string, points: number = 1, options: GetKeySecDurationOptions = {}): RateLimiterResult {\n    const rlKey = this.getKey(key)\n    const secDuration = this._getKeySecDuration(options)\n    const res = this.memoryStorage.incrby(rlKey, points, secDuration)\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0)\n\n    return res\n  }\n\n  reward (key: string, points: number = 1, options: GetKeySecDurationOptions = {}): RateLimiterResult {\n    const rlKey = this.getKey(key)\n    const secDuration = this._getKeySecDuration(options)\n    const res = this.memoryStorage.incrby(rlKey, -points, secDuration)\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0)\n\n    return res\n  }\n\n  /**\n   * Block any key for secDuration seconds\n   *\n   * @param key\n   * @param secDuration\n   */\n  block (key: string, secDuration: number): RateLimiterResult {\n    const msDuration = secDuration * 1000\n    const initPoints = this.points + 1\n\n    this.memoryStorage.set(this.getKey(key), initPoints, secDuration)\n\n    return {\n      remainingPoints: 0,\n      msBeforeNext: msDuration === 0 ? -1 : msDuration,\n      consumedPoints: initPoints,\n      isFirstInDuration: false\n    }\n  }\n\n  set (key: string, points: number, secDuration: number = 0): RateLimiterResult {\n    const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1000\n\n    this.memoryStorage.set(this.getKey(key), points, secDuration)\n\n    return {\n      remainingPoints: 0,\n      msBeforeNext: msDuration === 0 ? -1 : msDuration,\n      consumedPoints: points,\n      isFirstInDuration: false\n    }\n  }\n\n  get (key: string): RateLimiterResult | undefined {\n    const res = this.memoryStorage.get(this.getKey(key))\n\n    if (res != null) {\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0)\n    }\n\n    return res\n  }\n\n  delete (key: string): void {\n    this.memoryStorage.delete(this.getKey(key))\n  }\n\n  private _getKeySecDuration (options?: GetKeySecDurationOptions): number {\n    if (options?.customDuration != null && options.customDuration >= 0) {\n      return options.customDuration\n    }\n\n    return this.duration\n  }\n\n  getKey (key: string): string {\n    return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${key}` : key\n  }\n\n  parseKey (rlKey: string): string {\n    return rlKey.substring(this.keyPrefix.length)\n  }\n}\n\nexport class MemoryStorage {\n  public readonly storage: Map<string, RateRecord>\n\n  constructor () {\n    this.storage = new Map()\n  }\n\n  incrby (key: string, value: number, durationSec: number): RateLimiterResult {\n    const existing = this.storage.get(key)\n\n    if (existing != null) {\n      const msBeforeExpires = existing.expiresAt != null\n        ? existing.expiresAt.getTime() - new Date().getTime()\n        : -1\n\n      if (existing.expiresAt == null || msBeforeExpires > 0) {\n        // Change value\n        existing.value += value\n\n        return {\n          remainingPoints: 0,\n          msBeforeNext: msBeforeExpires,\n          consumedPoints: existing.value,\n          isFirstInDuration: false\n        }\n      }\n\n      return this.set(key, value, durationSec)\n    }\n\n    return this.set(key, value, durationSec)\n  }\n\n  set (key: string, value: number, durationSec: number): RateLimiterResult {\n    const durationMs = durationSec * 1000\n    const existing = this.storage.get(key)\n\n    if (existing != null) {\n      clearTimeout(existing.timeoutId)\n    }\n\n    const record: RateRecord = {\n      value,\n      expiresAt: durationMs > 0 ? new Date(Date.now() + durationMs) : undefined\n    }\n\n    this.storage.set(key, record)\n\n    if (durationMs > 0) {\n      record.timeoutId = setTimeout(() => {\n        this.storage.delete(key)\n      }, durationMs)\n\n      if ((record.timeoutId as any).unref != null) {\n        (record.timeoutId as any).unref()\n      }\n    }\n\n    return {\n      remainingPoints: 0,\n      msBeforeNext: durationMs === 0 ? -1 : durationMs,\n      consumedPoints: record.value,\n      isFirstInDuration: true\n    }\n  }\n\n  get (key: string): RateLimiterResult | undefined {\n    const existing = this.storage.get(key)\n\n    if (existing != null) {\n      const msBeforeExpires = existing.expiresAt != null\n        ? existing.expiresAt.getTime() - new Date().getTime()\n        : -1\n      return {\n        remainingPoints: 0,\n        msBeforeNext: msBeforeExpires,\n        consumedPoints: existing.value,\n        isFirstInDuration: false\n      }\n    }\n  }\n\n  delete (key: string): boolean {\n    const record = this.storage.get(key)\n\n    if (record != null) {\n      if (record.timeoutId != null) {\n        clearTimeout(record.timeoutId)\n      }\n\n      this.storage.delete(key)\n\n      return true\n    }\n    return false\n  }\n}\n", "import { anySignal } from 'any-signal'\nimport { setMaxListeners } from 'main-event'\nimport { debounce } from './debounce.ts'\nimport type { AbortOptions } from '@libp2p/interface'\n\nexport interface RepeatingTask {\n  /**\n   * Update the interval after which the next iteration of the task will run.\n   *\n   * This is useful if, for example, you want to retry a task with a short rest\n   * duration until it succeeds, then periodically after that.\n   *\n   * This only affects the next iteration of the task, if it is currently\n   * running, that run will not be interrupted.\n   *\n   * Setting the interval to the current value has no effect.\n   */\n  setInterval(ms: number): void\n\n  /**\n   * Update the amount of time a task will run before the passed abort signal\n   * will fire.\n   *\n   * This only affects the next iteration of the task, if it is currently\n   * running, that run will not be interrupted.\n   */\n  setTimeout(ms: number): void\n\n  /**\n   * Schedule the task to be run immediately - if the task is not running it\n   * will run after a short delay in order to debounce multiple `.run()`\n   * invocations.\n   */\n  run(): void\n\n  /**\n   * Start the task running\n   */\n  start(): void\n\n  /**\n   * Stop the task running\n   */\n  stop(): void\n}\n\nexport interface RepeatingTaskOptions {\n  /**\n   * How long the task is allowed to run before the passed AbortSignal fires an\n   * abort event\n   */\n  timeout?: number\n\n  /**\n   * Whether to schedule the task to run immediately\n   *\n   * @default false\n   */\n  runImmediately?: boolean\n\n  /**\n   * When `.run()` is called to run the task outside of the current interval,\n   * debounce repeated calls to `.run()` by this amount.\n   *\n   * @default 100\n   */\n  debounce?: number\n}\n\nexport function repeatingTask (fn: (options?: AbortOptions) => void | Promise<void>, interval: number, options?: RepeatingTaskOptions): RepeatingTask {\n  let timeout: ReturnType<typeof setTimeout>\n  let shutdownController: AbortController\n  let running = false\n\n  function runTask (): void {\n    const opts: AbortOptions = {\n      signal: shutdownController.signal\n    }\n\n    if (options?.timeout != null) {\n      const signal = anySignal([shutdownController.signal, AbortSignal.timeout(options.timeout)])\n      setMaxListeners(Infinity, signal)\n\n      opts.signal = signal\n    }\n\n    running = true\n\n    Promise.resolve().then(async () => {\n      await fn(opts)\n    })\n      .catch(() => {})\n      .finally(() => {\n        running = false\n\n        if (shutdownController.signal.aborted) {\n          // task has been cancelled, bail\n          return\n        }\n\n        // reschedule\n        timeout = setTimeout(runTask, interval)\n      })\n  }\n\n  const runTaskDebounced = debounce(runTask, options?.debounce ?? 100)\n\n  let started = false\n\n  return {\n    setInterval: (ms): void => {\n      if (interval === ms) {\n        // already running at this interval, nothing to do\n        return\n      }\n\n      interval = ms\n\n      // maybe reschedule\n      if (timeout != null) {\n        clearTimeout(timeout)\n        timeout = setTimeout(runTask, interval)\n      }\n    },\n    setTimeout: (ms): void => {\n      options ??= {}\n      options.timeout = ms\n    },\n    run: (): void => {\n      if (running) {\n        return\n      }\n\n      clearTimeout(timeout)\n      runTaskDebounced()\n    },\n    start: (): void => {\n      if (started) {\n        return\n      }\n\n      started = true\n      shutdownController = new AbortController()\n      setMaxListeners(Infinity, shutdownController.signal)\n\n      // run now\n      if (options?.runImmediately === true) {\n        queueMicrotask(() => {\n          runTask()\n        })\n      } else {\n        // run later\n        timeout = setTimeout(runTask, interval)\n      }\n    },\n    stop: (): void => {\n      clearTimeout(timeout)\n      shutdownController?.abort()\n      started = false\n    }\n  }\n}\n", "import type { Metric, Metrics } from '@libp2p/interface'\n\nexport interface TrackedMapInit {\n  name: string\n  metrics: Metrics\n}\n\nclass TrackedMap<K, V> extends Map<K, V> {\n  private readonly metric: Metric\n\n  constructor (init: TrackedMapInit) {\n    super()\n\n    const { name, metrics } = init\n\n    this.metric = metrics.registerMetric(name)\n    this.updateComponentMetric()\n  }\n\n  set (key: K, value: V): this {\n    super.set(key, value)\n    this.updateComponentMetric()\n    return this\n  }\n\n  delete (key: K): boolean {\n    const deleted = super.delete(key)\n    this.updateComponentMetric()\n    return deleted\n  }\n\n  clear (): void {\n    super.clear()\n    this.updateComponentMetric()\n  }\n\n  private updateComponentMetric (): void {\n    this.metric.update(this.size)\n  }\n}\n\nexport interface CreateTrackedMapInit {\n  /**\n   * The metric name to use\n   */\n  name: string\n\n  /**\n   * A metrics implementation\n   */\n  metrics?: Metrics\n}\n\nexport function trackedMap <K, V> (config: CreateTrackedMapInit): Map<K, V> {\n  const { name, metrics } = config\n  let map: Map<K, V>\n\n  if (metrics != null) {\n    map = new TrackedMap<K, V>({ name, metrics })\n  } else {\n    map = new Map<K, V>()\n  }\n\n  return map\n}\n"],
  "mappings": "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",
  "names": ["Netmask", "a", "c", "d", "i", "n", "s", "AbortError", "buffer", "buffer", "pushable", "options", "AbortError", "_pushable", "isAsyncIterable", "i", "p", "source", "byteStream", "lpStream", "buf", "pbStream", "d", "source", "pipe", "fnv1a", "buf", "i", "i", "fnv1a", "i", "n", "load", "fnv1a", "i", "a", "i", "e", "n", "i", "s", "m", "l", "i", "m", "l", "import_netmask", "r", "i", "err", "buf", "s", "err", "_a", "s", "signal", "t", "a", "DEFAULT_MAX_BUFFER_SIZE", "buf", "isBuffer", "buf", "fromString", "c", "alloc", "isBuffer", "i", "p", "c", "buf", "alloc", "buf", "encodedSize", "buf", "encodedSize", "compareTokens", "buf", "l", "fromString", "encodedSize", "compareTokens", "toToken", "l", "toToken", "l", "buf", "encodedSize", "toToken", "l", "buf", "encodedSize", "buf", "encodedSize", "buf", "encodedSize", "ui8a", "i", "p", "i", "e", "buf", "InvalidMessageLengthError", "InvalidDataLengthError", "InvalidDataLengthLengthError", "UnexpectedEOFError", "isAsyncIterable", "InvalidDataLengthError", "encode", "isAsyncIterable", "ReadMode", "buf", "decode", "buffer", "InvalidMessageLengthError", "InvalidDataLengthError", "InvalidDataLengthLengthError", "isAsyncIterable", "UnexpectedEOFError", "l", "value: StringValue | number", "options?: Options", "e", "t", "str: string", "s", "c", "l", "d", "f", "ms: number", "c", "ms", "options?: Options", "t", "msAbs: number", "n: number", "name: string", "i", "n", "r", "i", "c", "r", "src_default", "src_default", "err", "logger", "src_default", "r", "n", "setTimeout", "delay", "clearTimeout", "setTimeout", "clearTimeout", "a"]
}
