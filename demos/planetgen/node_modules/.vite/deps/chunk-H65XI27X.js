import {
  multiaddr
} from "./chunk-SAZZGDH5.js";
import {
  peerIdFromMultihash
} from "./chunk-RA2DG4WK.js";
import {
  MaxLengthError,
  Uint8ArrayList,
  decodeMessage,
  encodeMessage,
  message,
  publicKeyFromProtobuf,
  publicKeyToProtobuf
} from "./chunk-HXWYJQY6.js";
import {
  alloc,
  decode,
  encode,
  equals,
  fromString
} from "./chunk-PS3LPXH2.js";
import {
  __publicField
} from "./chunk-WOOG5QLI.js";

// ../../node_modules/@libp2p/peer-record/dist/src/envelope/envelope.js
var Envelope;
(function(Envelope2) {
  let _codec;
  Envelope2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.publicKey != null && obj.publicKey.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (obj.payloadType != null && obj.payloadType.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.payloadType);
        }
        if (obj.payload != null && obj.payload.byteLength > 0) {
          w.uint32(26);
          w.bytes(obj.payload);
        }
        if (obj.signature != null && obj.signature.byteLength > 0) {
          w.uint32(42);
          w.bytes(obj.signature);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        const obj = {
          publicKey: alloc(0),
          payloadType: alloc(0),
          payload: alloc(0),
          signature: alloc(0)
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 2: {
              obj.payloadType = reader.bytes();
              break;
            }
            case 3: {
              obj.payload = reader.bytes();
              break;
            }
            case 5: {
              obj.signature = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Envelope2.encode = (obj) => {
    return encodeMessage(obj, Envelope2.codec());
  };
  Envelope2.decode = (buf, opts) => {
    return decodeMessage(buf, Envelope2.codec(), opts);
  };
})(Envelope || (Envelope = {}));

// ../../node_modules/@libp2p/peer-record/dist/src/envelope/errors.js
var InvalidSignatureError = class extends Error {
  constructor(message2 = "Invalid signature") {
    super(message2);
    this.name = "InvalidSignatureError";
  }
};

// ../../node_modules/@libp2p/peer-record/dist/src/envelope/index.js
var _RecordEnvelope = class _RecordEnvelope {
  /**
   * The Envelope is responsible for keeping an arbitrary signed record
   * by a libp2p peer.
   */
  constructor(init) {
    __publicField(this, "publicKey");
    __publicField(this, "payloadType");
    __publicField(this, "payload");
    __publicField(this, "signature");
    __publicField(this, "marshaled");
    const { publicKey, payloadType, payload, signature } = init;
    this.publicKey = publicKey;
    this.payloadType = payloadType;
    this.payload = payload;
    this.signature = signature;
  }
  /**
   * Marshal the envelope content
   */
  marshal() {
    if (this.marshaled == null) {
      this.marshaled = Envelope.encode({
        publicKey: publicKeyToProtobuf(this.publicKey),
        payloadType: this.payloadType,
        payload: this.payload.subarray(),
        signature: this.signature
      });
    }
    return this.marshaled;
  }
  /**
   * Verifies if the other Envelope is identical to this one
   */
  equals(other) {
    if (other == null) {
      return false;
    }
    return equals(this.marshal(), other.marshal());
  }
  /**
   * Validate envelope data signature for the given domain
   */
  async validate(domain, options) {
    const signData = formatSignaturePayload(domain, this.payloadType, this.payload);
    return this.publicKey.verify(signData.subarray(), this.signature, options);
  }
};
/**
 * Unmarshal a serialized Envelope protobuf message
 */
__publicField(_RecordEnvelope, "createFromProtobuf", (data) => {
  const envelopeData = Envelope.decode(data);
  const publicKey = publicKeyFromProtobuf(envelopeData.publicKey);
  return new _RecordEnvelope({
    publicKey,
    payloadType: envelopeData.payloadType,
    payload: envelopeData.payload,
    signature: envelopeData.signature
  });
});
/**
 * Seal marshals the given Record, places the marshaled bytes inside an Envelope
 * and signs it with the given peerId's private key
 */
__publicField(_RecordEnvelope, "seal", async (record, privateKey, options) => {
  if (privateKey == null) {
    throw new Error("Missing private key");
  }
  const domain = record.domain;
  const payloadType = record.codec;
  const payload = record.marshal();
  const signData = formatSignaturePayload(domain, payloadType, payload);
  const signature = await privateKey.sign(signData.subarray(), options);
  return new _RecordEnvelope({
    publicKey: privateKey.publicKey,
    payloadType,
    payload,
    signature
  });
});
/**
 * Open and certify a given marshaled envelope.
 * Data is unmarshaled and the signature validated for the given domain.
 */
__publicField(_RecordEnvelope, "openAndCertify", async (data, domain, options) => {
  const envelope = _RecordEnvelope.createFromProtobuf(data);
  const valid = await envelope.validate(domain, options);
  if (!valid) {
    throw new InvalidSignatureError("Envelope signature is not valid for the given domain");
  }
  return envelope;
});
var RecordEnvelope = _RecordEnvelope;
var formatSignaturePayload = (domain, payloadType, payload) => {
  const domainUint8Array = fromString(domain);
  const domainLength = encode(domainUint8Array.byteLength);
  const payloadTypeLength = encode(payloadType.length);
  const payloadLength = encode(payload.length);
  return new Uint8ArrayList(domainLength, domainUint8Array, payloadTypeLength, payloadType, payloadLength, payload);
};

// ../../node_modules/@libp2p/peer-record/dist/src/peer-record/consts.js
var ENVELOPE_DOMAIN_PEER_RECORD = "libp2p-peer-record";
var ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1]);

// ../../node_modules/@libp2p/peer-record/dist/src/peer-record/peer-record.js
var PeerRecord;
(function(PeerRecord3) {
  let AddressInfo;
  (function(AddressInfo2) {
    let _codec2;
    AddressInfo2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.multiaddr);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length, opts = {}) => {
          const obj = {
            multiaddr: alloc(0)
          };
          const end = length == null ? reader.len : reader.pos + length;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.multiaddr = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    AddressInfo2.encode = (obj) => {
      return encodeMessage(obj, AddressInfo2.codec());
    };
    AddressInfo2.decode = (buf, opts) => {
      return decodeMessage(buf, AddressInfo2.codec(), opts);
    };
  })(AddressInfo = PeerRecord3.AddressInfo || (PeerRecord3.AddressInfo = {}));
  let _codec;
  PeerRecord3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.peerId != null && obj.peerId.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.peerId);
        }
        if (obj.seq != null && obj.seq !== 0n) {
          w.uint32(16);
          w.uint64(obj.seq);
        }
        if (obj.addresses != null) {
          for (const value of obj.addresses) {
            w.uint32(26);
            PeerRecord3.AddressInfo.codec().encode(value, w);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        var _a, _b;
        const obj = {
          peerId: alloc(0),
          seq: 0n,
          addresses: []
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.peerId = reader.bytes();
              break;
            }
            case 2: {
              obj.seq = reader.uint64();
              break;
            }
            case 3: {
              if (((_a = opts.limits) == null ? void 0 : _a.addresses) != null && obj.addresses.length === opts.limits.addresses) {
                throw new MaxLengthError('Decode error - map field "addresses" had too many elements');
              }
              obj.addresses.push(PeerRecord3.AddressInfo.codec().decode(reader, reader.uint32(), {
                limits: (_b = opts.limits) == null ? void 0 : _b.addresses$
              }));
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerRecord3.encode = (obj) => {
    return encodeMessage(obj, PeerRecord3.codec());
  };
  PeerRecord3.decode = (buf, opts) => {
    return decodeMessage(buf, PeerRecord3.codec(), opts);
  };
})(PeerRecord || (PeerRecord = {}));

// ../../node_modules/@libp2p/peer-record/dist/src/peer-record/utils.js
function arrayEquals(a, b) {
  const sort = (a2, b2) => a2.toString().localeCompare(b2.toString());
  if (a.length !== b.length) {
    return false;
  }
  b.sort(sort);
  return a.sort(sort).every((item, index) => b[index].equals(item));
}

// ../../node_modules/@libp2p/peer-record/dist/src/peer-record/index.js
var _PeerRecord = class _PeerRecord {
  constructor(init) {
    __publicField(this, "peerId");
    __publicField(this, "multiaddrs");
    __publicField(this, "seqNumber");
    __publicField(this, "domain", _PeerRecord.DOMAIN);
    __publicField(this, "codec", _PeerRecord.CODEC);
    __publicField(this, "marshaled");
    const { peerId, multiaddrs, seqNumber } = init;
    this.peerId = peerId;
    this.multiaddrs = multiaddrs ?? [];
    this.seqNumber = seqNumber ?? BigInt(Date.now());
  }
  /**
   * Marshal a record to be used in an envelope
   */
  marshal() {
    if (this.marshaled == null) {
      this.marshaled = PeerRecord.encode({
        peerId: this.peerId.toMultihash().bytes,
        seq: BigInt(this.seqNumber),
        addresses: this.multiaddrs.map((m) => ({
          multiaddr: m.bytes
        }))
      });
    }
    return this.marshaled;
  }
  /**
   * Returns true if `this` record equals the `other`
   */
  equals(other) {
    if (!(other instanceof _PeerRecord)) {
      return false;
    }
    if (!this.peerId.equals(other.peerId)) {
      return false;
    }
    if (this.seqNumber !== other.seqNumber) {
      return false;
    }
    if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {
      return false;
    }
    return true;
  }
};
/**
 * Unmarshal Peer Record Protobuf
 */
__publicField(_PeerRecord, "createFromProtobuf", (buf) => {
  const peerRecord = PeerRecord.decode(buf);
  const peerId = peerIdFromMultihash(decode(peerRecord.peerId));
  const multiaddrs = (peerRecord.addresses ?? []).map((a) => multiaddr(a.multiaddr));
  const seqNumber = peerRecord.seq;
  return new _PeerRecord({ peerId, multiaddrs, seqNumber });
});
__publicField(_PeerRecord, "DOMAIN", ENVELOPE_DOMAIN_PEER_RECORD);
__publicField(_PeerRecord, "CODEC", ENVELOPE_PAYLOAD_TYPE_PEER_RECORD);
var PeerRecord2 = _PeerRecord;

export {
  RecordEnvelope,
  PeerRecord2 as PeerRecord
};
//# sourceMappingURL=chunk-H65XI27X.js.map
