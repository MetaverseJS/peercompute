{
  "version": 3,
  "sources": ["../../../../../node_modules/@libp2p/circuit-relay-v2/src/constants.ts", "../../../../../node_modules/@libp2p/circuit-relay-v2/src/pb/index.ts", "../../../../../node_modules/@libp2p/circuit-relay-v2/src/errors.ts", "../../../../../node_modules/@libp2p/circuit-relay-v2/src/utils.ts", "../../../../../node_modules/retimeable-signal/src/index.ts", "../../../../../node_modules/@libp2p/circuit-relay-v2/src/server/reservation-store.ts", "../../../../../node_modules/@libp2p/circuit-relay-v2/src/server/reservation-voucher.ts", "../../../../../node_modules/@libp2p/circuit-relay-v2/src/server/index.ts", "../../../../../node_modules/@libp2p/circuit-relay-v2/src/transport/discovery.ts", "../../../../../node_modules/@libp2p/circuit-relay-v2/src/transport/listener.ts", "../../../../../node_modules/@libp2p/circuit-relay-v2/node_modules/nanoid/url-alphabet/index.js", "../../../../../node_modules/@libp2p/circuit-relay-v2/node_modules/nanoid/index.browser.js", "../../../../../node_modules/@libp2p/circuit-relay-v2/src/transport/reservation-store.ts", "../../../../../node_modules/@libp2p/circuit-relay-v2/src/transport/stream-to-conn.ts", "../../../../../node_modules/@libp2p/circuit-relay-v2/src/transport/index.ts", "../../../../../node_modules/@libp2p/circuit-relay-v2/src/index.ts"],
  "sourcesContent": ["import { KEEP_ALIVE } from '@libp2p/interface'\n\nconst second = 1000\nconst minute = 60 * second\n\n/**\n * The maximum number of relay reservations the relay server will accept\n */\nexport const DEFAULT_MAX_RESERVATION_STORE_SIZE = 15\n\n/**\n * How often to check for reservation expiry\n */\nexport const DEFAULT_MAX_RESERVATION_TTL = 2 * 60 * minute\n\n/**\n * How many reservation attempts to make in parallel\n */\nexport const DEFAULT_RESERVATION_CONCURRENCY = 1\n\n/**\n * How long to wait for a reservation attempt to finish\n */\nexport const DEFAULT_RESERVATION_COMPLETION_TIMEOUT = 5_000\n\n/**\n * How long to let the reservation attempt queue to grow\n */\nexport const DEFAULT_MAX_RESERVATION_QUEUE_LENGTH = 100\n\nexport const RELAY_SOURCE_TAG = 'circuit-relay-source'\n\nexport const KEEP_ALIVE_TAG = `${KEEP_ALIVE}-circuit-relay`\n\n// circuit v2 connection limits\n// https://github.com/libp2p/go-libp2p/blob/master/p2p/protocol/circuitv2/relay/resources.go#L61-L66\n\n// 2 min is the default connection duration\nexport const DEFAULT_DURATION_LIMIT = 2 * minute\n\n// 128k is the default data limit\nexport const DEFAULT_DATA_LIMIT = BigInt(1 << 17)\n\n/**\n * The hop protocol\n */\nexport const RELAY_V2_HOP_CODEC = '/libp2p/circuit/relay/0.2.0/hop'\n\n/**\n * the stop protocol\n */\nexport const RELAY_V2_STOP_CODEC = '/libp2p/circuit/relay/0.2.0/stop'\n\n/**\n * Hop messages must be exchanged inside this timeout\n */\nexport const DEFAULT_HOP_TIMEOUT = 30 * second\n\n/**\n * How long to wait before starting to advertise the relay service\n */\nexport const DEFAULT_ADVERT_BOOT_DELAY = 30 * second\n\nexport const MAX_CONNECTIONS = 300\n\nexport const DEFAULT_DISCOVERY_FILTER_SIZE = 4096\nexport const DEFAULT_DISCOVERY_FILTER_ERROR_RATE = 0.001\n", "import { decodeMessage, encodeMessage, enumeration, MaxLengthError, message } from 'protons-runtime'\nimport { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc'\nimport type { Codec, DecodeOptions } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface HopMessage {\n  type?: HopMessage.Type\n  peer?: Peer\n  reservation?: Reservation\n  limit?: Limit\n  status?: Status\n}\n\nexport namespace HopMessage {\n  export enum Type {\n    RESERVE = 'RESERVE',\n    CONNECT = 'CONNECT',\n    STATUS = 'STATUS'\n  }\n\n  enum __TypeValues {\n    RESERVE = 0,\n    CONNECT = 1,\n    STATUS = 2\n  }\n\n  export namespace Type {\n    export const codec = (): Codec<Type> => {\n      return enumeration<Type>(__TypeValues)\n    }\n  }\n\n  let _codec: Codec<HopMessage>\n\n  export const codec = (): Codec<HopMessage> => {\n    if (_codec == null) {\n      _codec = message<HopMessage>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.type != null) {\n          w.uint32(8)\n          HopMessage.Type.codec().encode(obj.type, w)\n        }\n\n        if (obj.peer != null) {\n          w.uint32(18)\n          Peer.codec().encode(obj.peer, w)\n        }\n\n        if (obj.reservation != null) {\n          w.uint32(26)\n          Reservation.codec().encode(obj.reservation, w)\n        }\n\n        if (obj.limit != null) {\n          w.uint32(34)\n          Limit.codec().encode(obj.limit, w)\n        }\n\n        if (obj.status != null) {\n          w.uint32(40)\n          Status.codec().encode(obj.status, w)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.type = HopMessage.Type.codec().decode(reader)\n              break\n            }\n            case 2: {\n              obj.peer = Peer.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.peer\n              })\n              break\n            }\n            case 3: {\n              obj.reservation = Reservation.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.reservation\n              })\n              break\n            }\n            case 4: {\n              obj.limit = Limit.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.limit\n              })\n              break\n            }\n            case 5: {\n              obj.status = Status.codec().decode(reader)\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<HopMessage>): Uint8Array => {\n    return encodeMessage(obj, HopMessage.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<HopMessage>): HopMessage => {\n    return decodeMessage(buf, HopMessage.codec(), opts)\n  }\n}\n\nexport interface StopMessage {\n  type?: StopMessage.Type\n  peer?: Peer\n  limit?: Limit\n  status?: Status\n}\n\nexport namespace StopMessage {\n  export enum Type {\n    CONNECT = 'CONNECT',\n    STATUS = 'STATUS'\n  }\n\n  enum __TypeValues {\n    CONNECT = 0,\n    STATUS = 1\n  }\n\n  export namespace Type {\n    export const codec = (): Codec<Type> => {\n      return enumeration<Type>(__TypeValues)\n    }\n  }\n\n  let _codec: Codec<StopMessage>\n\n  export const codec = (): Codec<StopMessage> => {\n    if (_codec == null) {\n      _codec = message<StopMessage>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.type != null) {\n          w.uint32(8)\n          StopMessage.Type.codec().encode(obj.type, w)\n        }\n\n        if (obj.peer != null) {\n          w.uint32(18)\n          Peer.codec().encode(obj.peer, w)\n        }\n\n        if (obj.limit != null) {\n          w.uint32(26)\n          Limit.codec().encode(obj.limit, w)\n        }\n\n        if (obj.status != null) {\n          w.uint32(32)\n          Status.codec().encode(obj.status, w)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.type = StopMessage.Type.codec().decode(reader)\n              break\n            }\n            case 2: {\n              obj.peer = Peer.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.peer\n              })\n              break\n            }\n            case 3: {\n              obj.limit = Limit.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.limit\n              })\n              break\n            }\n            case 4: {\n              obj.status = Status.codec().decode(reader)\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<StopMessage>): Uint8Array => {\n    return encodeMessage(obj, StopMessage.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<StopMessage>): StopMessage => {\n    return decodeMessage(buf, StopMessage.codec(), opts)\n  }\n}\n\nexport interface Peer {\n  id: Uint8Array\n  addrs: Uint8Array[]\n}\n\nexport namespace Peer {\n  let _codec: Codec<Peer>\n\n  export const codec = (): Codec<Peer> => {\n    if (_codec == null) {\n      _codec = message<Peer>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.id != null && obj.id.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.id)\n        }\n\n        if (obj.addrs != null) {\n          for (const value of obj.addrs) {\n            w.uint32(18)\n            w.bytes(value)\n          }\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          id: uint8ArrayAlloc(0),\n          addrs: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.id = reader.bytes()\n              break\n            }\n            case 2: {\n              if (opts.limits?.addrs != null && obj.addrs.length === opts.limits.addrs) {\n                throw new MaxLengthError('Decode error - map field \"addrs\" had too many elements')\n              }\n\n              obj.addrs.push(reader.bytes())\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Peer>): Uint8Array => {\n    return encodeMessage(obj, Peer.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Peer>): Peer => {\n    return decodeMessage(buf, Peer.codec(), opts)\n  }\n}\n\nexport interface Reservation {\n  expire: bigint\n  addrs: Uint8Array[]\n  voucher?: Envelope\n}\n\nexport namespace Reservation {\n  let _codec: Codec<Reservation>\n\n  export const codec = (): Codec<Reservation> => {\n    if (_codec == null) {\n      _codec = message<Reservation>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.expire != null && obj.expire !== 0n)) {\n          w.uint32(8)\n          w.uint64(obj.expire)\n        }\n\n        if (obj.addrs != null) {\n          for (const value of obj.addrs) {\n            w.uint32(18)\n            w.bytes(value)\n          }\n        }\n\n        if (obj.voucher != null) {\n          w.uint32(26)\n          Envelope.codec().encode(obj.voucher, w)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          expire: 0n,\n          addrs: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.expire = reader.uint64()\n              break\n            }\n            case 2: {\n              if (opts.limits?.addrs != null && obj.addrs.length === opts.limits.addrs) {\n                throw new MaxLengthError('Decode error - map field \"addrs\" had too many elements')\n              }\n\n              obj.addrs.push(reader.bytes())\n              break\n            }\n            case 3: {\n              obj.voucher = Envelope.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.voucher\n              })\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Reservation>): Uint8Array => {\n    return encodeMessage(obj, Reservation.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Reservation>): Reservation => {\n    return decodeMessage(buf, Reservation.codec(), opts)\n  }\n}\n\nexport interface Limit {\n  duration?: number\n  data?: bigint\n}\n\nexport namespace Limit {\n  let _codec: Codec<Limit>\n\n  export const codec = (): Codec<Limit> => {\n    if (_codec == null) {\n      _codec = message<Limit>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.duration != null) {\n          w.uint32(8)\n          w.uint32(obj.duration)\n        }\n\n        if (obj.data != null) {\n          w.uint32(16)\n          w.uint64(obj.data)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.duration = reader.uint32()\n              break\n            }\n            case 2: {\n              obj.data = reader.uint64()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Limit>): Uint8Array => {\n    return encodeMessage(obj, Limit.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Limit>): Limit => {\n    return decodeMessage(buf, Limit.codec(), opts)\n  }\n}\n\nexport enum Status {\n  UNUSED = 'UNUSED',\n  OK = 'OK',\n  RESERVATION_REFUSED = 'RESERVATION_REFUSED',\n  RESOURCE_LIMIT_EXCEEDED = 'RESOURCE_LIMIT_EXCEEDED',\n  PERMISSION_DENIED = 'PERMISSION_DENIED',\n  CONNECTION_FAILED = 'CONNECTION_FAILED',\n  NO_RESERVATION = 'NO_RESERVATION',\n  MALFORMED_MESSAGE = 'MALFORMED_MESSAGE',\n  UNEXPECTED_MESSAGE = 'UNEXPECTED_MESSAGE'\n}\n\nenum __StatusValues {\n  UNUSED = 0,\n  OK = 100,\n  RESERVATION_REFUSED = 200,\n  RESOURCE_LIMIT_EXCEEDED = 201,\n  PERMISSION_DENIED = 202,\n  CONNECTION_FAILED = 203,\n  NO_RESERVATION = 204,\n  MALFORMED_MESSAGE = 400,\n  UNEXPECTED_MESSAGE = 401\n}\n\nexport namespace Status {\n  export const codec = (): Codec<Status> => {\n    return enumeration<Status>(__StatusValues)\n  }\n}\nexport interface ReservationVoucher {\n  relay: Uint8Array\n  peer: Uint8Array\n  expiration: bigint\n}\n\nexport namespace ReservationVoucher {\n  let _codec: Codec<ReservationVoucher>\n\n  export const codec = (): Codec<ReservationVoucher> => {\n    if (_codec == null) {\n      _codec = message<ReservationVoucher>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.relay != null && obj.relay.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.relay)\n        }\n\n        if ((obj.peer != null && obj.peer.byteLength > 0)) {\n          w.uint32(18)\n          w.bytes(obj.peer)\n        }\n\n        if ((obj.expiration != null && obj.expiration !== 0n)) {\n          w.uint32(24)\n          w.uint64(obj.expiration)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          relay: uint8ArrayAlloc(0),\n          peer: uint8ArrayAlloc(0),\n          expiration: 0n\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.relay = reader.bytes()\n              break\n            }\n            case 2: {\n              obj.peer = reader.bytes()\n              break\n            }\n            case 3: {\n              obj.expiration = reader.uint64()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<ReservationVoucher>): Uint8Array => {\n    return encodeMessage(obj, ReservationVoucher.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<ReservationVoucher>): ReservationVoucher => {\n    return decodeMessage(buf, ReservationVoucher.codec(), opts)\n  }\n}\n\nexport interface Envelope {\n  publicKey: Uint8Array\n  payloadType: Uint8Array\n  payload?: ReservationVoucher\n  signature: Uint8Array\n}\n\nexport namespace Envelope {\n  let _codec: Codec<Envelope>\n\n  export const codec = (): Codec<Envelope> => {\n    if (_codec == null) {\n      _codec = message<Envelope>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.publicKey != null && obj.publicKey.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.publicKey)\n        }\n\n        if ((obj.payloadType != null && obj.payloadType.byteLength > 0)) {\n          w.uint32(18)\n          w.bytes(obj.payloadType)\n        }\n\n        if (obj.payload != null) {\n          w.uint32(26)\n          ReservationVoucher.codec().encode(obj.payload, w)\n        }\n\n        if ((obj.signature != null && obj.signature.byteLength > 0)) {\n          w.uint32(42)\n          w.bytes(obj.signature)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          publicKey: uint8ArrayAlloc(0),\n          payloadType: uint8ArrayAlloc(0),\n          signature: uint8ArrayAlloc(0)\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.publicKey = reader.bytes()\n              break\n            }\n            case 2: {\n              obj.payloadType = reader.bytes()\n              break\n            }\n            case 3: {\n              obj.payload = ReservationVoucher.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.payload\n              })\n              break\n            }\n            case 5: {\n              obj.signature = reader.bytes()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Envelope>): Uint8Array => {\n    return encodeMessage(obj, Envelope.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Envelope>): Envelope => {\n    return decodeMessage(buf, Envelope.codec(), opts)\n  }\n}\n", "/**\n * A transfer limit was hit\n */\nexport class TransferLimitError extends Error {\n  constructor (message = 'Transfer limit error') {\n    super(message)\n    this.name = 'TransferLimitError'\n  }\n}\n\n/**\n * A duration limit was hit\n */\nexport class DurationLimitError extends Error {\n  constructor (message = 'Duration limit error') {\n    super(message)\n    this.name = 'DurationLimitError'\n  }\n}\n\n/**\n * There were enough relay reservations already\n */\nexport class HadEnoughRelaysError extends Error {\n  static name: string = 'HadEnoughRelaysError'\n  name: string = 'HadEnoughRelaysError'\n}\n\n/**\n * An attempt to open a relayed connection over a relayed connection was made\n */\nexport class DoubleRelayError extends Error {\n  static name: string = 'DoubleRelayError'\n  name: string = 'DoubleRelayError'\n}\n\n/**\n * An attempt to make a reservation on a relay was made while the reservation\n * queue was full\n */\nexport class RelayQueueFullError extends Error {\n  static name: string = 'RelayQueueFullError'\n  name: string = 'RelayQueueFullError'\n}\n", "import { setMaxListeners } from '@libp2p/interface'\nimport { pipe } from '@libp2p/utils'\nimport { CODE_P2P_CIRCUIT } from '@multiformats/multiaddr'\nimport { P2P } from '@multiformats/multiaddr-matcher'\nimport { fmt, code, and } from '@multiformats/multiaddr-matcher/utils'\nimport { anySignal } from 'any-signal'\nimport { CID } from 'multiformats/cid'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { DurationLimitError, TransferLimitError } from './errors.js'\nimport type { RelayReservation } from './index.js'\nimport type { Limit } from './pb/index.js'\nimport type { ConnectionLimits, LoggerOptions, Stream, MessageStream, StreamMessageEvent } from '@libp2p/interface'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nfunction countStreamBytes (source: MessageStream, limit: { remaining: bigint }, options: LoggerOptions): void {\n  const limitBytes = limit.remaining\n\n  const abortIfStreamByteLimitExceeded = (evt: StreamMessageEvent): void => {\n    const len = BigInt(evt.data.byteLength)\n    limit.remaining -= len\n\n    if (limit.remaining < 0) {\n      source.abort(new TransferLimitError(`data limit of ${limitBytes} bytes exceeded`))\n    }\n  }\n  source.addEventListener('message', abortIfStreamByteLimitExceeded)\n}\n\nexport function createLimitedRelay (src: Stream, dst: Stream, abortSignal: AbortSignal, reservation: RelayReservation, options: LoggerOptions): void {\n  function abortStreams (err: Error): void {\n    src.abort(err)\n    dst.abort(err)\n  }\n\n  // combine shutdown signal and reservation expiry signal\n  const signals = [abortSignal, reservation.signal]\n\n  if (reservation.limit?.duration != null) {\n    options.log('limiting relayed connection duration to %dms', reservation.limit.duration)\n    const durationSignal = AbortSignal.timeout(reservation.limit.duration)\n    setMaxListeners(Infinity, durationSignal)\n    signals.push(durationSignal)\n  }\n\n  const signal = anySignal(signals)\n  setMaxListeners(Infinity, signal)\n\n  let dataLimit: { remaining: bigint } | undefined\n\n  if (reservation.limit?.data != null) {\n    dataLimit = {\n      remaining: reservation.limit.data\n    }\n  }\n\n  const onAbort = (): void => {\n    let err: Error\n\n    if (abortSignal.aborted) {\n      err = abortSignal.reason\n    } else {\n      err = new DurationLimitError(`duration limit of ${reservation.limit?.duration} ms exceeded`)\n    }\n\n    abortStreams(err)\n  }\n  signal.addEventListener('abort', onAbort, { once: true })\n\n  if (dataLimit != null) {\n    countStreamBytes(dst, dataLimit, options)\n    countStreamBytes(src, dataLimit, options)\n  }\n\n  // join the streams together\n  pipe(\n    src, dst, src\n  )\n    .catch(err => {\n      abortStreams(err)\n    })\n    .finally(() => {\n      signal.clear()\n    })\n}\n\n/**\n * Convert a namespace string into a cid\n */\nexport async function namespaceToCid (namespace: string): Promise<CID> {\n  const bytes = new TextEncoder().encode(namespace)\n  const hash = await sha256.digest(bytes)\n\n  return CID.createV0(hash)\n}\n\n/**\n * returns number of ms between now and expiration time\n */\nexport function getExpirationMilliseconds (expireTimeSeconds: bigint): number {\n  const expireTimeMillis = expireTimeSeconds * BigInt(1000)\n  const currentTime = new Date().getTime()\n\n  // downcast to number to use with setTimeout\n  return Number(expireTimeMillis - BigInt(currentTime))\n}\n\nexport class LimitTracker {\n  private readonly expires?: number\n  private bytes?: bigint\n\n  constructor (limits?: Limit) {\n    if (limits?.duration != null && limits?.duration !== 0) {\n      this.expires = Date.now() + (limits.duration * 1000)\n    }\n\n    this.bytes = limits?.data\n\n    if (this.bytes === 0n) {\n      this.bytes = undefined\n    }\n\n    this.onData = this.onData.bind(this)\n  }\n\n  onData (buf: Uint8ArrayList | Uint8Array): void {\n    if (this.bytes == null) {\n      return\n    }\n\n    this.bytes -= BigInt(buf.byteLength)\n\n    if (this.bytes < 0n) {\n      this.bytes = 0n\n    }\n  }\n\n  getLimits (): ConnectionLimits | undefined {\n    if (this.expires == null && this.bytes == null) {\n      return\n    }\n\n    const output = {}\n\n    if (this.bytes != null) {\n      const self = this\n\n      Object.defineProperty(output, 'bytes', {\n        get () {\n          return self.bytes\n        }\n      })\n    }\n\n    if (this.expires != null) {\n      const self = this\n\n      Object.defineProperty(output, 'seconds', {\n        get () {\n          return Math.round(((self.expires ?? 0) - Date.now()) / 1000)\n        }\n      })\n    }\n\n    return output\n  }\n}\n\n/**\n * A custom matcher that tells us to listen on a particular relay\n */\nexport const CircuitListen = fmt(\n  and(P2P.matchers[0], code(CODE_P2P_CIRCUIT))\n)\n\n/**\n * A custom matcher that tells us to discover available relays\n */\nexport const CircuitSearch = fmt(\n  code(CODE_P2P_CIRCUIT)\n)\n", "/**\n * @packageDocumentation\n *\n * This module exports a `retimeableSignal` function that returns an\n * `AbortSignal` that fires an \"abort\" event after a specified number of ms.\n *\n * It has been augmented with two additional methods `reset` and `clear` which\n * change the timeout time and prevent it from firing entirely.\n *\n * @example\n *\n * ```TypeScript\n * import { retimeableSignal } from 'retimeable-signal'\n *\n * const signal = retimeableSignal(100)\n *\n * //... time passes, reset timeout to now + 100ms\n * signal.reset(100)\n *\n * // stop the signal from aborting at all\n * signal.clear()\n * ```\n *\n * ## Prior art\n *\n * This is module is inspired by the [retimer](https://www.npmjs.com/package/retimer)\n * module except that uses `setTimeout` which can cause a Node.js process to\n * stay open, this uses `AbortSignal.timeout` which does not.\n */\n\n/**\n * An abort error class that extends error\n */\nclass AbortError extends Error {\n  public type: string\n  public code: string | string\n\n  constructor (message?: string, code?: string, name?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.name = name ?? 'AbortError'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface RetimerSignalOptions {\n  /**\n   * The message for the error thrown if the signal aborts\n   */\n  errorMessage?: string\n\n  /**\n   * The code for the error thrown if the signal aborts\n   */\n  errorCode?: string\n\n  /**\n   * The name for the error thrown if the signal aborts\n   */\n  errorName?: string\n}\n\n/**\n * An extension to the `AbortSignal` interface that allows resetting the timer\n * after which the signal will fire it's \"abort\" event.\n */\nexport interface RetimeableAbortSignal extends AbortSignal {\n  /**\n   * Reset the timer. If `ms` is specified, the timer will fire this many ms in\n   * the future, otherwise it will fire according to the `ms` arg originally\n   * passed to `retimerSignal`.\n   */\n  reset(ms?: number): void\n\n  /**\n   * Clear the timer, the \"abort\" event will no longer be fired\n   */\n  clear(): void\n}\n\n/**\n * Return an AbortSignal that times out after a specified number of ms with an\n * internal timer that can be reset to fire further into the future or cleared\n * entirely\n */\nexport function retimeableSignal (ms: number, opts?: RetimerSignalOptions): RetimeableAbortSignal {\n  // create the error here so we have more context in the stack trace\n  const error = new AbortError(opts?.errorMessage, opts?.errorCode, opts?.errorName)\n  const controller = new AbortController()\n  const abortHandler = (): void => {\n    controller.abort(error)\n  }\n\n  let signal: AbortSignal | undefined = AbortSignal.timeout(ms)\n  signal.addEventListener('abort', abortHandler)\n\n  const retimerSignal = controller.signal as any\n  retimerSignal.reset = (newMs?: number): void => {\n    signal?.removeEventListener('abort', abortHandler)\n    signal = AbortSignal.timeout(newMs ?? ms)\n    signal.addEventListener('abort', () => {\n      controller.abort(error)\n    })\n  }\n  retimerSignal.clear = (): void => {\n    signal?.removeEventListener('abort', abortHandler)\n    signal = undefined\n  }\n\n  return retimerSignal satisfies RetimeableAbortSignal\n}\n", "import { trackedPeerMap } from '@libp2p/peer-collections'\nimport { retimeableSignal } from 'retimeable-signal'\nimport { DEFAULT_DATA_LIMIT, DEFAULT_DURATION_LIMIT, DEFAULT_MAX_RESERVATION_STORE_SIZE, DEFAULT_MAX_RESERVATION_TTL } from '../constants.js'\nimport { Status } from '../pb/index.js'\nimport type { RelayReservation, ServerReservationStoreInit } from '../index.js'\nimport type { Limit } from '../pb/index.js'\nimport type { ComponentLogger, Logger, Metrics, PeerId } from '@libp2p/interface'\nimport type { PeerMap } from '@libp2p/peer-collections'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport type ReservationStatus = Status.OK | Status.PERMISSION_DENIED | Status.RESERVATION_REFUSED\n\nexport interface ReservationStoreComponents {\n  logger: ComponentLogger\n  metrics?: Metrics\n}\n\nexport class ReservationStore {\n  public readonly reservations: PeerMap<RelayReservation>\n  private readonly maxReservations: number\n  private readonly applyDefaultLimit: boolean\n  private readonly reservationTtl: number\n  private readonly defaultDurationLimit: number\n  private readonly defaultDataLimit: bigint\n  private readonly log: Logger\n\n  constructor (components: ReservationStoreComponents, init: ServerReservationStoreInit = {}) {\n    this.log = components.logger.forComponent('libp2p:circuit-relay:server:reservation-store')\n    this.maxReservations = init.maxReservations ?? DEFAULT_MAX_RESERVATION_STORE_SIZE\n    this.applyDefaultLimit = init.applyDefaultLimit !== false\n    this.reservationTtl = init.reservationTtl ?? DEFAULT_MAX_RESERVATION_TTL\n    this.defaultDurationLimit = init.defaultDurationLimit ?? DEFAULT_DURATION_LIMIT\n    this.defaultDataLimit = init.defaultDataLimit ?? DEFAULT_DATA_LIMIT\n\n    this.reservations = trackedPeerMap<RelayReservation>({\n      metrics: components.metrics,\n      name: 'libp2p_circuit_relay_server_reservations_total'\n    })\n  }\n\n  reserve (peer: PeerId, addr: Multiaddr, limit?: Limit): { status: ReservationStatus, expire?: number } {\n    let reservation = this.reservations.get(peer)\n\n    if (this.reservations.size >= this.maxReservations && reservation == null) {\n      return { status: Status.RESERVATION_REFUSED }\n    }\n\n    const expiry = new Date(Date.now() + this.reservationTtl)\n    let checkedLimit: Limit | undefined\n\n    if (this.applyDefaultLimit) {\n      checkedLimit = limit ?? {\n        data: this.defaultDataLimit,\n        duration: this.defaultDurationLimit\n      }\n    }\n\n    if (reservation != null) {\n      this.log('refreshing reservation for client %p', peer)\n      reservation.signal.reset(this.reservationTtl)\n    } else {\n      this.log('creating new reservation for client %p', peer)\n      reservation = {\n        addr,\n        expiry,\n        limit: checkedLimit,\n        signal: retimeableSignal(this.reservationTtl)\n      }\n    }\n\n    this.reservations.set(peer, reservation)\n\n    reservation.signal.addEventListener('abort', () => {\n      this.reservations.delete(peer)\n    })\n\n    // return expiry time in seconds\n    return { status: Status.OK, expire: Math.round(expiry.getTime() / 1000) }\n  }\n\n  removeReservation (peer: PeerId): void {\n    this.reservations.delete(peer)\n  }\n\n  get (peer: PeerId): RelayReservation | undefined {\n    return this.reservations.get(peer)\n  }\n\n  clear (): void {\n    this.reservations.clear()\n  }\n}\n", "import { ReservationVoucher } from '../pb/index.js'\nimport type { PeerId, Record } from '@libp2p/interface'\n\nexport interface ReservationVoucherOptions {\n  relay: PeerId\n  peer: PeerId\n  expiration: bigint\n}\n\nexport class ReservationVoucherRecord implements Record {\n  public readonly domain = 'libp2p-relay-rsvp'\n  public readonly codec = new Uint8Array([0x03, 0x02])\n\n  private readonly relay: PeerId\n  private readonly peer: PeerId\n  private readonly expiration: bigint\n\n  constructor ({ relay, peer, expiration }: ReservationVoucherOptions) {\n    this.relay = relay\n    this.peer = peer\n    this.expiration = expiration\n  }\n\n  marshal (): Uint8Array {\n    return ReservationVoucher.encode({\n      relay: this.relay.toMultihash().bytes,\n      peer: this.peer.toMultihash().bytes,\n      expiration: BigInt(this.expiration)\n    })\n  }\n\n  equals (other: Record): boolean {\n    if (!(other instanceof ReservationVoucherRecord)) {\n      return false\n    }\n    if (!this.peer.equals(other.peer)) {\n      return false\n    }\n\n    if (!this.relay.equals(other.relay)) {\n      return false\n    }\n\n    if (this.expiration !== other.expiration) {\n      return false\n    }\n\n    return true\n  }\n}\n", "import { publicKeyToProtobuf } from '@libp2p/crypto/keys'\nimport { peerIdFromMultihash } from '@libp2p/peer-id'\nimport { RecordEnvelope } from '@libp2p/peer-record'\nimport { pbStream } from '@libp2p/utils'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { Circuit } from '@multiformats/multiaddr-matcher'\nimport { TypedEventEmitter, setMaxListeners } from 'main-event'\nimport * as Digest from 'multiformats/hashes/digest'\nimport {\n  DEFAULT_HOP_TIMEOUT,\n  MAX_CONNECTIONS,\n  RELAY_SOURCE_TAG,\n  RELAY_V2_HOP_CODEC,\n  RELAY_V2_STOP_CODEC\n} from '../constants.js'\nimport { HopMessage, Status, StopMessage } from '../pb/index.js'\nimport { createLimitedRelay } from '../utils.js'\nimport { ReservationStore } from './reservation-store.js'\nimport { ReservationVoucherRecord } from './reservation-voucher.js'\nimport type { CircuitRelayServerComponents, CircuitRelayServerInit, CircuitRelayService, RelayReservation } from '../index.js'\nimport type { Reservation } from '../pb/index.js'\nimport type { Logger, Connection, Stream, PeerId, Startable, AbortOptions } from '@libp2p/interface'\nimport type { PeerMap } from '@libp2p/peer-collections'\nimport type { ProtobufStream } from '@libp2p/utils'\n\nexport interface HopProtocolOptions {\n  connection: Connection\n  request: HopMessage\n  stream: ProtobufStream<Stream>\n}\n\nexport interface StopOptions {\n  connection: Connection\n  request: StopMessage\n}\n\nexport interface RelayServerEvents {\n  'relay:reservation': CustomEvent<RelayReservation>\n  'relay:advert:success': CustomEvent<unknown>\n  'relay:advert:error': CustomEvent<Error>\n}\n\nconst defaults = {\n  maxOutboundStopStreams: MAX_CONNECTIONS\n}\n\nexport class CircuitRelayServer extends TypedEventEmitter<RelayServerEvents> implements Startable, CircuitRelayService {\n  private readonly components: CircuitRelayServerComponents\n  private readonly reservationStore: ReservationStore\n  private started: boolean\n  private readonly hopTimeout: number\n  private readonly shutdownController: AbortController\n  private readonly maxInboundHopStreams?: number\n  private readonly maxOutboundHopStreams?: number\n  private readonly maxOutboundStopStreams: number\n  private readonly log: Logger\n\n  /**\n   * Creates an instance of Relay\n   */\n  constructor (components: CircuitRelayServerComponents, init: CircuitRelayServerInit = {}) {\n    super()\n\n    this.log = components.logger.forComponent('libp2p:circuit-relay:server')\n    this.components = components\n    this.started = false\n    this.hopTimeout = init?.hopTimeout ?? DEFAULT_HOP_TIMEOUT\n    this.maxInboundHopStreams = init.maxInboundHopStreams\n    this.maxOutboundHopStreams = init.maxOutboundHopStreams\n    this.maxOutboundStopStreams = init.maxOutboundStopStreams ?? defaults.maxOutboundStopStreams\n    this.reservationStore = new ReservationStore(components, init.reservations)\n\n    this.shutdownController = new AbortController()\n    setMaxListeners(Infinity, this.shutdownController.signal)\n\n    this.onHop = this.onHop.bind(this)\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/circuit-relay-v2-server'\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  /**\n   * Start Relay service\n   */\n  async start (): Promise<void> {\n    if (this.started) {\n      return\n    }\n\n    await this.components.registrar.handle(RELAY_V2_HOP_CODEC, this.onHop, {\n      maxInboundStreams: this.maxInboundHopStreams,\n      maxOutboundStreams: this.maxOutboundHopStreams,\n      runOnLimitedConnection: true\n    })\n\n    this.started = true\n  }\n\n  /**\n   * Stop Relay service\n   */\n  async stop (): Promise<void> {\n    this.reservationStore.clear()\n    this.shutdownController.abort()\n    await this.components.registrar.unhandle(RELAY_V2_HOP_CODEC)\n\n    this.started = false\n  }\n\n  async onHop (stream: Stream, connection: Connection): Promise<void> {\n    this.log('received circuit v2 hop protocol stream from %p', connection.remotePeer)\n\n    const signal = AbortSignal.timeout(this.hopTimeout)\n    setMaxListeners(Infinity, signal)\n\n    const options = {\n      signal\n    }\n    const pbstr = pbStream(stream)\n\n    try {\n      const request: HopMessage = await pbstr.pb(HopMessage).read(options)\n\n      if (request?.type == null) {\n        throw new Error('request was invalid, could not read from stream')\n      }\n\n      this.log('received', request.type)\n\n      await this.handleHopProtocol({\n        connection,\n        stream: pbstr,\n        request\n      }, options)\n    } catch (err: any) {\n      this.log.error('error while handling hop - %e', err)\n      await pbstr.pb(HopMessage).write({\n        type: HopMessage.Type.STATUS,\n        status: Status.MALFORMED_MESSAGE\n      }, options)\n      stream.abort(err)\n    }\n  }\n\n  async handleHopProtocol ({ stream, request, connection }: HopProtocolOptions, options: AbortOptions): Promise<void> {\n    this.log('received hop message')\n    switch (request.type) {\n      case HopMessage.Type.RESERVE: await this.handleReserve({ stream, request, connection }, options); break\n      case HopMessage.Type.CONNECT: await this.handleConnect({ stream, request, connection }, options); break\n      default: {\n        this.log.error('invalid hop request type %s via peer %p', request.type, connection.remotePeer)\n        await stream.pb(HopMessage).write({ type: HopMessage.Type.STATUS, status: Status.UNEXPECTED_MESSAGE })\n      }\n    }\n  }\n\n  async handleReserve ({ stream, connection }: HopProtocolOptions, options: AbortOptions): Promise<void> {\n    const hopstr = stream.pb(HopMessage)\n    this.log('hop reserve request from %p', connection.remotePeer)\n\n    if (Circuit.exactMatch(connection.remoteAddr)) {\n      this.log.error('relay reservation over circuit connection denied for peer: %p', connection.remotePeer)\n      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, options)\n      return\n    }\n\n    if ((await this.components.connectionGater.denyInboundRelayReservation?.(connection.remotePeer)) === true) {\n      this.log.error('reservation for %p denied by connection gater', connection.remotePeer)\n      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, options)\n      return\n    }\n\n    const result = this.reservationStore.reserve(connection.remotePeer, connection.remoteAddr)\n\n    try {\n      if (result.status !== Status.OK) {\n        await hopstr.write({ type: HopMessage.Type.STATUS, status: result.status }, options)\n        return\n      }\n\n      // tag relay target peer\n      // result.expire is non-null if `ReservationStore.reserve` returns with status == OK\n      if (result.expire != null) {\n        const ttl = (result.expire * 1000) - Date.now()\n        await this.components.peerStore.merge(connection.remotePeer, {\n          tags: {\n            [RELAY_SOURCE_TAG]: { value: 1, ttl }\n          }\n        }, options)\n      }\n\n      await hopstr.write({\n        type: HopMessage.Type.STATUS,\n        status: Status.OK,\n        reservation: await this.makeReservation(connection.remotePeer, BigInt(result.expire ?? 0)),\n        limit: this.reservationStore.get(connection.remotePeer)?.limit\n      }, options)\n      this.log('sent confirmation response to %s', connection.remotePeer)\n\n      // close writable end of stream\n      await hopstr.unwrap().unwrap().close(options)\n    } catch (err) {\n      this.log.error('failed to send confirmation response to %p - %e', connection.remotePeer, err)\n      this.reservationStore.removeReservation(connection.remotePeer)\n\n      try {\n        await this.components.peerStore.merge(connection.remotePeer, {\n          tags: {\n            [RELAY_SOURCE_TAG]: undefined\n          }\n        }, options)\n      } catch (err) {\n        this.log.error('failed to untag relay source peer %p - %e', connection.remotePeer, err)\n      }\n    }\n  }\n\n  async makeReservation (\n    remotePeer: PeerId,\n    expire: bigint\n  ): Promise<Reservation> {\n    const addrs = []\n\n    for (const relayAddr of this.components.addressManager.getAddresses()) {\n      if (relayAddr.toString().includes('/p2p-circuit')) {\n        continue\n      }\n\n      addrs.push(relayAddr.bytes)\n    }\n\n    const envelope = await RecordEnvelope.seal(new ReservationVoucherRecord({\n      peer: remotePeer,\n      relay: this.components.peerId,\n      expiration: expire\n    }), this.components.privateKey)\n\n    return {\n      addrs,\n      expire,\n      voucher: {\n        publicKey: publicKeyToProtobuf(envelope.publicKey),\n        payloadType: envelope.payloadType,\n        payload: {\n          peer: remotePeer.toMultihash().bytes,\n          relay: this.components.peerId.toMultihash().bytes,\n          expiration: expire\n        },\n        signature: envelope.signature\n      }\n    }\n  }\n\n  async handleConnect ({ stream, request, connection }: HopProtocolOptions, options: AbortOptions): Promise<void> {\n    const hopstr = stream.pb(HopMessage)\n\n    if (Circuit.matches(connection.remoteAddr)) {\n      this.log.error('relay reservation over circuit connection denied for peer: %p', connection.remotePeer)\n      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, options)\n      return\n    }\n\n    this.log('hop connect request from %p', connection.remotePeer)\n\n    let dstPeer: PeerId\n\n    try {\n      if (request.peer == null) {\n        this.log.error('no peer info in hop connect request')\n        throw new Error('no peer info in request')\n      }\n\n      request.peer.addrs.forEach(multiaddr)\n      dstPeer = peerIdFromMultihash(Digest.decode(request.peer.id))\n    } catch (err) {\n      this.log.error('invalid hop connect request via peer %p - %e', connection.remotePeer, err)\n      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, options)\n      return\n    }\n\n    const reservation = this.reservationStore.get(dstPeer)\n\n    if (reservation == null) {\n      this.log.error('hop connect denied for destination peer %p not having a reservation for %p with status %s', dstPeer, connection.remotePeer, Status.NO_RESERVATION)\n      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.NO_RESERVATION }, options)\n      return\n    }\n\n    if ((await this.components.connectionGater.denyOutboundRelayedConnection?.(connection.remotePeer, dstPeer)) === true) {\n      this.log.error('hop connect for %p to %p denied by connection gater', connection.remotePeer, dstPeer)\n      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, options)\n      return\n    }\n\n    const connections = this.components.connectionManager.getConnections(dstPeer)\n\n    if (connections.length === 0) {\n      this.log('hop connect denied for destination peer %p not having a connection for %p as there is no destination connection', dstPeer, connection.remotePeer)\n      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.NO_RESERVATION }, options)\n      return\n    }\n\n    const destinationConnection = connections[0]\n\n    const destinationStream = await this.stopHop({\n      connection: destinationConnection,\n      request: {\n        type: StopMessage.Type.CONNECT,\n        peer: {\n          id: connection.remotePeer.toMultihash().bytes,\n          addrs: []\n        },\n        limit: reservation?.limit\n      }\n    }, options)\n\n    if (destinationStream == null) {\n      this.log.error('failed to open stream to destination peer %p', destinationConnection?.remotePeer)\n      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.CONNECTION_FAILED }, options)\n      return\n    }\n\n    await hopstr.write({\n      type: HopMessage.Type.STATUS,\n      status: Status.OK,\n      limit: reservation?.limit\n    }, options)\n\n    this.log('connection from %p to %p established - merging streams', connection.remotePeer, dstPeer)\n\n    // Short circuit the two streams to create the relayed connection\n    createLimitedRelay(stream.unwrap(), destinationStream, this.shutdownController.signal, reservation, {\n      log: this.log\n    })\n  }\n\n  /**\n   * Send a STOP request to the target peer that the dialing peer wants to contact\n   */\n  async stopHop ({ connection, request }: StopOptions, options: AbortOptions): Promise<Stream | undefined> {\n    this.log('starting circuit relay v2 stop request to %s', connection.remotePeer)\n    const stream = await connection.newStream(RELAY_V2_STOP_CODEC, {\n      maxOutboundStreams: this.maxOutboundStopStreams,\n      runOnLimitedConnection: true,\n      ...options\n    })\n    const pbstr = pbStream(stream)\n    const stopstr = pbstr.pb(StopMessage)\n    await stopstr.write(request, options)\n    let response\n\n    try {\n      response = await stopstr.read(options)\n    } catch (err) {\n      this.log.error('error parsing stop message response from %p - %e', connection.remotePeer, err)\n    }\n\n    if (response == null) {\n      this.log.error('could not read response from %p', connection.remotePeer)\n      await stream.close(options)\n      return\n    }\n\n    if (response.status === Status.OK) {\n      this.log('stop request to %p was successful', connection.remotePeer)\n      return pbstr.unwrap()\n    }\n\n    this.log('stop request failed with code %d', response.status)\n    await stream.close(options)\n  }\n\n  get reservations (): PeerMap<RelayReservation> {\n    return this.reservationStore.reservations\n  }\n}\n", "import { PeerQueue } from '@libp2p/utils'\nimport { anySignal } from 'any-signal'\nimport { TypedEventEmitter, setMaxListeners } from 'main-event'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport {\n  RELAY_V2_HOP_CODEC\n} from '../constants.js'\nimport type { RelayDiscoveryComponents, RelayDiscoveryEvents, RelayDiscoveryInit } from '../index.ts'\nimport type { Logger, Peer, PeerId, PeerInfo, Startable, TopologyFilter } from '@libp2p/interface'\n\n/**\n * ReservationManager automatically makes a circuit v2 reservation on any connected\n * peers that support the circuit v2 HOP protocol.\n */\nexport class RelayDiscovery extends TypedEventEmitter<RelayDiscoveryEvents> implements Startable {\n  private readonly components: RelayDiscoveryComponents\n  private started: boolean\n  private running: boolean\n  private topologyId?: string\n  private readonly log: Logger\n  private discoveryController: AbortController\n  private readonly filter?: TopologyFilter\n  private queue?: PeerQueue\n\n  constructor (components: RelayDiscoveryComponents, init: RelayDiscoveryInit = {}) {\n    super()\n\n    this.log = components.logger.forComponent('libp2p:circuit-relay:discover-relays')\n    this.components = components\n    this.started = false\n    this.running = false\n    this.filter = init.filter\n    this.discoveryController = new AbortController()\n    setMaxListeners(Infinity, this.discoveryController.signal)\n    this.dialPeer = this.dialPeer.bind(this)\n    this.onPeer = this.onPeer.bind(this)\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  async start (): Promise<void> {\n    // register a topology listener for when new peers are encountered\n    // that support the hop protocol\n    this.topologyId = await this.components.registrar.register(RELAY_V2_HOP_CODEC, {\n      filter: this.filter,\n      onConnect: (peerId) => {\n        this.log.trace('discovered relay %p queue (length: %d, active %d)', peerId, this.queue?.size, this.queue?.running)\n        this.safeDispatchEvent('relay:discover', { detail: peerId })\n      }\n    })\n\n    this.started = true\n  }\n\n  stop (): void {\n    if (this.topologyId != null) {\n      this.components.registrar.unregister(this.topologyId)\n    }\n\n    if (this.running) {\n      this.stopDiscovery()\n    }\n\n    this.started = false\n  }\n\n  /**\n   * Try to listen on available hop relay connections.\n   * The following order will happen while we do not have enough relays:\n   *\n   * 1. Check the metadata store for known relays, try to listen on the ones we are already connected to\n   * 2. Dial and try to listen on the peers we know that support hop but are not connected\n   * 3. Search the network - this requires a peer routing implementation to be configured but will fail gracefully\n   * 4. Dial any peers discovered - this covers when no peer routing implementation has been configured but some peer discovery mechanism is also present\n   */\n  startDiscovery (): void {\n    if (this.running) {\n      return\n    }\n\n    this.log('start discovery')\n    this.running = true\n    this.discoveryController = new AbortController()\n    setMaxListeners(Infinity, this.discoveryController.signal)\n\n    // dial any peer we discover\n    this.components.events.addEventListener('peer:discovery', this.onPeer)\n\n    Promise.resolve()\n      .then(async () => {\n        this.log('searching peer store for relays')\n\n        const peers = (await this.components.peerStore.all({\n          filters: [\n            // filter by a list of peers supporting RELAY_V2_HOP and ones we are not listening on\n            (peer) => {\n              return peer.protocols.includes(RELAY_V2_HOP_CODEC)\n            }\n          ],\n          orders: [\n            // randomize\n            () => Math.random() < 0.5 ? 1 : -1,\n            // prefer peers we've connected to in the past\n            (a, b) => {\n              const lastDialA = getLastDial(a)\n              const lastDialB = getLastDial(b)\n\n              if (lastDialA > lastDialB) {\n                return -1\n              }\n\n              if (lastDialB > lastDialA) {\n                return 1\n              }\n\n              return 0\n            }\n          ]\n        }))\n\n        for (const peer of peers) {\n          this.log.trace('found relay peer %p in peer store', peer.id)\n          this.safeDispatchEvent('relay:discover', { detail: peer.id })\n        }\n\n        this.log('found %d relay peers in peer store', peers.length)\n\n        // perform random walk and dial peers - after identify has run, the network\n        // topology will be notified of new relays\n        const queue = this.queue = new PeerQueue({\n          concurrency: 5\n        })\n\n        this.log('start random walk')\n\n        for await (const peer of this.components.randomWalk.walk({ signal: this.discoveryController.signal })) {\n          this.log.trace('found random peer %p', peer.id)\n\n          if (queue.has(peer.id)) {\n            this.log.trace('random peer %p was already in queue', peer.id)\n\n            // skip peers already in the queue\n            continue\n          }\n\n          if (this.components.connectionManager.getConnections(peer.id)?.length > 0) {\n            this.log.trace('random peer %p was already connected', peer.id)\n\n            // skip peers we are already connected to\n            continue\n          }\n\n          if (!(await this.components.connectionManager.isDialable(peer.multiaddrs))) {\n            this.log.trace('random peer %p was not dialable', peer.id, peer.multiaddrs.map(ma => ma.toString()))\n\n            // skip peers we can't dial\n            continue\n          }\n\n          if (queue.queued > 10) {\n            this.log.trace('wait for space in queue for %p', peer.id)\n\n            // pause the random walk until there is space in the queue\n            await queue.onSizeLessThan(10, {\n              signal: this.discoveryController.signal\n            })\n          }\n\n          this.log('adding random peer %p to dial queue (length: %d, active %d)', peer.id, queue.size, queue.running)\n\n          // dial the peer - this will cause identify to run and our topology to\n          // be notified and we'll attempt to create reservations\n          queue.add(this.dialPeer, {\n            peerId: peer.id,\n            signal: this.discoveryController.signal\n          })\n            .catch(err => {\n              this.log.error('error opening connection to random peer %p - %e', peer.id, err)\n            })\n        }\n\n        this.log('stop random walk')\n\n        await queue.onIdle()\n      })\n      .catch(err => {\n        if (!this.discoveryController.signal.aborted) {\n          this.log.error('failed when finding relays on the network - %e', err)\n        }\n      })\n  }\n\n  stopDiscovery (): void {\n    this.log('stop discovery')\n    this.running = false\n    this.discoveryController?.abort()\n    this.queue?.clear()\n\n    // stop dialing any peer we discover\n    this.components.events.removeEventListener('peer:discovery', this.onPeer)\n  }\n\n  onPeer (evt: CustomEvent<PeerInfo>): void {\n    this.log.trace('maybe dialing discovered peer %p', evt.detail.id)\n\n    this.maybeDialPeer(evt)\n      .catch(err => {\n        this.log.trace('error dialing discovered peer %p - %e', evt.detail.id, err)\n      })\n  }\n\n  async maybeDialPeer (evt: CustomEvent<PeerInfo>): Promise<void> {\n    if (this.queue == null) {\n      return\n    }\n\n    const peerId = evt.detail.id\n    const multiaddrs = evt.detail.multiaddrs\n\n    if (this.queue.has(peerId)) {\n      this.log.trace('random peer %p was already in queue', peerId)\n\n      // skip peers already in the queue\n      return\n    }\n\n    if (this.components.connectionManager.getConnections(peerId)?.length > 0) {\n      this.log.trace('random peer %p was already connected', peerId)\n\n      // skip peers we are already connected to\n      return\n    }\n\n    if (!(await this.components.connectionManager.isDialable(multiaddrs))) {\n      this.log.trace('random peer %p was not dialable', peerId)\n\n      // skip peers we can't dial\n      return\n    }\n\n    this.queue?.add(this.dialPeer, {\n      peerId: evt.detail.id,\n      signal: this.discoveryController.signal\n    })\n      .catch(err => {\n        this.log.error('error opening connection to discovered peer %p - %e', evt.detail.id, err)\n      })\n  }\n\n  async dialPeer ({ peerId, signal }: { peerId: PeerId, signal?: AbortSignal }): Promise<void> {\n    const combinedSignal = anySignal([AbortSignal.timeout(5_000), signal])\n    setMaxListeners(Infinity, combinedSignal)\n\n    try {\n      await this.components.connectionManager.openConnection(peerId, {\n        signal: combinedSignal\n      })\n    } finally {\n      combinedSignal.clear()\n    }\n  }\n}\n\n/**\n * Returns the timestamp of the last time we connected to this peer, if we've\n * not connected to them before return 0\n */\nfunction getLastDial (peer: Peer): number {\n  const lastDial = peer.metadata.get('last-dial-success')\n\n  if (lastDial == null) {\n    return 0\n  }\n\n  return new Date(uint8ArrayToString(lastDial)).getTime()\n}\n", "import { ListenError } from '@libp2p/interface'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { TypedEventEmitter, setMaxListeners } from 'main-event'\nimport { DEFAULT_RESERVATION_COMPLETION_TIMEOUT } from '../constants.js'\nimport { CircuitListen, CircuitSearch } from '../utils.js'\nimport type { RelayReservation, ReservationStore } from './reservation-store.js'\nimport type { ComponentLogger, Logger, Listener, ListenerEvents, PeerId } from '@libp2p/interface'\nimport type { AddressManager, ConnectionManager } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport interface CircuitRelayTransportListenerComponents {\n  peerId: PeerId\n  connectionManager: ConnectionManager\n  addressManager: AddressManager\n  reservationStore: ReservationStore\n  logger: ComponentLogger\n}\n\nexport interface CircuitRelayTransportListenerInit {\n  listenTimeout?: number\n}\n\nclass CircuitRelayTransportListener extends TypedEventEmitter<ListenerEvents> implements Listener {\n  private readonly connectionManager: ConnectionManager\n  private readonly addressManager: AddressManager\n  private readonly reservationStore: ReservationStore\n  private listeningAddrs: Multiaddr[]\n  private readonly log: Logger\n  private readonly listenTimeout: number\n  private reservationId?: string\n  private relay?: PeerId\n\n  constructor (components: CircuitRelayTransportListenerComponents, init: CircuitRelayTransportListenerInit = {}) {\n    super()\n\n    this.log = components.logger.forComponent('libp2p:circuit-relay:transport:listener')\n    this.connectionManager = components.connectionManager\n    this.addressManager = components.addressManager\n    this.reservationStore = components.reservationStore\n    this.listeningAddrs = []\n    this.listenTimeout = init.listenTimeout ?? DEFAULT_RESERVATION_COMPLETION_TIMEOUT\n\n    // remove listening addrs when a relay is removed\n    this.reservationStore.addEventListener('relay:removed', this._onRemoveRelayPeer)\n    this.reservationStore.addEventListener('relay:created-reservation', this._onAddRelayPeer)\n  }\n\n  _onRemoveRelayPeer = (evt: CustomEvent<RelayReservation>): void => {\n    this.log('relay removed %p our relay %p', evt.detail.relay, this.relay, this.relay?.equals(evt.detail.relay))\n\n    if (this.relay?.equals(evt.detail.relay) !== true) {\n      return\n    }\n\n    this.log('relay peer removed %p', evt.detail.relay)\n\n    this.listeningAddrs.forEach(ma => {\n      // mark as externally dialable\n      this.addressManager.removeObservedAddr(ma)\n    })\n\n    this.listeningAddrs = []\n\n    // announce listen addresses change\n    this.safeDispatchEvent('listening')\n  }\n\n  _onAddRelayPeer = (evt: CustomEvent<RelayReservation>): void => {\n    const {\n      details\n    } = evt.detail\n\n    if (details.type === 'configured') {\n      return\n    }\n\n    if (details.id !== this.reservationId) {\n      return\n    }\n\n    this.addedRelay(evt.detail)\n  }\n\n  async listen (addr: Multiaddr): Promise<void> {\n    if (CircuitSearch.exactMatch(addr)) {\n      this.log('searching for circuit relay servers')\n\n      // start relay discovery\n      this.reservationId = this.reservationStore.reserveRelay()\n    } else if (CircuitListen.exactMatch(addr)) {\n      this.log('listen on specific relay server %a', addr)\n\n      const signal = AbortSignal.timeout(this.listenTimeout)\n      setMaxListeners(Infinity, signal)\n\n      // try to make a reservation on one particular relay\n      // remove the circuit part to get the peer id of the relay\n      const relayAddr = addr.decapsulate('/p2p-circuit')\n      const relayConn = await this.connectionManager.openConnection(relayAddr, {\n        signal\n      })\n\n      if (!this.reservationStore.hasReservation(relayConn.remotePeer)) {\n        this.log('making reservation on peer %p', relayConn.remotePeer)\n        const reservation = await this.reservationStore.addRelay(relayConn.remotePeer, 'configured')\n        this.addedRelay(reservation)\n      }\n    } else {\n      throw new ListenError(`Could not listen on p2p-circuit address \"${addr}\"`)\n    }\n  }\n\n  getAddrs (): Multiaddr[] {\n    return [...this.listeningAddrs.values()].flat()\n  }\n\n  updateAnnounceAddrs (): void {\n\n  }\n\n  async close (): Promise<void> {\n    this.reservationStore.cancelReservations()\n    this.listeningAddrs = []\n\n    // remove listener\n    this.reservationStore.removeEventListener('relay:removed', this._onRemoveRelayPeer)\n\n    // announce listen addresses change\n    queueMicrotask(() => {\n      this.safeDispatchEvent('close')\n    })\n  }\n\n  private addedRelay (reservation: RelayReservation): void {\n    this.log('relay peer added %p', reservation.relay)\n\n    this.relay = reservation.relay\n\n    // add all addresses from the relay reservation\n    this.listeningAddrs = reservation.details.reservation.addrs\n      .map(buf => multiaddr(buf).encapsulate('/p2p-circuit'))\n\n    this.listeningAddrs.forEach(ma => {\n      // mark as externally dialable\n      this.addressManager.confirmObservedAddr(ma, {\n        type: 'transport'\n      })\n    })\n\n    // if that succeeded announce listen addresses change\n    queueMicrotask(() => {\n      this.safeDispatchEvent('listening')\n    })\n  }\n}\n\nexport function createListener (options: CircuitRelayTransportListenerComponents): Listener {\n  return new CircuitRelayTransportListener(options)\n}\n", "export const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n", "/* @ts-self-types=\"./index.d.ts\" */\nimport { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\nexport { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << Math.log2(alphabet.length - 1)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step | 0\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length >= size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size | 0, random)\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array((size |= 0)))\n  while (size--) {\n    id += scopedUrlAlphabet[bytes[size] & 63]\n  }\n  return id\n}\n", "import { ListenError } from '@libp2p/interface'\nimport { PeerMap } from '@libp2p/peer-collections'\nimport { createScalableCuckooFilter, PeerQueue, pbStream } from '@libp2p/utils'\nimport { CODE_P2P, multiaddr } from '@multiformats/multiaddr'\nimport { Circuit } from '@multiformats/multiaddr-matcher'\nimport { TypedEventEmitter, setMaxListeners } from 'main-event'\nimport { nanoid } from 'nanoid'\nimport { DEFAULT_MAX_RESERVATION_QUEUE_LENGTH, DEFAULT_RESERVATION_COMPLETION_TIMEOUT, DEFAULT_RESERVATION_CONCURRENCY, KEEP_ALIVE_TAG, RELAY_V2_HOP_CODEC } from '../constants.js'\nimport { DoubleRelayError, HadEnoughRelaysError, RelayQueueFullError } from '../errors.js'\nimport { HopMessage, Status } from '../pb/index.js'\nimport { getExpirationMilliseconds } from '../utils.js'\nimport type { TransportReservationStoreComponents, TransportReservationStoreInit } from '../index.ts'\nimport type { Reservation } from '../pb/index.js'\nimport type { AbortOptions, Libp2pEvents, Logger, PeerId, PeerStore, Startable, Peer, Connection } from '@libp2p/interface'\nimport type { ConnectionManager } from '@libp2p/interface-internal'\nimport type { Filter } from '@libp2p/utils'\nimport type { TypedEventTarget } from 'main-event'\n\n// allow refreshing a relay reservation if it will expire in the next 10 minutes\nconst REFRESH_WINDOW = (60 * 1000) * 10\n\n// try to refresh relay reservations 5 minutes before expiry\nconst REFRESH_TIMEOUT = (60 * 1000) * 5\n\n// minimum duration before which a reservation must not be refreshed\nconst REFRESH_TIMEOUT_MIN = 30 * 1000\n\nexport type RelayType = 'discovered' | 'configured'\n\nexport interface DiscoveredRelayEntry {\n  timeout: ReturnType<typeof setTimeout>\n  type: 'discovered'\n  reservation: Reservation\n\n  /**\n   * Stores the id of the connection we have to the relay\n   */\n  connection: string\n\n  /**\n   * Stores the identifier returned when the reservation was requested\n   */\n  id: string\n}\n\nexport interface ConfiguredRelayEntry {\n  timeout: ReturnType<typeof setTimeout>\n  type: 'configured'\n  reservation: Reservation\n\n  /**\n   * Stores the id of the connection we have to the relay\n   */\n  connection: string\n}\n\nexport type RelayEntry = DiscoveredRelayEntry | ConfiguredRelayEntry\n\nexport interface RelayReservation {\n  relay: PeerId\n  details: RelayEntry\n}\n\nexport interface ReservationStoreEvents {\n  'relay:not-enough-relays': CustomEvent\n  'relay:found-enough-relays': CustomEvent\n  'relay:removed': CustomEvent<RelayReservation>\n  'relay:created-reservation': CustomEvent<RelayReservation>\n}\n\nexport class ReservationStore extends TypedEventEmitter<ReservationStoreEvents> implements Startable {\n  private readonly peerId: PeerId\n  private readonly connectionManager: ConnectionManager\n  private readonly peerStore: PeerStore\n  private readonly events: TypedEventTarget<Libp2pEvents>\n  private readonly reserveQueue: PeerQueue<RelayReservation>\n  private readonly reservations: PeerMap<RelayEntry>\n  private readonly pendingReservations: string[]\n  private readonly maxReservationQueueLength: number\n  private readonly reservationCompletionTimeout: number\n  private started: boolean\n  private readonly log: Logger\n  private relayFilter: Filter\n\n  constructor (components: TransportReservationStoreComponents, init?: TransportReservationStoreInit) {\n    super()\n\n    this.log = components.logger.forComponent('libp2p:circuit-relay:transport:reservation-store')\n    this.peerId = components.peerId\n    this.connectionManager = components.connectionManager\n    this.peerStore = components.peerStore\n    this.events = components.events\n    this.reservations = new PeerMap()\n    this.pendingReservations = []\n    this.maxReservationQueueLength = init?.maxReservationQueueLength ?? DEFAULT_MAX_RESERVATION_QUEUE_LENGTH\n    this.reservationCompletionTimeout = init?.reservationCompletionTimeout ?? DEFAULT_RESERVATION_COMPLETION_TIMEOUT\n    this.started = false\n    this.relayFilter = createScalableCuckooFilter(100)\n\n    // ensure we don't listen on multiple relays simultaneously\n    this.reserveQueue = new PeerQueue({\n      concurrency: init?.reservationConcurrency ?? DEFAULT_RESERVATION_CONCURRENCY,\n      metricName: 'libp2p_relay_reservation_queue',\n      metrics: components.metrics\n    })\n\n    // reservations are only valid while we are still connected to the relay.\n    // if we had a reservation opened via that connection, remove it and maybe\n    // trigger a search for new relays\n    this.events.addEventListener('connection:close', (evt) => {\n      const reservation = [...this.reservations.values()]\n        .find(reservation => reservation.connection === evt.detail.id)\n\n      if (reservation == null) {\n        return\n      }\n\n      this.#removeReservation(evt.detail.remotePeer)\n        .catch(err => {\n          this.log('could not remove relay %p - %e', evt.detail, err)\n        })\n    })\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  start (): void {\n    this.started = true\n  }\n\n  afterStart (): void {\n    // remove old relay tags\n    void Promise.resolve()\n      .then(async () => {\n        const relayPeers: Peer[] = await this.peerStore.all({\n          filters: [(peer) => {\n            return peer.tags.has(KEEP_ALIVE_TAG)\n          }]\n        })\n\n        this.log('removing tag from %d old relays', relayPeers.length)\n\n        // remove old relay tag and redial\n        await Promise.all(\n          relayPeers.map(async peer => {\n            await this.peerStore.merge(peer.id, {\n              tags: {\n                [KEEP_ALIVE_TAG]: undefined\n              }\n            })\n          })\n        )\n\n        this.log('redialing %d old relays', relayPeers.length)\n        await Promise.all(\n          relayPeers.map(async peer => this.addRelay(peer.id, 'discovered'))\n        )\n\n        this.#checkReservationCount()\n      })\n      .catch(err => {\n        this.log.error('failed to clean up and redial old relays during afterStart - %e', err)\n      })\n  }\n\n  stop (): void {\n    this.reserveQueue.clear()\n    this.reservations.forEach(({ timeout }) => {\n      clearTimeout(timeout)\n    })\n    this.reservations.clear()\n    this.started = false\n  }\n\n  reserveRelay (): string {\n    const id = nanoid()\n\n    this.pendingReservations.push(id)\n\n    this.#checkReservationCount()\n\n    return id\n  }\n\n  /**\n   * If the number of current relays is beneath the configured `maxReservations`\n   * value, and the passed peer id is not our own, and we have a non-relayed\n   * connection to the remote, and the remote peer speaks the hop protocol, try\n   * to reserve a slot on the remote peer\n   */\n  async addRelay (peerId: PeerId, type: RelayType): Promise<RelayReservation> {\n    if (this.peerId.equals(peerId)) {\n      this.log.trace('not trying to use self as relay')\n      throw new ListenError('Cannot use self as relay')\n    }\n\n    if (this.reserveQueue.size > this.maxReservationQueueLength) {\n      throw new RelayQueueFullError('The reservation queue is full')\n    }\n\n    const existingJob = this.reserveQueue.find(peerId)\n\n    if (existingJob != null) {\n      this.log.trace('potential relay peer %p is already in the reservation queue', peerId)\n      return existingJob.join()\n    }\n\n    if (this.relayFilter.has(peerId.toMultihash().bytes)) {\n      throw new ListenError('The relay was previously invalid')\n    }\n\n    this.log.trace('try to reserve relay slot with %p', peerId)\n\n    return this.reserveQueue.add(async () => {\n      const start = Date.now()\n\n      try {\n        // allow refresh of an existing reservation if it is about to expire\n        const existingReservation = this.reservations.get(peerId)\n\n        if (existingReservation != null) {\n          const connections = this.connectionManager.getConnections(peerId)\n          let connected = false\n\n          if (connections.length === 0) {\n            this.log('already have relay reservation with %p but we are no longer connected', peerId)\n          }\n\n          if (connections.map(conn => conn.id).includes(existingReservation.connection)) {\n            this.log('already have relay reservation with %p and the original connection is still open', peerId)\n            connected = true\n          }\n\n          if (connected && getExpirationMilliseconds(existingReservation.reservation.expire) > REFRESH_WINDOW) {\n            this.log('already have relay reservation with %p but we are still connected and it does not expire soon', peerId)\n            return {\n              relay: peerId,\n              details: existingReservation\n            } satisfies RelayReservation\n          }\n\n          await this.#removeReservation(peerId)\n        }\n\n        if (type === 'discovered' && this.pendingReservations.length === 0) {\n          throw new HadEnoughRelaysError('Not making reservation on discovered relay because we do not need any more relays')\n        }\n\n        const signal = AbortSignal.timeout(this.reservationCompletionTimeout)\n        setMaxListeners(Infinity, signal)\n\n        const connection = await this.connectionManager.openConnection(peerId, {\n          signal\n        })\n\n        if (Circuit.matches(connection.remoteAddr)) {\n          throw new DoubleRelayError('not creating reservation over relayed connection')\n        }\n\n        const reservation = await this.#createReservation(connection, {\n          signal\n        })\n\n        const expiration = getExpirationMilliseconds(reservation.expire)\n\n        this.log('created reservation on relay peer %p, expiry date is %s', peerId, new Date(Date.now() + expiration).toString())\n\n        // sets a lower bound on the timeout, and also don't let it go over\n        // 2^31 - 1 (setTimeout will only accept signed 32 bit integers)\n        const timeoutDuration = Math.min(Math.max(expiration - REFRESH_TIMEOUT, REFRESH_TIMEOUT_MIN), Math.pow(2, 31) - 1)\n\n        const timeout = setTimeout(() => {\n          this.log('refresh reservation to relay %p', peerId)\n\n          this.addRelay(peerId, type)\n            .catch(async err => {\n              this.log.error('could not refresh reservation to relay %p - %e', peerId, err)\n              await this.#removeReservation(peerId)\n            })\n            .catch(err => {\n              this.log.error('could not remove expired reservation to relay %p - %e', peerId, err)\n            })\n        }, timeoutDuration)\n\n        let res: RelayEntry\n\n        // assign a reservation id if one was requested\n        if (type === 'discovered') {\n          const id = this.pendingReservations.pop()\n\n          if (id == null) {\n            throw new HadEnoughRelaysError('Made reservation on relay but did not need any more discovered relays')\n          }\n\n          res = {\n            timeout,\n            reservation,\n            type,\n            connection: connection.id,\n            id\n          }\n        } else {\n          res = {\n            timeout,\n            reservation,\n            type,\n            connection: connection.id\n          }\n        }\n\n        // we've managed to create a reservation successfully\n        this.reservations.set(peerId, res)\n\n        // ensure we don't close the connection to the relay\n        await this.peerStore.merge(peerId, {\n          tags: {\n            [KEEP_ALIVE_TAG]: {\n              value: 1,\n              ttl: expiration\n            }\n          }\n        })\n\n        // check to see if we have discovered enough relays\n        this.#checkReservationCount()\n\n        const result: RelayReservation = {\n          relay: peerId,\n          details: res\n        }\n\n        this.safeDispatchEvent('relay:created-reservation', {\n          detail: result\n        })\n\n        return result\n      } catch (err: any) {\n        if (!(type === 'discovered' && err.name === 'HadEnoughRelaysError')) {\n          this.log.error('could not reserve slot on %p after %dms - %e', peerId, Date.now() - start, err)\n        }\n\n        // don't try this peer again if dialing failed or they do not support\n        // the hop protocol\n        if (err.name === 'DialError' || err.name === 'UnsupportedProtocolError') {\n          this.relayFilter.add(peerId.toMultihash().bytes)\n        }\n\n        // if listening failed, remove the reservation\n        this.#removeReservation(peerId)\n          .catch(err => {\n            this.log.error('could not remove reservation on %p after reserving slot failed - %e', peerId, err)\n          })\n\n        throw err\n      }\n    }, {\n      peerId\n    })\n  }\n\n  hasReservation (peerId: PeerId): boolean {\n    return this.reservations.has(peerId)\n  }\n\n  getReservation (peerId: PeerId): Reservation | undefined {\n    return this.reservations.get(peerId)?.reservation\n  }\n\n  reservationCount (type?: RelayType): number {\n    if (type == null) {\n      return this.reservations.size\n    }\n\n    return [...this.reservations.values()].reduce((acc, curr) => {\n      if (curr.type === type) {\n        acc++\n      }\n\n      return acc\n    }, 0)\n  }\n\n  cancelReservations (): void {\n    [...this.reservations.values()].forEach(reservation => {\n      clearTimeout(reservation.timeout)\n    })\n\n    this.reservations.clear()\n  }\n\n  async #createReservation (connection: Connection, options: AbortOptions): Promise<Reservation> {\n    options.signal?.throwIfAborted()\n\n    this.log('requesting reservation from %p', connection.remotePeer)\n    const stream = await connection.newStream(RELAY_V2_HOP_CODEC, options)\n    const pbstr = pbStream(stream)\n    const hopstr = pbstr.pb(HopMessage)\n\n    this.log.trace('send RESERVE to %p', connection.remotePeer)\n    await hopstr.write({ type: HopMessage.Type.RESERVE }, options)\n\n    let response: HopMessage\n\n    try {\n      this.log.trace('reading response from %p', connection.remotePeer)\n      response = await hopstr.read(options)\n    } catch (err: any) {\n      stream.abort(err)\n      throw err\n    } finally {\n      if (stream.status !== 'closed') {\n        await stream.close(options)\n      }\n    }\n\n    this.log.trace('read response %s', response.status)\n\n    if (response.status === Status.OK && response.reservation != null) {\n      // check that the returned relay has the relay address - this can be\n      // omitted when requesting a reservation from a go-libp2p relay we\n      // already have a reservation on\n      const addresses = new Set<string>()\n      addresses.add(connection.remoteAddr.toString())\n\n      for (const buf of response.reservation.addrs) {\n        let ma = multiaddr(buf)\n\n        if (ma.getComponents().find(c => c.code === CODE_P2P) == null) {\n          ma = ma.encapsulate(`/p2p/${connection.remotePeer}`)\n        }\n\n        // TODO: workaround for https://github.com/libp2p/go-libp2p/issues/3003\n        ma = multiaddr(ma.toString().replace(\n          `/p2p/${connection.remotePeer}/p2p/${connection.remotePeer}`,\n          `/p2p/${connection.remotePeer}`\n        ))\n\n        addresses.add(ma.toString())\n      }\n\n      response.reservation.addrs = [...addresses].map(str => multiaddr(str).bytes)\n\n      return response.reservation\n    }\n\n    const errMsg = `reservation failed with status ${response.status ?? 'undefined'}`\n    this.log.error(errMsg)\n\n    throw new Error(errMsg)\n  }\n\n  /**\n   * Remove listen relay\n   */\n  async #removeReservation (peerId: PeerId): Promise<void> {\n    const reservation = this.reservations.get(peerId)\n\n    if (reservation == null) {\n      return\n    }\n\n    this.log('removing relay reservation with %p from local store', peerId)\n    clearTimeout(reservation.timeout)\n    this.reservations.delete(peerId)\n\n    // discover a new relay for this discovery request\n    if (reservation.type === 'discovered') {\n      this.pendingReservations.push(\n        reservation.id\n      )\n    }\n\n    // untag the relay\n    await this.peerStore.merge(peerId, {\n      tags: {\n        [KEEP_ALIVE_TAG]: undefined\n      }\n    })\n\n    this.safeDispatchEvent('relay:removed', {\n      detail: {\n        relay: peerId,\n        details: reservation\n      }\n    })\n\n    // maybe trigger discovery of new relays\n    this.#checkReservationCount()\n  }\n\n  #checkReservationCount (): void {\n    if (this.pendingReservations.length === 0) {\n      this.log.trace('have discovered enough relays')\n      this.reserveQueue.clear()\n      this.safeDispatchEvent('relay:found-enough-relays')\n\n      return\n    }\n\n    this.relayFilter = createScalableCuckooFilter(100)\n    this.log('not discovered enough relays %d/%d', this.reservations.size, this.pendingReservations.length)\n    this.safeDispatchEvent('relay:not-enough-relays')\n  }\n}\n", "import { AbstractMultiaddrConnection } from '@libp2p/utils'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport type { AbortOptions, MultiaddrConnection, Stream } from '@libp2p/interface'\nimport type { AbstractMultiaddrConnectionInit, SendResult } from '@libp2p/utils'\n\nexport interface StreamMultiaddrConnectionInit extends Omit<AbstractMultiaddrConnectionInit, 'direction'> {\n  stream: Stream\n\n  /**\n   * A callback invoked when data is read from the stream\n   */\n  onDataRead?(buf: Uint8ArrayList | Uint8Array): void\n\n  /**\n   * A callback invoked when data is written to the stream\n   */\n  onDataWrite?(buf: Uint8ArrayList | Uint8Array): void\n}\n\nclass StreamMultiaddrConnection extends AbstractMultiaddrConnection {\n  private stream: Stream\n  private init: StreamMultiaddrConnectionInit\n\n  constructor (init: StreamMultiaddrConnectionInit) {\n    super({\n      ...init,\n      direction: init.stream.direction\n\n    })\n\n    this.init = init\n    this.stream = init.stream\n\n    this.stream.addEventListener('close', (evt) => {\n      this.onTransportClosed(evt.error)\n    })\n\n    this.stream.addEventListener('remoteCloseWrite', (evt) => {\n      this.onRemoteCloseWrite()\n\n      // close our end when the remote closes\n      this.close()\n        .catch(err => {\n          this.abort(err)\n        })\n    })\n\n    // count incoming bytes\n    this.stream.addEventListener('message', (evt) => {\n      init.onDataRead?.(evt.data)\n      this.onData(evt.data)\n    })\n\n    // forward drain events\n    this.stream.addEventListener('drain', () => {\n      this.safeDispatchEvent('drain')\n    })\n  }\n\n  sendData (data: Uint8ArrayList): SendResult {\n    this.init.onDataWrite?.(data)\n\n    return {\n      sentBytes: data.byteLength,\n      canSendMore: this.stream.send(data)\n    }\n  }\n\n  async sendClose (options?: AbortOptions): Promise<void> {\n    await this.stream.close(options)\n  }\n\n  sendReset (): void {\n    this.stream.abort(new Error('An error occurred'))\n  }\n\n  sendPause (): void {\n    this.stream.pause()\n  }\n\n  sendResume (): void {\n    this.stream.resume()\n  }\n}\n\n/**\n * Convert a Stream into a MultiaddrConnection.\n */\nexport function streamToMaConnection (init: StreamMultiaddrConnectionInit): MultiaddrConnection {\n  return new StreamMultiaddrConnection(init)\n}\n", "import { DialError, InvalidMessageError, serviceCapabilities, serviceDependencies, start, stop, transportSymbol } from '@libp2p/interface'\nimport { peerFilter } from '@libp2p/peer-collections'\nimport { peerIdFromMultihash, peerIdFromString } from '@libp2p/peer-id'\nimport { pbStream } from '@libp2p/utils'\nimport { CODE_P2P, multiaddr } from '@multiformats/multiaddr'\nimport { Circuit } from '@multiformats/multiaddr-matcher'\nimport { setMaxListeners } from 'main-event'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { CustomProgressEvent } from 'progress-events'\nimport { DEFAULT_DISCOVERY_FILTER_ERROR_RATE, DEFAULT_DISCOVERY_FILTER_SIZE, MAX_CONNECTIONS, RELAY_V2_HOP_CODEC, RELAY_V2_STOP_CODEC } from '../constants.js'\nimport { StopMessage, HopMessage, Status } from '../pb/index.js'\nimport { CircuitListen, CircuitSearch, LimitTracker } from '../utils.js'\nimport { RelayDiscovery } from './discovery.js'\nimport { createListener } from './listener.js'\nimport { ReservationStore } from './reservation-store.js'\nimport { streamToMaConnection } from './stream-to-conn.js'\nimport type { CircuitRelayTransportComponents, CircuitRelayTransportInit } from '../index.ts'\nimport type { Transport, CreateListenerOptions, Listener, Logger, Connection, Stream, OutboundConnectionUpgradeEvents, DialTransportOptions, OpenConnectionProgressEvents } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { ProgressEvent } from 'progress-events'\n\nconst isValidStop = (request: StopMessage): request is Required<StopMessage> => {\n  if (request.peer == null) {\n    return false\n  }\n\n  try {\n    request.peer.addrs.forEach(multiaddr)\n  } catch {\n    return false\n  }\n\n  return true\n}\n\nconst defaults = {\n  maxInboundStopStreams: MAX_CONNECTIONS,\n  maxOutboundStopStreams: MAX_CONNECTIONS,\n  stopTimeout: 30000\n}\n\nexport type CircuitRelayDialEvents =\n  OutboundConnectionUpgradeEvents |\n  OpenConnectionProgressEvents |\n  ProgressEvent<'circuit-relay:open-connection'> |\n  ProgressEvent<'circuit-relay:reuse-connection'> |\n  ProgressEvent<'circuit-relay:open-hop-stream'> |\n  ProgressEvent<'circuit-relay:write-connect-message'> |\n  ProgressEvent<'circuit-relay:read-connect-response'>\n\nexport class CircuitRelayTransport implements Transport<CircuitRelayDialEvents> {\n  private readonly components: CircuitRelayTransportComponents\n  private readonly discovery?: RelayDiscovery\n  public readonly reservationStore: ReservationStore\n  private readonly maxInboundStopStreams: number\n  private readonly maxOutboundStopStreams?: number\n  private started: boolean\n  private readonly log: Logger\n  private shutdownController: AbortController\n\n  constructor (components: CircuitRelayTransportComponents, init: CircuitRelayTransportInit = {}) {\n    this.components = components\n    this.log = components.logger.forComponent('libp2p:circuit-relay:transport')\n    this.maxInboundStopStreams = init.maxInboundStopStreams ?? defaults.maxInboundStopStreams\n    this.maxOutboundStopStreams = init.maxOutboundStopStreams ?? defaults.maxOutboundStopStreams\n    this.shutdownController = new AbortController()\n\n    this.discovery = new RelayDiscovery(components, {\n      filter: init.discoveryFilter ?? peerFilter(DEFAULT_DISCOVERY_FILTER_SIZE, DEFAULT_DISCOVERY_FILTER_ERROR_RATE)\n    })\n    this.discovery.addEventListener('relay:discover', (evt) => {\n      this.reservationStore.addRelay(evt.detail, 'discovered')\n        .catch(err => {\n          if (err.name !== 'HadEnoughRelaysError' && err.name !== 'RelayQueueFullError') {\n            this.log.error('could not add discovered relay %p - %e', evt.detail, err)\n          }\n        })\n    })\n    this.reservationStore = new ReservationStore(components, init)\n    this.reservationStore.addEventListener('relay:not-enough-relays', () => {\n      this.discovery?.startDiscovery()\n    })\n    this.reservationStore.addEventListener('relay:found-enough-relays', () => {\n      this.discovery?.stopDiscovery()\n    })\n\n    this.started = false\n\n    this.onStop = this.onStop.bind(this)\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/circuit-relay-v2-transport'\n\n  readonly [serviceCapabilities]: string[] = [\n    '@libp2p/transport',\n    '@libp2p/circuit-relay-v2-transport'\n  ]\n\n  get [serviceDependencies] (): string[] {\n    // we only need identify if discovery is enabled\n    if (this.discovery != null) {\n      return [\n        '@libp2p/identify'\n      ]\n    }\n\n    return []\n  }\n\n  readonly [transportSymbol] = true\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  async start (): Promise<void> {\n    this.shutdownController = new AbortController()\n    setMaxListeners(Infinity, this.shutdownController.signal)\n\n    await this.components.registrar.handle(RELAY_V2_STOP_CODEC, this.onStop, {\n      maxInboundStreams: this.maxInboundStopStreams,\n      maxOutboundStreams: this.maxOutboundStopStreams,\n      runOnLimitedConnection: true\n    })\n\n    await start(this.discovery, this.reservationStore)\n\n    this.started = true\n  }\n\n  async stop (): Promise<void> {\n    this.shutdownController.abort()\n    await stop(this.discovery, this.reservationStore)\n    await this.components.registrar.unhandle(RELAY_V2_STOP_CODEC)\n\n    this.started = false\n  }\n\n  /**\n   * Dial a peer over a relay\n   */\n  async dial (ma: Multiaddr, options: DialTransportOptions<CircuitRelayDialEvents>): Promise<Connection> {\n    // Check the multiaddr to see if it contains a relay and a destination peer\n    const addrs = ma.toString().split('/p2p-circuit')\n    const relayAddr = multiaddr(addrs[0])\n    const destinationAddr = multiaddr(addrs[addrs.length - 1])\n    const relayId = relayAddr.getComponents().find(c => c.code === CODE_P2P)?.value\n    const destinationId = destinationAddr.getComponents().find(c => c.code === CODE_P2P)?.value\n\n    if (relayId == null || destinationId == null) {\n      const errMsg = `ircuit relay dial to ${ma.toString()} failed as address did not have both relay and destination PeerIDs`\n      this.log.error(`c${errMsg}`)\n      throw new DialError(`C${errMsg}`)\n    }\n\n    const relayPeer = peerIdFromString(relayId)\n    const destinationPeer = peerIdFromString(destinationId)\n\n    const relayConnections = this.components.connectionManager.getConnections(relayPeer)\n    let relayConnection = relayConnections[0]\n\n    if (relayConnection == null) {\n      await this.components.peerStore.merge(relayPeer, {\n        multiaddrs: [relayAddr]\n      })\n\n      options.onProgress?.(new CustomProgressEvent('circuit-relay:open-connection'))\n      relayConnection = await this.components.connectionManager.openConnection(relayPeer, options)\n    } else {\n      options.onProgress?.(new CustomProgressEvent('circuit-relay:reuse-connection'))\n    }\n\n    let stream: Stream | undefined\n\n    try {\n      options.onProgress?.(new CustomProgressEvent('circuit-relay:open-hop-stream'))\n      stream = await relayConnection.newStream(RELAY_V2_HOP_CODEC, options)\n\n      const hopstr = pbStream(stream).pb(HopMessage)\n\n      options.onProgress?.(new CustomProgressEvent('circuit-relay:write-connect-message'))\n      await hopstr.write({\n        type: HopMessage.Type.CONNECT,\n        peer: {\n          id: destinationPeer.toMultihash().bytes,\n          addrs: [multiaddr(destinationAddr).bytes]\n        }\n      }, options)\n\n      options.onProgress?.(new CustomProgressEvent('circuit-relay:read-connect-response'))\n      const status = await hopstr.read(options)\n\n      if (status.status !== Status.OK) {\n        throw new InvalidMessageError(`failed to connect via relay with status ${status?.status?.toString() ?? 'undefined'}`)\n      }\n\n      const limits = new LimitTracker(status.limit)\n\n      const maConn = streamToMaConnection({\n        stream: hopstr.unwrap().unwrap(),\n        remoteAddr: ma,\n        localAddr: relayAddr.encapsulate(`/p2p-circuit/p2p/${this.components.peerId.toString()}`),\n        onDataRead: limits.onData,\n        onDataWrite: limits.onData,\n        log: stream.log.newScope('circuit-relay:connection')\n      })\n\n      const conn = await this.components.upgrader.upgradeOutbound(maConn, {\n        ...options,\n        limits: limits.getLimits()\n      })\n\n      conn.log('outbound relayed connection established to %p with limits %o, over connection %s', conn.remotePeer, status.limit ?? 'none', relayConnection.id)\n\n      return conn\n    } catch (err: any) {\n      this.log.error('circuit relay dial to destination %p via relay %p failed - %e', destinationPeer, relayPeer, err)\n      stream?.abort(err)\n\n      throw err\n    }\n  }\n\n  /**\n   * Create a listener\n   */\n  createListener (options: CreateListenerOptions): Listener {\n    return createListener({\n      peerId: this.components.peerId,\n      connectionManager: this.components.connectionManager,\n      addressManager: this.components.addressManager,\n      reservationStore: this.reservationStore,\n      logger: this.components.logger\n    })\n  }\n\n  /**\n   * Filter check for all Multiaddrs that this transport can listen on\n   */\n  listenFilter (multiaddrs: Multiaddr[]): Multiaddr[] {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs]\n\n    return multiaddrs.filter((ma) => {\n      return CircuitListen.exactMatch(ma) || CircuitSearch.exactMatch(ma)\n    })\n  }\n\n  /**\n   * Filter check for all Multiaddrs that this transport can dial\n   */\n  dialFilter (multiaddrs: Multiaddr[]): Multiaddr[] {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs]\n\n    return multiaddrs.filter((ma) => {\n      return Circuit.exactMatch(ma)\n    })\n  }\n\n  /**\n   * An incoming STOP request means a remote peer wants to dial us via a relay\n   */\n  async onStop (stream: Stream, connection: Connection): Promise<void> {\n    const signal = this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal)\n\n    try {\n      if (!this.reservationStore.hasReservation(connection.remotePeer)) {\n        try {\n          this.log('dialed via relay we did not have a reservation on, start listening on that relay address')\n          await this.components.transportManager.listen([connection.remoteAddr.encapsulate('/p2p-circuit')])\n        } catch (err: any) {\n          // failed to refresh our hitherto unknown relay reservation but allow the connection attempt anyway\n          this.log.error('failed to listen on a relay peer we were dialed via but did not have a reservation on - %e', err)\n        }\n      }\n\n      const stopStream = pbStream(stream).pb(StopMessage)\n      const request = await stopStream.read({\n        signal\n      })\n\n      this.log('new circuit relay v2 stop stream from %p with type %s', connection.remotePeer, request.type)\n\n      if (request?.type === undefined) {\n        this.log.error('type was missing from circuit v2 stop protocol request from %s', connection.remotePeer)\n        await stopStream.write({ type: StopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, {\n          signal\n        })\n        await stream.close({\n          signal\n        })\n        return\n      }\n\n      // Validate the STOP request has the required input\n      if (request.type !== StopMessage.Type.CONNECT) {\n        this.log.error('invalid stop connect request via peer %p', connection.remotePeer)\n        await stopStream.write({ type: StopMessage.Type.STATUS, status: Status.UNEXPECTED_MESSAGE }, {\n          signal\n        })\n        await stream.close({\n          signal\n        })\n        return\n      }\n\n      if (!isValidStop(request)) {\n        this.log.error('invalid stop connect request via peer %p', connection.remotePeer)\n        await stopStream.write({ type: StopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, {\n          signal\n        })\n        await stream.close({\n          signal\n        })\n        return\n      }\n\n      const remotePeerId = peerIdFromMultihash(Digest.decode(request.peer.id))\n\n      if ((await this.components.connectionGater.denyInboundRelayedConnection?.(connection.remotePeer, remotePeerId)) === true) {\n        this.log.error('connection gater denied inbound relayed connection from %p', connection.remotePeer)\n        await stopStream.write({ type: StopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, {\n          signal\n        })\n        await stream.close({\n          signal\n        })\n        return\n      }\n\n      this.log.trace('sending success response to %p', connection.remotePeer)\n      await stopStream.write({ type: StopMessage.Type.STATUS, status: Status.OK }, {\n        signal\n      })\n\n      const limits = new LimitTracker(request.limit)\n      const remoteAddr = connection.remoteAddr.encapsulate(`/p2p-circuit/p2p/${remotePeerId.toString()}`)\n      const localAddr = this.components.addressManager.getAddresses()[0]\n      const maConn = streamToMaConnection({\n        stream: stopStream.unwrap().unwrap(),\n        remoteAddr,\n        localAddr,\n        onDataRead: limits.onData,\n        onDataWrite: limits.onData,\n        log: stream.log.newScope('circuit-relay:connection')\n      })\n\n      await this.components.upgrader.upgradeInbound(maConn, {\n        limits: limits.getLimits(),\n        signal\n      })\n\n      maConn.log('inbound relayed connection established to %p with limits %o, over connection %s', remotePeerId, request.limit ?? 'none', connection.id)\n    } finally {\n      signal?.clear()\n    }\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * The `circuitRelayTransport` allows libp2p to dial and listen on [Circuit Relay](https://docs.libp2p.io/concepts/nat/circuit-relay/)\n * addresses.\n *\n * @example Use as a transport\n *\n * Configuring a transport will let you dial other circuit relay addresses.\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n * import { circuitRelayTransport } from '@libp2p/circuit-relay-v2'\n *\n * const node = await createLibp2p({\n *   transports: [\n *     circuitRelayTransport()\n *   ]\n * })\n * ```\n *\n * The `circuitRelayServer` function allows libp2p to function as a [Circuit Relay](https://docs.libp2p.io/concepts/nat/circuit-relay/)\n * server.  This will not work in browsers.\n *\n * @example Use as a server\n *\n * Configuring a server will let you function as a network relay for other\n * nodes.\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n * import { circuitRelayServer } from '@libp2p/circuit-relay-v2'\n *\n * const node = await createLibp2p({\n *   services: {\n *     circuitRelay: circuitRelayServer()\n *   }\n * })\n * ```\n */\n\nimport { TypedEventEmitter } from 'main-event'\nimport { CircuitRelayServer } from './server/index.js'\nimport { CircuitRelayTransport } from './transport/index.ts'\nimport type { Limit } from './pb/index.js'\nimport type { ComponentLogger, ConnectionGater, Libp2pEvents, Metrics, PeerId, PeerStore, PrivateKey, TopologyFilter, Transport, TypedEventTarget, Upgrader } from '@libp2p/interface'\nimport type { AddressManager, ConnectionManager, RandomWalk, Registrar, TransportManager } from '@libp2p/interface-internal'\nimport type { PeerMap } from '@libp2p/peer-collections'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { RetimeableAbortSignal } from 'retimeable-signal'\n\nexport type { Limit }\n\nexport interface RelayReservation {\n  /**\n   * When this reservation expires\n   */\n  expiry: Date\n\n  /**\n   * The address of the relay client\n   */\n  addr: Multiaddr\n\n  /**\n   * How much data can be transferred over each relayed connection and for how\n   * long before the underlying stream is reset\n   */\n  limit?: Limit\n\n  /**\n   * This signal will fire it's \"abort\" event when the reservation expires\n   */\n  signal: RetimeableAbortSignal\n}\n\nexport interface CircuitRelayServiceEvents {\n  'relay:reservation': CustomEvent<RelayReservation>\n  'relay:advert:success': CustomEvent<unknown>\n  'relay:advert:error': CustomEvent<Error>\n}\n\nexport interface CircuitRelayService extends TypedEventEmitter<CircuitRelayServiceEvents> {\n  reservations: PeerMap<RelayReservation>\n}\n\nexport {\n  RELAY_V2_HOP_CODEC,\n  RELAY_V2_STOP_CODEC\n} from './constants.js'\n\nexport interface ServerReservationStoreInit {\n  /**\n   * maximum number of reservations allowed\n   *\n   * @default 15\n   */\n  maxReservations?: number\n\n  /**\n   * interval after which stale reservations are cleared\n   *\n   * @default 300000\n   */\n  reservationClearInterval?: number\n\n  /**\n   * apply default relay limits to a new reservation\n   *\n   * @default true\n   */\n  applyDefaultLimit?: boolean\n\n  /**\n   * reservation ttl\n   *\n   * @default 7200000\n   */\n  reservationTtl?: number\n\n  /**\n   * The maximum time a relayed connection can be open for\n   */\n  defaultDurationLimit?: number\n\n  /**\n   * The maximum amount of data allowed to be transferred over a relayed connection\n   */\n  defaultDataLimit?: bigint\n}\n\nexport interface CircuitRelayServerComponents {\n  registrar: Registrar\n  peerStore: PeerStore\n  addressManager: AddressManager\n  peerId: PeerId\n  privateKey: PrivateKey\n  connectionManager: ConnectionManager\n  connectionGater: ConnectionGater\n  logger: ComponentLogger\n  metrics?: Metrics\n}\n\nexport interface CircuitRelayServerInit {\n  /**\n   * Incoming hop requests must complete within this time in ms otherwise\n   * the stream will be reset\n   *\n   * @default 30000\n   */\n  hopTimeout?: number\n\n  /**\n   * Configuration of reservations\n   */\n  reservations?: ServerReservationStoreInit\n\n  /**\n   * The maximum number of simultaneous HOP inbound streams that can be open at once\n   */\n  maxInboundHopStreams?: number\n\n  /**\n   * The maximum number of simultaneous HOP outbound streams that can be open at once\n   */\n  maxOutboundHopStreams?: number\n\n  /**\n   * The maximum number of simultaneous STOP outbound streams that can be open at\n   * once.\n   *\n   * @default 300\n   */\n  maxOutboundStopStreams?: number\n}\n\nexport function circuitRelayServer (init: CircuitRelayServerInit = {}): (components: CircuitRelayServerComponents) => CircuitRelayService {\n  return (components) => {\n    return new CircuitRelayServer(components, init)\n  }\n}\n\nexport interface RelayDiscoveryEvents {\n  'relay:discover': CustomEvent<PeerId>\n}\n\nexport interface TransportReservationStoreComponents {\n  peerId: PeerId\n  connectionManager: ConnectionManager\n  peerStore: PeerStore\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n  metrics?: Metrics\n}\n\nexport interface TransportReservationStoreInit {\n  /**\n   * Multiple relays may be discovered simultaneously - to prevent listening\n   * on too many relays, this value controls how many to attempt to reserve a\n   * slot on at once. If set to more than one, we may end up listening on\n   * more relays than the `maxReservations` value, but on networks with poor\n   * connectivity the user may wish to attempt to reserve on multiple relays\n   * simultaneously.\n   *\n   * @default 1\n   */\n  reservationConcurrency?: number\n\n  /**\n   * Limit the number of potential relays we will dial\n   *\n   * @default 100\n   */\n  maxReservationQueueLength?: number\n\n  /**\n   * When creating a reservation it must complete within this number of ms\n   *\n   * @default 5000\n   */\n  reservationCompletionTimeout?: number\n}\n\nexport interface RelayDiscoveryComponents {\n  peerStore: PeerStore\n  connectionManager: ConnectionManager\n  transportManager: TransportManager\n  registrar: Registrar\n  logger: ComponentLogger\n  randomWalk: RandomWalk\n  events: TypedEventTarget<Libp2pEvents>\n}\n\nexport interface RelayDiscoveryInit {\n  filter?: TopologyFilter\n}\n\nexport interface CircuitRelayTransportComponents extends RelayDiscoveryComponents {\n  peerId: PeerId\n  upgrader: Upgrader\n  addressManager: AddressManager\n  connectionGater: ConnectionGater\n}\n\n/**\n * RelayConfig configures the circuit v2 relay transport.\n */\nexport interface CircuitRelayTransportInit extends TransportReservationStoreInit {\n  /**\n   * An optional filter used to prevent duplicate attempts to reserve relay\n   * slots on the same peer\n   */\n  discoveryFilter?: TopologyFilter\n\n  /**\n   * The maximum number of simultaneous STOP inbound streams that can be open at\n   * once - each inbound relayed connection uses a STOP stream\n   *\n   * @default 300\n   */\n  maxInboundStopStreams?: number\n\n  /**\n   * The maximum number of simultaneous STOP outbound streams that can be open\n   * at once. If this transport is used along with the relay server these\n   * settings should be set to the same value\n   *\n   * @default 300\n   */\n  maxOutboundStopStreams?: number\n\n  /**\n   * When creating a reservation it must complete within this number of ms\n   *\n   * @default 10_000\n   */\n  reservationCompletionTimeout?: number\n}\n\nexport function circuitRelayTransport (init: CircuitRelayTransportInit = {}): (components: CircuitRelayTransportComponents) => Transport {\n  return (components) => {\n    return new CircuitRelayTransport(components, init)\n  }\n}\n"],
  "mappings": "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",
  "names": ["HopMessage", "Type", "__TypeValues", "_a", "_b", "_c", "StopMessage", "Peer", "Reservation", "Limit", "Status", "__StatusValues", "ReservationVoucher", "Envelope", "message", "_a", "_b", "message", "code", "_a", "_b", "_c", "err", "_a", "_b", "_a", "_b", "ReservationStore", "reservation", "start", "err", "_a", "_a", "_b", "defaults", "_a", "_b", "ReservationStore", "_c", "_d"]
}
