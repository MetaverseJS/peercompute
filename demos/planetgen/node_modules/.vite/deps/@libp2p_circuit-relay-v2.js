import {
  CustomProgressEvent
} from "./chunk-L4KE4EKF.js";
import {
  PeerMap,
  peerFilter,
  trackedPeerMap
} from "./chunk-WIUPDO5L.js";
import {
  RecordEnvelope
} from "./chunk-H65XI27X.js";
import {
  Circuit,
  P2P,
  and,
  code,
  fmt
} from "./chunk-7DMLAAL4.js";
import {
  AbstractMultiaddrConnection,
  PeerQueue,
  anySignal,
  createScalableCuckooFilter,
  pbStream,
  pipe
} from "./chunk-WWTG3YU6.js";
import {
  CODE_P2P,
  CODE_P2P_CIRCUIT,
  multiaddr
} from "./chunk-SAZZGDH5.js";
import {
  peerIdFromMultihash,
  peerIdFromString
} from "./chunk-RA2DG4WK.js";
import "./chunk-MXJRKQ3V.js";
import {
  DialError,
  InvalidMessageError,
  KEEP_ALIVE,
  ListenError,
  MaxLengthError,
  TypedEventEmitter,
  decodeMessage,
  encodeMessage,
  enumeration,
  message,
  publicKeyToProtobuf,
  serviceCapabilities,
  serviceDependencies,
  setMaxListeners,
  start,
  stop,
  transportSymbol
} from "./chunk-HXWYJQY6.js";
import {
  alloc,
  decode,
  toString
} from "./chunk-PS3LPXH2.js";
import {
  __privateAdd,
  __privateMethod,
  __publicField
} from "./chunk-WOOG5QLI.js";

// ../../node_modules/@libp2p/circuit-relay-v2/dist/src/constants.js
var second = 1e3;
var minute = 60 * second;
var DEFAULT_MAX_RESERVATION_STORE_SIZE = 15;
var DEFAULT_MAX_RESERVATION_TTL = 2 * 60 * minute;
var DEFAULT_RESERVATION_CONCURRENCY = 1;
var DEFAULT_RESERVATION_COMPLETION_TIMEOUT = 5e3;
var DEFAULT_MAX_RESERVATION_QUEUE_LENGTH = 100;
var RELAY_SOURCE_TAG = "circuit-relay-source";
var KEEP_ALIVE_TAG = `${KEEP_ALIVE}-circuit-relay`;
var DEFAULT_DURATION_LIMIT = 2 * minute;
var DEFAULT_DATA_LIMIT = BigInt(1 << 17);
var RELAY_V2_HOP_CODEC = "/libp2p/circuit/relay/0.2.0/hop";
var RELAY_V2_STOP_CODEC = "/libp2p/circuit/relay/0.2.0/stop";
var DEFAULT_HOP_TIMEOUT = 30 * second;
var DEFAULT_ADVERT_BOOT_DELAY = 30 * second;
var MAX_CONNECTIONS = 300;
var DEFAULT_DISCOVERY_FILTER_SIZE = 4096;
var DEFAULT_DISCOVERY_FILTER_ERROR_RATE = 1e-3;

// ../../node_modules/@libp2p/circuit-relay-v2/dist/src/pb/index.js
var HopMessage;
(function(HopMessage2) {
  let Type;
  (function(Type2) {
    Type2["RESERVE"] = "RESERVE";
    Type2["CONNECT"] = "CONNECT";
    Type2["STATUS"] = "STATUS";
  })(Type = HopMessage2.Type || (HopMessage2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["RESERVE"] = 0] = "RESERVE";
    __TypeValues2[__TypeValues2["CONNECT"] = 1] = "CONNECT";
    __TypeValues2[__TypeValues2["STATUS"] = 2] = "STATUS";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type2) {
    Type2.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Type = HopMessage2.Type || (HopMessage2.Type = {}));
  let _codec;
  HopMessage2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null) {
          w.uint32(8);
          HopMessage2.Type.codec().encode(obj.type, w);
        }
        if (obj.peer != null) {
          w.uint32(18);
          Peer.codec().encode(obj.peer, w);
        }
        if (obj.reservation != null) {
          w.uint32(26);
          Reservation.codec().encode(obj.reservation, w);
        }
        if (obj.limit != null) {
          w.uint32(34);
          Limit.codec().encode(obj.limit, w);
        }
        if (obj.status != null) {
          w.uint32(40);
          Status.codec().encode(obj.status, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        var _a3, _b3, _c2;
        const obj = {};
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.type = HopMessage2.Type.codec().decode(reader);
              break;
            }
            case 2: {
              obj.peer = Peer.codec().decode(reader, reader.uint32(), {
                limits: (_a3 = opts.limits) == null ? void 0 : _a3.peer
              });
              break;
            }
            case 3: {
              obj.reservation = Reservation.codec().decode(reader, reader.uint32(), {
                limits: (_b3 = opts.limits) == null ? void 0 : _b3.reservation
              });
              break;
            }
            case 4: {
              obj.limit = Limit.codec().decode(reader, reader.uint32(), {
                limits: (_c2 = opts.limits) == null ? void 0 : _c2.limit
              });
              break;
            }
            case 5: {
              obj.status = Status.codec().decode(reader);
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  HopMessage2.encode = (obj) => {
    return encodeMessage(obj, HopMessage2.codec());
  };
  HopMessage2.decode = (buf, opts) => {
    return decodeMessage(buf, HopMessage2.codec(), opts);
  };
})(HopMessage || (HopMessage = {}));
var StopMessage;
(function(StopMessage2) {
  let Type;
  (function(Type2) {
    Type2["CONNECT"] = "CONNECT";
    Type2["STATUS"] = "STATUS";
  })(Type = StopMessage2.Type || (StopMessage2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["CONNECT"] = 0] = "CONNECT";
    __TypeValues2[__TypeValues2["STATUS"] = 1] = "STATUS";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type2) {
    Type2.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Type = StopMessage2.Type || (StopMessage2.Type = {}));
  let _codec;
  StopMessage2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null) {
          w.uint32(8);
          StopMessage2.Type.codec().encode(obj.type, w);
        }
        if (obj.peer != null) {
          w.uint32(18);
          Peer.codec().encode(obj.peer, w);
        }
        if (obj.limit != null) {
          w.uint32(26);
          Limit.codec().encode(obj.limit, w);
        }
        if (obj.status != null) {
          w.uint32(32);
          Status.codec().encode(obj.status, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        var _a3, _b3;
        const obj = {};
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.type = StopMessage2.Type.codec().decode(reader);
              break;
            }
            case 2: {
              obj.peer = Peer.codec().decode(reader, reader.uint32(), {
                limits: (_a3 = opts.limits) == null ? void 0 : _a3.peer
              });
              break;
            }
            case 3: {
              obj.limit = Limit.codec().decode(reader, reader.uint32(), {
                limits: (_b3 = opts.limits) == null ? void 0 : _b3.limit
              });
              break;
            }
            case 4: {
              obj.status = Status.codec().decode(reader);
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  StopMessage2.encode = (obj) => {
    return encodeMessage(obj, StopMessage2.codec());
  };
  StopMessage2.decode = (buf, opts) => {
    return decodeMessage(buf, StopMessage2.codec(), opts);
  };
})(StopMessage || (StopMessage = {}));
var Peer;
(function(Peer2) {
  let _codec;
  Peer2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.id != null && obj.id.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.id);
        }
        if (obj.addrs != null) {
          for (const value of obj.addrs) {
            w.uint32(18);
            w.bytes(value);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        var _a3;
        const obj = {
          id: alloc(0),
          addrs: []
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.id = reader.bytes();
              break;
            }
            case 2: {
              if (((_a3 = opts.limits) == null ? void 0 : _a3.addrs) != null && obj.addrs.length === opts.limits.addrs) {
                throw new MaxLengthError('Decode error - map field "addrs" had too many elements');
              }
              obj.addrs.push(reader.bytes());
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Peer2.encode = (obj) => {
    return encodeMessage(obj, Peer2.codec());
  };
  Peer2.decode = (buf, opts) => {
    return decodeMessage(buf, Peer2.codec(), opts);
  };
})(Peer || (Peer = {}));
var Reservation;
(function(Reservation2) {
  let _codec;
  Reservation2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.expire != null && obj.expire !== 0n) {
          w.uint32(8);
          w.uint64(obj.expire);
        }
        if (obj.addrs != null) {
          for (const value of obj.addrs) {
            w.uint32(18);
            w.bytes(value);
          }
        }
        if (obj.voucher != null) {
          w.uint32(26);
          Envelope.codec().encode(obj.voucher, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        var _a3, _b3;
        const obj = {
          expire: 0n,
          addrs: []
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.expire = reader.uint64();
              break;
            }
            case 2: {
              if (((_a3 = opts.limits) == null ? void 0 : _a3.addrs) != null && obj.addrs.length === opts.limits.addrs) {
                throw new MaxLengthError('Decode error - map field "addrs" had too many elements');
              }
              obj.addrs.push(reader.bytes());
              break;
            }
            case 3: {
              obj.voucher = Envelope.codec().decode(reader, reader.uint32(), {
                limits: (_b3 = opts.limits) == null ? void 0 : _b3.voucher
              });
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Reservation2.encode = (obj) => {
    return encodeMessage(obj, Reservation2.codec());
  };
  Reservation2.decode = (buf, opts) => {
    return decodeMessage(buf, Reservation2.codec(), opts);
  };
})(Reservation || (Reservation = {}));
var Limit;
(function(Limit2) {
  let _codec;
  Limit2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.duration != null) {
          w.uint32(8);
          w.uint32(obj.duration);
        }
        if (obj.data != null) {
          w.uint32(16);
          w.uint64(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        const obj = {};
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.duration = reader.uint32();
              break;
            }
            case 2: {
              obj.data = reader.uint64();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Limit2.encode = (obj) => {
    return encodeMessage(obj, Limit2.codec());
  };
  Limit2.decode = (buf, opts) => {
    return decodeMessage(buf, Limit2.codec(), opts);
  };
})(Limit || (Limit = {}));
var Status;
(function(Status2) {
  Status2["UNUSED"] = "UNUSED";
  Status2["OK"] = "OK";
  Status2["RESERVATION_REFUSED"] = "RESERVATION_REFUSED";
  Status2["RESOURCE_LIMIT_EXCEEDED"] = "RESOURCE_LIMIT_EXCEEDED";
  Status2["PERMISSION_DENIED"] = "PERMISSION_DENIED";
  Status2["CONNECTION_FAILED"] = "CONNECTION_FAILED";
  Status2["NO_RESERVATION"] = "NO_RESERVATION";
  Status2["MALFORMED_MESSAGE"] = "MALFORMED_MESSAGE";
  Status2["UNEXPECTED_MESSAGE"] = "UNEXPECTED_MESSAGE";
})(Status || (Status = {}));
var __StatusValues;
(function(__StatusValues2) {
  __StatusValues2[__StatusValues2["UNUSED"] = 0] = "UNUSED";
  __StatusValues2[__StatusValues2["OK"] = 100] = "OK";
  __StatusValues2[__StatusValues2["RESERVATION_REFUSED"] = 200] = "RESERVATION_REFUSED";
  __StatusValues2[__StatusValues2["RESOURCE_LIMIT_EXCEEDED"] = 201] = "RESOURCE_LIMIT_EXCEEDED";
  __StatusValues2[__StatusValues2["PERMISSION_DENIED"] = 202] = "PERMISSION_DENIED";
  __StatusValues2[__StatusValues2["CONNECTION_FAILED"] = 203] = "CONNECTION_FAILED";
  __StatusValues2[__StatusValues2["NO_RESERVATION"] = 204] = "NO_RESERVATION";
  __StatusValues2[__StatusValues2["MALFORMED_MESSAGE"] = 400] = "MALFORMED_MESSAGE";
  __StatusValues2[__StatusValues2["UNEXPECTED_MESSAGE"] = 401] = "UNEXPECTED_MESSAGE";
})(__StatusValues || (__StatusValues = {}));
(function(Status2) {
  Status2.codec = () => {
    return enumeration(__StatusValues);
  };
})(Status || (Status = {}));
var ReservationVoucher;
(function(ReservationVoucher2) {
  let _codec;
  ReservationVoucher2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.relay != null && obj.relay.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.relay);
        }
        if (obj.peer != null && obj.peer.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.peer);
        }
        if (obj.expiration != null && obj.expiration !== 0n) {
          w.uint32(24);
          w.uint64(obj.expiration);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        const obj = {
          relay: alloc(0),
          peer: alloc(0),
          expiration: 0n
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.relay = reader.bytes();
              break;
            }
            case 2: {
              obj.peer = reader.bytes();
              break;
            }
            case 3: {
              obj.expiration = reader.uint64();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  ReservationVoucher2.encode = (obj) => {
    return encodeMessage(obj, ReservationVoucher2.codec());
  };
  ReservationVoucher2.decode = (buf, opts) => {
    return decodeMessage(buf, ReservationVoucher2.codec(), opts);
  };
})(ReservationVoucher || (ReservationVoucher = {}));
var Envelope;
(function(Envelope2) {
  let _codec;
  Envelope2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.publicKey != null && obj.publicKey.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (obj.payloadType != null && obj.payloadType.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.payloadType);
        }
        if (obj.payload != null) {
          w.uint32(26);
          ReservationVoucher.codec().encode(obj.payload, w);
        }
        if (obj.signature != null && obj.signature.byteLength > 0) {
          w.uint32(42);
          w.bytes(obj.signature);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        var _a3;
        const obj = {
          publicKey: alloc(0),
          payloadType: alloc(0),
          signature: alloc(0)
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 2: {
              obj.payloadType = reader.bytes();
              break;
            }
            case 3: {
              obj.payload = ReservationVoucher.codec().decode(reader, reader.uint32(), {
                limits: (_a3 = opts.limits) == null ? void 0 : _a3.payload
              });
              break;
            }
            case 5: {
              obj.signature = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Envelope2.encode = (obj) => {
    return encodeMessage(obj, Envelope2.codec());
  };
  Envelope2.decode = (buf, opts) => {
    return decodeMessage(buf, Envelope2.codec(), opts);
  };
})(Envelope || (Envelope = {}));

// ../../node_modules/@libp2p/circuit-relay-v2/dist/src/errors.js
var TransferLimitError = class extends Error {
  constructor(message2 = "Transfer limit error") {
    super(message2);
    this.name = "TransferLimitError";
  }
};
var DurationLimitError = class extends Error {
  constructor(message2 = "Duration limit error") {
    super(message2);
    this.name = "DurationLimitError";
  }
};
var HadEnoughRelaysError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "HadEnoughRelaysError");
  }
};
__publicField(HadEnoughRelaysError, "name", "HadEnoughRelaysError");
var DoubleRelayError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "DoubleRelayError");
  }
};
__publicField(DoubleRelayError, "name", "DoubleRelayError");
var RelayQueueFullError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "RelayQueueFullError");
  }
};
__publicField(RelayQueueFullError, "name", "RelayQueueFullError");

// ../../node_modules/@libp2p/circuit-relay-v2/dist/src/utils.js
function countStreamBytes(source, limit, options) {
  const limitBytes = limit.remaining;
  const abortIfStreamByteLimitExceeded = (evt) => {
    const len = BigInt(evt.data.byteLength);
    limit.remaining -= len;
    if (limit.remaining < 0) {
      source.abort(new TransferLimitError(`data limit of ${limitBytes} bytes exceeded`));
    }
  };
  source.addEventListener("message", abortIfStreamByteLimitExceeded);
}
function createLimitedRelay(src, dst, abortSignal, reservation, options) {
  var _a3, _b3;
  function abortStreams(err) {
    src.abort(err);
    dst.abort(err);
  }
  const signals = [abortSignal, reservation.signal];
  if (((_a3 = reservation.limit) == null ? void 0 : _a3.duration) != null) {
    options.log("limiting relayed connection duration to %dms", reservation.limit.duration);
    const durationSignal = AbortSignal.timeout(reservation.limit.duration);
    setMaxListeners(Infinity, durationSignal);
    signals.push(durationSignal);
  }
  const signal = anySignal(signals);
  setMaxListeners(Infinity, signal);
  let dataLimit;
  if (((_b3 = reservation.limit) == null ? void 0 : _b3.data) != null) {
    dataLimit = {
      remaining: reservation.limit.data
    };
  }
  const onAbort = () => {
    var _a4;
    let err;
    if (abortSignal.aborted) {
      err = abortSignal.reason;
    } else {
      err = new DurationLimitError(`duration limit of ${(_a4 = reservation.limit) == null ? void 0 : _a4.duration} ms exceeded`);
    }
    abortStreams(err);
  };
  signal.addEventListener("abort", onAbort, { once: true });
  if (dataLimit != null) {
    countStreamBytes(dst, dataLimit, options);
    countStreamBytes(src, dataLimit, options);
  }
  pipe(src, dst, src).catch((err) => {
    abortStreams(err);
  }).finally(() => {
    signal.clear();
  });
}
function getExpirationMilliseconds(expireTimeSeconds) {
  const expireTimeMillis = expireTimeSeconds * BigInt(1e3);
  const currentTime = (/* @__PURE__ */ new Date()).getTime();
  return Number(expireTimeMillis - BigInt(currentTime));
}
var LimitTracker = class {
  constructor(limits) {
    __publicField(this, "expires");
    __publicField(this, "bytes");
    if ((limits == null ? void 0 : limits.duration) != null && (limits == null ? void 0 : limits.duration) !== 0) {
      this.expires = Date.now() + limits.duration * 1e3;
    }
    this.bytes = limits == null ? void 0 : limits.data;
    if (this.bytes === 0n) {
      this.bytes = void 0;
    }
    this.onData = this.onData.bind(this);
  }
  onData(buf) {
    if (this.bytes == null) {
      return;
    }
    this.bytes -= BigInt(buf.byteLength);
    if (this.bytes < 0n) {
      this.bytes = 0n;
    }
  }
  getLimits() {
    if (this.expires == null && this.bytes == null) {
      return;
    }
    const output = {};
    if (this.bytes != null) {
      const self = this;
      Object.defineProperty(output, "bytes", {
        get() {
          return self.bytes;
        }
      });
    }
    if (this.expires != null) {
      const self = this;
      Object.defineProperty(output, "seconds", {
        get() {
          return Math.round(((self.expires ?? 0) - Date.now()) / 1e3);
        }
      });
    }
    return output;
  }
};
var CircuitListen = fmt(and(P2P.matchers[0], code(CODE_P2P_CIRCUIT)));
var CircuitSearch = fmt(code(CODE_P2P_CIRCUIT));

// ../../node_modules/retimeable-signal/dist/src/index.js
var AbortError = class extends Error {
  constructor(message2, code2, name) {
    super(message2 ?? "The operation was aborted");
    __publicField(this, "type");
    __publicField(this, "code");
    this.type = "aborted";
    this.name = name ?? "AbortError";
    this.code = code2 ?? "ABORT_ERR";
  }
};
function retimeableSignal(ms, opts) {
  const error = new AbortError(opts == null ? void 0 : opts.errorMessage, opts == null ? void 0 : opts.errorCode, opts == null ? void 0 : opts.errorName);
  const controller = new AbortController();
  const abortHandler = () => {
    controller.abort(error);
  };
  let signal = AbortSignal.timeout(ms);
  signal.addEventListener("abort", abortHandler);
  const retimerSignal = controller.signal;
  retimerSignal.reset = (newMs) => {
    signal == null ? void 0 : signal.removeEventListener("abort", abortHandler);
    signal = AbortSignal.timeout(newMs ?? ms);
    signal.addEventListener("abort", () => {
      controller.abort(error);
    });
  };
  retimerSignal.clear = () => {
    signal == null ? void 0 : signal.removeEventListener("abort", abortHandler);
    signal = void 0;
  };
  return retimerSignal;
}

// ../../node_modules/@libp2p/circuit-relay-v2/dist/src/server/reservation-store.js
var ReservationStore = class {
  constructor(components, init = {}) {
    __publicField(this, "reservations");
    __publicField(this, "maxReservations");
    __publicField(this, "applyDefaultLimit");
    __publicField(this, "reservationTtl");
    __publicField(this, "defaultDurationLimit");
    __publicField(this, "defaultDataLimit");
    __publicField(this, "log");
    this.log = components.logger.forComponent("libp2p:circuit-relay:server:reservation-store");
    this.maxReservations = init.maxReservations ?? DEFAULT_MAX_RESERVATION_STORE_SIZE;
    this.applyDefaultLimit = init.applyDefaultLimit !== false;
    this.reservationTtl = init.reservationTtl ?? DEFAULT_MAX_RESERVATION_TTL;
    this.defaultDurationLimit = init.defaultDurationLimit ?? DEFAULT_DURATION_LIMIT;
    this.defaultDataLimit = init.defaultDataLimit ?? DEFAULT_DATA_LIMIT;
    this.reservations = trackedPeerMap({
      metrics: components.metrics,
      name: "libp2p_circuit_relay_server_reservations_total"
    });
  }
  reserve(peer, addr, limit) {
    let reservation = this.reservations.get(peer);
    if (this.reservations.size >= this.maxReservations && reservation == null) {
      return { status: Status.RESERVATION_REFUSED };
    }
    const expiry = new Date(Date.now() + this.reservationTtl);
    let checkedLimit;
    if (this.applyDefaultLimit) {
      checkedLimit = limit ?? {
        data: this.defaultDataLimit,
        duration: this.defaultDurationLimit
      };
    }
    if (reservation != null) {
      this.log("refreshing reservation for client %p", peer);
      reservation.signal.reset(this.reservationTtl);
    } else {
      this.log("creating new reservation for client %p", peer);
      reservation = {
        addr,
        expiry,
        limit: checkedLimit,
        signal: retimeableSignal(this.reservationTtl)
      };
    }
    this.reservations.set(peer, reservation);
    reservation.signal.addEventListener("abort", () => {
      this.reservations.delete(peer);
    });
    return { status: Status.OK, expire: Math.round(expiry.getTime() / 1e3) };
  }
  removeReservation(peer) {
    this.reservations.delete(peer);
  }
  get(peer) {
    return this.reservations.get(peer);
  }
  clear() {
    this.reservations.clear();
  }
};

// ../../node_modules/@libp2p/circuit-relay-v2/dist/src/server/reservation-voucher.js
var ReservationVoucherRecord = class _ReservationVoucherRecord {
  constructor({ relay, peer, expiration }) {
    __publicField(this, "domain", "libp2p-relay-rsvp");
    __publicField(this, "codec", new Uint8Array([3, 2]));
    __publicField(this, "relay");
    __publicField(this, "peer");
    __publicField(this, "expiration");
    this.relay = relay;
    this.peer = peer;
    this.expiration = expiration;
  }
  marshal() {
    return ReservationVoucher.encode({
      relay: this.relay.toMultihash().bytes,
      peer: this.peer.toMultihash().bytes,
      expiration: BigInt(this.expiration)
    });
  }
  equals(other) {
    if (!(other instanceof _ReservationVoucherRecord)) {
      return false;
    }
    if (!this.peer.equals(other.peer)) {
      return false;
    }
    if (!this.relay.equals(other.relay)) {
      return false;
    }
    if (this.expiration !== other.expiration) {
      return false;
    }
    return true;
  }
};

// ../../node_modules/@libp2p/circuit-relay-v2/dist/src/server/index.js
var defaults = {
  maxOutboundStopStreams: MAX_CONNECTIONS
};
var _a, _b;
var CircuitRelayServer = class extends (_b = TypedEventEmitter, _a = Symbol.toStringTag, _b) {
  /**
   * Creates an instance of Relay
   */
  constructor(components, init = {}) {
    super();
    __publicField(this, "components");
    __publicField(this, "reservationStore");
    __publicField(this, "started");
    __publicField(this, "hopTimeout");
    __publicField(this, "shutdownController");
    __publicField(this, "maxInboundHopStreams");
    __publicField(this, "maxOutboundHopStreams");
    __publicField(this, "maxOutboundStopStreams");
    __publicField(this, "log");
    __publicField(this, _a, "@libp2p/circuit-relay-v2-server");
    this.log = components.logger.forComponent("libp2p:circuit-relay:server");
    this.components = components;
    this.started = false;
    this.hopTimeout = (init == null ? void 0 : init.hopTimeout) ?? DEFAULT_HOP_TIMEOUT;
    this.maxInboundHopStreams = init.maxInboundHopStreams;
    this.maxOutboundHopStreams = init.maxOutboundHopStreams;
    this.maxOutboundStopStreams = init.maxOutboundStopStreams ?? defaults.maxOutboundStopStreams;
    this.reservationStore = new ReservationStore(components, init.reservations);
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
    this.onHop = this.onHop.bind(this);
  }
  isStarted() {
    return this.started;
  }
  /**
   * Start Relay service
   */
  async start() {
    if (this.started) {
      return;
    }
    await this.components.registrar.handle(RELAY_V2_HOP_CODEC, this.onHop, {
      maxInboundStreams: this.maxInboundHopStreams,
      maxOutboundStreams: this.maxOutboundHopStreams,
      runOnLimitedConnection: true
    });
    this.started = true;
  }
  /**
   * Stop Relay service
   */
  async stop() {
    this.reservationStore.clear();
    this.shutdownController.abort();
    await this.components.registrar.unhandle(RELAY_V2_HOP_CODEC);
    this.started = false;
  }
  async onHop(stream, connection) {
    this.log("received circuit v2 hop protocol stream from %p", connection.remotePeer);
    const signal = AbortSignal.timeout(this.hopTimeout);
    setMaxListeners(Infinity, signal);
    const options = {
      signal
    };
    const pbstr = pbStream(stream);
    try {
      const request = await pbstr.pb(HopMessage).read(options);
      if ((request == null ? void 0 : request.type) == null) {
        throw new Error("request was invalid, could not read from stream");
      }
      this.log("received", request.type);
      await this.handleHopProtocol({
        connection,
        stream: pbstr,
        request
      }, options);
    } catch (err) {
      this.log.error("error while handling hop - %e", err);
      await pbstr.pb(HopMessage).write({
        type: HopMessage.Type.STATUS,
        status: Status.MALFORMED_MESSAGE
      }, options);
      stream.abort(err);
    }
  }
  async handleHopProtocol({ stream, request, connection }, options) {
    this.log("received hop message");
    switch (request.type) {
      case HopMessage.Type.RESERVE:
        await this.handleReserve({ stream, request, connection }, options);
        break;
      case HopMessage.Type.CONNECT:
        await this.handleConnect({ stream, request, connection }, options);
        break;
      default: {
        this.log.error("invalid hop request type %s via peer %p", request.type, connection.remotePeer);
        await stream.pb(HopMessage).write({ type: HopMessage.Type.STATUS, status: Status.UNEXPECTED_MESSAGE });
      }
    }
  }
  async handleReserve({ stream, connection }, options) {
    var _a3, _b3, _c2;
    const hopstr = stream.pb(HopMessage);
    this.log("hop reserve request from %p", connection.remotePeer);
    if (Circuit.exactMatch(connection.remoteAddr)) {
      this.log.error("relay reservation over circuit connection denied for peer: %p", connection.remotePeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, options);
      return;
    }
    if (await ((_b3 = (_a3 = this.components.connectionGater).denyInboundRelayReservation) == null ? void 0 : _b3.call(_a3, connection.remotePeer)) === true) {
      this.log.error("reservation for %p denied by connection gater", connection.remotePeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, options);
      return;
    }
    const result = this.reservationStore.reserve(connection.remotePeer, connection.remoteAddr);
    try {
      if (result.status !== Status.OK) {
        await hopstr.write({ type: HopMessage.Type.STATUS, status: result.status }, options);
        return;
      }
      if (result.expire != null) {
        const ttl = result.expire * 1e3 - Date.now();
        await this.components.peerStore.merge(connection.remotePeer, {
          tags: {
            [RELAY_SOURCE_TAG]: { value: 1, ttl }
          }
        }, options);
      }
      await hopstr.write({
        type: HopMessage.Type.STATUS,
        status: Status.OK,
        reservation: await this.makeReservation(connection.remotePeer, BigInt(result.expire ?? 0)),
        limit: (_c2 = this.reservationStore.get(connection.remotePeer)) == null ? void 0 : _c2.limit
      }, options);
      this.log("sent confirmation response to %s", connection.remotePeer);
      await hopstr.unwrap().unwrap().close(options);
    } catch (err) {
      this.log.error("failed to send confirmation response to %p - %e", connection.remotePeer, err);
      this.reservationStore.removeReservation(connection.remotePeer);
      try {
        await this.components.peerStore.merge(connection.remotePeer, {
          tags: {
            [RELAY_SOURCE_TAG]: void 0
          }
        }, options);
      } catch (err2) {
        this.log.error("failed to untag relay source peer %p - %e", connection.remotePeer, err2);
      }
    }
  }
  async makeReservation(remotePeer, expire) {
    const addrs = [];
    for (const relayAddr of this.components.addressManager.getAddresses()) {
      if (relayAddr.toString().includes("/p2p-circuit")) {
        continue;
      }
      addrs.push(relayAddr.bytes);
    }
    const envelope = await RecordEnvelope.seal(new ReservationVoucherRecord({
      peer: remotePeer,
      relay: this.components.peerId,
      expiration: expire
    }), this.components.privateKey);
    return {
      addrs,
      expire,
      voucher: {
        publicKey: publicKeyToProtobuf(envelope.publicKey),
        payloadType: envelope.payloadType,
        payload: {
          peer: remotePeer.toMultihash().bytes,
          relay: this.components.peerId.toMultihash().bytes,
          expiration: expire
        },
        signature: envelope.signature
      }
    };
  }
  async handleConnect({ stream, request, connection }, options) {
    var _a3, _b3;
    const hopstr = stream.pb(HopMessage);
    if (Circuit.matches(connection.remoteAddr)) {
      this.log.error("relay reservation over circuit connection denied for peer: %p", connection.remotePeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, options);
      return;
    }
    this.log("hop connect request from %p", connection.remotePeer);
    let dstPeer;
    try {
      if (request.peer == null) {
        this.log.error("no peer info in hop connect request");
        throw new Error("no peer info in request");
      }
      request.peer.addrs.forEach(multiaddr);
      dstPeer = peerIdFromMultihash(decode(request.peer.id));
    } catch (err) {
      this.log.error("invalid hop connect request via peer %p - %e", connection.remotePeer, err);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, options);
      return;
    }
    const reservation = this.reservationStore.get(dstPeer);
    if (reservation == null) {
      this.log.error("hop connect denied for destination peer %p not having a reservation for %p with status %s", dstPeer, connection.remotePeer, Status.NO_RESERVATION);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.NO_RESERVATION }, options);
      return;
    }
    if (await ((_b3 = (_a3 = this.components.connectionGater).denyOutboundRelayedConnection) == null ? void 0 : _b3.call(_a3, connection.remotePeer, dstPeer)) === true) {
      this.log.error("hop connect for %p to %p denied by connection gater", connection.remotePeer, dstPeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, options);
      return;
    }
    const connections = this.components.connectionManager.getConnections(dstPeer);
    if (connections.length === 0) {
      this.log("hop connect denied for destination peer %p not having a connection for %p as there is no destination connection", dstPeer, connection.remotePeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.NO_RESERVATION }, options);
      return;
    }
    const destinationConnection = connections[0];
    const destinationStream = await this.stopHop({
      connection: destinationConnection,
      request: {
        type: StopMessage.Type.CONNECT,
        peer: {
          id: connection.remotePeer.toMultihash().bytes,
          addrs: []
        },
        limit: reservation == null ? void 0 : reservation.limit
      }
    }, options);
    if (destinationStream == null) {
      this.log.error("failed to open stream to destination peer %p", destinationConnection == null ? void 0 : destinationConnection.remotePeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.CONNECTION_FAILED }, options);
      return;
    }
    await hopstr.write({
      type: HopMessage.Type.STATUS,
      status: Status.OK,
      limit: reservation == null ? void 0 : reservation.limit
    }, options);
    this.log("connection from %p to %p established - merging streams", connection.remotePeer, dstPeer);
    createLimitedRelay(stream.unwrap(), destinationStream, this.shutdownController.signal, reservation, {
      log: this.log
    });
  }
  /**
   * Send a STOP request to the target peer that the dialing peer wants to contact
   */
  async stopHop({ connection, request }, options) {
    this.log("starting circuit relay v2 stop request to %s", connection.remotePeer);
    const stream = await connection.newStream(RELAY_V2_STOP_CODEC, {
      maxOutboundStreams: this.maxOutboundStopStreams,
      runOnLimitedConnection: true,
      ...options
    });
    const pbstr = pbStream(stream);
    const stopstr = pbstr.pb(StopMessage);
    await stopstr.write(request, options);
    let response;
    try {
      response = await stopstr.read(options);
    } catch (err) {
      this.log.error("error parsing stop message response from %p - %e", connection.remotePeer, err);
    }
    if (response == null) {
      this.log.error("could not read response from %p", connection.remotePeer);
      await stream.close(options);
      return;
    }
    if (response.status === Status.OK) {
      this.log("stop request to %p was successful", connection.remotePeer);
      return pbstr.unwrap();
    }
    this.log("stop request failed with code %d", response.status);
    await stream.close(options);
  }
  get reservations() {
    return this.reservationStore.reservations;
  }
};

// ../../node_modules/@libp2p/circuit-relay-v2/dist/src/transport/discovery.js
var RelayDiscovery = class extends TypedEventEmitter {
  constructor(components, init = {}) {
    super();
    __publicField(this, "components");
    __publicField(this, "started");
    __publicField(this, "running");
    __publicField(this, "topologyId");
    __publicField(this, "log");
    __publicField(this, "discoveryController");
    __publicField(this, "filter");
    __publicField(this, "queue");
    this.log = components.logger.forComponent("libp2p:circuit-relay:discover-relays");
    this.components = components;
    this.started = false;
    this.running = false;
    this.filter = init.filter;
    this.discoveryController = new AbortController();
    setMaxListeners(Infinity, this.discoveryController.signal);
    this.dialPeer = this.dialPeer.bind(this);
    this.onPeer = this.onPeer.bind(this);
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.topologyId = await this.components.registrar.register(RELAY_V2_HOP_CODEC, {
      filter: this.filter,
      onConnect: (peerId) => {
        var _a3, _b3;
        this.log.trace("discovered relay %p queue (length: %d, active %d)", peerId, (_a3 = this.queue) == null ? void 0 : _a3.size, (_b3 = this.queue) == null ? void 0 : _b3.running);
        this.safeDispatchEvent("relay:discover", { detail: peerId });
      }
    });
    this.started = true;
  }
  stop() {
    if (this.topologyId != null) {
      this.components.registrar.unregister(this.topologyId);
    }
    if (this.running) {
      this.stopDiscovery();
    }
    this.started = false;
  }
  /**
   * Try to listen on available hop relay connections.
   * The following order will happen while we do not have enough relays:
   *
   * 1. Check the metadata store for known relays, try to listen on the ones we are already connected to
   * 2. Dial and try to listen on the peers we know that support hop but are not connected
   * 3. Search the network - this requires a peer routing implementation to be configured but will fail gracefully
   * 4. Dial any peers discovered - this covers when no peer routing implementation has been configured but some peer discovery mechanism is also present
   */
  startDiscovery() {
    if (this.running) {
      return;
    }
    this.log("start discovery");
    this.running = true;
    this.discoveryController = new AbortController();
    setMaxListeners(Infinity, this.discoveryController.signal);
    this.components.events.addEventListener("peer:discovery", this.onPeer);
    Promise.resolve().then(async () => {
      var _a3;
      this.log("searching peer store for relays");
      const peers = await this.components.peerStore.all({
        filters: [
          // filter by a list of peers supporting RELAY_V2_HOP and ones we are not listening on
          (peer) => {
            return peer.protocols.includes(RELAY_V2_HOP_CODEC);
          }
        ],
        orders: [
          // randomize
          () => Math.random() < 0.5 ? 1 : -1,
          // prefer peers we've connected to in the past
          (a, b) => {
            const lastDialA = getLastDial(a);
            const lastDialB = getLastDial(b);
            if (lastDialA > lastDialB) {
              return -1;
            }
            if (lastDialB > lastDialA) {
              return 1;
            }
            return 0;
          }
        ]
      });
      for (const peer of peers) {
        this.log.trace("found relay peer %p in peer store", peer.id);
        this.safeDispatchEvent("relay:discover", { detail: peer.id });
      }
      this.log("found %d relay peers in peer store", peers.length);
      const queue = this.queue = new PeerQueue({
        concurrency: 5
      });
      this.log("start random walk");
      for await (const peer of this.components.randomWalk.walk({ signal: this.discoveryController.signal })) {
        this.log.trace("found random peer %p", peer.id);
        if (queue.has(peer.id)) {
          this.log.trace("random peer %p was already in queue", peer.id);
          continue;
        }
        if (((_a3 = this.components.connectionManager.getConnections(peer.id)) == null ? void 0 : _a3.length) > 0) {
          this.log.trace("random peer %p was already connected", peer.id);
          continue;
        }
        if (!await this.components.connectionManager.isDialable(peer.multiaddrs)) {
          this.log.trace("random peer %p was not dialable", peer.id, peer.multiaddrs.map((ma) => ma.toString()));
          continue;
        }
        if (queue.queued > 10) {
          this.log.trace("wait for space in queue for %p", peer.id);
          await queue.onSizeLessThan(10, {
            signal: this.discoveryController.signal
          });
        }
        this.log("adding random peer %p to dial queue (length: %d, active %d)", peer.id, queue.size, queue.running);
        queue.add(this.dialPeer, {
          peerId: peer.id,
          signal: this.discoveryController.signal
        }).catch((err) => {
          this.log.error("error opening connection to random peer %p - %e", peer.id, err);
        });
      }
      this.log("stop random walk");
      await queue.onIdle();
    }).catch((err) => {
      if (!this.discoveryController.signal.aborted) {
        this.log.error("failed when finding relays on the network - %e", err);
      }
    });
  }
  stopDiscovery() {
    var _a3, _b3;
    this.log("stop discovery");
    this.running = false;
    (_a3 = this.discoveryController) == null ? void 0 : _a3.abort();
    (_b3 = this.queue) == null ? void 0 : _b3.clear();
    this.components.events.removeEventListener("peer:discovery", this.onPeer);
  }
  onPeer(evt) {
    this.log.trace("maybe dialing discovered peer %p", evt.detail.id);
    this.maybeDialPeer(evt).catch((err) => {
      this.log.trace("error dialing discovered peer %p - %e", evt.detail.id, err);
    });
  }
  async maybeDialPeer(evt) {
    var _a3, _b3;
    if (this.queue == null) {
      return;
    }
    const peerId = evt.detail.id;
    const multiaddrs = evt.detail.multiaddrs;
    if (this.queue.has(peerId)) {
      this.log.trace("random peer %p was already in queue", peerId);
      return;
    }
    if (((_a3 = this.components.connectionManager.getConnections(peerId)) == null ? void 0 : _a3.length) > 0) {
      this.log.trace("random peer %p was already connected", peerId);
      return;
    }
    if (!await this.components.connectionManager.isDialable(multiaddrs)) {
      this.log.trace("random peer %p was not dialable", peerId);
      return;
    }
    (_b3 = this.queue) == null ? void 0 : _b3.add(this.dialPeer, {
      peerId: evt.detail.id,
      signal: this.discoveryController.signal
    }).catch((err) => {
      this.log.error("error opening connection to discovered peer %p - %e", evt.detail.id, err);
    });
  }
  async dialPeer({ peerId, signal }) {
    const combinedSignal = anySignal([AbortSignal.timeout(5e3), signal]);
    setMaxListeners(Infinity, combinedSignal);
    try {
      await this.components.connectionManager.openConnection(peerId, {
        signal: combinedSignal
      });
    } finally {
      combinedSignal.clear();
    }
  }
};
function getLastDial(peer) {
  const lastDial = peer.metadata.get("last-dial-success");
  if (lastDial == null) {
    return 0;
  }
  return new Date(toString(lastDial)).getTime();
}

// ../../node_modules/@libp2p/circuit-relay-v2/dist/src/transport/listener.js
var CircuitRelayTransportListener = class extends TypedEventEmitter {
  constructor(components, init = {}) {
    super();
    __publicField(this, "connectionManager");
    __publicField(this, "addressManager");
    __publicField(this, "reservationStore");
    __publicField(this, "listeningAddrs");
    __publicField(this, "log");
    __publicField(this, "listenTimeout");
    __publicField(this, "reservationId");
    __publicField(this, "relay");
    __publicField(this, "_onRemoveRelayPeer", (evt) => {
      var _a3, _b3;
      this.log("relay removed %p our relay %p", evt.detail.relay, this.relay, (_a3 = this.relay) == null ? void 0 : _a3.equals(evt.detail.relay));
      if (((_b3 = this.relay) == null ? void 0 : _b3.equals(evt.detail.relay)) !== true) {
        return;
      }
      this.log("relay peer removed %p", evt.detail.relay);
      this.listeningAddrs.forEach((ma) => {
        this.addressManager.removeObservedAddr(ma);
      });
      this.listeningAddrs = [];
      this.safeDispatchEvent("listening");
    });
    __publicField(this, "_onAddRelayPeer", (evt) => {
      const { details } = evt.detail;
      if (details.type === "configured") {
        return;
      }
      if (details.id !== this.reservationId) {
        return;
      }
      this.addedRelay(evt.detail);
    });
    this.log = components.logger.forComponent("libp2p:circuit-relay:transport:listener");
    this.connectionManager = components.connectionManager;
    this.addressManager = components.addressManager;
    this.reservationStore = components.reservationStore;
    this.listeningAddrs = [];
    this.listenTimeout = init.listenTimeout ?? DEFAULT_RESERVATION_COMPLETION_TIMEOUT;
    this.reservationStore.addEventListener("relay:removed", this._onRemoveRelayPeer);
    this.reservationStore.addEventListener("relay:created-reservation", this._onAddRelayPeer);
  }
  async listen(addr) {
    if (CircuitSearch.exactMatch(addr)) {
      this.log("searching for circuit relay servers");
      this.reservationId = this.reservationStore.reserveRelay();
    } else if (CircuitListen.exactMatch(addr)) {
      this.log("listen on specific relay server %a", addr);
      const signal = AbortSignal.timeout(this.listenTimeout);
      setMaxListeners(Infinity, signal);
      const relayAddr = addr.decapsulate("/p2p-circuit");
      const relayConn = await this.connectionManager.openConnection(relayAddr, {
        signal
      });
      if (!this.reservationStore.hasReservation(relayConn.remotePeer)) {
        this.log("making reservation on peer %p", relayConn.remotePeer);
        const reservation = await this.reservationStore.addRelay(relayConn.remotePeer, "configured");
        this.addedRelay(reservation);
      }
    } else {
      throw new ListenError(`Could not listen on p2p-circuit address "${addr}"`);
    }
  }
  getAddrs() {
    return [...this.listeningAddrs.values()].flat();
  }
  updateAnnounceAddrs() {
  }
  async close() {
    this.reservationStore.cancelReservations();
    this.listeningAddrs = [];
    this.reservationStore.removeEventListener("relay:removed", this._onRemoveRelayPeer);
    queueMicrotask(() => {
      this.safeDispatchEvent("close");
    });
  }
  addedRelay(reservation) {
    this.log("relay peer added %p", reservation.relay);
    this.relay = reservation.relay;
    this.listeningAddrs = reservation.details.reservation.addrs.map((buf) => multiaddr(buf).encapsulate("/p2p-circuit"));
    this.listeningAddrs.forEach((ma) => {
      this.addressManager.confirmObservedAddr(ma, {
        type: "transport"
      });
    });
    queueMicrotask(() => {
      this.safeDispatchEvent("listening");
    });
  }
};
function createListener(options) {
  return new CircuitRelayTransportListener(options);
}

// ../../node_modules/@libp2p/circuit-relay-v2/node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// ../../node_modules/@libp2p/circuit-relay-v2/node_modules/nanoid/index.browser.js
var nanoid = (size = 21) => {
  let id = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size |= 0));
  while (size--) {
    id += urlAlphabet[bytes[size] & 63];
  }
  return id;
};

// ../../node_modules/@libp2p/circuit-relay-v2/dist/src/transport/reservation-store.js
var REFRESH_WINDOW = 60 * 1e3 * 10;
var REFRESH_TIMEOUT = 60 * 1e3 * 5;
var REFRESH_TIMEOUT_MIN = 30 * 1e3;
var _ReservationStore_instances, createReservation_fn, removeReservation_fn, checkReservationCount_fn;
var ReservationStore2 = class extends TypedEventEmitter {
  constructor(components, init) {
    super();
    __privateAdd(this, _ReservationStore_instances);
    __publicField(this, "peerId");
    __publicField(this, "connectionManager");
    __publicField(this, "peerStore");
    __publicField(this, "events");
    __publicField(this, "reserveQueue");
    __publicField(this, "reservations");
    __publicField(this, "pendingReservations");
    __publicField(this, "maxReservationQueueLength");
    __publicField(this, "reservationCompletionTimeout");
    __publicField(this, "started");
    __publicField(this, "log");
    __publicField(this, "relayFilter");
    this.log = components.logger.forComponent("libp2p:circuit-relay:transport:reservation-store");
    this.peerId = components.peerId;
    this.connectionManager = components.connectionManager;
    this.peerStore = components.peerStore;
    this.events = components.events;
    this.reservations = new PeerMap();
    this.pendingReservations = [];
    this.maxReservationQueueLength = (init == null ? void 0 : init.maxReservationQueueLength) ?? DEFAULT_MAX_RESERVATION_QUEUE_LENGTH;
    this.reservationCompletionTimeout = (init == null ? void 0 : init.reservationCompletionTimeout) ?? DEFAULT_RESERVATION_COMPLETION_TIMEOUT;
    this.started = false;
    this.relayFilter = createScalableCuckooFilter(100);
    this.reserveQueue = new PeerQueue({
      concurrency: (init == null ? void 0 : init.reservationConcurrency) ?? DEFAULT_RESERVATION_CONCURRENCY,
      metricName: "libp2p_relay_reservation_queue",
      metrics: components.metrics
    });
    this.events.addEventListener("connection:close", (evt) => {
      const reservation = [...this.reservations.values()].find((reservation2) => reservation2.connection === evt.detail.id);
      if (reservation == null) {
        return;
      }
      __privateMethod(this, _ReservationStore_instances, removeReservation_fn).call(this, evt.detail.remotePeer).catch((err) => {
        this.log("could not remove relay %p - %e", evt.detail, err);
      });
    });
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  afterStart() {
    void Promise.resolve().then(async () => {
      const relayPeers = await this.peerStore.all({
        filters: [(peer) => {
          return peer.tags.has(KEEP_ALIVE_TAG);
        }]
      });
      this.log("removing tag from %d old relays", relayPeers.length);
      await Promise.all(relayPeers.map(async (peer) => {
        await this.peerStore.merge(peer.id, {
          tags: {
            [KEEP_ALIVE_TAG]: void 0
          }
        });
      }));
      this.log("redialing %d old relays", relayPeers.length);
      await Promise.all(relayPeers.map(async (peer) => this.addRelay(peer.id, "discovered")));
      __privateMethod(this, _ReservationStore_instances, checkReservationCount_fn).call(this);
    }).catch((err) => {
      this.log.error("failed to clean up and redial old relays during afterStart - %e", err);
    });
  }
  stop() {
    this.reserveQueue.clear();
    this.reservations.forEach(({ timeout }) => {
      clearTimeout(timeout);
    });
    this.reservations.clear();
    this.started = false;
  }
  reserveRelay() {
    const id = nanoid();
    this.pendingReservations.push(id);
    __privateMethod(this, _ReservationStore_instances, checkReservationCount_fn).call(this);
    return id;
  }
  /**
   * If the number of current relays is beneath the configured `maxReservations`
   * value, and the passed peer id is not our own, and we have a non-relayed
   * connection to the remote, and the remote peer speaks the hop protocol, try
   * to reserve a slot on the remote peer
   */
  async addRelay(peerId, type) {
    if (this.peerId.equals(peerId)) {
      this.log.trace("not trying to use self as relay");
      throw new ListenError("Cannot use self as relay");
    }
    if (this.reserveQueue.size > this.maxReservationQueueLength) {
      throw new RelayQueueFullError("The reservation queue is full");
    }
    const existingJob = this.reserveQueue.find(peerId);
    if (existingJob != null) {
      this.log.trace("potential relay peer %p is already in the reservation queue", peerId);
      return existingJob.join();
    }
    if (this.relayFilter.has(peerId.toMultihash().bytes)) {
      throw new ListenError("The relay was previously invalid");
    }
    this.log.trace("try to reserve relay slot with %p", peerId);
    return this.reserveQueue.add(async () => {
      const start2 = Date.now();
      try {
        const existingReservation = this.reservations.get(peerId);
        if (existingReservation != null) {
          const connections = this.connectionManager.getConnections(peerId);
          let connected = false;
          if (connections.length === 0) {
            this.log("already have relay reservation with %p but we are no longer connected", peerId);
          }
          if (connections.map((conn) => conn.id).includes(existingReservation.connection)) {
            this.log("already have relay reservation with %p and the original connection is still open", peerId);
            connected = true;
          }
          if (connected && getExpirationMilliseconds(existingReservation.reservation.expire) > REFRESH_WINDOW) {
            this.log("already have relay reservation with %p but we are still connected and it does not expire soon", peerId);
            return {
              relay: peerId,
              details: existingReservation
            };
          }
          await __privateMethod(this, _ReservationStore_instances, removeReservation_fn).call(this, peerId);
        }
        if (type === "discovered" && this.pendingReservations.length === 0) {
          throw new HadEnoughRelaysError("Not making reservation on discovered relay because we do not need any more relays");
        }
        const signal = AbortSignal.timeout(this.reservationCompletionTimeout);
        setMaxListeners(Infinity, signal);
        const connection = await this.connectionManager.openConnection(peerId, {
          signal
        });
        if (Circuit.matches(connection.remoteAddr)) {
          throw new DoubleRelayError("not creating reservation over relayed connection");
        }
        const reservation = await __privateMethod(this, _ReservationStore_instances, createReservation_fn).call(this, connection, {
          signal
        });
        const expiration = getExpirationMilliseconds(reservation.expire);
        this.log("created reservation on relay peer %p, expiry date is %s", peerId, new Date(Date.now() + expiration).toString());
        const timeoutDuration = Math.min(Math.max(expiration - REFRESH_TIMEOUT, REFRESH_TIMEOUT_MIN), Math.pow(2, 31) - 1);
        const timeout = setTimeout(() => {
          this.log("refresh reservation to relay %p", peerId);
          this.addRelay(peerId, type).catch(async (err) => {
            this.log.error("could not refresh reservation to relay %p - %e", peerId, err);
            await __privateMethod(this, _ReservationStore_instances, removeReservation_fn).call(this, peerId);
          }).catch((err) => {
            this.log.error("could not remove expired reservation to relay %p - %e", peerId, err);
          });
        }, timeoutDuration);
        let res;
        if (type === "discovered") {
          const id = this.pendingReservations.pop();
          if (id == null) {
            throw new HadEnoughRelaysError("Made reservation on relay but did not need any more discovered relays");
          }
          res = {
            timeout,
            reservation,
            type,
            connection: connection.id,
            id
          };
        } else {
          res = {
            timeout,
            reservation,
            type,
            connection: connection.id
          };
        }
        this.reservations.set(peerId, res);
        await this.peerStore.merge(peerId, {
          tags: {
            [KEEP_ALIVE_TAG]: {
              value: 1,
              ttl: expiration
            }
          }
        });
        __privateMethod(this, _ReservationStore_instances, checkReservationCount_fn).call(this);
        const result = {
          relay: peerId,
          details: res
        };
        this.safeDispatchEvent("relay:created-reservation", {
          detail: result
        });
        return result;
      } catch (err) {
        if (!(type === "discovered" && err.name === "HadEnoughRelaysError")) {
          this.log.error("could not reserve slot on %p after %dms - %e", peerId, Date.now() - start2, err);
        }
        if (err.name === "DialError" || err.name === "UnsupportedProtocolError") {
          this.relayFilter.add(peerId.toMultihash().bytes);
        }
        __privateMethod(this, _ReservationStore_instances, removeReservation_fn).call(this, peerId).catch((err2) => {
          this.log.error("could not remove reservation on %p after reserving slot failed - %e", peerId, err2);
        });
        throw err;
      }
    }, {
      peerId
    });
  }
  hasReservation(peerId) {
    return this.reservations.has(peerId);
  }
  getReservation(peerId) {
    var _a3;
    return (_a3 = this.reservations.get(peerId)) == null ? void 0 : _a3.reservation;
  }
  reservationCount(type) {
    if (type == null) {
      return this.reservations.size;
    }
    return [...this.reservations.values()].reduce((acc, curr) => {
      if (curr.type === type) {
        acc++;
      }
      return acc;
    }, 0);
  }
  cancelReservations() {
    [...this.reservations.values()].forEach((reservation) => {
      clearTimeout(reservation.timeout);
    });
    this.reservations.clear();
  }
};
_ReservationStore_instances = new WeakSet();
createReservation_fn = async function(connection, options) {
  var _a3;
  (_a3 = options.signal) == null ? void 0 : _a3.throwIfAborted();
  this.log("requesting reservation from %p", connection.remotePeer);
  const stream = await connection.newStream(RELAY_V2_HOP_CODEC, options);
  const pbstr = pbStream(stream);
  const hopstr = pbstr.pb(HopMessage);
  this.log.trace("send RESERVE to %p", connection.remotePeer);
  await hopstr.write({ type: HopMessage.Type.RESERVE }, options);
  let response;
  try {
    this.log.trace("reading response from %p", connection.remotePeer);
    response = await hopstr.read(options);
  } catch (err) {
    stream.abort(err);
    throw err;
  } finally {
    if (stream.status !== "closed") {
      await stream.close(options);
    }
  }
  this.log.trace("read response %s", response.status);
  if (response.status === Status.OK && response.reservation != null) {
    const addresses = /* @__PURE__ */ new Set();
    addresses.add(connection.remoteAddr.toString());
    for (const buf of response.reservation.addrs) {
      let ma = multiaddr(buf);
      if (ma.getComponents().find((c) => c.code === CODE_P2P) == null) {
        ma = ma.encapsulate(`/p2p/${connection.remotePeer}`);
      }
      ma = multiaddr(ma.toString().replace(`/p2p/${connection.remotePeer}/p2p/${connection.remotePeer}`, `/p2p/${connection.remotePeer}`));
      addresses.add(ma.toString());
    }
    response.reservation.addrs = [...addresses].map((str) => multiaddr(str).bytes);
    return response.reservation;
  }
  const errMsg = `reservation failed with status ${response.status ?? "undefined"}`;
  this.log.error(errMsg);
  throw new Error(errMsg);
};
removeReservation_fn = async function(peerId) {
  const reservation = this.reservations.get(peerId);
  if (reservation == null) {
    return;
  }
  this.log("removing relay reservation with %p from local store", peerId);
  clearTimeout(reservation.timeout);
  this.reservations.delete(peerId);
  if (reservation.type === "discovered") {
    this.pendingReservations.push(reservation.id);
  }
  await this.peerStore.merge(peerId, {
    tags: {
      [KEEP_ALIVE_TAG]: void 0
    }
  });
  this.safeDispatchEvent("relay:removed", {
    detail: {
      relay: peerId,
      details: reservation
    }
  });
  __privateMethod(this, _ReservationStore_instances, checkReservationCount_fn).call(this);
};
checkReservationCount_fn = function() {
  if (this.pendingReservations.length === 0) {
    this.log.trace("have discovered enough relays");
    this.reserveQueue.clear();
    this.safeDispatchEvent("relay:found-enough-relays");
    return;
  }
  this.relayFilter = createScalableCuckooFilter(100);
  this.log("not discovered enough relays %d/%d", this.reservations.size, this.pendingReservations.length);
  this.safeDispatchEvent("relay:not-enough-relays");
};

// ../../node_modules/@libp2p/circuit-relay-v2/dist/src/transport/stream-to-conn.js
var StreamMultiaddrConnection = class extends AbstractMultiaddrConnection {
  constructor(init) {
    super({
      ...init,
      direction: init.stream.direction
    });
    __publicField(this, "stream");
    __publicField(this, "init");
    this.init = init;
    this.stream = init.stream;
    this.stream.addEventListener("close", (evt) => {
      this.onTransportClosed(evt.error);
    });
    this.stream.addEventListener("remoteCloseWrite", (evt) => {
      this.onRemoteCloseWrite();
      this.close().catch((err) => {
        this.abort(err);
      });
    });
    this.stream.addEventListener("message", (evt) => {
      var _a3;
      (_a3 = init.onDataRead) == null ? void 0 : _a3.call(init, evt.data);
      this.onData(evt.data);
    });
    this.stream.addEventListener("drain", () => {
      this.safeDispatchEvent("drain");
    });
  }
  sendData(data) {
    var _a3, _b3;
    (_b3 = (_a3 = this.init).onDataWrite) == null ? void 0 : _b3.call(_a3, data);
    return {
      sentBytes: data.byteLength,
      canSendMore: this.stream.send(data)
    };
  }
  async sendClose(options) {
    await this.stream.close(options);
  }
  sendReset() {
    this.stream.abort(new Error("An error occurred"));
  }
  sendPause() {
    this.stream.pause();
  }
  sendResume() {
    this.stream.resume();
  }
};
function streamToMaConnection(init) {
  return new StreamMultiaddrConnection(init);
}

// ../../node_modules/@libp2p/circuit-relay-v2/dist/src/transport/index.js
var isValidStop = (request) => {
  if (request.peer == null) {
    return false;
  }
  try {
    request.peer.addrs.forEach(multiaddr);
  } catch {
    return false;
  }
  return true;
};
var defaults2 = {
  maxInboundStopStreams: MAX_CONNECTIONS,
  maxOutboundStopStreams: MAX_CONNECTIONS,
  stopTimeout: 3e4
};
var _a2, _b2, _c, _d;
var CircuitRelayTransport = class {
  constructor(components, init = {}) {
    __publicField(this, "components");
    __publicField(this, "discovery");
    __publicField(this, "reservationStore");
    __publicField(this, "maxInboundStopStreams");
    __publicField(this, "maxOutboundStopStreams");
    __publicField(this, "started");
    __publicField(this, "log");
    __publicField(this, "shutdownController");
    __publicField(this, _d, "@libp2p/circuit-relay-v2-transport");
    __publicField(this, _c, [
      "@libp2p/transport",
      "@libp2p/circuit-relay-v2-transport"
    ]);
    __publicField(this, _a2, true);
    this.components = components;
    this.log = components.logger.forComponent("libp2p:circuit-relay:transport");
    this.maxInboundStopStreams = init.maxInboundStopStreams ?? defaults2.maxInboundStopStreams;
    this.maxOutboundStopStreams = init.maxOutboundStopStreams ?? defaults2.maxOutboundStopStreams;
    this.shutdownController = new AbortController();
    this.discovery = new RelayDiscovery(components, {
      filter: init.discoveryFilter ?? peerFilter(DEFAULT_DISCOVERY_FILTER_SIZE, DEFAULT_DISCOVERY_FILTER_ERROR_RATE)
    });
    this.discovery.addEventListener("relay:discover", (evt) => {
      this.reservationStore.addRelay(evt.detail, "discovered").catch((err) => {
        if (err.name !== "HadEnoughRelaysError" && err.name !== "RelayQueueFullError") {
          this.log.error("could not add discovered relay %p - %e", evt.detail, err);
        }
      });
    });
    this.reservationStore = new ReservationStore2(components, init);
    this.reservationStore.addEventListener("relay:not-enough-relays", () => {
      var _a3;
      (_a3 = this.discovery) == null ? void 0 : _a3.startDiscovery();
    });
    this.reservationStore.addEventListener("relay:found-enough-relays", () => {
      var _a3;
      (_a3 = this.discovery) == null ? void 0 : _a3.stopDiscovery();
    });
    this.started = false;
    this.onStop = this.onStop.bind(this);
  }
  get [(_d = Symbol.toStringTag, _c = serviceCapabilities, _b2 = serviceDependencies, _a2 = transportSymbol, _b2)]() {
    if (this.discovery != null) {
      return [
        "@libp2p/identify"
      ];
    }
    return [];
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
    await this.components.registrar.handle(RELAY_V2_STOP_CODEC, this.onStop, {
      maxInboundStreams: this.maxInboundStopStreams,
      maxOutboundStreams: this.maxOutboundStopStreams,
      runOnLimitedConnection: true
    });
    await start(this.discovery, this.reservationStore);
    this.started = true;
  }
  async stop() {
    this.shutdownController.abort();
    await stop(this.discovery, this.reservationStore);
    await this.components.registrar.unhandle(RELAY_V2_STOP_CODEC);
    this.started = false;
  }
  /**
   * Dial a peer over a relay
   */
  async dial(ma, options) {
    var _a3, _b3, _c2, _d2, _e, _f, _g, _h;
    const addrs = ma.toString().split("/p2p-circuit");
    const relayAddr = multiaddr(addrs[0]);
    const destinationAddr = multiaddr(addrs[addrs.length - 1]);
    const relayId = (_a3 = relayAddr.getComponents().find((c) => c.code === CODE_P2P)) == null ? void 0 : _a3.value;
    const destinationId = (_b3 = destinationAddr.getComponents().find((c) => c.code === CODE_P2P)) == null ? void 0 : _b3.value;
    if (relayId == null || destinationId == null) {
      const errMsg = `ircuit relay dial to ${ma.toString()} failed as address did not have both relay and destination PeerIDs`;
      this.log.error(`c${errMsg}`);
      throw new DialError(`C${errMsg}`);
    }
    const relayPeer = peerIdFromString(relayId);
    const destinationPeer = peerIdFromString(destinationId);
    const relayConnections = this.components.connectionManager.getConnections(relayPeer);
    let relayConnection = relayConnections[0];
    if (relayConnection == null) {
      await this.components.peerStore.merge(relayPeer, {
        multiaddrs: [relayAddr]
      });
      (_c2 = options.onProgress) == null ? void 0 : _c2.call(options, new CustomProgressEvent("circuit-relay:open-connection"));
      relayConnection = await this.components.connectionManager.openConnection(relayPeer, options);
    } else {
      (_d2 = options.onProgress) == null ? void 0 : _d2.call(options, new CustomProgressEvent("circuit-relay:reuse-connection"));
    }
    let stream;
    try {
      (_e = options.onProgress) == null ? void 0 : _e.call(options, new CustomProgressEvent("circuit-relay:open-hop-stream"));
      stream = await relayConnection.newStream(RELAY_V2_HOP_CODEC, options);
      const hopstr = pbStream(stream).pb(HopMessage);
      (_f = options.onProgress) == null ? void 0 : _f.call(options, new CustomProgressEvent("circuit-relay:write-connect-message"));
      await hopstr.write({
        type: HopMessage.Type.CONNECT,
        peer: {
          id: destinationPeer.toMultihash().bytes,
          addrs: [multiaddr(destinationAddr).bytes]
        }
      }, options);
      (_g = options.onProgress) == null ? void 0 : _g.call(options, new CustomProgressEvent("circuit-relay:read-connect-response"));
      const status = await hopstr.read(options);
      if (status.status !== Status.OK) {
        throw new InvalidMessageError(`failed to connect via relay with status ${((_h = status == null ? void 0 : status.status) == null ? void 0 : _h.toString()) ?? "undefined"}`);
      }
      const limits = new LimitTracker(status.limit);
      const maConn = streamToMaConnection({
        stream: hopstr.unwrap().unwrap(),
        remoteAddr: ma,
        localAddr: relayAddr.encapsulate(`/p2p-circuit/p2p/${this.components.peerId.toString()}`),
        onDataRead: limits.onData,
        onDataWrite: limits.onData,
        log: stream.log.newScope("circuit-relay:connection")
      });
      const conn = await this.components.upgrader.upgradeOutbound(maConn, {
        ...options,
        limits: limits.getLimits()
      });
      conn.log("outbound relayed connection established to %p with limits %o, over connection %s", conn.remotePeer, status.limit ?? "none", relayConnection.id);
      return conn;
    } catch (err) {
      this.log.error("circuit relay dial to destination %p via relay %p failed - %e", destinationPeer, relayPeer, err);
      stream == null ? void 0 : stream.abort(err);
      throw err;
    }
  }
  /**
   * Create a listener
   */
  createListener(options) {
    return createListener({
      peerId: this.components.peerId,
      connectionManager: this.components.connectionManager,
      addressManager: this.components.addressManager,
      reservationStore: this.reservationStore,
      logger: this.components.logger
    });
  }
  /**
   * Filter check for all Multiaddrs that this transport can listen on
   */
  listenFilter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    return multiaddrs.filter((ma) => {
      return CircuitListen.exactMatch(ma) || CircuitSearch.exactMatch(ma);
    });
  }
  /**
   * Filter check for all Multiaddrs that this transport can dial
   */
  dialFilter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    return multiaddrs.filter((ma) => {
      return Circuit.exactMatch(ma);
    });
  }
  /**
   * An incoming STOP request means a remote peer wants to dial us via a relay
   */
  async onStop(stream, connection) {
    var _a3, _b3;
    const signal = this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);
    try {
      if (!this.reservationStore.hasReservation(connection.remotePeer)) {
        try {
          this.log("dialed via relay we did not have a reservation on, start listening on that relay address");
          await this.components.transportManager.listen([connection.remoteAddr.encapsulate("/p2p-circuit")]);
        } catch (err) {
          this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on - %e", err);
        }
      }
      const stopStream = pbStream(stream).pb(StopMessage);
      const request = await stopStream.read({
        signal
      });
      this.log("new circuit relay v2 stop stream from %p with type %s", connection.remotePeer, request.type);
      if ((request == null ? void 0 : request.type) === void 0) {
        this.log.error("type was missing from circuit v2 stop protocol request from %s", connection.remotePeer);
        await stopStream.write({ type: StopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, {
          signal
        });
        await stream.close({
          signal
        });
        return;
      }
      if (request.type !== StopMessage.Type.CONNECT) {
        this.log.error("invalid stop connect request via peer %p", connection.remotePeer);
        await stopStream.write({ type: StopMessage.Type.STATUS, status: Status.UNEXPECTED_MESSAGE }, {
          signal
        });
        await stream.close({
          signal
        });
        return;
      }
      if (!isValidStop(request)) {
        this.log.error("invalid stop connect request via peer %p", connection.remotePeer);
        await stopStream.write({ type: StopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, {
          signal
        });
        await stream.close({
          signal
        });
        return;
      }
      const remotePeerId = peerIdFromMultihash(decode(request.peer.id));
      if (await ((_b3 = (_a3 = this.components.connectionGater).denyInboundRelayedConnection) == null ? void 0 : _b3.call(_a3, connection.remotePeer, remotePeerId)) === true) {
        this.log.error("connection gater denied inbound relayed connection from %p", connection.remotePeer);
        await stopStream.write({ type: StopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, {
          signal
        });
        await stream.close({
          signal
        });
        return;
      }
      this.log.trace("sending success response to %p", connection.remotePeer);
      await stopStream.write({ type: StopMessage.Type.STATUS, status: Status.OK }, {
        signal
      });
      const limits = new LimitTracker(request.limit);
      const remoteAddr = connection.remoteAddr.encapsulate(`/p2p-circuit/p2p/${remotePeerId.toString()}`);
      const localAddr = this.components.addressManager.getAddresses()[0];
      const maConn = streamToMaConnection({
        stream: stopStream.unwrap().unwrap(),
        remoteAddr,
        localAddr,
        onDataRead: limits.onData,
        onDataWrite: limits.onData,
        log: stream.log.newScope("circuit-relay:connection")
      });
      await this.components.upgrader.upgradeInbound(maConn, {
        limits: limits.getLimits(),
        signal
      });
      maConn.log("inbound relayed connection established to %p with limits %o, over connection %s", remotePeerId, request.limit ?? "none", connection.id);
    } finally {
      signal == null ? void 0 : signal.clear();
    }
  }
};

// ../../node_modules/@libp2p/circuit-relay-v2/dist/src/index.js
function circuitRelayServer(init = {}) {
  return (components) => {
    return new CircuitRelayServer(components, init);
  };
}
function circuitRelayTransport(init = {}) {
  return (components) => {
    return new CircuitRelayTransport(components, init);
  };
}
export {
  RELAY_V2_HOP_CODEC,
  RELAY_V2_STOP_CODEC,
  circuitRelayServer,
  circuitRelayTransport
};
//# sourceMappingURL=@libp2p_circuit-relay-v2.js.map
