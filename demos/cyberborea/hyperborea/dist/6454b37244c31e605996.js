const ELEV_MAX=3e3,TERRAIN_THRESHOLDS={peak:2700,summit:2400,alpine:1800,boreal:450,beach:75};class SeededRandom{constructor(e){this.seed=e}next(){return this.seed=(9301*this.seed+49297)%233280,this.seed/233280}}class SimplexNoise{constructor(e){const t=new SeededRandom(e);this.perm=[];for(let e=0;e<256;e++)this.perm[e]=e;for(let e=255;e>0;e--){const s=Math.floor(t.next()*(e+1));[this.perm[e],this.perm[s]]=[this.perm[s],this.perm[e]]}this.perm=[...this.perm,...this.perm]}fade(e){return e*e*e*(e*(6*e-15)+10)}lerp(e,t,s){return t+e*(s-t)}grad(e,t,s){const r=3&e,i=r<2?t:s,o=r<2?s:t;return(1&r?-i:i)+(2&r?-o:o)}noise(e,t){const s=255&Math.floor(e),r=255&Math.floor(t);e-=Math.floor(e),t-=Math.floor(t);const i=this.fade(e),o=this.fade(t),h=this.perm[s]+r,a=this.perm[s+1]+r;return this.lerp(o,this.lerp(i,this.grad(this.perm[h],e,t),this.grad(this.perm[a],e-1,t)),this.lerp(i,this.grad(this.perm[h+1],e,t-1),this.grad(this.perm[a+1],e-1,t-1)))}octave(e,t,s,r,i){let o=0,h=1,a=1,n=0;for(let c=0;c<s;c++)o+=this.noise(e*h/i,t*h/i)*a,n+=a,a*=r,h*=2;return o/n}}class TerrainGenerator{constructor(e){this.heightNoise=new SimplexNoise(e),this.moistureNoise=new SimplexNoise(e+1),this.treeNoise=new SimplexNoise(e+2),this.structureNoise=new SimplexNoise(e+3),this.macroNoise=new SimplexNoise(e+4),this.warpNoise1=new SimplexNoise(e+5),this.warpNoise2=new SimplexNoise(e+6)}warpCoords(e,t,s=8e3,r=220){const i=Math.cos(.37),o=Math.sin(.37),h=e*i-t*o,a=e*o+t*i;return{x:e+this.warpNoise1.octave(h,a,2,.5,s)*r,z:t+this.warpNoise2.octave(h+1337,a+1337,2,.5,s)*r}}getHeight(e,t){const s=this.warpCoords(e,t,9e3,260),r=s.x,i=s.z;let o=6e3*this.macroNoise.octave(r,i,5,.5,16e3);return o+=600*this.heightNoise.octave(r,i,5,.5,4096),o+=60*this.heightNoise.octave(r,i,5,.5,1024),o}getMoisture(e,t){const s=this.warpCoords(e,t,6500,220),r=this.moistureNoise.octave(s.x,s.z,4,.45,3200),i=this.getHeight(e,t);return.9*r+.1*(1-Math.min(Math.max(i/6e3,0),1))}shouldPlaceTree(e,t,s,r){if(s<450||s>1800)return!1;const i=this.getHeight(e+3,t),o=this.getHeight(e-3,t);if(Math.abs(i-o)/6>.5)return!1;const h=r>.05?.55:.35,a=this.warpCoords(e,t,6e3,150);return this.treeNoise.noise(.18*a.x,.18*a.z)>1-h}shouldPlaceStructure(e,t,s){if(s<20||s>150)return!1;const r=this.getHeight(e+15,t),i=this.getHeight(e-15,t),o=this.getHeight(e,t+15),h=this.getHeight(e,t-15);if(Math.max(Math.abs(r-s),Math.abs(i-s),Math.abs(o-s),Math.abs(h-s))>20)return!1;const a=this.warpCoords(e,t,8e3,220);return this.structureNoise.noise(.01*a.x,.01*a.z)>.95}}export function computeTerrainChunk(e){const{seed:t,startX:s,startZ:r,lodStep:i,size:o,treeLevel:h,includeStructures:a}=e,n=Math.floor(o/i),c=new Array((n+1)*(n+1)),l=new Array((n+1)*(n+1)),u=new Array((n+1)*(n+1)),p=new TerrainGenerator(t);let m=-1/0;const g=TERRAIN_THRESHOLDS.peak,d=TERRAIN_THRESHOLDS.summit,N=TERRAIN_THRESHOLDS.alpine,S=TERRAIN_THRESHOLDS.boreal,M=TERRAIN_THRESHOLDS.beach;for(let e=0;e<=n;e++)for(let t=0;t<=n;t++){const o=s+t*i,h=r+e*i,a=e*(n+1)+t,f=p.getHeight(o,h),x=p.getMoisture(o,h);c[a]=f,l[a]=x,m=Math.max(m,f);const H=.03*(Math.max(0,Math.min(1,.5*(x+1)))-.5)*3e3;let w="boreal";w=f<M+H?"water":f>=g+H?"peak":f>=d+H?"summit":f>=N+H?"alpine":f>=S+H?"boreal":"beach",u[a]={type:w,height:f,moisture:x}}const f=[];if(h){const e=Math.max(16,2*i);for(let t=0;t<o;t+=e)for(let i=0;i<o;i+=e){const e=s+i,o=r+t,a=p.getHeight(e,o),n=p.getMoisture(e,o);if(p.shouldPlaceTree(e,o,a,n)){const t=43758.5453*Math.sin(12.9898*e+78.233*o),s=8+Math.abs(t)%1*6,r=1.5+Math.abs(7*t)%1*1;f.push({x:e,y:a+.65*s,z:o,radius:r,height:s,level:h})}}}const x=[];if(a){const e=s+o/2,t=r+o/2,i=p.getHeight(e,t);p.shouldPlaceStructure(e,t,i)&&x.push({x:e,y:i,z:t})}return{seed:t,startX:s,startZ:r,size:o,lodStep:i,gridSize:n,heights:c,moisture:l,terrainTypes:u,maxHeight:m,trees:f,structures:x}}